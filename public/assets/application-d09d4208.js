(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod3) => function __require() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));

  // node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: typeof console !== "undefined" ? console : void 0,
        WebSocket: typeof WebSocket !== "undefined" ? WebSocket : void 0
      };
    }
  });

  // node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = () => (/* @__PURE__ */ new Date()).getTime();
      secondsSince = (time) => (now() - time) / 1e3;
      ConnectionMonitor = class {
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordMessage() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        // Private
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(
            () => {
              this.reconnectIfStale();
              this.poll();
            },
            this.getPollInterval()
          );
        }
        getPollInterval() {
          const { staleThreshold, reconnectionBackoffRate } = this.constructor;
          const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
          const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
          const jitter = jitterMax * Math.random();
          return staleThreshold * 1e3 * backoff * (1 + jitter);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        get refreshedAt() {
          return this.pingedAt ? this.pingedAt : this.startedAt;
        }
        connectionIsStale() {
          return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(
              () => {
                if (this.connectionIsStale() || !this.connection.isOpen()) {
                  logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                  this.connection.reopen();
                }
              },
              200
            );
          }
        }
      };
      ConnectionMonitor.staleThreshold = 6;
      ConnectionMonitor.reconnectionBackoffRate = 0.15;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart",
          "remote": "remote"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        constructor(consumer3) {
          this.open = this.open.bind(this);
          this.consumer = consumer3;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data2) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data2));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            const socketProtocols = [...protocols, ...this.consumer.subprotocols || []];
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, socketProtocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isOpen()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error4) {
              logger_default.log("Failed to reopen WebSocket", error4);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        triedToReconnect() {
          return this.monitor.reconnectAttempts > 0;
        }
        // Private
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          this.monitor.recordMessage();
          switch (type) {
            case message_types.welcome:
              if (this.triedToReconnect()) {
                this.reconnectAttempted = true;
              }
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return null;
            case message_types.confirmation:
              this.subscriptions.confirmSubscription(identifier);
              if (this.reconnectAttempted) {
                this.reconnectAttempted = false;
                return this.subscriptions.notify(identifier, "connected", { reconnected: true });
              } else {
                return this.subscriptions.notify(identifier, "connected", { reconnected: false });
              }
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // node_modules/@rails/actioncable/src/subscription.js
  var extend, Subscription;
  var init_subscription = __esm({
    "node_modules/@rails/actioncable/src/subscription.js"() {
      extend = function(object, properties) {
        if (properties != null) {
          for (let key in properties) {
            const value2 = properties[key];
            object[key] = value2;
          }
        }
        return object;
      };
      Subscription = class {
        constructor(consumer3, params = {}, mixin) {
          this.consumer = consumer3;
          this.identifier = JSON.stringify(params);
          extend(this, mixin);
        }
        // Perform a channel action with the optional data passed as an attribute
        perform(action, data2 = {}) {
          data2.action = action;
          return this.send(data2);
        }
        send(data2) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data2) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/subscription_guarantor.js
  var SubscriptionGuarantor, subscription_guarantor_default;
  var init_subscription_guarantor = __esm({
    "node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
      init_logger();
      SubscriptionGuarantor = class {
        constructor(subscriptions) {
          this.subscriptions = subscriptions;
          this.pendingSubscriptions = [];
        }
        guarantee(subscription) {
          if (this.pendingSubscriptions.indexOf(subscription) == -1) {
            logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
            this.pendingSubscriptions.push(subscription);
          } else {
            logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
          }
          this.startGuaranteeing();
        }
        forget(subscription) {
          logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
          this.pendingSubscriptions = this.pendingSubscriptions.filter((s3) => s3 !== subscription);
        }
        startGuaranteeing() {
          this.stopGuaranteeing();
          this.retrySubscribing();
        }
        stopGuaranteeing() {
          clearTimeout(this.retryTimeout);
        }
        retrySubscribing() {
          this.retryTimeout = setTimeout(
            () => {
              if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
                this.pendingSubscriptions.map((subscription) => {
                  logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                  this.subscriptions.subscribe(subscription);
                });
              }
            },
            500
          );
        }
      };
      subscription_guarantor_default = SubscriptionGuarantor;
    }
  });

  // node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      init_subscription_guarantor();
      init_logger();
      Subscriptions = class {
        constructor(consumer3) {
          this.consumer = consumer3;
          this.guarantor = new subscription_guarantor_default(this);
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        // Private
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.subscribe(subscription);
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.guarantor.forget(subscription);
          this.subscriptions = this.subscriptions.filter((s3) => s3 !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s3) => s3.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.subscribe(subscription));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        subscribe(subscription) {
          if (this.sendCommand(subscription, "subscribe")) {
            this.guarantor.guarantee(subscription);
          }
        }
        confirmSubscription(identifier) {
          logger_default.log(`Subscription confirmed ${identifier}`);
          this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
        }
        sendCommand(subscription, command) {
          const { identifier } = subscription;
          return this.consumer.send({ command, identifier });
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a3 = document.createElement("a");
      a3.href = url;
      a3.href = a3.href;
      a3.protocol = a3.protocol.replace("http", "ws");
      return a3.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
          this.subprotocols = [];
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data2) {
          return this.connection.send(data2);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
        addSubProtocol(subprotocol) {
          this.subprotocols = [...this.subprotocols, subprotocol];
        }
      };
    }
  });

  // node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    SubscriptionGuarantor: () => subscription_guarantor_default,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name2) {
    const element = document.head.querySelector(`meta[name='action-cable-${name2}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_subscription_guarantor();
      init_adapters();
      init_logger();
    }
  });

  // node_modules/choices.js/public/assets/scripts/choices.js
  var require_choices = __commonJS({
    "node_modules/choices.js/public/assets/scripts/choices.js"(exports, module) {
      (function webpackUniversalModuleDefinition(root2, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define([], factory);
        else if (typeof exports === "object")
          exports["Choices"] = factory();
        else
          root2["Choices"] = factory();
      })(window, function() {
        return (
          /******/
          function() {
            "use strict";
            var __webpack_modules__ = {
              /***/
              282: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.clearChoices = exports2.activateChoices = exports2.filterChoices = exports2.addChoice = void 0;
                  var constants_1 = __webpack_require__2(883);
                  var addChoice = function(_a) {
                    var value2 = _a.value, label = _a.label, id5 = _a.id, groupId = _a.groupId, disabled = _a.disabled, elementId = _a.elementId, customProperties = _a.customProperties, placeholder = _a.placeholder, keyCode = _a.keyCode;
                    return {
                      type: constants_1.ACTION_TYPES.ADD_CHOICE,
                      value: value2,
                      label,
                      id: id5,
                      groupId,
                      disabled,
                      elementId,
                      customProperties,
                      placeholder,
                      keyCode
                    };
                  };
                  exports2.addChoice = addChoice;
                  var filterChoices = function(results) {
                    return {
                      type: constants_1.ACTION_TYPES.FILTER_CHOICES,
                      results
                    };
                  };
                  exports2.filterChoices = filterChoices;
                  var activateChoices = function(active) {
                    if (active === void 0) {
                      active = true;
                    }
                    return {
                      type: constants_1.ACTION_TYPES.ACTIVATE_CHOICES,
                      active
                    };
                  };
                  exports2.activateChoices = activateChoices;
                  var clearChoices = function() {
                    return {
                      type: constants_1.ACTION_TYPES.CLEAR_CHOICES
                    };
                  };
                  exports2.clearChoices = clearChoices;
                }
              ),
              /***/
              783: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.addGroup = void 0;
                  var constants_1 = __webpack_require__2(883);
                  var addGroup = function(_a) {
                    var value2 = _a.value, id5 = _a.id, active = _a.active, disabled = _a.disabled;
                    return {
                      type: constants_1.ACTION_TYPES.ADD_GROUP,
                      value: value2,
                      id: id5,
                      active,
                      disabled
                    };
                  };
                  exports2.addGroup = addGroup;
                }
              ),
              /***/
              464: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.highlightItem = exports2.removeItem = exports2.addItem = void 0;
                  var constants_1 = __webpack_require__2(883);
                  var addItem = function(_a) {
                    var value2 = _a.value, label = _a.label, id5 = _a.id, choiceId = _a.choiceId, groupId = _a.groupId, customProperties = _a.customProperties, placeholder = _a.placeholder, keyCode = _a.keyCode;
                    return {
                      type: constants_1.ACTION_TYPES.ADD_ITEM,
                      value: value2,
                      label,
                      id: id5,
                      choiceId,
                      groupId,
                      customProperties,
                      placeholder,
                      keyCode
                    };
                  };
                  exports2.addItem = addItem;
                  var removeItem = function(id5, choiceId) {
                    return {
                      type: constants_1.ACTION_TYPES.REMOVE_ITEM,
                      id: id5,
                      choiceId
                    };
                  };
                  exports2.removeItem = removeItem;
                  var highlightItem = function(id5, highlighted) {
                    return {
                      type: constants_1.ACTION_TYPES.HIGHLIGHT_ITEM,
                      id: id5,
                      highlighted
                    };
                  };
                  exports2.highlightItem = highlightItem;
                }
              ),
              /***/
              137: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.setIsLoading = exports2.resetTo = exports2.clearAll = void 0;
                  var constants_1 = __webpack_require__2(883);
                  var clearAll = function() {
                    return {
                      type: constants_1.ACTION_TYPES.CLEAR_ALL
                    };
                  };
                  exports2.clearAll = clearAll;
                  var resetTo = function(state) {
                    return {
                      type: constants_1.ACTION_TYPES.RESET_TO,
                      state
                    };
                  };
                  exports2.resetTo = resetTo;
                  var setIsLoading = function(isLoading) {
                    return {
                      type: constants_1.ACTION_TYPES.SET_IS_LOADING,
                      isLoading
                    };
                  };
                  exports2.setIsLoading = setIsLoading;
                }
              ),
              /***/
              373: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __spreadArray2 = this && this.__spreadArray || function(to, from, pack3) {
                    if (pack3 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                  };
                  var __importDefault = this && this.__importDefault || function(mod3) {
                    return mod3 && mod3.__esModule ? mod3 : {
                      "default": mod3
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var deepmerge_1 = __importDefault(__webpack_require__2(996));
                  var fuse_js_1 = __importDefault(__webpack_require__2(221));
                  var choices_1 = __webpack_require__2(282);
                  var groups_1 = __webpack_require__2(783);
                  var items_1 = __webpack_require__2(464);
                  var misc_1 = __webpack_require__2(137);
                  var components_1 = __webpack_require__2(520);
                  var constants_1 = __webpack_require__2(883);
                  var defaults_1 = __webpack_require__2(789);
                  var utils_1 = __webpack_require__2(799);
                  var reducers_1 = __webpack_require__2(655);
                  var store_1 = __importDefault(__webpack_require__2(744));
                  var templates_1 = __importDefault(__webpack_require__2(686));
                  var IS_IE11 = "-ms-scroll-limit" in document.documentElement.style && "-ms-ime-align" in document.documentElement.style;
                  var USER_DEFAULTS = {};
                  var Choices2 = (
                    /** @class */
                    function() {
                      function Choices3(element, userConfig) {
                        if (element === void 0) {
                          element = "[data-choice]";
                        }
                        if (userConfig === void 0) {
                          userConfig = {};
                        }
                        var _this = this;
                        if (userConfig.allowHTML === void 0) {
                          console.warn("Deprecation warning: allowHTML will default to false in a future release. To render HTML in Choices, you will need to set it to true. Setting allowHTML will suppress this message.");
                        }
                        this.config = deepmerge_1.default.all(
                          [defaults_1.DEFAULT_CONFIG, Choices3.defaults.options, userConfig],
                          // When merging array configs, replace with a copy of the userConfig array,
                          // instead of concatenating with the default array
                          {
                            arrayMerge: function(_2, sourceArray) {
                              return __spreadArray2([], sourceArray, true);
                            }
                          }
                        );
                        var invalidConfigOptions = (0, utils_1.diff)(this.config, defaults_1.DEFAULT_CONFIG);
                        if (invalidConfigOptions.length) {
                          console.warn("Unknown config option(s) passed", invalidConfigOptions.join(", "));
                        }
                        var passedElement = typeof element === "string" ? document.querySelector(element) : element;
                        if (!(passedElement instanceof HTMLInputElement || passedElement instanceof HTMLSelectElement)) {
                          throw TypeError("Expected one of the following types text|select-one|select-multiple");
                        }
                        this._isTextElement = passedElement.type === constants_1.TEXT_TYPE;
                        this._isSelectOneElement = passedElement.type === constants_1.SELECT_ONE_TYPE;
                        this._isSelectMultipleElement = passedElement.type === constants_1.SELECT_MULTIPLE_TYPE;
                        this._isSelectElement = this._isSelectOneElement || this._isSelectMultipleElement;
                        this.config.searchEnabled = this._isSelectMultipleElement || this.config.searchEnabled;
                        if (!["auto", "always"].includes("".concat(this.config.renderSelectedChoices))) {
                          this.config.renderSelectedChoices = "auto";
                        }
                        if (userConfig.addItemFilter && typeof userConfig.addItemFilter !== "function") {
                          var re2 = userConfig.addItemFilter instanceof RegExp ? userConfig.addItemFilter : new RegExp(userConfig.addItemFilter);
                          this.config.addItemFilter = re2.test.bind(re2);
                        }
                        if (this._isTextElement) {
                          this.passedElement = new components_1.WrappedInput({
                            element: passedElement,
                            classNames: this.config.classNames,
                            delimiter: this.config.delimiter
                          });
                        } else {
                          this.passedElement = new components_1.WrappedSelect({
                            element: passedElement,
                            classNames: this.config.classNames,
                            template: function(data2) {
                              return _this._templates.option(data2);
                            }
                          });
                        }
                        this.initialised = false;
                        this._store = new store_1.default();
                        this._initialState = reducers_1.defaultState;
                        this._currentState = reducers_1.defaultState;
                        this._prevState = reducers_1.defaultState;
                        this._currentValue = "";
                        this._canSearch = !!this.config.searchEnabled;
                        this._isScrollingOnIe = false;
                        this._highlightPosition = 0;
                        this._wasTap = true;
                        this._placeholderValue = this._generatePlaceholderValue();
                        this._baseId = (0, utils_1.generateId)(this.passedElement.element, "choices-");
                        this._direction = this.passedElement.dir;
                        if (!this._direction) {
                          var elementDirection = window.getComputedStyle(this.passedElement.element).direction;
                          var documentDirection = window.getComputedStyle(document.documentElement).direction;
                          if (elementDirection !== documentDirection) {
                            this._direction = elementDirection;
                          }
                        }
                        this._idNames = {
                          itemChoice: "item-choice"
                        };
                        if (this._isSelectElement) {
                          this._presetGroups = this.passedElement.optionGroups;
                          this._presetOptions = this.passedElement.options;
                        }
                        this._presetChoices = this.config.choices;
                        this._presetItems = this.config.items;
                        if (this.passedElement.value && this._isTextElement) {
                          var splitValues = this.passedElement.value.split(this.config.delimiter);
                          this._presetItems = this._presetItems.concat(splitValues);
                        }
                        if (this.passedElement.options) {
                          this.passedElement.options.forEach(function(option2) {
                            _this._presetChoices.push({
                              value: option2.value,
                              label: option2.innerHTML,
                              selected: !!option2.selected,
                              disabled: option2.disabled || option2.parentNode.disabled,
                              placeholder: option2.value === "" || option2.hasAttribute("placeholder"),
                              customProperties: (0, utils_1.parseCustomProperties)(option2.dataset.customProperties)
                            });
                          });
                        }
                        this._render = this._render.bind(this);
                        this._onFocus = this._onFocus.bind(this);
                        this._onBlur = this._onBlur.bind(this);
                        this._onKeyUp = this._onKeyUp.bind(this);
                        this._onKeyDown = this._onKeyDown.bind(this);
                        this._onClick = this._onClick.bind(this);
                        this._onTouchMove = this._onTouchMove.bind(this);
                        this._onTouchEnd = this._onTouchEnd.bind(this);
                        this._onMouseDown = this._onMouseDown.bind(this);
                        this._onMouseOver = this._onMouseOver.bind(this);
                        this._onFormReset = this._onFormReset.bind(this);
                        this._onSelectKey = this._onSelectKey.bind(this);
                        this._onEnterKey = this._onEnterKey.bind(this);
                        this._onEscapeKey = this._onEscapeKey.bind(this);
                        this._onDirectionKey = this._onDirectionKey.bind(this);
                        this._onDeleteKey = this._onDeleteKey.bind(this);
                        if (this.passedElement.isActive) {
                          if (!this.config.silent) {
                            console.warn("Trying to initialise Choices on element already initialised", {
                              element
                            });
                          }
                          this.initialised = true;
                          return;
                        }
                        this.init();
                      }
                      Object.defineProperty(Choices3, "defaults", {
                        get: function() {
                          return Object.preventExtensions({
                            get options() {
                              return USER_DEFAULTS;
                            },
                            get templates() {
                              return templates_1.default;
                            }
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Choices3.prototype.init = function() {
                        if (this.initialised) {
                          return;
                        }
                        this._createTemplates();
                        this._createElements();
                        this._createStructure();
                        this._store.subscribe(this._render);
                        this._render();
                        this._addEventListeners();
                        var shouldDisable = !this.config.addItems || this.passedElement.element.hasAttribute("disabled");
                        if (shouldDisable) {
                          this.disable();
                        }
                        this.initialised = true;
                        var callbackOnInit = this.config.callbackOnInit;
                        if (callbackOnInit && typeof callbackOnInit === "function") {
                          callbackOnInit.call(this);
                        }
                      };
                      Choices3.prototype.destroy = function() {
                        if (!this.initialised) {
                          return;
                        }
                        this._removeEventListeners();
                        this.passedElement.reveal();
                        this.containerOuter.unwrap(this.passedElement.element);
                        this.clearStore();
                        if (this._isSelectElement) {
                          this.passedElement.options = this._presetOptions;
                        }
                        this._templates = templates_1.default;
                        this.initialised = false;
                      };
                      Choices3.prototype.enable = function() {
                        if (this.passedElement.isDisabled) {
                          this.passedElement.enable();
                        }
                        if (this.containerOuter.isDisabled) {
                          this._addEventListeners();
                          this.input.enable();
                          this.containerOuter.enable();
                        }
                        return this;
                      };
                      Choices3.prototype.disable = function() {
                        if (!this.passedElement.isDisabled) {
                          this.passedElement.disable();
                        }
                        if (!this.containerOuter.isDisabled) {
                          this._removeEventListeners();
                          this.input.disable();
                          this.containerOuter.disable();
                        }
                        return this;
                      };
                      Choices3.prototype.highlightItem = function(item, runEvent) {
                        if (runEvent === void 0) {
                          runEvent = true;
                        }
                        if (!item || !item.id) {
                          return this;
                        }
                        var id5 = item.id, _a = item.groupId, groupId = _a === void 0 ? -1 : _a, _b = item.value, value2 = _b === void 0 ? "" : _b, _c = item.label, label = _c === void 0 ? "" : _c;
                        var group3 = groupId >= 0 ? this._store.getGroupById(groupId) : null;
                        this._store.dispatch((0, items_1.highlightItem)(id5, true));
                        if (runEvent) {
                          this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
                            id: id5,
                            value: value2,
                            label,
                            groupValue: group3 && group3.value ? group3.value : null
                          });
                        }
                        return this;
                      };
                      Choices3.prototype.unhighlightItem = function(item) {
                        if (!item || !item.id) {
                          return this;
                        }
                        var id5 = item.id, _a = item.groupId, groupId = _a === void 0 ? -1 : _a, _b = item.value, value2 = _b === void 0 ? "" : _b, _c = item.label, label = _c === void 0 ? "" : _c;
                        var group3 = groupId >= 0 ? this._store.getGroupById(groupId) : null;
                        this._store.dispatch((0, items_1.highlightItem)(id5, false));
                        this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
                          id: id5,
                          value: value2,
                          label,
                          groupValue: group3 && group3.value ? group3.value : null
                        });
                        return this;
                      };
                      Choices3.prototype.highlightAll = function() {
                        var _this = this;
                        this._store.items.forEach(function(item) {
                          return _this.highlightItem(item);
                        });
                        return this;
                      };
                      Choices3.prototype.unhighlightAll = function() {
                        var _this = this;
                        this._store.items.forEach(function(item) {
                          return _this.unhighlightItem(item);
                        });
                        return this;
                      };
                      Choices3.prototype.removeActiveItemsByValue = function(value2) {
                        var _this = this;
                        this._store.activeItems.filter(function(item) {
                          return item.value === value2;
                        }).forEach(function(item) {
                          return _this._removeItem(item);
                        });
                        return this;
                      };
                      Choices3.prototype.removeActiveItems = function(excludedId) {
                        var _this = this;
                        this._store.activeItems.filter(function(_a) {
                          var id5 = _a.id;
                          return id5 !== excludedId;
                        }).forEach(function(item) {
                          return _this._removeItem(item);
                        });
                        return this;
                      };
                      Choices3.prototype.removeHighlightedItems = function(runEvent) {
                        var _this = this;
                        if (runEvent === void 0) {
                          runEvent = false;
                        }
                        this._store.highlightedActiveItems.forEach(function(item) {
                          _this._removeItem(item);
                          if (runEvent) {
                            _this._triggerChange(item.value);
                          }
                        });
                        return this;
                      };
                      Choices3.prototype.showDropdown = function(preventInputFocus) {
                        var _this = this;
                        if (this.dropdown.isActive) {
                          return this;
                        }
                        requestAnimationFrame(function() {
                          _this.dropdown.show();
                          _this.containerOuter.open(_this.dropdown.distanceFromTopWindow);
                          if (!preventInputFocus && _this._canSearch) {
                            _this.input.focus();
                          }
                          _this.passedElement.triggerEvent(constants_1.EVENTS.showDropdown, {});
                        });
                        return this;
                      };
                      Choices3.prototype.hideDropdown = function(preventInputBlur) {
                        var _this = this;
                        if (!this.dropdown.isActive) {
                          return this;
                        }
                        requestAnimationFrame(function() {
                          _this.dropdown.hide();
                          _this.containerOuter.close();
                          if (!preventInputBlur && _this._canSearch) {
                            _this.input.removeActiveDescendant();
                            _this.input.blur();
                          }
                          _this.passedElement.triggerEvent(constants_1.EVENTS.hideDropdown, {});
                        });
                        return this;
                      };
                      Choices3.prototype.getValue = function(valueOnly) {
                        if (valueOnly === void 0) {
                          valueOnly = false;
                        }
                        var values = this._store.activeItems.reduce(function(selectedItems, item) {
                          var itemValue = valueOnly ? item.value : item;
                          selectedItems.push(itemValue);
                          return selectedItems;
                        }, []);
                        return this._isSelectOneElement ? values[0] : values;
                      };
                      Choices3.prototype.setValue = function(items) {
                        var _this = this;
                        if (!this.initialised) {
                          return this;
                        }
                        items.forEach(function(value2) {
                          return _this._setChoiceOrItem(value2);
                        });
                        return this;
                      };
                      Choices3.prototype.setChoiceByValue = function(value2) {
                        var _this = this;
                        if (!this.initialised || this._isTextElement) {
                          return this;
                        }
                        var choiceValue = Array.isArray(value2) ? value2 : [value2];
                        choiceValue.forEach(function(val) {
                          return _this._findAndSelectChoiceByValue(val);
                        });
                        return this;
                      };
                      Choices3.prototype.setChoices = function(choicesArrayOrFetcher, value2, label, replaceChoices) {
                        var _this = this;
                        if (choicesArrayOrFetcher === void 0) {
                          choicesArrayOrFetcher = [];
                        }
                        if (value2 === void 0) {
                          value2 = "value";
                        }
                        if (label === void 0) {
                          label = "label";
                        }
                        if (replaceChoices === void 0) {
                          replaceChoices = false;
                        }
                        if (!this.initialised) {
                          throw new ReferenceError("setChoices was called on a non-initialized instance of Choices");
                        }
                        if (!this._isSelectElement) {
                          throw new TypeError("setChoices can't be used with INPUT based Choices");
                        }
                        if (typeof value2 !== "string" || !value2) {
                          throw new TypeError("value parameter must be a name of 'value' field in passed objects");
                        }
                        if (replaceChoices) {
                          this.clearChoices();
                        }
                        if (typeof choicesArrayOrFetcher === "function") {
                          var fetcher_1 = choicesArrayOrFetcher(this);
                          if (typeof Promise === "function" && fetcher_1 instanceof Promise) {
                            return new Promise(function(resolve) {
                              return requestAnimationFrame(resolve);
                            }).then(function() {
                              return _this._handleLoadingState(true);
                            }).then(function() {
                              return fetcher_1;
                            }).then(function(data2) {
                              return _this.setChoices(data2, value2, label, replaceChoices);
                            }).catch(function(err) {
                              if (!_this.config.silent) {
                                console.error(err);
                              }
                            }).then(function() {
                              return _this._handleLoadingState(false);
                            }).then(function() {
                              return _this;
                            });
                          }
                          if (!Array.isArray(fetcher_1)) {
                            throw new TypeError(".setChoices first argument function must return either array of choices or Promise, got: ".concat(typeof fetcher_1));
                          }
                          return this.setChoices(fetcher_1, value2, label, false);
                        }
                        if (!Array.isArray(choicesArrayOrFetcher)) {
                          throw new TypeError(".setChoices must be called either with array of choices with a function resulting into Promise of array of choices");
                        }
                        this.containerOuter.removeLoadingState();
                        this._startLoading();
                        choicesArrayOrFetcher.forEach(function(groupOrChoice) {
                          if (groupOrChoice.choices) {
                            _this._addGroup({
                              id: groupOrChoice.id ? parseInt("".concat(groupOrChoice.id), 10) : null,
                              group: groupOrChoice,
                              valueKey: value2,
                              labelKey: label
                            });
                          } else {
                            var choice = groupOrChoice;
                            _this._addChoice({
                              value: choice[value2],
                              label: choice[label],
                              isSelected: !!choice.selected,
                              isDisabled: !!choice.disabled,
                              placeholder: !!choice.placeholder,
                              customProperties: choice.customProperties
                            });
                          }
                        });
                        this._stopLoading();
                        return this;
                      };
                      Choices3.prototype.clearChoices = function() {
                        this._store.dispatch((0, choices_1.clearChoices)());
                        return this;
                      };
                      Choices3.prototype.clearStore = function() {
                        this._store.dispatch((0, misc_1.clearAll)());
                        return this;
                      };
                      Choices3.prototype.clearInput = function() {
                        var shouldSetInputWidth = !this._isSelectOneElement;
                        this.input.clear(shouldSetInputWidth);
                        if (!this._isTextElement && this._canSearch) {
                          this._isSearching = false;
                          this._store.dispatch((0, choices_1.activateChoices)(true));
                        }
                        return this;
                      };
                      Choices3.prototype._render = function() {
                        if (this._store.isLoading()) {
                          return;
                        }
                        this._currentState = this._store.state;
                        var stateChanged = this._currentState.choices !== this._prevState.choices || this._currentState.groups !== this._prevState.groups || this._currentState.items !== this._prevState.items;
                        var shouldRenderChoices = this._isSelectElement;
                        var shouldRenderItems = this._currentState.items !== this._prevState.items;
                        if (!stateChanged) {
                          return;
                        }
                        if (shouldRenderChoices) {
                          this._renderChoices();
                        }
                        if (shouldRenderItems) {
                          this._renderItems();
                        }
                        this._prevState = this._currentState;
                      };
                      Choices3.prototype._renderChoices = function() {
                        var _this = this;
                        var _a = this._store, activeGroups = _a.activeGroups, activeChoices = _a.activeChoices;
                        var choiceListFragment = document.createDocumentFragment();
                        this.choiceList.clear();
                        if (this.config.resetScrollPosition) {
                          requestAnimationFrame(function() {
                            return _this.choiceList.scrollToTop();
                          });
                        }
                        if (activeGroups.length >= 1 && !this._isSearching) {
                          var activePlaceholders = activeChoices.filter(function(activeChoice) {
                            return activeChoice.placeholder === true && activeChoice.groupId === -1;
                          });
                          if (activePlaceholders.length >= 1) {
                            choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);
                          }
                          choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);
                        } else if (activeChoices.length >= 1) {
                          choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);
                        }
                        if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {
                          var activeItems = this._store.activeItems;
                          var canAddItem = this._canAddItem(activeItems, this.input.value);
                          if (canAddItem.response) {
                            this.choiceList.append(choiceListFragment);
                            this._highlightChoice();
                          } else {
                            var notice = this._getTemplate("notice", canAddItem.notice);
                            this.choiceList.append(notice);
                          }
                        } else {
                          var dropdownItem = void 0;
                          var notice = void 0;
                          if (this._isSearching) {
                            notice = typeof this.config.noResultsText === "function" ? this.config.noResultsText() : this.config.noResultsText;
                            dropdownItem = this._getTemplate("notice", notice, "no-results");
                          } else {
                            notice = typeof this.config.noChoicesText === "function" ? this.config.noChoicesText() : this.config.noChoicesText;
                            dropdownItem = this._getTemplate("notice", notice, "no-choices");
                          }
                          this.choiceList.append(dropdownItem);
                        }
                      };
                      Choices3.prototype._renderItems = function() {
                        var activeItems = this._store.activeItems || [];
                        this.itemList.clear();
                        var itemListFragment = this._createItemsFragment(activeItems);
                        if (itemListFragment.childNodes) {
                          this.itemList.append(itemListFragment);
                        }
                      };
                      Choices3.prototype._createGroupsFragment = function(groups2, choices, fragment) {
                        var _this = this;
                        if (fragment === void 0) {
                          fragment = document.createDocumentFragment();
                        }
                        var getGroupChoices = function(group3) {
                          return choices.filter(function(choice) {
                            if (_this._isSelectOneElement) {
                              return choice.groupId === group3.id;
                            }
                            return choice.groupId === group3.id && (_this.config.renderSelectedChoices === "always" || !choice.selected);
                          });
                        };
                        if (this.config.shouldSort) {
                          groups2.sort(this.config.sorter);
                        }
                        groups2.forEach(function(group3) {
                          var groupChoices = getGroupChoices(group3);
                          if (groupChoices.length >= 1) {
                            var dropdownGroup = _this._getTemplate("choiceGroup", group3);
                            fragment.appendChild(dropdownGroup);
                            _this._createChoicesFragment(groupChoices, fragment, true);
                          }
                        });
                        return fragment;
                      };
                      Choices3.prototype._createChoicesFragment = function(choices, fragment, withinGroup) {
                        var _this = this;
                        if (fragment === void 0) {
                          fragment = document.createDocumentFragment();
                        }
                        if (withinGroup === void 0) {
                          withinGroup = false;
                        }
                        var _a = this.config, renderSelectedChoices = _a.renderSelectedChoices, searchResultLimit = _a.searchResultLimit, renderChoiceLimit = _a.renderChoiceLimit;
                        var filter2 = this._isSearching ? utils_1.sortByScore : this.config.sorter;
                        var appendChoice = function(choice) {
                          var shouldRender = renderSelectedChoices === "auto" ? _this._isSelectOneElement || !choice.selected : true;
                          if (shouldRender) {
                            var dropdownItem = _this._getTemplate("choice", choice, _this.config.itemSelectText);
                            fragment.appendChild(dropdownItem);
                          }
                        };
                        var rendererableChoices = choices;
                        if (renderSelectedChoices === "auto" && !this._isSelectOneElement) {
                          rendererableChoices = choices.filter(function(choice) {
                            return !choice.selected;
                          });
                        }
                        var _b = rendererableChoices.reduce(function(acc, choice) {
                          if (choice.placeholder) {
                            acc.placeholderChoices.push(choice);
                          } else {
                            acc.normalChoices.push(choice);
                          }
                          return acc;
                        }, {
                          placeholderChoices: [],
                          normalChoices: []
                        }), placeholderChoices = _b.placeholderChoices, normalChoices = _b.normalChoices;
                        if (this.config.shouldSort || this._isSearching) {
                          normalChoices.sort(filter2);
                        }
                        var choiceLimit = rendererableChoices.length;
                        var sortedChoices = this._isSelectOneElement ? __spreadArray2(__spreadArray2([], placeholderChoices, true), normalChoices, true) : normalChoices;
                        if (this._isSearching) {
                          choiceLimit = searchResultLimit;
                        } else if (renderChoiceLimit && renderChoiceLimit > 0 && !withinGroup) {
                          choiceLimit = renderChoiceLimit;
                        }
                        for (var i = 0; i < choiceLimit; i += 1) {
                          if (sortedChoices[i]) {
                            appendChoice(sortedChoices[i]);
                          }
                        }
                        return fragment;
                      };
                      Choices3.prototype._createItemsFragment = function(items, fragment) {
                        var _this = this;
                        if (fragment === void 0) {
                          fragment = document.createDocumentFragment();
                        }
                        var _a = this.config, shouldSortItems = _a.shouldSortItems, sorter = _a.sorter, removeItemButton = _a.removeItemButton;
                        if (shouldSortItems && !this._isSelectOneElement) {
                          items.sort(sorter);
                        }
                        if (this._isTextElement) {
                          this.passedElement.value = items.map(function(_a2) {
                            var value2 = _a2.value;
                            return value2;
                          }).join(this.config.delimiter);
                        } else {
                          this.passedElement.options = items;
                        }
                        var addItemToFragment = function(item) {
                          var listItem = _this._getTemplate("item", item, removeItemButton);
                          fragment.appendChild(listItem);
                        };
                        items.forEach(addItemToFragment);
                        return fragment;
                      };
                      Choices3.prototype._triggerChange = function(value2) {
                        if (value2 === void 0 || value2 === null) {
                          return;
                        }
                        this.passedElement.triggerEvent(constants_1.EVENTS.change, {
                          value: value2
                        });
                      };
                      Choices3.prototype._selectPlaceholderChoice = function(placeholderChoice) {
                        this._addItem({
                          value: placeholderChoice.value,
                          label: placeholderChoice.label,
                          choiceId: placeholderChoice.id,
                          groupId: placeholderChoice.groupId,
                          placeholder: placeholderChoice.placeholder
                        });
                        this._triggerChange(placeholderChoice.value);
                      };
                      Choices3.prototype._handleButtonAction = function(activeItems, element) {
                        if (!activeItems || !element || !this.config.removeItems || !this.config.removeItemButton) {
                          return;
                        }
                        var itemId = element.parentNode && element.parentNode.dataset.id;
                        var itemToRemove = itemId && activeItems.find(function(item) {
                          return item.id === parseInt(itemId, 10);
                        });
                        if (!itemToRemove) {
                          return;
                        }
                        this._removeItem(itemToRemove);
                        this._triggerChange(itemToRemove.value);
                        if (this._isSelectOneElement && this._store.placeholderChoice) {
                          this._selectPlaceholderChoice(this._store.placeholderChoice);
                        }
                      };
                      Choices3.prototype._handleItemAction = function(activeItems, element, hasShiftKey) {
                        var _this = this;
                        if (hasShiftKey === void 0) {
                          hasShiftKey = false;
                        }
                        if (!activeItems || !element || !this.config.removeItems || this._isSelectOneElement) {
                          return;
                        }
                        var passedId = element.dataset.id;
                        activeItems.forEach(function(item) {
                          if (item.id === parseInt("".concat(passedId), 10) && !item.highlighted) {
                            _this.highlightItem(item);
                          } else if (!hasShiftKey && item.highlighted) {
                            _this.unhighlightItem(item);
                          }
                        });
                        this.input.focus();
                      };
                      Choices3.prototype._handleChoiceAction = function(activeItems, element) {
                        if (!activeItems || !element) {
                          return;
                        }
                        var id5 = element.dataset.id;
                        var choice = id5 && this._store.getChoiceById(id5);
                        if (!choice) {
                          return;
                        }
                        var passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : void 0;
                        var hasActiveDropdown = this.dropdown.isActive;
                        choice.keyCode = passedKeyCode;
                        this.passedElement.triggerEvent(constants_1.EVENTS.choice, {
                          choice
                        });
                        if (!choice.selected && !choice.disabled) {
                          var canAddItem = this._canAddItem(activeItems, choice.value);
                          if (canAddItem.response) {
                            this._addItem({
                              value: choice.value,
                              label: choice.label,
                              choiceId: choice.id,
                              groupId: choice.groupId,
                              customProperties: choice.customProperties,
                              placeholder: choice.placeholder,
                              keyCode: choice.keyCode
                            });
                            this._triggerChange(choice.value);
                          }
                        }
                        this.clearInput();
                        if (hasActiveDropdown && this._isSelectOneElement) {
                          this.hideDropdown(true);
                          this.containerOuter.focus();
                        }
                      };
                      Choices3.prototype._handleBackspace = function(activeItems) {
                        if (!this.config.removeItems || !activeItems) {
                          return;
                        }
                        var lastItem = activeItems[activeItems.length - 1];
                        var hasHighlightedItems = activeItems.some(function(item) {
                          return item.highlighted;
                        });
                        if (this.config.editItems && !hasHighlightedItems && lastItem) {
                          this.input.value = lastItem.value;
                          this.input.setWidth();
                          this._removeItem(lastItem);
                          this._triggerChange(lastItem.value);
                        } else {
                          if (!hasHighlightedItems) {
                            this.highlightItem(lastItem, false);
                          }
                          this.removeHighlightedItems(true);
                        }
                      };
                      Choices3.prototype._startLoading = function() {
                        this._store.dispatch((0, misc_1.setIsLoading)(true));
                      };
                      Choices3.prototype._stopLoading = function() {
                        this._store.dispatch((0, misc_1.setIsLoading)(false));
                      };
                      Choices3.prototype._handleLoadingState = function(setLoading) {
                        if (setLoading === void 0) {
                          setLoading = true;
                        }
                        var placeholderItem = this.itemList.getChild(".".concat(this.config.classNames.placeholder));
                        if (setLoading) {
                          this.disable();
                          this.containerOuter.addLoadingState();
                          if (this._isSelectOneElement) {
                            if (!placeholderItem) {
                              placeholderItem = this._getTemplate("placeholder", this.config.loadingText);
                              if (placeholderItem) {
                                this.itemList.append(placeholderItem);
                              }
                            } else {
                              placeholderItem.innerHTML = this.config.loadingText;
                            }
                          } else {
                            this.input.placeholder = this.config.loadingText;
                          }
                        } else {
                          this.enable();
                          this.containerOuter.removeLoadingState();
                          if (this._isSelectOneElement) {
                            if (placeholderItem) {
                              placeholderItem.innerHTML = this._placeholderValue || "";
                            }
                          } else {
                            this.input.placeholder = this._placeholderValue || "";
                          }
                        }
                      };
                      Choices3.prototype._handleSearch = function(value2) {
                        if (!this.input.isFocussed) {
                          return;
                        }
                        var choices = this._store.choices;
                        var _a = this.config, searchFloor = _a.searchFloor, searchChoices = _a.searchChoices;
                        var hasUnactiveChoices = choices.some(function(option2) {
                          return !option2.active;
                        });
                        if (value2 !== null && typeof value2 !== "undefined" && value2.length >= searchFloor) {
                          var resultCount = searchChoices ? this._searchChoices(value2) : 0;
                          this.passedElement.triggerEvent(constants_1.EVENTS.search, {
                            value: value2,
                            resultCount
                          });
                        } else if (hasUnactiveChoices) {
                          this._isSearching = false;
                          this._store.dispatch((0, choices_1.activateChoices)(true));
                        }
                      };
                      Choices3.prototype._canAddItem = function(activeItems, value2) {
                        var canAddItem = true;
                        var notice = typeof this.config.addItemText === "function" ? this.config.addItemText(value2) : this.config.addItemText;
                        if (!this._isSelectOneElement) {
                          var isDuplicateValue = (0, utils_1.existsInArray)(activeItems, value2);
                          if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {
                            canAddItem = false;
                            notice = typeof this.config.maxItemText === "function" ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;
                          }
                          if (!this.config.duplicateItemsAllowed && isDuplicateValue && canAddItem) {
                            canAddItem = false;
                            notice = typeof this.config.uniqueItemText === "function" ? this.config.uniqueItemText(value2) : this.config.uniqueItemText;
                          }
                          if (this._isTextElement && this.config.addItems && canAddItem && typeof this.config.addItemFilter === "function" && !this.config.addItemFilter(value2)) {
                            canAddItem = false;
                            notice = typeof this.config.customAddItemText === "function" ? this.config.customAddItemText(value2) : this.config.customAddItemText;
                          }
                        }
                        return {
                          response: canAddItem,
                          notice
                        };
                      };
                      Choices3.prototype._searchChoices = function(value2) {
                        var newValue = typeof value2 === "string" ? value2.trim() : value2;
                        var currentValue = typeof this._currentValue === "string" ? this._currentValue.trim() : this._currentValue;
                        if (newValue.length < 1 && newValue === "".concat(currentValue, " ")) {
                          return 0;
                        }
                        var haystack = this._store.searchableChoices;
                        var needle = newValue;
                        var options = Object.assign(this.config.fuseOptions, {
                          keys: __spreadArray2([], this.config.searchFields, true),
                          includeMatches: true
                        });
                        var fuse = new fuse_js_1.default(haystack, options);
                        var results = fuse.search(needle);
                        this._currentValue = newValue;
                        this._highlightPosition = 0;
                        this._isSearching = true;
                        this._store.dispatch((0, choices_1.filterChoices)(results));
                        return results.length;
                      };
                      Choices3.prototype._addEventListeners = function() {
                        var documentElement = document.documentElement;
                        documentElement.addEventListener("touchend", this._onTouchEnd, true);
                        this.containerOuter.element.addEventListener("keydown", this._onKeyDown, true);
                        this.containerOuter.element.addEventListener("mousedown", this._onMouseDown, true);
                        documentElement.addEventListener("click", this._onClick, {
                          passive: true
                        });
                        documentElement.addEventListener("touchmove", this._onTouchMove, {
                          passive: true
                        });
                        this.dropdown.element.addEventListener("mouseover", this._onMouseOver, {
                          passive: true
                        });
                        if (this._isSelectOneElement) {
                          this.containerOuter.element.addEventListener("focus", this._onFocus, {
                            passive: true
                          });
                          this.containerOuter.element.addEventListener("blur", this._onBlur, {
                            passive: true
                          });
                        }
                        this.input.element.addEventListener("keyup", this._onKeyUp, {
                          passive: true
                        });
                        this.input.element.addEventListener("focus", this._onFocus, {
                          passive: true
                        });
                        this.input.element.addEventListener("blur", this._onBlur, {
                          passive: true
                        });
                        if (this.input.element.form) {
                          this.input.element.form.addEventListener("reset", this._onFormReset, {
                            passive: true
                          });
                        }
                        this.input.addEventListeners();
                      };
                      Choices3.prototype._removeEventListeners = function() {
                        var documentElement = document.documentElement;
                        documentElement.removeEventListener("touchend", this._onTouchEnd, true);
                        this.containerOuter.element.removeEventListener("keydown", this._onKeyDown, true);
                        this.containerOuter.element.removeEventListener("mousedown", this._onMouseDown, true);
                        documentElement.removeEventListener("click", this._onClick);
                        documentElement.removeEventListener("touchmove", this._onTouchMove);
                        this.dropdown.element.removeEventListener("mouseover", this._onMouseOver);
                        if (this._isSelectOneElement) {
                          this.containerOuter.element.removeEventListener("focus", this._onFocus);
                          this.containerOuter.element.removeEventListener("blur", this._onBlur);
                        }
                        this.input.element.removeEventListener("keyup", this._onKeyUp);
                        this.input.element.removeEventListener("focus", this._onFocus);
                        this.input.element.removeEventListener("blur", this._onBlur);
                        if (this.input.element.form) {
                          this.input.element.form.removeEventListener("reset", this._onFormReset);
                        }
                        this.input.removeEventListeners();
                      };
                      Choices3.prototype._onKeyDown = function(event) {
                        var keyCode = event.keyCode;
                        var activeItems = this._store.activeItems;
                        var hasFocusedInput = this.input.isFocussed;
                        var hasActiveDropdown = this.dropdown.isActive;
                        var hasItems = this.itemList.hasChildren();
                        var keyString = String.fromCharCode(keyCode);
                        var wasPrintableChar = /[^\x00-\x1F]/.test(keyString);
                        var BACK_KEY = constants_1.KEY_CODES.BACK_KEY, DELETE_KEY = constants_1.KEY_CODES.DELETE_KEY, ENTER_KEY = constants_1.KEY_CODES.ENTER_KEY, A_KEY = constants_1.KEY_CODES.A_KEY, ESC_KEY = constants_1.KEY_CODES.ESC_KEY, UP_KEY = constants_1.KEY_CODES.UP_KEY, DOWN_KEY = constants_1.KEY_CODES.DOWN_KEY, PAGE_UP_KEY = constants_1.KEY_CODES.PAGE_UP_KEY, PAGE_DOWN_KEY = constants_1.KEY_CODES.PAGE_DOWN_KEY;
                        if (!this._isTextElement && !hasActiveDropdown && wasPrintableChar) {
                          this.showDropdown();
                          if (!this.input.isFocussed) {
                            this.input.value += event.key.toLowerCase();
                          }
                        }
                        switch (keyCode) {
                          case A_KEY:
                            return this._onSelectKey(event, hasItems);
                          case ENTER_KEY:
                            return this._onEnterKey(event, activeItems, hasActiveDropdown);
                          case ESC_KEY:
                            return this._onEscapeKey(hasActiveDropdown);
                          case UP_KEY:
                          case PAGE_UP_KEY:
                          case DOWN_KEY:
                          case PAGE_DOWN_KEY:
                            return this._onDirectionKey(event, hasActiveDropdown);
                          case DELETE_KEY:
                          case BACK_KEY:
                            return this._onDeleteKey(event, activeItems, hasFocusedInput);
                          default:
                        }
                      };
                      Choices3.prototype._onKeyUp = function(_a) {
                        var target = _a.target, keyCode = _a.keyCode;
                        var value2 = this.input.value;
                        var activeItems = this._store.activeItems;
                        var canAddItem = this._canAddItem(activeItems, value2);
                        var backKey = constants_1.KEY_CODES.BACK_KEY, deleteKey2 = constants_1.KEY_CODES.DELETE_KEY;
                        if (this._isTextElement) {
                          var canShowDropdownNotice = canAddItem.notice && value2;
                          if (canShowDropdownNotice) {
                            var dropdownItem = this._getTemplate("notice", canAddItem.notice);
                            this.dropdown.element.innerHTML = dropdownItem.outerHTML;
                            this.showDropdown(true);
                          } else {
                            this.hideDropdown(true);
                          }
                        } else {
                          var wasRemovalKeyCode = keyCode === backKey || keyCode === deleteKey2;
                          var userHasRemovedValue = wasRemovalKeyCode && target && !target.value;
                          var canReactivateChoices = !this._isTextElement && this._isSearching;
                          var canSearch = this._canSearch && canAddItem.response;
                          if (userHasRemovedValue && canReactivateChoices) {
                            this._isSearching = false;
                            this._store.dispatch((0, choices_1.activateChoices)(true));
                          } else if (canSearch) {
                            this._handleSearch(this.input.rawValue);
                          }
                        }
                        this._canSearch = this.config.searchEnabled;
                      };
                      Choices3.prototype._onSelectKey = function(event, hasItems) {
                        var ctrlKey = event.ctrlKey, metaKey = event.metaKey;
                        var hasCtrlDownKeyPressed = ctrlKey || metaKey;
                        if (hasCtrlDownKeyPressed && hasItems) {
                          this._canSearch = false;
                          var shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;
                          if (shouldHightlightAll) {
                            this.highlightAll();
                          }
                        }
                      };
                      Choices3.prototype._onEnterKey = function(event, activeItems, hasActiveDropdown) {
                        var target = event.target;
                        var enterKey = constants_1.KEY_CODES.ENTER_KEY;
                        var targetWasButton = target && target.hasAttribute("data-button");
                        if (this._isTextElement && target && target.value) {
                          var value2 = this.input.value;
                          var canAddItem = this._canAddItem(activeItems, value2);
                          if (canAddItem.response) {
                            this.hideDropdown(true);
                            this._addItem({
                              value: value2
                            });
                            this._triggerChange(value2);
                            this.clearInput();
                          }
                        }
                        if (targetWasButton) {
                          this._handleButtonAction(activeItems, target);
                          event.preventDefault();
                        }
                        if (hasActiveDropdown) {
                          var highlightedChoice = this.dropdown.getChild(".".concat(this.config.classNames.highlightedState));
                          if (highlightedChoice) {
                            if (activeItems[0]) {
                              activeItems[0].keyCode = enterKey;
                            }
                            this._handleChoiceAction(activeItems, highlightedChoice);
                          }
                          event.preventDefault();
                        } else if (this._isSelectOneElement) {
                          this.showDropdown();
                          event.preventDefault();
                        }
                      };
                      Choices3.prototype._onEscapeKey = function(hasActiveDropdown) {
                        if (hasActiveDropdown) {
                          this.hideDropdown(true);
                          this.containerOuter.focus();
                        }
                      };
                      Choices3.prototype._onDirectionKey = function(event, hasActiveDropdown) {
                        var keyCode = event.keyCode, metaKey = event.metaKey;
                        var downKey = constants_1.KEY_CODES.DOWN_KEY, pageUpKey = constants_1.KEY_CODES.PAGE_UP_KEY, pageDownKey = constants_1.KEY_CODES.PAGE_DOWN_KEY;
                        if (hasActiveDropdown || this._isSelectOneElement) {
                          this.showDropdown();
                          this._canSearch = false;
                          var directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;
                          var skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;
                          var selectableChoiceIdentifier = "[data-choice-selectable]";
                          var nextEl2 = void 0;
                          if (skipKey) {
                            if (directionInt > 0) {
                              nextEl2 = this.dropdown.element.querySelector("".concat(selectableChoiceIdentifier, ":last-of-type"));
                            } else {
                              nextEl2 = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                            }
                          } else {
                            var currentEl = this.dropdown.element.querySelector(".".concat(this.config.classNames.highlightedState));
                            if (currentEl) {
                              nextEl2 = (0, utils_1.getAdjacentEl)(currentEl, selectableChoiceIdentifier, directionInt);
                            } else {
                              nextEl2 = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                            }
                          }
                          if (nextEl2) {
                            if (!(0, utils_1.isScrolledIntoView)(nextEl2, this.choiceList.element, directionInt)) {
                              this.choiceList.scrollToChildElement(nextEl2, directionInt);
                            }
                            this._highlightChoice(nextEl2);
                          }
                          event.preventDefault();
                        }
                      };
                      Choices3.prototype._onDeleteKey = function(event, activeItems, hasFocusedInput) {
                        var target = event.target;
                        if (!this._isSelectOneElement && !target.value && hasFocusedInput) {
                          this._handleBackspace(activeItems);
                          event.preventDefault();
                        }
                      };
                      Choices3.prototype._onTouchMove = function() {
                        if (this._wasTap) {
                          this._wasTap = false;
                        }
                      };
                      Choices3.prototype._onTouchEnd = function(event) {
                        var target = (event || event.touches[0]).target;
                        var touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);
                        if (touchWasWithinContainer) {
                          var containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;
                          if (containerWasExactTarget) {
                            if (this._isTextElement) {
                              this.input.focus();
                            } else if (this._isSelectMultipleElement) {
                              this.showDropdown();
                            }
                          }
                          event.stopPropagation();
                        }
                        this._wasTap = true;
                      };
                      Choices3.prototype._onMouseDown = function(event) {
                        var target = event.target;
                        if (!(target instanceof HTMLElement)) {
                          return;
                        }
                        if (IS_IE11 && this.choiceList.element.contains(target)) {
                          var firstChoice = this.choiceList.element.firstElementChild;
                          var isOnScrollbar = this._direction === "ltr" ? event.offsetX >= firstChoice.offsetWidth : event.offsetX < firstChoice.offsetLeft;
                          this._isScrollingOnIe = isOnScrollbar;
                        }
                        if (target === this.input.element) {
                          return;
                        }
                        var item = target.closest("[data-button],[data-item],[data-choice]");
                        if (item instanceof HTMLElement) {
                          var hasShiftKey = event.shiftKey;
                          var activeItems = this._store.activeItems;
                          var dataset = item.dataset;
                          if ("button" in dataset) {
                            this._handleButtonAction(activeItems, item);
                          } else if ("item" in dataset) {
                            this._handleItemAction(activeItems, item, hasShiftKey);
                          } else if ("choice" in dataset) {
                            this._handleChoiceAction(activeItems, item);
                          }
                        }
                        event.preventDefault();
                      };
                      Choices3.prototype._onMouseOver = function(_a) {
                        var target = _a.target;
                        if (target instanceof HTMLElement && "choice" in target.dataset) {
                          this._highlightChoice(target);
                        }
                      };
                      Choices3.prototype._onClick = function(_a) {
                        var target = _a.target;
                        var clickWasWithinContainer = this.containerOuter.element.contains(target);
                        if (clickWasWithinContainer) {
                          if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {
                            if (this._isTextElement) {
                              if (document.activeElement !== this.input.element) {
                                this.input.focus();
                              }
                            } else {
                              this.showDropdown();
                              this.containerOuter.focus();
                            }
                          } else if (this._isSelectOneElement && target !== this.input.element && !this.dropdown.element.contains(target)) {
                            this.hideDropdown();
                          }
                        } else {
                          var hasHighlightedItems = this._store.highlightedActiveItems.length > 0;
                          if (hasHighlightedItems) {
                            this.unhighlightAll();
                          }
                          this.containerOuter.removeFocusState();
                          this.hideDropdown(true);
                        }
                      };
                      Choices3.prototype._onFocus = function(_a) {
                        var _b;
                        var _this = this;
                        var target = _a.target;
                        var focusWasWithinContainer = target && this.containerOuter.element.contains(target);
                        if (!focusWasWithinContainer) {
                          return;
                        }
                        var focusActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function() {
                          if (target === _this.input.element) {
                            _this.containerOuter.addFocusState();
                          }
                        }, _b[constants_1.SELECT_ONE_TYPE] = function() {
                          _this.containerOuter.addFocusState();
                          if (target === _this.input.element) {
                            _this.showDropdown(true);
                          }
                        }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function() {
                          if (target === _this.input.element) {
                            _this.showDropdown(true);
                            _this.containerOuter.addFocusState();
                          }
                        }, _b);
                        focusActions[this.passedElement.element.type]();
                      };
                      Choices3.prototype._onBlur = function(_a) {
                        var _b;
                        var _this = this;
                        var target = _a.target;
                        var blurWasWithinContainer = target && this.containerOuter.element.contains(target);
                        if (blurWasWithinContainer && !this._isScrollingOnIe) {
                          var activeItems = this._store.activeItems;
                          var hasHighlightedItems_1 = activeItems.some(function(item) {
                            return item.highlighted;
                          });
                          var blurActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function() {
                            if (target === _this.input.element) {
                              _this.containerOuter.removeFocusState();
                              if (hasHighlightedItems_1) {
                                _this.unhighlightAll();
                              }
                              _this.hideDropdown(true);
                            }
                          }, _b[constants_1.SELECT_ONE_TYPE] = function() {
                            _this.containerOuter.removeFocusState();
                            if (target === _this.input.element || target === _this.containerOuter.element && !_this._canSearch) {
                              _this.hideDropdown(true);
                            }
                          }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function() {
                            if (target === _this.input.element) {
                              _this.containerOuter.removeFocusState();
                              _this.hideDropdown(true);
                              if (hasHighlightedItems_1) {
                                _this.unhighlightAll();
                              }
                            }
                          }, _b);
                          blurActions[this.passedElement.element.type]();
                        } else {
                          this._isScrollingOnIe = false;
                          this.input.element.focus();
                        }
                      };
                      Choices3.prototype._onFormReset = function() {
                        this._store.dispatch((0, misc_1.resetTo)(this._initialState));
                      };
                      Choices3.prototype._highlightChoice = function(el) {
                        var _this = this;
                        if (el === void 0) {
                          el = null;
                        }
                        var choices = Array.from(this.dropdown.element.querySelectorAll("[data-choice-selectable]"));
                        if (!choices.length) {
                          return;
                        }
                        var passedEl = el;
                        var highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(".".concat(this.config.classNames.highlightedState)));
                        highlightedChoices.forEach(function(choice) {
                          choice.classList.remove(_this.config.classNames.highlightedState);
                          choice.setAttribute("aria-selected", "false");
                        });
                        if (passedEl) {
                          this._highlightPosition = choices.indexOf(passedEl);
                        } else {
                          if (choices.length > this._highlightPosition) {
                            passedEl = choices[this._highlightPosition];
                          } else {
                            passedEl = choices[choices.length - 1];
                          }
                          if (!passedEl) {
                            passedEl = choices[0];
                          }
                        }
                        passedEl.classList.add(this.config.classNames.highlightedState);
                        passedEl.setAttribute("aria-selected", "true");
                        this.passedElement.triggerEvent(constants_1.EVENTS.highlightChoice, {
                          el: passedEl
                        });
                        if (this.dropdown.isActive) {
                          this.input.setActiveDescendant(passedEl.id);
                          this.containerOuter.setActiveDescendant(passedEl.id);
                        }
                      };
                      Choices3.prototype._addItem = function(_a) {
                        var value2 = _a.value, _b = _a.label, label = _b === void 0 ? null : _b, _c = _a.choiceId, choiceId = _c === void 0 ? -1 : _c, _d = _a.groupId, groupId = _d === void 0 ? -1 : _d, _e = _a.customProperties, customProperties = _e === void 0 ? {} : _e, _f = _a.placeholder, placeholder = _f === void 0 ? false : _f, _g = _a.keyCode, keyCode = _g === void 0 ? -1 : _g;
                        var passedValue = typeof value2 === "string" ? value2.trim() : value2;
                        var items = this._store.items;
                        var passedLabel = label || passedValue;
                        var passedOptionId = choiceId || -1;
                        var group3 = groupId >= 0 ? this._store.getGroupById(groupId) : null;
                        var id5 = items ? items.length + 1 : 1;
                        if (this.config.prependValue) {
                          passedValue = this.config.prependValue + passedValue.toString();
                        }
                        if (this.config.appendValue) {
                          passedValue += this.config.appendValue.toString();
                        }
                        this._store.dispatch((0, items_1.addItem)({
                          value: passedValue,
                          label: passedLabel,
                          id: id5,
                          choiceId: passedOptionId,
                          groupId,
                          customProperties,
                          placeholder,
                          keyCode
                        }));
                        if (this._isSelectOneElement) {
                          this.removeActiveItems(id5);
                        }
                        this.passedElement.triggerEvent(constants_1.EVENTS.addItem, {
                          id: id5,
                          value: passedValue,
                          label: passedLabel,
                          customProperties,
                          groupValue: group3 && group3.value ? group3.value : null,
                          keyCode
                        });
                      };
                      Choices3.prototype._removeItem = function(item) {
                        var id5 = item.id, value2 = item.value, label = item.label, customProperties = item.customProperties, choiceId = item.choiceId, groupId = item.groupId;
                        var group3 = groupId && groupId >= 0 ? this._store.getGroupById(groupId) : null;
                        if (!id5 || !choiceId) {
                          return;
                        }
                        this._store.dispatch((0, items_1.removeItem)(id5, choiceId));
                        this.passedElement.triggerEvent(constants_1.EVENTS.removeItem, {
                          id: id5,
                          value: value2,
                          label,
                          customProperties,
                          groupValue: group3 && group3.value ? group3.value : null
                        });
                      };
                      Choices3.prototype._addChoice = function(_a) {
                        var value2 = _a.value, _b = _a.label, label = _b === void 0 ? null : _b, _c = _a.isSelected, isSelected = _c === void 0 ? false : _c, _d = _a.isDisabled, isDisabled = _d === void 0 ? false : _d, _e = _a.groupId, groupId = _e === void 0 ? -1 : _e, _f = _a.customProperties, customProperties = _f === void 0 ? {} : _f, _g = _a.placeholder, placeholder = _g === void 0 ? false : _g, _h = _a.keyCode, keyCode = _h === void 0 ? -1 : _h;
                        if (typeof value2 === "undefined" || value2 === null) {
                          return;
                        }
                        var choices = this._store.choices;
                        var choiceLabel = label || value2;
                        var choiceId = choices ? choices.length + 1 : 1;
                        var choiceElementId = "".concat(this._baseId, "-").concat(this._idNames.itemChoice, "-").concat(choiceId);
                        this._store.dispatch((0, choices_1.addChoice)({
                          id: choiceId,
                          groupId,
                          elementId: choiceElementId,
                          value: value2,
                          label: choiceLabel,
                          disabled: isDisabled,
                          customProperties,
                          placeholder,
                          keyCode
                        }));
                        if (isSelected) {
                          this._addItem({
                            value: value2,
                            label: choiceLabel,
                            choiceId,
                            customProperties,
                            placeholder,
                            keyCode
                          });
                        }
                      };
                      Choices3.prototype._addGroup = function(_a) {
                        var _this = this;
                        var group3 = _a.group, id5 = _a.id, _b = _a.valueKey, valueKey = _b === void 0 ? "value" : _b, _c = _a.labelKey, labelKey = _c === void 0 ? "label" : _c;
                        var groupChoices = (0, utils_1.isType)("Object", group3) ? group3.choices : Array.from(group3.getElementsByTagName("OPTION"));
                        var groupId = id5 || Math.floor((/* @__PURE__ */ new Date()).valueOf() * Math.random());
                        var isDisabled = group3.disabled ? group3.disabled : false;
                        if (groupChoices) {
                          this._store.dispatch((0, groups_1.addGroup)({
                            value: group3.label,
                            id: groupId,
                            active: true,
                            disabled: isDisabled
                          }));
                          var addGroupChoices = function(choice) {
                            var isOptDisabled = choice.disabled || choice.parentNode && choice.parentNode.disabled;
                            _this._addChoice({
                              value: choice[valueKey],
                              label: (0, utils_1.isType)("Object", choice) ? choice[labelKey] : choice.innerHTML,
                              isSelected: choice.selected,
                              isDisabled: isOptDisabled,
                              groupId,
                              customProperties: choice.customProperties,
                              placeholder: choice.placeholder
                            });
                          };
                          groupChoices.forEach(addGroupChoices);
                        } else {
                          this._store.dispatch((0, groups_1.addGroup)({
                            value: group3.label,
                            id: group3.id,
                            active: false,
                            disabled: group3.disabled
                          }));
                        }
                      };
                      Choices3.prototype._getTemplate = function(template) {
                        var _a;
                        var args = [];
                        for (var _i = 1; _i < arguments.length; _i++) {
                          args[_i - 1] = arguments[_i];
                        }
                        return (_a = this._templates[template]).call.apply(_a, __spreadArray2([this, this.config], args, false));
                      };
                      Choices3.prototype._createTemplates = function() {
                        var callbackOnCreateTemplates = this.config.callbackOnCreateTemplates;
                        var userTemplates = {};
                        if (callbackOnCreateTemplates && typeof callbackOnCreateTemplates === "function") {
                          userTemplates = callbackOnCreateTemplates.call(this, utils_1.strToEl);
                        }
                        this._templates = (0, deepmerge_1.default)(templates_1.default, userTemplates);
                      };
                      Choices3.prototype._createElements = function() {
                        this.containerOuter = new components_1.Container({
                          element: this._getTemplate("containerOuter", this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type, this.config.labelId),
                          classNames: this.config.classNames,
                          type: this.passedElement.element.type,
                          position: this.config.position
                        });
                        this.containerInner = new components_1.Container({
                          element: this._getTemplate("containerInner"),
                          classNames: this.config.classNames,
                          type: this.passedElement.element.type,
                          position: this.config.position
                        });
                        this.input = new components_1.Input({
                          element: this._getTemplate("input", this._placeholderValue),
                          classNames: this.config.classNames,
                          type: this.passedElement.element.type,
                          preventPaste: !this.config.paste
                        });
                        this.choiceList = new components_1.List({
                          element: this._getTemplate("choiceList", this._isSelectOneElement)
                        });
                        this.itemList = new components_1.List({
                          element: this._getTemplate("itemList", this._isSelectOneElement)
                        });
                        this.dropdown = new components_1.Dropdown({
                          element: this._getTemplate("dropdown"),
                          classNames: this.config.classNames,
                          type: this.passedElement.element.type
                        });
                      };
                      Choices3.prototype._createStructure = function() {
                        this.passedElement.conceal();
                        this.containerInner.wrap(this.passedElement.element);
                        this.containerOuter.wrap(this.containerInner.element);
                        if (this._isSelectOneElement) {
                          this.input.placeholder = this.config.searchPlaceholderValue || "";
                        } else if (this._placeholderValue) {
                          this.input.placeholder = this._placeholderValue;
                          this.input.setWidth();
                        }
                        this.containerOuter.element.appendChild(this.containerInner.element);
                        this.containerOuter.element.appendChild(this.dropdown.element);
                        this.containerInner.element.appendChild(this.itemList.element);
                        if (!this._isTextElement) {
                          this.dropdown.element.appendChild(this.choiceList.element);
                        }
                        if (!this._isSelectOneElement) {
                          this.containerInner.element.appendChild(this.input.element);
                        } else if (this.config.searchEnabled) {
                          this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);
                        }
                        if (this._isSelectElement) {
                          this._highlightPosition = 0;
                          this._isSearching = false;
                          this._startLoading();
                          if (this._presetGroups.length) {
                            this._addPredefinedGroups(this._presetGroups);
                          } else {
                            this._addPredefinedChoices(this._presetChoices);
                          }
                          this._stopLoading();
                        }
                        if (this._isTextElement) {
                          this._addPredefinedItems(this._presetItems);
                        }
                      };
                      Choices3.prototype._addPredefinedGroups = function(groups2) {
                        var _this = this;
                        var placeholderChoice = this.passedElement.placeholderOption;
                        if (placeholderChoice && placeholderChoice.parentNode && placeholderChoice.parentNode.tagName === "SELECT") {
                          this._addChoice({
                            value: placeholderChoice.value,
                            label: placeholderChoice.innerHTML,
                            isSelected: placeholderChoice.selected,
                            isDisabled: placeholderChoice.disabled,
                            placeholder: true
                          });
                        }
                        groups2.forEach(function(group3) {
                          return _this._addGroup({
                            group: group3,
                            id: group3.id || null
                          });
                        });
                      };
                      Choices3.prototype._addPredefinedChoices = function(choices) {
                        var _this = this;
                        if (this.config.shouldSort) {
                          choices.sort(this.config.sorter);
                        }
                        var hasSelectedChoice = choices.some(function(choice) {
                          return choice.selected;
                        });
                        var firstEnabledChoiceIndex = choices.findIndex(function(choice) {
                          return choice.disabled === void 0 || !choice.disabled;
                        });
                        choices.forEach(function(choice, index4) {
                          var _a = choice.value, value2 = _a === void 0 ? "" : _a, label = choice.label, customProperties = choice.customProperties, placeholder = choice.placeholder;
                          if (_this._isSelectElement) {
                            if (choice.choices) {
                              _this._addGroup({
                                group: choice,
                                id: choice.id || null
                              });
                            } else {
                              var shouldPreselect = _this._isSelectOneElement && !hasSelectedChoice && index4 === firstEnabledChoiceIndex;
                              var isSelected = shouldPreselect ? true : choice.selected;
                              var isDisabled = choice.disabled;
                              _this._addChoice({
                                value: value2,
                                label,
                                isSelected: !!isSelected,
                                isDisabled: !!isDisabled,
                                placeholder: !!placeholder,
                                customProperties
                              });
                            }
                          } else {
                            _this._addChoice({
                              value: value2,
                              label,
                              isSelected: !!choice.selected,
                              isDisabled: !!choice.disabled,
                              placeholder: !!choice.placeholder,
                              customProperties
                            });
                          }
                        });
                      };
                      Choices3.prototype._addPredefinedItems = function(items) {
                        var _this = this;
                        items.forEach(function(item) {
                          if (typeof item === "object" && item.value) {
                            _this._addItem({
                              value: item.value,
                              label: item.label,
                              choiceId: item.id,
                              customProperties: item.customProperties,
                              placeholder: item.placeholder
                            });
                          }
                          if (typeof item === "string") {
                            _this._addItem({
                              value: item
                            });
                          }
                        });
                      };
                      Choices3.prototype._setChoiceOrItem = function(item) {
                        var _this = this;
                        var itemType = (0, utils_1.getType)(item).toLowerCase();
                        var handleType = {
                          object: function() {
                            if (!item.value) {
                              return;
                            }
                            if (!_this._isTextElement) {
                              _this._addChoice({
                                value: item.value,
                                label: item.label,
                                isSelected: true,
                                isDisabled: false,
                                customProperties: item.customProperties,
                                placeholder: item.placeholder
                              });
                            } else {
                              _this._addItem({
                                value: item.value,
                                label: item.label,
                                choiceId: item.id,
                                customProperties: item.customProperties,
                                placeholder: item.placeholder
                              });
                            }
                          },
                          string: function() {
                            if (!_this._isTextElement) {
                              _this._addChoice({
                                value: item,
                                label: item,
                                isSelected: true,
                                isDisabled: false
                              });
                            } else {
                              _this._addItem({
                                value: item
                              });
                            }
                          }
                        };
                        handleType[itemType]();
                      };
                      Choices3.prototype._findAndSelectChoiceByValue = function(value2) {
                        var _this = this;
                        var choices = this._store.choices;
                        var foundChoice = choices.find(function(choice) {
                          return _this.config.valueComparer(choice.value, value2);
                        });
                        if (foundChoice && !foundChoice.selected) {
                          this._addItem({
                            value: foundChoice.value,
                            label: foundChoice.label,
                            choiceId: foundChoice.id,
                            groupId: foundChoice.groupId,
                            customProperties: foundChoice.customProperties,
                            placeholder: foundChoice.placeholder,
                            keyCode: foundChoice.keyCode
                          });
                        }
                      };
                      Choices3.prototype._generatePlaceholderValue = function() {
                        if (this._isSelectElement && this.passedElement.placeholderOption) {
                          var placeholderOption = this.passedElement.placeholderOption;
                          return placeholderOption ? placeholderOption.text : null;
                        }
                        var _a = this.config, placeholder = _a.placeholder, placeholderValue = _a.placeholderValue;
                        var dataset = this.passedElement.element.dataset;
                        if (placeholder) {
                          if (placeholderValue) {
                            return placeholderValue;
                          }
                          if (dataset.placeholder) {
                            return dataset.placeholder;
                          }
                        }
                        return null;
                      };
                      return Choices3;
                    }()
                  );
                  exports2["default"] = Choices2;
                }
              ),
              /***/
              613: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var utils_1 = __webpack_require__2(799);
                  var constants_1 = __webpack_require__2(883);
                  var Container2 = (
                    /** @class */
                    function() {
                      function Container3(_a) {
                        var element = _a.element, type = _a.type, classNames2 = _a.classNames, position = _a.position;
                        this.element = element;
                        this.classNames = classNames2;
                        this.type = type;
                        this.position = position;
                        this.isOpen = false;
                        this.isFlipped = false;
                        this.isFocussed = false;
                        this.isDisabled = false;
                        this.isLoading = false;
                        this._onFocus = this._onFocus.bind(this);
                        this._onBlur = this._onBlur.bind(this);
                      }
                      Container3.prototype.addEventListeners = function() {
                        this.element.addEventListener("focus", this._onFocus);
                        this.element.addEventListener("blur", this._onBlur);
                      };
                      Container3.prototype.removeEventListeners = function() {
                        this.element.removeEventListener("focus", this._onFocus);
                        this.element.removeEventListener("blur", this._onBlur);
                      };
                      Container3.prototype.shouldFlip = function(dropdownPos) {
                        if (typeof dropdownPos !== "number") {
                          return false;
                        }
                        var shouldFlip = false;
                        if (this.position === "auto") {
                          shouldFlip = !window.matchMedia("(min-height: ".concat(dropdownPos + 1, "px)")).matches;
                        } else if (this.position === "top") {
                          shouldFlip = true;
                        }
                        return shouldFlip;
                      };
                      Container3.prototype.setActiveDescendant = function(activeDescendantID) {
                        this.element.setAttribute("aria-activedescendant", activeDescendantID);
                      };
                      Container3.prototype.removeActiveDescendant = function() {
                        this.element.removeAttribute("aria-activedescendant");
                      };
                      Container3.prototype.open = function(dropdownPos) {
                        this.element.classList.add(this.classNames.openState);
                        this.element.setAttribute("aria-expanded", "true");
                        this.isOpen = true;
                        if (this.shouldFlip(dropdownPos)) {
                          this.element.classList.add(this.classNames.flippedState);
                          this.isFlipped = true;
                        }
                      };
                      Container3.prototype.close = function() {
                        this.element.classList.remove(this.classNames.openState);
                        this.element.setAttribute("aria-expanded", "false");
                        this.removeActiveDescendant();
                        this.isOpen = false;
                        if (this.isFlipped) {
                          this.element.classList.remove(this.classNames.flippedState);
                          this.isFlipped = false;
                        }
                      };
                      Container3.prototype.focus = function() {
                        if (!this.isFocussed) {
                          this.element.focus();
                        }
                      };
                      Container3.prototype.addFocusState = function() {
                        this.element.classList.add(this.classNames.focusState);
                      };
                      Container3.prototype.removeFocusState = function() {
                        this.element.classList.remove(this.classNames.focusState);
                      };
                      Container3.prototype.enable = function() {
                        this.element.classList.remove(this.classNames.disabledState);
                        this.element.removeAttribute("aria-disabled");
                        if (this.type === constants_1.SELECT_ONE_TYPE) {
                          this.element.setAttribute("tabindex", "0");
                        }
                        this.isDisabled = false;
                      };
                      Container3.prototype.disable = function() {
                        this.element.classList.add(this.classNames.disabledState);
                        this.element.setAttribute("aria-disabled", "true");
                        if (this.type === constants_1.SELECT_ONE_TYPE) {
                          this.element.setAttribute("tabindex", "-1");
                        }
                        this.isDisabled = true;
                      };
                      Container3.prototype.wrap = function(element) {
                        (0, utils_1.wrap)(element, this.element);
                      };
                      Container3.prototype.unwrap = function(element) {
                        if (this.element.parentNode) {
                          this.element.parentNode.insertBefore(element, this.element);
                          this.element.parentNode.removeChild(this.element);
                        }
                      };
                      Container3.prototype.addLoadingState = function() {
                        this.element.classList.add(this.classNames.loadingState);
                        this.element.setAttribute("aria-busy", "true");
                        this.isLoading = true;
                      };
                      Container3.prototype.removeLoadingState = function() {
                        this.element.classList.remove(this.classNames.loadingState);
                        this.element.removeAttribute("aria-busy");
                        this.isLoading = false;
                      };
                      Container3.prototype._onFocus = function() {
                        this.isFocussed = true;
                      };
                      Container3.prototype._onBlur = function() {
                        this.isFocussed = false;
                      };
                      return Container3;
                    }()
                  );
                  exports2["default"] = Container2;
                }
              ),
              /***/
              217: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var Dropdown = (
                    /** @class */
                    function() {
                      function Dropdown2(_a) {
                        var element = _a.element, type = _a.type, classNames2 = _a.classNames;
                        this.element = element;
                        this.classNames = classNames2;
                        this.type = type;
                        this.isActive = false;
                      }
                      Object.defineProperty(Dropdown2.prototype, "distanceFromTopWindow", {
                        /**
                         * Bottom position of dropdown in viewport coordinates
                         */
                        get: function() {
                          return this.element.getBoundingClientRect().bottom;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Dropdown2.prototype.getChild = function(selector) {
                        return this.element.querySelector(selector);
                      };
                      Dropdown2.prototype.show = function() {
                        this.element.classList.add(this.classNames.activeState);
                        this.element.setAttribute("aria-expanded", "true");
                        this.isActive = true;
                        return this;
                      };
                      Dropdown2.prototype.hide = function() {
                        this.element.classList.remove(this.classNames.activeState);
                        this.element.setAttribute("aria-expanded", "false");
                        this.isActive = false;
                        return this;
                      };
                      return Dropdown2;
                    }()
                  );
                  exports2["default"] = Dropdown;
                }
              ),
              /***/
              520: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __importDefault = this && this.__importDefault || function(mod3) {
                    return mod3 && mod3.__esModule ? mod3 : {
                      "default": mod3
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.WrappedSelect = exports2.WrappedInput = exports2.List = exports2.Input = exports2.Container = exports2.Dropdown = void 0;
                  var dropdown_1 = __importDefault(__webpack_require__2(217));
                  exports2.Dropdown = dropdown_1.default;
                  var container_1 = __importDefault(__webpack_require__2(613));
                  exports2.Container = container_1.default;
                  var input_1 = __importDefault(__webpack_require__2(11));
                  exports2.Input = input_1.default;
                  var list_1 = __importDefault(__webpack_require__2(624));
                  exports2.List = list_1.default;
                  var wrapped_input_1 = __importDefault(__webpack_require__2(541));
                  exports2.WrappedInput = wrapped_input_1.default;
                  var wrapped_select_1 = __importDefault(__webpack_require__2(982));
                  exports2.WrappedSelect = wrapped_select_1.default;
                }
              ),
              /***/
              11: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var utils_1 = __webpack_require__2(799);
                  var constants_1 = __webpack_require__2(883);
                  var Input = (
                    /** @class */
                    function() {
                      function Input2(_a) {
                        var element = _a.element, type = _a.type, classNames2 = _a.classNames, preventPaste = _a.preventPaste;
                        this.element = element;
                        this.type = type;
                        this.classNames = classNames2;
                        this.preventPaste = preventPaste;
                        this.isFocussed = this.element.isEqualNode(document.activeElement);
                        this.isDisabled = element.disabled;
                        this._onPaste = this._onPaste.bind(this);
                        this._onInput = this._onInput.bind(this);
                        this._onFocus = this._onFocus.bind(this);
                        this._onBlur = this._onBlur.bind(this);
                      }
                      Object.defineProperty(Input2.prototype, "placeholder", {
                        set: function(placeholder) {
                          this.element.placeholder = placeholder;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Input2.prototype, "value", {
                        get: function() {
                          return (0, utils_1.sanitise)(this.element.value);
                        },
                        set: function(value2) {
                          this.element.value = value2;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Input2.prototype, "rawValue", {
                        get: function() {
                          return this.element.value;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Input2.prototype.addEventListeners = function() {
                        this.element.addEventListener("paste", this._onPaste);
                        this.element.addEventListener("input", this._onInput, {
                          passive: true
                        });
                        this.element.addEventListener("focus", this._onFocus, {
                          passive: true
                        });
                        this.element.addEventListener("blur", this._onBlur, {
                          passive: true
                        });
                      };
                      Input2.prototype.removeEventListeners = function() {
                        this.element.removeEventListener("input", this._onInput);
                        this.element.removeEventListener("paste", this._onPaste);
                        this.element.removeEventListener("focus", this._onFocus);
                        this.element.removeEventListener("blur", this._onBlur);
                      };
                      Input2.prototype.enable = function() {
                        this.element.removeAttribute("disabled");
                        this.isDisabled = false;
                      };
                      Input2.prototype.disable = function() {
                        this.element.setAttribute("disabled", "");
                        this.isDisabled = true;
                      };
                      Input2.prototype.focus = function() {
                        if (!this.isFocussed) {
                          this.element.focus();
                        }
                      };
                      Input2.prototype.blur = function() {
                        if (this.isFocussed) {
                          this.element.blur();
                        }
                      };
                      Input2.prototype.clear = function(setWidth) {
                        if (setWidth === void 0) {
                          setWidth = true;
                        }
                        if (this.element.value) {
                          this.element.value = "";
                        }
                        if (setWidth) {
                          this.setWidth();
                        }
                        return this;
                      };
                      Input2.prototype.setWidth = function() {
                        var _a = this.element, style = _a.style, value2 = _a.value, placeholder = _a.placeholder;
                        style.minWidth = "".concat(placeholder.length + 1, "ch");
                        style.width = "".concat(value2.length + 1, "ch");
                      };
                      Input2.prototype.setActiveDescendant = function(activeDescendantID) {
                        this.element.setAttribute("aria-activedescendant", activeDescendantID);
                      };
                      Input2.prototype.removeActiveDescendant = function() {
                        this.element.removeAttribute("aria-activedescendant");
                      };
                      Input2.prototype._onInput = function() {
                        if (this.type !== constants_1.SELECT_ONE_TYPE) {
                          this.setWidth();
                        }
                      };
                      Input2.prototype._onPaste = function(event) {
                        if (this.preventPaste) {
                          event.preventDefault();
                        }
                      };
                      Input2.prototype._onFocus = function() {
                        this.isFocussed = true;
                      };
                      Input2.prototype._onBlur = function() {
                        this.isFocussed = false;
                      };
                      return Input2;
                    }()
                  );
                  exports2["default"] = Input;
                }
              ),
              /***/
              624: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var constants_1 = __webpack_require__2(883);
                  var List = (
                    /** @class */
                    function() {
                      function List2(_a) {
                        var element = _a.element;
                        this.element = element;
                        this.scrollPos = this.element.scrollTop;
                        this.height = this.element.offsetHeight;
                      }
                      List2.prototype.clear = function() {
                        this.element.innerHTML = "";
                      };
                      List2.prototype.append = function(node) {
                        this.element.appendChild(node);
                      };
                      List2.prototype.getChild = function(selector) {
                        return this.element.querySelector(selector);
                      };
                      List2.prototype.hasChildren = function() {
                        return this.element.hasChildNodes();
                      };
                      List2.prototype.scrollToTop = function() {
                        this.element.scrollTop = 0;
                      };
                      List2.prototype.scrollToChildElement = function(element, direction2) {
                        var _this = this;
                        if (!element) {
                          return;
                        }
                        var listHeight = this.element.offsetHeight;
                        var listScrollPosition = this.element.scrollTop + listHeight;
                        var elementHeight = element.offsetHeight;
                        var elementPos = element.offsetTop + elementHeight;
                        var destination = direction2 > 0 ? this.element.scrollTop + elementPos - listScrollPosition : element.offsetTop;
                        requestAnimationFrame(function() {
                          _this._animateScroll(destination, direction2);
                        });
                      };
                      List2.prototype._scrollDown = function(scrollPos, strength, destination) {
                        var easing = (destination - scrollPos) / strength;
                        var distance7 = easing > 1 ? easing : 1;
                        this.element.scrollTop = scrollPos + distance7;
                      };
                      List2.prototype._scrollUp = function(scrollPos, strength, destination) {
                        var easing = (scrollPos - destination) / strength;
                        var distance7 = easing > 1 ? easing : 1;
                        this.element.scrollTop = scrollPos - distance7;
                      };
                      List2.prototype._animateScroll = function(destination, direction2) {
                        var _this = this;
                        var strength = constants_1.SCROLLING_SPEED;
                        var choiceListScrollTop = this.element.scrollTop;
                        var continueAnimation = false;
                        if (direction2 > 0) {
                          this._scrollDown(choiceListScrollTop, strength, destination);
                          if (choiceListScrollTop < destination) {
                            continueAnimation = true;
                          }
                        } else {
                          this._scrollUp(choiceListScrollTop, strength, destination);
                          if (choiceListScrollTop > destination) {
                            continueAnimation = true;
                          }
                        }
                        if (continueAnimation) {
                          requestAnimationFrame(function() {
                            _this._animateScroll(destination, direction2);
                          });
                        }
                      };
                      return List2;
                    }()
                  );
                  exports2["default"] = List;
                }
              ),
              /***/
              730: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var utils_1 = __webpack_require__2(799);
                  var WrappedElement = (
                    /** @class */
                    function() {
                      function WrappedElement2(_a) {
                        var element = _a.element, classNames2 = _a.classNames;
                        this.element = element;
                        this.classNames = classNames2;
                        if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLSelectElement)) {
                          throw new TypeError("Invalid element passed");
                        }
                        this.isDisabled = false;
                      }
                      Object.defineProperty(WrappedElement2.prototype, "isActive", {
                        get: function() {
                          return this.element.dataset.choice === "active";
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(WrappedElement2.prototype, "dir", {
                        get: function() {
                          return this.element.dir;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(WrappedElement2.prototype, "value", {
                        get: function() {
                          return this.element.value;
                        },
                        set: function(value2) {
                          this.element.value = value2;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      WrappedElement2.prototype.conceal = function() {
                        this.element.classList.add(this.classNames.input);
                        this.element.hidden = true;
                        this.element.tabIndex = -1;
                        var origStyle = this.element.getAttribute("style");
                        if (origStyle) {
                          this.element.setAttribute("data-choice-orig-style", origStyle);
                        }
                        this.element.setAttribute("data-choice", "active");
                      };
                      WrappedElement2.prototype.reveal = function() {
                        this.element.classList.remove(this.classNames.input);
                        this.element.hidden = false;
                        this.element.removeAttribute("tabindex");
                        var origStyle = this.element.getAttribute("data-choice-orig-style");
                        if (origStyle) {
                          this.element.removeAttribute("data-choice-orig-style");
                          this.element.setAttribute("style", origStyle);
                        } else {
                          this.element.removeAttribute("style");
                        }
                        this.element.removeAttribute("data-choice");
                        this.element.value = this.element.value;
                      };
                      WrappedElement2.prototype.enable = function() {
                        this.element.removeAttribute("disabled");
                        this.element.disabled = false;
                        this.isDisabled = false;
                      };
                      WrappedElement2.prototype.disable = function() {
                        this.element.setAttribute("disabled", "");
                        this.element.disabled = true;
                        this.isDisabled = true;
                      };
                      WrappedElement2.prototype.triggerEvent = function(eventType, data2) {
                        (0, utils_1.dispatchEvent)(this.element, eventType, data2);
                      };
                      return WrappedElement2;
                    }()
                  );
                  exports2["default"] = WrappedElement;
                }
              ),
              /***/
              541: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __extends2 = this && this.__extends || /* @__PURE__ */ function() {
                    var extendStatics2 = function(d3, b) {
                      extendStatics2 = Object.setPrototypeOf || {
                        __proto__: []
                      } instanceof Array && function(d4, b2) {
                        d4.__proto__ = b2;
                      } || function(d4, b2) {
                        for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d4[p2] = b2[p2];
                      };
                      return extendStatics2(d3, b);
                    };
                    return function(d3, b) {
                      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                      extendStatics2(d3, b);
                      function __() {
                        this.constructor = d3;
                      }
                      d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                  }();
                  var __importDefault = this && this.__importDefault || function(mod3) {
                    return mod3 && mod3.__esModule ? mod3 : {
                      "default": mod3
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var wrapped_element_1 = __importDefault(__webpack_require__2(730));
                  var WrappedInput = (
                    /** @class */
                    function(_super) {
                      __extends2(WrappedInput2, _super);
                      function WrappedInput2(_a) {
                        var element = _a.element, classNames2 = _a.classNames, delimiter = _a.delimiter;
                        var _this = _super.call(this, {
                          element,
                          classNames: classNames2
                        }) || this;
                        _this.delimiter = delimiter;
                        return _this;
                      }
                      Object.defineProperty(WrappedInput2.prototype, "value", {
                        get: function() {
                          return this.element.value;
                        },
                        set: function(value2) {
                          this.element.setAttribute("value", value2);
                          this.element.value = value2;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      return WrappedInput2;
                    }(wrapped_element_1.default)
                  );
                  exports2["default"] = WrappedInput;
                }
              ),
              /***/
              982: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __extends2 = this && this.__extends || /* @__PURE__ */ function() {
                    var extendStatics2 = function(d3, b) {
                      extendStatics2 = Object.setPrototypeOf || {
                        __proto__: []
                      } instanceof Array && function(d4, b2) {
                        d4.__proto__ = b2;
                      } || function(d4, b2) {
                        for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d4[p2] = b2[p2];
                      };
                      return extendStatics2(d3, b);
                    };
                    return function(d3, b) {
                      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                      extendStatics2(d3, b);
                      function __() {
                        this.constructor = d3;
                      }
                      d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                  }();
                  var __importDefault = this && this.__importDefault || function(mod3) {
                    return mod3 && mod3.__esModule ? mod3 : {
                      "default": mod3
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var wrapped_element_1 = __importDefault(__webpack_require__2(730));
                  var WrappedSelect = (
                    /** @class */
                    function(_super) {
                      __extends2(WrappedSelect2, _super);
                      function WrappedSelect2(_a) {
                        var element = _a.element, classNames2 = _a.classNames, template = _a.template;
                        var _this = _super.call(this, {
                          element,
                          classNames: classNames2
                        }) || this;
                        _this.template = template;
                        return _this;
                      }
                      Object.defineProperty(WrappedSelect2.prototype, "placeholderOption", {
                        get: function() {
                          return this.element.querySelector('option[value=""]') || // Backward compatibility layer for the non-standard placeholder attribute supported in older versions.
                          this.element.querySelector("option[placeholder]");
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(WrappedSelect2.prototype, "optionGroups", {
                        get: function() {
                          return Array.from(this.element.getElementsByTagName("OPTGROUP"));
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(WrappedSelect2.prototype, "options", {
                        get: function() {
                          return Array.from(this.element.options);
                        },
                        set: function(options) {
                          var _this = this;
                          var fragment = document.createDocumentFragment();
                          var addOptionToFragment = function(data2) {
                            var option2 = _this.template(data2);
                            fragment.appendChild(option2);
                          };
                          options.forEach(function(optionData) {
                            return addOptionToFragment(optionData);
                          });
                          this.appendDocFragment(fragment);
                        },
                        enumerable: false,
                        configurable: true
                      });
                      WrappedSelect2.prototype.appendDocFragment = function(fragment) {
                        this.element.innerHTML = "";
                        this.element.appendChild(fragment);
                      };
                      return WrappedSelect2;
                    }(wrapped_element_1.default)
                  );
                  exports2["default"] = WrappedSelect;
                }
              ),
              /***/
              883: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.SCROLLING_SPEED = exports2.SELECT_MULTIPLE_TYPE = exports2.SELECT_ONE_TYPE = exports2.TEXT_TYPE = exports2.KEY_CODES = exports2.ACTION_TYPES = exports2.EVENTS = void 0;
                  exports2.EVENTS = {
                    showDropdown: "showDropdown",
                    hideDropdown: "hideDropdown",
                    change: "change",
                    choice: "choice",
                    search: "search",
                    addItem: "addItem",
                    removeItem: "removeItem",
                    highlightItem: "highlightItem",
                    highlightChoice: "highlightChoice",
                    unhighlightItem: "unhighlightItem"
                  };
                  exports2.ACTION_TYPES = {
                    ADD_CHOICE: "ADD_CHOICE",
                    FILTER_CHOICES: "FILTER_CHOICES",
                    ACTIVATE_CHOICES: "ACTIVATE_CHOICES",
                    CLEAR_CHOICES: "CLEAR_CHOICES",
                    ADD_GROUP: "ADD_GROUP",
                    ADD_ITEM: "ADD_ITEM",
                    REMOVE_ITEM: "REMOVE_ITEM",
                    HIGHLIGHT_ITEM: "HIGHLIGHT_ITEM",
                    CLEAR_ALL: "CLEAR_ALL",
                    RESET_TO: "RESET_TO",
                    SET_IS_LOADING: "SET_IS_LOADING"
                  };
                  exports2.KEY_CODES = {
                    BACK_KEY: 46,
                    DELETE_KEY: 8,
                    ENTER_KEY: 13,
                    A_KEY: 65,
                    ESC_KEY: 27,
                    UP_KEY: 38,
                    DOWN_KEY: 40,
                    PAGE_UP_KEY: 33,
                    PAGE_DOWN_KEY: 34
                  };
                  exports2.TEXT_TYPE = "text";
                  exports2.SELECT_ONE_TYPE = "select-one";
                  exports2.SELECT_MULTIPLE_TYPE = "select-multiple";
                  exports2.SCROLLING_SPEED = 4;
                }
              ),
              /***/
              789: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.DEFAULT_CONFIG = exports2.DEFAULT_CLASSNAMES = void 0;
                  var utils_1 = __webpack_require__2(799);
                  exports2.DEFAULT_CLASSNAMES = {
                    containerOuter: "choices",
                    containerInner: "choices__inner",
                    input: "choices__input",
                    inputCloned: "choices__input--cloned",
                    list: "choices__list",
                    listItems: "choices__list--multiple",
                    listSingle: "choices__list--single",
                    listDropdown: "choices__list--dropdown",
                    item: "choices__item",
                    itemSelectable: "choices__item--selectable",
                    itemDisabled: "choices__item--disabled",
                    itemChoice: "choices__item--choice",
                    placeholder: "choices__placeholder",
                    group: "choices__group",
                    groupHeading: "choices__heading",
                    button: "choices__button",
                    activeState: "is-active",
                    focusState: "is-focused",
                    openState: "is-open",
                    disabledState: "is-disabled",
                    highlightedState: "is-highlighted",
                    selectedState: "is-selected",
                    flippedState: "is-flipped",
                    loadingState: "is-loading",
                    noResults: "has-no-results",
                    noChoices: "has-no-choices"
                  };
                  exports2.DEFAULT_CONFIG = {
                    items: [],
                    choices: [],
                    silent: false,
                    renderChoiceLimit: -1,
                    maxItemCount: -1,
                    addItems: true,
                    addItemFilter: null,
                    removeItems: true,
                    removeItemButton: false,
                    editItems: false,
                    allowHTML: true,
                    duplicateItemsAllowed: true,
                    delimiter: ",",
                    paste: true,
                    searchEnabled: true,
                    searchChoices: true,
                    searchFloor: 1,
                    searchResultLimit: 4,
                    searchFields: ["label", "value"],
                    position: "auto",
                    resetScrollPosition: true,
                    shouldSort: true,
                    shouldSortItems: false,
                    sorter: utils_1.sortByAlpha,
                    placeholder: true,
                    placeholderValue: null,
                    searchPlaceholderValue: null,
                    prependValue: null,
                    appendValue: null,
                    renderSelectedChoices: "auto",
                    loadingText: "Loading...",
                    noResultsText: "No results found",
                    noChoicesText: "No choices to choose from",
                    itemSelectText: "Press to select",
                    uniqueItemText: "Only unique values can be added",
                    customAddItemText: "Only values matching specific conditions can be added",
                    addItemText: function(value2) {
                      return 'Press Enter to add <b>"'.concat((0, utils_1.sanitise)(value2), '"</b>');
                    },
                    maxItemText: function(maxItemCount) {
                      return "Only ".concat(maxItemCount, " values can be added");
                    },
                    valueComparer: function(value1, value2) {
                      return value1 === value2;
                    },
                    fuseOptions: {
                      includeScore: true
                    },
                    labelId: "",
                    callbackOnInit: null,
                    callbackOnCreateTemplates: null,
                    classNames: exports2.DEFAULT_CLASSNAMES
                  };
                }
              ),
              /***/
              18: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              978: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              948: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              359: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              285: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              533: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              187: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __createBinding = this && this.__createBinding || (Object.create ? function(o, m3, k, k2) {
                    if (k2 === void 0) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m3, k);
                    if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
                      desc = {
                        enumerable: true,
                        get: function() {
                          return m3[k];
                        }
                      };
                    }
                    Object.defineProperty(o, k2, desc);
                  } : function(o, m3, k, k2) {
                    if (k2 === void 0) k2 = k;
                    o[k2] = m3[k];
                  });
                  var __exportStar = this && this.__exportStar || function(m3, exports3) {
                    for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2)) __createBinding(exports3, m3, p2);
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  __exportStar(__webpack_require__2(18), exports2);
                  __exportStar(__webpack_require__2(978), exports2);
                  __exportStar(__webpack_require__2(948), exports2);
                  __exportStar(__webpack_require__2(359), exports2);
                  __exportStar(__webpack_require__2(285), exports2);
                  __exportStar(__webpack_require__2(533), exports2);
                  __exportStar(__webpack_require__2(287), exports2);
                  __exportStar(__webpack_require__2(132), exports2);
                  __exportStar(__webpack_require__2(837), exports2);
                  __exportStar(__webpack_require__2(598), exports2);
                  __exportStar(__webpack_require__2(369), exports2);
                  __exportStar(__webpack_require__2(37), exports2);
                  __exportStar(__webpack_require__2(47), exports2);
                  __exportStar(__webpack_require__2(923), exports2);
                  __exportStar(__webpack_require__2(876), exports2);
                }
              ),
              /***/
              287: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              132: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              837: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              598: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              37: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              369: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              47: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              923: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              876: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              799: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.parseCustomProperties = exports2.diff = exports2.cloneObject = exports2.existsInArray = exports2.dispatchEvent = exports2.sortByScore = exports2.sortByAlpha = exports2.strToEl = exports2.sanitise = exports2.isScrolledIntoView = exports2.getAdjacentEl = exports2.wrap = exports2.isType = exports2.getType = exports2.generateId = exports2.generateChars = exports2.getRandomNumber = void 0;
                  var getRandomNumber = function(min10, max11) {
                    return Math.floor(Math.random() * (max11 - min10) + min10);
                  };
                  exports2.getRandomNumber = getRandomNumber;
                  var generateChars = function(length5) {
                    return Array.from({
                      length: length5
                    }, function() {
                      return (0, exports2.getRandomNumber)(0, 36).toString(36);
                    }).join("");
                  };
                  exports2.generateChars = generateChars;
                  var generateId = function(element, prefix) {
                    var id5 = element.id || element.name && "".concat(element.name, "-").concat((0, exports2.generateChars)(2)) || (0, exports2.generateChars)(4);
                    id5 = id5.replace(/(:|\.|\[|\]|,)/g, "");
                    id5 = "".concat(prefix, "-").concat(id5);
                    return id5;
                  };
                  exports2.generateId = generateId;
                  var getType2 = function(obj) {
                    return Object.prototype.toString.call(obj).slice(8, -1);
                  };
                  exports2.getType = getType2;
                  var isType2 = function(type, obj) {
                    return obj !== void 0 && obj !== null && (0, exports2.getType)(obj) === type;
                  };
                  exports2.isType = isType2;
                  var wrap = function(element, wrapper) {
                    if (wrapper === void 0) {
                      wrapper = document.createElement("div");
                    }
                    if (element.parentNode) {
                      if (element.nextSibling) {
                        element.parentNode.insertBefore(wrapper, element.nextSibling);
                      } else {
                        element.parentNode.appendChild(wrapper);
                      }
                    }
                    return wrapper.appendChild(element);
                  };
                  exports2.wrap = wrap;
                  var getAdjacentEl = function(startEl, selector, direction2) {
                    if (direction2 === void 0) {
                      direction2 = 1;
                    }
                    var prop = "".concat(direction2 > 0 ? "next" : "previous", "ElementSibling");
                    var sibling = startEl[prop];
                    while (sibling) {
                      if (sibling.matches(selector)) {
                        return sibling;
                      }
                      sibling = sibling[prop];
                    }
                    return sibling;
                  };
                  exports2.getAdjacentEl = getAdjacentEl;
                  var isScrolledIntoView = function(element, parent, direction2) {
                    if (direction2 === void 0) {
                      direction2 = 1;
                    }
                    if (!element) {
                      return false;
                    }
                    var isVisible;
                    if (direction2 > 0) {
                      isVisible = parent.scrollTop + parent.offsetHeight >= element.offsetTop + element.offsetHeight;
                    } else {
                      isVisible = element.offsetTop >= parent.scrollTop;
                    }
                    return isVisible;
                  };
                  exports2.isScrolledIntoView = isScrolledIntoView;
                  var sanitise = function(value2) {
                    if (typeof value2 !== "string") {
                      return value2;
                    }
                    return value2.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;");
                  };
                  exports2.sanitise = sanitise;
                  exports2.strToEl = function() {
                    var tmpEl = document.createElement("div");
                    return function(str7) {
                      var cleanedInput = str7.trim();
                      tmpEl.innerHTML = cleanedInput;
                      var firldChild = tmpEl.children[0];
                      while (tmpEl.firstChild) {
                        tmpEl.removeChild(tmpEl.firstChild);
                      }
                      return firldChild;
                    };
                  }();
                  var sortByAlpha = function(_a, _b) {
                    var value2 = _a.value, _c = _a.label, label = _c === void 0 ? value2 : _c;
                    var value22 = _b.value, _d = _b.label, label2 = _d === void 0 ? value22 : _d;
                    return label.localeCompare(label2, [], {
                      sensitivity: "base",
                      ignorePunctuation: true,
                      numeric: true
                    });
                  };
                  exports2.sortByAlpha = sortByAlpha;
                  var sortByScore = function(a3, b) {
                    var _a = a3.score, scoreA = _a === void 0 ? 0 : _a;
                    var _b = b.score, scoreB = _b === void 0 ? 0 : _b;
                    return scoreA - scoreB;
                  };
                  exports2.sortByScore = sortByScore;
                  var dispatchEvent4 = function(element, type, customArgs) {
                    if (customArgs === void 0) {
                      customArgs = null;
                    }
                    var event = new CustomEvent(type, {
                      detail: customArgs,
                      bubbles: true,
                      cancelable: true
                    });
                    return element.dispatchEvent(event);
                  };
                  exports2.dispatchEvent = dispatchEvent4;
                  var existsInArray = function(array2, value2, key) {
                    if (key === void 0) {
                      key = "value";
                    }
                    return array2.some(function(item) {
                      if (typeof value2 === "string") {
                        return item[key] === value2.trim();
                      }
                      return item[key] === value2;
                    });
                  };
                  exports2.existsInArray = existsInArray;
                  var cloneObject = function(obj) {
                    return JSON.parse(JSON.stringify(obj));
                  };
                  exports2.cloneObject = cloneObject;
                  var diff = function(a3, b) {
                    var aKeys = Object.keys(a3).sort();
                    var bKeys = Object.keys(b).sort();
                    return aKeys.filter(function(i) {
                      return bKeys.indexOf(i) < 0;
                    });
                  };
                  exports2.diff = diff;
                  var parseCustomProperties = function(customProperties) {
                    if (typeof customProperties !== "undefined") {
                      try {
                        return JSON.parse(customProperties);
                      } catch (e3) {
                        return customProperties;
                      }
                    }
                    return {};
                  };
                  exports2.parseCustomProperties = parseCustomProperties;
                }
              ),
              /***/
              273: (
                /***/
                function(__unused_webpack_module, exports2) {
                  var __spreadArray2 = this && this.__spreadArray || function(to, from, pack3) {
                    if (pack3 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.defaultState = void 0;
                  exports2.defaultState = [];
                  function choices(state, action) {
                    if (state === void 0) {
                      state = exports2.defaultState;
                    }
                    if (action === void 0) {
                      action = {};
                    }
                    switch (action.type) {
                      case "ADD_CHOICE": {
                        var addChoiceAction = action;
                        var choice = {
                          id: addChoiceAction.id,
                          elementId: addChoiceAction.elementId,
                          groupId: addChoiceAction.groupId,
                          value: addChoiceAction.value,
                          label: addChoiceAction.label || addChoiceAction.value,
                          disabled: addChoiceAction.disabled || false,
                          selected: false,
                          active: true,
                          score: 9999,
                          customProperties: addChoiceAction.customProperties,
                          placeholder: addChoiceAction.placeholder || false
                        };
                        return __spreadArray2(__spreadArray2([], state, true), [choice], false);
                      }
                      case "ADD_ITEM": {
                        var addItemAction_1 = action;
                        if (addItemAction_1.choiceId > -1) {
                          return state.map(function(obj) {
                            var choice2 = obj;
                            if (choice2.id === parseInt("".concat(addItemAction_1.choiceId), 10)) {
                              choice2.selected = true;
                            }
                            return choice2;
                          });
                        }
                        return state;
                      }
                      case "REMOVE_ITEM": {
                        var removeItemAction_1 = action;
                        if (removeItemAction_1.choiceId && removeItemAction_1.choiceId > -1) {
                          return state.map(function(obj) {
                            var choice2 = obj;
                            if (choice2.id === parseInt("".concat(removeItemAction_1.choiceId), 10)) {
                              choice2.selected = false;
                            }
                            return choice2;
                          });
                        }
                        return state;
                      }
                      case "FILTER_CHOICES": {
                        var filterChoicesAction_1 = action;
                        return state.map(function(obj) {
                          var choice2 = obj;
                          choice2.active = filterChoicesAction_1.results.some(function(_a) {
                            var item = _a.item, score2 = _a.score;
                            if (item.id === choice2.id) {
                              choice2.score = score2;
                              return true;
                            }
                            return false;
                          });
                          return choice2;
                        });
                      }
                      case "ACTIVATE_CHOICES": {
                        var activateChoicesAction_1 = action;
                        return state.map(function(obj) {
                          var choice2 = obj;
                          choice2.active = activateChoicesAction_1.active;
                          return choice2;
                        });
                      }
                      case "CLEAR_CHOICES": {
                        return exports2.defaultState;
                      }
                      default: {
                        return state;
                      }
                    }
                  }
                  exports2["default"] = choices;
                }
              ),
              /***/
              871: (
                /***/
                function(__unused_webpack_module, exports2) {
                  var __spreadArray2 = this && this.__spreadArray || function(to, from, pack3) {
                    if (pack3 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.defaultState = void 0;
                  exports2.defaultState = [];
                  function groups2(state, action) {
                    if (state === void 0) {
                      state = exports2.defaultState;
                    }
                    if (action === void 0) {
                      action = {};
                    }
                    switch (action.type) {
                      case "ADD_GROUP": {
                        var addGroupAction = action;
                        return __spreadArray2(__spreadArray2([], state, true), [{
                          id: addGroupAction.id,
                          value: addGroupAction.value,
                          active: addGroupAction.active,
                          disabled: addGroupAction.disabled
                        }], false);
                      }
                      case "CLEAR_CHOICES": {
                        return [];
                      }
                      default: {
                        return state;
                      }
                    }
                  }
                  exports2["default"] = groups2;
                }
              ),
              /***/
              655: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __importDefault = this && this.__importDefault || function(mod3) {
                    return mod3 && mod3.__esModule ? mod3 : {
                      "default": mod3
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.defaultState = void 0;
                  var redux_1 = __webpack_require__2(791);
                  var items_1 = __importDefault(__webpack_require__2(52));
                  var groups_1 = __importDefault(__webpack_require__2(871));
                  var choices_1 = __importDefault(__webpack_require__2(273));
                  var loading_1 = __importDefault(__webpack_require__2(502));
                  var utils_1 = __webpack_require__2(799);
                  exports2.defaultState = {
                    groups: [],
                    items: [],
                    choices: [],
                    loading: false
                  };
                  var appReducer = (0, redux_1.combineReducers)({
                    items: items_1.default,
                    groups: groups_1.default,
                    choices: choices_1.default,
                    loading: loading_1.default
                  });
                  var rootReducer = function(passedState, action) {
                    var state = passedState;
                    if (action.type === "CLEAR_ALL") {
                      state = exports2.defaultState;
                    } else if (action.type === "RESET_TO") {
                      return (0, utils_1.cloneObject)(action.state);
                    }
                    return appReducer(state, action);
                  };
                  exports2["default"] = rootReducer;
                }
              ),
              /***/
              52: (
                /***/
                function(__unused_webpack_module, exports2) {
                  var __spreadArray2 = this && this.__spreadArray || function(to, from, pack3) {
                    if (pack3 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.defaultState = void 0;
                  exports2.defaultState = [];
                  function items(state, action) {
                    if (state === void 0) {
                      state = exports2.defaultState;
                    }
                    if (action === void 0) {
                      action = {};
                    }
                    switch (action.type) {
                      case "ADD_ITEM": {
                        var addItemAction = action;
                        var newState = __spreadArray2(__spreadArray2([], state, true), [{
                          id: addItemAction.id,
                          choiceId: addItemAction.choiceId,
                          groupId: addItemAction.groupId,
                          value: addItemAction.value,
                          label: addItemAction.label,
                          active: true,
                          highlighted: false,
                          customProperties: addItemAction.customProperties,
                          placeholder: addItemAction.placeholder || false,
                          keyCode: null
                        }], false);
                        return newState.map(function(obj) {
                          var item = obj;
                          item.highlighted = false;
                          return item;
                        });
                      }
                      case "REMOVE_ITEM": {
                        return state.map(function(obj) {
                          var item = obj;
                          if (item.id === action.id) {
                            item.active = false;
                          }
                          return item;
                        });
                      }
                      case "HIGHLIGHT_ITEM": {
                        var highlightItemAction_1 = action;
                        return state.map(function(obj) {
                          var item = obj;
                          if (item.id === highlightItemAction_1.id) {
                            item.highlighted = highlightItemAction_1.highlighted;
                          }
                          return item;
                        });
                      }
                      default: {
                        return state;
                      }
                    }
                  }
                  exports2["default"] = items;
                }
              ),
              /***/
              502: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.defaultState = void 0;
                  exports2.defaultState = false;
                  var general = function(state, action) {
                    if (state === void 0) {
                      state = exports2.defaultState;
                    }
                    if (action === void 0) {
                      action = {};
                    }
                    switch (action.type) {
                      case "SET_IS_LOADING": {
                        return action.isLoading;
                      }
                      default: {
                        return state;
                      }
                    }
                  };
                  exports2["default"] = general;
                }
              ),
              /***/
              744: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __spreadArray2 = this && this.__spreadArray || function(to, from, pack3) {
                    if (pack3 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                  };
                  var __importDefault = this && this.__importDefault || function(mod3) {
                    return mod3 && mod3.__esModule ? mod3 : {
                      "default": mod3
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var redux_1 = __webpack_require__2(791);
                  var index_1 = __importDefault(__webpack_require__2(655));
                  var Store = (
                    /** @class */
                    function() {
                      function Store2() {
                        this._store = (0, redux_1.createStore)(index_1.default, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
                      }
                      Store2.prototype.subscribe = function(onChange) {
                        this._store.subscribe(onChange);
                      };
                      Store2.prototype.dispatch = function(action) {
                        this._store.dispatch(action);
                      };
                      Object.defineProperty(Store2.prototype, "state", {
                        /**
                         * Get store object (wrapping Redux method)
                         */
                        get: function() {
                          return this._store.getState();
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "items", {
                        /**
                         * Get items from store
                         */
                        get: function() {
                          return this.state.items;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "activeItems", {
                        /**
                         * Get active items from store
                         */
                        get: function() {
                          return this.items.filter(function(item) {
                            return item.active === true;
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "highlightedActiveItems", {
                        /**
                         * Get highlighted items from store
                         */
                        get: function() {
                          return this.items.filter(function(item) {
                            return item.active && item.highlighted;
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "choices", {
                        /**
                         * Get choices from store
                         */
                        get: function() {
                          return this.state.choices;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "activeChoices", {
                        /**
                         * Get active choices from store
                         */
                        get: function() {
                          return this.choices.filter(function(choice) {
                            return choice.active === true;
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "selectableChoices", {
                        /**
                         * Get selectable choices from store
                         */
                        get: function() {
                          return this.choices.filter(function(choice) {
                            return choice.disabled !== true;
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "searchableChoices", {
                        /**
                         * Get choices that can be searched (excluding placeholders)
                         */
                        get: function() {
                          return this.selectableChoices.filter(function(choice) {
                            return choice.placeholder !== true;
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "placeholderChoice", {
                        /**
                         * Get placeholder choice from store
                         */
                        get: function() {
                          return __spreadArray2([], this.choices, true).reverse().find(function(choice) {
                            return choice.placeholder === true;
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "groups", {
                        /**
                         * Get groups from store
                         */
                        get: function() {
                          return this.state.groups;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "activeGroups", {
                        /**
                         * Get active groups from store
                         */
                        get: function() {
                          var _a = this, groups2 = _a.groups, choices = _a.choices;
                          return groups2.filter(function(group3) {
                            var isActive = group3.active === true && group3.disabled === false;
                            var hasActiveOptions = choices.some(function(choice) {
                              return choice.active === true && choice.disabled === false;
                            });
                            return isActive && hasActiveOptions;
                          }, []);
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Store2.prototype.isLoading = function() {
                        return this.state.loading;
                      };
                      Store2.prototype.getChoiceById = function(id5) {
                        return this.activeChoices.find(function(choice) {
                          return choice.id === parseInt(id5, 10);
                        });
                      };
                      Store2.prototype.getGroupById = function(id5) {
                        return this.groups.find(function(group3) {
                          return group3.id === id5;
                        });
                      };
                      return Store2;
                    }()
                  );
                  exports2["default"] = Store;
                }
              ),
              /***/
              686: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var templates = {
                    containerOuter: function(_a, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType, labelId) {
                      var containerOuter = _a.classNames.containerOuter;
                      var div4 = Object.assign(document.createElement("div"), {
                        className: containerOuter
                      });
                      div4.dataset.type = passedElementType;
                      if (dir) {
                        div4.dir = dir;
                      }
                      if (isSelectOneElement) {
                        div4.tabIndex = 0;
                      }
                      if (isSelectElement) {
                        div4.setAttribute("role", searchEnabled ? "combobox" : "listbox");
                        if (searchEnabled) {
                          div4.setAttribute("aria-autocomplete", "list");
                        }
                      }
                      div4.setAttribute("aria-haspopup", "true");
                      div4.setAttribute("aria-expanded", "false");
                      if (labelId) {
                        div4.setAttribute("aria-labelledby", labelId);
                      }
                      return div4;
                    },
                    containerInner: function(_a) {
                      var containerInner = _a.classNames.containerInner;
                      return Object.assign(document.createElement("div"), {
                        className: containerInner
                      });
                    },
                    itemList: function(_a, isSelectOneElement) {
                      var _b = _a.classNames, list = _b.list, listSingle = _b.listSingle, listItems = _b.listItems;
                      return Object.assign(document.createElement("div"), {
                        className: "".concat(list, " ").concat(isSelectOneElement ? listSingle : listItems)
                      });
                    },
                    placeholder: function(_a, value2) {
                      var _b;
                      var allowHTML = _a.allowHTML, placeholder = _a.classNames.placeholder;
                      return Object.assign(document.createElement("div"), (_b = {
                        className: placeholder
                      }, _b[allowHTML ? "innerHTML" : "innerText"] = value2, _b));
                    },
                    item: function(_a, _b, removeItemButton) {
                      var _c, _d;
                      var allowHTML = _a.allowHTML, _e = _a.classNames, item = _e.item, button2 = _e.button, highlightedState = _e.highlightedState, itemSelectable = _e.itemSelectable, placeholder = _e.placeholder;
                      var id5 = _b.id, value2 = _b.value, label = _b.label, customProperties = _b.customProperties, active = _b.active, disabled = _b.disabled, highlighted = _b.highlighted, isPlaceholder = _b.placeholder;
                      var div4 = Object.assign(document.createElement("div"), (_c = {
                        className: item
                      }, _c[allowHTML ? "innerHTML" : "innerText"] = label, _c));
                      Object.assign(div4.dataset, {
                        item: "",
                        id: id5,
                        value: value2,
                        customProperties
                      });
                      if (active) {
                        div4.setAttribute("aria-selected", "true");
                      }
                      if (disabled) {
                        div4.setAttribute("aria-disabled", "true");
                      }
                      if (isPlaceholder) {
                        div4.classList.add(placeholder);
                      }
                      div4.classList.add(highlighted ? highlightedState : itemSelectable);
                      if (removeItemButton) {
                        if (disabled) {
                          div4.classList.remove(itemSelectable);
                        }
                        div4.dataset.deletable = "";
                        var REMOVE_ITEM_TEXT = "Remove item";
                        var removeButton = Object.assign(document.createElement("button"), (_d = {
                          type: "button",
                          className: button2
                        }, _d[allowHTML ? "innerHTML" : "innerText"] = REMOVE_ITEM_TEXT, _d));
                        removeButton.setAttribute("aria-label", "".concat(REMOVE_ITEM_TEXT, ": '").concat(value2, "'"));
                        removeButton.dataset.button = "";
                        div4.appendChild(removeButton);
                      }
                      return div4;
                    },
                    choiceList: function(_a, isSelectOneElement) {
                      var list = _a.classNames.list;
                      var div4 = Object.assign(document.createElement("div"), {
                        className: list
                      });
                      if (!isSelectOneElement) {
                        div4.setAttribute("aria-multiselectable", "true");
                      }
                      div4.setAttribute("role", "listbox");
                      return div4;
                    },
                    choiceGroup: function(_a, _b) {
                      var _c;
                      var allowHTML = _a.allowHTML, _d = _a.classNames, group3 = _d.group, groupHeading = _d.groupHeading, itemDisabled = _d.itemDisabled;
                      var id5 = _b.id, value2 = _b.value, disabled = _b.disabled;
                      var div4 = Object.assign(document.createElement("div"), {
                        className: "".concat(group3, " ").concat(disabled ? itemDisabled : "")
                      });
                      div4.setAttribute("role", "group");
                      Object.assign(div4.dataset, {
                        group: "",
                        id: id5,
                        value: value2
                      });
                      if (disabled) {
                        div4.setAttribute("aria-disabled", "true");
                      }
                      div4.appendChild(Object.assign(document.createElement("div"), (_c = {
                        className: groupHeading
                      }, _c[allowHTML ? "innerHTML" : "innerText"] = value2, _c)));
                      return div4;
                    },
                    choice: function(_a, _b, selectText) {
                      var _c;
                      var allowHTML = _a.allowHTML, _d = _a.classNames, item = _d.item, itemChoice = _d.itemChoice, itemSelectable = _d.itemSelectable, selectedState = _d.selectedState, itemDisabled = _d.itemDisabled, placeholder = _d.placeholder;
                      var id5 = _b.id, value2 = _b.value, label = _b.label, groupId = _b.groupId, elementId = _b.elementId, isDisabled = _b.disabled, isSelected = _b.selected, isPlaceholder = _b.placeholder;
                      var div4 = Object.assign(document.createElement("div"), (_c = {
                        id: elementId
                      }, _c[allowHTML ? "innerHTML" : "innerText"] = label, _c.className = "".concat(item, " ").concat(itemChoice), _c));
                      if (isSelected) {
                        div4.classList.add(selectedState);
                      }
                      if (isPlaceholder) {
                        div4.classList.add(placeholder);
                      }
                      div4.setAttribute("role", groupId && groupId > 0 ? "treeitem" : "option");
                      Object.assign(div4.dataset, {
                        choice: "",
                        id: id5,
                        value: value2,
                        selectText
                      });
                      if (isDisabled) {
                        div4.classList.add(itemDisabled);
                        div4.dataset.choiceDisabled = "";
                        div4.setAttribute("aria-disabled", "true");
                      } else {
                        div4.classList.add(itemSelectable);
                        div4.dataset.choiceSelectable = "";
                      }
                      return div4;
                    },
                    input: function(_a, placeholderValue) {
                      var _b = _a.classNames, input = _b.input, inputCloned = _b.inputCloned;
                      var inp = Object.assign(document.createElement("input"), {
                        type: "search",
                        name: "search_terms",
                        className: "".concat(input, " ").concat(inputCloned),
                        autocomplete: "off",
                        autocapitalize: "off",
                        spellcheck: false
                      });
                      inp.setAttribute("role", "textbox");
                      inp.setAttribute("aria-autocomplete", "list");
                      inp.setAttribute("aria-label", placeholderValue);
                      return inp;
                    },
                    dropdown: function(_a) {
                      var _b = _a.classNames, list = _b.list, listDropdown = _b.listDropdown;
                      var div4 = document.createElement("div");
                      div4.classList.add(list, listDropdown);
                      div4.setAttribute("aria-expanded", "false");
                      return div4;
                    },
                    notice: function(_a, innerText, type) {
                      var _b;
                      var allowHTML = _a.allowHTML, _c = _a.classNames, item = _c.item, itemChoice = _c.itemChoice, noResults = _c.noResults, noChoices = _c.noChoices;
                      if (type === void 0) {
                        type = "";
                      }
                      var classes = [item, itemChoice];
                      if (type === "no-choices") {
                        classes.push(noChoices);
                      } else if (type === "no-results") {
                        classes.push(noResults);
                      }
                      return Object.assign(document.createElement("div"), (_b = {}, _b[allowHTML ? "innerHTML" : "innerText"] = innerText, _b.className = classes.join(" "), _b));
                    },
                    option: function(_a) {
                      var label = _a.label, value2 = _a.value, customProperties = _a.customProperties, active = _a.active, disabled = _a.disabled;
                      var opt = new Option(label, value2, false, active);
                      if (customProperties) {
                        opt.dataset.customProperties = "".concat(customProperties);
                      }
                      opt.disabled = !!disabled;
                      return opt;
                    }
                  };
                  exports2["default"] = templates;
                }
              ),
              /***/
              996: (
                /***/
                function(module2) {
                  var isMergeableObject = function isMergeableObject2(value2) {
                    return isNonNullObject(value2) && !isSpecial(value2);
                  };
                  function isNonNullObject(value2) {
                    return !!value2 && typeof value2 === "object";
                  }
                  function isSpecial(value2) {
                    var stringValue = Object.prototype.toString.call(value2);
                    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value2);
                  }
                  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
                  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
                  function isReactElement(value2) {
                    return value2.$$typeof === REACT_ELEMENT_TYPE;
                  }
                  function emptyTarget(val) {
                    return Array.isArray(val) ? [] : {};
                  }
                  function cloneUnlessOtherwiseSpecified(value2, options) {
                    return options.clone !== false && options.isMergeableObject(value2) ? deepmerge(emptyTarget(value2), value2, options) : value2;
                  }
                  function defaultArrayMerge(target, source, options) {
                    return target.concat(source).map(function(element) {
                      return cloneUnlessOtherwiseSpecified(element, options);
                    });
                  }
                  function getMergeFunction(key, options) {
                    if (!options.customMerge) {
                      return deepmerge;
                    }
                    var customMerge = options.customMerge(key);
                    return typeof customMerge === "function" ? customMerge : deepmerge;
                  }
                  function getEnumerableOwnPropertySymbols(target) {
                    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
                      return target.propertyIsEnumerable(symbol);
                    }) : [];
                  }
                  function getKeys(target) {
                    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
                  }
                  function propertyIsOnObject(object, property) {
                    try {
                      return property in object;
                    } catch (_2) {
                      return false;
                    }
                  }
                  function propertyIsUnsafe(target, key) {
                    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
                  }
                  function mergeObject(target, source, options) {
                    var destination = {};
                    if (options.isMergeableObject(target)) {
                      getKeys(target).forEach(function(key) {
                        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
                      });
                    }
                    getKeys(source).forEach(function(key) {
                      if (propertyIsUnsafe(target, key)) {
                        return;
                      }
                      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
                        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
                      } else {
                        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
                      }
                    });
                    return destination;
                  }
                  function deepmerge(target, source, options) {
                    options = options || {};
                    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
                    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
                    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
                    var sourceIsArray = Array.isArray(source);
                    var targetIsArray = Array.isArray(target);
                    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
                    if (!sourceAndTargetTypesMatch) {
                      return cloneUnlessOtherwiseSpecified(source, options);
                    } else if (sourceIsArray) {
                      return options.arrayMerge(target, source, options);
                    } else {
                      return mergeObject(target, source, options);
                    }
                  }
                  deepmerge.all = function deepmergeAll(array2, options) {
                    if (!Array.isArray(array2)) {
                      throw new Error("first argument should be an array");
                    }
                    return array2.reduce(function(prev, next) {
                      return deepmerge(prev, next, options);
                    }, {});
                  };
                  var deepmerge_1 = deepmerge;
                  module2.exports = deepmerge_1;
                }
              ),
              /***/
              221: (
                /***/
                function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
                  __webpack_require__2.r(__webpack_exports__2);
                  __webpack_require__2.d(__webpack_exports__2, {
                    /* harmony export */
                    "default": function() {
                      return (
                        /* binding */
                        Fuse
                      );
                    }
                    /* harmony export */
                  });
                  function isArray2(value2) {
                    return !Array.isArray ? getTag(value2) === "[object Array]" : Array.isArray(value2);
                  }
                  const INFINITY = 1 / 0;
                  function baseToString(value2) {
                    if (typeof value2 == "string") {
                      return value2;
                    }
                    let result = value2 + "";
                    return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
                  }
                  function toString2(value2) {
                    return value2 == null ? "" : baseToString(value2);
                  }
                  function isString3(value2) {
                    return typeof value2 === "string";
                  }
                  function isNumber3(value2) {
                    return typeof value2 === "number";
                  }
                  function isBoolean2(value2) {
                    return value2 === true || value2 === false || isObjectLike2(value2) && getTag(value2) == "[object Boolean]";
                  }
                  function isObject4(value2) {
                    return typeof value2 === "object";
                  }
                  function isObjectLike2(value2) {
                    return isObject4(value2) && value2 !== null;
                  }
                  function isDefined(value2) {
                    return value2 !== void 0 && value2 !== null;
                  }
                  function isBlank(value2) {
                    return !value2.trim().length;
                  }
                  function getTag(value2) {
                    return value2 == null ? value2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value2);
                  }
                  const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
                  const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
                  const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
                  const PATTERN_LENGTH_TOO_LARGE = (max11) => `Pattern length exceeds max of ${max11}.`;
                  const MISSING_KEY_PROPERTY = (name2) => `Missing ${name2} property in key`;
                  const INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
                  const hasOwn2 = Object.prototype.hasOwnProperty;
                  class KeyStore {
                    constructor(keys2) {
                      this._keys = [];
                      this._keyMap = {};
                      let totalWeight = 0;
                      keys2.forEach((key) => {
                        let obj = createKey2(key);
                        totalWeight += obj.weight;
                        this._keys.push(obj);
                        this._keyMap[obj.id] = obj;
                        totalWeight += obj.weight;
                      });
                      this._keys.forEach((key) => {
                        key.weight /= totalWeight;
                      });
                    }
                    get(keyId) {
                      return this._keyMap[keyId];
                    }
                    keys() {
                      return this._keys;
                    }
                    toJSON() {
                      return JSON.stringify(this._keys);
                    }
                  }
                  function createKey2(key) {
                    let path2 = null;
                    let id5 = null;
                    let src = null;
                    let weight2 = 1;
                    let getFn = null;
                    if (isString3(key) || isArray2(key)) {
                      src = key;
                      path2 = createKeyPath(key);
                      id5 = createKeyId(key);
                    } else {
                      if (!hasOwn2.call(key, "name")) {
                        throw new Error(MISSING_KEY_PROPERTY("name"));
                      }
                      const name2 = key.name;
                      src = name2;
                      if (hasOwn2.call(key, "weight")) {
                        weight2 = key.weight;
                        if (weight2 <= 0) {
                          throw new Error(INVALID_KEY_WEIGHT_VALUE(name2));
                        }
                      }
                      path2 = createKeyPath(name2);
                      id5 = createKeyId(name2);
                      getFn = key.getFn;
                    }
                    return { path: path2, id: id5, weight: weight2, src, getFn };
                  }
                  function createKeyPath(key) {
                    return isArray2(key) ? key : key.split(".");
                  }
                  function createKeyId(key) {
                    return isArray2(key) ? key.join(".") : key;
                  }
                  function get2(obj, path2) {
                    let list = [];
                    let arr = false;
                    const deepGet = (obj2, path3, index4) => {
                      if (!isDefined(obj2)) {
                        return;
                      }
                      if (!path3[index4]) {
                        list.push(obj2);
                      } else {
                        let key = path3[index4];
                        const value2 = obj2[key];
                        if (!isDefined(value2)) {
                          return;
                        }
                        if (index4 === path3.length - 1 && (isString3(value2) || isNumber3(value2) || isBoolean2(value2))) {
                          list.push(toString2(value2));
                        } else if (isArray2(value2)) {
                          arr = true;
                          for (let i = 0, len5 = value2.length; i < len5; i += 1) {
                            deepGet(value2[i], path3, index4 + 1);
                          }
                        } else if (path3.length) {
                          deepGet(value2, path3, index4 + 1);
                        }
                      }
                    };
                    deepGet(obj, isString3(path2) ? path2.split(".") : path2, 0);
                    return arr ? list : list[0];
                  }
                  const MatchOptions = {
                    // Whether the matches should be included in the result set. When `true`, each record in the result
                    // set will include the indices of the matched characters.
                    // These can consequently be used for highlighting purposes.
                    includeMatches: false,
                    // When `true`, the matching function will continue to the end of a search pattern even if
                    // a perfect match has already been located in the string.
                    findAllMatches: false,
                    // Minimum number of characters that must be matched before a result is considered a match
                    minMatchCharLength: 1
                  };
                  const BasicOptions = {
                    // When `true`, the algorithm continues searching to the end of the input even if a perfect
                    // match is found before the end of the same input.
                    isCaseSensitive: false,
                    // When true, the matching function will continue to the end of a search pattern even if
                    includeScore: false,
                    // List of properties that will be searched. This also supports nested properties.
                    keys: [],
                    // Whether to sort the result list, by score
                    shouldSort: true,
                    // Default sort function: sort by ascending score, ascending index
                    sortFn: (a3, b) => a3.score === b.score ? a3.idx < b.idx ? -1 : 1 : a3.score < b.score ? -1 : 1
                  };
                  const FuzzyOptions = {
                    // Approximately where in the text is the pattern expected to be found?
                    location: 0,
                    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
                    // (of both letters and location), a threshold of '1.0' would match anything.
                    threshold: 0.6,
                    // Determines how close the match must be to the fuzzy location (specified above).
                    // An exact letter match which is 'distance' characters away from the fuzzy location
                    // would score as a complete mismatch. A distance of '0' requires the match be at
                    // the exact location specified, a threshold of '1000' would require a perfect match
                    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
                    distance: 100
                  };
                  const AdvancedOptions = {
                    // When `true`, it enables the use of unix-like search commands
                    useExtendedSearch: false,
                    // The get function to use when fetching an object's properties.
                    // The default will search nested paths *ie foo.bar.baz*
                    getFn: get2,
                    // When `true`, search will ignore `location` and `distance`, so it won't matter
                    // where in the string the pattern appears.
                    // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
                    ignoreLocation: false,
                    // When `true`, the calculation for the relevance score (used for sorting) will
                    // ignore the field-length norm.
                    // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
                    ignoreFieldNorm: false,
                    // The weight to determine how much field length norm effects scoring.
                    fieldNormWeight: 1
                  };
                  var Config2 = {
                    ...BasicOptions,
                    ...MatchOptions,
                    ...FuzzyOptions,
                    ...AdvancedOptions
                  };
                  const SPACE = /[^ ]+/g;
                  function norm(weight2 = 1, mantissa = 3) {
                    const cache3 = /* @__PURE__ */ new Map();
                    const m3 = Math.pow(10, mantissa);
                    return {
                      get(value2) {
                        const numTokens = value2.match(SPACE).length;
                        if (cache3.has(numTokens)) {
                          return cache3.get(numTokens);
                        }
                        const norm3 = 1 / Math.pow(numTokens, 0.5 * weight2);
                        const n2 = parseFloat(Math.round(norm3 * m3) / m3);
                        cache3.set(numTokens, n2);
                        return n2;
                      },
                      clear() {
                        cache3.clear();
                      }
                    };
                  }
                  class FuseIndex {
                    constructor({
                      getFn = Config2.getFn,
                      fieldNormWeight = Config2.fieldNormWeight
                    } = {}) {
                      this.norm = norm(fieldNormWeight, 3);
                      this.getFn = getFn;
                      this.isCreated = false;
                      this.setIndexRecords();
                    }
                    setSources(docs = []) {
                      this.docs = docs;
                    }
                    setIndexRecords(records = []) {
                      this.records = records;
                    }
                    setKeys(keys2 = []) {
                      this.keys = keys2;
                      this._keysMap = {};
                      keys2.forEach((key, idx) => {
                        this._keysMap[key.id] = idx;
                      });
                    }
                    create() {
                      if (this.isCreated || !this.docs.length) {
                        return;
                      }
                      this.isCreated = true;
                      if (isString3(this.docs[0])) {
                        this.docs.forEach((doc, docIndex) => {
                          this._addString(doc, docIndex);
                        });
                      } else {
                        this.docs.forEach((doc, docIndex) => {
                          this._addObject(doc, docIndex);
                        });
                      }
                      this.norm.clear();
                    }
                    // Adds a doc to the end of the index
                    add(doc) {
                      const idx = this.size();
                      if (isString3(doc)) {
                        this._addString(doc, idx);
                      } else {
                        this._addObject(doc, idx);
                      }
                    }
                    // Removes the doc at the specified index of the index
                    removeAt(idx) {
                      this.records.splice(idx, 1);
                      for (let i = idx, len5 = this.size(); i < len5; i += 1) {
                        this.records[i].i -= 1;
                      }
                    }
                    getValueForItemAtKeyId(item, keyId) {
                      return item[this._keysMap[keyId]];
                    }
                    size() {
                      return this.records.length;
                    }
                    _addString(doc, docIndex) {
                      if (!isDefined(doc) || isBlank(doc)) {
                        return;
                      }
                      let record = {
                        v: doc,
                        i: docIndex,
                        n: this.norm.get(doc)
                      };
                      this.records.push(record);
                    }
                    _addObject(doc, docIndex) {
                      let record = { i: docIndex, $: {} };
                      this.keys.forEach((key, keyIndex) => {
                        let value2 = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
                        if (!isDefined(value2)) {
                          return;
                        }
                        if (isArray2(value2)) {
                          let subRecords = [];
                          const stack = [{ nestedArrIndex: -1, value: value2 }];
                          while (stack.length) {
                            const { nestedArrIndex, value: value3 } = stack.pop();
                            if (!isDefined(value3)) {
                              continue;
                            }
                            if (isString3(value3) && !isBlank(value3)) {
                              let subRecord = {
                                v: value3,
                                i: nestedArrIndex,
                                n: this.norm.get(value3)
                              };
                              subRecords.push(subRecord);
                            } else if (isArray2(value3)) {
                              value3.forEach((item, k) => {
                                stack.push({
                                  nestedArrIndex: k,
                                  value: item
                                });
                              });
                            } else ;
                          }
                          record.$[keyIndex] = subRecords;
                        } else if (isString3(value2) && !isBlank(value2)) {
                          let subRecord = {
                            v: value2,
                            n: this.norm.get(value2)
                          };
                          record.$[keyIndex] = subRecord;
                        }
                      });
                      this.records.push(record);
                    }
                    toJSON() {
                      return {
                        keys: this.keys,
                        records: this.records
                      };
                    }
                  }
                  function createIndex(keys2, docs, { getFn = Config2.getFn, fieldNormWeight = Config2.fieldNormWeight } = {}) {
                    const myIndex = new FuseIndex({ getFn, fieldNormWeight });
                    myIndex.setKeys(keys2.map(createKey2));
                    myIndex.setSources(docs);
                    myIndex.create();
                    return myIndex;
                  }
                  function parseIndex(data2, { getFn = Config2.getFn, fieldNormWeight = Config2.fieldNormWeight } = {}) {
                    const { keys: keys2, records } = data2;
                    const myIndex = new FuseIndex({ getFn, fieldNormWeight });
                    myIndex.setKeys(keys2);
                    myIndex.setIndexRecords(records);
                    return myIndex;
                  }
                  function computeScore$1(pattern, {
                    errors = 0,
                    currentLocation = 0,
                    expectedLocation = 0,
                    distance: distance7 = Config2.distance,
                    ignoreLocation = Config2.ignoreLocation
                  } = {}) {
                    const accuracy = errors / pattern.length;
                    if (ignoreLocation) {
                      return accuracy;
                    }
                    const proximity = Math.abs(expectedLocation - currentLocation);
                    if (!distance7) {
                      return proximity ? 1 : accuracy;
                    }
                    return accuracy + proximity / distance7;
                  }
                  function convertMaskToIndices(matchmask = [], minMatchCharLength = Config2.minMatchCharLength) {
                    let indices = [];
                    let start2 = -1;
                    let end = -1;
                    let i = 0;
                    for (let len5 = matchmask.length; i < len5; i += 1) {
                      let match2 = matchmask[i];
                      if (match2 && start2 === -1) {
                        start2 = i;
                      } else if (!match2 && start2 !== -1) {
                        end = i - 1;
                        if (end - start2 + 1 >= minMatchCharLength) {
                          indices.push([start2, end]);
                        }
                        start2 = -1;
                      }
                    }
                    if (matchmask[i - 1] && i - start2 >= minMatchCharLength) {
                      indices.push([start2, i - 1]);
                    }
                    return indices;
                  }
                  const MAX_BITS = 32;
                  function search2(text, pattern, patternAlphabet, {
                    location: location2 = Config2.location,
                    distance: distance7 = Config2.distance,
                    threshold = Config2.threshold,
                    findAllMatches = Config2.findAllMatches,
                    minMatchCharLength = Config2.minMatchCharLength,
                    includeMatches = Config2.includeMatches,
                    ignoreLocation = Config2.ignoreLocation
                  } = {}) {
                    if (pattern.length > MAX_BITS) {
                      throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
                    }
                    const patternLen = pattern.length;
                    const textLen = text.length;
                    const expectedLocation = Math.max(0, Math.min(location2, textLen));
                    let currentThreshold = threshold;
                    let bestLocation = expectedLocation;
                    const computeMatches = minMatchCharLength > 1 || includeMatches;
                    const matchMask = computeMatches ? Array(textLen) : [];
                    let index4;
                    while ((index4 = text.indexOf(pattern, bestLocation)) > -1) {
                      let score2 = computeScore$1(pattern, {
                        currentLocation: index4,
                        expectedLocation,
                        distance: distance7,
                        ignoreLocation
                      });
                      currentThreshold = Math.min(score2, currentThreshold);
                      bestLocation = index4 + patternLen;
                      if (computeMatches) {
                        let i = 0;
                        while (i < patternLen) {
                          matchMask[index4 + i] = 1;
                          i += 1;
                        }
                      }
                    }
                    bestLocation = -1;
                    let lastBitArr = [];
                    let finalScore = 1;
                    let binMax = patternLen + textLen;
                    const mask = 1 << patternLen - 1;
                    for (let i = 0; i < patternLen; i += 1) {
                      let binMin = 0;
                      let binMid = binMax;
                      while (binMin < binMid) {
                        const score3 = computeScore$1(pattern, {
                          errors: i,
                          currentLocation: expectedLocation + binMid,
                          expectedLocation,
                          distance: distance7,
                          ignoreLocation
                        });
                        if (score3 <= currentThreshold) {
                          binMin = binMid;
                        } else {
                          binMax = binMid;
                        }
                        binMid = Math.floor((binMax - binMin) / 2 + binMin);
                      }
                      binMax = binMid;
                      let start2 = Math.max(1, expectedLocation - binMid + 1);
                      let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
                      let bitArr = Array(finish + 2);
                      bitArr[finish + 1] = (1 << i) - 1;
                      for (let j = finish; j >= start2; j -= 1) {
                        let currentLocation = j - 1;
                        let charMatch = patternAlphabet[text.charAt(currentLocation)];
                        if (computeMatches) {
                          matchMask[currentLocation] = +!!charMatch;
                        }
                        bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
                        if (i) {
                          bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
                        }
                        if (bitArr[j] & mask) {
                          finalScore = computeScore$1(pattern, {
                            errors: i,
                            currentLocation,
                            expectedLocation,
                            distance: distance7,
                            ignoreLocation
                          });
                          if (finalScore <= currentThreshold) {
                            currentThreshold = finalScore;
                            bestLocation = currentLocation;
                            if (bestLocation <= expectedLocation) {
                              break;
                            }
                            start2 = Math.max(1, 2 * expectedLocation - bestLocation);
                          }
                        }
                      }
                      const score2 = computeScore$1(pattern, {
                        errors: i + 1,
                        currentLocation: expectedLocation,
                        expectedLocation,
                        distance: distance7,
                        ignoreLocation
                      });
                      if (score2 > currentThreshold) {
                        break;
                      }
                      lastBitArr = bitArr;
                    }
                    const result = {
                      isMatch: bestLocation >= 0,
                      // Count exact matches (those with a score of 0) to be "almost" exact
                      score: Math.max(1e-3, finalScore)
                    };
                    if (computeMatches) {
                      const indices = convertMaskToIndices(matchMask, minMatchCharLength);
                      if (!indices.length) {
                        result.isMatch = false;
                      } else if (includeMatches) {
                        result.indices = indices;
                      }
                    }
                    return result;
                  }
                  function createPatternAlphabet(pattern) {
                    let mask = {};
                    for (let i = 0, len5 = pattern.length; i < len5; i += 1) {
                      const char = pattern.charAt(i);
                      mask[char] = (mask[char] || 0) | 1 << len5 - i - 1;
                    }
                    return mask;
                  }
                  class BitapSearch {
                    constructor(pattern, {
                      location: location2 = Config2.location,
                      threshold = Config2.threshold,
                      distance: distance7 = Config2.distance,
                      includeMatches = Config2.includeMatches,
                      findAllMatches = Config2.findAllMatches,
                      minMatchCharLength = Config2.minMatchCharLength,
                      isCaseSensitive = Config2.isCaseSensitive,
                      ignoreLocation = Config2.ignoreLocation
                    } = {}) {
                      this.options = {
                        location: location2,
                        threshold,
                        distance: distance7,
                        includeMatches,
                        findAllMatches,
                        minMatchCharLength,
                        isCaseSensitive,
                        ignoreLocation
                      };
                      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
                      this.chunks = [];
                      if (!this.pattern.length) {
                        return;
                      }
                      const addChunk = (pattern2, startIndex) => {
                        this.chunks.push({
                          pattern: pattern2,
                          alphabet: createPatternAlphabet(pattern2),
                          startIndex
                        });
                      };
                      const len5 = this.pattern.length;
                      if (len5 > MAX_BITS) {
                        let i = 0;
                        const remainder = len5 % MAX_BITS;
                        const end = len5 - remainder;
                        while (i < end) {
                          addChunk(this.pattern.substr(i, MAX_BITS), i);
                          i += MAX_BITS;
                        }
                        if (remainder) {
                          const startIndex = len5 - MAX_BITS;
                          addChunk(this.pattern.substr(startIndex), startIndex);
                        }
                      } else {
                        addChunk(this.pattern, 0);
                      }
                    }
                    searchIn(text) {
                      const { isCaseSensitive, includeMatches } = this.options;
                      if (!isCaseSensitive) {
                        text = text.toLowerCase();
                      }
                      if (this.pattern === text) {
                        let result2 = {
                          isMatch: true,
                          score: 0
                        };
                        if (includeMatches) {
                          result2.indices = [[0, text.length - 1]];
                        }
                        return result2;
                      }
                      const {
                        location: location2,
                        distance: distance7,
                        threshold,
                        findAllMatches,
                        minMatchCharLength,
                        ignoreLocation
                      } = this.options;
                      let allIndices = [];
                      let totalScore = 0;
                      let hasMatches = false;
                      this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
                        const { isMatch: isMatch2, score: score2, indices } = search2(text, pattern, alphabet, {
                          location: location2 + startIndex,
                          distance: distance7,
                          threshold,
                          findAllMatches,
                          minMatchCharLength,
                          includeMatches,
                          ignoreLocation
                        });
                        if (isMatch2) {
                          hasMatches = true;
                        }
                        totalScore += score2;
                        if (isMatch2 && indices) {
                          allIndices = [...allIndices, ...indices];
                        }
                      });
                      let result = {
                        isMatch: hasMatches,
                        score: hasMatches ? totalScore / this.chunks.length : 1
                      };
                      if (hasMatches && includeMatches) {
                        result.indices = allIndices;
                      }
                      return result;
                    }
                  }
                  class BaseMatch {
                    constructor(pattern) {
                      this.pattern = pattern;
                    }
                    static isMultiMatch(pattern) {
                      return getMatch(pattern, this.multiRegex);
                    }
                    static isSingleMatch(pattern) {
                      return getMatch(pattern, this.singleRegex);
                    }
                    search() {
                    }
                  }
                  function getMatch(pattern, exp3) {
                    const matches2 = pattern.match(exp3);
                    return matches2 ? matches2[1] : null;
                  }
                  class ExactMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "exact";
                    }
                    static get multiRegex() {
                      return /^="(.*)"$/;
                    }
                    static get singleRegex() {
                      return /^=(.*)$/;
                    }
                    search(text) {
                      const isMatch2 = text === this.pattern;
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices: [0, this.pattern.length - 1]
                      };
                    }
                  }
                  class InverseExactMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "inverse-exact";
                    }
                    static get multiRegex() {
                      return /^!"(.*)"$/;
                    }
                    static get singleRegex() {
                      return /^!(.*)$/;
                    }
                    search(text) {
                      const index4 = text.indexOf(this.pattern);
                      const isMatch2 = index4 === -1;
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices: [0, text.length - 1]
                      };
                    }
                  }
                  class PrefixExactMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "prefix-exact";
                    }
                    static get multiRegex() {
                      return /^\^"(.*)"$/;
                    }
                    static get singleRegex() {
                      return /^\^(.*)$/;
                    }
                    search(text) {
                      const isMatch2 = text.startsWith(this.pattern);
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices: [0, this.pattern.length - 1]
                      };
                    }
                  }
                  class InversePrefixExactMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "inverse-prefix-exact";
                    }
                    static get multiRegex() {
                      return /^!\^"(.*)"$/;
                    }
                    static get singleRegex() {
                      return /^!\^(.*)$/;
                    }
                    search(text) {
                      const isMatch2 = !text.startsWith(this.pattern);
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices: [0, text.length - 1]
                      };
                    }
                  }
                  class SuffixExactMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "suffix-exact";
                    }
                    static get multiRegex() {
                      return /^"(.*)"\$$/;
                    }
                    static get singleRegex() {
                      return /^(.*)\$$/;
                    }
                    search(text) {
                      const isMatch2 = text.endsWith(this.pattern);
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices: [text.length - this.pattern.length, text.length - 1]
                      };
                    }
                  }
                  class InverseSuffixExactMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "inverse-suffix-exact";
                    }
                    static get multiRegex() {
                      return /^!"(.*)"\$$/;
                    }
                    static get singleRegex() {
                      return /^!(.*)\$$/;
                    }
                    search(text) {
                      const isMatch2 = !text.endsWith(this.pattern);
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices: [0, text.length - 1]
                      };
                    }
                  }
                  class FuzzyMatch extends BaseMatch {
                    constructor(pattern, {
                      location: location2 = Config2.location,
                      threshold = Config2.threshold,
                      distance: distance7 = Config2.distance,
                      includeMatches = Config2.includeMatches,
                      findAllMatches = Config2.findAllMatches,
                      minMatchCharLength = Config2.minMatchCharLength,
                      isCaseSensitive = Config2.isCaseSensitive,
                      ignoreLocation = Config2.ignoreLocation
                    } = {}) {
                      super(pattern);
                      this._bitapSearch = new BitapSearch(pattern, {
                        location: location2,
                        threshold,
                        distance: distance7,
                        includeMatches,
                        findAllMatches,
                        minMatchCharLength,
                        isCaseSensitive,
                        ignoreLocation
                      });
                    }
                    static get type() {
                      return "fuzzy";
                    }
                    static get multiRegex() {
                      return /^"(.*)"$/;
                    }
                    static get singleRegex() {
                      return /^(.*)$/;
                    }
                    search(text) {
                      return this._bitapSearch.searchIn(text);
                    }
                  }
                  class IncludeMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "include";
                    }
                    static get multiRegex() {
                      return /^'"(.*)"$/;
                    }
                    static get singleRegex() {
                      return /^'(.*)$/;
                    }
                    search(text) {
                      let location2 = 0;
                      let index4;
                      const indices = [];
                      const patternLen = this.pattern.length;
                      while ((index4 = text.indexOf(this.pattern, location2)) > -1) {
                        location2 = index4 + patternLen;
                        indices.push([index4, location2 - 1]);
                      }
                      const isMatch2 = !!indices.length;
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices
                      };
                    }
                  }
                  const searchers = [
                    ExactMatch,
                    IncludeMatch,
                    PrefixExactMatch,
                    InversePrefixExactMatch,
                    InverseSuffixExactMatch,
                    SuffixExactMatch,
                    InverseExactMatch,
                    FuzzyMatch
                  ];
                  const searchersLen = searchers.length;
                  const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
                  const OR_TOKEN = "|";
                  function parseQuery(pattern, options = {}) {
                    return pattern.split(OR_TOKEN).map((item) => {
                      let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
                      let results = [];
                      for (let i = 0, len5 = query.length; i < len5; i += 1) {
                        const queryItem = query[i];
                        let found = false;
                        let idx = -1;
                        while (!found && ++idx < searchersLen) {
                          const searcher = searchers[idx];
                          let token2 = searcher.isMultiMatch(queryItem);
                          if (token2) {
                            results.push(new searcher(token2, options));
                            found = true;
                          }
                        }
                        if (found) {
                          continue;
                        }
                        idx = -1;
                        while (++idx < searchersLen) {
                          const searcher = searchers[idx];
                          let token2 = searcher.isSingleMatch(queryItem);
                          if (token2) {
                            results.push(new searcher(token2, options));
                            break;
                          }
                        }
                      }
                      return results;
                    });
                  }
                  const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
                  class ExtendedSearch {
                    constructor(pattern, {
                      isCaseSensitive = Config2.isCaseSensitive,
                      includeMatches = Config2.includeMatches,
                      minMatchCharLength = Config2.minMatchCharLength,
                      ignoreLocation = Config2.ignoreLocation,
                      findAllMatches = Config2.findAllMatches,
                      location: location2 = Config2.location,
                      threshold = Config2.threshold,
                      distance: distance7 = Config2.distance
                    } = {}) {
                      this.query = null;
                      this.options = {
                        isCaseSensitive,
                        includeMatches,
                        minMatchCharLength,
                        findAllMatches,
                        ignoreLocation,
                        location: location2,
                        threshold,
                        distance: distance7
                      };
                      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
                      this.query = parseQuery(this.pattern, this.options);
                    }
                    static condition(_2, options) {
                      return options.useExtendedSearch;
                    }
                    searchIn(text) {
                      const query = this.query;
                      if (!query) {
                        return {
                          isMatch: false,
                          score: 1
                        };
                      }
                      const { includeMatches, isCaseSensitive } = this.options;
                      text = isCaseSensitive ? text : text.toLowerCase();
                      let numMatches = 0;
                      let allIndices = [];
                      let totalScore = 0;
                      for (let i = 0, qLen = query.length; i < qLen; i += 1) {
                        const searchers2 = query[i];
                        allIndices.length = 0;
                        numMatches = 0;
                        for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
                          const searcher = searchers2[j];
                          const { isMatch: isMatch2, indices, score: score2 } = searcher.search(text);
                          if (isMatch2) {
                            numMatches += 1;
                            totalScore += score2;
                            if (includeMatches) {
                              const type = searcher.constructor.type;
                              if (MultiMatchSet.has(type)) {
                                allIndices = [...allIndices, ...indices];
                              } else {
                                allIndices.push(indices);
                              }
                            }
                          } else {
                            totalScore = 0;
                            numMatches = 0;
                            allIndices.length = 0;
                            break;
                          }
                        }
                        if (numMatches) {
                          let result = {
                            isMatch: true,
                            score: totalScore / numMatches
                          };
                          if (includeMatches) {
                            result.indices = allIndices;
                          }
                          return result;
                        }
                      }
                      return {
                        isMatch: false,
                        score: 1
                      };
                    }
                  }
                  const registeredSearchers = [];
                  function register(...args) {
                    registeredSearchers.push(...args);
                  }
                  function createSearcher(pattern, options) {
                    for (let i = 0, len5 = registeredSearchers.length; i < len5; i += 1) {
                      let searcherClass = registeredSearchers[i];
                      if (searcherClass.condition(pattern, options)) {
                        return new searcherClass(pattern, options);
                      }
                    }
                    return new BitapSearch(pattern, options);
                  }
                  const LogicalOperator = {
                    AND: "$and",
                    OR: "$or"
                  };
                  const KeyType = {
                    PATH: "$path",
                    PATTERN: "$val"
                  };
                  const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
                  const isPath = (query) => !!query[KeyType.PATH];
                  const isLeaf = (query) => !isArray2(query) && isObject4(query) && !isExpression(query);
                  const convertToExplicit = (query) => ({
                    [LogicalOperator.AND]: Object.keys(query).map((key) => ({
                      [key]: query[key]
                    }))
                  });
                  function parse2(query, options, { auto = true } = {}) {
                    const next = (query2) => {
                      let keys2 = Object.keys(query2);
                      const isQueryPath = isPath(query2);
                      if (!isQueryPath && keys2.length > 1 && !isExpression(query2)) {
                        return next(convertToExplicit(query2));
                      }
                      if (isLeaf(query2)) {
                        const key = isQueryPath ? query2[KeyType.PATH] : keys2[0];
                        const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
                        if (!isString3(pattern)) {
                          throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
                        }
                        const obj = {
                          keyId: createKeyId(key),
                          pattern
                        };
                        if (auto) {
                          obj.searcher = createSearcher(pattern, options);
                        }
                        return obj;
                      }
                      let node = {
                        children: [],
                        operator: keys2[0]
                      };
                      keys2.forEach((key) => {
                        const value2 = query2[key];
                        if (isArray2(value2)) {
                          value2.forEach((item) => {
                            node.children.push(next(item));
                          });
                        }
                      });
                      return node;
                    };
                    if (!isExpression(query)) {
                      query = convertToExplicit(query);
                    }
                    return next(query);
                  }
                  function computeScore(results, { ignoreFieldNorm = Config2.ignoreFieldNorm }) {
                    results.forEach((result) => {
                      let totalScore = 1;
                      result.matches.forEach(({ key, norm: norm3, score: score2 }) => {
                        const weight2 = key ? key.weight : null;
                        totalScore *= Math.pow(
                          score2 === 0 && weight2 ? Number.EPSILON : score2,
                          (weight2 || 1) * (ignoreFieldNorm ? 1 : norm3)
                        );
                      });
                      result.score = totalScore;
                    });
                  }
                  function transformMatches(result, data2) {
                    const matches2 = result.matches;
                    data2.matches = [];
                    if (!isDefined(matches2)) {
                      return;
                    }
                    matches2.forEach((match2) => {
                      if (!isDefined(match2.indices) || !match2.indices.length) {
                        return;
                      }
                      const { indices, value: value2 } = match2;
                      let obj = {
                        indices,
                        value: value2
                      };
                      if (match2.key) {
                        obj.key = match2.key.src;
                      }
                      if (match2.idx > -1) {
                        obj.refIndex = match2.idx;
                      }
                      data2.matches.push(obj);
                    });
                  }
                  function transformScore(result, data2) {
                    data2.score = result.score;
                  }
                  function format3(results, docs, {
                    includeMatches = Config2.includeMatches,
                    includeScore = Config2.includeScore
                  } = {}) {
                    const transformers = [];
                    if (includeMatches) transformers.push(transformMatches);
                    if (includeScore) transformers.push(transformScore);
                    return results.map((result) => {
                      const { idx } = result;
                      const data2 = {
                        item: docs[idx],
                        refIndex: idx
                      };
                      if (transformers.length) {
                        transformers.forEach((transformer2) => {
                          transformer2(result, data2);
                        });
                      }
                      return data2;
                    });
                  }
                  class Fuse {
                    constructor(docs, options = {}, index4) {
                      this.options = { ...Config2, ...options };
                      if (this.options.useExtendedSearch && false) {
                      }
                      this._keyStore = new KeyStore(this.options.keys);
                      this.setCollection(docs, index4);
                    }
                    setCollection(docs, index4) {
                      this._docs = docs;
                      if (index4 && !(index4 instanceof FuseIndex)) {
                        throw new Error(INCORRECT_INDEX_TYPE);
                      }
                      this._myIndex = index4 || createIndex(this.options.keys, this._docs, {
                        getFn: this.options.getFn,
                        fieldNormWeight: this.options.fieldNormWeight
                      });
                    }
                    add(doc) {
                      if (!isDefined(doc)) {
                        return;
                      }
                      this._docs.push(doc);
                      this._myIndex.add(doc);
                    }
                    remove(predicate = () => false) {
                      const results = [];
                      for (let i = 0, len5 = this._docs.length; i < len5; i += 1) {
                        const doc = this._docs[i];
                        if (predicate(doc, i)) {
                          this.removeAt(i);
                          i -= 1;
                          len5 -= 1;
                          results.push(doc);
                        }
                      }
                      return results;
                    }
                    removeAt(idx) {
                      this._docs.splice(idx, 1);
                      this._myIndex.removeAt(idx);
                    }
                    getIndex() {
                      return this._myIndex;
                    }
                    search(query, { limit = -1 } = {}) {
                      const {
                        includeMatches,
                        includeScore,
                        shouldSort,
                        sortFn,
                        ignoreFieldNorm
                      } = this.options;
                      let results = isString3(query) ? isString3(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
                      computeScore(results, { ignoreFieldNorm });
                      if (shouldSort) {
                        results.sort(sortFn);
                      }
                      if (isNumber3(limit) && limit > -1) {
                        results = results.slice(0, limit);
                      }
                      return format3(results, this._docs, {
                        includeMatches,
                        includeScore
                      });
                    }
                    _searchStringList(query) {
                      const searcher = createSearcher(query, this.options);
                      const { records } = this._myIndex;
                      const results = [];
                      records.forEach(({ v: text, i: idx, n: norm3 }) => {
                        if (!isDefined(text)) {
                          return;
                        }
                        const { isMatch: isMatch2, score: score2, indices } = searcher.searchIn(text);
                        if (isMatch2) {
                          results.push({
                            item: text,
                            idx,
                            matches: [{ score: score2, value: text, norm: norm3, indices }]
                          });
                        }
                      });
                      return results;
                    }
                    _searchLogical(query) {
                      const expression = parse2(query, this.options);
                      const evaluate = (node, item, idx) => {
                        if (!node.children) {
                          const { keyId, searcher } = node;
                          const matches2 = this._findMatches({
                            key: this._keyStore.get(keyId),
                            value: this._myIndex.getValueForItemAtKeyId(item, keyId),
                            searcher
                          });
                          if (matches2 && matches2.length) {
                            return [
                              {
                                idx,
                                item,
                                matches: matches2
                              }
                            ];
                          }
                          return [];
                        }
                        const res = [];
                        for (let i = 0, len5 = node.children.length; i < len5; i += 1) {
                          const child = node.children[i];
                          const result = evaluate(child, item, idx);
                          if (result.length) {
                            res.push(...result);
                          } else if (node.operator === LogicalOperator.AND) {
                            return [];
                          }
                        }
                        return res;
                      };
                      const records = this._myIndex.records;
                      const resultMap = {};
                      const results = [];
                      records.forEach(({ $: item, i: idx }) => {
                        if (isDefined(item)) {
                          let expResults = evaluate(expression, item, idx);
                          if (expResults.length) {
                            if (!resultMap[idx]) {
                              resultMap[idx] = { idx, item, matches: [] };
                              results.push(resultMap[idx]);
                            }
                            expResults.forEach(({ matches: matches2 }) => {
                              resultMap[idx].matches.push(...matches2);
                            });
                          }
                        }
                      });
                      return results;
                    }
                    _searchObjectList(query) {
                      const searcher = createSearcher(query, this.options);
                      const { keys: keys2, records } = this._myIndex;
                      const results = [];
                      records.forEach(({ $: item, i: idx }) => {
                        if (!isDefined(item)) {
                          return;
                        }
                        let matches2 = [];
                        keys2.forEach((key, keyIndex) => {
                          matches2.push(
                            ...this._findMatches({
                              key,
                              value: item[keyIndex],
                              searcher
                            })
                          );
                        });
                        if (matches2.length) {
                          results.push({
                            idx,
                            item,
                            matches: matches2
                          });
                        }
                      });
                      return results;
                    }
                    _findMatches({ key, value: value2, searcher }) {
                      if (!isDefined(value2)) {
                        return [];
                      }
                      let matches2 = [];
                      if (isArray2(value2)) {
                        value2.forEach(({ v: text, i: idx, n: norm3 }) => {
                          if (!isDefined(text)) {
                            return;
                          }
                          const { isMatch: isMatch2, score: score2, indices } = searcher.searchIn(text);
                          if (isMatch2) {
                            matches2.push({
                              score: score2,
                              key,
                              value: text,
                              idx,
                              norm: norm3,
                              indices
                            });
                          }
                        });
                      } else {
                        const { v: text, n: norm3 } = value2;
                        const { isMatch: isMatch2, score: score2, indices } = searcher.searchIn(text);
                        if (isMatch2) {
                          matches2.push({ score: score2, key, value: text, norm: norm3, indices });
                        }
                      }
                      return matches2;
                    }
                  }
                  Fuse.version = "6.6.2";
                  Fuse.createIndex = createIndex;
                  Fuse.parseIndex = parseIndex;
                  Fuse.config = Config2;
                  {
                    Fuse.parseQuery = parse2;
                  }
                  {
                    register(ExtendedSearch);
                  }
                }
              ),
              /***/
              791: (
                /***/
                function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
                  __webpack_require__2.r(__webpack_exports__2);
                  __webpack_require__2.d(__webpack_exports__2, {
                    "__DO_NOT_USE__ActionTypes": function() {
                      return (
                        /* binding */
                        ActionTypes
                      );
                    },
                    "applyMiddleware": function() {
                      return (
                        /* binding */
                        applyMiddleware
                      );
                    },
                    "bindActionCreators": function() {
                      return (
                        /* binding */
                        bindActionCreators
                      );
                    },
                    "combineReducers": function() {
                      return (
                        /* binding */
                        combineReducers
                      );
                    },
                    "compose": function() {
                      return (
                        /* binding */
                        compose3
                      );
                    },
                    "createStore": function() {
                      return (
                        /* binding */
                        createStore
                      );
                    },
                    "legacy_createStore": function() {
                      return (
                        /* binding */
                        legacy_createStore
                      );
                    }
                  });
                  ;
                  function _typeof3(obj) {
                    "@babel/helpers - typeof";
                    return _typeof3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
                      return typeof obj2;
                    } : function(obj2) {
                      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    }, _typeof3(obj);
                  }
                  ;
                  function _toPrimitive(input, hint) {
                    if (_typeof3(input) !== "object" || input === null) return input;
                    var prim = input[Symbol.toPrimitive];
                    if (prim !== void 0) {
                      var res = prim.call(input, hint || "default");
                      if (_typeof3(res) !== "object") return res;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return (hint === "string" ? String : Number)(input);
                  }
                  ;
                  function _toPropertyKey(arg) {
                    var key = _toPrimitive(arg, "string");
                    return _typeof3(key) === "symbol" ? key : String(key);
                  }
                  ;
                  function _defineProperty3(obj, key, value2) {
                    key = _toPropertyKey(key);
                    if (key in obj) {
                      Object.defineProperty(obj, key, {
                        value: value2,
                        enumerable: true,
                        configurable: true,
                        writable: true
                      });
                    } else {
                      obj[key] = value2;
                    }
                    return obj;
                  }
                  ;
                  function ownKeys3(object, enumerableOnly) {
                    var keys2 = Object.keys(object);
                    if (Object.getOwnPropertySymbols) {
                      var symbols = Object.getOwnPropertySymbols(object);
                      enumerableOnly && (symbols = symbols.filter(function(sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                      })), keys2.push.apply(keys2, symbols);
                    }
                    return keys2;
                  }
                  function _objectSpread23(target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = null != arguments[i] ? arguments[i] : {};
                      i % 2 ? ownKeys3(Object(source), true).forEach(function(key) {
                        _defineProperty3(target, key, source[key]);
                      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys3(Object(source)).forEach(function(key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                      });
                    }
                    return target;
                  }
                  ;
                  function formatProdErrorMessage(code) {
                    return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
                  }
                  var $$observable = function() {
                    return typeof Symbol === "function" && Symbol.observable || "@@observable";
                  }();
                  var randomString = function randomString2() {
                    return Math.random().toString(36).substring(7).split("").join(".");
                  };
                  var ActionTypes = {
                    INIT: "@@redux/INIT" + randomString(),
                    REPLACE: "@@redux/REPLACE" + randomString(),
                    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
                      return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
                    }
                  };
                  function isPlainObject2(obj) {
                    if (typeof obj !== "object" || obj === null) return false;
                    var proto = obj;
                    while (Object.getPrototypeOf(proto) !== null) {
                      proto = Object.getPrototypeOf(proto);
                    }
                    return Object.getPrototypeOf(obj) === proto;
                  }
                  function miniKindOf(val) {
                    if (val === void 0) return "undefined";
                    if (val === null) return "null";
                    var type = typeof val;
                    switch (type) {
                      case "boolean":
                      case "string":
                      case "number":
                      case "symbol":
                      case "function": {
                        return type;
                      }
                    }
                    if (Array.isArray(val)) return "array";
                    if (isDate2(val)) return "date";
                    if (isError(val)) return "error";
                    var constructorName = ctorName(val);
                    switch (constructorName) {
                      case "Symbol":
                      case "Promise":
                      case "WeakMap":
                      case "WeakSet":
                      case "Map":
                      case "Set":
                        return constructorName;
                    }
                    return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
                  }
                  function ctorName(val) {
                    return typeof val.constructor === "function" ? val.constructor.name : null;
                  }
                  function isError(val) {
                    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
                  }
                  function isDate2(val) {
                    if (val instanceof Date) return true;
                    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
                  }
                  function kindOf(val) {
                    var typeOfVal = typeof val;
                    if (false) {
                    }
                    return typeOfVal;
                  }
                  function createStore(reducer, preloadedState, enhancer) {
                    var _ref2;
                    if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
                      throw new Error(true ? formatProdErrorMessage(0) : 0);
                    }
                    if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
                      enhancer = preloadedState;
                      preloadedState = void 0;
                    }
                    if (typeof enhancer !== "undefined") {
                      if (typeof enhancer !== "function") {
                        throw new Error(true ? formatProdErrorMessage(1) : 0);
                      }
                      return enhancer(createStore)(reducer, preloadedState);
                    }
                    if (typeof reducer !== "function") {
                      throw new Error(true ? formatProdErrorMessage(2) : 0);
                    }
                    var currentReducer = reducer;
                    var currentState = preloadedState;
                    var currentListeners = [];
                    var nextListeners = currentListeners;
                    var isDispatching = false;
                    function ensureCanMutateNextListeners() {
                      if (nextListeners === currentListeners) {
                        nextListeners = currentListeners.slice();
                      }
                    }
                    function getState() {
                      if (isDispatching) {
                        throw new Error(true ? formatProdErrorMessage(3) : 0);
                      }
                      return currentState;
                    }
                    function subscribe(listener) {
                      if (typeof listener !== "function") {
                        throw new Error(true ? formatProdErrorMessage(4) : 0);
                      }
                      if (isDispatching) {
                        throw new Error(true ? formatProdErrorMessage(5) : 0);
                      }
                      var isSubscribed = true;
                      ensureCanMutateNextListeners();
                      nextListeners.push(listener);
                      return function unsubscribe() {
                        if (!isSubscribed) {
                          return;
                        }
                        if (isDispatching) {
                          throw new Error(true ? formatProdErrorMessage(6) : 0);
                        }
                        isSubscribed = false;
                        ensureCanMutateNextListeners();
                        var index4 = nextListeners.indexOf(listener);
                        nextListeners.splice(index4, 1);
                        currentListeners = null;
                      };
                    }
                    function dispatch3(action) {
                      if (!isPlainObject2(action)) {
                        throw new Error(true ? formatProdErrorMessage(7) : 0);
                      }
                      if (typeof action.type === "undefined") {
                        throw new Error(true ? formatProdErrorMessage(8) : 0);
                      }
                      if (isDispatching) {
                        throw new Error(true ? formatProdErrorMessage(9) : 0);
                      }
                      try {
                        isDispatching = true;
                        currentState = currentReducer(currentState, action);
                      } finally {
                        isDispatching = false;
                      }
                      var listeners = currentListeners = nextListeners;
                      for (var i = 0; i < listeners.length; i++) {
                        var listener = listeners[i];
                        listener();
                      }
                      return action;
                    }
                    function replaceReducer(nextReducer) {
                      if (typeof nextReducer !== "function") {
                        throw new Error(true ? formatProdErrorMessage(10) : 0);
                      }
                      currentReducer = nextReducer;
                      dispatch3({
                        type: ActionTypes.REPLACE
                      });
                    }
                    function observable() {
                      var _ref;
                      var outerSubscribe = subscribe;
                      return _ref = {
                        /**
                         * The minimal observable subscription method.
                         * @param {Object} observer Any object that can be used as an observer.
                         * The observer object should have a `next` method.
                         * @returns {subscription} An object with an `unsubscribe` method that can
                         * be used to unsubscribe the observable from the store, and prevent further
                         * emission of values from the observable.
                         */
                        subscribe: function subscribe2(observer) {
                          if (typeof observer !== "object" || observer === null) {
                            throw new Error(true ? formatProdErrorMessage(11) : 0);
                          }
                          function observeState() {
                            if (observer.next) {
                              observer.next(getState());
                            }
                          }
                          observeState();
                          var unsubscribe = outerSubscribe(observeState);
                          return {
                            unsubscribe
                          };
                        }
                      }, _ref[$$observable] = function() {
                        return this;
                      }, _ref;
                    }
                    dispatch3({
                      type: ActionTypes.INIT
                    });
                    return _ref2 = {
                      dispatch: dispatch3,
                      subscribe,
                      getState,
                      replaceReducer
                    }, _ref2[$$observable] = observable, _ref2;
                  }
                  var legacy_createStore = createStore;
                  function warning(message) {
                    if (typeof console !== "undefined" && typeof console.error === "function") {
                      console.error(message);
                    }
                    try {
                      throw new Error(message);
                    } catch (e3) {
                    }
                  }
                  function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
                    var reducerKeys = Object.keys(reducers);
                    var argumentName = action && action.type === ActionTypes.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
                    if (reducerKeys.length === 0) {
                      return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
                    }
                    if (!isPlainObject2(inputState)) {
                      return "The " + argumentName + ' has unexpected type of "' + kindOf(inputState) + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
                    }
                    var unexpectedKeys = Object.keys(inputState).filter(function(key) {
                      return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
                    });
                    unexpectedKeys.forEach(function(key) {
                      unexpectedKeyCache[key] = true;
                    });
                    if (action && action.type === ActionTypes.REPLACE) return;
                    if (unexpectedKeys.length > 0) {
                      return "Unexpected " + (unexpectedKeys.length > 1 ? "keys" : "key") + " " + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
                    }
                  }
                  function assertReducerShape(reducers) {
                    Object.keys(reducers).forEach(function(key) {
                      var reducer = reducers[key];
                      var initialState = reducer(void 0, {
                        type: ActionTypes.INIT
                      });
                      if (typeof initialState === "undefined") {
                        throw new Error(true ? formatProdErrorMessage(12) : 0);
                      }
                      if (typeof reducer(void 0, {
                        type: ActionTypes.PROBE_UNKNOWN_ACTION()
                      }) === "undefined") {
                        throw new Error(true ? formatProdErrorMessage(13) : 0);
                      }
                    });
                  }
                  function combineReducers(reducers) {
                    var reducerKeys = Object.keys(reducers);
                    var finalReducers = {};
                    for (var i = 0; i < reducerKeys.length; i++) {
                      var key = reducerKeys[i];
                      if (false) {
                      }
                      if (typeof reducers[key] === "function") {
                        finalReducers[key] = reducers[key];
                      }
                    }
                    var finalReducerKeys = Object.keys(finalReducers);
                    var unexpectedKeyCache;
                    if (false) {
                    }
                    var shapeAssertionError;
                    try {
                      assertReducerShape(finalReducers);
                    } catch (e3) {
                      shapeAssertionError = e3;
                    }
                    return function combination(state, action) {
                      if (state === void 0) {
                        state = {};
                      }
                      if (shapeAssertionError) {
                        throw shapeAssertionError;
                      }
                      if (false) {
                        var warningMessage;
                      }
                      var hasChanged = false;
                      var nextState = {};
                      for (var _i = 0; _i < finalReducerKeys.length; _i++) {
                        var _key = finalReducerKeys[_i];
                        var reducer = finalReducers[_key];
                        var previousStateForKey = state[_key];
                        var nextStateForKey = reducer(previousStateForKey, action);
                        if (typeof nextStateForKey === "undefined") {
                          var actionType = action && action.type;
                          throw new Error(true ? formatProdErrorMessage(14) : 0);
                        }
                        nextState[_key] = nextStateForKey;
                        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
                      }
                      hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
                      return hasChanged ? nextState : state;
                    };
                  }
                  function bindActionCreator(actionCreator, dispatch3) {
                    return function() {
                      return dispatch3(actionCreator.apply(this, arguments));
                    };
                  }
                  function bindActionCreators(actionCreators, dispatch3) {
                    if (typeof actionCreators === "function") {
                      return bindActionCreator(actionCreators, dispatch3);
                    }
                    if (typeof actionCreators !== "object" || actionCreators === null) {
                      throw new Error(true ? formatProdErrorMessage(16) : 0);
                    }
                    var boundActionCreators = {};
                    for (var key in actionCreators) {
                      var actionCreator = actionCreators[key];
                      if (typeof actionCreator === "function") {
                        boundActionCreators[key] = bindActionCreator(actionCreator, dispatch3);
                      }
                    }
                    return boundActionCreators;
                  }
                  function compose3() {
                    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
                      funcs[_key] = arguments[_key];
                    }
                    if (funcs.length === 0) {
                      return function(arg) {
                        return arg;
                      };
                    }
                    if (funcs.length === 1) {
                      return funcs[0];
                    }
                    return funcs.reduce(function(a3, b) {
                      return function() {
                        return a3(b.apply(void 0, arguments));
                      };
                    });
                  }
                  function applyMiddleware() {
                    for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
                      middlewares[_key] = arguments[_key];
                    }
                    return function(createStore2) {
                      return function() {
                        var store = createStore2.apply(void 0, arguments);
                        var _dispatch = function dispatch3() {
                          throw new Error(true ? formatProdErrorMessage(15) : 0);
                        };
                        var middlewareAPI = {
                          getState: store.getState,
                          dispatch: function dispatch3() {
                            return _dispatch.apply(void 0, arguments);
                          }
                        };
                        var chain = middlewares.map(function(middleware) {
                          return middleware(middlewareAPI);
                        });
                        _dispatch = compose3.apply(void 0, chain)(store.dispatch);
                        return _objectSpread23(_objectSpread23({}, store), {}, {
                          dispatch: _dispatch
                        });
                      };
                    };
                  }
                  function isCrushed() {
                  }
                  if (false) {
                  }
                }
              )
              /******/
            };
            var __webpack_module_cache__ = {};
            function __webpack_require__(moduleId) {
              var cachedModule = __webpack_module_cache__[moduleId];
              if (cachedModule !== void 0) {
                return cachedModule.exports;
              }
              var module2 = __webpack_module_cache__[moduleId] = {
                /******/
                // no module.id needed
                /******/
                // no module.loaded needed
                /******/
                exports: {}
                /******/
              };
              __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
              return module2.exports;
            }
            !function() {
              __webpack_require__.n = function(module2) {
                var getter = module2 && module2.__esModule ? (
                  /******/
                  function() {
                    return module2["default"];
                  }
                ) : (
                  /******/
                  function() {
                    return module2;
                  }
                );
                __webpack_require__.d(getter, { a: getter });
                return getter;
              };
            }();
            !function() {
              __webpack_require__.d = function(exports2, definition) {
                for (var key in definition) {
                  if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                    Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                  }
                }
              };
            }();
            !function() {
              __webpack_require__.o = function(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
              };
            }();
            !function() {
              __webpack_require__.r = function(exports2) {
                if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
                }
                Object.defineProperty(exports2, "__esModule", { value: true });
              };
            }();
            var __webpack_exports__ = {};
            !function() {
              var _scripts_choices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(373);
              var _scripts_choices__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__.n(_scripts_choices__WEBPACK_IMPORTED_MODULE_0__);
              var _scripts_interfaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(187);
              var _scripts_interfaces__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__.n(_scripts_interfaces__WEBPACK_IMPORTED_MODULE_1__);
              var _scripts_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(883);
              var _scripts_defaults__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(789);
              var _scripts_templates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(686);
              __webpack_exports__["default"] = _scripts_choices__WEBPACK_IMPORTED_MODULE_0___default();
            }();
            __webpack_exports__ = __webpack_exports__["default"];
            return __webpack_exports__;
          }()
        );
      });
    }
  });

  // node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "node_modules/color-name/index.js"(exports, module) {
      "use strict";
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // node_modules/simple-swizzle/node_modules/is-arrayish/index.js
  var require_is_arrayish = __commonJS({
    "node_modules/simple-swizzle/node_modules/is-arrayish/index.js"(exports, module) {
      module.exports = function isArrayish(obj) {
        if (!obj || typeof obj === "string") {
          return false;
        }
        return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
      };
    }
  });

  // node_modules/simple-swizzle/index.js
  var require_simple_swizzle = __commonJS({
    "node_modules/simple-swizzle/index.js"(exports, module) {
      "use strict";
      var isArrayish = require_is_arrayish();
      var concat = Array.prototype.concat;
      var slice3 = Array.prototype.slice;
      var swizzle = module.exports = function swizzle2(args) {
        var results = [];
        for (var i = 0, len5 = args.length; i < len5; i++) {
          var arg = args[i];
          if (isArrayish(arg)) {
            results = concat.call(results, slice3.call(arg));
          } else {
            results.push(arg);
          }
        }
        return results;
      };
      swizzle.wrap = function(fn) {
        return function() {
          return fn(swizzle(arguments));
        };
      };
    }
  });

  // node_modules/color-string/index.js
  var require_color_string = __commonJS({
    "node_modules/color-string/index.js"(exports, module) {
      var colorNames = require_color_name();
      var swizzle = require_simple_swizzle();
      var hasOwnProperty3 = Object.hasOwnProperty;
      var reverseNames = /* @__PURE__ */ Object.create(null);
      for (name2 in colorNames) {
        if (hasOwnProperty3.call(colorNames, name2)) {
          reverseNames[colorNames[name2]] = name2;
        }
      }
      var name2;
      var cs = module.exports = {
        to: {},
        get: {}
      };
      cs.get = function(string) {
        var prefix = string.substring(0, 3).toLowerCase();
        var val;
        var model;
        switch (prefix) {
          case "hsl":
            val = cs.get.hsl(string);
            model = "hsl";
            break;
          case "hwb":
            val = cs.get.hwb(string);
            model = "hwb";
            break;
          default:
            val = cs.get.rgb(string);
            model = "rgb";
            break;
        }
        if (!val) {
          return null;
        }
        return { model, value: val };
      };
      cs.get.rgb = function(string) {
        if (!string) {
          return null;
        }
        var abbr = /^#([a-f0-9]{3,4})$/i;
        var hex2 = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
        var rgba2 = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
        var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
        var keyword = /^(\w+)$/;
        var rgb2 = [0, 0, 0, 1];
        var match2;
        var i;
        var hexAlpha;
        if (match2 = string.match(hex2)) {
          hexAlpha = match2[2];
          match2 = match2[1];
          for (i = 0; i < 3; i++) {
            var i2 = i * 2;
            rgb2[i] = parseInt(match2.slice(i2, i2 + 2), 16);
          }
          if (hexAlpha) {
            rgb2[3] = parseInt(hexAlpha, 16) / 255;
          }
        } else if (match2 = string.match(abbr)) {
          match2 = match2[1];
          hexAlpha = match2[3];
          for (i = 0; i < 3; i++) {
            rgb2[i] = parseInt(match2[i] + match2[i], 16);
          }
          if (hexAlpha) {
            rgb2[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
          }
        } else if (match2 = string.match(rgba2)) {
          for (i = 0; i < 3; i++) {
            rgb2[i] = parseInt(match2[i + 1], 0);
          }
          if (match2[4]) {
            if (match2[5]) {
              rgb2[3] = parseFloat(match2[4]) * 0.01;
            } else {
              rgb2[3] = parseFloat(match2[4]);
            }
          }
        } else if (match2 = string.match(per)) {
          for (i = 0; i < 3; i++) {
            rgb2[i] = Math.round(parseFloat(match2[i + 1]) * 2.55);
          }
          if (match2[4]) {
            if (match2[5]) {
              rgb2[3] = parseFloat(match2[4]) * 0.01;
            } else {
              rgb2[3] = parseFloat(match2[4]);
            }
          }
        } else if (match2 = string.match(keyword)) {
          if (match2[1] === "transparent") {
            return [0, 0, 0, 0];
          }
          if (!hasOwnProperty3.call(colorNames, match2[1])) {
            return null;
          }
          rgb2 = colorNames[match2[1]];
          rgb2[3] = 1;
          return rgb2;
        } else {
          return null;
        }
        for (i = 0; i < 3; i++) {
          rgb2[i] = clamp3(rgb2[i], 0, 255);
        }
        rgb2[3] = clamp3(rgb2[3], 0, 1);
        return rgb2;
      };
      cs.get.hsl = function(string) {
        if (!string) {
          return null;
        }
        var hsl2 = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
        var match2 = string.match(hsl2);
        if (match2) {
          var alpha = parseFloat(match2[4]);
          var h = (parseFloat(match2[1]) % 360 + 360) % 360;
          var s3 = clamp3(parseFloat(match2[2]), 0, 100);
          var l2 = clamp3(parseFloat(match2[3]), 0, 100);
          var a3 = clamp3(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h, s3, l2, a3];
        }
        return null;
      };
      cs.get.hwb = function(string) {
        if (!string) {
          return null;
        }
        var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
        var match2 = string.match(hwb);
        if (match2) {
          var alpha = parseFloat(match2[4]);
          var h = (parseFloat(match2[1]) % 360 + 360) % 360;
          var w = clamp3(parseFloat(match2[2]), 0, 100);
          var b = clamp3(parseFloat(match2[3]), 0, 100);
          var a3 = clamp3(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h, w, b, a3];
        }
        return null;
      };
      cs.to.hex = function() {
        var rgba2 = swizzle(arguments);
        return "#" + hexDouble(rgba2[0]) + hexDouble(rgba2[1]) + hexDouble(rgba2[2]) + (rgba2[3] < 1 ? hexDouble(Math.round(rgba2[3] * 255)) : "");
      };
      cs.to.rgb = function() {
        var rgba2 = swizzle(arguments);
        return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ")" : "rgba(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ", " + rgba2[3] + ")";
      };
      cs.to.rgb.percent = function() {
        var rgba2 = swizzle(arguments);
        var r = Math.round(rgba2[0] / 255 * 100);
        var g = Math.round(rgba2[1] / 255 * 100);
        var b = Math.round(rgba2[2] / 255 * 100);
        return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba2[3] + ")";
      };
      cs.to.hsl = function() {
        var hsla2 = swizzle(arguments);
        return hsla2.length < 4 || hsla2[3] === 1 ? "hsl(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%)" : "hsla(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%, " + hsla2[3] + ")";
      };
      cs.to.hwb = function() {
        var hwba = swizzle(arguments);
        var a3 = "";
        if (hwba.length >= 4 && hwba[3] !== 1) {
          a3 = ", " + hwba[3];
        }
        return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a3 + ")";
      };
      cs.to.keyword = function(rgb2) {
        return reverseNames[rgb2.slice(0, 3)];
      };
      function clamp3(num, min10, max11) {
        return Math.min(Math.max(min10, num), max11);
      }
      function hexDouble(num) {
        var str7 = Math.round(num).toString(16).toUpperCase();
        return str7.length < 2 ? "0" + str7 : str7;
      }
    }
  });

  // node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter3() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter3.prototype.eventNames = function eventNames() {
        var names = [], events, name2;
        if (this._eventsCount === 0) return names;
        for (name2 in events = this._events) {
          if (has.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter3.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l2 = handlers.length, ee = new Array(l2); i < l2; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter3.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter3.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len5 = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len5) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a22), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a22, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len5 - 1); i < len5; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length5 = listeners.length, j;
          for (i = 0; i < length5; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len5) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a22);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a22, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len5 - 1); j < len5; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter3.prototype.on = function on2(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter3.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length5 = listeners.length; i < length5; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
      EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
      EventEmitter3.prefixed = prefix;
      EventEmitter3.EventEmitter = EventEmitter3;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter3;
      }
    }
  });

  // node_modules/@antv/coord/dist/coordinate.min.js
  var require_coordinate_min = __commonJS({
    "node_modules/@antv/coord/dist/coordinate.min.js"(exports, module) {
      !function(t, r) {
        "object" == typeof exports && "undefined" != typeof module ? r(exports) : "function" == typeof define && define.amd ? define(["exports"], r) : r((t = "undefined" != typeof globalThis ? globalThis : t || self).Coordinate = {});
      }(exports, function(t) {
        "use strict";
        function x3(t2) {
          var r2 = "function" == typeof Symbol && Symbol.iterator, n3 = r2 && t2[r2], e4 = 0;
          if (n3) return n3.call(t2);
          if (t2 && "number" == typeof t2.length) return { next: function() {
            return { value: (t2 = t2 && e4 >= t2.length ? void 0 : t2) && t2[e4++], done: !t2 };
          } };
          throw new TypeError(r2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function k(t2, r2) {
          var n3 = "function" == typeof Symbol && t2[Symbol.iterator];
          if (!n3) return t2;
          var e4, o2, a4 = n3.call(t2), i2 = [];
          try {
            for (; (void 0 === r2 || 0 < r2--) && !(e4 = a4.next()).done; ) i2.push(e4.value);
          } catch (t3) {
            o2 = { error: t3 };
          } finally {
            try {
              e4 && !e4.done && (n3 = a4.return) && n3.call(a4);
            } finally {
              if (o2) throw o2.error;
            }
          }
          return i2;
        }
        function O(t2, r2, n3) {
          if (n3 || 2 === arguments.length) for (var e4, o2 = 0, a4 = r2.length; o2 < a4; o2++) !e4 && o2 in r2 || ((e4 = e4 || Array.prototype.slice.call(r2, 0, o2))[o2] = r2[o2]);
          return t2.concat(e4 || Array.prototype.slice.call(r2));
        }
        function q(t2) {
          return i(t2, "Function");
        }
        var C4 = {}.toString, i = function(t2, r2) {
          return C4.call(t2) === "[object " + r2 + "]";
        }, W = function(t2) {
          return Array.isArray ? Array.isArray(t2) : i(t2, "Array");
        };
        var B4 = function(t2) {
          if ("object" != typeof (r2 = t2) || null === r2 || !i(t2, "Object")) return false;
          var r2;
          if (null === Object.getPrototypeOf(t2)) return true;
          for (var n3 = t2; null !== Object.getPrototypeOf(n3); ) n3 = Object.getPrototypeOf(n3);
          return Object.getPrototypeOf(t2) === n3;
        }, $ = function(t2) {
          return i(t2, "Number");
        }, z = Object.values ? function(t2) {
          return Object.values(t2);
        } : function(n3) {
          var t2, e4 = [], r2 = n3, o2 = function(t3, r3) {
            q(n3) && "prototype" === r3 || e4.push(t3);
          };
          if (r2) {
            if (W(r2)) for (var a4 = 0, i2 = r2.length; a4 < i2 && false !== o2(r2[a4], a4); a4++) ;
            else if (t2 = typeof r2, null !== r2 && "object" == t2 || "function" == t2) {
              for (var u2 in r2) if (r2.hasOwnProperty(u2) && false === o2(r2[u2], u2)) break;
            }
          }
          return e4;
        }, E2 = 5;
        function r(t2) {
          for (var r2 = [], n3 = 1; n3 < arguments.length; n3++) r2[n3 - 1] = arguments[n3];
          for (var e4 = 0; e4 < r2.length; e4 += 1) !function t3(r3, n4, e6, o2) {
            for (var a4 in e6 = e6 || 0, o2 = o2 || E2, n4) {
              var i2;
              n4.hasOwnProperty(a4) && (null !== (i2 = n4[a4]) && B4(i2) ? (B4(r3[a4]) || (r3[a4] = {}), e6 < o2 ? t3(r3[a4], i2, e6 + 1, o2) : r3[a4] = n4[a4]) : W(i2) ? (r3[a4] = [], r3[a4] = r3[a4].concat(i2)) : void 0 !== i2 && (r3[a4] = i2));
            }
          }(t2, r2[e4]);
          return t2;
        }
        function A5(t2) {
          return t2;
        }
        !function(a4, i2) {
          var u2;
          if (q(a4)) return (u2 = function() {
            for (var t2 = [], r2 = 0; r2 < arguments.length; r2++) t2[r2] = arguments[r2];
            var n3, e4 = i2 ? i2.apply(this, t2) : t2[0], o2 = u2.cache;
            return o2.has(e4) ? o2.get(e4) : (n3 = a4.apply(this, t2), o2.set(e4, n3), n3);
          }).cache = /* @__PURE__ */ new Map();
          throw new TypeError("Expected a function");
        }(function(t2, r2) {
          var n3 = (r2 = void 0 === r2 ? {} : r2).fontSize, e4 = r2.fontFamily, o2 = r2.fontWeight, a4 = r2.fontStyle, r2 = r2.fontVariant;
          return (u = u || document.createElement("canvas").getContext("2d")).font = [a4, r2, o2, n3 + "px", e4].join(" "), u.measureText(i(t2, "String") ? t2 : "").width;
        }, function(t2, r2) {
          return function() {
            for (var t3 = 0, r3 = 0, n3 = arguments.length; r3 < n3; r3++) t3 += arguments[r3].length;
            for (var e4 = Array(t3), o2 = 0, r3 = 0; r3 < n3; r3++) for (var a4 = arguments[r3], i2 = 0, u2 = a4.length; i2 < u2; i2++, o2++) e4[o2] = a4[i2];
            return e4;
          }([t2], z(r2 = void 0 === r2 ? {} : r2)).join("");
        });
        var u, P = "undefined" != typeof Float32Array ? Float32Array : Array;
        function g() {
          var t2 = new P(9);
          return P != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
        }
        Math.hypot || (Math.hypot = function() {
          for (var t2 = 0, r2 = arguments.length; r2--; ) t2 += arguments[r2] * arguments[r2];
          return Math.sqrt(t2);
        });
        var J = function(t2, r2, n3) {
          var e4 = r2[0], o2 = r2[1], a4 = r2[2], i2 = r2[3], u2 = r2[4], s4 = r2[5], l3 = r2[6], h2 = r2[7], r2 = r2[8], c6 = n3[0], p3 = n3[1], f2 = n3[2], d4 = n3[3], g2 = n3[4], v2 = n3[5], m4 = n3[6], y4 = n3[7], n3 = n3[8];
          return t2[0] = c6 * e4 + p3 * i2 + f2 * l3, t2[1] = c6 * o2 + p3 * u2 + f2 * h2, t2[2] = c6 * a4 + p3 * s4 + f2 * r2, t2[3] = d4 * e4 + g2 * i2 + v2 * l3, t2[4] = d4 * o2 + g2 * u2 + v2 * h2, t2[5] = d4 * a4 + g2 * s4 + v2 * r2, t2[6] = m4 * e4 + y4 * i2 + n3 * l3, t2[7] = m4 * o2 + y4 * u2 + n3 * h2, t2[8] = m4 * a4 + y4 * s4 + n3 * r2, t2;
        };
        function R() {
          var t2 = new P(16);
          return P != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
        }
        var L = function(t2, r2, n3) {
          var e4 = r2[0], o2 = r2[1], a4 = r2[2], i2 = r2[3], u2 = r2[4], s4 = r2[5], l3 = r2[6], h2 = r2[7], c6 = r2[8], p3 = r2[9], f2 = r2[10], d4 = r2[11], g2 = r2[12], v2 = r2[13], m4 = r2[14], r2 = r2[15], y4 = n3[0], M3 = n3[1], w2 = n3[2], b2 = n3[3];
          return t2[0] = y4 * e4 + M3 * u2 + w2 * c6 + b2 * g2, t2[1] = y4 * o2 + M3 * s4 + w2 * p3 + b2 * v2, t2[2] = y4 * a4 + M3 * l3 + w2 * f2 + b2 * m4, t2[3] = y4 * i2 + M3 * h2 + w2 * d4 + b2 * r2, y4 = n3[4], M3 = n3[5], w2 = n3[6], b2 = n3[7], t2[4] = y4 * e4 + M3 * u2 + w2 * c6 + b2 * g2, t2[5] = y4 * o2 + M3 * s4 + w2 * p3 + b2 * v2, t2[6] = y4 * a4 + M3 * l3 + w2 * f2 + b2 * m4, t2[7] = y4 * i2 + M3 * h2 + w2 * d4 + b2 * r2, y4 = n3[8], M3 = n3[9], w2 = n3[10], b2 = n3[11], t2[8] = y4 * e4 + M3 * u2 + w2 * c6 + b2 * g2, t2[9] = y4 * o2 + M3 * s4 + w2 * p3 + b2 * v2, t2[10] = y4 * a4 + M3 * l3 + w2 * f2 + b2 * m4, t2[11] = y4 * i2 + M3 * h2 + w2 * d4 + b2 * r2, y4 = n3[12], M3 = n3[13], w2 = n3[14], b2 = n3[15], t2[12] = y4 * e4 + M3 * u2 + w2 * c6 + b2 * g2, t2[13] = y4 * o2 + M3 * s4 + w2 * p3 + b2 * v2, t2[14] = y4 * a4 + M3 * l3 + w2 * f2 + b2 * m4, t2[15] = y4 * i2 + M3 * h2 + w2 * d4 + b2 * r2, t2;
        };
        function U(t2) {
          for (var r2 = [], n3 = 1; n3 < arguments.length; n3++) r2[n3 - 1] = arguments[n3];
          return t2 ? r2.reduce(function(r3, n4) {
            return function(t3) {
              return n4(r3(t3));
            };
          }, t2) : A5;
        }
        function _2(t2) {
          return t2 instanceof Float32Array || t2 instanceof Array;
        }
        function V(t2, r2, n3) {
          for (; t2 < r2; ) t2 += 2 * Math.PI;
          for (; n3 < t2; ) t2 -= 2 * Math.PI;
          return t2;
        }
        e3 = new P(3), P != Float32Array && (e3[0] = 0, e3[1] = 0, e3[2] = 0), e3 = new P(4), P != Float32Array && (e3[0] = 0, e3[1] = 0, e3[2] = 0, e3[3] = 0);
        function G(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 2))[0], t2 = t2[1], i2 = g();
          return a4 = [a4, t2], (t2 = i2)[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 1, t2[5] = 0, t2[6] = a4[0], t2[7] = a4[1], t2[8] = 1, t2;
        }
        function l2(t2, ...r2) {
          return r2.reduce((r3, n3) => (t3) => r3(n3(t3)), t2);
        }
        function h(r2, n3) {
          return n3 - r2 ? (t2) => (t2 - r2) / (n3 - r2) : (t2) => 0.5;
        }
        const H = Math.sqrt(50), Q = Math.sqrt(10), X = Math.sqrt(2);
        function s3(t2, r2, n3) {
          r2 = (r2 - t2) / Math.max(0, n3), t2 = Math.floor(Math.log(r2) / Math.LN10), n3 = r2 / 10 ** t2;
          return 0 <= t2 ? (n3 >= H ? 10 : n3 >= Q ? 5 : n3 >= X ? 2 : 1) * 10 ** t2 : -(10 ** -t2) / (n3 >= H ? 10 : n3 >= Q ? 5 : n3 >= X ? 2 : 1);
        }
        const Y = (t2, r2, n3 = 5) => {
          t2 = [t2, r2];
          let e4 = 0, o2 = t2.length - 1, a4 = t2[e4], i2 = t2[o2], u2;
          return i2 < a4 && ([a4, i2] = [i2, a4], [e4, o2] = [o2, e4]), 0 < (u2 = s3(a4, i2, n3)) ? (a4 = Math.floor(a4 / u2) * u2, i2 = Math.ceil(i2 / u2) * u2, u2 = s3(a4, i2, n3)) : u2 < 0 && (a4 = Math.ceil(a4 * u2) / u2, i2 = Math.floor(i2 * u2) / u2, u2 = s3(a4, i2, n3)), 0 < u2 ? (t2[e4] = Math.floor(a4 / u2) * u2, t2[o2] = Math.ceil(i2 / u2) * u2) : u2 < 0 && (t2[e4] = Math.ceil(a4 * u2) / u2, t2[o2] = Math.floor(i2 * u2) / u2), t2;
        };
        function Z(t2) {
          return null != t2 && !Number.isNaN(t2);
        }
        function tt(r2, i2) {
          return (t2) => {
            t2.prototype.rescale = function() {
              this.initRange(), this.nice();
              var [t3] = this.chooseTransforms();
              this.composeOutput(t3, this.chooseClamp(t3));
            }, t2.prototype.initRange = function() {
              var t3 = this.options["interpolator"];
              this.options.range = r2(t3);
            }, t2.prototype.composeOutput = function(t3, r3) {
              var n3, { domain: e4, interpolator: o2, round: a4 } = this.getOptions(), e4 = i2(e4.map(t3)), a4 = a4 ? (n3 = o2, (t4) => {
                t4 = n3(t4);
                return $(t4) ? Math.round(t4) : t4;
              }) : o2;
              this.output = l2(a4, e4, r3, t3);
            }, t2.prototype.invert = void 0;
          };
        }
        var n2, e3 = { exports: {} }, o = { exports: {} }, rt = function(t2) {
          return !(!t2 || "string" == typeof t2) && (t2 instanceof Array || Array.isArray(t2) || 0 <= t2.length && (t2.splice instanceof Function || Object.getOwnPropertyDescriptor(t2, t2.length - 1) && "String" !== t2.constructor.name));
        }, nt = Array.prototype.concat, et = Array.prototype.slice, ot = o.exports = function(t2) {
          for (var r2 = [], n3 = 0, e4 = t2.length; n3 < e4; n3++) {
            var o2 = t2[n3];
            rt(o2) ? r2 = nt.call(r2, et.call(o2)) : r2.push(o2);
          }
          return r2;
        }, c5 = (ot.wrap = function(t2) {
          return function() {
            return t2(ot(arguments));
          };
        }, { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }), a3 = o.exports, at = Object.hasOwnProperty, it = /* @__PURE__ */ Object.create(null);
        for (n2 in c5) at.call(c5, n2) && (it[c5[n2]] = n2);
        var p2 = e3.exports = { to: {}, get: {} };
        function f(t2, r2, n3) {
          return Math.min(Math.max(r2, t2), n3);
        }
        function d3(t2) {
          t2 = Math.round(t2).toString(16).toUpperCase();
          return t2.length < 2 ? "0" + t2 : t2;
        }
        p2.get = function(t2) {
          var r2, n3;
          switch (t2.substring(0, 3).toLowerCase()) {
            case "hsl":
              r2 = p2.get.hsl(t2), n3 = "hsl";
              break;
            case "hwb":
              r2 = p2.get.hwb(t2), n3 = "hwb";
              break;
            default:
              r2 = p2.get.rgb(t2), n3 = "rgb";
          }
          return r2 ? { model: n3, value: r2 } : null;
        }, p2.get.rgb = function(t2) {
          if (!t2) return null;
          var r2, n3, e4, o2 = [0, 0, 0, 1];
          if (r2 = t2.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)) {
            for (e4 = r2[2], r2 = r2[1], n3 = 0; n3 < 3; n3++) {
              var a4 = 2 * n3;
              o2[n3] = parseInt(r2.slice(a4, 2 + a4), 16);
            }
            e4 && (o2[3] = parseInt(e4, 16) / 255);
          } else if (r2 = t2.match(/^#([a-f0-9]{3,4})$/i)) {
            for (e4 = (r2 = r2[1])[3], n3 = 0; n3 < 3; n3++) o2[n3] = parseInt(r2[n3] + r2[n3], 16);
            e4 && (o2[3] = parseInt(e4 + e4, 16) / 255);
          } else {
            if (r2 = t2.match(/^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)) for (n3 = 0; n3 < 3; n3++) o2[n3] = parseInt(r2[n3 + 1], 0);
            else {
              if (!(r2 = t2.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/))) return (r2 = t2.match(/^(\w+)$/)) ? "transparent" === r2[1] ? [0, 0, 0, 0] : at.call(c5, r2[1]) ? ((o2 = c5[r2[1]])[3] = 1, o2) : null : null;
              for (n3 = 0; n3 < 3; n3++) o2[n3] = Math.round(2.55 * parseFloat(r2[n3 + 1]));
            }
            r2[4] && (r2[5] ? o2[3] = 0.01 * parseFloat(r2[4]) : o2[3] = parseFloat(r2[4]));
          }
          for (n3 = 0; n3 < 3; n3++) o2[n3] = f(o2[n3], 0, 255);
          return o2[3] = f(o2[3], 0, 1), o2;
        }, p2.get.hsl = function(t2) {
          var r2;
          return (t2 = t2 && t2.match(/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/)) ? (r2 = parseFloat(t2[4]), [(parseFloat(t2[1]) % 360 + 360) % 360, f(parseFloat(t2[2]), 0, 100), f(parseFloat(t2[3]), 0, 100), f(isNaN(r2) ? 1 : r2, 0, 1)]) : null;
        }, p2.get.hwb = function(t2) {
          var r2;
          return (t2 = t2 && t2.match(/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/)) ? (r2 = parseFloat(t2[4]), [(parseFloat(t2[1]) % 360 + 360) % 360, f(parseFloat(t2[2]), 0, 100), f(parseFloat(t2[3]), 0, 100), f(isNaN(r2) ? 1 : r2, 0, 1)]) : null;
        }, p2.to.hex = function() {
          var t2 = a3(arguments);
          return "#" + d3(t2[0]) + d3(t2[1]) + d3(t2[2]) + (t2[3] < 1 ? d3(Math.round(255 * t2[3])) : "");
        }, p2.to.rgb = function() {
          var t2 = a3(arguments);
          return t2.length < 4 || 1 === t2[3] ? "rgb(" + Math.round(t2[0]) + ", " + Math.round(t2[1]) + ", " + Math.round(t2[2]) + ")" : "rgba(" + Math.round(t2[0]) + ", " + Math.round(t2[1]) + ", " + Math.round(t2[2]) + ", " + t2[3] + ")";
        }, p2.to.rgb.percent = function() {
          var t2 = a3(arguments), r2 = Math.round(t2[0] / 255 * 100), n3 = Math.round(t2[1] / 255 * 100), e4 = Math.round(t2[2] / 255 * 100);
          return t2.length < 4 || 1 === t2[3] ? "rgb(" + r2 + "%, " + n3 + "%, " + e4 + "%)" : "rgba(" + r2 + "%, " + n3 + "%, " + e4 + "%, " + t2[3] + ")";
        }, p2.to.hsl = function() {
          var t2 = a3(arguments);
          return t2.length < 4 || 1 === t2[3] ? "hsl(" + t2[0] + ", " + t2[1] + "%, " + t2[2] + "%)" : "hsla(" + t2[0] + ", " + t2[1] + "%, " + t2[2] + "%, " + t2[3] + ")";
        }, p2.to.hwb = function() {
          var t2 = a3(arguments), r2 = "";
          return 4 <= t2.length && 1 !== t2[3] && (r2 = ", " + t2[3]), "hwb(" + t2[0] + ", " + t2[1] + "%, " + t2[2] + "%" + r2 + ")";
        }, p2.to.keyword = function(t2) {
          return it[t2.slice(0, 3)];
        };
        var ut = e3.exports;
        function v(t2, r2, n3) {
          let e4 = n3;
          return e4 < 0 && (e4 += 1), 1 < e4 && --e4, e4 < 1 / 6 ? t2 + 6 * (r2 - t2) * e4 : e4 < 0.5 ? r2 : e4 < 2 / 3 ? t2 + (r2 - t2) * (2 / 3 - e4) * 6 : t2;
        }
        function st(t2) {
          var r2, n3, e4, t2 = ut.get(t2);
          return t2 ? ({ model: t2, value: r2 } = t2, "rgb" === t2 ? r2 : "hsl" === t2 ? (r2 = (t2 = r2)[0] / 360, n3 = t2[1] / 100, e4 = t2[2] / 100, t2 = t2[3], 0 == n3 ? [255 * e4, 255 * e4, 255 * e4, t2] : [255 * v(n3 = 2 * e4 - (e4 = e4 < 0.5 ? e4 * (1 + n3) : e4 + n3 - e4 * n3), e4, r2 + 1 / 3), 255 * v(n3, e4, r2), 255 * v(n3, e4, r2 - 1 / 3), t2]) : null) : null;
        }
        const m3 = (r2, n3) => (t2) => r2 * (1 - t2) + n3 * t2, lt = (t2, r2) => {
          if ("number" == typeof t2 && "number" == typeof r2) return m3(t2, r2);
          if ("string" != typeof t2 || "string" != typeof r2) return () => t2;
          {
            var n3 = t2, e4 = r2;
            const s4 = st(n3), l3 = st(e4);
            return null === s4 || null === l3 ? s4 ? () => n3 : () => e4 : (r3) => {
              var n4 = new Array(4);
              for (let t4 = 0; t4 < 4; t4 += 1) {
                var e6 = s4[t4], o2 = l3[t4];
                n4[t4] = e6 * (1 - r3) + o2 * r3;
              }
              var [t3, a4, i2, u2] = n4;
              return `rgba(${Math.round(t3)}, ${Math.round(a4)}, ${Math.round(i2)}, ${u2})`;
            };
          }
        }, ht = (t2, r2) => {
          const n3 = m3(t2, r2);
          return (t3) => Math.round(n3(t3));
        };
        function ct({ map: t2, initKey: r2 }, n3) {
          r2 = r2(n3);
          return t2.has(r2) ? t2.get(r2) : n3;
        }
        function pt(t2) {
          return "object" == typeof t2 ? t2.valueOf() : t2;
        }
        class ft extends Map {
          constructor(t2) {
            if (super(), this.map = /* @__PURE__ */ new Map(), this.initKey = pt, null !== t2) for (var [r2, n3] of t2) this.set(r2, n3);
          }
          get(t2) {
            return super.get(ct({ map: this.map, initKey: this.initKey }, t2));
          }
          has(t2) {
            return super.has(ct({ map: this.map, initKey: this.initKey }, t2));
          }
          set(t2, r2) {
            return super.set(([{ map: t2, initKey: n3 }, e4] = [{ map: this.map, initKey: this.initKey }, t2], n3 = n3(e4), t2.has(n3) ? t2.get(n3) : (t2.set(n3, e4), e4)), r2);
            var n3, e4;
          }
          delete(t2) {
            return super.delete(([{ map: t2, initKey: r2 }, n3] = [{ map: this.map, initKey: this.initKey }, t2], r2 = r2(n3), t2.has(r2) && (n3 = t2.get(r2), t2.delete(r2)), n3));
            var r2, n3;
          }
        }
        class dt {
          constructor(t2) {
            this.options = r({}, this.getDefaultOptions()), this.update(t2);
          }
          getOptions() {
            return this.options;
          }
          update(t2 = {}) {
            this.options = r({}, this.options, t2), this.rescale(t2);
          }
          rescale(t2) {
          }
        }
        const y3 = Symbol("defaultUnknown");
        function gt(r2, n3, e4) {
          for (let t2 = 0; t2 < n3.length; t2 += 1) r2.has(n3[t2]) || r2.set(e4(n3[t2]), t2);
        }
        function vt(t2) {
          var { value: t2, from: r2, to: n3, mapper: e4, notFoundReturn: o2 } = t2;
          let a4 = e4.get(t2);
          if (void 0 === a4) {
            if (o2 !== y3) return o2;
            a4 = r2.push(t2) - 1, e4.set(t2, a4);
          }
          return n3[a4 % n3.length];
        }
        function mt(t2) {
          return t2 instanceof Date ? (t3) => "" + t3 : "object" == typeof t2 ? (t3) => JSON.stringify(t3) : (t3) => t3;
        }
        class yt extends dt {
          getDefaultOptions() {
            return { domain: [], range: [], unknown: y3 };
          }
          constructor(t2) {
            super(t2);
          }
          map(t2) {
            return 0 === this.domainIndexMap.size && gt(this.domainIndexMap, this.getDomain(), this.domainKey), vt({ value: this.domainKey(t2), mapper: this.domainIndexMap, from: this.getDomain(), to: this.getRange(), notFoundReturn: this.options.unknown });
          }
          invert(t2) {
            return 0 === this.rangeIndexMap.size && gt(this.rangeIndexMap, this.getRange(), this.rangeKey), vt({ value: this.rangeKey(t2), mapper: this.rangeIndexMap, from: this.getRange(), to: this.getDomain(), notFoundReturn: this.options.unknown });
          }
          rescale(t2) {
            var [r2] = this.options.domain, [n3] = this.options.range;
            this.domainKey = mt(r2), this.rangeKey = mt(n3), this.rangeIndexMap ? (t2 && !t2.range || this.rangeIndexMap.clear(), t2 && !t2.domain && !t2.compare || (this.domainIndexMap.clear(), this.sortedDomain = void 0)) : (this.rangeIndexMap = /* @__PURE__ */ new Map(), this.domainIndexMap = /* @__PURE__ */ new Map());
          }
          clone() {
            return new yt(this.options);
          }
          getRange() {
            return this.options.range;
          }
          getDomain() {
            var t2, r2;
            return this.sortedDomain || ({ domain: t2, compare: r2 } = this.options, this.sortedDomain = r2 ? [...t2].sort(r2) : t2), this.sortedDomain;
          }
        }
        function Mt(t2) {
          const { domain: r2, range: n3, paddingOuter: e4, paddingInner: o2, flex: a4, round: i2, align: u2 } = t2;
          var s4 = r2.length, l3 = 0 < (l3 = (t2 = s4) - (h2 = a4).length) ? [...h2, ...new Array(l3).fill(1)] : l3 < 0 ? h2.slice(0, t2) : h2, [t2, h2] = n3, h2 = h2 - t2, c6 = h2 / (2 / s4 * e4 + 1 - 1 / s4 * o2);
          const p3 = c6 * o2 / s4;
          c6 -= s4 * p3;
          const f2 = function(t3) {
            const r3 = Math.min(...t3);
            return t3.map((t4) => t4 / r3);
          }(l3), d4 = c6 / f2.reduce((t3, r3) => t3 + r3);
          var l3 = new ft(r2.map((t3, r3) => {
            r3 = f2[r3] * d4;
            return [t3, i2 ? Math.floor(r3) : r3];
          })), g2 = new ft(r2.map((t3, r3) => {
            r3 = f2[r3] * d4 + p3;
            return [t3, i2 ? Math.floor(r3) : r3];
          })), c6 = Array.from(g2.values()).reduce((t3, r3) => t3 + r3), t2 = t2 + (h2 - (c6 - c6 / s4 * o2)) * u2;
          let v2 = i2 ? Math.round(t2) : t2;
          var m4 = new Array(s4);
          for (let t3 = 0; t3 < s4; t3 += 1) {
            m4[t3] = (y4 = v2, Math.round(1e12 * y4) / 1e12);
            var y4 = r2[t3];
            v2 += g2.get(y4);
          }
          return { valueBandWidth: l3, valueStep: g2, adjustedRange: m4 };
        }
        class wt extends yt {
          getDefaultOptions() {
            return { domain: [], range: [0, 1], align: 0.5, round: false, paddingInner: 0, paddingOuter: 0, padding: 0, unknown: y3, flex: [] };
          }
          constructor(t2) {
            super(t2);
          }
          clone() {
            return new wt(this.options);
          }
          getStep(t2) {
            return void 0 === this.valueStep ? 1 : "number" == typeof this.valueStep ? this.valueStep : void 0 === t2 ? Array.from(this.valueStep.values())[0] : this.valueStep.get(t2);
          }
          getBandWidth(t2) {
            return void 0 === this.valueBandWidth ? 1 : "number" == typeof this.valueBandWidth ? this.valueBandWidth : void 0 === t2 ? Array.from(this.valueBandWidth.values())[0] : this.valueBandWidth.get(t2);
          }
          getRange() {
            return this.adjustedRange;
          }
          getPaddingInner() {
            var { padding: t2, paddingInner: r2 } = this.options;
            return 0 < t2 ? t2 : r2;
          }
          getPaddingOuter() {
            var { padding: t2, paddingOuter: r2 } = this.options;
            return 0 < t2 ? t2 : r2;
          }
          rescale() {
            super.rescale();
            var { align: t2, domain: r2, range: n3, round: e4, flex: o2 } = this.options, { adjustedRange: t2, valueBandWidth: n3, valueStep: e4 } = function(t3) {
              var r3 = t3["domain"];
              if (0 === (r3 = r3.length)) return { valueBandWidth: void 0, valueStep: void 0, adjustedRange: [] };
              if (!(null == (n4 = t3.flex) || !n4.length)) return Mt(t3);
              var { range: n4, paddingOuter: t3, paddingInner: e6, round: o3, align: a4 } = t3;
              let i2, u2, s4 = n4[0];
              return n4 = n4[1] - s4, i2 = n4 / Math.max(1, 2 * t3 + (r3 - e6)), o3 && (i2 = Math.floor(i2)), s4 += (n4 - i2 * (r3 - e6)) * a4, u2 = i2 * (1 - e6), o3 && (s4 = Math.round(s4), u2 = Math.round(u2)), t3 = new Array(r3).fill(0).map((t4, r4) => s4 + r4 * i2), { valueStep: i2, valueBandWidth: u2, adjustedRange: t3 };
            }({ align: t2, range: n3, round: e4, flex: o2, paddingInner: this.getPaddingInner(), paddingOuter: this.getPaddingOuter(), domain: r2 });
            this.valueStep = e4, this.valueBandWidth = n3, this.adjustedRange = t2;
          }
        }
        const M2 = (t2, r2, n3) => {
          let e4, o2, a4 = t2, i2 = r2;
          if (a4 === i2 && 0 < n3) return [a4];
          let u2 = s3(a4, i2, n3);
          if (0 === u2 || !Number.isFinite(u2)) return [];
          if (0 < u2) {
            a4 = Math.ceil(a4 / u2), i2 = Math.floor(i2 / u2), o2 = new Array(e4 = Math.ceil(i2 - a4 + 1));
            for (let t3 = 0; t3 < e4; t3 += 1) o2[t3] = (a4 + t3) * u2;
          } else {
            u2 = -u2, a4 = Math.ceil(a4 * u2), i2 = Math.floor(i2 * u2), o2 = new Array(e4 = Math.ceil(i2 - a4 + 1));
            for (let t3 = 0; t3 < e4; t3 += 1) o2[t3] = (a4 + t3) / u2;
          }
          return o2;
        }, bt = (t2, r2, n3) => {
          var [t2, e4] = t2, [r2, o2] = r2;
          let a4, i2;
          return l2(i2 = t2 < e4 ? (a4 = h(t2, e4), n3(r2, o2)) : (a4 = h(e4, t2), n3(o2, r2)), a4);
        }, xt = (e4, t2, r2) => {
          const o2 = Math.min(e4.length, t2.length) - 1, a4 = new Array(o2), i2 = new Array(o2);
          var n3 = e4[0] > e4[o2], u2 = n3 ? [...e4].reverse() : e4, s4 = n3 ? [...t2].reverse() : t2;
          for (let t3 = 0; t3 < o2; t3 += 1) a4[t3] = h(u2[t3], u2[t3 + 1]), i2[t3] = r2(s4[t3], s4[t3 + 1]);
          return (t3) => {
            var r3 = function(t4, r4, n5, e6, o3) {
              let a5 = n5 || 0, i3 = e6 || t4.length;
              for (var u3 = o3 || ((t5) => t5); a5 < i3; ) {
                var s5 = Math.floor((a5 + i3) / 2);
                u3(t4[s5]) > r4 ? i3 = s5 : a5 = s5 + 1;
              }
              return a5;
            }(e4, t3, 1, o2) - 1, n4 = a4[r3];
            return l2(i2[r3], n4)(t3);
          };
        }, kt = (t2, r2, n3, e4) => {
          return (2 < Math.min(t2.length, r2.length) ? xt : bt)(t2, r2, e4 ? ht : n3);
        };
        class Ot extends dt {
          getDefaultOptions() {
            return { domain: [0, 1], range: [0, 1], nice: false, clamp: false, round: false, interpolate: m3, tickCount: 5 };
          }
          map(t2) {
            return Z(t2) ? this.output(t2) : this.options.unknown;
          }
          invert(t2) {
            return Z(t2) ? this.input(t2) : this.options.unknown;
          }
          nice() {
            var t2, r2, n3, e4;
            this.options.nice && ([t2, r2, n3, ...e4] = this.getTickMethodOptions(), this.options.domain = this.chooseNice()(t2, r2, n3, ...e4));
          }
          getTicks() {
            var t2 = this.options["tickMethod"], [r2, n3, e4, ...o2] = this.getTickMethodOptions();
            return t2(r2, n3, e4, ...o2);
          }
          getTickMethodOptions() {
            var { domain: t2, tickCount: r2 } = this.options;
            return [t2[0], t2[t2.length - 1], r2];
          }
          chooseNice() {
            return Y;
          }
          rescale() {
            this.nice();
            var [t2, r2] = this.chooseTransforms();
            this.composeOutput(t2, this.chooseClamp(t2)), this.composeInput(t2, r2, this.chooseClamp(r2));
          }
          chooseClamp(t2) {
            var { clamp: r2, range: n3 } = this.options, t2 = this.options.domain.map(t2), n3 = Math.min(t2.length, n3.length);
            if (r2) {
              r2 = t2[0], t2 = t2[n3 - 1];
              const e4 = t2 < r2 ? t2 : r2, o2 = t2 < r2 ? r2 : t2;
              return (t3) => Math.min(Math.max(e4, t3), o2);
            }
            return A5;
          }
          composeOutput(t2, r2) {
            var { domain: n3, range: e4, round: o2, interpolate: a4 } = this.options, n3 = kt(n3.map(t2), e4, a4, o2);
            this.output = l2(n3, r2, t2);
          }
          composeInput(t2, r2, n3) {
            var { domain: e4, range: o2 } = this.options, o2 = kt(o2, e4.map(t2), m3);
            this.input = l2(r2, n3, o2);
          }
        }
        class w extends Ot {
          getDefaultOptions() {
            return { domain: [0, 1], range: [0, 1], unknown: void 0, nice: false, clamp: false, round: false, interpolate: lt, tickMethod: M2, tickCount: 5 };
          }
          chooseTransforms() {
            return [A5, A5];
          }
          clone() {
            return new w(this.options);
          }
        }
        class At extends wt {
          getDefaultOptions() {
            return { domain: [], range: [0, 1], align: 0.5, round: false, padding: 0, unknown: y3, paddingInner: 1, paddingOuter: 0 };
          }
          constructor(t2) {
            super(t2);
          }
          getPaddingInner() {
            return 1;
          }
          clone() {
            return new At(this.options);
          }
          update(t2) {
            super.update(t2);
          }
          getPaddingOuter() {
            return this.options.padding;
          }
        }
        function jt(t2, r2) {
          for (var n3 = [], e4 = 0, o2 = t2.length; e4 < o2; e4++) n3.push(t2[e4].substr(0, r2));
          return n3;
        }
        var b, o = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], e3 = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], j = jt(e3, 3);
        !function(t2) {
          for (var r2 = [], n3 = 1; n3 < arguments.length; n3++) r2[n3 - 1] = arguments[n3];
          for (var e4 = 0, o2 = r2; e4 < o2.length; e4++) {
            var a4, i2 = o2[e4];
            for (a4 in i2) t2[a4] = i2[a4];
          }
        }({}, { dayNamesShort: jt(o, 3), dayNames: o, monthNamesShort: j, monthNames: e3, amPm: ["am", "pm"], DoFn: function(t2) {
          return t2 + ["th", "st", "nd", "rd"][3 < t2 % 10 ? 0 : (t2 - t2 % 10 != 10 ? 1 : 0) * t2 % 10];
        } });
        var I;
        let It = b = class extends w {
          getDefaultOptions() {
            return { domain: [0, 1], unknown: void 0, nice: false, clamp: false, round: false, interpolator: A5, tickMethod: M2, tickCount: 5 };
          }
          constructor(t2) {
            super(t2);
          }
          clone() {
            return new b(this.options);
          }
        };
        It = b = function(t2, r2, n3, e4) {
          var o2, a4 = arguments.length, i2 = a4 < 3 ? r2 : null === e4 ? e4 = Object.getOwnPropertyDescriptor(r2, n3) : e4;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i2 = Reflect.decorate(t2, r2, n3, e4);
          else for (var u2 = t2.length - 1; 0 <= u2; u2--) (o2 = t2[u2]) && (i2 = (a4 < 3 ? o2(i2) : 3 < a4 ? o2(r2, n3, i2) : o2(r2, n3)) || i2);
          return 3 < a4 && i2 && Object.defineProperty(r2, n3, i2), i2;
        }([tt(function(t2) {
          return [t2(0), t2(1)];
        }, (t2) => {
          var [t2, r2] = t2;
          return l2(m3(0, 1), h(t2, r2));
        })], It);
        let St = I = class extends w {
          getDefaultOptions() {
            return { domain: [0, 0.5, 1], unknown: void 0, nice: false, clamp: false, round: false, interpolator: A5, tickMethod: M2, tickCount: 5 };
          }
          constructor(t2) {
            super(t2);
          }
          clone() {
            return new I(this.options);
          }
        };
        St = I = function(t2, r2, n3, e4) {
          var o2, a4 = arguments.length, i2 = a4 < 3 ? r2 : null === e4 ? e4 = Object.getOwnPropertyDescriptor(r2, n3) : e4;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i2 = Reflect.decorate(t2, r2, n3, e4);
          else for (var u2 = t2.length - 1; 0 <= u2; u2--) (o2 = t2[u2]) && (i2 = (a4 < 3 ? o2(i2) : 3 < a4 ? o2(r2, n3, i2) : o2(r2, n3)) || i2);
          return 3 < a4 && i2 && Object.defineProperty(r2, n3, i2), i2;
        }([tt(function(t2) {
          return [t2(0), t2(0.5), t2(1)];
        }, (t2) => {
          const [r2, n3, e4] = t2, o2 = l2(m3(0, 0.5), h(r2, n3)), a4 = l2(m3(0.5, 1), h(n3, e4));
          return (t3) => (r2 > e4 ? t3 < n3 ? a4 : o2 : t3 < n3 ? o2 : a4)(t3);
        })], St);
        function Ft(t2, r2, n3, e4, o2) {
          var a4 = new w({ range: [r2, r2 + e4] }), i2 = new w({ range: [n3, n3 + o2] });
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [a4.map(r3), i2.map(t3)];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [a4.invert(r3), i2.invert(t3)];
          } };
        }
        function Dt(t2, r2, n3, e4, o2) {
          return (0, k(t2, 1)[0])(r2, n3, e4, o2);
        }
        function Pt(t2, r2, n3, e4, o2) {
          return k(t2, 1)[0];
        }
        function Rt(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 4))[0], i2 = t2[1], u2 = t2[2], t2 = t2[3], s4 = new w({ range: [u2, t2] }), l3 = new w({ range: [a4, i2] }), h2 = 1 < (u2 = o2 / e4) ? 1 : u2, c6 = 1 < u2 ? 1 / u2 : 1;
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1], r3 = l3.map(r3), t3 = s4.map(t3);
            return [0.5 * (t3 * Math.cos(r3) * h2) + 0.5, 0.5 * (t3 * Math.sin(r3) * c6) + 0.5];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1], r3 = 2 * (r3 - 0.5) / h2, t3 = 2 * (t3 - 0.5) / c6, n4 = Math.sqrt(Math.pow(r3, 2) + Math.pow(t3, 2)), t3 = V(Math.atan2(t3, r3), a4, i2);
            return [l3.invert(t3), s4.invert(n4)];
          } };
        }
        function Tt(t2, r2, n3, e4, o2) {
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0];
            return [t3[1], r3];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0];
            return [t3[1], r3];
          } };
        }
        function Kt(t2) {
          for (var r2 = [], n3 = 1; n3 < arguments.length; n3++) r2[n3 - 1] = arguments[n3];
          return S.apply(void 0, O([[-1, -1]], k(r2), false));
        }
        function Nt(t2) {
          for (var r2 = [], n3 = 1; n3 < arguments.length; n3++) r2[n3 - 1] = arguments[n3];
          return S.apply(void 0, O([[-1, 1]], k(r2), false));
        }
        function qt(t2) {
          for (var r2 = [], n3 = 1; n3 < arguments.length; n3++) r2[n3 - 1] = arguments[n3];
          return S.apply(void 0, O([[1, -1]], k(r2), false));
        }
        function Ct(t2, r2, n3, e4, o2) {
          var a4, t2 = k(t2, 1)[0], i2 = g();
          return i2 = i2, t2 = t2, a4 = Math.sin(t2), t2 = Math.cos(t2), i2[0] = t2, i2[1] = a4, i2[2] = 0, i2[3] = -a4, i2[4] = t2, i2[5] = 0, i2[6] = 0, i2[7] = 0, i2[8] = 1, i2;
        }
        function Wt(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 4))[0], i2 = t2[1], u2 = t2[2], s4 = (t2[3] - u2) / (+i2 / (2 * Math.PI) + 1), l3 = s4 / (2 * Math.PI), h2 = new w({ range: [u2, u2 + 0.99 * s4] }), c6 = new w({ range: [a4, i2] }), p3 = 1 < (t2 = o2 / e4) ? 1 : t2, f2 = 1 < t2 ? 1 / t2 : 1;
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1], r3 = c6.map(r3), t3 = h2.map(t3);
            return [0.5 * (Math.cos(r3) * (l3 * r3 + t3) * p3) + 0.5, 0.5 * (Math.sin(r3) * (l3 * r3 + t3) * f2) + 0.5];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1], r3 = 2 * (r3 - 0.5) / p3, t3 = 2 * (t3 - 0.5) / f2, n4 = Math.sqrt(Math.pow(r3, 2) + Math.pow(t3, 2)), t3 = V(Math.atan2(t3, r3) + Math.floor(n4 / s4) * Math.PI * 2, a4, i2), r3 = n4 - l3 * t3;
            return [c6.invert(t3), h2.invert(r3)];
          } };
        }
        function Bt(t2, r2, n3, e4, o2) {
          var u2 = (t2 = k(t2, 4))[0], s4 = t2[1], a4 = t2[2], t2 = t2[3], l3 = new w({ range: [a4, t2] });
          return { transform: function(t3) {
            for (var r3 = [], n4 = t3.length, e6 = new At({ domain: new Array(n4).fill(0).map(function(t4, r4) {
              return r4;
            }), range: [u2, s4] }), o3 = 0; o3 < n4; o3++) {
              var a5 = t3[o3], i2 = e6.map(o3), a5 = l3.map(a5);
              r3.push(i2, a5);
            }
            return r3;
          }, untransform: function(t3) {
            for (var r3 = [], n4 = 0; n4 < t3.length; n4 += 2) {
              var e6 = t3[n4 + 1];
              r3.push(l3.invert(e6));
            }
            return r3;
          } };
        }
        var S = function(t2, r2, n3, e4, o2) {
          var t2 = k(t2, 2), a4 = t2[0], t2 = t2[1], i2 = g();
          return a4 = [a4, t2], (t2 = i2)[0] = a4[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = a4[1], t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
        };
        function $t(t2) {
          return 1 / Math.tan(t2);
        }
        function zt(t2, r2, n3, e4, o2) {
          var a4 = $t(k(t2, 1)[0]);
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [r3 + t3 * a4, t3];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [r3 - t3 * a4, t3];
          } };
        }
        function Et(t2, r2, n3, e4, o2) {
          var a4 = $t(k(t2, 1)[0]);
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0];
            return [r3, t3[1] + r3 * a4];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0];
            return [r3, t3[1] - r3 * a4];
          } };
        }
        function F(t2, r2, n3, e4, o2) {
          var a4 = t2 < r2, o2 = (a4 ? r2 - e4 : o2 - r2) || o2 - e4, e4 = a4 ? -1 : 1;
          return e4 * o2 * (n3 + 1) / (n3 + o2 / ((t2 - r2) * e4)) + r2;
        }
        function D2(t2, r2, n3, e4, o2) {
          var a4 = t2 < r2, o2 = (a4 ? r2 - e4 : o2 - r2) || o2 - e4;
          return o2 / (o2 * (n3 + 1) / (t2 - r2) - n3 * (a4 ? -1 : 1)) + r2;
        }
        function T(t2, r2, n3) {
          return n3 ? new w({ range: [0, 1], domain: [0, r2] }).map(t2) : t2;
        }
        function Jt(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 3))[0], i2 = t2[1], t2 = t2[2], u2 = T(a4, e4, void 0 !== t2 && t2);
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [F(r3, u2, i2, 0, 1), t3];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [D2(r3, u2, i2, 0, 1), t3];
          } };
        }
        function Lt(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 3))[0], i2 = t2[1], t2 = t2[2], u2 = T(a4, o2, void 0 !== t2 && t2);
          return { transform: function(t3) {
            t3 = k(t3, 2);
            return [t3[0], F(t3[1], u2, i2, 0, 1)];
          }, untransform: function(t3) {
            t3 = k(t3, 2);
            return [t3[0], D2(t3[1], u2, i2, 0, 1)];
          } };
        }
        function Ut(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 5))[0], i2 = t2[1], u2 = t2[2], s4 = t2[3], t2 = t2[4], l3 = T(a4, e4, t2 = void 0 !== t2 && t2), h2 = T(i2, o2, t2);
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [F(r3, l3, u2, 0, 1), F(t3, h2, s4, 0, 1)];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [D2(r3, l3, u2, 0, 1), D2(t3, h2, s4, 0, 1)];
          } };
        }
        function _t(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 5))[0], i2 = t2[1], u2 = t2[2], s4 = t2[3], t2 = void 0 !== (t2 = t2[4]) && t2, l3 = new w({ range: [0, e4] }), h2 = new w({ range: [0, o2] }), c6 = t2 ? a4 : l3.map(a4), p3 = t2 ? i2 : h2.map(i2);
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1], n4 = l3.map(r3) - c6, e6 = h2.map(t3) - p3, o3 = Math.sqrt(n4 * n4 + e6 * e6);
            return u2 < o3 ? [r3, t3] : (r3 = F(o3, 0, s4, 0, u2), t3 = Math.atan2(e6, n4), o3 = c6 + r3 * Math.cos(t3), e6 = p3 + r3 * Math.sin(t3), [l3.invert(o3), h2.invert(e6)]);
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1], n4 = l3.map(r3) - c6, e6 = h2.map(t3) - p3, o3 = Math.sqrt(n4 * n4 + e6 * e6);
            return u2 < o3 ? [r3, t3] : (r3 = D2(o3, 0, s4, 0, u2), t3 = Math.atan2(e6, n4), o3 = c6 + r3 * Math.cos(t3), e6 = p3 + r3 * Math.sin(t3), [l3.invert(o3), h2.invert(e6)]);
          } };
        }
        function Vt(t2, r2, n3, e4, o2, a4, i2) {
          var u2 = new w({ range: [r2, r2 + o2] }), s4 = new w({ range: [n3, n3 + a4] }), l3 = new w({ range: [e4, e4 + i2] });
          return { transform: function(t3) {
            var t3 = k(t3, 3), r3 = t3[0], n4 = t3[1], t3 = t3[2];
            return [u2.map(r3), s4.map(n4), l3.map(t3)];
          }, untransform: function(t3) {
            var t3 = k(t3, 3), r3 = t3[0], n4 = t3[1], t3 = t3[2];
            return [u2.invert(r3), s4.invert(n4), l3.invert(t3)];
          } };
        }
        function Gt(t2, r2, n3, e4, o2, a4, i2) {
          var u2, s4 = (t2 = k(t2, 3))[0], l3 = t2[1], t2 = t2[2];
          return u2 = R(), s4 = [s4, l3, t2], u2[0] = 1, u2[1] = 0, u2[2] = 0, u2[3] = 0, u2[4] = 0, u2[5] = 1, u2[6] = 0, u2[7] = 0, u2[8] = 0, u2[9] = 0, u2[10] = 1, u2[11] = 0, u2[12] = s4[0], u2[13] = s4[1], u2[14] = s4[2], u2[15] = 1, u2;
        }
        function Ht(t2, r2, n3, e4, o2, a4, i2) {
          return { transform: function(t3) {
            var t3 = k(t3, 3), r3 = t3[0];
            return [t3[1], r3, t3[2]];
          }, untransform: function(t3) {
            var t3 = k(t3, 3), r3 = t3[0];
            return [t3[1], r3, t3[2]];
          } };
        }
        function Qt(t2, r2, n3, e4, o2, a4, i2) {
          var u2, s4 = (t2 = k(t2, 3))[0], l3 = t2[1], t2 = t2[2];
          return u2 = R(), s4 = [s4, l3, t2], u2[0] = s4[0], u2[1] = 0, u2[2] = 0, u2[3] = 0, u2[4] = 0, u2[5] = s4[1], u2[6] = 0, u2[7] = 0, u2[8] = 0, u2[9] = 0, u2[10] = s4[2], u2[11] = 0, u2[12] = 0, u2[13] = 0, u2[14] = 0, u2[15] = 1, u2;
        }
        K.prototype.update = function(t2) {
          this.options = r({}, this.options, t2), this.recoordinate();
        }, K.prototype.clone = function() {
          return new K(this.options);
        }, K.prototype.getOptions = function() {
          return this.options;
        }, K.prototype.clear = function() {
          this.update({ transformations: [] });
        }, K.prototype.getSize = function() {
          var t2 = this.options;
          return [t2.width, t2.height];
        }, K.prototype.getCenter = function() {
          var t2 = this.options, r2 = t2.x, n3 = t2.y;
          return [(2 * r2 + t2.width) / 2, (2 * n3 + t2.height) / 2];
        }, K.prototype.transform = function() {
          for (var t2 = [], r2 = 0; r2 < arguments.length; r2++) t2[r2] = arguments[r2];
          var n3 = this.options.transformations;
          return this.update({ transformations: O(O([], k(n3), false), [O([], k(t2), false)], false) }), this;
        }, K.prototype.map = function(t2) {
          return this.output(t2);
        }, K.prototype.invert = function(t2) {
          return this.input(t2);
        }, K.prototype.recoordinate = function() {
          this.output = this.compose(), this.input = this.compose(true);
        }, K.prototype.compose = function(t2) {
          function r2(t3, r3) {
            var o3;
            u2.push((r3 = void 0 === r3 ? true : r3) ? (o3 = t3, function(t4) {
              for (var r4 = [], n4 = 0; n4 < t4.length - 1; n4 += 2) {
                var e6 = [t4[n4], t4[n4 + 1]], e6 = o3(e6);
                r4.push.apply(r4, O([], k(e6), false));
              }
              return r4;
            }) : t3);
          }
          var n3, e4, o2 = (t2 = void 0 === t2 ? false : t2) ? O([], k(this.options.transformations), false).reverse() : this.options.transformations, a4 = t2 ? function(t3) {
            return t3.untransform;
          } : function(t3) {
            return t3.transform;
          }, i2 = [], u2 = [];
          try {
            for (var s4 = x3(o2), l3 = s4.next(); !l3.done; l3 = s4.next()) {
              var h2, c6, p3, f2, d4, g2, v2 = k(l3.value), m4 = v2[0], y4 = v2.slice(1), M3 = this.transformers[m4];
              M3 && (c6 = (h2 = this.options).x, p3 = h2.y, f2 = h2.width, d4 = h2.height, _2(g2 = M3(O([], k(y4), false), c6, p3, f2, d4)) ? i2.push(g2) : (i2.length && (r2(this.createMatrixTransform(i2, t2)), i2.splice(0, i2.length)), r2(a4(g2) || A5, "parallel" !== m4)));
            }
          } catch (t3) {
            n3 = { error: t3 };
          } finally {
            try {
              l3 && !l3.done && (e4 = s4.return) && e4.call(s4);
            } finally {
              if (n3) throw n3.error;
            }
          }
          return i2.length && r2(this.createMatrixTransform(i2, t2)), U.apply(void 0, O([], k(u2), false));
        }, K.prototype.createMatrixTransform = function(t2, r2) {
          var n3, e4, o2, a4, i2, u2, s4, l3, h2, c6, p3, f2, d4 = g();
          return r2 && t2.reverse(), t2.forEach(function(t3) {
            return J(d4, d4, t3);
          }), r2 && (r2 = t2 = d4, (f2 = new P(9))[0] = r2[0], f2[1] = r2[1], f2[2] = r2[2], f2[3] = r2[3], f2[4] = r2[4], f2[5] = r2[5], f2[6] = r2[6], f2[7] = r2[7], f2[8] = r2[8], f2 = (r2 = f2)[0], n3 = r2[1], e4 = r2[2], o2 = r2[3], a4 = r2[4], i2 = r2[5], u2 = r2[6], s4 = r2[7], l3 = (r2 = r2[8]) * a4 - i2 * s4, p3 = f2 * l3 + n3 * (h2 = -r2 * o2 + i2 * u2) + e4 * (c6 = s4 * o2 - a4 * u2)) && (t2[0] = l3 * (p3 = 1 / p3), t2[1] = (-r2 * n3 + e4 * s4) * p3, t2[2] = (i2 * n3 - e4 * a4) * p3, t2[3] = h2 * p3, t2[4] = (r2 * f2 - e4 * u2) * p3, t2[5] = (-i2 * f2 + e4 * o2) * p3, t2[6] = c6 * p3, t2[7] = (-s4 * f2 + n3 * u2) * p3, t2[8] = (a4 * f2 - n3 * o2) * p3), function(t3) {
            var r3, n4, e6, o3, a5, t3 = [t3[0], t3[1], 1];
            return e6 = d4, o3 = (n4 = r3 = t3)[0], a5 = n4[1], n4 = n4[2], r3[0] = o3 * e6[0] + a5 * e6[3] + n4 * e6[6], r3[1] = o3 * e6[1] + a5 * e6[4] + n4 * e6[7], r3[2] = o3 * e6[2] + a5 * e6[5] + n4 * e6[8], [t3[0], t3[1]];
          };
        };
        o = K;
        function K(t2) {
          this.options = { x: 0, y: 0, width: 300, height: 150, transformations: [] }, this.transformers = { cartesian: Ft, translate: G, custom: Dt, matrix: Pt, polar: Rt, transpose: Tt, scale: S, "shear.x": zt, "shear.y": Et, reflect: Kt, "reflect.x": Nt, "reflect.y": qt, rotate: Ct, helix: Wt, parallel: Bt, fisheye: Ut, "fisheye.x": Jt, "fisheye.y": Lt, "fisheye.circular": _t }, this.update(t2);
        }
        N.prototype.update = function(t2) {
          this.options = r({}, this.options, t2), this.recoordinate();
        }, N.prototype.clone = function() {
          return new N(this.options);
        }, N.prototype.getOptions = function() {
          return this.options;
        }, N.prototype.clear = function() {
          this.update({ transformations: [] });
        }, N.prototype.getSize = function() {
          var t2 = this.options;
          return [t2.width, t2.height, t2.depth];
        }, N.prototype.getCenter = function() {
          var t2 = this.options, r2 = t2.x, n3 = t2.y, e4 = t2.z;
          return [(2 * r2 + t2.width) / 2, (2 * n3 + t2.height) / 2, (2 * e4 + t2.depth) / 2];
        }, N.prototype.transform = function() {
          for (var t2 = [], r2 = 0; r2 < arguments.length; r2++) t2[r2] = arguments[r2];
          var n3 = this.options.transformations;
          return this.update({ transformations: O(O([], k(n3), false), [O([], k(t2), false)], false) }), this;
        }, N.prototype.map = function(t2) {
          return this.output(t2);
        }, N.prototype.invert = function(t2) {
          return this.input(t2);
        }, N.prototype.recoordinate = function() {
          this.output = this.compose(), this.input = this.compose(true);
        }, N.prototype.compose = function(t2) {
          function r2(t3, r3) {
            var o3;
            u2.push((r3 = void 0 === r3 ? true : r3) ? (o3 = t3, function(t4) {
              for (var r4 = [], n4 = 0; n4 < t4.length - 1; n4 += 3) {
                var e6 = [t4[n4], t4[n4 + 1], t4[n4 + 2]], e6 = o3(e6);
                r4.push.apply(r4, O([], k(e6), false));
              }
              return r4;
            }) : t3);
          }
          var n3, e4, o2 = (t2 = void 0 === t2 ? false : t2) ? O([], k(this.options.transformations), false).reverse() : this.options.transformations, a4 = t2 ? function(t3) {
            return t3.untransform;
          } : function(t3) {
            return t3.transform;
          }, i2 = [], u2 = [];
          try {
            for (var s4 = x3(o2), l3 = s4.next(); !l3.done; l3 = s4.next()) {
              var h2, c6, p3, f2, d4, g2, v2, m4, y4 = k(l3.value), M3 = y4[0], w2 = y4.slice(1), b2 = this.transformers[M3];
              b2 && (c6 = (h2 = this.options).x, p3 = h2.y, f2 = h2.z, d4 = h2.width, g2 = h2.height, v2 = h2.depth, _2(m4 = b2(O([], k(w2), false), c6, p3, f2, d4, g2, v2)) ? i2.push(m4) : (i2.length && (r2(this.createMatrixTransform(i2, t2)), i2.splice(0, i2.length)), r2(a4(m4) || A5, true)));
            }
          } catch (t3) {
            n3 = { error: t3 };
          } finally {
            try {
              l3 && !l3.done && (e4 = s4.return) && e4.call(s4);
            } finally {
              if (n3) throw n3.error;
            }
          }
          return i2.length && r2(this.createMatrixTransform(i2, t2)), U.apply(void 0, O([], k(u2), false));
        }, N.prototype.createMatrixTransform = function(t2, r2) {
          var n3, e4, o2, a4, i2, u2, s4, l3, h2, c6, p3, f2, d4, g2, v2, m4, y4, M3, w2, b2, x4, k2, O2, A6, j2, I2, S2, F2, D3 = R();
          return r2 && t2.reverse(), t2.forEach(function(t3) {
            return L(D3, D3, t3);
          }), r2 && (r2 = t2 = D3, (F2 = new P(16))[0] = r2[0], F2[1] = r2[1], F2[2] = r2[2], F2[3] = r2[3], F2[4] = r2[4], F2[5] = r2[5], F2[6] = r2[6], F2[7] = r2[7], F2[8] = r2[8], F2[9] = r2[9], F2[10] = r2[10], F2[11] = r2[11], F2[12] = r2[12], F2[13] = r2[13], F2[14] = r2[14], F2[15] = r2[15], F2 = (r2 = F2)[0], n3 = r2[1], e4 = r2[2], o2 = r2[3], a4 = r2[4], i2 = r2[5], u2 = r2[6], s4 = r2[7], l3 = r2[8], h2 = r2[9], c6 = r2[10], p3 = r2[11], f2 = r2[12], d4 = r2[13], g2 = r2[14], r2 = r2[15], S2 = (v2 = F2 * i2 - n3 * a4) * (I2 = c6 * r2 - p3 * g2) - (m4 = F2 * u2 - e4 * a4) * (j2 = h2 * r2 - p3 * d4) + (y4 = F2 * s4 - o2 * a4) * (A6 = h2 * g2 - c6 * d4) + (M3 = n3 * u2 - e4 * i2) * (O2 = l3 * r2 - p3 * f2) - (w2 = n3 * s4 - o2 * i2) * (k2 = l3 * g2 - c6 * f2) + (b2 = e4 * s4 - o2 * u2) * (x4 = l3 * d4 - h2 * f2)) && (t2[0] = (i2 * I2 - u2 * j2 + s4 * A6) * (S2 = 1 / S2), t2[1] = (e4 * j2 - n3 * I2 - o2 * A6) * S2, t2[2] = (d4 * b2 - g2 * w2 + r2 * M3) * S2, t2[3] = (c6 * w2 - h2 * b2 - p3 * M3) * S2, t2[4] = (u2 * O2 - a4 * I2 - s4 * k2) * S2, t2[5] = (F2 * I2 - e4 * O2 + o2 * k2) * S2, t2[6] = (g2 * y4 - f2 * b2 - r2 * m4) * S2, t2[7] = (l3 * b2 - c6 * y4 + p3 * m4) * S2, t2[8] = (a4 * j2 - i2 * O2 + s4 * x4) * S2, t2[9] = (n3 * O2 - F2 * j2 - o2 * x4) * S2, t2[10] = (f2 * w2 - d4 * y4 + r2 * v2) * S2, t2[11] = (h2 * y4 - l3 * w2 - p3 * v2) * S2, t2[12] = (i2 * k2 - a4 * A6 - u2 * x4) * S2, t2[13] = (F2 * A6 - n3 * k2 + e4 * x4) * S2, t2[14] = (d4 * m4 - f2 * M3 - g2 * v2) * S2, t2[15] = (l3 * M3 - h2 * m4 + c6 * v2) * S2), function(t3) {
            var r3, n4, e6, o3, a5, i3, t3 = [t3[0], t3[1], t3[2], 1];
            return e6 = D3, o3 = (n4 = r3 = t3)[0], a5 = n4[1], i3 = n4[2], n4 = n4[3], r3[0] = e6[0] * o3 + e6[4] * a5 + e6[8] * i3 + e6[12] * n4, r3[1] = e6[1] * o3 + e6[5] * a5 + e6[9] * i3 + e6[13] * n4, r3[2] = e6[2] * o3 + e6[6] * a5 + e6[10] * i3 + e6[14] * n4, r3[3] = e6[3] * o3 + e6[7] * a5 + e6[11] * i3 + e6[15] * n4, [t3[0], t3[1], t3[2]];
          };
        };
        j = N;
        function N(t2) {
          this.options = { x: 0, y: 0, z: 0, width: 300, height: 150, depth: 150, transformations: [] }, this.transformers = { cartesian3D: Vt, translate3D: Gt, scale3D: Qt, transpose3D: Ht }, this.update(t2);
        }
        t.Coordinate = o, t.Coordinate3D = j, Object.defineProperty(t, "__esModule", { value: true });
      });
    }
  });

  // node_modules/pdfast/src/helper.js
  var require_helper = __commonJS({
    "node_modules/pdfast/src/helper.js"(exports, module) {
      "use strict";
      var self2 = module.exports;
      module.exports.isNumber = function(x3) {
        return typeof x3 === "number";
      };
      module.exports.findMin = function(arr) {
        if (arr.length === 0) {
          return Infinity;
        }
        var curr = arr[0];
        for (var i = 1; i < arr.length; i++) {
          curr = Math.min(curr, arr[i]);
        }
        return curr;
      };
      module.exports.findMax = function(arr) {
        if (arr.length === 0) {
          return -Infinity;
        }
        var curr = arr[0];
        for (var i = 1; i < arr.length; i++) {
          curr = Math.max(curr, arr[i]);
        }
        return curr;
      };
      module.exports.findMinMulti = function(arr) {
        var curr = self2.findMin(arr[0]);
        for (var i = 1; i < arr.length; i++) {
          curr = Math.min(curr, self2.findMin(arr[i]));
        }
        return curr;
      };
      module.exports.findMaxMulti = function(arr) {
        var curr = self2.findMax(arr[0]);
        for (var i = 1; i < arr.length; i++) {
          curr = Math.max(curr, self2.findMax(arr[i]));
        }
        return curr;
      };
      module.exports.inside = function(min10, max11, x3) {
        return min10 <= x3 && x3 <= max11;
      };
    }
  });

  // node_modules/pdfast/src/index.js
  var require_src = __commonJS({
    "node_modules/pdfast/src/index.js"(exports, module) {
      "use strict";
      var DEFAULT_SIZE = 50;
      var DEFAULT_WIDTH = 2;
      var LN_2 = Math.log(2);
      var self2 = module.exports;
      var helper = require_helper();
      function kernel(x3) {
        return 1 - Math.abs(x3);
      }
      module.exports.getUnifiedMinMax = function(arr, options) {
        return self2.getUnifiedMinMaxMulti([arr], options);
      };
      module.exports.getUnifiedMinMaxMulti = function(arrMulti, options) {
        options = options || {};
        var relaxMin = false;
        var relaxMax = false;
        var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
        var size2 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
        var min10 = helper.isNumber(options.min) ? options.min : (relaxMin = true, helper.findMinMulti(arrMulti));
        var max11 = helper.isNumber(options.max) ? options.max : (relaxMax = true, helper.findMaxMulti(arrMulti));
        var range3 = max11 - min10;
        var step2 = range3 / (size2 - 1);
        if (relaxMin) {
          min10 = min10 - 2 * width * step2;
        }
        if (relaxMax) {
          max11 = max11 + 2 * width * step2;
        }
        return {
          min: min10,
          max: max11
        };
      };
      module.exports.create = function(arr, options) {
        options = options || {};
        if (!arr || arr.length === 0) {
          return [];
        }
        var size2 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
        var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
        var normalizedMinMax = self2.getUnifiedMinMax(arr, {
          size: size2,
          width,
          min: options.min,
          max: options.max
        });
        var min10 = normalizedMinMax.min;
        var max11 = normalizedMinMax.max;
        var range3 = max11 - min10;
        var step2 = range3 / (size2 - 1);
        if (range3 === 0) {
          return [{ x: min10, y: 1 }];
        }
        var buckets = [];
        for (var i = 0; i < size2; i++) {
          buckets.push({
            x: min10 + i * step2,
            y: 0
          });
        }
        var xToBucket = function(x3) {
          return Math.floor((x3 - min10) / step2);
        };
        var partialArea = generatePartialAreas(kernel, width);
        var fullArea = partialArea[width];
        var c5 = partialArea[width - 1] - partialArea[width - 2];
        var initalValue = 0;
        arr.forEach(function(x3) {
          var bucket = xToBucket(x3);
          if (bucket + width < 0 || bucket - width >= buckets.length) {
            return;
          }
          var start2 = Math.max(bucket - width, 0);
          var mid2 = bucket;
          var end = Math.min(bucket + width, buckets.length - 1);
          var leftBlockCount = start2 - (bucket - width);
          var rightBlockCount = bucket + width - end;
          var spilledAreaLeft = partialArea[-width - 1 + leftBlockCount] || 0;
          var spilledAreaRight = partialArea[-width - 1 + rightBlockCount] || 0;
          var weight2 = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);
          if (leftBlockCount > 0) {
            initalValue += weight2 * (leftBlockCount - 1) * c5;
          }
          var startGradPos = Math.max(0, bucket - width + 1);
          if (helper.inside(0, buckets.length - 1, startGradPos)) {
            buckets[startGradPos].y += weight2 * 1 * c5;
          }
          if (helper.inside(0, buckets.length - 1, mid2 + 1)) {
            buckets[mid2 + 1].y -= weight2 * 2 * c5;
          }
          if (helper.inside(0, buckets.length - 1, end + 1)) {
            buckets[end + 1].y += weight2 * 1 * c5;
          }
        });
        var accumulator = initalValue;
        var gradAccumulator = 0;
        var area2 = 0;
        buckets.forEach(function(bucket) {
          gradAccumulator += bucket.y;
          accumulator += gradAccumulator;
          bucket.y = accumulator;
          area2 += accumulator;
        });
        if (area2 > 0) {
          buckets.forEach(function(bucket) {
            bucket.y /= area2;
          });
        }
        return buckets;
      };
      function generatePartialAreas(kernel2, width) {
        var partialAreas = {};
        var accumulator = 0;
        for (var i = -width; i <= width; i++) {
          accumulator += kernel2(i / width);
          partialAreas[i] = accumulator;
        }
        return partialAreas;
      }
      module.exports.getExpectedValueFromPdf = function(pdf2) {
        if (!pdf2 || pdf2.length === 0) {
          return void 0;
        }
        var expected = 0;
        pdf2.forEach(function(obj) {
          expected += obj.x * obj.y;
        });
        return expected;
      };
      module.exports.getXWithLeftTailArea = function(pdf2, area2) {
        if (!pdf2 || pdf2.length === 0) {
          return void 0;
        }
        var accumulator = 0;
        var last4 = 0;
        for (var i = 0; i < pdf2.length; i++) {
          last4 = i;
          accumulator += pdf2[i].y;
          if (accumulator >= area2) {
            break;
          }
        }
        return pdf2[last4].x;
      };
      module.exports.getPerplexity = function(pdf2) {
        if (!pdf2 || pdf2.length === 0) {
          return void 0;
        }
        var entropy = 0;
        pdf2.forEach(function(obj) {
          var ln2 = Math.log(obj.y);
          if (isFinite(ln2)) {
            entropy += obj.y * ln2;
          }
        });
        entropy = -entropy / LN_2;
        return Math.pow(2, entropy);
      };
    }
  });

  // node_modules/fmin/build/fmin.js
  var require_fmin = __commonJS({
    "node_modules/fmin/build/fmin.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.fmin = global2.fmin || {});
      })(exports, function(exports2) {
        "use strict";
        function bisect3(f, a3, b, parameters) {
          parameters = parameters || {};
          var maxIterations = parameters.maxIterations || 100, tolerance2 = parameters.tolerance || 1e-10, fA = f(a3), fB = f(b), delta = b - a3;
          if (fA * fB > 0) {
            throw "Initial bisect points must have opposite signs";
          }
          if (fA === 0) return a3;
          if (fB === 0) return b;
          for (var i = 0; i < maxIterations; ++i) {
            delta /= 2;
            var mid2 = a3 + delta, fMid = f(mid2);
            if (fMid * fA >= 0) {
              a3 = mid2;
            }
            if (Math.abs(delta) < tolerance2 || fMid === 0) {
              return mid2;
            }
          }
          return a3 + delta;
        }
        function zeros2(x3) {
          var r = new Array(x3);
          for (var i = 0; i < x3; ++i) {
            r[i] = 0;
          }
          return r;
        }
        function zerosM2(x3, y3) {
          return zeros2(x3).map(function() {
            return zeros2(y3);
          });
        }
        function dot8(a3, b) {
          var ret = 0;
          for (var i = 0; i < a3.length; ++i) {
            ret += a3[i] * b[i];
          }
          return ret;
        }
        function norm22(a3) {
          return Math.sqrt(dot8(a3, a3));
        }
        function scale10(ret, value2, c5) {
          for (var i = 0; i < value2.length; ++i) {
            ret[i] = value2[i] * c5;
          }
        }
        function weightedSum(ret, w1, v1, w2, v2) {
          for (var j = 0; j < ret.length; ++j) {
            ret[j] = w1 * v1[j] + w2 * v2[j];
          }
        }
        function nelderMead2(f, x05, parameters) {
          parameters = parameters || {};
          var maxIterations = parameters.maxIterations || x05.length * 200, nonZeroDelta = parameters.nonZeroDelta || 1.05, zeroDelta = parameters.zeroDelta || 1e-3, minErrorDelta = parameters.minErrorDelta || 1e-6, minTolerance = parameters.minErrorDelta || 1e-5, rho = parameters.rho !== void 0 ? parameters.rho : 1, chi = parameters.chi !== void 0 ? parameters.chi : 2, psi = parameters.psi !== void 0 ? parameters.psi : -0.5, sigma = parameters.sigma !== void 0 ? parameters.sigma : 0.5, maxDiff;
          var N = x05.length, simplex = new Array(N + 1);
          simplex[0] = x05;
          simplex[0].fx = f(x05);
          simplex[0].id = 0;
          for (var i = 0; i < N; ++i) {
            var point6 = x05.slice();
            point6[i] = point6[i] ? point6[i] * nonZeroDelta : zeroDelta;
            simplex[i + 1] = point6;
            simplex[i + 1].fx = f(point6);
            simplex[i + 1].id = i + 1;
          }
          function updateSimplex(value2) {
            for (var i2 = 0; i2 < value2.length; i2++) {
              simplex[N][i2] = value2[i2];
            }
            simplex[N].fx = value2.fx;
          }
          var sortOrder = function(a3, b) {
            return a3.fx - b.fx;
          };
          var centroid = x05.slice(), reflected = x05.slice(), contracted = x05.slice(), expanded = x05.slice();
          for (var iteration = 0; iteration < maxIterations; ++iteration) {
            simplex.sort(sortOrder);
            if (parameters.history) {
              var sortedSimplex = simplex.map(function(x3) {
                var state = x3.slice();
                state.fx = x3.fx;
                state.id = x3.id;
                return state;
              });
              sortedSimplex.sort(function(a3, b) {
                return a3.id - b.id;
              });
              parameters.history.push({
                x: simplex[0].slice(),
                fx: simplex[0].fx,
                simplex: sortedSimplex
              });
            }
            maxDiff = 0;
            for (i = 0; i < N; ++i) {
              maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
            }
            if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {
              break;
            }
            for (i = 0; i < N; ++i) {
              centroid[i] = 0;
              for (var j = 0; j < N; ++j) {
                centroid[i] += simplex[j][i];
              }
              centroid[i] /= N;
            }
            var worst = simplex[N];
            weightedSum(reflected, 1 + rho, centroid, -rho, worst);
            reflected.fx = f(reflected);
            if (reflected.fx < simplex[0].fx) {
              weightedSum(expanded, 1 + chi, centroid, -chi, worst);
              expanded.fx = f(expanded);
              if (expanded.fx < reflected.fx) {
                updateSimplex(expanded);
              } else {
                updateSimplex(reflected);
              }
            } else if (reflected.fx >= simplex[N - 1].fx) {
              var shouldReduce = false;
              if (reflected.fx > worst.fx) {
                weightedSum(contracted, 1 + psi, centroid, -psi, worst);
                contracted.fx = f(contracted);
                if (contracted.fx < worst.fx) {
                  updateSimplex(contracted);
                } else {
                  shouldReduce = true;
                }
              } else {
                weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);
                contracted.fx = f(contracted);
                if (contracted.fx < reflected.fx) {
                  updateSimplex(contracted);
                } else {
                  shouldReduce = true;
                }
              }
              if (shouldReduce) {
                if (sigma >= 1) break;
                for (i = 1; i < simplex.length; ++i) {
                  weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
                  simplex[i].fx = f(simplex[i]);
                }
              }
            } else {
              updateSimplex(reflected);
            }
          }
          simplex.sort(sortOrder);
          return {
            fx: simplex[0].fx,
            x: simplex[0]
          };
        }
        function wolfeLineSearch(f, pk, current, next, a3, c1, c22) {
          var phi0 = current.fx, phiPrime0 = dot8(current.fxprime, pk), phi2 = phi0, phi_old = phi0, phiPrime = phiPrime0, a0 = 0;
          a3 = a3 || 1;
          c1 = c1 || 1e-6;
          c22 = c22 || 0.1;
          function zoom(a_lo, a_high, phi_lo) {
            for (var iteration2 = 0; iteration2 < 16; ++iteration2) {
              a3 = (a_lo + a_high) / 2;
              weightedSum(next.x, 1, current.x, a3, pk);
              phi2 = next.fx = f(next.x, next.fxprime);
              phiPrime = dot8(next.fxprime, pk);
              if (phi2 > phi0 + c1 * a3 * phiPrime0 || phi2 >= phi_lo) {
                a_high = a3;
              } else {
                if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
                  return a3;
                }
                if (phiPrime * (a_high - a_lo) >= 0) {
                  a_high = a_lo;
                }
                a_lo = a3;
                phi_lo = phi2;
              }
            }
            return 0;
          }
          for (var iteration = 0; iteration < 10; ++iteration) {
            weightedSum(next.x, 1, current.x, a3, pk);
            phi2 = next.fx = f(next.x, next.fxprime);
            phiPrime = dot8(next.fxprime, pk);
            if (phi2 > phi0 + c1 * a3 * phiPrime0 || iteration && phi2 >= phi_old) {
              return zoom(a0, a3, phi_old);
            }
            if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
              return a3;
            }
            if (phiPrime >= 0) {
              return zoom(a3, a0, phi2);
            }
            phi_old = phi2;
            a0 = a3;
            a3 *= 2;
          }
          return a3;
        }
        function conjugateGradient2(f, initial, params) {
          var current = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, next = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, yk = initial.slice(), pk, temp, a3 = 1, maxIterations;
          params = params || {};
          maxIterations = params.maxIterations || initial.length * 20;
          current.fx = f(current.x, current.fxprime);
          pk = current.fxprime.slice();
          scale10(pk, current.fxprime, -1);
          for (var i = 0; i < maxIterations; ++i) {
            a3 = wolfeLineSearch(f, pk, current, next, a3);
            if (params.history) {
              params.history.push({
                x: current.x.slice(),
                fx: current.fx,
                fxprime: current.fxprime.slice(),
                alpha: a3
              });
            }
            if (!a3) {
              scale10(pk, current.fxprime, -1);
            } else {
              weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
              var delta_k = dot8(current.fxprime, current.fxprime), beta_k = Math.max(0, dot8(yk, next.fxprime) / delta_k);
              weightedSum(pk, beta_k, pk, -1, next.fxprime);
              temp = current;
              current = next;
              next = temp;
            }
            if (norm22(current.fxprime) <= 1e-5) {
              break;
            }
          }
          if (params.history) {
            params.history.push({
              x: current.x.slice(),
              fx: current.fx,
              fxprime: current.fxprime.slice(),
              alpha: a3
            });
          }
          return current;
        }
        function gradientDescent(f, initial, params) {
          params = params || {};
          var maxIterations = params.maxIterations || initial.length * 100, learnRate = params.learnRate || 1e-3, current = { x: initial.slice(), fx: 0, fxprime: initial.slice() };
          for (var i = 0; i < maxIterations; ++i) {
            current.fx = f(current.x, current.fxprime);
            if (params.history) {
              params.history.push({
                x: current.x.slice(),
                fx: current.fx,
                fxprime: current.fxprime.slice()
              });
            }
            weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);
            if (norm22(current.fxprime) <= 1e-5) {
              break;
            }
          }
          return current;
        }
        function gradientDescentLineSearch(f, initial, params) {
          params = params || {};
          var current = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, next = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, maxIterations = params.maxIterations || initial.length * 100, learnRate = params.learnRate || 1, pk = initial.slice(), c1 = params.c1 || 1e-3, c22 = params.c2 || 0.1, temp, functionCalls = [];
          if (params.history) {
            var inner = f;
            f = function(x3, fxprime) {
              functionCalls.push(x3.slice());
              return inner(x3, fxprime);
            };
          }
          current.fx = f(current.x, current.fxprime);
          for (var i = 0; i < maxIterations; ++i) {
            scale10(pk, current.fxprime, -1);
            learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c22);
            if (params.history) {
              params.history.push({
                x: current.x.slice(),
                fx: current.fx,
                fxprime: current.fxprime.slice(),
                functionCalls,
                learnRate,
                alpha: learnRate
              });
              functionCalls = [];
            }
            temp = current;
            current = next;
            next = temp;
            if (learnRate === 0 || norm22(current.fxprime) < 1e-5) break;
          }
          return current;
        }
        exports2.bisect = bisect3;
        exports2.nelderMead = nelderMead2;
        exports2.conjugateGradient = conjugateGradient2;
        exports2.gradientDescent = gradientDescent;
        exports2.gradientDescentLineSearch = gradientDescentLineSearch;
        exports2.zeros = zeros2;
        exports2.zerosM = zerosM2;
        exports2.norm2 = norm22;
        exports2.weightedSum = weightedSum;
        exports2.scale = scale10;
      });
    }
  });

  // node_modules/spark-md5/spark-md5.js
  var require_spark_md5 = __commonJS({
    "node_modules/spark-md5/spark-md5.js"(exports, module) {
      (function(factory) {
        if (typeof exports === "object") {
          module.exports = factory();
        } else if (typeof define === "function" && define.amd) {
          define(factory);
        } else {
          var glob;
          try {
            glob = window;
          } catch (e3) {
            glob = self;
          }
          glob.SparkMD5 = factory();
        }
      })(function(undefined2) {
        "use strict";
        var add32 = function(a3, b) {
          return a3 + b & 4294967295;
        }, hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        function cmn(q, a3, b, x3, s3, t) {
          a3 = add32(add32(a3, q), add32(x3, t));
          return add32(a3 << s3 | a3 >>> 32 - s3, b);
        }
        function md5cycle(x3, k) {
          var a3 = x3[0], b = x3[1], c5 = x3[2], d3 = x3[3];
          a3 += (b & c5 | ~b & d3) + k[0] - 680876936 | 0;
          a3 = (a3 << 7 | a3 >>> 25) + b | 0;
          d3 += (a3 & b | ~a3 & c5) + k[1] - 389564586 | 0;
          d3 = (d3 << 12 | d3 >>> 20) + a3 | 0;
          c5 += (d3 & a3 | ~d3 & b) + k[2] + 606105819 | 0;
          c5 = (c5 << 17 | c5 >>> 15) + d3 | 0;
          b += (c5 & d3 | ~c5 & a3) + k[3] - 1044525330 | 0;
          b = (b << 22 | b >>> 10) + c5 | 0;
          a3 += (b & c5 | ~b & d3) + k[4] - 176418897 | 0;
          a3 = (a3 << 7 | a3 >>> 25) + b | 0;
          d3 += (a3 & b | ~a3 & c5) + k[5] + 1200080426 | 0;
          d3 = (d3 << 12 | d3 >>> 20) + a3 | 0;
          c5 += (d3 & a3 | ~d3 & b) + k[6] - 1473231341 | 0;
          c5 = (c5 << 17 | c5 >>> 15) + d3 | 0;
          b += (c5 & d3 | ~c5 & a3) + k[7] - 45705983 | 0;
          b = (b << 22 | b >>> 10) + c5 | 0;
          a3 += (b & c5 | ~b & d3) + k[8] + 1770035416 | 0;
          a3 = (a3 << 7 | a3 >>> 25) + b | 0;
          d3 += (a3 & b | ~a3 & c5) + k[9] - 1958414417 | 0;
          d3 = (d3 << 12 | d3 >>> 20) + a3 | 0;
          c5 += (d3 & a3 | ~d3 & b) + k[10] - 42063 | 0;
          c5 = (c5 << 17 | c5 >>> 15) + d3 | 0;
          b += (c5 & d3 | ~c5 & a3) + k[11] - 1990404162 | 0;
          b = (b << 22 | b >>> 10) + c5 | 0;
          a3 += (b & c5 | ~b & d3) + k[12] + 1804603682 | 0;
          a3 = (a3 << 7 | a3 >>> 25) + b | 0;
          d3 += (a3 & b | ~a3 & c5) + k[13] - 40341101 | 0;
          d3 = (d3 << 12 | d3 >>> 20) + a3 | 0;
          c5 += (d3 & a3 | ~d3 & b) + k[14] - 1502002290 | 0;
          c5 = (c5 << 17 | c5 >>> 15) + d3 | 0;
          b += (c5 & d3 | ~c5 & a3) + k[15] + 1236535329 | 0;
          b = (b << 22 | b >>> 10) + c5 | 0;
          a3 += (b & d3 | c5 & ~d3) + k[1] - 165796510 | 0;
          a3 = (a3 << 5 | a3 >>> 27) + b | 0;
          d3 += (a3 & c5 | b & ~c5) + k[6] - 1069501632 | 0;
          d3 = (d3 << 9 | d3 >>> 23) + a3 | 0;
          c5 += (d3 & b | a3 & ~b) + k[11] + 643717713 | 0;
          c5 = (c5 << 14 | c5 >>> 18) + d3 | 0;
          b += (c5 & a3 | d3 & ~a3) + k[0] - 373897302 | 0;
          b = (b << 20 | b >>> 12) + c5 | 0;
          a3 += (b & d3 | c5 & ~d3) + k[5] - 701558691 | 0;
          a3 = (a3 << 5 | a3 >>> 27) + b | 0;
          d3 += (a3 & c5 | b & ~c5) + k[10] + 38016083 | 0;
          d3 = (d3 << 9 | d3 >>> 23) + a3 | 0;
          c5 += (d3 & b | a3 & ~b) + k[15] - 660478335 | 0;
          c5 = (c5 << 14 | c5 >>> 18) + d3 | 0;
          b += (c5 & a3 | d3 & ~a3) + k[4] - 405537848 | 0;
          b = (b << 20 | b >>> 12) + c5 | 0;
          a3 += (b & d3 | c5 & ~d3) + k[9] + 568446438 | 0;
          a3 = (a3 << 5 | a3 >>> 27) + b | 0;
          d3 += (a3 & c5 | b & ~c5) + k[14] - 1019803690 | 0;
          d3 = (d3 << 9 | d3 >>> 23) + a3 | 0;
          c5 += (d3 & b | a3 & ~b) + k[3] - 187363961 | 0;
          c5 = (c5 << 14 | c5 >>> 18) + d3 | 0;
          b += (c5 & a3 | d3 & ~a3) + k[8] + 1163531501 | 0;
          b = (b << 20 | b >>> 12) + c5 | 0;
          a3 += (b & d3 | c5 & ~d3) + k[13] - 1444681467 | 0;
          a3 = (a3 << 5 | a3 >>> 27) + b | 0;
          d3 += (a3 & c5 | b & ~c5) + k[2] - 51403784 | 0;
          d3 = (d3 << 9 | d3 >>> 23) + a3 | 0;
          c5 += (d3 & b | a3 & ~b) + k[7] + 1735328473 | 0;
          c5 = (c5 << 14 | c5 >>> 18) + d3 | 0;
          b += (c5 & a3 | d3 & ~a3) + k[12] - 1926607734 | 0;
          b = (b << 20 | b >>> 12) + c5 | 0;
          a3 += (b ^ c5 ^ d3) + k[5] - 378558 | 0;
          a3 = (a3 << 4 | a3 >>> 28) + b | 0;
          d3 += (a3 ^ b ^ c5) + k[8] - 2022574463 | 0;
          d3 = (d3 << 11 | d3 >>> 21) + a3 | 0;
          c5 += (d3 ^ a3 ^ b) + k[11] + 1839030562 | 0;
          c5 = (c5 << 16 | c5 >>> 16) + d3 | 0;
          b += (c5 ^ d3 ^ a3) + k[14] - 35309556 | 0;
          b = (b << 23 | b >>> 9) + c5 | 0;
          a3 += (b ^ c5 ^ d3) + k[1] - 1530992060 | 0;
          a3 = (a3 << 4 | a3 >>> 28) + b | 0;
          d3 += (a3 ^ b ^ c5) + k[4] + 1272893353 | 0;
          d3 = (d3 << 11 | d3 >>> 21) + a3 | 0;
          c5 += (d3 ^ a3 ^ b) + k[7] - 155497632 | 0;
          c5 = (c5 << 16 | c5 >>> 16) + d3 | 0;
          b += (c5 ^ d3 ^ a3) + k[10] - 1094730640 | 0;
          b = (b << 23 | b >>> 9) + c5 | 0;
          a3 += (b ^ c5 ^ d3) + k[13] + 681279174 | 0;
          a3 = (a3 << 4 | a3 >>> 28) + b | 0;
          d3 += (a3 ^ b ^ c5) + k[0] - 358537222 | 0;
          d3 = (d3 << 11 | d3 >>> 21) + a3 | 0;
          c5 += (d3 ^ a3 ^ b) + k[3] - 722521979 | 0;
          c5 = (c5 << 16 | c5 >>> 16) + d3 | 0;
          b += (c5 ^ d3 ^ a3) + k[6] + 76029189 | 0;
          b = (b << 23 | b >>> 9) + c5 | 0;
          a3 += (b ^ c5 ^ d3) + k[9] - 640364487 | 0;
          a3 = (a3 << 4 | a3 >>> 28) + b | 0;
          d3 += (a3 ^ b ^ c5) + k[12] - 421815835 | 0;
          d3 = (d3 << 11 | d3 >>> 21) + a3 | 0;
          c5 += (d3 ^ a3 ^ b) + k[15] + 530742520 | 0;
          c5 = (c5 << 16 | c5 >>> 16) + d3 | 0;
          b += (c5 ^ d3 ^ a3) + k[2] - 995338651 | 0;
          b = (b << 23 | b >>> 9) + c5 | 0;
          a3 += (c5 ^ (b | ~d3)) + k[0] - 198630844 | 0;
          a3 = (a3 << 6 | a3 >>> 26) + b | 0;
          d3 += (b ^ (a3 | ~c5)) + k[7] + 1126891415 | 0;
          d3 = (d3 << 10 | d3 >>> 22) + a3 | 0;
          c5 += (a3 ^ (d3 | ~b)) + k[14] - 1416354905 | 0;
          c5 = (c5 << 15 | c5 >>> 17) + d3 | 0;
          b += (d3 ^ (c5 | ~a3)) + k[5] - 57434055 | 0;
          b = (b << 21 | b >>> 11) + c5 | 0;
          a3 += (c5 ^ (b | ~d3)) + k[12] + 1700485571 | 0;
          a3 = (a3 << 6 | a3 >>> 26) + b | 0;
          d3 += (b ^ (a3 | ~c5)) + k[3] - 1894986606 | 0;
          d3 = (d3 << 10 | d3 >>> 22) + a3 | 0;
          c5 += (a3 ^ (d3 | ~b)) + k[10] - 1051523 | 0;
          c5 = (c5 << 15 | c5 >>> 17) + d3 | 0;
          b += (d3 ^ (c5 | ~a3)) + k[1] - 2054922799 | 0;
          b = (b << 21 | b >>> 11) + c5 | 0;
          a3 += (c5 ^ (b | ~d3)) + k[8] + 1873313359 | 0;
          a3 = (a3 << 6 | a3 >>> 26) + b | 0;
          d3 += (b ^ (a3 | ~c5)) + k[15] - 30611744 | 0;
          d3 = (d3 << 10 | d3 >>> 22) + a3 | 0;
          c5 += (a3 ^ (d3 | ~b)) + k[6] - 1560198380 | 0;
          c5 = (c5 << 15 | c5 >>> 17) + d3 | 0;
          b += (d3 ^ (c5 | ~a3)) + k[13] + 1309151649 | 0;
          b = (b << 21 | b >>> 11) + c5 | 0;
          a3 += (c5 ^ (b | ~d3)) + k[4] - 145523070 | 0;
          a3 = (a3 << 6 | a3 >>> 26) + b | 0;
          d3 += (b ^ (a3 | ~c5)) + k[11] - 1120210379 | 0;
          d3 = (d3 << 10 | d3 >>> 22) + a3 | 0;
          c5 += (a3 ^ (d3 | ~b)) + k[2] + 718787259 | 0;
          c5 = (c5 << 15 | c5 >>> 17) + d3 | 0;
          b += (d3 ^ (c5 | ~a3)) + k[9] - 343485551 | 0;
          b = (b << 21 | b >>> 11) + c5 | 0;
          x3[0] = a3 + x3[0] | 0;
          x3[1] = b + x3[1] | 0;
          x3[2] = c5 + x3[2] | 0;
          x3[3] = d3 + x3[3] | 0;
        }
        function md5blk(s3) {
          var md5blks = [], i;
          for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s3.charCodeAt(i) + (s3.charCodeAt(i + 1) << 8) + (s3.charCodeAt(i + 2) << 16) + (s3.charCodeAt(i + 3) << 24);
          }
          return md5blks;
        }
        function md5blk_array(a3) {
          var md5blks = [], i;
          for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a3[i] + (a3[i + 1] << 8) + (a3[i + 2] << 16) + (a3[i + 3] << 24);
          }
          return md5blks;
        }
        function md51(s3) {
          var n2 = s3.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length5, tail, tmp2, lo, hi;
          for (i = 64; i <= n2; i += 64) {
            md5cycle(state, md5blk(s3.substring(i - 64, i)));
          }
          s3 = s3.substring(i - 64);
          length5 = s3.length;
          tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          for (i = 0; i < length5; i += 1) {
            tail[i >> 2] |= s3.charCodeAt(i) << (i % 4 << 3);
          }
          tail[i >> 2] |= 128 << (i % 4 << 3);
          if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
              tail[i] = 0;
            }
          }
          tmp2 = n2 * 8;
          tmp2 = tmp2.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp2[2], 16);
          hi = parseInt(tmp2[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(state, tail);
          return state;
        }
        function md51_array(a3) {
          var n2 = a3.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length5, tail, tmp2, lo, hi;
          for (i = 64; i <= n2; i += 64) {
            md5cycle(state, md5blk_array(a3.subarray(i - 64, i)));
          }
          a3 = i - 64 < n2 ? a3.subarray(i - 64) : new Uint8Array(0);
          length5 = a3.length;
          tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          for (i = 0; i < length5; i += 1) {
            tail[i >> 2] |= a3[i] << (i % 4 << 3);
          }
          tail[i >> 2] |= 128 << (i % 4 << 3);
          if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
              tail[i] = 0;
            }
          }
          tmp2 = n2 * 8;
          tmp2 = tmp2.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp2[2], 16);
          hi = parseInt(tmp2[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(state, tail);
          return state;
        }
        function rhex(n2) {
          var s3 = "", j;
          for (j = 0; j < 4; j += 1) {
            s3 += hex_chr[n2 >> j * 8 + 4 & 15] + hex_chr[n2 >> j * 8 & 15];
          }
          return s3;
        }
        function hex2(x3) {
          var i;
          for (i = 0; i < x3.length; i += 1) {
            x3[i] = rhex(x3[i]);
          }
          return x3.join("");
        }
        if (hex2(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") {
          add32 = function(x3, y3) {
            var lsw = (x3 & 65535) + (y3 & 65535), msw = (x3 >> 16) + (y3 >> 16) + (lsw >> 16);
            return msw << 16 | lsw & 65535;
          };
        }
        if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
          (function() {
            function clamp3(val, length5) {
              val = val | 0 || 0;
              if (val < 0) {
                return Math.max(val + length5, 0);
              }
              return Math.min(val, length5);
            }
            ArrayBuffer.prototype.slice = function(from, to) {
              var length5 = this.byteLength, begin = clamp3(from, length5), end = length5, num, target, targetArray, sourceArray;
              if (to !== undefined2) {
                end = clamp3(to, length5);
              }
              if (begin > end) {
                return new ArrayBuffer(0);
              }
              num = end - begin;
              target = new ArrayBuffer(num);
              targetArray = new Uint8Array(target);
              sourceArray = new Uint8Array(this, begin, num);
              targetArray.set(sourceArray);
              return target;
            };
          })();
        }
        function toUtf8(str7) {
          if (/[\u0080-\uFFFF]/.test(str7)) {
            str7 = unescape(encodeURIComponent(str7));
          }
          return str7;
        }
        function utf8Str2ArrayBuffer(str7, returnUInt8Array) {
          var length5 = str7.length, buff = new ArrayBuffer(length5), arr = new Uint8Array(buff), i;
          for (i = 0; i < length5; i += 1) {
            arr[i] = str7.charCodeAt(i);
          }
          return returnUInt8Array ? arr : buff;
        }
        function arrayBuffer2Utf8Str(buff) {
          return String.fromCharCode.apply(null, new Uint8Array(buff));
        }
        function concatenateArrayBuffers(first3, second2, returnUInt8Array) {
          var result = new Uint8Array(first3.byteLength + second2.byteLength);
          result.set(new Uint8Array(first3));
          result.set(new Uint8Array(second2), first3.byteLength);
          return returnUInt8Array ? result : result.buffer;
        }
        function hexToBinaryString(hex3) {
          var bytes = [], length5 = hex3.length, x3;
          for (x3 = 0; x3 < length5 - 1; x3 += 2) {
            bytes.push(parseInt(hex3.substr(x3, 2), 16));
          }
          return String.fromCharCode.apply(String, bytes);
        }
        function SparkMD52() {
          this.reset();
        }
        SparkMD52.prototype.append = function(str7) {
          this.appendBinary(toUtf8(str7));
          return this;
        };
        SparkMD52.prototype.appendBinary = function(contents) {
          this._buff += contents;
          this._length += contents.length;
          var length5 = this._buff.length, i;
          for (i = 64; i <= length5; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
          }
          this._buff = this._buff.substring(i - 64);
          return this;
        };
        SparkMD52.prototype.end = function(raw) {
          var buff = this._buff, length5 = buff.length, i, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
          for (i = 0; i < length5; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
          }
          this._finish(tail, length5);
          ret = hex2(this._hash);
          if (raw) {
            ret = hexToBinaryString(ret);
          }
          this.reset();
          return ret;
        };
        SparkMD52.prototype.reset = function() {
          this._buff = "";
          this._length = 0;
          this._hash = [1732584193, -271733879, -1732584194, 271733878];
          return this;
        };
        SparkMD52.prototype.getState = function() {
          return {
            buff: this._buff,
            length: this._length,
            hash: this._hash.slice()
          };
        };
        SparkMD52.prototype.setState = function(state) {
          this._buff = state.buff;
          this._length = state.length;
          this._hash = state.hash;
          return this;
        };
        SparkMD52.prototype.destroy = function() {
          delete this._hash;
          delete this._buff;
          delete this._length;
        };
        SparkMD52.prototype._finish = function(tail, length5) {
          var i = length5, tmp2, lo, hi;
          tail[i >> 2] |= 128 << (i % 4 << 3);
          if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
              tail[i] = 0;
            }
          }
          tmp2 = this._length * 8;
          tmp2 = tmp2.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp2[2], 16);
          hi = parseInt(tmp2[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(this._hash, tail);
        };
        SparkMD52.hash = function(str7, raw) {
          return SparkMD52.hashBinary(toUtf8(str7), raw);
        };
        SparkMD52.hashBinary = function(content, raw) {
          var hash = md51(content), ret = hex2(hash);
          return raw ? hexToBinaryString(ret) : ret;
        };
        SparkMD52.ArrayBuffer = function() {
          this.reset();
        };
        SparkMD52.ArrayBuffer.prototype.append = function(arr) {
          var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length5 = buff.length, i;
          this._length += arr.byteLength;
          for (i = 64; i <= length5; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
          }
          this._buff = i - 64 < length5 ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);
          return this;
        };
        SparkMD52.ArrayBuffer.prototype.end = function(raw) {
          var buff = this._buff, length5 = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i, ret;
          for (i = 0; i < length5; i += 1) {
            tail[i >> 2] |= buff[i] << (i % 4 << 3);
          }
          this._finish(tail, length5);
          ret = hex2(this._hash);
          if (raw) {
            ret = hexToBinaryString(ret);
          }
          this.reset();
          return ret;
        };
        SparkMD52.ArrayBuffer.prototype.reset = function() {
          this._buff = new Uint8Array(0);
          this._length = 0;
          this._hash = [1732584193, -271733879, -1732584194, 271733878];
          return this;
        };
        SparkMD52.ArrayBuffer.prototype.getState = function() {
          var state = SparkMD52.prototype.getState.call(this);
          state.buff = arrayBuffer2Utf8Str(state.buff);
          return state;
        };
        SparkMD52.ArrayBuffer.prototype.setState = function(state) {
          state.buff = utf8Str2ArrayBuffer(state.buff, true);
          return SparkMD52.prototype.setState.call(this, state);
        };
        SparkMD52.ArrayBuffer.prototype.destroy = SparkMD52.prototype.destroy;
        SparkMD52.ArrayBuffer.prototype._finish = SparkMD52.prototype._finish;
        SparkMD52.ArrayBuffer.hash = function(arr, raw) {
          var hash = md51_array(new Uint8Array(arr)), ret = hex2(hash);
          return raw ? hexToBinaryString(ret) : ret;
        };
        return SparkMD52;
      });
    }
  });

  // node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  var turbo_es2017_esm_exports = {};
  __export(turbo_es2017_esm_exports, {
    FetchEnctype: () => FetchEnctype,
    FetchMethod: () => FetchMethod,
    FetchRequest: () => FetchRequest,
    FetchResponse: () => FetchResponse,
    FrameElement: () => FrameElement,
    FrameLoadingStyle: () => FrameLoadingStyle,
    FrameRenderer: () => FrameRenderer,
    PageRenderer: () => PageRenderer,
    PageSnapshot: () => PageSnapshot,
    StreamActions: () => StreamActions,
    StreamElement: () => StreamElement,
    StreamSourceElement: () => StreamSourceElement,
    cache: () => cache,
    clearCache: () => clearCache,
    config: () => config,
    connectStreamSource: () => connectStreamSource,
    disconnectStreamSource: () => disconnectStreamSource,
    fetch: () => fetchWithTurboHeaders,
    fetchEnctypeFromString: () => fetchEnctypeFromString,
    fetchMethodFromString: () => fetchMethodFromString,
    isSafe: () => isSafe,
    navigator: () => navigator$1,
    registerAdapter: () => registerAdapter,
    renderStreamMessage: () => renderStreamMessage,
    session: () => session,
    setConfirmMethod: () => setConfirmMethod,
    setFormMode: () => setFormMode,
    setProgressBarDelay: () => setProgressBarDelay,
    start: () => start,
    visit: () => visit
  });
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function") return;
    prototype.requestSubmit = function(submitter2) {
      if (submitter2) {
        validateSubmitter(submitter2, this);
        submitter2.click();
      } else {
        submitter2 = document.createElement("input");
        submitter2.type = "submit";
        submitter2.hidden = true;
        this.appendChild(submitter2);
        submitter2.click();
        this.removeChild(submitter2);
      }
    };
    function validateSubmitter(submitter2, form) {
      submitter2 instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter2.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter2.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name2) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name2);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return candidate?.type == "submit" ? candidate : null;
  }
  function clickCaptured(event) {
    const submitter2 = findSubmitterFromClickTarget(event.target);
    if (submitter2 && submitter2.form) {
      submittersByForm.set(submitter2.form, submitter2);
    }
  }
  (function() {
    if ("submitter" in Event.prototype) return;
    let prototype = window.Event.prototype;
    if ("SubmitEvent" in window) {
      const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
      if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
        prototype = prototypeOfSubmitEvent;
      } else {
        return;
      }
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle = {
    eager: "eager",
    lazy: "lazy"
  };
  var FrameElement = class _FrameElement extends HTMLElement {
    static delegateConstructor = void 0;
    loaded = Promise.resolve();
    static get observedAttributes() {
      return ["disabled", "loading", "src"];
    }
    constructor() {
      super();
      this.delegate = new _FrameElement.delegateConstructor(this);
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      return this.delegate.sourceURLReloaded();
    }
    attributeChangedCallback(name2) {
      if (name2 == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name2 == "src") {
        this.delegate.sourceURLChanged();
      } else if (name2 == "disabled") {
        this.delegate.disabledChanged();
      }
    }
    /**
     * Gets the URL to lazily load source HTML from
     */
    get src() {
      return this.getAttribute("src");
    }
    /**
     * Sets the URL to lazily load source HTML from
     */
    set src(value2) {
      if (value2) {
        this.setAttribute("src", value2);
      } else {
        this.removeAttribute("src");
      }
    }
    /**
     * Gets the refresh mode for the frame.
     */
    get refresh() {
      return this.getAttribute("refresh");
    }
    /**
     * Sets the refresh mode for the frame.
     */
    set refresh(value2) {
      if (value2) {
        this.setAttribute("refresh", value2);
      } else {
        this.removeAttribute("refresh");
      }
    }
    get shouldReloadWithMorph() {
      return this.src && this.refresh === "morph";
    }
    /**
     * Determines if the element is loading
     */
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    /**
     * Sets the value of if the element is loading
     */
    set loading(value2) {
      if (value2) {
        this.setAttribute("loading", value2);
      } else {
        this.removeAttribute("loading");
      }
    }
    /**
     * Gets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    get disabled() {
      return this.hasAttribute("disabled");
    }
    /**
     * Sets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    set disabled(value2) {
      if (value2) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    /**
     * Gets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    /**
     * Sets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    set autoscroll(value2) {
      if (value2) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    /**
     * Determines if the element has finished loading
     */
    get complete() {
      return !this.delegate.isLoading;
    }
    /**
     * Gets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    /**
     * Sets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isPreview() {
      return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style) {
    switch (style.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  var drive = {
    enabled: true,
    progressBarDelay: 500,
    unvisitableExtensions: /* @__PURE__ */ new Set(
      [
        ".7z",
        ".aac",
        ".apk",
        ".avi",
        ".bmp",
        ".bz2",
        ".css",
        ".csv",
        ".deb",
        ".dmg",
        ".doc",
        ".docx",
        ".exe",
        ".gif",
        ".gz",
        ".heic",
        ".heif",
        ".ico",
        ".iso",
        ".jpeg",
        ".jpg",
        ".js",
        ".json",
        ".m4a",
        ".mkv",
        ".mov",
        ".mp3",
        ".mp4",
        ".mpeg",
        ".mpg",
        ".msi",
        ".ogg",
        ".ogv",
        ".pdf",
        ".pkg",
        ".png",
        ".ppt",
        ".pptx",
        ".rar",
        ".rtf",
        ".svg",
        ".tar",
        ".tif",
        ".tiff",
        ".txt",
        ".wav",
        ".webm",
        ".webp",
        ".wma",
        ".wmv",
        ".xls",
        ".xlsx",
        ".xml",
        ".zip"
      ]
    )
  };
  function activateScriptElement(element) {
    if (element.getAttribute("data-turbo-eval") == "false") {
      return element;
    } else {
      const createdScriptElement = document.createElement("script");
      const cspNonce = getCspNonce();
      if (cspNonce) {
        createdScriptElement.nonce = cspNonce;
      }
      createdScriptElement.textContent = element.textContent;
      createdScriptElement.async = false;
      copyElementAttributes(createdScriptElement, element);
      return createdScriptElement;
    }
  }
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name: name2, value: value2 } of sourceElement.attributes) {
      destinationElement.setAttribute(name2, value2);
    }
  }
  function createDocumentFragment(html) {
    const template = document.createElement("template");
    template.innerHTML = html;
    return template.content;
  }
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, {
      cancelable,
      bubbles: true,
      composed: true,
      detail
    });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  function cancelEvent(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  function nextRepaint() {
    if (document.visibilityState === "hidden") {
      return nextEventLoopTick();
    } else {
      return nextAnimationFrame();
    }
  }
  function nextAnimationFrame() {
    return new Promise((resolve) => requestAnimationFrame(() => resolve()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve) => setTimeout(() => resolve(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match2 = lines[0].match(/^\s+/);
    const indent = match2 ? match2[0].length : 0;
    return lines.map((line4) => line4.slice(indent)).join("\n");
  }
  function interpolate(strings, values) {
    return strings.reduce((result, string, i) => {
      const value2 = values[i] == void 0 ? "" : values[i];
      return result + string + value2;
    }, "");
  }
  function uuid() {
    return Array.from({ length: 36 }).map((_2, i) => {
      if (i == 8 || i == 13 || i == 18 || i == 23) {
        return "-";
      } else if (i == 14) {
        return "4";
      } else if (i == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements) {
    for (const value2 of elements.map((element) => element?.getAttribute(attributeName))) {
      if (typeof value2 == "string") return value2;
    }
    return null;
  }
  function hasAttribute(attributeName, ...elements) {
    return elements.some((element) => element && element.hasAttribute(attributeName));
  }
  function markAsBusy(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  function waitForLoad(element, timeoutInMilliseconds = 2e3) {
    return new Promise((resolve) => {
      const onComplete = () => {
        element.removeEventListener("error", onComplete);
        element.removeEventListener("load", onComplete);
        resolve();
      };
      element.addEventListener("load", onComplete, { once: true });
      element.addEventListener("error", onComplete, { once: true });
      setTimeout(resolve, timeoutInMilliseconds);
    });
  }
  function getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  function getVisitAction(...elements) {
    const action = getAttribute("data-turbo-action", ...elements);
    return isAction(action) ? action : null;
  }
  function getMetaElement(name2) {
    return document.querySelector(`meta[name="${name2}"]`);
  }
  function getMetaContent(name2) {
    const element = getMetaElement(name2);
    return element && element.content;
  }
  function getCspNonce() {
    const element = getMetaElement("csp-nonce");
    if (element) {
      const { nonce, content } = element;
      return nonce == "" ? content : nonce;
    }
  }
  function setMetaContent(name2, content) {
    let element = getMetaElement(name2);
    if (!element) {
      element = document.createElement("meta");
      element.setAttribute("name", name2);
      document.head.appendChild(element);
    }
    element.setAttribute("content", content);
    return element;
  }
  function findClosestRecursively(element, selector) {
    if (element instanceof Element) {
      return element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector);
    }
  }
  function elementIsFocusable(element) {
    const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
    return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
  }
  function queryAutofocusableElement(elementOrDocumentFragment) {
    return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
  }
  async function around(callback, reader) {
    const before = reader();
    callback();
    await nextAnimationFrame();
    const after = reader();
    return [before, after];
  }
  function doesNotTargetIFrame(name2) {
    if (name2 === "_blank") {
      return false;
    } else if (name2) {
      for (const element of document.getElementsByName(name2)) {
        if (element instanceof HTMLIFrameElement) return false;
      }
      return true;
    } else {
      return true;
    }
  }
  function findLinkFromClickTarget(target) {
    return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
  }
  function getLocationForLink(link2) {
    return expandURL(link2.getAttribute("href") || "");
  }
  function debounce(fn, delay) {
    let timeoutId = null;
    return (...args) => {
      const callback = () => fn.apply(this, args);
      clearTimeout(timeoutId);
      timeoutId = setTimeout(callback, delay);
    };
  }
  var submitter = {
    "aria-disabled": {
      beforeSubmit: (submitter2) => {
        submitter2.setAttribute("aria-disabled", "true");
        submitter2.addEventListener("click", cancelEvent);
      },
      afterSubmit: (submitter2) => {
        submitter2.removeAttribute("aria-disabled");
        submitter2.removeEventListener("click", cancelEvent);
      }
    },
    "disabled": {
      beforeSubmit: (submitter2) => submitter2.disabled = true,
      afterSubmit: (submitter2) => submitter2.disabled = false
    }
  };
  var Config = class {
    #submitter = null;
    constructor(config2) {
      Object.assign(this, config2);
    }
    get submitter() {
      return this.#submitter;
    }
    set submitter(value2) {
      this.#submitter = submitter[value2] || value2;
    }
  };
  var forms = new Config({
    mode: "on",
    submitter: "disabled"
  });
  var config = {
    drive,
    forms
  };
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction$1(form, submitter2) {
    const action = submitter2?.getAttribute("formaction") || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && !config.drive.unvisitableExtensions.has(getExtension(location2));
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left2, right2) {
    return expandURL(left2).href == expandURL(right2).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value2) {
    return value2.endsWith("/") ? value2 : value2 + "/";
  }
  var FetchResponse = class {
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name2) {
      return this.response.headers.get(name2);
    }
  };
  var LimitedSet = class extends Set {
    constructor(maxSize) {
      super();
      this.maxSize = maxSize;
    }
    add(value2) {
      if (this.size >= this.maxSize) {
        const iterator = this.values();
        const oldestValue = iterator.next().value;
        this.delete(oldestValue);
      }
      super.add(value2);
    }
  };
  var recentRequests = new LimitedSet(20);
  var nativeFetch = window.fetch;
  function fetchWithTurboHeaders(url, options = {}) {
    const modifiedHeaders = new Headers(options.headers || {});
    const requestUID = uuid();
    recentRequests.add(requestUID);
    modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
    return nativeFetch(url, {
      ...options,
      headers: modifiedHeaders
    });
  }
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchMethod = {
    get: "get",
    post: "post",
    put: "put",
    patch: "patch",
    delete: "delete"
  };
  function fetchEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FetchEnctype.multipart:
        return FetchEnctype.multipart;
      case FetchEnctype.plain:
        return FetchEnctype.plain;
      default:
        return FetchEnctype.urlEncoded;
    }
  }
  var FetchEnctype = {
    urlEncoded: "application/x-www-form-urlencoded",
    multipart: "multipart/form-data",
    plain: "text/plain"
  };
  var FetchRequest = class {
    abortController = new AbortController();
    #resolveRequestPromise = (_value) => {
    };
    constructor(delegate, method, location2, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {
      const [url, body] = buildResourceAndBody(expandURL(location2), method, requestBody, enctype);
      this.delegate = delegate;
      this.url = url;
      this.target = target;
      this.fetchOptions = {
        credentials: "same-origin",
        redirect: "follow",
        method: method.toUpperCase(),
        headers: { ...this.defaultHeaders },
        body,
        signal: this.abortSignal,
        referrer: this.delegate.referrer?.href
      };
      this.enctype = enctype;
    }
    get method() {
      return this.fetchOptions.method;
    }
    set method(value2) {
      const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();
      const fetchMethod = fetchMethodFromString(value2) || FetchMethod.get;
      this.url.search = "";
      const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
      this.url = url;
      this.fetchOptions.body = body;
      this.fetchOptions.method = fetchMethod.toUpperCase();
    }
    get headers() {
      return this.fetchOptions.headers;
    }
    set headers(value2) {
      this.fetchOptions.headers = value2;
    }
    get body() {
      if (this.isSafe) {
        return this.url.searchParams;
      } else {
        return this.fetchOptions.body;
      }
    }
    set body(value2) {
      this.fetchOptions.body = value2;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      const { fetchOptions } = this;
      this.delegate.prepareRequest(this);
      const event = await this.#allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        if (event.detail.fetchRequest) {
          this.response = event.detail.fetchRequest.response;
        } else {
          this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
        }
        const response = await this.response;
        return await this.receive(response);
      } catch (error4) {
        if (error4.name !== "AbortError") {
          if (this.#willDelegateErrorHandling(error4)) {
            this.delegate.requestErrored(this, error4);
          }
          throw error4;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", {
        cancelable: true,
        detail: { fetchResponse },
        target: this.target
      });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get defaultHeaders() {
      return {
        Accept: "text/html, application/xhtml+xml"
      };
    }
    get isSafe() {
      return isSafe(this.method);
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    acceptResponseType(mimeType) {
      this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
    }
    async #allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve) => this.#resolveRequestPromise = resolve);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.#resolveRequestPromise
        },
        target: this.target
      });
      this.url = event.detail.url;
      if (event.defaultPrevented) await requestInterception;
      return event;
    }
    #willDelegateErrorHandling(error4) {
      const event = dispatch("turbo:fetch-request-error", {
        target: this.target,
        cancelable: true,
        detail: { request: this, error: error4 }
      });
      return !event.defaultPrevented;
    }
  };
  function isSafe(fetchMethod) {
    return fetchMethodFromString(fetchMethod) == FetchMethod.get;
  }
  function buildResourceAndBody(resource, method, requestBody, enctype) {
    const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
    if (isSafe(method)) {
      return [mergeIntoURLSearchParams(resource, searchParams), null];
    } else if (enctype == FetchEnctype.urlEncoded) {
      return [resource, searchParams];
    } else {
      return [resource, requestBody];
    }
  }
  function entriesExcludingFiles(requestBody) {
    const entries = [];
    for (const [name2, value2] of requestBody) {
      if (value2 instanceof File) continue;
      else entries.push([name2, value2]);
    }
    return entries;
  }
  function mergeIntoURLSearchParams(url, requestBody) {
    const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
    url.search = searchParams.toString();
    return url;
  }
  var AppearanceObserver = class {
    started = false;
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
    intersect = (entries) => {
      const lastEntry = entries.slice(-1)[0];
      if (lastEntry?.isIntersecting) {
        this.delegate.elementAppearedInViewport(this.element);
      }
    };
  };
  var StreamMessage = class {
    static contentType = "text/vnd.turbo-stream.html";
    static wrap(message) {
      if (typeof message == "string") {
        return new this(createDocumentFragment(message));
      } else {
        return message;
      }
    }
    constructor(fragment) {
      this.fragment = importStreamElements(fragment);
    }
  };
  function importStreamElements(fragment) {
    for (const element of fragment.querySelectorAll("turbo-stream")) {
      const streamElement = document.importNode(element, true);
      for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
        inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
      }
      element.replaceWith(streamElement);
    }
    return fragment;
  }
  var PREFETCH_DELAY = 100;
  var PrefetchCache = class {
    #prefetchTimeout = null;
    #prefetched = null;
    get(url) {
      if (this.#prefetched && this.#prefetched.url === url && this.#prefetched.expire > Date.now()) {
        return this.#prefetched.request;
      }
    }
    setLater(url, request, ttl) {
      this.clear();
      this.#prefetchTimeout = setTimeout(() => {
        request.perform();
        this.set(url, request, ttl);
        this.#prefetchTimeout = null;
      }, PREFETCH_DELAY);
    }
    set(url, request, ttl) {
      this.#prefetched = { url, request, expire: new Date((/* @__PURE__ */ new Date()).getTime() + ttl) };
    }
    clear() {
      if (this.#prefetchTimeout) clearTimeout(this.#prefetchTimeout);
      this.#prefetched = null;
    }
  };
  var cacheTtl = 10 * 1e3;
  var prefetchCache = new PrefetchCache();
  var FormSubmissionState = {
    initialized: "initialized",
    requesting: "requesting",
    waiting: "waiting",
    receiving: "receiving",
    stopping: "stopping",
    stopped: "stopped"
  };
  var FormSubmission = class _FormSubmission {
    state = FormSubmissionState.initialized;
    static confirmMethod(message) {
      return Promise.resolve(confirm(message));
    }
    constructor(delegate, formElement, submitter2, mustRedirect = false) {
      const method = getMethod(formElement, submitter2);
      const action = getAction(getFormAction(formElement, submitter2), method);
      const body = buildFormData(formElement, submitter2);
      const enctype = getEnctype(formElement, submitter2);
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter2;
      this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
      this.mustRedirect = mustRedirect;
    }
    get method() {
      return this.fetchRequest.method;
    }
    set method(value2) {
      this.fetchRequest.method = value2;
    }
    get action() {
      return this.fetchRequest.url.toString();
    }
    set action(value2) {
      this.fetchRequest.url = expandURL(value2);
    }
    get body() {
      return this.fetchRequest.body;
    }
    get enctype() {
      return this.fetchRequest.enctype;
    }
    get isSafe() {
      return this.fetchRequest.isSafe;
    }
    get location() {
      return this.fetchRequest.url;
    }
    // The submission process
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
      if (typeof confirmationMessage === "string") {
        const confirmMethod = typeof config.forms.confirm === "function" ? config.forms.confirm : _FormSubmission.confirmMethod;
        const answer = await confirmMethod(confirmationMessage, this.formElement, this.submitter);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (!request.isSafe) {
        const token2 = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token2) {
          request.headers["X-CSRF-Token"] = token2;
        }
      }
      if (this.requestAcceptsTurboStreamResponse(request)) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      this.state = FormSubmissionState.waiting;
      if (this.submitter) config.forms.submitter.beforeSubmit(this.submitter);
      this.setSubmitsWith();
      markAsBusy(this.formElement);
      dispatch("turbo:submit-start", {
        target: this.formElement,
        detail: { formSubmission: this }
      });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      prefetchCache.clear();
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
        return;
      }
      prefetchCache.clear();
      if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error4 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error4);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error4) {
      this.result = { success: false, error: error4 };
      this.delegate.formSubmissionErrored(this, error4);
    }
    requestFinished(_request) {
      this.state = FormSubmissionState.stopped;
      if (this.submitter) config.forms.submitter.afterSubmit(this.submitter);
      this.resetSubmitterText();
      clearBusyState(this.formElement);
      dispatch("turbo:submit-end", {
        target: this.formElement,
        detail: { formSubmission: this, ...this.result }
      });
      this.delegate.formSubmissionFinished(this);
    }
    // Private
    setSubmitsWith() {
      if (!this.submitter || !this.submitsWith) return;
      if (this.submitter.matches("button")) {
        this.originalSubmitText = this.submitter.innerHTML;
        this.submitter.innerHTML = this.submitsWith;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        this.originalSubmitText = input.value;
        input.value = this.submitsWith;
      }
    }
    resetSubmitterText() {
      if (!this.submitter || !this.originalSubmitText) return;
      if (this.submitter.matches("button")) {
        this.submitter.innerHTML = this.originalSubmitText;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        input.value = this.originalSubmitText;
      }
    }
    requestMustRedirect(request) {
      return !request.isSafe && this.mustRedirect;
    }
    requestAcceptsTurboStreamResponse(request) {
      return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
    }
    get submitsWith() {
      return this.submitter?.getAttribute("data-turbo-submits-with");
    }
  };
  function buildFormData(formElement, submitter2) {
    const formData = new FormData(formElement);
    const name2 = submitter2?.getAttribute("name");
    const value2 = submitter2?.getAttribute("value");
    if (name2) {
      formData.append(name2, value2 || "");
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value2 = cookie.split("=").slice(1).join("=");
        return value2 ? decodeURIComponent(value2) : void 0;
      }
    }
  }
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  function getFormAction(formElement, submitter2) {
    const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
    if (submitter2?.hasAttribute("formaction")) {
      return submitter2.getAttribute("formaction") || "";
    } else {
      return formElement.getAttribute("action") || formElementAction || "";
    }
  }
  function getAction(formAction, fetchMethod) {
    const action = expandURL(formAction);
    if (isSafe(fetchMethod)) {
      action.search = "";
    }
    return action;
  }
  function getMethod(formElement, submitter2) {
    const method = submitter2?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
    return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
  }
  function getEnctype(formElement, submitter2) {
    return fetchEnctypeFromString(submitter2?.getAttribute("formenctype") || formElement.enctype);
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get activeElement() {
      return this.element.ownerDocument.activeElement;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      return queryAutofocusableElement(this.element);
    }
    get permanentElements() {
      return queryPermanentElementsAll(this.element);
    }
    getPermanentElementById(id5) {
      return getPermanentElementById(this.element, id5);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id: id5 } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id5);
        if (newPermanentElement) {
          permanentElementMap[id5] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  function getPermanentElementById(node, id5) {
    return node.querySelector(`#${id5}[data-turbo-permanent]`);
  }
  function queryPermanentElementsAll(node) {
    return node.querySelectorAll("[id][data-turbo-permanent]");
  }
  var FormSubmitObserver = class {
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
    submitCaptured = () => {
      this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
      this.eventTarget.addEventListener("submit", this.submitBubbled, false);
    };
    submitBubbled = (event) => {
      if (!event.defaultPrevented) {
        const form = event.target instanceof HTMLFormElement ? event.target : void 0;
        const submitter2 = event.submitter || void 0;
        if (form && submissionDoesNotDismissDialog(form, submitter2) && submissionDoesNotTargetIFrame(form, submitter2) && this.delegate.willSubmitForm(form, submitter2)) {
          event.preventDefault();
          event.stopImmediatePropagation();
          this.delegate.formSubmitted(form, submitter2);
        }
      }
    };
  };
  function submissionDoesNotDismissDialog(form, submitter2) {
    const method = submitter2?.getAttribute("formmethod") || form.getAttribute("method");
    return method != "dialog";
  }
  function submissionDoesNotTargetIFrame(form, submitter2) {
    const target = submitter2?.getAttribute("formtarget") || form.getAttribute("target");
    return doesNotTargetIFrame(target);
  }
  var View = class {
    #resolveRenderPromise = (_value) => {
    };
    #resolveInterceptionPromise = (_value) => {
    };
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    // Scrolling
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x: x3, y: y3 }) {
      this.scrollRoot.scrollTo(x3, y3);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    // Rendering
    async render(renderer) {
      const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer;
      const shouldInvalidate = willRender;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve) => this.#resolveRenderPromise = resolve);
          this.renderer = renderer;
          await this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve) => this.#resolveInterceptionPromise = resolve);
          const options = { resume: this.#resolveInterceptionPromise, render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
          if (!immediateRender) await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
          this.delegate.preloadOnLoadLinksForView(this.element);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          this.#resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else if (shouldInvalidate) {
        this.invalidate(renderer.reloadReason);
      }
    }
    invalidate(reason) {
      this.delegate.viewInvalidated(reason);
    }
    async prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      await renderer.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    markVisitDirection(direction2) {
      this.element.setAttribute("data-turbo-visit-direction", direction2);
    }
    unmarkVisitDirection() {
      this.element.removeAttribute("data-turbo-visit-direction");
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  var FrameView = class extends View {
    missing() {
      this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    clickBubbled = (event) => {
      if (this.clickEventIsSignificant(event)) {
        this.clickEvent = event;
      } else {
        delete this.clickEvent;
      }
    };
    linkClicked = (event) => {
      if (this.clickEvent && this.clickEventIsSignificant(event)) {
        if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
          this.clickEvent.preventDefault();
          event.preventDefault();
          this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
        }
      }
      delete this.clickEvent;
    };
    willVisit = (_event) => {
      delete this.clickEvent;
    };
    clickEventIsSignificant(event) {
      const target = event.composed ? event.target?.parentElement : event.target;
      const element = findLinkFromClickTarget(target) || target;
      return element instanceof Element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var LinkClickObserver = class {
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickCaptured = () => {
      this.eventTarget.removeEventListener("click", this.clickBubbled, false);
      this.eventTarget.addEventListener("click", this.clickBubbled, false);
    };
    clickBubbled = (event) => {
      if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
        const target = event.composedPath && event.composedPath()[0] || event.target;
        const link2 = findLinkFromClickTarget(target);
        if (link2 && doesNotTargetIFrame(link2.target)) {
          const location2 = getLocationForLink(link2);
          if (this.delegate.willFollowLinkToLocation(link2, location2, event)) {
            event.preventDefault();
            this.delegate.followedLinkToLocation(link2, location2);
          }
        }
      }
    };
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
  };
  var FormLinkClickObserver = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.linkInterceptor = new LinkClickObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link2, location2) {
      return false;
    }
    prefetchAndCacheRequestToLocation(link2, location2) {
      return;
    }
    // Link click observer delegate
    willFollowLinkToLocation(link2, location2, originalEvent) {
      return this.delegate.willSubmitFormLinkToLocation(link2, location2, originalEvent) && (link2.hasAttribute("data-turbo-method") || link2.hasAttribute("data-turbo-stream"));
    }
    followedLinkToLocation(link2, location2) {
      const form = document.createElement("form");
      const type = "hidden";
      for (const [name2, value2] of location2.searchParams) {
        form.append(Object.assign(document.createElement("input"), { type, name: name2, value: value2 }));
      }
      const action = Object.assign(location2, { search: "" });
      form.setAttribute("data-turbo", "true");
      form.setAttribute("action", action.href);
      form.setAttribute("hidden", "");
      const method = link2.getAttribute("data-turbo-method");
      if (method) form.setAttribute("method", method);
      const turboFrame = link2.getAttribute("data-turbo-frame");
      if (turboFrame) form.setAttribute("data-turbo-frame", turboFrame);
      const turboAction = getVisitAction(link2);
      if (turboAction) form.setAttribute("data-turbo-action", turboAction);
      const turboConfirm = link2.getAttribute("data-turbo-confirm");
      if (turboConfirm) form.setAttribute("data-turbo-confirm", turboConfirm);
      const turboStream = link2.hasAttribute("data-turbo-stream");
      if (turboStream) form.setAttribute("data-turbo-stream", "");
      this.delegate.submittedFormLinkToLocation(link2, location2, form);
      document.body.appendChild(form);
      form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
      requestAnimationFrame(() => form.requestSubmit());
    }
  };
  var Bardo = class {
    static async preservingPermanentElements(delegate, permanentElementMap, callback) {
      const bardo = new this(delegate, permanentElementMap);
      bardo.enter();
      await callback();
      bardo.leave();
    }
    constructor(delegate, permanentElementMap) {
      this.delegate = delegate;
      this.permanentElementMap = permanentElementMap;
    }
    enter() {
      for (const id5 in this.permanentElementMap) {
        const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id5];
        this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id5 in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id5];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
        this.delegate.leavingBardo(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone11 = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone11);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder?.replaceWith(permanentElement);
    }
    getPlaceholderById(id5) {
      return this.placeholders.find((element) => element.content == id5);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var Renderer = class {
    #activeElement = null;
    static renderElement(currentElement, newElement) {
    }
    constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.renderElement = this.constructor.renderElement;
      this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });
    }
    get shouldRender() {
      return true;
    }
    get shouldAutofocus() {
      return true;
    }
    get reloadReason() {
      return;
    }
    prepareToRender() {
      return;
    }
    render() {
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    async preservingPermanentElements(callback) {
      await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
    }
    focusFirstAutofocusableElement() {
      if (this.shouldAutofocus) {
        const element = this.connectedSnapshot.firstAutofocusableElement;
        if (element) {
          element.focus();
        }
      }
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement) {
      if (this.#activeElement) return;
      if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
        this.#activeElement = this.currentSnapshot.activeElement;
      }
    }
    leavingBardo(currentPermanentElement) {
      if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {
        this.#activeElement.focus();
        this.#activeElement = null;
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
    get renderMethod() {
      return "replace";
    }
  };
  var FrameRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(currentElement);
      destinationRange.deleteContents();
      const frameElement = newElement;
      const sourceRange = frameElement.ownerDocument?.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        currentElement.appendChild(sourceRange.extractContents());
      }
    }
    constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
      this.delegate = delegate;
    }
    get shouldRender() {
      return true;
    }
    async render() {
      await nextRepaint();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextRepaint();
      this.focusFirstAutofocusableElement();
      await nextRepaint();
      this.activateScriptElements();
    }
    loadFrameElement() {
      this.delegate.willRenderFrame(this.currentElement, this.newElement);
      this.renderElement(this.currentElement, this.newElement);
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
        if (element) {
          element.scrollIntoView({ block, behavior });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value2, defaultValue) {
    if (value2 == "end" || value2 == "start" || value2 == "center" || value2 == "nearest") {
      return value2;
    } else {
      return defaultValue;
    }
  }
  function readScrollBehavior(value2, defaultValue) {
    if (value2 == "auto" || value2 == "smooth") {
      return value2;
    } else {
      return defaultValue;
    }
  }
  var Idiomorph = /* @__PURE__ */ function() {
    let EMPTY_SET = /* @__PURE__ */ new Set();
    let defaults5 = {
      morphStyle: "outerHTML",
      callbacks: {
        beforeNodeAdded: noOp,
        afterNodeAdded: noOp,
        beforeNodeMorphed: noOp,
        afterNodeMorphed: noOp,
        beforeNodeRemoved: noOp,
        afterNodeRemoved: noOp,
        beforeAttributeUpdated: noOp
      },
      head: {
        style: "merge",
        shouldPreserve: function(elt) {
          return elt.getAttribute("im-preserve") === "true";
        },
        shouldReAppend: function(elt) {
          return elt.getAttribute("im-re-append") === "true";
        },
        shouldRemove: noOp,
        afterHeadMorphed: noOp
      }
    };
    function morph(oldNode, newContent, config2 = {}) {
      if (oldNode instanceof Document) {
        oldNode = oldNode.documentElement;
      }
      if (typeof newContent === "string") {
        newContent = parseContent(newContent);
      }
      let normalizedContent = normalizeContent(newContent);
      let ctx2 = createMorphContext(oldNode, normalizedContent, config2);
      return morphNormalizedContent(oldNode, normalizedContent, ctx2);
    }
    function morphNormalizedContent(oldNode, normalizedNewContent, ctx2) {
      if (ctx2.head.block) {
        let oldHead = oldNode.querySelector("head");
        let newHead = normalizedNewContent.querySelector("head");
        if (oldHead && newHead) {
          let promises = handleHeadElement(newHead, oldHead, ctx2);
          Promise.all(promises).then(function() {
            morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx2, {
              head: {
                block: false,
                ignore: true
              }
            }));
          });
          return;
        }
      }
      if (ctx2.morphStyle === "innerHTML") {
        morphChildren2(normalizedNewContent, oldNode, ctx2);
        return oldNode.children;
      } else if (ctx2.morphStyle === "outerHTML" || ctx2.morphStyle == null) {
        let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx2);
        let previousSibling = bestMatch?.previousSibling;
        let nextSibling = bestMatch?.nextSibling;
        let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx2);
        if (bestMatch) {
          return insertSiblings(previousSibling, morphedNode, nextSibling);
        } else {
          return [];
        }
      } else {
        throw "Do not understand how to morph style " + ctx2.morphStyle;
      }
    }
    function ignoreValueOfActiveElement(possibleActiveElement, ctx2) {
      return ctx2.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
    }
    function morphOldNodeTo(oldNode, newContent, ctx2) {
      if (ctx2.ignoreActive && oldNode === document.activeElement) ;
      else if (newContent == null) {
        if (ctx2.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        oldNode.remove();
        ctx2.callbacks.afterNodeRemoved(oldNode);
        return null;
      } else if (!isSoftMatch(oldNode, newContent)) {
        if (ctx2.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        if (ctx2.callbacks.beforeNodeAdded(newContent) === false) return oldNode;
        oldNode.parentElement.replaceChild(newContent, oldNode);
        ctx2.callbacks.afterNodeAdded(newContent);
        ctx2.callbacks.afterNodeRemoved(oldNode);
        return newContent;
      } else {
        if (ctx2.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;
        if (oldNode instanceof HTMLHeadElement && ctx2.head.ignore) ;
        else if (oldNode instanceof HTMLHeadElement && ctx2.head.style !== "morph") {
          handleHeadElement(newContent, oldNode, ctx2);
        } else {
          syncNodeFrom(newContent, oldNode, ctx2);
          if (!ignoreValueOfActiveElement(oldNode, ctx2)) {
            morphChildren2(newContent, oldNode, ctx2);
          }
        }
        ctx2.callbacks.afterNodeMorphed(oldNode, newContent);
        return oldNode;
      }
    }
    function morphChildren2(newParent, oldParent, ctx2) {
      let nextNewChild = newParent.firstChild;
      let insertionPoint = oldParent.firstChild;
      let newChild;
      while (nextNewChild) {
        newChild = nextNewChild;
        nextNewChild = newChild.nextSibling;
        if (insertionPoint == null) {
          if (ctx2.callbacks.beforeNodeAdded(newChild) === false) return;
          oldParent.appendChild(newChild);
          ctx2.callbacks.afterNodeAdded(newChild);
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        if (isIdSetMatch(newChild, insertionPoint, ctx2)) {
          morphOldNodeTo(insertionPoint, newChild, ctx2);
          insertionPoint = insertionPoint.nextSibling;
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx2);
        if (idSetMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx2);
          morphOldNodeTo(idSetMatch, newChild, ctx2);
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx2);
        if (softMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx2);
          morphOldNodeTo(softMatch, newChild, ctx2);
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        if (ctx2.callbacks.beforeNodeAdded(newChild) === false) return;
        oldParent.insertBefore(newChild, insertionPoint);
        ctx2.callbacks.afterNodeAdded(newChild);
        removeIdsFromConsideration(ctx2, newChild);
      }
      while (insertionPoint !== null) {
        let tempNode = insertionPoint;
        insertionPoint = insertionPoint.nextSibling;
        removeNode(tempNode, ctx2);
      }
    }
    function ignoreAttribute(attr2, to, updateType, ctx2) {
      if (attr2 === "value" && ctx2.ignoreActiveValue && to === document.activeElement) {
        return true;
      }
      return ctx2.callbacks.beforeAttributeUpdated(attr2, to, updateType) === false;
    }
    function syncNodeFrom(from, to, ctx2) {
      let type = from.nodeType;
      if (type === 1) {
        const fromAttributes = from.attributes;
        const toAttributes = to.attributes;
        for (const fromAttribute of fromAttributes) {
          if (ignoreAttribute(fromAttribute.name, to, "update", ctx2)) {
            continue;
          }
          if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {
            to.setAttribute(fromAttribute.name, fromAttribute.value);
          }
        }
        for (let i = toAttributes.length - 1; 0 <= i; i--) {
          const toAttribute = toAttributes[i];
          if (ignoreAttribute(toAttribute.name, to, "remove", ctx2)) {
            continue;
          }
          if (!from.hasAttribute(toAttribute.name)) {
            to.removeAttribute(toAttribute.name);
          }
        }
      }
      if (type === 8 || type === 3) {
        if (to.nodeValue !== from.nodeValue) {
          to.nodeValue = from.nodeValue;
        }
      }
      if (!ignoreValueOfActiveElement(to, ctx2)) {
        syncInputValue(from, to, ctx2);
      }
    }
    function syncBooleanAttribute(from, to, attributeName, ctx2) {
      if (from[attributeName] !== to[attributeName]) {
        let ignoreUpdate = ignoreAttribute(attributeName, to, "update", ctx2);
        if (!ignoreUpdate) {
          to[attributeName] = from[attributeName];
        }
        if (from[attributeName]) {
          if (!ignoreUpdate) {
            to.setAttribute(attributeName, from[attributeName]);
          }
        } else {
          if (!ignoreAttribute(attributeName, to, "remove", ctx2)) {
            to.removeAttribute(attributeName);
          }
        }
      }
    }
    function syncInputValue(from, to, ctx2) {
      if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== "file") {
        let fromValue = from.value;
        let toValue = to.value;
        syncBooleanAttribute(from, to, "checked", ctx2);
        syncBooleanAttribute(from, to, "disabled", ctx2);
        if (!from.hasAttribute("value")) {
          if (!ignoreAttribute("value", to, "remove", ctx2)) {
            to.value = "";
            to.removeAttribute("value");
          }
        } else if (fromValue !== toValue) {
          if (!ignoreAttribute("value", to, "update", ctx2)) {
            to.setAttribute("value", fromValue);
            to.value = fromValue;
          }
        }
      } else if (from instanceof HTMLOptionElement) {
        syncBooleanAttribute(from, to, "selected", ctx2);
      } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {
        let fromValue = from.value;
        let toValue = to.value;
        if (ignoreAttribute("value", to, "update", ctx2)) {
          return;
        }
        if (fromValue !== toValue) {
          to.value = fromValue;
        }
        if (to.firstChild && to.firstChild.nodeValue !== fromValue) {
          to.firstChild.nodeValue = fromValue;
        }
      }
    }
    function handleHeadElement(newHeadTag, currentHead, ctx2) {
      let added = [];
      let removed = [];
      let preserved = [];
      let nodesToAppend = [];
      let headMergeStyle = ctx2.head.style;
      let srcToNewHeadNodes = /* @__PURE__ */ new Map();
      for (const newHeadChild of newHeadTag.children) {
        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
      }
      for (const currentHeadElt of currentHead.children) {
        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
        let isReAppended = ctx2.head.shouldReAppend(currentHeadElt);
        let isPreserved = ctx2.head.shouldPreserve(currentHeadElt);
        if (inNewContent || isPreserved) {
          if (isReAppended) {
            removed.push(currentHeadElt);
          } else {
            srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
            preserved.push(currentHeadElt);
          }
        } else {
          if (headMergeStyle === "append") {
            if (isReAppended) {
              removed.push(currentHeadElt);
              nodesToAppend.push(currentHeadElt);
            }
          } else {
            if (ctx2.head.shouldRemove(currentHeadElt) !== false) {
              removed.push(currentHeadElt);
            }
          }
        }
      }
      nodesToAppend.push(...srcToNewHeadNodes.values());
      let promises = [];
      for (const newNode of nodesToAppend) {
        let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
        if (ctx2.callbacks.beforeNodeAdded(newElt) !== false) {
          if (newElt.href || newElt.src) {
            let resolve = null;
            let promise = new Promise(function(_resolve) {
              resolve = _resolve;
            });
            newElt.addEventListener("load", function() {
              resolve();
            });
            promises.push(promise);
          }
          currentHead.appendChild(newElt);
          ctx2.callbacks.afterNodeAdded(newElt);
          added.push(newElt);
        }
      }
      for (const removedElement of removed) {
        if (ctx2.callbacks.beforeNodeRemoved(removedElement) !== false) {
          currentHead.removeChild(removedElement);
          ctx2.callbacks.afterNodeRemoved(removedElement);
        }
      }
      ctx2.head.afterHeadMorphed(currentHead, { added, kept: preserved, removed });
      return promises;
    }
    function noOp() {
    }
    function mergeDefaults(config2) {
      let finalConfig = {};
      Object.assign(finalConfig, defaults5);
      Object.assign(finalConfig, config2);
      finalConfig.callbacks = {};
      Object.assign(finalConfig.callbacks, defaults5.callbacks);
      Object.assign(finalConfig.callbacks, config2.callbacks);
      finalConfig.head = {};
      Object.assign(finalConfig.head, defaults5.head);
      Object.assign(finalConfig.head, config2.head);
      return finalConfig;
    }
    function createMorphContext(oldNode, newContent, config2) {
      config2 = mergeDefaults(config2);
      return {
        target: oldNode,
        newContent,
        config: config2,
        morphStyle: config2.morphStyle,
        ignoreActive: config2.ignoreActive,
        ignoreActiveValue: config2.ignoreActiveValue,
        idMap: createIdMap(oldNode, newContent),
        deadIds: /* @__PURE__ */ new Set(),
        callbacks: config2.callbacks,
        head: config2.head
      };
    }
    function isIdSetMatch(node1, node2, ctx2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {
        if (node1.id !== "" && node1.id === node2.id) {
          return true;
        } else {
          return getIdIntersectionCount(ctx2, node1, node2) > 0;
        }
      }
      return false;
    }
    function isSoftMatch(node1, node2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;
    }
    function removeNodesBetween(startInclusive, endExclusive, ctx2) {
      while (startInclusive !== endExclusive) {
        let tempNode = startInclusive;
        startInclusive = startInclusive.nextSibling;
        removeNode(tempNode, ctx2);
      }
      removeIdsFromConsideration(ctx2, endExclusive);
      return endExclusive.nextSibling;
    }
    function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx2) {
      let newChildPotentialIdCount = getIdIntersectionCount(ctx2, newChild, oldParent);
      let potentialMatch = null;
      if (newChildPotentialIdCount > 0) {
        let potentialMatch2 = insertionPoint;
        let otherMatchCount = 0;
        while (potentialMatch2 != null) {
          if (isIdSetMatch(newChild, potentialMatch2, ctx2)) {
            return potentialMatch2;
          }
          otherMatchCount += getIdIntersectionCount(ctx2, potentialMatch2, newContent);
          if (otherMatchCount > newChildPotentialIdCount) {
            return null;
          }
          potentialMatch2 = potentialMatch2.nextSibling;
        }
      }
      return potentialMatch;
    }
    function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx2) {
      let potentialSoftMatch = insertionPoint;
      let nextSibling = newChild.nextSibling;
      let siblingSoftMatchCount = 0;
      while (potentialSoftMatch != null) {
        if (getIdIntersectionCount(ctx2, potentialSoftMatch, newContent) > 0) {
          return null;
        }
        if (isSoftMatch(newChild, potentialSoftMatch)) {
          return potentialSoftMatch;
        }
        if (isSoftMatch(nextSibling, potentialSoftMatch)) {
          siblingSoftMatchCount++;
          nextSibling = nextSibling.nextSibling;
          if (siblingSoftMatchCount >= 2) {
            return null;
          }
        }
        potentialSoftMatch = potentialSoftMatch.nextSibling;
      }
      return potentialSoftMatch;
    }
    function parseContent(newContent) {
      let parser2 = new DOMParser();
      let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
      if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
        let content = parser2.parseFromString(newContent, "text/html");
        if (contentWithSvgsRemoved.match(/<\/html>/)) {
          content.generatedByIdiomorph = true;
          return content;
        } else {
          let htmlElement = content.firstChild;
          if (htmlElement) {
            htmlElement.generatedByIdiomorph = true;
            return htmlElement;
          } else {
            return null;
          }
        }
      } else {
        let responseDoc = parser2.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
        let content = responseDoc.body.querySelector("template").content;
        content.generatedByIdiomorph = true;
        return content;
      }
    }
    function normalizeContent(newContent) {
      if (newContent == null) {
        const dummyParent = document.createElement("div");
        return dummyParent;
      } else if (newContent.generatedByIdiomorph) {
        return newContent;
      } else if (newContent instanceof Node) {
        const dummyParent = document.createElement("div");
        dummyParent.append(newContent);
        return dummyParent;
      } else {
        const dummyParent = document.createElement("div");
        for (const elt of [...newContent]) {
          dummyParent.append(elt);
        }
        return dummyParent;
      }
    }
    function insertSiblings(previousSibling, morphedNode, nextSibling) {
      let stack = [];
      let added = [];
      while (previousSibling != null) {
        stack.push(previousSibling);
        previousSibling = previousSibling.previousSibling;
      }
      while (stack.length > 0) {
        let node = stack.pop();
        added.push(node);
        morphedNode.parentElement.insertBefore(node, morphedNode);
      }
      added.push(morphedNode);
      while (nextSibling != null) {
        stack.push(nextSibling);
        added.push(nextSibling);
        nextSibling = nextSibling.nextSibling;
      }
      while (stack.length > 0) {
        morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);
      }
      return added;
    }
    function findBestNodeMatch(newContent, oldNode, ctx2) {
      let currentElement;
      currentElement = newContent.firstChild;
      let bestElement = currentElement;
      let score2 = 0;
      while (currentElement) {
        let newScore = scoreElement(currentElement, oldNode, ctx2);
        if (newScore > score2) {
          bestElement = currentElement;
          score2 = newScore;
        }
        currentElement = currentElement.nextSibling;
      }
      return bestElement;
    }
    function scoreElement(node1, node2, ctx2) {
      if (isSoftMatch(node1, node2)) {
        return 0.5 + getIdIntersectionCount(ctx2, node1, node2);
      }
      return 0;
    }
    function removeNode(tempNode, ctx2) {
      removeIdsFromConsideration(ctx2, tempNode);
      if (ctx2.callbacks.beforeNodeRemoved(tempNode) === false) return;
      tempNode.remove();
      ctx2.callbacks.afterNodeRemoved(tempNode);
    }
    function isIdInConsideration(ctx2, id5) {
      return !ctx2.deadIds.has(id5);
    }
    function idIsWithinNode(ctx2, id5, targetNode) {
      let idSet = ctx2.idMap.get(targetNode) || EMPTY_SET;
      return idSet.has(id5);
    }
    function removeIdsFromConsideration(ctx2, node) {
      let idSet = ctx2.idMap.get(node) || EMPTY_SET;
      for (const id5 of idSet) {
        ctx2.deadIds.add(id5);
      }
    }
    function getIdIntersectionCount(ctx2, node1, node2) {
      let sourceSet = ctx2.idMap.get(node1) || EMPTY_SET;
      let matchCount = 0;
      for (const id5 of sourceSet) {
        if (isIdInConsideration(ctx2, id5) && idIsWithinNode(ctx2, id5, node2)) {
          ++matchCount;
        }
      }
      return matchCount;
    }
    function populateIdMapForNode(node, idMap) {
      let nodeParent = node.parentElement;
      let idElements = node.querySelectorAll("[id]");
      for (const elt of idElements) {
        let current = elt;
        while (current !== nodeParent && current != null) {
          let idSet = idMap.get(current);
          if (idSet == null) {
            idSet = /* @__PURE__ */ new Set();
            idMap.set(current, idSet);
          }
          idSet.add(elt.id);
          current = current.parentElement;
        }
      }
    }
    function createIdMap(oldContent, newContent) {
      let idMap = /* @__PURE__ */ new Map();
      populateIdMapForNode(oldContent, idMap);
      populateIdMapForNode(newContent, idMap);
      return idMap;
    }
    return {
      morph,
      defaults: defaults5
    };
  }();
  function morphElements(currentElement, newElement, { callbacks, ...options } = {}) {
    Idiomorph.morph(currentElement, newElement, {
      ...options,
      callbacks: new DefaultIdiomorphCallbacks(callbacks)
    });
  }
  function morphChildren(currentElement, newElement) {
    morphElements(currentElement, newElement.children, {
      morphStyle: "innerHTML"
    });
  }
  var DefaultIdiomorphCallbacks = class {
    #beforeNodeMorphed;
    constructor({ beforeNodeMorphed } = {}) {
      this.#beforeNodeMorphed = beforeNodeMorphed || (() => true);
    }
    beforeNodeAdded = (node) => {
      return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
    };
    beforeNodeMorphed = (currentElement, newElement) => {
      if (currentElement instanceof Element) {
        if (!currentElement.hasAttribute("data-turbo-permanent") && this.#beforeNodeMorphed(currentElement, newElement)) {
          const event = dispatch("turbo:before-morph-element", {
            cancelable: true,
            target: currentElement,
            detail: { currentElement, newElement }
          });
          return !event.defaultPrevented;
        } else {
          return false;
        }
      }
    };
    beforeAttributeUpdated = (attributeName, target, mutationType) => {
      const event = dispatch("turbo:before-morph-attribute", {
        cancelable: true,
        target,
        detail: { attributeName, mutationType }
      });
      return !event.defaultPrevented;
    };
    beforeNodeRemoved = (node) => {
      return this.beforeNodeMorphed(node);
    };
    afterNodeMorphed = (currentElement, newElement) => {
      if (currentElement instanceof Element) {
        dispatch("turbo:morph-element", {
          target: currentElement,
          detail: { currentElement, newElement }
        });
      }
    };
  };
  var MorphingFrameRenderer = class extends FrameRenderer {
    static renderElement(currentElement, newElement) {
      dispatch("turbo:before-frame-morph", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
      morphChildren(currentElement, newElement);
    }
    async preservingPermanentElements(callback) {
      return await callback();
    }
  };
  var ProgressBar = class _ProgressBar {
    static animationDuration = 300;
    /*ms*/
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    hiding = false;
    value = 0;
    visible = false;
    constructor() {
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value2) {
      this.value = value2;
      this.refresh();
    }
    // Private
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback, _ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    trickle = () => {
      this.setValue(this.value + Math.random() / 100);
    };
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = _ProgressBar.defaultCSS;
      const cspNonce = getCspNonce();
      if (cspNonce) {
        element.nonce = cspNonce;
      }
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
  };
  var HeadSnapshot = class extends Snapshot {
    detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
      const { outerHTML } = element;
      const details = outerHTML in result ? result[outerHTML] : {
        type: elementType(element),
        tracked: elementIsTracked(element),
        elements: []
      };
      return {
        ...result,
        [outerHTML]: {
          ...details,
          elements: [...details.elements, element]
        }
      };
    }, {});
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements];
        } else if (elements.length > 1) {
          return [...result, ...elements.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name2) {
      const element = this.findMetaElementByName(name2);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name2) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const {
          elements: [element]
        } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name2) ? element : result;
      }, void 0 | void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.localName;
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.localName;
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.localName;
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name2) {
    const tagName = element.localName;
    return tagName == "meta" && element.getAttribute("name") == name2;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class _PageSnapshot extends Snapshot {
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ documentElement, body, head }) {
      return new this(documentElement, body, new HeadSnapshot(head));
    }
    constructor(documentElement, body, headSnapshot) {
      super(body);
      this.documentElement = documentElement;
      this.headSnapshot = headSnapshot;
    }
    clone() {
      const clonedElement = this.element.cloneNode(true);
      const selectElements = this.element.querySelectorAll("select");
      const clonedSelectElements = clonedElement.querySelectorAll("select");
      for (const [index4, source] of selectElements.entries()) {
        const clone11 = clonedSelectElements[index4];
        for (const option2 of clone11.selectedOptions) option2.selected = false;
        for (const option2 of source.selectedOptions) clone11.options[option2.index].selected = true;
      }
      for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
        clonedPasswordInput.value = "";
      }
      return new _PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
    }
    get lang() {
      return this.documentElement.getAttribute("lang");
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      const root2 = this.getSetting("root") ?? "/";
      return expandURL(root2);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    get prefersViewTransitions() {
      return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
    }
    get shouldMorphPage() {
      return this.getSetting("refresh-method") === "morph";
    }
    get shouldPreserveScrollPosition() {
      return this.getSetting("refresh-scroll") === "preserve";
    }
    // Private
    getSetting(name2) {
      return this.headSnapshot.getMetaValue(`turbo-${name2}`);
    }
  };
  var ViewTransitioner = class {
    #viewTransitionStarted = false;
    #lastOperation = Promise.resolve();
    renderChange(useViewTransition, render2) {
      if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {
        this.#viewTransitionStarted = true;
        this.#lastOperation = this.#lastOperation.then(async () => {
          await document.startViewTransition(render2).finished;
        });
      } else {
        this.#lastOperation = this.#lastOperation.then(render2);
      }
      return this.#lastOperation;
    }
    get viewTransitionsAvailable() {
      return document.startViewTransition;
    }
  };
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true,
    updateHistory: true,
    shouldCacheSnapshot: true,
    acceptsStreamResponse: false
  };
  var TimingMetric = {
    visitStart: "visitStart",
    requestStart: "requestStart",
    requestEnd: "requestEnd",
    visitEnd: "visitEnd"
  };
  var VisitState = {
    initialized: "initialized",
    started: "started",
    canceled: "canceled",
    failed: "failed",
    completed: "completed"
  };
  var SystemStatusCode = {
    networkFailure: 0,
    timeoutFailure: -1,
    contentTypeMismatch: -2
  };
  var Direction = {
    advance: "forward",
    restore: "back",
    replace: "none"
  };
  var Visit = class {
    identifier = uuid();
    // Required by turbo-ios
    timingMetrics = {};
    followedRedirect = false;
    historyChanged = false;
    scrolled = false;
    shouldCacheSnapshot = true;
    acceptsStreamResponse = false;
    snapshotCached = false;
    state = VisitState.initialized;
    viewTransitioner = new ViewTransitioner();
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const {
        action,
        historyChanged,
        referrer,
        snapshot,
        snapshotHTML,
        response,
        visitCachedSnapshot,
        willRender,
        updateHistory,
        shouldCacheSnapshot,
        acceptsStreamResponse,
        direction: direction2
      } = {
        ...defaultOptions,
        ...options
      };
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshot = snapshot;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.isPageRefresh = this.view.isPageRefresh(this);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.updateHistory = updateHistory;
      this.scrolled = !willRender;
      this.shouldCacheSnapshot = shouldCacheSnapshot;
      this.acceptsStreamResponse = acceptsStreamResponse;
      this.direction = direction2 || Direction[action];
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.adapter.visitCompleted(this);
        this.state = VisitState.completed;
        this.followRedirect();
        if (!this.followedRedirect) {
          this.delegate.visitCompleted(this);
        }
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
        this.delegate.visitCompleted(this);
      }
    }
    changeHistory() {
      if (!this.historyChanged && this.updateHistory) {
        const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
        const method = getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          if (this.shouldCacheSnapshot) this.cacheSnapshot();
          if (this.view.renderPromise) await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            const snapshot = PageSnapshot.fromHTMLString(responseHTML);
            await this.renderPageSnapshot(snapshot, false);
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage || this.isPageRefresh) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise) await this.view.renderPromise;
            await this.renderPageSnapshot(snapshot, isPreview);
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response,
          shouldCacheSnapshot: false,
          willRender: false
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.performScroll();
          this.changeHistory();
          this.adapter.visitRendered(this);
        });
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (this.acceptsStreamResponse) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(_request, _response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(_request, _error) {
      this.recordResponse({
        statusCode: SystemStatusCode.networkFailure,
        redirected: false
      });
    }
    requestFinished() {
      this.finishRequest();
    }
    // Scrolling
    performScroll() {
      if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    // Instrumentation
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
    }
    getTimingMetrics() {
      return { ...this.timingMetrics };
    }
    // Private
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback) {
      this.cancelRender();
      await new Promise((resolve) => {
        this.frame = document.visibilityState === "hidden" ? setTimeout(() => resolve(), 0) : requestAnimationFrame(() => resolve());
      });
      await callback();
      delete this.frame;
    }
    async renderPageSnapshot(snapshot, isPreview) {
      await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
        await this.view.renderPage(snapshot, isPreview, this.willRender, this);
        this.performScroll();
      });
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    progressBar = new ProgressBar();
    constructor(session2) {
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      if (locationIsVisitable(location2, this.navigator.rootLocation)) {
        this.navigator.startVisit(location2, options?.restorationIdentifier || uuid(), options);
      } else {
        window.location.href = location2.toString();
      }
    }
    visitStarted(visit2) {
      this.location = visit2.location;
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload({
            reason: "request_failed",
            context: {
              statusCode
            }
          });
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(_visit) {
    }
    visitCompleted(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    pageInvalidated(reason) {
      this.reload(reason);
    }
    visitFailed(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitRendered(_visit) {
    }
    // Form Submission Delegate
    formSubmissionStarted(_formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(_formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    // Private
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    showProgressBar = () => {
      this.progressBar.show();
    };
    reload(reason) {
      dispatch("turbo:reload", { detail: reason });
      window.location.href = this.location?.toString() || window.location.href;
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    selector = "[data-turbo-temporary]";
    deprecatedSelector = "[data-turbo-cache=false]";
    started = false;
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    removeTemporaryElements = (_event) => {
      for (const element of this.temporaryElements) {
        element.remove();
      }
    };
    get temporaryElements() {
      return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
    }
    get temporaryElementsWithDeprecation() {
      const elements = document.querySelectorAll(this.deprecatedSelector);
      if (elements.length) {
        console.warn(
          `The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`
        );
      }
      return [...elements];
    }
  };
  var FrameRedirector = class {
    constructor(session2, element) {
      this.session = session2;
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formSubmitObserver = new FormSubmitObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldRedirect(element);
    }
    linkClickIntercepted(element, url, event) {
      const frame2 = this.#findFrameElement(element);
      if (frame2) {
        frame2.delegate.linkClickIntercepted(element, url, event);
      }
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter2) {
      return element.closest("turbo-frame") == null && this.#shouldSubmit(element, submitter2) && this.#shouldRedirect(element, submitter2);
    }
    formSubmitted(element, submitter2) {
      const frame2 = this.#findFrameElement(element, submitter2);
      if (frame2) {
        frame2.delegate.formSubmitted(element, submitter2);
      }
    }
    #shouldSubmit(form, submitter2) {
      const action = getAction$1(form, submitter2);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL(meta?.content ?? "/");
      return this.#shouldRedirect(form, submitter2) && locationIsVisitable(action, rootLocation);
    }
    #shouldRedirect(element, submitter2) {
      const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter2) : this.session.elementIsNavigatable(element);
      if (isNavigatable) {
        const frame2 = this.#findFrameElement(element, submitter2);
        return frame2 ? frame2 != element.closest("turbo-frame") : false;
      } else {
        return false;
      }
    }
    #findFrameElement(element, submitter2) {
      const id5 = submitter2?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
      if (id5 && id5 != "_top") {
        const frame2 = this.element.querySelector(`#${id5}:not([disabled])`);
        if (frame2 instanceof FrameElement) {
          return frame2;
        }
      }
    }
  };
  var History = class {
    location;
    restorationIdentifier = uuid();
    restorationData = {};
    started = false;
    pageLoaded = false;
    currentIndex = 0;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.currentIndex = history.state?.turbo?.restorationIndex || 0;
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      if (method === history.pushState) ++this.currentIndex;
      const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    // Restoration data
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = {
        ...restorationData,
        ...additionalData
      };
    }
    // Scroll restoration
    assumeControlOfScrollRestoration() {
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = history.scrollRestoration ?? "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    // Event handlers
    onPopState = (event) => {
      if (this.shouldHandlePopState()) {
        const { turbo } = event.state || {};
        if (turbo) {
          this.location = new URL(window.location.href);
          const { restorationIdentifier, restorationIndex } = turbo;
          this.restorationIdentifier = restorationIdentifier;
          const direction2 = restorationIndex > this.currentIndex ? "forward" : "back";
          this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction2);
          this.currentIndex = restorationIndex;
        }
      }
    };
    onPageLoad = async (_event) => {
      await nextMicrotask();
      this.pageLoaded = true;
    };
    // Private
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var LinkPrefetchObserver = class {
    started = false;
    #prefetchedLink = null;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (this.started) return;
      if (this.eventTarget.readyState === "loading") {
        this.eventTarget.addEventListener("DOMContentLoaded", this.#enable, { once: true });
      } else {
        this.#enable();
      }
    }
    stop() {
      if (!this.started) return;
      this.eventTarget.removeEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = false;
    }
    #enable = () => {
      this.eventTarget.addEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = true;
    };
    #tryToPrefetchRequest = (event) => {
      if (getMetaContent("turbo-prefetch") === "false") return;
      const target = event.target;
      const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
      if (isLink && this.#isPrefetchable(target)) {
        const link2 = target;
        const location2 = getLocationForLink(link2);
        if (this.delegate.canPrefetchRequestToLocation(link2, location2)) {
          this.#prefetchedLink = link2;
          const fetchRequest = new FetchRequest(
            this,
            FetchMethod.get,
            location2,
            new URLSearchParams(),
            target
          );
          prefetchCache.setLater(location2.toString(), fetchRequest, this.#cacheTtl);
        }
      }
    };
    #cancelRequestIfObsolete = (event) => {
      if (event.target === this.#prefetchedLink) this.#cancelPrefetchRequest();
    };
    #cancelPrefetchRequest = () => {
      prefetchCache.clear();
      this.#prefetchedLink = null;
    };
    #tryToUsePrefetchedRequest = (event) => {
      if (event.target.tagName !== "FORM" && event.detail.fetchOptions.method === "GET") {
        const cached = prefetchCache.get(event.detail.url.toString());
        if (cached) {
          event.detail.fetchRequest = cached;
        }
        prefetchCache.clear();
      }
    };
    prepareRequest(request) {
      const link2 = request.target;
      request.headers["X-Sec-Purpose"] = "prefetch";
      const turboFrame = link2.closest("turbo-frame");
      const turboFrameTarget = link2.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;
      if (turboFrameTarget && turboFrameTarget !== "_top") {
        request.headers["Turbo-Frame"] = turboFrameTarget;
      }
    }
    // Fetch request interface
    requestSucceededWithResponse() {
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    get #cacheTtl() {
      return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
    }
    #isPrefetchable(link2) {
      const href = link2.getAttribute("href");
      if (!href) return false;
      if (unfetchableLink(link2)) return false;
      if (linkToTheSamePage(link2)) return false;
      if (linkOptsOut(link2)) return false;
      if (nonSafeLink(link2)) return false;
      if (eventPrevented(link2)) return false;
      return true;
    }
  };
  var unfetchableLink = (link2) => {
    return link2.origin !== document.location.origin || !["http:", "https:"].includes(link2.protocol) || link2.hasAttribute("target");
  };
  var linkToTheSamePage = (link2) => {
    return link2.pathname + link2.search === document.location.pathname + document.location.search || link2.href.startsWith("#");
  };
  var linkOptsOut = (link2) => {
    if (link2.getAttribute("data-turbo-prefetch") === "false") return true;
    if (link2.getAttribute("data-turbo") === "false") return true;
    const turboPrefetchParent = findClosestRecursively(link2, "[data-turbo-prefetch]");
    if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false") return true;
    return false;
  };
  var nonSafeLink = (link2) => {
    const turboMethod = link2.getAttribute("data-turbo-method");
    if (turboMethod && turboMethod.toLowerCase() !== "get") return true;
    if (isUJS(link2)) return true;
    if (link2.hasAttribute("data-turbo-confirm")) return true;
    if (link2.hasAttribute("data-turbo-stream")) return true;
    return false;
  };
  var isUJS = (link2) => {
    return link2.hasAttribute("data-remote") || link2.hasAttribute("data-behavior") || link2.hasAttribute("data-confirm") || link2.hasAttribute("data-method");
  };
  var eventPrevented = (link2) => {
    const event = dispatch("turbo:before-prefetch", { target: link2, cancelable: true });
    return event.defaultPrevented;
  };
  var Navigator = class {
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        this.delegate.visitProposedToLocation(location2, options);
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
        referrer: this.location,
        ...options
      });
      this.currentVisit.start();
    }
    submitForm(form, submitter2) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter2, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get rootLocation() {
      return this.view.snapshot.rootLocation;
    }
    get history() {
      return this.delegate.history;
    }
    // Form submission delegate
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          const shouldCacheSnapshot = formSubmission.isSafe;
          if (!shouldCacheSnapshot) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);
          const visitOptions = {
            action,
            shouldCacheSnapshot,
            response: { statusCode, responseHTML, redirected }
          };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot, this.currentVisit);
        } else {
          await this.view.renderPage(snapshot, false, true, this.currentVisit);
        }
        if (!snapshot.shouldPreserveScrollPosition) {
          this.view.scrollToTop();
        }
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error4) {
      console.error(error4);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    // Visit delegate
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
      delete this.currentVisit;
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    // Visits
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    #getActionForFormSubmission(formSubmission, fetchResponse) {
      const { submitter: submitter2, formElement } = formSubmission;
      return getVisitAction(submitter2, formElement) || this.#getDefaultAction(fetchResponse);
    }
    #getDefaultAction(fetchResponse) {
      const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
      return sameLocationRedirect ? "replace" : "advance";
    }
  };
  var PageStage = {
    initial: 0,
    loading: 1,
    interactive: 2,
    complete: 3
  };
  var PageObserver = class {
    stage = PageStage.initial;
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    interpretReadyState = () => {
      const { readyState } = this;
      if (readyState == "interactive") {
        this.pageIsInteractive();
      } else if (readyState == "complete") {
        this.pageIsComplete();
      }
    };
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    pageWillUnload = () => {
      this.delegate.pageWillUnload();
    };
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    onScroll = () => {
      this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
    };
    // Private
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamMessageRenderer = class {
    render({ fragment }) {
      Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
        withAutofocusFromFragment(fragment, () => {
          withPreservedFocus(() => {
            document.documentElement.appendChild(fragment);
          });
        });
      });
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement, newPermanentElement) {
      newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
    }
    leavingBardo() {
    }
  };
  function getPermanentElementMapForFragment(fragment) {
    const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
    const permanentElementMap = {};
    for (const permanentElementInDocument of permanentElementsInDocument) {
      const { id: id5 } = permanentElementInDocument;
      for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
        const elementInStream = getPermanentElementById(streamElement.templateElement.content, id5);
        if (elementInStream) {
          permanentElementMap[id5] = [permanentElementInDocument, elementInStream];
        }
      }
    }
    return permanentElementMap;
  }
  async function withAutofocusFromFragment(fragment, callback) {
    const generatedID = `turbo-stream-autofocus-${uuid()}`;
    const turboStreams = fragment.querySelectorAll("turbo-stream");
    const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
    let willAutofocusId = null;
    if (elementWithAutofocus) {
      if (elementWithAutofocus.id) {
        willAutofocusId = elementWithAutofocus.id;
      } else {
        willAutofocusId = generatedID;
      }
      elementWithAutofocus.id = willAutofocusId;
    }
    callback();
    await nextRepaint();
    const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
    if (hasNoActiveElement && willAutofocusId) {
      const elementToAutofocus = document.getElementById(willAutofocusId);
      if (elementIsFocusable(elementToAutofocus)) {
        elementToAutofocus.focus();
      }
      if (elementToAutofocus && elementToAutofocus.id == generatedID) {
        elementToAutofocus.removeAttribute("id");
      }
    }
  }
  async function withPreservedFocus(callback) {
    const [activeElementBeforeRender, activeElementAfterRender] = await around(callback, () => document.activeElement);
    const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
    if (restoreFocusTo) {
      const elementToFocus = document.getElementById(restoreFocusTo);
      if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
        elementToFocus.focus();
      }
    }
  }
  function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
    for (const streamElement of nodeListOfStreamElements) {
      const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
      if (elementWithAutofocus) return elementWithAutofocus;
    }
    return null;
  }
  var StreamObserver = class {
    sources = /* @__PURE__ */ new Set();
    #started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.#started) {
        this.#started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.#started) {
        this.#started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    inspectFetchResponse = (event) => {
      const response = fetchResponseFromEvent(event);
      if (response && fetchResponseIsStream(response)) {
        event.preventDefault();
        this.receiveMessageResponse(response);
      }
    };
    receiveMessageEvent = (event) => {
      if (this.#started && typeof event.data == "string") {
        this.receiveMessageHTML(event.data);
      }
    };
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
    }
  };
  function fetchResponseFromEvent(event) {
    const fetchResponse = event.detail?.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response) {
    const contentType = response.contentType ?? "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const { documentElement, body } = document;
      documentElement.replaceChild(newElement, body);
    }
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head } = document;
      documentElement.replaceChild(this.newHead, head);
      this.renderElement(this.currentElement, this.newElement);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode = replaceableElement.parentNode;
        if (parentNode) {
          const element = activateScriptElement(replaceableElement);
          parentNode.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return document.documentElement.querySelectorAll("script");
    }
  };
  var PageRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      if (document.body && newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(newElement);
      } else {
        document.documentElement.appendChild(newElement);
      }
    }
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    get reloadReason() {
      if (!this.newSnapshot.isVisitable) {
        return {
          reason: "turbo_visit_control_is_reload"
        };
      }
      if (!this.trackedElementsAreIdentical) {
        return {
          reason: "tracked_element_mismatch"
        };
      }
    }
    async prepareToRender() {
      this.#setLanguage();
      await this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        await this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    #setLanguage() {
      const { documentElement } = this.currentSnapshot;
      const { lang } = this.newSnapshot;
      if (lang) {
        documentElement.setAttribute("lang", lang);
      } else {
        documentElement.removeAttribute("lang");
      }
    }
    async mergeHead() {
      const mergedHeadElements = this.mergeProvisionalElements();
      const newStylesheetElements = this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      await mergedHeadElements;
      await newStylesheetElements;
      if (this.willRender) {
        this.removeUnusedDynamicStylesheetElements();
      }
    }
    async replaceBody() {
      await this.preservingPermanentElements(async () => {
        this.activateNewBody();
        await this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    async copyNewHeadStylesheetElements() {
      const loadingElements = [];
      for (const element of this.newHeadStylesheetElements) {
        loadingElements.push(waitForLoad(element));
        document.head.appendChild(element);
      }
      await Promise.all(loadingElements);
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(activateScriptElement(element));
      }
    }
    removeUnusedDynamicStylesheetElements() {
      for (const element of this.unusedDynamicStylesheetElements) {
        document.head.removeChild(element);
      }
    }
    async mergeProvisionalElements() {
      const newHeadElements = [...this.newHeadProvisionalElements];
      for (const element of this.currentHeadProvisionalElements) {
        if (!this.isCurrentElementInElementList(element, newHeadElements)) {
          document.head.removeChild(element);
        }
      }
      for (const element of newHeadElements) {
        document.head.appendChild(element);
      }
    }
    isCurrentElementInElementList(element, elementList) {
      for (const [index4, newElement] of elementList.entries()) {
        if (element.tagName == "TITLE") {
          if (newElement.tagName != "TITLE") {
            continue;
          }
          if (element.innerHTML == newElement.innerHTML) {
            elementList.splice(index4, 1);
            return true;
          }
        }
        if (newElement.isEqualNode(element)) {
          elementList.splice(index4, 1);
          return true;
        }
      }
      return false;
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    async assignNewBody() {
      await this.renderElement(this.currentElement, this.newElement);
    }
    get unusedDynamicStylesheetElements() {
      return this.oldHeadStylesheetElements.filter((element) => {
        return element.getAttribute("data-turbo-track") === "dynamic";
      });
    }
    get oldHeadStylesheetElements() {
      return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var MorphingPageRenderer = class extends PageRenderer {
    static renderElement(currentElement, newElement) {
      morphElements(currentElement, newElement, {
        callbacks: {
          beforeNodeMorphed: (element) => !canRefreshFrame(element)
        }
      });
      for (const frame2 of currentElement.querySelectorAll("turbo-frame")) {
        if (canRefreshFrame(frame2)) frame2.reload();
      }
      dispatch("turbo:morph", { detail: { currentElement, newElement } });
    }
    async preservingPermanentElements(callback) {
      return await callback();
    }
    get renderMethod() {
      return "morph";
    }
    get shouldAutofocus() {
      return false;
    }
  };
  function canRefreshFrame(frame2) {
    return frame2 instanceof FrameElement && frame2.src && frame2.refresh === "morph" && !frame2.closest("[data-turbo-permanent]");
  }
  var SnapshotCache = class {
    keys = [];
    snapshots = {};
    constructor(size2) {
      this.size = size2;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    // Private
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index4 = this.keys.indexOf(key);
      if (index4 > -1) this.keys.splice(index4, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    snapshotCache = new SnapshotCache(10);
    lastRenderedLocation = new URL(location.href);
    forceReloaded = false;
    shouldTransitionTo(newSnapshot) {
      return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
    }
    renderPage(snapshot, isPreview = false, willRender = true, visit2) {
      const shouldMorphPage = this.isPageRefresh(visit2) && this.snapshot.shouldMorphPage;
      const rendererClass = shouldMorphPage ? MorphingPageRenderer : PageRenderer;
      const renderer = new rendererClass(this.snapshot, snapshot, isPreview, willRender);
      if (!renderer.shouldRender) {
        this.forceReloaded = true;
      } else {
        visit2?.changeHistory();
      }
      return this.render(renderer);
    }
    renderError(snapshot, visit2) {
      visit2?.changeHistory();
      const renderer = new ErrorRenderer(this.snapshot, snapshot, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot(snapshot = this.snapshot) {
      if (snapshot.isCacheable) {
        this.delegate.viewWillCacheSnapshot();
        const { lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    isPageRefresh(visit2) {
      return !visit2 || this.lastRenderedLocation.pathname === visit2.location.pathname && visit2.action === "replace";
    }
    shouldPreserveScrollPosition(visit2) {
      return this.isPageRefresh(visit2) && this.snapshot.shouldPreserveScrollPosition;
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
  };
  var Preloader = class {
    selector = "a[data-turbo-preload]";
    constructor(delegate, snapshotCache) {
      this.delegate = delegate;
      this.snapshotCache = snapshotCache;
    }
    start() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", this.#preloadAll);
      } else {
        this.preloadOnLoadLinksForView(document.body);
      }
    }
    stop() {
      document.removeEventListener("DOMContentLoaded", this.#preloadAll);
    }
    preloadOnLoadLinksForView(element) {
      for (const link2 of element.querySelectorAll(this.selector)) {
        if (this.delegate.shouldPreloadLink(link2)) {
          this.preloadURL(link2);
        }
      }
    }
    async preloadURL(link2) {
      const location2 = new URL(link2.href);
      if (this.snapshotCache.has(location2)) {
        return;
      }
      const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams(), link2);
      await fetchRequest.perform();
    }
    // Fetch request delegate
    prepareRequest(fetchRequest) {
      fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
    }
    async requestSucceededWithResponse(fetchRequest, fetchResponse) {
      try {
        const responseHTML = await fetchResponse.responseHTML;
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        this.snapshotCache.put(fetchRequest.url, snapshot);
      } catch (_2) {
      }
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    #preloadAll = () => {
      this.preloadOnLoadLinksForView(document.body);
    };
  };
  var Cache = class {
    constructor(session2) {
      this.session = session2;
    }
    clear() {
      this.session.clearCache();
    }
    resetCacheControl() {
      this.#setCacheControl("");
    }
    exemptPageFromCache() {
      this.#setCacheControl("no-cache");
    }
    exemptPageFromPreview() {
      this.#setCacheControl("no-preview");
    }
    #setCacheControl(value2) {
      setMetaContent("turbo-cache-control", value2);
    }
  };
  var Session = class {
    navigator = new Navigator(this);
    history = new History(this);
    view = new PageView(this, document.documentElement);
    adapter = new BrowserAdapter(this);
    pageObserver = new PageObserver(this);
    cacheObserver = new CacheObserver();
    linkPrefetchObserver = new LinkPrefetchObserver(this, document);
    linkClickObserver = new LinkClickObserver(this, window);
    formSubmitObserver = new FormSubmitObserver(this, document);
    scrollObserver = new ScrollObserver(this);
    streamObserver = new StreamObserver(this);
    formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
    frameRedirector = new FrameRedirector(this, document.documentElement);
    streamMessageRenderer = new StreamMessageRenderer();
    cache = new Cache(this);
    enabled = true;
    started = false;
    #pageRefreshDebouncePeriod = 150;
    constructor(recentRequests2) {
      this.recentRequests = recentRequests2;
      this.preloader = new Preloader(this, this.view.snapshotCache);
      this.debouncedRefresh = this.refresh;
      this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.linkPrefetchObserver.start();
        this.formLinkClickObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.preloader.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.linkPrefetchObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.preloader.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter2) {
      this.adapter = adapter2;
    }
    visit(location2, options = {}) {
      const frameElement = options.frame ? document.getElementById(options.frame) : null;
      if (frameElement instanceof FrameElement) {
        const action = options.action || getVisitAction(frameElement);
        frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
        frameElement.src = location2.toString();
      } else {
        this.navigator.proposeVisit(expandURL(location2), options);
      }
    }
    refresh(url, requestId) {
      const isRecentRequest = requestId && this.recentRequests.has(requestId);
      if (!isRecentRequest && !this.navigator.currentVisit) {
        this.visit(url, { action: "replace", shouldCacheSnapshot: false });
      }
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      this.streamMessageRenderer.render(StreamMessage.wrap(message));
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      console.warn(
        "Please replace `session.setProgressBarDelay(delay)` with `session.progressBarDelay = delay`. The function is deprecated and will be removed in a future version of Turbo.`"
      );
      this.progressBarDelay = delay;
    }
    set progressBarDelay(delay) {
      config.drive.progressBarDelay = delay;
    }
    get progressBarDelay() {
      return config.drive.progressBarDelay;
    }
    set drive(value2) {
      config.drive.enabled = value2;
    }
    get drive() {
      return config.drive.enabled;
    }
    set formMode(value2) {
      config.forms.mode = value2;
    }
    get formMode() {
      return config.forms.mode;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    get pageRefreshDebouncePeriod() {
      return this.#pageRefreshDebouncePeriod;
    }
    set pageRefreshDebouncePeriod(value2) {
      this.refresh = debounce(this.debouncedRefresh.bind(this), value2);
      this.#pageRefreshDebouncePeriod = value2;
    }
    // Preloader delegate
    shouldPreloadLink(element) {
      const isUnsafe = element.hasAttribute("data-turbo-method");
      const isStream = element.hasAttribute("data-turbo-stream");
      const frameTarget = element.getAttribute("data-turbo-frame");
      const frame2 = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
      if (isUnsafe || isStream || frame2 instanceof FrameElement) {
        return false;
      } else {
        const location2 = new URL(element.href);
        return this.elementIsNavigatable(element) && locationIsVisitable(location2, this.snapshot.rootLocation);
      }
    }
    // History delegate
    historyPoppedToLocationWithRestorationIdentifierAndDirection(location2, restorationIdentifier, direction2) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, {
          action: "restore",
          historyChanged: true,
          direction: direction2
        });
      } else {
        this.adapter.pageInvalidated({
          reason: "turbo_disabled"
        });
      }
    }
    // Scroll observer delegate
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    // Form click observer delegate
    willSubmitFormLinkToLocation(link2, location2) {
      return this.elementIsNavigatable(link2) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    submittedFormLinkToLocation() {
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link2, location2) {
      return this.elementIsNavigatable(link2) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    // Link click observer delegate
    willFollowLinkToLocation(link2, location2, event) {
      return this.elementIsNavigatable(link2) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link2, location2, event);
    }
    followedLinkToLocation(link2, location2) {
      const action = this.getActionForLink(link2);
      const acceptsStreamResponse = link2.hasAttribute("data-turbo-stream");
      this.visit(location2.href, { action, acceptsStreamResponse });
    }
    // Navigator delegate
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    // Visit delegate
    visitStarted(visit2) {
      if (!visit2.acceptsStreamResponse) {
        markAsBusy(document.documentElement);
        this.view.markVisitDirection(visit2.direction);
      }
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      this.view.unmarkVisitDirection();
      clearBusyState(document.documentElement);
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    // Form submit observer delegate
    willSubmitForm(form, submitter2) {
      const action = getAction$1(form, submitter2);
      return this.submissionIsNavigatable(form, submitter2) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter2) {
      this.navigator.submitForm(form, submitter2);
    }
    // Page observer delegate
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    // Stream observer delegate
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    // Page view delegate
    viewWillCacheSnapshot() {
      if (!this.navigator.currentVisit?.silent) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, options) {
      const event = this.notifyApplicationBeforeRender(element, options);
      const {
        defaultPrevented,
        detail: { render: render2 }
      } = event;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender(renderMethod);
    }
    preloadOnLoadLinksForView(element) {
      this.preloader.preloadOnLoadLinksForView(element);
    }
    viewInvalidated(reason) {
      this.adapter.pageInvalidated(reason);
    }
    // Frame element
    frameLoaded(frame2) {
      this.notifyApplicationAfterFrameLoad(frame2);
    }
    frameRendered(fetchResponse, frame2) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame2);
    }
    // Application events
    applicationAllowsFollowingLinkToLocation(link2, location2, ev) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link2, location2, ev);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link2, location2, event) {
      return dispatch("turbo:click", {
        target: link2,
        detail: { url: location2.href, originalEvent: event },
        cancelable: true
      });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", {
        detail: { url: location2.href },
        cancelable: true
      });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, options) {
      return dispatch("turbo:before-render", {
        detail: { newBody, ...options },
        cancelable: true
      });
    }
    notifyApplicationAfterRender(renderMethod) {
      return dispatch("turbo:render", { detail: { renderMethod } });
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      return dispatch("turbo:load", {
        detail: { url: this.location.href, timing }
      });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(
        new HashChangeEvent("hashchange", {
          oldURL: oldURL.toString(),
          newURL: newURL.toString()
        })
      );
    }
    notifyApplicationAfterFrameLoad(frame2) {
      return dispatch("turbo:frame-load", { target: frame2 });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame2) {
      return dispatch("turbo:frame-render", {
        detail: { fetchResponse },
        target: frame2,
        cancelable: true
      });
    }
    // Helpers
    submissionIsNavigatable(form, submitter2) {
      if (config.forms.mode == "off") {
        return false;
      } else {
        const submitterIsNavigatable = submitter2 ? this.elementIsNavigatable(submitter2) : true;
        if (config.forms.mode == "optin") {
          return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
        } else {
          return submitterIsNavigatable && this.elementIsNavigatable(form);
        }
      }
    }
    elementIsNavigatable(element) {
      const container = findClosestRecursively(element, "[data-turbo]");
      const withinFrame = findClosestRecursively(element, "turbo-frame");
      if (config.drive.enabled || withinFrame) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    // Private
    getActionForLink(link2) {
      return getVisitAction(link2) || "advance";
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var session = new Session(recentRequests);
  var { cache, navigator: navigator$1 } = session;
  function start() {
    session.start();
  }
  function registerAdapter(adapter2) {
    session.registerAdapter(adapter2);
  }
  function visit(location2, options) {
    session.visit(location2, options);
  }
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    console.warn(
      "Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    console.warn(
      "Please replace `Turbo.setProgressBarDelay(delay)` with `Turbo.config.drive.progressBarDelay = delay`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    config.drive.progressBarDelay = delay;
  }
  function setConfirmMethod(confirmMethod) {
    console.warn(
      "Please replace `Turbo.setConfirmMethod(confirmMethod)` with `Turbo.config.forms.confirm = confirmMethod`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    config.forms.confirm = confirmMethod;
  }
  function setFormMode(mode) {
    console.warn(
      "Please replace `Turbo.setFormMode(mode)` with `Turbo.config.forms.mode = mode`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    config.forms.mode = mode;
  }
  var Turbo2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    cache,
    PageRenderer,
    PageSnapshot,
    FrameRenderer,
    fetch: fetchWithTurboHeaders,
    config,
    start,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod,
    setFormMode
  });
  var TurboFrameMissingError = class extends Error {
  };
  var FrameController = class {
    fetchResponseLoaded = (_fetchResponse) => Promise.resolve();
    #currentFetchRequest = null;
    #resolveVisitPromise = () => {
    };
    #connected = false;
    #hasBeenLoaded = false;
    #ignoredAttributes = /* @__PURE__ */ new Set();
    #shouldMorphFrame = false;
    action = null;
    constructor(element) {
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.restorationIdentifier = uuid();
      this.formSubmitObserver = new FormSubmitObserver(this, this.element);
    }
    // Frame delegate
    connect() {
      if (!this.#connected) {
        this.#connected = true;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        } else {
          this.#loadSourceURL();
        }
        this.formLinkClickObserver.start();
        this.linkInterceptor.start();
        this.formSubmitObserver.start();
      }
    }
    disconnect() {
      if (this.#connected) {
        this.#connected = false;
        this.appearanceObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkInterceptor.stop();
        this.formSubmitObserver.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.#loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.#isIgnoringChangesTo("src")) return;
      if (this.element.isConnected) {
        this.complete = false;
      }
      if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {
        this.#loadSourceURL();
      }
    }
    sourceURLReloaded() {
      const { refresh, src } = this.element;
      this.#shouldMorphFrame = src && refresh === "morph";
      this.element.removeAttribute("complete");
      this.element.src = null;
      this.element.src = src;
      return this.element.loaded;
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.#loadSourceURL();
      }
    }
    async #loadSourceURL() {
      if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
        this.element.loaded = this.#visit(expandURL(this.sourceURL));
        this.appearanceObserver.stop();
        await this.element.loaded;
        this.#hasBeenLoaded = true;
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const document2 = parseHTMLDocument(html);
          const pageSnapshot = PageSnapshot.fromDocument(document2);
          if (pageSnapshot.isVisitable) {
            await this.#loadFrameResponse(fetchResponse, document2);
          } else {
            await this.#handleUnvisitableFrameResponse(fetchResponse);
          }
        }
      } finally {
        this.#shouldMorphFrame = false;
        this.fetchResponseLoaded = () => Promise.resolve();
      }
    }
    // Appearance observer delegate
    elementAppearedInViewport(element) {
      this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
      this.#loadSourceURL();
    }
    // Form link click observer delegate
    willSubmitFormLinkToLocation(link2) {
      return this.#shouldInterceptNavigation(link2);
    }
    submittedFormLinkToLocation(link2, _location, form) {
      const frame2 = this.#findFrameElement(link2);
      if (frame2) form.setAttribute("data-turbo-frame", frame2.id);
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldInterceptNavigation(element);
    }
    linkClickIntercepted(element, location2) {
      this.#navigateFrame(element, location2);
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter2) {
      return element.closest("turbo-frame") == this.element && this.#shouldInterceptNavigation(element, submitter2);
    }
    formSubmitted(element, submitter2) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.formSubmission = new FormSubmission(this, element, submitter2);
      const { fetchRequest } = this.formSubmission;
      this.prepareRequest(fetchRequest);
      this.formSubmission.start();
    }
    // Fetch request delegate
    prepareRequest(request) {
      request.headers["Turbo-Frame"] = this.id;
      if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(_request, _response) {
      this.#resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    async requestFailedWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    requestErrored(request, error4) {
      console.error(error4);
      this.#resolveVisitPromise();
    }
    requestFinished(_request) {
      clearBusyState(this.element);
    }
    // Form submission delegate
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.#findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame2 = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);
      frame2.delegate.proposeVisitIfNavigatedWithAction(frame2, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame2));
      frame2.delegate.loadResponse(response);
      if (!formSubmission.isSafe) {
        session.clearCache();
      }
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
      session.clearCache();
    }
    formSubmissionErrored(formSubmission, error4) {
      console.error(error4);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.#findFrameElement(formElement));
    }
    // View delegate
    allowsImmediateRender({ element: newFrame }, options) {
      const event = dispatch("turbo:before-frame-render", {
        target: this.element,
        detail: { newFrame, ...options },
        cancelable: true
      });
      const {
        defaultPrevented,
        detail: { render: render2 }
      } = event;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {
    }
    preloadOnLoadLinksForView(element) {
      session.preloadOnLoadLinksForView(element);
    }
    viewInvalidated() {
    }
    // Frame renderer delegate
    willRenderFrame(currentElement, _newElement) {
      this.previousFrameElement = currentElement.cloneNode(true);
    }
    visitCachedSnapshot = ({ element }) => {
      const frame2 = element.querySelector("#" + this.element.id);
      if (frame2 && this.previousFrameElement) {
        frame2.replaceChildren(...this.previousFrameElement.children);
      }
      delete this.previousFrameElement;
    };
    // Private
    async #loadFrameResponse(fetchResponse, document2) {
      const newFrameElement = await this.extractForeignFrameElement(document2.body);
      const rendererClass = this.#shouldMorphFrame ? MorphingFrameRenderer : FrameRenderer;
      if (newFrameElement) {
        const snapshot = new Snapshot(newFrameElement);
        const renderer = new rendererClass(this, this.view.snapshot, snapshot, false, false);
        if (this.view.renderPromise) await this.view.renderPromise;
        this.changeHistory();
        await this.view.render(renderer);
        this.complete = true;
        session.frameRendered(fetchResponse, this.element);
        session.frameLoaded(this.element);
        await this.fetchResponseLoaded(fetchResponse);
      } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {
        this.#handleFrameMissingFromResponse(fetchResponse);
      }
    }
    async #visit(url) {
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      this.#currentFetchRequest?.cancel();
      this.#currentFetchRequest = request;
      return new Promise((resolve) => {
        this.#resolveVisitPromise = () => {
          this.#resolveVisitPromise = () => {
          };
          this.#currentFetchRequest = null;
          resolve();
        };
        request.perform();
      });
    }
    #navigateFrame(element, url, submitter2) {
      const frame2 = this.#findFrameElement(element, submitter2);
      frame2.delegate.proposeVisitIfNavigatedWithAction(frame2, getVisitAction(submitter2, element, frame2));
      this.#withCurrentNavigationElement(element, () => {
        frame2.src = url;
      });
    }
    proposeVisitIfNavigatedWithAction(frame2, action = null) {
      this.action = action;
      if (this.action) {
        const pageSnapshot = PageSnapshot.fromElement(frame2).clone();
        const { visitCachedSnapshot } = frame2.delegate;
        frame2.delegate.fetchResponseLoaded = async (fetchResponse) => {
          if (frame2.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = await fetchResponse.responseHTML;
            const response = { statusCode, redirected, responseHTML };
            const options = {
              response,
              visitCachedSnapshot,
              willRender: false,
              updateHistory: false,
              restorationIdentifier: this.restorationIdentifier,
              snapshot: pageSnapshot
            };
            if (this.action) options.action = this.action;
            session.visit(frame2.src, options);
          }
        };
      }
    }
    changeHistory() {
      if (this.action) {
        const method = getHistoryMethodForAction(this.action);
        session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
      }
    }
    async #handleUnvisitableFrameResponse(fetchResponse) {
      console.warn(
        `The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`
      );
      await this.#visitResponse(fetchResponse.response);
    }
    #willHandleFrameMissingFromResponse(fetchResponse) {
      this.element.setAttribute("complete", "");
      const response = fetchResponse.response;
      const visit2 = async (url, options) => {
        if (url instanceof Response) {
          this.#visitResponse(url);
        } else {
          session.visit(url, options);
        }
      };
      const event = dispatch("turbo:frame-missing", {
        target: this.element,
        detail: { response, visit: visit2 },
        cancelable: true
      });
      return !event.defaultPrevented;
    }
    #handleFrameMissingFromResponse(fetchResponse) {
      this.view.missing();
      this.#throwFrameMissingError(fetchResponse);
    }
    #throwFrameMissingError(fetchResponse) {
      const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
      throw new TurboFrameMissingError(message);
    }
    async #visitResponse(response) {
      const wrapped = new FetchResponse(response);
      const responseHTML = await wrapped.responseHTML;
      const { location: location2, redirected, statusCode } = wrapped;
      return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
    }
    #findFrameElement(element, submitter2) {
      const id5 = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
      return getFrameElementById(id5) ?? this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id5 = CSS.escape(this.id);
      try {
        element = activateElement(container.querySelector(`turbo-frame#${id5}`), this.sourceURL);
        if (element) {
          return element;
        }
        element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id5}]`), this.sourceURL);
        if (element) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
      } catch (error4) {
        console.error(error4);
        return new FrameElement();
      }
      return null;
    }
    #formActionIsVisitable(form, submitter2) {
      const action = getAction$1(form, submitter2);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    #shouldInterceptNavigation(element, submitter2) {
      const id5 = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter2)) {
        return false;
      }
      if (!this.enabled || id5 == "_top") {
        return false;
      }
      if (id5) {
        const frameElement = getFrameElementById(id5);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementIsNavigatable(element)) {
        return false;
      }
      if (submitter2 && !session.elementIsNavigatable(submitter2)) {
        return false;
      }
      return true;
    }
    // Computed properties
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    set sourceURL(sourceURL) {
      this.#ignoringChangesToAttribute("src", () => {
        this.element.src = sourceURL ?? null;
      });
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.#resolveVisitPromise() !== void 0;
    }
    get complete() {
      return this.element.hasAttribute("complete");
    }
    set complete(value2) {
      if (value2) {
        this.element.setAttribute("complete", "");
      } else {
        this.element.removeAttribute("complete");
      }
    }
    get isActive() {
      return this.element.isActive && this.#connected;
    }
    get rootLocation() {
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root2 = meta?.content ?? "/";
      return expandURL(root2);
    }
    #isIgnoringChangesTo(attributeName) {
      return this.#ignoredAttributes.has(attributeName);
    }
    #ignoringChangesToAttribute(attributeName, callback) {
      this.#ignoredAttributes.add(attributeName);
      callback();
      this.#ignoredAttributes.delete(attributeName);
    }
    #withCurrentNavigationElement(element, callback) {
      this.currentNavigationElement = element;
      callback();
      delete this.currentNavigationElement;
    }
  };
  function getFrameElementById(id5) {
    if (id5 != null) {
      const element = document.getElementById(id5);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamActions = {
    after() {
      this.targetElements.forEach((e3) => e3.parentElement?.insertBefore(this.templateContent, e3.nextSibling));
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e3) => e3.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e3) => e3.parentElement?.insertBefore(this.templateContent, e3));
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e3) => e3.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e3) => e3.remove());
    },
    replace() {
      const method = this.getAttribute("method");
      this.targetElements.forEach((targetElement) => {
        if (method === "morph") {
          morphElements(targetElement, this.templateContent);
        } else {
          targetElement.replaceWith(this.templateContent);
        }
      });
    },
    update() {
      const method = this.getAttribute("method");
      this.targetElements.forEach((targetElement) => {
        if (method === "morph") {
          morphChildren(targetElement, this.templateContent);
        } else {
          targetElement.innerHTML = "";
          targetElement.append(this.templateContent);
        }
      });
    },
    refresh() {
      session.refresh(this.baseURI, this.requestId);
    }
  };
  var StreamElement = class _StreamElement extends HTMLElement {
    static async renderElement(newElement) {
      await newElement.performAction();
    }
    async connectedCallback() {
      try {
        await this.render();
      } catch (error4) {
        console.error(error4);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      return this.renderPromise ??= (async () => {
        const event = this.beforeRenderEvent;
        if (this.dispatchEvent(event)) {
          await nextRepaint();
          await event.detail.render(this);
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch {
      }
    }
    /**
     * Removes duplicate children (by ID)
     */
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c5) => c5.remove());
    }
    /**
     * Gets the list of duplicate children (i.e. those with the same ID)
     */
    get duplicateChildren() {
      const existingChildren = this.targetElements.flatMap((e3) => [...e3.children]).filter((c5) => !!c5.id);
      const newChildrenIds = [...this.templateContent?.children || []].filter((c5) => !!c5.id).map((c5) => c5.id);
      return existingChildren.filter((c5) => newChildrenIds.includes(c5.id));
    }
    /**
     * Gets the action function to be performed.
     */
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.#raise("unknown action");
      }
      this.#raise("action attribute is missing");
    }
    /**
     * Gets the target elements which the template will be rendered to.
     */
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.#raise("target or targets attribute is missing");
      }
    }
    /**
     * Gets the contents of the main `<template>`.
     */
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    /**
     * Gets the main `<template>` used for rendering
     */
    get templateElement() {
      if (this.firstElementChild === null) {
        const template = this.ownerDocument.createElement("template");
        this.appendChild(template);
        return template;
      } else if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.#raise("first child element must be a <template> element");
    }
    /**
     * Gets the current action.
     */
    get action() {
      return this.getAttribute("action");
    }
    /**
     * Gets the current target (an element ID) to which the result will
     * be rendered.
     */
    get target() {
      return this.getAttribute("target");
    }
    /**
     * Gets the current "targets" selector (a CSS selector)
     */
    get targets() {
      return this.getAttribute("targets");
    }
    /**
     * Reads the request-id attribute
     */
    get requestId() {
      return this.getAttribute("request-id");
    }
    #raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", {
        bubbles: true,
        cancelable: true,
        detail: { newStream: this, render: _StreamElement.renderElement }
      });
    }
    get targetElementsById() {
      const element = this.ownerDocument?.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      const elements = this.ownerDocument?.querySelectorAll(this.targets);
      if (elements.length !== 0) {
        return Array.prototype.slice.call(elements);
      } else {
        return [];
      }
    }
  };
  var StreamSourceElement = class extends HTMLElement {
    streamSource = null;
    connectedCallback() {
      this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
      connectStreamSource(this.streamSource);
    }
    disconnectedCallback() {
      if (this.streamSource) {
        this.streamSource.close();
        disconnectStreamSource(this.streamSource);
      }
    }
    get src() {
      return this.getAttribute("src") || "";
    }
  };
  FrameElement.delegateConstructor = FrameController;
  if (customElements.get("turbo-frame") === void 0) {
    customElements.define("turbo-frame", FrameElement);
  }
  if (customElements.get("turbo-stream") === void 0) {
    customElements.define("turbo-stream", StreamElement);
  }
  if (customElements.get("turbo-stream-source") === void 0) {
    customElements.define("turbo-stream-source", StreamSourceElement);
  }
  (() => {
    let element = document.currentScript;
    if (!element) return;
    if (element.hasAttribute("data-turbo-suppress-warning")) return;
    element = element.parentElement;
    while (element) {
      if (element == document.body) {
        return console.warn(
          unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your application’s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ——
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `,
          element.outerHTML
        );
      }
      element = element.parentElement;
    }
  })();
  window.Turbo = { ...Turbo2, StreamActions };
  start();

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer2;
  async function getConsumer() {
    return consumer2 || setConsumer(createConsumer2().then(setConsumer));
  }
  function setConsumer(newConsumer) {
    return consumer2 = newConsumer;
  }
  async function createConsumer2() {
    const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer3();
  }
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
  function walk(obj) {
    if (!obj || typeof obj !== "object") return obj;
    if (obj instanceof Date || obj instanceof RegExp) return obj;
    if (Array.isArray(obj)) return obj.map(walk);
    return Object.keys(obj).reduce(function(acc, key) {
      var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m3, x3) {
        return "_" + x3.toLowerCase();
      });
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    static observedAttributes = ["channel", "signed-stream-name"];
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, {
        received: this.dispatchMessageEvent.bind(this),
        connected: this.subscriptionConnected.bind(this),
        disconnected: this.subscriptionDisconnected.bind(this)
      });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription) this.subscription.unsubscribe();
      this.subscriptionDisconnected();
    }
    attributeChangedCallback() {
      if (this.subscription) {
        this.disconnectedCallback();
        this.connectedCallback();
      }
    }
    dispatchMessageEvent(data2) {
      const event = new MessageEvent("message", { data: data2 });
      return this.dispatchEvent(event);
    }
    subscriptionConnected() {
      this.setAttribute("connected", "");
    }
    subscriptionDisconnected() {
      this.removeAttribute("connected");
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
    }
  };
  if (customElements.get("turbo-cable-stream-source") === void 0) {
    customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
  function encodeMethodIntoRequestBody(event) {
    if (event.target instanceof HTMLFormElement) {
      const { target: form, detail: { fetchOptions } } = event;
      form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter: submitter2 } } }) => {
        const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
        const method = determineFetchMethod(submitter2, body, form);
        if (!/get/i.test(method)) {
          if (/post/i.test(method)) {
            body.delete("_method");
          } else {
            body.set("_method", method);
          }
          fetchOptions.method = "post";
        }
      }, { once: true });
    }
  }
  function determineFetchMethod(submitter2, body, form) {
    const formMethod = determineFormMethod(submitter2);
    const overrideMethod = body.get("_method");
    const method = form.getAttribute("method") || "get";
    if (typeof formMethod == "string") {
      return formMethod;
    } else if (typeof overrideMethod == "string") {
      return overrideMethod;
    } else {
      return method;
    }
  }
  function determineFormMethod(submitter2) {
    if (submitter2 instanceof HTMLButtonElement || submitter2 instanceof HTMLInputElement) {
      if (submitter2.name === "_method") {
        return submitter2.value;
      } else if (submitter2.hasAttribute("formmethod")) {
        return submitter2.formMethod;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  function isBodyInit(body) {
    return body instanceof FormData || body instanceof URLSearchParams;
  }

  // node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
  window.Turbo = turbo_es2017_esm_exports;
  addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

  // node_modules/idiomorph/dist/idiomorph.esm.js
  var Idiomorph2 = function() {
    "use strict";
    let EMPTY_SET = /* @__PURE__ */ new Set();
    let defaults5 = {
      morphStyle: "outerHTML",
      callbacks: {
        beforeNodeAdded: noOp,
        afterNodeAdded: noOp,
        beforeNodeMorphed: noOp,
        afterNodeMorphed: noOp,
        beforeNodeRemoved: noOp,
        afterNodeRemoved: noOp,
        beforeAttributeUpdated: noOp
      },
      head: {
        style: "merge",
        shouldPreserve: function(elt) {
          return elt.getAttribute("im-preserve") === "true";
        },
        shouldReAppend: function(elt) {
          return elt.getAttribute("im-re-append") === "true";
        },
        shouldRemove: noOp,
        afterHeadMorphed: noOp
      }
    };
    function morph(oldNode, newContent, config2 = {}) {
      if (oldNode instanceof Document) {
        oldNode = oldNode.documentElement;
      }
      if (typeof newContent === "string") {
        newContent = parseContent(newContent);
      }
      let normalizedContent = normalizeContent(newContent);
      let ctx2 = createMorphContext(oldNode, normalizedContent, config2);
      return morphNormalizedContent(oldNode, normalizedContent, ctx2);
    }
    function morphNormalizedContent(oldNode, normalizedNewContent, ctx2) {
      if (ctx2.head.block) {
        let oldHead = oldNode.querySelector("head");
        let newHead = normalizedNewContent.querySelector("head");
        if (oldHead && newHead) {
          let promises = handleHeadElement(newHead, oldHead, ctx2);
          Promise.all(promises).then(function() {
            morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx2, {
              head: {
                block: false,
                ignore: true
              }
            }));
          });
          return;
        }
      }
      if (ctx2.morphStyle === "innerHTML") {
        morphChildren2(normalizedNewContent, oldNode, ctx2);
        return oldNode.children;
      } else if (ctx2.morphStyle === "outerHTML" || ctx2.morphStyle == null) {
        let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx2);
        let previousSibling = bestMatch?.previousSibling;
        let nextSibling = bestMatch?.nextSibling;
        let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx2);
        if (bestMatch) {
          return insertSiblings(previousSibling, morphedNode, nextSibling);
        } else {
          return [];
        }
      } else {
        throw "Do not understand how to morph style " + ctx2.morphStyle;
      }
    }
    function ignoreValueOfActiveElement(possibleActiveElement, ctx2) {
      return ctx2.ignoreActiveValue && possibleActiveElement === document.activeElement;
    }
    function morphOldNodeTo(oldNode, newContent, ctx2) {
      if (ctx2.ignoreActive && oldNode === document.activeElement) {
      } else if (newContent == null) {
        if (ctx2.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        oldNode.remove();
        ctx2.callbacks.afterNodeRemoved(oldNode);
        return null;
      } else if (!isSoftMatch(oldNode, newContent)) {
        if (ctx2.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        if (ctx2.callbacks.beforeNodeAdded(newContent) === false) return oldNode;
        oldNode.parentElement.replaceChild(newContent, oldNode);
        ctx2.callbacks.afterNodeAdded(newContent);
        ctx2.callbacks.afterNodeRemoved(oldNode);
        return newContent;
      } else {
        if (ctx2.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;
        if (oldNode instanceof HTMLHeadElement && ctx2.head.ignore) {
        } else if (oldNode instanceof HTMLHeadElement && ctx2.head.style !== "morph") {
          handleHeadElement(newContent, oldNode, ctx2);
        } else {
          syncNodeFrom(newContent, oldNode, ctx2);
          if (!ignoreValueOfActiveElement(oldNode, ctx2)) {
            morphChildren2(newContent, oldNode, ctx2);
          }
        }
        ctx2.callbacks.afterNodeMorphed(oldNode, newContent);
        return oldNode;
      }
    }
    function morphChildren2(newParent, oldParent, ctx2) {
      let nextNewChild = newParent.firstChild;
      let insertionPoint = oldParent.firstChild;
      let newChild;
      while (nextNewChild) {
        newChild = nextNewChild;
        nextNewChild = newChild.nextSibling;
        if (insertionPoint == null) {
          if (ctx2.callbacks.beforeNodeAdded(newChild) === false) return;
          oldParent.appendChild(newChild);
          ctx2.callbacks.afterNodeAdded(newChild);
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        if (isIdSetMatch(newChild, insertionPoint, ctx2)) {
          morphOldNodeTo(insertionPoint, newChild, ctx2);
          insertionPoint = insertionPoint.nextSibling;
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx2);
        if (idSetMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx2);
          morphOldNodeTo(idSetMatch, newChild, ctx2);
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx2);
        if (softMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx2);
          morphOldNodeTo(softMatch, newChild, ctx2);
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        if (ctx2.callbacks.beforeNodeAdded(newChild) === false) return;
        oldParent.insertBefore(newChild, insertionPoint);
        ctx2.callbacks.afterNodeAdded(newChild);
        removeIdsFromConsideration(ctx2, newChild);
      }
      while (insertionPoint !== null) {
        let tempNode = insertionPoint;
        insertionPoint = insertionPoint.nextSibling;
        removeNode(tempNode, ctx2);
      }
    }
    function ignoreAttribute(attr2, to, updateType, ctx2) {
      if (attr2 === "value" && ctx2.ignoreActiveValue && to === document.activeElement) {
        return true;
      }
      return ctx2.callbacks.beforeAttributeUpdated(attr2, to, updateType) === false;
    }
    function syncNodeFrom(from, to, ctx2) {
      let type = from.nodeType;
      if (type === 1) {
        const fromAttributes = from.attributes;
        const toAttributes = to.attributes;
        for (const fromAttribute of fromAttributes) {
          if (ignoreAttribute(fromAttribute.name, to, "update", ctx2)) {
            continue;
          }
          if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {
            to.setAttribute(fromAttribute.name, fromAttribute.value);
          }
        }
        for (let i = toAttributes.length - 1; 0 <= i; i--) {
          const toAttribute = toAttributes[i];
          if (ignoreAttribute(toAttribute.name, to, "remove", ctx2)) {
            continue;
          }
          if (!from.hasAttribute(toAttribute.name)) {
            to.removeAttribute(toAttribute.name);
          }
        }
      }
      if (type === 8 || type === 3) {
        if (to.nodeValue !== from.nodeValue) {
          to.nodeValue = from.nodeValue;
        }
      }
      if (!ignoreValueOfActiveElement(to, ctx2)) {
        syncInputValue(from, to, ctx2);
      }
    }
    function syncBooleanAttribute(from, to, attributeName, ctx2) {
      if (from[attributeName] !== to[attributeName]) {
        let ignoreUpdate = ignoreAttribute(attributeName, to, "update", ctx2);
        if (!ignoreUpdate) {
          to[attributeName] = from[attributeName];
        }
        if (from[attributeName]) {
          if (!ignoreUpdate) {
            to.setAttribute(attributeName, from[attributeName]);
          }
        } else {
          if (!ignoreAttribute(attributeName, to, "remove", ctx2)) {
            to.removeAttribute(attributeName);
          }
        }
      }
    }
    function syncInputValue(from, to, ctx2) {
      if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== "file") {
        let fromValue = from.value;
        let toValue = to.value;
        syncBooleanAttribute(from, to, "checked", ctx2);
        syncBooleanAttribute(from, to, "disabled", ctx2);
        if (!from.hasAttribute("value")) {
          if (!ignoreAttribute("value", to, "remove", ctx2)) {
            to.value = "";
            to.removeAttribute("value");
          }
        } else if (fromValue !== toValue) {
          if (!ignoreAttribute("value", to, "update", ctx2)) {
            to.setAttribute("value", fromValue);
            to.value = fromValue;
          }
        }
      } else if (from instanceof HTMLOptionElement) {
        syncBooleanAttribute(from, to, "selected", ctx2);
      } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {
        let fromValue = from.value;
        let toValue = to.value;
        if (ignoreAttribute("value", to, "update", ctx2)) {
          return;
        }
        if (fromValue !== toValue) {
          to.value = fromValue;
        }
        if (to.firstChild && to.firstChild.nodeValue !== fromValue) {
          to.firstChild.nodeValue = fromValue;
        }
      }
    }
    function handleHeadElement(newHeadTag, currentHead, ctx2) {
      let added = [];
      let removed = [];
      let preserved = [];
      let nodesToAppend = [];
      let headMergeStyle = ctx2.head.style;
      let srcToNewHeadNodes = /* @__PURE__ */ new Map();
      for (const newHeadChild of newHeadTag.children) {
        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
      }
      for (const currentHeadElt of currentHead.children) {
        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
        let isReAppended = ctx2.head.shouldReAppend(currentHeadElt);
        let isPreserved = ctx2.head.shouldPreserve(currentHeadElt);
        if (inNewContent || isPreserved) {
          if (isReAppended) {
            removed.push(currentHeadElt);
          } else {
            srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
            preserved.push(currentHeadElt);
          }
        } else {
          if (headMergeStyle === "append") {
            if (isReAppended) {
              removed.push(currentHeadElt);
              nodesToAppend.push(currentHeadElt);
            }
          } else {
            if (ctx2.head.shouldRemove(currentHeadElt) !== false) {
              removed.push(currentHeadElt);
            }
          }
        }
      }
      nodesToAppend.push(...srcToNewHeadNodes.values());
      log2("to append: ", nodesToAppend);
      let promises = [];
      for (const newNode of nodesToAppend) {
        log2("adding: ", newNode);
        let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
        log2(newElt);
        if (ctx2.callbacks.beforeNodeAdded(newElt) !== false) {
          if (newElt.href || newElt.src) {
            let resolve = null;
            let promise = new Promise(function(_resolve) {
              resolve = _resolve;
            });
            newElt.addEventListener("load", function() {
              resolve();
            });
            promises.push(promise);
          }
          currentHead.appendChild(newElt);
          ctx2.callbacks.afterNodeAdded(newElt);
          added.push(newElt);
        }
      }
      for (const removedElement of removed) {
        if (ctx2.callbacks.beforeNodeRemoved(removedElement) !== false) {
          currentHead.removeChild(removedElement);
          ctx2.callbacks.afterNodeRemoved(removedElement);
        }
      }
      ctx2.head.afterHeadMorphed(currentHead, { added, kept: preserved, removed });
      return promises;
    }
    function log2() {
    }
    function noOp() {
    }
    function mergeDefaults(config2) {
      let finalConfig = {};
      Object.assign(finalConfig, defaults5);
      Object.assign(finalConfig, config2);
      finalConfig.callbacks = {};
      Object.assign(finalConfig.callbacks, defaults5.callbacks);
      Object.assign(finalConfig.callbacks, config2.callbacks);
      finalConfig.head = {};
      Object.assign(finalConfig.head, defaults5.head);
      Object.assign(finalConfig.head, config2.head);
      return finalConfig;
    }
    function createMorphContext(oldNode, newContent, config2) {
      config2 = mergeDefaults(config2);
      return {
        target: oldNode,
        newContent,
        config: config2,
        morphStyle: config2.morphStyle,
        ignoreActive: config2.ignoreActive,
        ignoreActiveValue: config2.ignoreActiveValue,
        idMap: createIdMap(oldNode, newContent),
        deadIds: /* @__PURE__ */ new Set(),
        callbacks: config2.callbacks,
        head: config2.head
      };
    }
    function isIdSetMatch(node1, node2, ctx2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {
        if (node1.id !== "" && node1.id === node2.id) {
          return true;
        } else {
          return getIdIntersectionCount(ctx2, node1, node2) > 0;
        }
      }
      return false;
    }
    function isSoftMatch(node1, node2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;
    }
    function removeNodesBetween(startInclusive, endExclusive, ctx2) {
      while (startInclusive !== endExclusive) {
        let tempNode = startInclusive;
        startInclusive = startInclusive.nextSibling;
        removeNode(tempNode, ctx2);
      }
      removeIdsFromConsideration(ctx2, endExclusive);
      return endExclusive.nextSibling;
    }
    function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx2) {
      let newChildPotentialIdCount = getIdIntersectionCount(ctx2, newChild, oldParent);
      let potentialMatch = null;
      if (newChildPotentialIdCount > 0) {
        let potentialMatch2 = insertionPoint;
        let otherMatchCount = 0;
        while (potentialMatch2 != null) {
          if (isIdSetMatch(newChild, potentialMatch2, ctx2)) {
            return potentialMatch2;
          }
          otherMatchCount += getIdIntersectionCount(ctx2, potentialMatch2, newContent);
          if (otherMatchCount > newChildPotentialIdCount) {
            return null;
          }
          potentialMatch2 = potentialMatch2.nextSibling;
        }
      }
      return potentialMatch;
    }
    function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx2) {
      let potentialSoftMatch = insertionPoint;
      let nextSibling = newChild.nextSibling;
      let siblingSoftMatchCount = 0;
      while (potentialSoftMatch != null) {
        if (getIdIntersectionCount(ctx2, potentialSoftMatch, newContent) > 0) {
          return null;
        }
        if (isSoftMatch(newChild, potentialSoftMatch)) {
          return potentialSoftMatch;
        }
        if (isSoftMatch(nextSibling, potentialSoftMatch)) {
          siblingSoftMatchCount++;
          nextSibling = nextSibling.nextSibling;
          if (siblingSoftMatchCount >= 2) {
            return null;
          }
        }
        potentialSoftMatch = potentialSoftMatch.nextSibling;
      }
      return potentialSoftMatch;
    }
    function parseContent(newContent) {
      let parser2 = new DOMParser();
      let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
      if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
        let content = parser2.parseFromString(newContent, "text/html");
        if (contentWithSvgsRemoved.match(/<\/html>/)) {
          content.generatedByIdiomorph = true;
          return content;
        } else {
          let htmlElement = content.firstChild;
          if (htmlElement) {
            htmlElement.generatedByIdiomorph = true;
            return htmlElement;
          } else {
            return null;
          }
        }
      } else {
        let responseDoc = parser2.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
        let content = responseDoc.body.querySelector("template").content;
        content.generatedByIdiomorph = true;
        return content;
      }
    }
    function normalizeContent(newContent) {
      if (newContent == null) {
        const dummyParent = document.createElement("div");
        return dummyParent;
      } else if (newContent.generatedByIdiomorph) {
        return newContent;
      } else if (newContent instanceof Node) {
        const dummyParent = document.createElement("div");
        dummyParent.append(newContent);
        return dummyParent;
      } else {
        const dummyParent = document.createElement("div");
        for (const elt of [...newContent]) {
          dummyParent.append(elt);
        }
        return dummyParent;
      }
    }
    function insertSiblings(previousSibling, morphedNode, nextSibling) {
      let stack = [];
      let added = [];
      while (previousSibling != null) {
        stack.push(previousSibling);
        previousSibling = previousSibling.previousSibling;
      }
      while (stack.length > 0) {
        let node = stack.pop();
        added.push(node);
        morphedNode.parentElement.insertBefore(node, morphedNode);
      }
      added.push(morphedNode);
      while (nextSibling != null) {
        stack.push(nextSibling);
        added.push(nextSibling);
        nextSibling = nextSibling.nextSibling;
      }
      while (stack.length > 0) {
        morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);
      }
      return added;
    }
    function findBestNodeMatch(newContent, oldNode, ctx2) {
      let currentElement;
      currentElement = newContent.firstChild;
      let bestElement = currentElement;
      let score2 = 0;
      while (currentElement) {
        let newScore = scoreElement(currentElement, oldNode, ctx2);
        if (newScore > score2) {
          bestElement = currentElement;
          score2 = newScore;
        }
        currentElement = currentElement.nextSibling;
      }
      return bestElement;
    }
    function scoreElement(node1, node2, ctx2) {
      if (isSoftMatch(node1, node2)) {
        return 0.5 + getIdIntersectionCount(ctx2, node1, node2);
      }
      return 0;
    }
    function removeNode(tempNode, ctx2) {
      removeIdsFromConsideration(ctx2, tempNode);
      if (ctx2.callbacks.beforeNodeRemoved(tempNode) === false) return;
      tempNode.remove();
      ctx2.callbacks.afterNodeRemoved(tempNode);
    }
    function isIdInConsideration(ctx2, id5) {
      return !ctx2.deadIds.has(id5);
    }
    function idIsWithinNode(ctx2, id5, targetNode) {
      let idSet = ctx2.idMap.get(targetNode) || EMPTY_SET;
      return idSet.has(id5);
    }
    function removeIdsFromConsideration(ctx2, node) {
      let idSet = ctx2.idMap.get(node) || EMPTY_SET;
      for (const id5 of idSet) {
        ctx2.deadIds.add(id5);
      }
    }
    function getIdIntersectionCount(ctx2, node1, node2) {
      let sourceSet = ctx2.idMap.get(node1) || EMPTY_SET;
      let matchCount = 0;
      for (const id5 of sourceSet) {
        if (isIdInConsideration(ctx2, id5) && idIsWithinNode(ctx2, id5, node2)) {
          ++matchCount;
        }
      }
      return matchCount;
    }
    function populateIdMapForNode(node, idMap) {
      let nodeParent = node.parentElement;
      let idElements = node.querySelectorAll("[id]");
      for (const elt of idElements) {
        let current = elt;
        while (current !== nodeParent && current != null) {
          let idSet = idMap.get(current);
          if (idSet == null) {
            idSet = /* @__PURE__ */ new Set();
            idMap.set(current, idSet);
          }
          idSet.add(elt.id);
          current = current.parentElement;
        }
      }
    }
    function createIdMap(oldContent, newContent) {
      let idMap = /* @__PURE__ */ new Map();
      populateIdMapForNode(oldContent, idMap);
      populateIdMapForNode(newContent, idMap);
      return idMap;
    }
    return {
      morph,
      defaults: defaults5
    };
  }();

  // engine/rails_design/app/javascripts/rails_design/dataset.js
  DOMStringMap.prototype.add = function(name2, value2) {
    if (typeof this[name2] === "string") {
      const values = this[name2].split(" ");
      if (!values.includes(value2)) {
        values.push(value2);
      }
      this[name2] = values.join(" ");
    } else {
      this[name2] = value2;
    }
  };
  DOMStringMap.prototype.remove = function(name2, value2) {
    if (typeof this[name2] === "string") {
      const values = this[name2].split(" ");
      const index4 = values.indexOf(value2);
      if (index4 > -1) {
        values.splice(index4, 1);
      }
      this[name2] = values.join(" ");
    }
  };
  DOMStringMap.prototype.replace = function(name2, old_value, new_value) {
    if (typeof this[name2] === "string") {
      const values = this[name2].split(" ");
      const reg = new RegExp(old_value);
      values.forEach((ele, index4) => {
        if (reg.test(ele)) {
          values[index4] = String(ele).replace(old_value, new_value);
        }
      });
      this[name2] = values.join(" ");
    }
  };

  // engine/rails_design/app/javascripts/rails_design/utils.js
  window.utils = {
    xx: (date) => {
      const format3 = new Intl.DateTimeFormat("zh-Hans-CN", {
        calendar: "chinese",
        timeZone: "Asia/Shanghai"
      });
      format3.format(date);
    }
  };

  // engine/rails_design/app/javascripts/rails_design/weixin_script.js
  var weixin_fetch2 = function({ url = location.href, success, ...args } = {}) {
    if (typeof wx === "undefined") {
      return;
    }
    fetch("/wechat/js", {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ url })
    }).then((response) => {
      return response.json();
    }).then((body) => {
      let config2 = {
        debug: body["debug"],
        appId: body["appid"],
        timestamp: body["timestamp"],
        nonceStr: body["noncestr"],
        signature: body["signature"],
        jsApiList: body["apis"],
        openTagList: body["open_tags"]
      };
      if (body["beta"]) {
        Object.assign(config2, { beta: true });
      }
      if (body["debug"]) {
        alert("body is:" + JSON.stringify(config2));
      }
      wx.config(config2);
      wx.ready(() => {
        if (body["debug"]) {
          alert("wx.config ready");
        } else {
          console.debug("ready, ok");
        }
        if (success) {
          success(args);
        }
      });
      wx.error((res) => {
        if (body["debug"]) {
          alert("wx.config: " + JSON.stringify(res) + `
location: ${location.href}`);
        } else {
          console.debug("wx.config:", res);
        }
      });
    });
  };
  window.weixin_fetch = weixin_fetch2;
  var weixin_script = document.getElementById("weixin_script");
  var wxwork_script = document.getElementById("wxwork_script");
  if (weixin_script && wxwork_script) {
    wxwork_script.addEventListener("load", (event) => {
      wxwork_fetch();
    });
  } else if (weixin_script) {
    weixin_script.addEventListener("load", (event) => {
      weixin_fetch2();
    });
  }

  // engine/rails_design/app/javascripts/rails_design/wxwork_script.js
  var wxwork_fetch2 = function({ url = location.href, success, ...args } = {}) {
    weixin_fetch({
      url,
      success: () => {
        fetch("/wechat/agent_js", {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ url })
        }).then((response) => {
          return response.json();
        }).then((body) => {
          wx.agentConfig({
            corpid: body["corpid"],
            agentid: body["agentid"],
            timestamp: body["timestamp"],
            nonceStr: body["noncestr"],
            signature: body["signature"],
            jsApiList: body["apis"],
            success: (res) => {
              if (body["debug"]) {
                alert("wx.agentConfig success" + JSON.stringify(res));
              } else {
                console.debug("wx.agentConfig success", JSON.stringify(res));
              }
              if (success) {
                success(args);
              }
            },
            fail: (res) => {
              new Error("wx.agentConfig fail " + JSON.stringify(res));
            }
          });
        });
      }
    });
  };
  window.wxwork_fetch = wxwork_fetch2;

  // node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent);
        }
      }
    }
    hasBindings() {
      return this.unorderedBindings.size > 0;
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left2, right2) => {
        const leftIndex = left2.index, rightIndex = right2.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map3) => listeners.concat(Array.from(map3.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
      if (clearEventListeners)
        this.clearEventListenersForBinding(binding);
    }
    handleError(error4, message, detail = {}) {
      this.application.handleError(error4, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
      const eventListener = this.fetchEventListenerForBinding(binding);
      if (!eventListener.hasBindings()) {
        eventListener.disconnect();
        this.removeMappedEventListenerFor(binding);
      }
    }
    removeMappedEventListenerFor(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      eventListenerMap.delete(cacheKey);
      if (eventListenerMap.size == 0)
        this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts.join(":");
    }
  };
  var defaultActionDescriptorFilters = {
    stop({ event, value: value2 }) {
      if (value2)
        event.stopPropagation();
      return true;
    },
    prevent({ event, value: value2 }) {
      if (value2)
        event.preventDefault();
      return true;
    },
    self({ event, value: value2, element }) {
      if (value2) {
        return element === event.target;
      } else {
        return true;
      }
    }
  };
  var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches2 = source.match(descriptorPattern) || [];
    let eventName = matches2[2];
    let keyFilter = matches2[3];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
      eventName += `.${keyFilter}`;
      keyFilter = "";
    }
    return {
      eventTarget: parseEventTarget(matches2[4]),
      eventName,
      eventOptions: matches2[7] ? parseEventOptions(matches2[7]) : {},
      identifier: matches2[5],
      methodName: matches2[6],
      keyFilter: matches2[1] || keyFilter
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token2) => Object.assign(options, { [token2.replace(/^!/, "")]: !/^!/.test(token2) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value2) {
    return value2.replace(/(?:[_-])([a-z0-9])/g, (_2, char) => char.toUpperCase());
  }
  function namespaceCamelize(value2) {
    return camelize(value2.replace(/--/g, "-").replace(/__/g, "_"));
  }
  function capitalize(value2) {
    return value2.charAt(0).toUpperCase() + value2.slice(1);
  }
  function dasherize(value2) {
    return value2.replace(/([A-Z])/g, (_2, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value2) {
    return value2.match(/[^\s]+/g) || [];
  }
  function isSomething(object) {
    return object !== null && object !== void 0;
  }
  function hasProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  var allModifiers = ["meta", "ctrl", "alt", "shift"];
  var Action = class {
    constructor(element, index4, descriptor, schema) {
      this.element = element;
      this.index = index4;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
      this.keyFilter = descriptor.keyFilter || "";
      this.schema = schema;
    }
    static forToken(token2, schema) {
      return new this(token2.element, token2.index, parseActionDescriptorString(token2.content), schema);
    }
    toString() {
      const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
      const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    shouldIgnoreKeyboardEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = this.keyFilter.split("+");
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
      if (!standardFilter) {
        return false;
      }
      if (!hasProperty(this.keyMappings, standardFilter)) {
        error(`contains unknown key filter: ${this.keyFilter}`);
      }
      return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
    }
    shouldIgnoreMouseEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = [this.keyFilter];
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      return false;
    }
    get params() {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
      for (const { name: name2, value: value2 } of Array.from(this.element.attributes)) {
        const match2 = name2.match(pattern);
        const key = match2 && match2[1];
        if (key) {
          params[camelize(key)] = typecast(value2);
        }
      }
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
      return this.schema.keyMappings;
    }
    keyFilterDissatisfied(event, filters) {
      const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
      return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
    }
  };
  var defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e3) => e3.getAttribute("type") == "submit" ? "click" : "input",
    select: () => "change",
    textarea: () => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value2) {
    try {
      return JSON.parse(value2);
    } catch (o_O) {
      return value2;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      const actionEvent = this.prepareActionEvent(event);
      if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
        this.invokeWithEvent(actionEvent);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event) {
      const { element } = this.action;
      const { actionDescriptorFilters } = this.context.application;
      const { controller } = this.context;
      let passes = true;
      for (const [name2, value2] of Object.entries(this.eventOptions)) {
        if (name2 in actionDescriptorFilters) {
          const filter2 = actionDescriptorFilters[name2];
          passes = passes && filter2({ name: name2, value: value2, event, element, controller });
        } else {
          continue;
        }
      }
      return passes;
    }
    prepareActionEvent(event) {
      return Object.assign(event, { params: this.action.params });
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        this.method.call(this.controller, event);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error4) {
        const { identifier, controller, element, index: index4 } = this;
        const detail = { identifier, controller, element, index: index4, event };
        this.context.handleError(error4, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
        return false;
      }
      if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
        return false;
      }
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches2 = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches2.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches2)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(element, attributeName) {
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match2 = this.matchElement(tree) ? [tree] : [];
      const matches2 = Array.from(tree.querySelectorAll(this.selector));
      return match2.concat(matches2);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  function add(map3, key, value2) {
    fetch2(map3, key).add(value2);
  }
  function del(map3, key, value2) {
    fetch2(map3, key).delete(value2);
    prune(map3, key);
  }
  function fetch2(map3, key) {
    let values = map3.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map3.set(key, values);
    }
    return values;
  }
  function prune(map3, key) {
    const values = map3.get(key);
    if (values != null && values.size == 0) {
      map3.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values, set8) => values.concat(Array.from(set8)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size2, set8) => size2 + set8.size, 0);
    }
    add(key, value2) {
      add(this.valuesByKey, key, value2);
    }
    delete(key, value2) {
      del(this.valuesByKey, key, value2);
    }
    has(key, value2) {
      const values = this.valuesByKey.get(key);
      return values != null && values.has(value2);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value2) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set8) => set8.has(value2));
    }
    getValuesForKey(key) {
      const values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value2) {
      return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value2)).map(([key, _values]) => key);
    }
  };
  var SelectorObserver = class {
    constructor(element, selector, delegate, details) {
      this._selector = selector;
      this.details = details;
      this.elementObserver = new ElementObserver(element, this);
      this.delegate = delegate;
      this.matchesByElement = new Multimap();
    }
    get started() {
      return this.elementObserver.started;
    }
    get selector() {
      return this._selector;
    }
    set selector(selector) {
      this._selector = selector;
      this.refresh();
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get element() {
      return this.elementObserver.element;
    }
    matchElement(element) {
      const { selector } = this;
      if (selector) {
        const matches2 = element.matches(selector);
        if (this.delegate.selectorMatchElement) {
          return matches2 && this.delegate.selectorMatchElement(element, this.details);
        }
        return matches2;
      } else {
        return false;
      }
    }
    matchElementsInTree(tree) {
      const { selector } = this;
      if (selector) {
        const match2 = this.matchElement(tree) ? [tree] : [];
        const matches2 = Array.from(tree.querySelectorAll(selector)).filter((match3) => this.matchElement(match3));
        return match2.concat(matches2);
      } else {
        return [];
      }
    }
    elementMatched(element) {
      const { selector } = this;
      if (selector) {
        this.selectorMatched(element, selector);
      }
    }
    elementUnmatched(element) {
      const selectors = this.matchesByElement.getKeysForValue(element);
      for (const selector of selectors) {
        this.selectorUnmatched(element, selector);
      }
    }
    elementAttributeChanged(element, _attributeName) {
      const { selector } = this;
      if (selector) {
        const matches2 = this.matchElement(element);
        const matchedBefore = this.matchesByElement.has(selector, element);
        if (matches2 && !matchedBefore) {
          this.selectorMatched(element, selector);
        } else if (!matches2 && matchedBefore) {
          this.selectorUnmatched(element, selector);
        }
      }
    }
    selectorMatched(element, selector) {
      this.delegate.selectorMatched(element, selector, this.details);
      this.matchesByElement.add(selector, element);
    }
    selectorUnmatched(element, selector) {
      this.delegate.selectorUnmatched(element, selector, this.details);
      this.matchesByElement.delete(selector, element);
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value2 = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value2) {
          this.stringMapValueChanged(value2, key, oldValue);
        }
        if (value2 == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value2);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value2, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value2, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback) {
      this.attributeObserver.pause(callback);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens4) {
      tokens4.forEach((token2) => this.tokenMatched(token2));
    }
    tokensUnmatched(tokens4) {
      tokens4.forEach((token2) => this.tokenUnmatched(token2));
    }
    tokenMatched(token2) {
      this.delegate.tokenMatched(token2);
      this.tokensByElement.add(token2.element, token2);
    }
    tokenUnmatched(token2) {
      this.delegate.tokenUnmatched(token2);
      this.tokensByElement.delete(token2.element, token2);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index4) => ({ element, attributeName, content, index: index4 }));
  }
  function zip(left2, right2) {
    const length5 = Math.max(left2.length, right2.length);
    return Array.from({ length: length5 }, (_2, index4) => [left2[index4], right2[index4]]);
  }
  function tokensAreEqual(left2, right2) {
    return left2 && right2 && left2.index == right2.index && left2.content == right2.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token2) {
      const { element } = token2;
      const { value: value2 } = this.fetchParseResultForToken(token2);
      if (value2) {
        this.fetchValuesByTokenForElement(element).set(token2, value2);
        this.delegate.elementMatchedValue(element, value2);
      }
    }
    tokenUnmatched(token2) {
      const { element } = token2;
      const { value: value2 } = this.fetchParseResultForToken(token2);
      if (value2) {
        this.fetchValuesByTokenForElement(element).delete(token2);
        this.delegate.elementUnmatchedValue(element, value2);
      }
    }
    fetchParseResultForToken(token2) {
      let parseResult = this.parseResultsByToken.get(token2);
      if (!parseResult) {
        parseResult = this.parseToken(token2);
        this.parseResultsByToken.set(token2, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token2) {
      try {
        const value2 = this.delegate.parseValueForToken(token2);
        return { value: value2 };
      } catch (error4) {
        return { error: error4 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token2) {
      const action = Action.forToken(token2, this.schema);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
      this.stringMapObserver.start();
      this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value2, name2, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name2];
      if (value2 === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name2, value2, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name: name2, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name2, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name2, rawValue, rawOldValue) {
      const changedMethodName = `${name2}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name2];
        try {
          const value2 = descriptor.reader(rawValue);
          let oldValue = rawOldValue;
          if (rawOldValue) {
            oldValue = descriptor.reader(rawOldValue);
          }
          changedMethod.call(this.receiver, value2, oldValue);
        } catch (error4) {
          if (error4 instanceof TypeError) {
            error4.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error4.message}`;
          }
          throw error4;
        }
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors[descriptor.name] = descriptor;
      });
      return descriptors;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name2 }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name2);
      }
    }
    tokenUnmatched({ element, content: name2 }) {
      this.disconnectTarget(element, name2);
    }
    connectTarget(element, name2) {
      var _a;
      if (!this.targetsByName.has(name2, element)) {
        this.targetsByName.add(name2, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name2));
      }
    }
    disconnectTarget(element, name2) {
      var _a;
      if (this.targetsByName.has(name2, element)) {
        this.targetsByName.delete(name2, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name2));
      }
    }
    disconnectAllTargets() {
      for (const name2 of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name2)) {
          this.disconnectTarget(element, name2);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name2) => values.add(name2));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  var OutletObserver = class {
    constructor(context, delegate) {
      this.started = false;
      this.context = context;
      this.delegate = delegate;
      this.outletsByName = new Multimap();
      this.outletElementsByName = new Multimap();
      this.selectorObserverMap = /* @__PURE__ */ new Map();
      this.attributeObserverMap = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.started) {
        this.outletDefinitions.forEach((outletName) => {
          this.setupSelectorObserverForOutlet(outletName);
          this.setupAttributeObserverForOutlet(outletName);
        });
        this.started = true;
        this.dependentContexts.forEach((context) => context.refresh());
      }
    }
    refresh() {
      this.selectorObserverMap.forEach((observer) => observer.refresh());
      this.attributeObserverMap.forEach((observer) => observer.refresh());
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.disconnectAllOutlets();
        this.stopSelectorObservers();
        this.stopAttributeObservers();
      }
    }
    stopSelectorObservers() {
      if (this.selectorObserverMap.size > 0) {
        this.selectorObserverMap.forEach((observer) => observer.stop());
        this.selectorObserverMap.clear();
      }
    }
    stopAttributeObservers() {
      if (this.attributeObserverMap.size > 0) {
        this.attributeObserverMap.forEach((observer) => observer.stop());
        this.attributeObserverMap.clear();
      }
    }
    selectorMatched(element, _selector, { outletName }) {
      const outlet = this.getOutlet(element, outletName);
      if (outlet) {
        this.connectOutlet(outlet, element, outletName);
      }
    }
    selectorUnmatched(element, _selector, { outletName }) {
      const outlet = this.getOutletFromMap(element, outletName);
      if (outlet) {
        this.disconnectOutlet(outlet, element, outletName);
      }
    }
    selectorMatchElement(element, { outletName }) {
      const selector = this.selector(outletName);
      const hasOutlet = this.hasOutlet(element, outletName);
      const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
      if (selector) {
        return hasOutlet && hasOutletController && element.matches(selector);
      } else {
        return false;
      }
    }
    elementMatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementAttributeValueChanged(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementUnmatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    connectOutlet(outlet, element, outletName) {
      var _a;
      if (!this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.add(outletName, outlet);
        this.outletElementsByName.add(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
      }
    }
    disconnectOutlet(outlet, element, outletName) {
      var _a;
      if (this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.delete(outletName, outlet);
        this.outletElementsByName.delete(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
      }
    }
    disconnectAllOutlets() {
      for (const outletName of this.outletElementsByName.keys) {
        for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
          for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
            this.disconnectOutlet(outlet, element, outletName);
          }
        }
      }
    }
    updateSelectorObserverForOutlet(outletName) {
      const observer = this.selectorObserverMap.get(outletName);
      if (observer) {
        observer.selector = this.selector(outletName);
      }
    }
    setupSelectorObserverForOutlet(outletName) {
      const selector = this.selector(outletName);
      const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
      this.selectorObserverMap.set(outletName, selectorObserver);
      selectorObserver.start();
    }
    setupAttributeObserverForOutlet(outletName) {
      const attributeName = this.attributeNameForOutletName(outletName);
      const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
      this.attributeObserverMap.set(outletName, attributeObserver);
      attributeObserver.start();
    }
    selector(outletName) {
      return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    attributeNameForOutletName(outletName) {
      return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
    }
    getOutletNameFromOutletAttributeName(attributeName) {
      return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
    }
    get outletDependencies() {
      const dependencies = new Multimap();
      this.router.modules.forEach((module) => {
        const constructor = module.definition.controllerConstructor;
        const outlets = readInheritableStaticArrayValues(constructor, "outlets");
        outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
      });
      return dependencies;
    }
    get outletDefinitions() {
      return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
      return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
      const identifiers = this.dependentControllerIdentifiers;
      return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
    }
    hasOutlet(element, outletName) {
      return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
      return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
      return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
      return this.context.scope;
    }
    get schema() {
      return this.context.schema;
    }
    get identifier() {
      return this.context.identifier;
    }
    get application() {
      return this.context.application;
    }
    get router() {
      return this.application.router;
    }
  };
  var Context = class {
    constructor(module, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module;
      this.scope = scope;
      this.controller = new module.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      this.outletObserver = new OutletObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error4) {
        this.handleError(error4, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      this.outletObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error4) {
        this.handleError(error4, "connecting controller");
      }
    }
    refresh() {
      this.outletObserver.refresh();
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error4) {
        this.handleError(error4, "disconnecting controller");
      }
      this.outletObserver.stop();
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error4, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error4, `Error ${message}`, detail);
    }
    targetConnected(element, name2) {
      this.invokeControllerMethod(`${name2}TargetConnected`, element);
    }
    targetDisconnected(element, name2) {
      this.invokeControllerMethod(`${name2}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name2) {
      this.invokeControllerMethod(`${namespaceCamelize(name2)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name2) {
      this.invokeControllerMethod(`${namespaceCamelize(name2)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend2(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend2 = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a3 = function() {
        this.a.call(this);
      };
      const b = extendWithReflect(a3);
      b.prototype.a = function() {
      };
      return new b();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error4) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name2) {
      return this.data.has(this.getDataKey(name2));
    }
    get(name2) {
      return this.getAll(name2)[0];
    }
    getAll(name2) {
      const tokenString = this.data.get(this.getDataKey(name2)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name2) {
      return this.data.getAttributeNameForKey(this.getDataKey(name2));
    }
    getDataKey(name2) {
      return `${name2}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name2 = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name2);
    }
    set(key, value2) {
      const name2 = this.getAttributeNameForKey(key);
      this.element.setAttribute(name2, value2);
      return this.get(key);
    }
    has(key) {
      const name2 = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name2);
    }
    delete(key) {
      if (this.has(key)) {
        const name2 = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name2);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token2) {
    return `[${attributeName}~="${token2}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var OutletSet = class {
    constructor(scope, controllerElement) {
      this.scope = scope;
      this.controllerElement = controllerElement;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(outletName) {
      return this.find(outletName) != null;
    }
    find(...outletNames) {
      return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), void 0);
    }
    findAll(...outletNames) {
      return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
      const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
      return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      if (selector)
        return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
      const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
      return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
  };
  var Scope = class _Scope {
    constructor(schema, element, identifier, logger) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger);
      this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
      return this.element === document.documentElement;
    }
    get documentScope() {
      return this.isDocumentScope ? this : new _Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token2) {
      const { element, content: identifier } = token2;
      return this.parseValueForElementAndIdentifier(element, identifier);
    }
    parseValueForElementAndIdentifier(element, identifier) {
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value2) {
      const referenceCount = (this.scopeReferenceCounts.get(value2) || 0) + 1;
      this.scopeReferenceCounts.set(value2, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value2);
      }
    }
    elementUnmatchedValue(element, value2) {
      const referenceCount = this.scopeReferenceCounts.get(value2);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value2, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value2);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module = new Module(this.application, definition);
      this.connectModule(module);
      const afterLoad = definition.controllerConstructor.afterLoad;
      if (afterLoad) {
        afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
      }
    }
    unloadIdentifier(identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        this.disconnectModule(module);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        return module.contexts.find((context) => context.element == element);
      }
    }
    proposeToConnectScopeForElementAndIdentifier(element, identifier) {
      const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
      if (scope) {
        this.scopeObserver.elementMatchedValue(scope.element, scope);
      } else {
        console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
      }
    }
    handleError(error4, message, detail) {
      this.application.handleError(error4, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.disconnectContextForScope(scope);
      }
    }
    connectModule(module) {
      this.modulesByIdentifier.set(module.identifier, module);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
      this.modulesByIdentifier.delete(module.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c5) => [c5, c5]))), objectFromEntries("0123456789".split("").map((n2) => [n2, n2])))
  };
  function objectFromEntries(array2) {
    return array2.reduce((memo, [k, v]) => Object.assign(Object.assign({}, memo), { [k]: v }), {});
  }
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
      this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
      const application2 = new this(element, schema);
      application2.start();
      return application2;
    }
    async start() {
      await domReady();
      this.logDebugActivity("application", "starting");
      this.dispatcher.start();
      this.router.start();
      this.logDebugActivity("application", "start");
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name2, filter2) {
      this.actionDescriptorFilters[name2] = filter2;
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => {
        if (definition.controllerConstructor.shouldLoad) {
          this.router.loadDefinition(definition);
        }
      });
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error4, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error4, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error4);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve());
      } else {
        resolve();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
      return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
  }
  function getOutletController(controller, element, identifier) {
    return controller.application.getControllerForElementAndIdentifier(element, identifier);
  }
  function getControllerAndEnsureConnectedScope(controller, element, outletName) {
    let outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
    controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
    outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
  }
  function propertiesForOutletDefinition(name2) {
    const camelizedName = namespaceCamelize(name2);
    return {
      [`${camelizedName}Outlet`]: {
        get() {
          const outletElement = this.outlets.find(name2);
          const selector = this.outlets.getSelectorForOutletName(name2);
          if (outletElement) {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name2);
            if (outletController)
              return outletController;
            throw new Error(`The provided outlet element is missing an outlet controller "${name2}" instance for host controller "${this.identifier}"`);
          }
          throw new Error(`Missing outlet element "${name2}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      },
      [`${camelizedName}Outlets`]: {
        get() {
          const outlets = this.outlets.findAll(name2);
          if (outlets.length > 0) {
            return outlets.map((outletElement) => {
              const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name2);
              if (outletController)
                return outletController;
              console.warn(`The provided outlet element is missing an outlet controller "${name2}" instance for host controller "${this.identifier}"`, outletElement);
            }).filter((controller) => controller);
          }
          return [];
        }
      },
      [`${camelizedName}OutletElement`]: {
        get() {
          const outletElement = this.outlets.find(name2);
          const selector = this.outlets.getSelectorForOutletName(name2);
          if (outletElement) {
            return outletElement;
          } else {
            throw new Error(`Missing outlet element "${name2}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
          }
        }
      },
      [`${camelizedName}OutletElements`]: {
        get() {
          return this.outlets.findAll(name2);
        }
      },
      [`has${capitalize(camelizedName)}Outlet`]: {
        get() {
          return this.outlets.has(name2);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name2) {
    return {
      [`${name2}Target`]: {
        get() {
          const target = this.targets.find(name2);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name2}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name2}Targets`]: {
        get() {
          return this.targets.findAll(name2);
        }
      },
      [`has${capitalize(name2)}Target`]: {
        get() {
          return this.targets.has(name2);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name: name2, reader: read, writer: write } = definition;
    return {
      [name2]: {
        get() {
          const value2 = this.data.get(key);
          if (value2 !== null) {
            return read(value2);
          } else {
            return definition.defaultValue;
          }
        },
        set(value2) {
          if (value2 === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write(value2));
          }
        }
      },
      [`has${capitalize(name2)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token2, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
      controller,
      token: token2,
      typeDefinition
    });
  }
  function parseValueTypeConstant(constant4) {
    switch (constant4) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(payload) {
    const { controller, token: token2, typeObject } = payload;
    const hasType = isSomething(typeObject.type);
    const hasDefault = isSomething(typeObject.default);
    const fullObject = hasType && hasDefault;
    const onlyType = hasType && !hasDefault;
    const onlyDefault = !hasType && hasDefault;
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
    if (onlyType)
      return typeFromObject;
    if (onlyDefault)
      return typeFromDefaultValue;
    if (typeFromObject !== typeFromDefaultValue) {
      const propertyPath = controller ? `${controller}.${token2}` : token2;
      throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
    }
    if (fullObject)
      return typeFromObject;
  }
  function parseValueTypeDefinition(payload) {
    const { controller, token: token2, typeDefinition } = payload;
    const typeObject = { controller, token: token2, typeObject: typeDefinition };
    const typeFromObject = parseValueTypeObject(typeObject);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    const propertyPath = controller ? `${controller}.${typeDefinition}` : token2;
    throw new Error(`Unknown value type "${propertyPath}" for "${token2}" value`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant4 = parseValueTypeConstant(typeDefinition);
    if (constant4)
      return defaultValuesByType[constant4];
    const hasDefault = hasProperty(typeDefinition, "default");
    const hasType = hasProperty(typeDefinition, "type");
    const typeObject = typeDefinition;
    if (hasDefault)
      return typeObject.default;
    if (hasType) {
      const { type } = typeObject;
      const constantFromType = parseValueTypeConstant(type);
      if (constantFromType)
        return defaultValuesByType[constantFromType];
    }
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(payload) {
    const { token: token2, typeDefinition } = payload;
    const key = `${dasherize(token2)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value2) {
      const array2 = JSON.parse(value2);
      if (!Array.isArray(array2)) {
        throw new TypeError(`expected value of type "array" but instead got value "${value2}" of type "${parseValueTypeDefault(array2)}"`);
      }
      return array2;
    },
    boolean(value2) {
      return !(value2 == "0" || String(value2).toLowerCase() == "false");
    },
    number(value2) {
      return Number(value2.replace(/_/g, ""));
    },
    object(value2) {
      const object = JSON.parse(value2);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError(`expected value of type "object" but instead got value "${value2}" of type "${parseValueTypeDefault(object)}"`);
      }
      return object;
    },
    string(value2) {
      return value2;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value2) {
    return JSON.stringify(value2);
  }
  function writeString(value2) {
    return `${value2}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    static afterLoad(_identifier, _application) {
      return;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get outlets() {
      return this.scope.outlets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing
  ];
  Controller.targets = [];
  Controller.outlets = [];
  Controller.values = {};

  // engine/rails_design/app/javascripts/stimulus_base/index.js
  window.application = Application.start();
  HTMLElement.prototype.getController = function(identifier) {
    return application.getControllerForElementAndIdentifier(this, identifier);
  };

  // engine/rails_design/app/javascripts/stimulus_com/alert.js
  var alert_default = class extends Controller {
    static values = {
      content: String
    };
    alert() {
      alert(this.contentValue);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/animate-typer.js
  var animate_typer_default = class extends Controller {
    static targets = ["src", "item"];
    connect() {
      const ele = this.element;
      ele.classList.remove("invisible");
      ele.style.animationDuration = `${ele.innerText.length * 200}ms`;
      ele.classList.add("has-animate-typer");
      ele.addEventListener("animationend", this.typeNext, { once: true });
    }
    typeNext(event) {
      const ele = event.currentTarget;
      let nextEle = ele.nextElementSibling;
      while (nextEle) {
        if (nextEle.innerHTML) {
          nextEle.dataset.add("controller", "animate-typer");
          break;
        } else {
          nextEle = nextEle.nextElementSibling;
        }
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/audio-player.js
  var audio_player_default = class extends Controller {
    static values = {
      auto: String,
      url: String,
      link: String,
      loop: { type: Boolean, default: false },
      next: { type: Boolean, default: true }
    };
    initialize() {
      window.audioContext ||= new AudioContext();
    }
    connect() {
      if (this.hasAutoValue) {
        this.doPlay(this.autoValue);
      } else if (this.hasUrlValue) {
        this.doFetch(this.urlValue);
      }
      if (window.__wxjs_environment === "miniprogram") {
        WeixinJSBridge.on("onPageStateChange", (res) => {
          if (res.active === "true" || res.active === true) {
            this.stop();
          }
        });
      }
    }
    disconnect() {
      this.disconnected = true;
      this.source?.stop();
    }
    stop() {
      this.source.stop();
    }
    play(event) {
      if (this.hasAutoValue) {
        this.doPlay(this.autoValue);
      } else if (this.hasUrlValue) {
        this.doPlay(this.urlValue);
      }
    }
    autoPlay() {
      this.element.querySelector(":scope > video:first-child")?.play();
    }
    async doPlay(url) {
      await this.doFetch(url, this.doStart);
    }
    async doFetch(url, callback) {
      const response = await fetch(url);
      audioContext.decodeAudioData(await response.arrayBuffer(), (decodeData) => {
        this.source = audioContext.createBufferSource();
        this.source.buffer = decodeData;
        this.source.connect(audioContext.destination);
        this.source.loop = this.loopValue;
        console.log(this.source);
        callback(this);
      });
    }
    doStart(that = this) {
      console.debug("---------------", that);
      if (!that.disconnected) {
        that.source.start();
      }
      if (that.linkValue) {
        that.source.addEventListener("ended", (e3) => {
          Turbo.visit(that.linkValue);
        });
      } else if (that.nextValue) {
        that.source.that = that;
        that.source.addEventListener("ended", that.goPlayNext);
      }
    }
    playNext(event) {
      let ele = event.currentTarget;
      const controller = event.target.closest("[data-controller~=audio-player]").getController("audio-player");
      controller.playAnd(ele);
    }
    playAnd(ele) {
      if (ele.dataset.hidden) {
        const hiddenEles = document.querySelectorAll(ele.dataset.hidden);
        hiddenEles.forEach((el) => {
          el.style.display = "none";
          if (["VIDEO", "AUDIO"].includes(el.tagName)) {
            el.pause();
          } else {
            el.querySelectorAll("video, audio").forEach((hideVideo) => {
              hideVideo.pause();
            });
          }
        });
      }
      if (ele.dataset.next) {
        const nextEles = document.querySelectorAll(ele.dataset.next);
        nextEles.forEach((nextEle) => {
          nextEle.style.removeProperty("display");
          if (["VIDEO", "AUDIO"].includes(nextEle.tagName)) {
            nextEle.play();
          } else if (nextEle.getController("audio-player")) {
            nextEle.getController("audio-player").doStart();
          } else {
            nextEle.querySelectorAll("video, audio").forEach((nextVideo) => {
              nextVideo.play();
            });
          }
        });
      }
    }
    goPlayNext(event) {
      const tar = event.currentTarget;
      tar.that.playAnd(tar.that.element);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/cable.js
  var cable_default = class extends Controller {
    connect() {
      consumer.connection.reopen();
    }
  };

  // engine/rails_design/app/javascripts/base_controller.js
  var base_controller_default = class extends Controller {
    static values = {
      url: String,
      input: String,
      params: Object
    };
    csrfToken() {
      const meta = document.querySelector("meta[name=csrf-token]");
      return meta && meta.content;
    }
    get(url) {
      this.request(url, "GET");
    }
    post(url, body, headers) {
      this.request(
        url,
        "POST",
        body,
        { "Content-Type": "application/json", "X-CSRF-Token": this.csrfToken(), ...headers }
      );
    }
    patch(url, body, headers) {
      this.request(
        url,
        "PATCH",
        body,
        { "Content-Type": "application/json", "X-CSRF-Token": this.csrfToken(), ...headers }
      );
    }
    formPost(form) {
      this.request(
        this.urlValue,
        "POST",
        new FormData(form),
        { "X-CSRF-Token": this.csrfToken() }
      );
    }
    inputPost(input) {
      const body = new FormData();
      if (this.hasInputValue) {
        body.append(this.inputValue, input.value);
      } else {
        body.append(input.name, input.value);
      }
      if (this.hasParamsValue) {
        Object.keys(this.paramsValue).forEach((k) => {
          body.append(k, this.paramsValue[k]);
        });
      }
      this.request(
        this.urlValue,
        "POST",
        body,
        { "X-CSRF-Token": this.csrfToken() }
      );
    }
    inputGet(input) {
      let url;
      if (input.dataset.url) {
        url = new URL(input.dataset.url, location.origin);
      } else {
        url = new URL(this.urlValue, location.origin);
      }
      if (this.hasInputValue) {
        url.searchParams.set(this.inputValue, input.value);
      } else {
        url.searchParams.set(input.name, input.value);
      }
      if (this.hasParamsValue) {
        Object.keys(this.paramsValue).forEach((k) => {
          url.searchParams.set(k, this.paramsValue[k]);
        });
      }
      this.get(url);
    }
    request(url, method, body, headers) {
      fetch(url, {
        credentials: "include",
        method: method.toUpperCase(),
        headers: {
          Accept: "text/vnd.turbo-stream.html",
          ...headers
        },
        body
      }).then((response) => {
        return response.text();
      }).then((body2) => {
        Turbo.renderStreamMessage(body2);
      });
    }
    get locale() {
      return document.querySelector("html").lang;
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/common.js
  var common_default = class extends base_controller_default {
    static values = {
      body: String
    };
    cancel(event) {
      event.preventDefault();
      Turbo.visit(location.href, { action: "replace" });
    }
    link() {
      this.post(this.urlValue, this.bodyValue);
    }
    streamPost() {
      this.post(this.urlValue, this.bodyValue);
    }
    stream(event) {
      const ele = event.currentTarget;
      this.inputGet(ele);
    }
    postInput(event) {
      const ele = event.currentTarget;
      this.inputPost(ele);
    }
    // turbo:submit-start@window->common#submit
    submit(event) {
      const form = event.detail.formSubmission;
      form.mustRedirect = false;
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/clipboard.js
  var clipboard_default = class extends Controller {
    static targets = ["source", "toast"];
    copyInput() {
      navigator.clipboard.writeText(this.sourceTarget.value);
    }
    copyInner() {
      navigator.clipboard.writeText(this.sourceTarget.innerText);
    }
    copy() {
      navigator.clipboard?.writeText(this.sourceTarget.textContent);
      if (this.hasToastTarget) {
        this.toastTarget.style.animationDuration = "2s";
        this.toastTarget.classList.remove("display-none");
        this.toastTarget.classList.add("has-animate-fade-in-out");
        this.toastTarget.addEventListener("animationend", (event) => {
          event.currentTarget.classList.add("display-none");
          event.currentTarget.classList.remove("has-animate-fade-in-out");
        }, { once: true });
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/count-down.js
  var count_down_default = class extends Controller {
    static values = {
      time: { type: Number, default: 60 },
      get: { type: String, default: "\u83B7\u53D6\u9A8C\u8BC1\u7801" }
    };
    static targets = ["count", "hidden", "disabled"];
    connect() {
      this.countDown();
    }
    countDown() {
      let countdown = this.timeValue;
      let value2;
      if (this.countTarget instanceof HTMLInputElement) {
        value2 = this.countTarget.value;
      } else {
        value2 = "";
      }
      this.setCount(value2, countdown);
      let timer2 = setInterval(() => {
        countdown--;
        if (countdown <= 0) {
          if (this.hasDisabledTarget) {
            this.disabledTarget.removeAttribute("disabled");
          }
          this.setCount(value2, this.getValue);
          this.hiddenTargets.forEach((el) => {
            el.remove();
          });
          clearInterval(timer2);
        } else {
          this.setCount(value2, countdown);
        }
      }, 1e3, countdown);
    }
    setCount(text, countdown) {
      if (this.countTarget instanceof HTMLInputElement) {
        if (countdown <= 0) {
          this.countTarget.value = `${text}`;
        } else {
          this.countTarget.value = `${text} ${countdown}\u79D2`;
        }
      } else {
        this.countTarget.innerText = countdown;
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/custom.js
  var custom_default = class extends Controller {
    static classes = ["remove", "add"];
    static values = {
      order: Array,
      only: Boolean
    };
    toggle(event) {
      const checkbox = event.currentTarget;
      if (checkbox.checked) {
        this.toggleOn(checkbox);
      } else if (!checkbox.checked) {
        this.toggleOffCss(checkbox);
      }
      checkbox.form.requestSubmit();
    }
    toggleOn(checkbox) {
      if (this.onlyValue) {
        this.toggleOffOther(checkbox);
      }
    }
    toggleOff(checkbox) {
      checkbox.checked = false;
      this.toggleOffCss(checkbox);
    }
    toggleOffCss(checkbox) {
      checkbox.labels.forEach((i) => {
        i.classList.remove("weui-btn_primary");
        i.classList.add("weui-btn_default");
      });
    }
    toggleOnDisable(input) {
      input.disabled = true;
      input.labels.forEach((i) => {
        i.classList.add("weui-cell_disabled");
      });
    }
    toggleOffDisable(input) {
      if (input.disabled) {
        input.disabled = false;
        input.labels.forEach((i) => {
          i.classList.remove("weui-cell_disabled");
        });
      }
    }
    toggleOffOther(checkbox) {
      const items = checkbox.form.elements[checkbox.name];
      let toRemove;
      for (let i of items) {
        if (i.dataset.partTaxonId === checkbox.dataset.partTaxonId && i !== checkbox) {
          if (i.type === "checkbox") {
            this.toggleOff(i);
            this.toggleOffDisable(i);
          } else if (i.type === "hidden") {
            toRemove = i;
          }
        }
      }
      if (toRemove) {
        toRemove.remove();
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/dispatch.js
  var dispatch_default = class extends Controller {
    static values = {
      id: String,
      controller: String,
      action: String,
      click: String
    };
    static outlets = ["modal"];
    stop() {
      this.outlet["stop"]();
    }
    doClick() {
      this.modalOutlet[this.clickValue]();
    }
    get outlet() {
      return document.getElementById(this.idValue).getController(this.controllerValue);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/draw-line.js
  var draw_line_default = class extends Controller {
    link() {
      this.element.querySelectorAll("[data-id]").forEach((el) => {
        const src = document.getElementById(el.dataset.id);
        this.drawLine(src, el);
      });
    }
    drawLine(src, dest) {
      const src_x = src.getBoundingClientRect().right;
      const src_y = src.getBoundingClientRect().top + src.clientHeight / 2;
      const dest_x = dest.getBoundingClientRect().left;
      const dest_y = dest.getBoundingClientRect().top + dest.clientHeight / 2;
      const length5 = Math.sqrt(Math.pow(dest_x - src_x, 2), Math.pow(dest_y - src_y, 2));
      const rad2 = Math.atan2(dest_y - src_y, dest_x - src_x);
      const top = (src_y + dest_y) / 2;
      const left2 = (src_x + dest_x) / 2 - length5 / 2;
      const line4 = document.createElement("div");
      line4.classList.add("draw-line");
      line4.style.top = `${top}px`;
      line4.style.left = `${left2}px`;
      line4.style.width = `${length5}px`;
      line4.style.transform = `rotate(${rad2}rad)`;
      document.body.appendChild(line4);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/empty.js
  var empty_default = class extends Controller {
    static targets = ["content", "text"];
    connect() {
      if (this.hasContentTarget && this.contentTarget.childElementCount < 1) {
        this.element.remove();
      } else if (this.hasTextTarget && this.textTarget.innerText.length < 1) {
        this.element.remove();
      } else if (this.element.childElementCount < 1) {
        this.element.remove();
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/enter-section.js
  var enter_section_default = class extends Controller {
    static targets = ["order", "children"];
    static values = {
      threshold: { type: Number, default: 0.35 },
      delay: { type: Number, default: 0.2 }
    };
    connect() {
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((el) => {
            if (el.isIntersecting) {
              if (this.hasChildrenTarget) {
                Array.from(this.childrenTarget.children).forEach((child, index4) => {
                  child.style.transitionDelay = `${index4 * this.delayValue}s`;
                  this.zz(child);
                  child.addEventListener("transitionend", this.endXx, { once: true });
                  child.addEventListener("transitioncancel", this.cancelXx, { once: true });
                });
              } else {
                this.zz(el.target);
              }
            } else if (!el.isIntersecting && el.boundingClientRect.top > 0) {
              if (this.hasChildrenTarget) {
                Array.from(this.childrenTarget.children).forEach((child, index4) => {
                  child.style.transitionDelay = `${index4 * this.delayValue}s`;
                  this.zzz(child);
                  child.addEventListener("transitionend", this.endXx, { once: true });
                  child.addEventListener("transitioncancel", this.cancelXx, { once: true });
                });
              } else {
                this.zzz(el.target);
              }
            }
          });
        },
        {
          threshold: this.thresholdValue
        }
      );
      this.observer.observe(this.element);
    }
    zz(ele) {
      ele.classList.add("has-fade-animate");
      ele.classList.replace("has-fade-start", "has-fade-end");
    }
    zzz(ele) {
      ele.classList.add("has-fade-animate");
      ele.classList.replace("has-fade-end", "has-fade-start");
    }
    endXx(event) {
      const controller = event.target.closest("[data-controller~=enter-section]").getController("enter-section");
      controller.xx(event.target);
      event.target.removeEventListener("transitioncancel", controller.cancelXx);
    }
    cancelXx(event) {
      const controller = event.target.closest("[data-controller~=enter-section]").getController("enter-section");
      controller.xx(event.target);
      event.target.removeEventListener("transitionend", controller.endXx);
    }
    xx(target) {
      target.classList.remove("has-fade-animate");
      target.style.removeProperty("transition-delay");
    }
    disconnect() {
      this.observer.disconnect();
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/fixed-width.js
  var fixed_width_default = class extends Controller {
    connect() {
      this.element.style.width = `${this.element.getBoundingClientRect().width}px`;
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/hover.js
  var hover_default = class extends Controller {
    static targets = ["card"];
    static values = {
      url: String
    };
    show(event) {
      let ele = event.currentTarget;
      if (this.hasCardTarget) {
        this.cardTarget.classList.remove("display-none");
      } else if (this.urlValue) {
        fetch(this.urlValue, {
          method: "GET",
          dataType: "text/html",
          success: function(html) {
            ele.insertAdjacentHTML("beforebegin", html.body.innerHTML);
          },
          error: function(data2) {
            console.debug("error", data2);
          }
        });
      }
    }
    hide() {
      if (this.hasCardTarget) {
        this.cardTarget.classList.add("display-none");
      }
    }
    disconnect() {
      if (this.hasCardTarget) {
        this.cardTarget.remove();
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/gif.js
  var gif_default = class extends Controller {
    static values = {
      duration: Number
    };
    connect() {
      if (this.hasDurationValue) {
        setTimeout(() => {
          this.innerShowNext(this.element, this.identifier);
        }, this.durationValue);
      }
    }
    showNext(event) {
      const ele = event.currentTarget;
      this.innerShowNext(ele, this.identifier);
    }
    innerShowNext(ele, identifier) {
      if (ele.dataset.hidden) {
        const hiddenEles = document.querySelectorAll(ele.dataset.hidden);
        hiddenEles.forEach((el) => {
          el.style.display = "none";
        });
      }
      let nextEles = [ele.nextElementSibling];
      if (ele.dataset.next) {
        nextEles = document.querySelectorAll(ele.dataset.next);
      }
      let nextCon = identifier;
      if (ele.dataset.nextController) {
        nextCon = ele.dataset.nextController;
      }
      nextEles.forEach((el) => {
        el.style.removeProperty("display");
        el.dataset.add("controller", nextCon);
      });
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/notice.js
  var notice_default = class extends Controller {
    static targets = ["progress"];
    static values = {
      duration: { type: Number, default: 5 }
    };
    connect() {
      this.element.style.animationDuration = `${this.durationValue}s`;
      if (this.hasProgressTarget) {
        let count4 = 100;
        const rate = this.durationValue * 1e3 / count4;
        this.timer = setInterval(() => {
          count4--;
          this.progressTarget.value = count4;
          if (count4 <= 0) {
            clearInterval(this.timer);
          }
        }, rate);
      }
    }
    close() {
      this.element.remove();
    }
    disconnect() {
      if (this.timer) {
        clearInterval(this.timer);
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/touch.js
  var touch_default = class extends Controller {
    static values = {
      debug: Boolean
    };
    // data-action="touchstart->slide#start:passive"
    initStatus(event) {
      const touch = event.targetTouches[0];
      this.startPos = {
        x: touch.pageX,
        y: touch.pageY
      };
      this.startTime = (/* @__PURE__ */ new Date()).getTime();
    }
    // scale && scale !== 表示缩放了
    zoomed(event) {
      const result = event.changedTouches.length > 1 || event.scale && event.scale !== 1;
      if (result) {
        console.error("\u662F\u5426\u7F29\u653E\uFF1A", result);
      }
      return result;
    }
    // 是否达到触发条件
    effective(pad3, x3 = true) {
      const endTime = (/* @__PURE__ */ new Date()).getTime();
      let isMore;
      if (x3) {
        isMore = pad3 > this.element.clientWidth / 2;
      } else {
        isMore = pad3 > this.element.clientHeight / 2;
      }
      console.debug("\u662F\u5426\u8D85\u8FC7\u4E00\u534A\uFF1A", isMore);
      const speed = pad3 / (endTime - this.startTime);
      const isFast = speed > 0.1;
      console.debug("\u624B\u52BF\u901F\u5EA6\uFF1A", isFast);
      return isMore || isFast;
    }
    isHorizontal(pad3, offset3) {
      const isHorizontal3 = pad3 > Math.abs(offset3.y);
      if (this.hasDebugValue && this.debugValue) {
        console.debug("\u662F\u5426\u5DE6\u53F3\u6ED1\u52A8\uFF1A", isHorizontal3);
      }
      return isHorizontal3;
    }
    offset(event) {
      const touch = event.changedTouches[0];
      const offset3 = {
        x: touch.pageX - this.startPos.x,
        y: touch.pageY - this.startPos.y
      };
      if (this.hasDebugValue && this.debugValue) {
        console.debug(event.type, "offset:", offset3);
      }
      return offset3;
    }
    removeStyle(ele, styles) {
      styles.forEach((rule) => {
        ele.style.removeProperty(rule);
      });
    }
    get startPos() {
      let r = this.data.get("startPos").split(",");
      return {
        x: parseFloat(r[0]),
        y: parseFloat(r[1])
      };
    }
    set startPos(pos) {
      this.data.set("startPos", [pos.x, pos.y].join(","));
    }
    get startTime() {
      return this.data.get("startTime");
    }
    set startTime(time) {
      this.data.set("startTime", time);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/page.js
  var page_default = class extends touch_default {
    static targets = ["paging", "loading", "tip"];
    connect() {
      this.element.addEventListener("touchstart", (event) => {
        this.start(event);
      }, { passive: true });
    }
    start(event) {
      this.initStatus(event);
    }
    move(event) {
      const offset3 = this.offset(event);
      if (offset3.y < 0 && this.arriveBottom() && this.currentPage < this.totalPage) {
        this.loadingTarget.style.display = "flex";
        this.appendPage();
      } else {
        console.log("\u672A\u89E6\u53D1\u7FFB\u9875");
      }
    }
    arriveBottom() {
      const wrap = this.element.parentNode.parentNode;
      const toBottom = wrap.scrollHeight - (wrap.clientHeight + wrap.scrollTop);
      console.debug("to bottom", toBottom);
      if (this.hasTipTarget) {
        return toBottom < this.tipTarget.clientHeight;
      } else {
        return false;
      }
    }
    appendPage() {
      const url = new URL(location.href);
      this.currentPage = this.currentPage + 1;
      url.searchParams.set("page", this.currentPage);
      fetch(url, {
        headers: {
          Accept: "text/vnd.turbo-stream.html"
        }
      }).then((response) => {
        return response.text();
      }).then((body) => {
        Turbo.renderStreamMessage(body);
      });
    }
    get currentPage() {
      return Number(this.pagingTarget.dataset.page) || 1;
    }
    set currentPage(value2) {
      this.pagingTarget.dataset.page = value2;
    }
    get totalPage() {
      return Number(this.pagingTarget.dataset.total) || 1;
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/player.js
  var player_default = class extends audio_player_default {
    static targets = [
      "media",
      "progress",
      "cover",
      "hide"
    ];
    static values = {
      show: String
    };
    connect() {
      if (this.hasMediaTarget && this.mediaTarget.duration && this.hasProgressTarget) {
        this.progressTarget.setAttribute("max", this.mediaTarget.duration);
      } else if (this.hasMediaTarget && this.hasProgressTarget) {
        this.mediaTarget.addEventListener("loadedmetadata", (e3) => {
          this.progressTarget.setAttribute("max", e3.currentTarget.duration);
        });
      }
      if (this.hasProgressTarget) {
        this.mediaTarget.addEventListener("timeupdate", () => {
          if (!this.progressTarget.getAttribute("max")) {
            this.progressTarget.setAttribute("max", this.mediaTarget.duration);
          }
          this.progressTarget.value = this.mediaTarget.currentTime;
        });
      }
    }
    toggle(e3) {
      const ele = e3.currentTarget;
      if (this.mediaTarget.played.length === 0 || this.mediaTarget.paused) {
        this.mediaTarget.play();
        ele.children[0].classList.replace("fa-play", "fa-pause");
        this.coverTarget.style.animationPlayState = "running";
      } else {
        this.mediaTarget.pause();
        ele.children[0].classList.replace("fa-pause", "fa-play");
        this.coverTarget.style.animationPlayState = "paused";
      }
    }
    play() {
      if (this.hasMediaTarget && (this.mediaTarget.played.length === 0 || this.mediaTarget.paused)) {
        this.mediaTarget.play();
      }
    }
    cutTo() {
      if (this.hasHideTarget) {
        this.hideTarget.style.display = "none";
      }
      if (this.hasShowValue) {
        const show3 = document.getElementById(this.showValue);
        show3.style.removeProperty("display");
        if (["VIDEO", "AUDIO"].includes(show3.tagName)) {
          show3.play();
        } else {
          show3.querySelector("video, audio")?.play();
        }
      }
    }
    disconnect() {
      this.source?.stop();
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/print.js
  var print_default = class extends Controller {
    static values = {
      url: String,
      name: String,
      hidden: Boolean
    };
    doPrint() {
      const present_frame = document.getElementById("pdf_iframe");
      if (present_frame) {
        present_frame.src = this.urlValue;
      } else {
        const iframe = document.createElement("iframe");
        iframe.src = this.urlValue;
        iframe.name = "pdf";
        iframe.id = "pdf_iframe";
        iframe.hidden = true;
        iframe.onload = () => {
          const pdfFrame = window.frames["pdf"];
          pdfFrame.focus();
          pdfFrame.print();
        };
        document.body.appendChild(iframe);
      }
    }
    batchPrint() {
      this.batchUrl();
      this.doPrint();
    }
    batchUrl() {
      const ids = [];
      this.checkboxes.forEach((item) => {
        if (item.checked && !item.disabled) {
          ids.push(item.value);
        }
      });
      if (ids.length > 0) {
        const url = new URL(this.urlValue);
        url.searchParams.set("ids", ids.join(","));
        this.urlValue = url;
      } else {
        alert("no need commit");
      }
    }
    // checkbox data-action="check#toggleAll"
    toggleAll(event) {
      const element = event.currentTarget;
      for (let checkbox of this.checkboxes) {
        if (!checkbox.disabled) {
          checkbox.checked = element.checked;
        }
      }
    }
    get checkboxes() {
      return document.querySelectorAll(`input[type=checkbox][name='${this.nameValue}']`);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/qy-login.js
  var qy_login_default = class extends Controller {
    static values = {
      options: Object
    };
    connect() {
      const r = {
        lang: "zh",
        id: "wx_reg",
        ...this.optionsValue
      };
      console.debug("options is", r);
      this.wwLogin = new WwLogin(r);
    }
    disconnect() {
      this.wwLogin.destroyed();
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/scroll.js
  var scroll_default = class extends Controller {
    preserve(event) {
      let scrollTop;
      let oldContainer = event.target.parentElement;
      while (oldContainer) {
        if (oldContainer.scrollTop > 0) {
          scrollTop = oldContainer.scrollTop;
          break;
        }
        oldContainer = oldContainer.parentElement;
      }
      window.addEventListener("turbo:render", (ev) => {
        const newContainer = document.getElementById(oldContainer.id) || document.scrollingElement;
        console.debug("old container scroll top", oldContainer, scrollTop);
        newContainer.scrollTo(0, scrollTop);
      }, { once: true });
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/scroll-next.js
  var scroll_next_default = class extends Controller {
    static values = {
      content: String
    };
    next() {
      if (this.element.nextElementSibling) {
        this.element.nextElementSibling.scrollIntoView();
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/show.js
  var show_default = class extends Controller {
    static targets = ["src", "item", "check", "hidden"];
    show() {
      this.itemTargets.forEach((el) => {
        el.classList.remove("visibility-hidden");
      });
    }
    hide() {
      this.itemTargets.forEach((el) => {
        el.classList.add("visibility-hidden");
      });
    }
    toggle(event) {
      const ele = event.currentTarget;
      if (ele.checked) {
        this.checkTargets.forEach((el) => {
          el.classList.remove("display-none");
        });
        this.hiddenTargets.forEach((el) => {
          el.classList.add("display-none");
        });
        document.querySelectorAll(`[name^="${ele.name.replace(/\[\w+]$/, "")}"]:not([name="${ele.name}"], [name="${ele.name.replace(/\[\w+]$/, "[id]")}"])`).forEach((ele2) => {
          ele2.disabled = false;
        });
      } else {
        this.checkTargets.forEach((el) => {
          el.classList.add("display-none");
        });
        this.hiddenTargets.forEach((el) => {
          el.classList.remove("display-none");
        });
        document.querySelectorAll(`[name^="${ele.name.replace(/\[\w+]$/, "")}"]:not([name="${ele.name}"], [name="${ele.name.replace(/\[\w+]$/, "[id]")}"])`).forEach((ele2) => {
          ele2.disabled = true;
        });
      }
    }
    queryShow(event) {
      const ele = event.currentTarget;
      if (ele.dataset.hidden) {
        const hiddenEles = document.querySelectorAll(ele.dataset.hidden);
        hiddenEles.forEach((el) => {
          el.style.display = "none";
        });
      }
      if (ele.dataset.next) {
        const nextEles = document.querySelectorAll(ele.dataset.next);
        nextEles.forEach((el) => {
          el.style.removeProperty("display");
        });
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/showcase.js
  var showcase_default = class extends Controller {
    static targets = [
      "window"
    ];
    static classes = [
      "hover"
    ];
    // data-action="mouseover->showcase#show"
    show(event) {
      const ele = event.currentTarget;
      ele.classList.add(this.hoverClass);
      for (const el of ele.parentElement.children) {
        if (el !== ele) {
          el.classList.remove(this.hoverClass);
        }
      }
      const target = this.windowTarget.querySelector(`[data-index="${ele.dataset.index}"`);
      target.style.zIndex = 1;
      for (const el of this.windowTarget.children) {
        if (el.dataset.index !== ele.dataset.index) {
          el.style.zIndex = 0;
        }
      }
    }
  };

  // node_modules/luxon/src/errors.js
  var LuxonError = class extends Error {
  };
  var InvalidDateTimeError = class extends LuxonError {
    constructor(reason) {
      super(`Invalid DateTime: ${reason.toMessage()}`);
    }
  };
  var InvalidIntervalError = class extends LuxonError {
    constructor(reason) {
      super(`Invalid Interval: ${reason.toMessage()}`);
    }
  };
  var InvalidDurationError = class extends LuxonError {
    constructor(reason) {
      super(`Invalid Duration: ${reason.toMessage()}`);
    }
  };
  var ConflictingSpecificationError = class extends LuxonError {
  };
  var InvalidUnitError = class extends LuxonError {
    constructor(unit) {
      super(`Invalid unit ${unit}`);
    }
  };
  var InvalidArgumentError = class extends LuxonError {
  };
  var ZoneIsAbstractError = class extends LuxonError {
    constructor() {
      super("Zone is an abstract class");
    }
  };

  // node_modules/luxon/src/impl/formats.js
  var n = "numeric";
  var s = "short";
  var l = "long";
  var DATE_SHORT = {
    year: n,
    month: n,
    day: n
  };
  var DATE_MED = {
    year: n,
    month: s,
    day: n
  };
  var DATE_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s
  };
  var DATE_FULL = {
    year: n,
    month: l,
    day: n
  };
  var DATE_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l
  };
  var TIME_SIMPLE = {
    hour: n,
    minute: n
  };
  var TIME_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n
  };
  var TIME_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
  };
  var TIME_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
  };
  var TIME_24_SIMPLE = {
    hour: n,
    minute: n,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: s
  };
  var TIME_24_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: l
  };
  var DATETIME_SHORT = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n
  };
  var DATETIME_SHORT_WITH_SECONDS = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n,
    second: n
  };
  var DATETIME_MED = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n
  };
  var DATETIME_MED_WITH_SECONDS = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n,
    second: n
  };
  var DATETIME_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s,
    hour: n,
    minute: n
  };
  var DATETIME_FULL = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    timeZoneName: s
  };
  var DATETIME_FULL_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
  };
  var DATETIME_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    timeZoneName: l
  };
  var DATETIME_HUGE_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
  };

  // node_modules/luxon/src/zone.js
  var Zone = class {
    /**
     * The type of zone
     * @abstract
     * @type {string}
     */
    get type() {
      throw new ZoneIsAbstractError();
    }
    /**
     * The name of this zone.
     * @abstract
     * @type {string}
     */
    get name() {
      throw new ZoneIsAbstractError();
    }
    /**
     * The IANA name of this zone.
     * Defaults to `name` if not overwritten by a subclass.
     * @abstract
     * @type {string}
     */
    get ianaName() {
      return this.name;
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year.
     * @abstract
     * @type {boolean}
     */
    get isUniversal() {
      throw new ZoneIsAbstractError();
    }
    /**
     * Returns the offset's common name (such as EST) at the specified timestamp
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to get the name
     * @param {Object} opts - Options to affect the format
     * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
     * @param {string} opts.locale - What locale to return the offset name in.
     * @return {string}
     */
    offsetName(ts, opts) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Returns the offset's value as a string
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(ts, format3) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to compute the offset
     * @return {number}
     */
    offset(ts) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Return whether this Zone is equal to another zone
     * @abstract
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(otherZone) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Return whether this Zone is valid.
     * @abstract
     * @type {boolean}
     */
    get isValid() {
      throw new ZoneIsAbstractError();
    }
  };

  // node_modules/luxon/src/zones/systemZone.js
  var singleton = null;
  var SystemZone = class _SystemZone extends Zone {
    /**
     * Get a singleton instance of the local zone
     * @return {SystemZone}
     */
    static get instance() {
      if (singleton === null) {
        singleton = new _SystemZone();
      }
      return singleton;
    }
    /** @override **/
    get type() {
      return "system";
    }
    /** @override **/
    get name() {
      return new Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    /** @override **/
    get isUniversal() {
      return false;
    }
    /** @override **/
    offsetName(ts, { format: format3, locale: locale2 }) {
      return parseZoneInfo(ts, format3, locale2);
    }
    /** @override **/
    formatOffset(ts, format3) {
      return formatOffset(this.offset(ts), format3);
    }
    /** @override **/
    offset(ts) {
      return -new Date(ts).getTimezoneOffset();
    }
    /** @override **/
    equals(otherZone) {
      return otherZone.type === "system";
    }
    /** @override **/
    get isValid() {
      return true;
    }
  };

  // node_modules/luxon/src/zones/IANAZone.js
  var dtfCache = {};
  function makeDTF(zone) {
    if (!dtfCache[zone]) {
      dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone: zone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short"
      });
    }
    return dtfCache[zone];
  }
  var typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6
  };
  function hackyOffset(dtf, date) {
    const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
    return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
  }
  function partsOffset(dtf, date) {
    const formatted = dtf.formatToParts(date);
    const filled = [];
    for (let i = 0; i < formatted.length; i++) {
      const { type, value: value2 } = formatted[i];
      const pos = typeToPos[type];
      if (type === "era") {
        filled[pos] = value2;
      } else if (!isUndefined(pos)) {
        filled[pos] = parseInt(value2, 10);
      }
    }
    return filled;
  }
  var ianaZoneCache = {};
  var IANAZone = class _IANAZone extends Zone {
    /**
     * @param {string} name - Zone name
     * @return {IANAZone}
     */
    static create(name2) {
      if (!ianaZoneCache[name2]) {
        ianaZoneCache[name2] = new _IANAZone(name2);
      }
      return ianaZoneCache[name2];
    }
    /**
     * Reset local caches. Should only be necessary in testing scenarios.
     * @return {void}
     */
    static resetCache() {
      ianaZoneCache = {};
      dtfCache = {};
    }
    /**
     * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
     * @param {string} s - The string to check validity on
     * @example IANAZone.isValidSpecifier("America/New_York") //=> true
     * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
     * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
     * @return {boolean}
     */
    static isValidSpecifier(s3) {
      return this.isValidZone(s3);
    }
    /**
     * Returns whether the provided string identifies a real zone
     * @param {string} zone - The string to check
     * @example IANAZone.isValidZone("America/New_York") //=> true
     * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
     * @example IANAZone.isValidZone("Sport~~blorp") //=> false
     * @return {boolean}
     */
    static isValidZone(zone) {
      if (!zone) {
        return false;
      }
      try {
        new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
        return true;
      } catch (e3) {
        return false;
      }
    }
    constructor(name2) {
      super();
      this.zoneName = name2;
      this.valid = _IANAZone.isValidZone(name2);
    }
    /**
     * The type of zone. `iana` for all instances of `IANAZone`.
     * @override
     * @type {string}
     */
    get type() {
      return "iana";
    }
    /**
     * The name of this zone (i.e. the IANA zone name).
     * @override
     * @type {string}
     */
    get name() {
      return this.zoneName;
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year:
     * Always returns false for all IANA zones.
     * @override
     * @type {boolean}
     */
    get isUniversal() {
      return false;
    }
    /**
     * Returns the offset's common name (such as EST) at the specified timestamp
     * @override
     * @param {number} ts - Epoch milliseconds for which to get the name
     * @param {Object} opts - Options to affect the format
     * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
     * @param {string} opts.locale - What locale to return the offset name in.
     * @return {string}
     */
    offsetName(ts, { format: format3, locale: locale2 }) {
      return parseZoneInfo(ts, format3, locale2, this.name);
    }
    /**
     * Returns the offset's value as a string
     * @override
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(ts, format3) {
      return formatOffset(this.offset(ts), format3);
    }
    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     * @override
     * @param {number} ts - Epoch milliseconds for which to compute the offset
     * @return {number}
     */
    offset(ts) {
      const date = new Date(ts);
      if (isNaN(date)) return NaN;
      const dtf = makeDTF(this.name);
      let [year2, month2, day2, adOrBc, hour2, minute2, second2] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
      if (adOrBc === "BC") {
        year2 = -Math.abs(year2) + 1;
      }
      const adjustedHour = hour2 === 24 ? 0 : hour2;
      const asUTC = objToLocalTS({
        year: year2,
        month: month2,
        day: day2,
        hour: adjustedHour,
        minute: minute2,
        second: second2,
        millisecond: 0
      });
      let asTS = +date;
      const over = asTS % 1e3;
      asTS -= over >= 0 ? over : 1e3 + over;
      return (asUTC - asTS) / (60 * 1e3);
    }
    /**
     * Return whether this Zone is equal to another zone
     * @override
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(otherZone) {
      return otherZone.type === "iana" && otherZone.name === this.name;
    }
    /**
     * Return whether this Zone is valid.
     * @override
     * @type {boolean}
     */
    get isValid() {
      return this.valid;
    }
  };

  // node_modules/luxon/src/impl/locale.js
  var intlLFCache = {};
  function getCachedLF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlLFCache[key];
    if (!dtf) {
      dtf = new Intl.ListFormat(locString, opts);
      intlLFCache[key] = dtf;
    }
    return dtf;
  }
  var intlDTCache = {};
  function getCachedDTF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlDTCache[key];
    if (!dtf) {
      dtf = new Intl.DateTimeFormat(locString, opts);
      intlDTCache[key] = dtf;
    }
    return dtf;
  }
  var intlNumCache = {};
  function getCachedINF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let inf = intlNumCache[key];
    if (!inf) {
      inf = new Intl.NumberFormat(locString, opts);
      intlNumCache[key] = inf;
    }
    return inf;
  }
  var intlRelCache = {};
  function getCachedRTF(locString, opts = {}) {
    const { base, ...cacheKeyOpts } = opts;
    const key = JSON.stringify([locString, cacheKeyOpts]);
    let inf = intlRelCache[key];
    if (!inf) {
      inf = new Intl.RelativeTimeFormat(locString, opts);
      intlRelCache[key] = inf;
    }
    return inf;
  }
  var sysLocaleCache = null;
  function systemLocale() {
    if (sysLocaleCache) {
      return sysLocaleCache;
    } else {
      sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
      return sysLocaleCache;
    }
  }
  var weekInfoCache = {};
  function getCachedWeekInfo(locString) {
    let data2 = weekInfoCache[locString];
    if (!data2) {
      const locale2 = new Intl.Locale(locString);
      data2 = "getWeekInfo" in locale2 ? locale2.getWeekInfo() : locale2.weekInfo;
      weekInfoCache[locString] = data2;
    }
    return data2;
  }
  function parseLocaleString(localeStr) {
    const xIndex = localeStr.indexOf("-x-");
    if (xIndex !== -1) {
      localeStr = localeStr.substring(0, xIndex);
    }
    const uIndex = localeStr.indexOf("-u-");
    if (uIndex === -1) {
      return [localeStr];
    } else {
      let options;
      let selectedStr;
      try {
        options = getCachedDTF(localeStr).resolvedOptions();
        selectedStr = localeStr;
      } catch (e3) {
        const smaller = localeStr.substring(0, uIndex);
        options = getCachedDTF(smaller).resolvedOptions();
        selectedStr = smaller;
      }
      const { numberingSystem, calendar } = options;
      return [selectedStr, numberingSystem, calendar];
    }
  }
  function intlConfigString(localeStr, numberingSystem, outputCalendar) {
    if (outputCalendar || numberingSystem) {
      if (!localeStr.includes("-u-")) {
        localeStr += "-u";
      }
      if (outputCalendar) {
        localeStr += `-ca-${outputCalendar}`;
      }
      if (numberingSystem) {
        localeStr += `-nu-${numberingSystem}`;
      }
      return localeStr;
    } else {
      return localeStr;
    }
  }
  function mapMonths(f) {
    const ms2 = [];
    for (let i = 1; i <= 12; i++) {
      const dt = DateTime.utc(2009, i, 1);
      ms2.push(f(dt));
    }
    return ms2;
  }
  function mapWeekdays(f) {
    const ms2 = [];
    for (let i = 1; i <= 7; i++) {
      const dt = DateTime.utc(2016, 11, 13 + i);
      ms2.push(f(dt));
    }
    return ms2;
  }
  function listStuff(loc, length5, englishFn, intlFn) {
    const mode = loc.listingMode();
    if (mode === "error") {
      return null;
    } else if (mode === "en") {
      return englishFn(length5);
    } else {
      return intlFn(length5);
    }
  }
  function supportsFastNumbers(loc) {
    if (loc.numberingSystem && loc.numberingSystem !== "latn") {
      return false;
    } else {
      return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
    }
  }
  var PolyNumberFormatter = class {
    constructor(intl, forceSimple, opts) {
      this.padTo = opts.padTo || 0;
      this.floor = opts.floor || false;
      const { padTo, floor: floor4, ...otherOpts } = opts;
      if (!forceSimple || Object.keys(otherOpts).length > 0) {
        const intlOpts = { useGrouping: false, ...opts };
        if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
        this.inf = getCachedINF(intl, intlOpts);
      }
    }
    format(i) {
      if (this.inf) {
        const fixed = this.floor ? Math.floor(i) : i;
        return this.inf.format(fixed);
      } else {
        const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
        return padStart(fixed, this.padTo);
      }
    }
  };
  var PolyDateFormatter = class {
    constructor(dt, intl, opts) {
      this.opts = opts;
      this.originalZone = void 0;
      let z = void 0;
      if (this.opts.timeZone) {
        this.dt = dt;
      } else if (dt.zone.type === "fixed") {
        const gmtOffset = -1 * (dt.offset / 60);
        const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
        if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
          z = offsetZ;
          this.dt = dt;
        } else {
          z = "UTC";
          this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
          this.originalZone = dt.zone;
        }
      } else if (dt.zone.type === "system") {
        this.dt = dt;
      } else if (dt.zone.type === "iana") {
        this.dt = dt;
        z = dt.zone.name;
      } else {
        z = "UTC";
        this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
      const intlOpts = { ...this.opts };
      intlOpts.timeZone = intlOpts.timeZone || z;
      this.dtf = getCachedDTF(intl, intlOpts);
    }
    format() {
      if (this.originalZone) {
        return this.formatToParts().map(({ value: value2 }) => value2).join("");
      }
      return this.dtf.format(this.dt.toJSDate());
    }
    formatToParts() {
      const parts = this.dtf.formatToParts(this.dt.toJSDate());
      if (this.originalZone) {
        return parts.map((part) => {
          if (part.type === "timeZoneName") {
            const offsetName = this.originalZone.offsetName(this.dt.ts, {
              locale: this.dt.locale,
              format: this.opts.timeZoneName
            });
            return {
              ...part,
              value: offsetName
            };
          } else {
            return part;
          }
        });
      }
      return parts;
    }
    resolvedOptions() {
      return this.dtf.resolvedOptions();
    }
  };
  var PolyRelFormatter = class {
    constructor(intl, isEnglish, opts) {
      this.opts = { style: "long", ...opts };
      if (!isEnglish && hasRelative()) {
        this.rtf = getCachedRTF(intl, opts);
      }
    }
    format(count4, unit) {
      if (this.rtf) {
        return this.rtf.format(count4, unit);
      } else {
        return formatRelativeTime(unit, count4, this.opts.numeric, this.opts.style !== "long");
      }
    }
    formatToParts(count4, unit) {
      if (this.rtf) {
        return this.rtf.formatToParts(count4, unit);
      } else {
        return [];
      }
    }
  };
  var fallbackWeekSettings = {
    firstDay: 1,
    minimalDays: 4,
    weekend: [6, 7]
  };
  var Locale = class _Locale {
    static fromOpts(opts) {
      return _Locale.create(
        opts.locale,
        opts.numberingSystem,
        opts.outputCalendar,
        opts.weekSettings,
        opts.defaultToEN
      );
    }
    static create(locale2, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
      const specifiedLocale = locale2 || Settings.defaultLocale;
      const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
      const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
      const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
      const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
      return new _Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
    }
    static resetCache() {
      sysLocaleCache = null;
      intlDTCache = {};
      intlNumCache = {};
      intlRelCache = {};
    }
    static fromObject({ locale: locale2, numberingSystem, outputCalendar, weekSettings } = {}) {
      return _Locale.create(locale2, numberingSystem, outputCalendar, weekSettings);
    }
    constructor(locale2, numbering, outputCalendar, weekSettings, specifiedLocale) {
      const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale2);
      this.locale = parsedLocale;
      this.numberingSystem = numbering || parsedNumberingSystem || null;
      this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
      this.weekSettings = weekSettings;
      this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
      this.weekdaysCache = { format: {}, standalone: {} };
      this.monthsCache = { format: {}, standalone: {} };
      this.meridiemCache = null;
      this.eraCache = {};
      this.specifiedLocale = specifiedLocale;
      this.fastNumbersCached = null;
    }
    get fastNumbers() {
      if (this.fastNumbersCached == null) {
        this.fastNumbersCached = supportsFastNumbers(this);
      }
      return this.fastNumbersCached;
    }
    listingMode() {
      const isActuallyEn = this.isEnglish();
      const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
      return isActuallyEn && hasNoWeirdness ? "en" : "intl";
    }
    clone(alts) {
      if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
        return this;
      } else {
        return _Locale.create(
          alts.locale || this.specifiedLocale,
          alts.numberingSystem || this.numberingSystem,
          alts.outputCalendar || this.outputCalendar,
          validateWeekSettings(alts.weekSettings) || this.weekSettings,
          alts.defaultToEN || false
        );
      }
    }
    redefaultToEN(alts = {}) {
      return this.clone({ ...alts, defaultToEN: true });
    }
    redefaultToSystem(alts = {}) {
      return this.clone({ ...alts, defaultToEN: false });
    }
    months(length5, format3 = false) {
      return listStuff(this, length5, months, () => {
        const intl = format3 ? { month: length5, day: "numeric" } : { month: length5 }, formatStr = format3 ? "format" : "standalone";
        if (!this.monthsCache[formatStr][length5]) {
          this.monthsCache[formatStr][length5] = mapMonths((dt) => this.extract(dt, intl, "month"));
        }
        return this.monthsCache[formatStr][length5];
      });
    }
    weekdays(length5, format3 = false) {
      return listStuff(this, length5, weekdays, () => {
        const intl = format3 ? { weekday: length5, year: "numeric", month: "long", day: "numeric" } : { weekday: length5 }, formatStr = format3 ? "format" : "standalone";
        if (!this.weekdaysCache[formatStr][length5]) {
          this.weekdaysCache[formatStr][length5] = mapWeekdays(
            (dt) => this.extract(dt, intl, "weekday")
          );
        }
        return this.weekdaysCache[formatStr][length5];
      });
    }
    meridiems() {
      return listStuff(
        this,
        void 0,
        () => meridiems,
        () => {
          if (!this.meridiemCache) {
            const intl = { hour: "numeric", hourCycle: "h12" };
            this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
              (dt) => this.extract(dt, intl, "dayperiod")
            );
          }
          return this.meridiemCache;
        }
      );
    }
    eras(length5) {
      return listStuff(this, length5, eras, () => {
        const intl = { era: length5 };
        if (!this.eraCache[length5]) {
          this.eraCache[length5] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
            (dt) => this.extract(dt, intl, "era")
          );
        }
        return this.eraCache[length5];
      });
    }
    extract(dt, intlOpts, field3) {
      const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m3) => m3.type.toLowerCase() === field3);
      return matching ? matching.value : null;
    }
    numberFormatter(opts = {}) {
      return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
    }
    dtFormatter(dt, intlOpts = {}) {
      return new PolyDateFormatter(dt, this.intl, intlOpts);
    }
    relFormatter(opts = {}) {
      return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
    }
    listFormatter(opts = {}) {
      return getCachedLF(this.intl, opts);
    }
    isEnglish() {
      return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
    }
    getWeekSettings() {
      if (this.weekSettings) {
        return this.weekSettings;
      } else if (!hasLocaleWeekInfo()) {
        return fallbackWeekSettings;
      } else {
        return getCachedWeekInfo(this.locale);
      }
    }
    getStartOfWeek() {
      return this.getWeekSettings().firstDay;
    }
    getMinDaysInFirstWeek() {
      return this.getWeekSettings().minimalDays;
    }
    getWeekendDays() {
      return this.getWeekSettings().weekend;
    }
    equals(other) {
      return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
    }
    toString() {
      return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
    }
  };

  // node_modules/luxon/src/zones/fixedOffsetZone.js
  var singleton2 = null;
  var FixedOffsetZone = class _FixedOffsetZone extends Zone {
    /**
     * Get a singleton instance of UTC
     * @return {FixedOffsetZone}
     */
    static get utcInstance() {
      if (singleton2 === null) {
        singleton2 = new _FixedOffsetZone(0);
      }
      return singleton2;
    }
    /**
     * Get an instance with a specified offset
     * @param {number} offset - The offset in minutes
     * @return {FixedOffsetZone}
     */
    static instance(offset3) {
      return offset3 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset3);
    }
    /**
     * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
     * @param {string} s - The offset string to parse
     * @example FixedOffsetZone.parseSpecifier("UTC+6")
     * @example FixedOffsetZone.parseSpecifier("UTC+06")
     * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
     * @return {FixedOffsetZone}
     */
    static parseSpecifier(s3) {
      if (s3) {
        const r = s3.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
        if (r) {
          return new _FixedOffsetZone(signedOffset(r[1], r[2]));
        }
      }
      return null;
    }
    constructor(offset3) {
      super();
      this.fixed = offset3;
    }
    /**
     * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
     * @override
     * @type {string}
     */
    get type() {
      return "fixed";
    }
    /**
     * The name of this zone.
     * All fixed zones' names always start with "UTC" (plus optional offset)
     * @override
     * @type {string}
     */
    get name() {
      return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
    }
    /**
     * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
     *
     * @override
     * @type {string}
     */
    get ianaName() {
      if (this.fixed === 0) {
        return "Etc/UTC";
      } else {
        return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
      }
    }
    /**
     * Returns the offset's common name at the specified timestamp.
     *
     * For fixed offset zones this equals to the zone name.
     * @override
     */
    offsetName() {
      return this.name;
    }
    /**
     * Returns the offset's value as a string
     * @override
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(ts, format3) {
      return formatOffset(this.fixed, format3);
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year:
     * Always returns true for all fixed offset zones.
     * @override
     * @type {boolean}
     */
    get isUniversal() {
      return true;
    }
    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     *
     * For fixed offset zones, this is constant and does not depend on a timestamp.
     * @override
     * @return {number}
     */
    offset() {
      return this.fixed;
    }
    /**
     * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
     * @override
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(otherZone) {
      return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
    }
    /**
     * Return whether this Zone is valid:
     * All fixed offset zones are valid.
     * @override
     * @type {boolean}
     */
    get isValid() {
      return true;
    }
  };

  // node_modules/luxon/src/zones/invalidZone.js
  var InvalidZone = class extends Zone {
    constructor(zoneName) {
      super();
      this.zoneName = zoneName;
    }
    /** @override **/
    get type() {
      return "invalid";
    }
    /** @override **/
    get name() {
      return this.zoneName;
    }
    /** @override **/
    get isUniversal() {
      return false;
    }
    /** @override **/
    offsetName() {
      return null;
    }
    /** @override **/
    formatOffset() {
      return "";
    }
    /** @override **/
    offset() {
      return NaN;
    }
    /** @override **/
    equals() {
      return false;
    }
    /** @override **/
    get isValid() {
      return false;
    }
  };

  // node_modules/luxon/src/impl/zoneUtil.js
  function normalizeZone(input, defaultZone2) {
    let offset3;
    if (isUndefined(input) || input === null) {
      return defaultZone2;
    } else if (input instanceof Zone) {
      return input;
    } else if (isString(input)) {
      const lowered = input.toLowerCase();
      if (lowered === "default") return defaultZone2;
      else if (lowered === "local" || lowered === "system") return SystemZone.instance;
      else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
      else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
    } else if (isNumber(input)) {
      return FixedOffsetZone.instance(input);
    } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
      return input;
    } else {
      return new InvalidZone(input);
    }
  }

  // node_modules/luxon/src/impl/digits.js
  var numberingSystems = {
    arab: "[\u0660-\u0669]",
    arabext: "[\u06F0-\u06F9]",
    bali: "[\u1B50-\u1B59]",
    beng: "[\u09E6-\u09EF]",
    deva: "[\u0966-\u096F]",
    fullwide: "[\uFF10-\uFF19]",
    gujr: "[\u0AE6-\u0AEF]",
    hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
    khmr: "[\u17E0-\u17E9]",
    knda: "[\u0CE6-\u0CEF]",
    laoo: "[\u0ED0-\u0ED9]",
    limb: "[\u1946-\u194F]",
    mlym: "[\u0D66-\u0D6F]",
    mong: "[\u1810-\u1819]",
    mymr: "[\u1040-\u1049]",
    orya: "[\u0B66-\u0B6F]",
    tamldec: "[\u0BE6-\u0BEF]",
    telu: "[\u0C66-\u0C6F]",
    thai: "[\u0E50-\u0E59]",
    tibt: "[\u0F20-\u0F29]",
    latn: "\\d"
  };
  var numberingSystemsUTF16 = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881]
  };
  var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
  function parseDigits(str7) {
    let value2 = parseInt(str7, 10);
    if (isNaN(value2)) {
      value2 = "";
      for (let i = 0; i < str7.length; i++) {
        const code = str7.charCodeAt(i);
        if (str7[i].search(numberingSystems.hanidec) !== -1) {
          value2 += hanidecChars.indexOf(str7[i]);
        } else {
          for (const key in numberingSystemsUTF16) {
            const [min10, max11] = numberingSystemsUTF16[key];
            if (code >= min10 && code <= max11) {
              value2 += code - min10;
            }
          }
        }
      }
      return parseInt(value2, 10);
    } else {
      return value2;
    }
  }
  var digitRegexCache = {};
  function resetDigitRegexCache() {
    digitRegexCache = {};
  }
  function digitRegex({ numberingSystem }, append3 = "") {
    const ns = numberingSystem || "latn";
    if (!digitRegexCache[ns]) {
      digitRegexCache[ns] = {};
    }
    if (!digitRegexCache[ns][append3]) {
      digitRegexCache[ns][append3] = new RegExp(`${numberingSystems[ns]}${append3}`);
    }
    return digitRegexCache[ns][append3];
  }

  // node_modules/luxon/src/settings.js
  var now2 = () => Date.now();
  var defaultZone = "system";
  var defaultLocale = null;
  var defaultNumberingSystem = null;
  var defaultOutputCalendar = null;
  var twoDigitCutoffYear = 60;
  var throwOnInvalid;
  var defaultWeekSettings = null;
  var Settings = class {
    /**
     * Get the callback for returning the current timestamp.
     * @type {function}
     */
    static get now() {
      return now2;
    }
    /**
     * Set the callback for returning the current timestamp.
     * The function should return a number, which will be interpreted as an Epoch millisecond count
     * @type {function}
     * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
     * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
     */
    static set now(n2) {
      now2 = n2;
    }
    /**
     * Set the default time zone to create DateTimes in. Does not affect existing instances.
     * Use the value "system" to reset this value to the system's time zone.
     * @type {string}
     */
    static set defaultZone(zone) {
      defaultZone = zone;
    }
    /**
     * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
     * The default value is the system's time zone (the one set on the machine that runs this code).
     * @type {Zone}
     */
    static get defaultZone() {
      return normalizeZone(defaultZone, SystemZone.instance);
    }
    /**
     * Get the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultLocale() {
      return defaultLocale;
    }
    /**
     * Set the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultLocale(locale2) {
      defaultLocale = locale2;
    }
    /**
     * Get the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultNumberingSystem() {
      return defaultNumberingSystem;
    }
    /**
     * Set the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultNumberingSystem(numberingSystem) {
      defaultNumberingSystem = numberingSystem;
    }
    /**
     * Get the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultOutputCalendar() {
      return defaultOutputCalendar;
    }
    /**
     * Set the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultOutputCalendar(outputCalendar) {
      defaultOutputCalendar = outputCalendar;
    }
    /**
     * @typedef {Object} WeekSettings
     * @property {number} firstDay
     * @property {number} minimalDays
     * @property {number[]} weekend
     */
    /**
     * @return {WeekSettings|null}
     */
    static get defaultWeekSettings() {
      return defaultWeekSettings;
    }
    /**
     * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
     * how many days are required in the first week of a year.
     * Does not affect existing instances.
     *
     * @param {WeekSettings|null} weekSettings
     */
    static set defaultWeekSettings(weekSettings) {
      defaultWeekSettings = validateWeekSettings(weekSettings);
    }
    /**
     * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
     * @type {number}
     */
    static get twoDigitCutoffYear() {
      return twoDigitCutoffYear;
    }
    /**
     * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
     * @type {number}
     * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
     * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
     * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
     * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
     * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
     */
    static set twoDigitCutoffYear(cutoffYear) {
      twoDigitCutoffYear = cutoffYear % 100;
    }
    /**
     * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    static get throwOnInvalid() {
      return throwOnInvalid;
    }
    /**
     * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    static set throwOnInvalid(t) {
      throwOnInvalid = t;
    }
    /**
     * Reset Luxon's global caches. Should only be necessary in testing scenarios.
     * @return {void}
     */
    static resetCaches() {
      Locale.resetCache();
      IANAZone.resetCache();
      DateTime.resetCache();
      resetDigitRegexCache();
    }
  };

  // node_modules/luxon/src/impl/invalid.js
  var Invalid = class {
    constructor(reason, explanation) {
      this.reason = reason;
      this.explanation = explanation;
    }
    toMessage() {
      if (this.explanation) {
        return `${this.reason}: ${this.explanation}`;
      } else {
        return this.reason;
      }
    }
  };

  // node_modules/luxon/src/impl/conversions.js
  var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  function unitOutOfRange(unit, value2) {
    return new Invalid(
      "unit out of range",
      `you specified ${value2} (of type ${typeof value2}) as a ${unit}, which is invalid`
    );
  }
  function dayOfWeek(year2, month2, day2) {
    const d3 = new Date(Date.UTC(year2, month2 - 1, day2));
    if (year2 < 100 && year2 >= 0) {
      d3.setUTCFullYear(d3.getUTCFullYear() - 1900);
    }
    const js = d3.getUTCDay();
    return js === 0 ? 7 : js;
  }
  function computeOrdinal(year2, month2, day2) {
    return day2 + (isLeapYear(year2) ? leapLadder : nonLeapLadder)[month2 - 1];
  }
  function uncomputeOrdinal(year2, ordinal) {
    const table = isLeapYear(year2) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day2 = ordinal - table[month0];
    return { month: month0 + 1, day: day2 };
  }
  function isoWeekdayToLocal(isoWeekday, startOfWeek) {
    return (isoWeekday - startOfWeek + 7) % 7 + 1;
  }
  function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const { year: year2, month: month2, day: day2 } = gregObj, ordinal = computeOrdinal(year2, month2, day2), weekday = isoWeekdayToLocal(dayOfWeek(year2, month2, day2), startOfWeek);
    let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
    if (weekNumber < 1) {
      weekYear = year2 - 1;
      weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
    } else if (weekNumber > weeksInWeekYear(year2, minDaysInFirstWeek, startOfWeek)) {
      weekYear = year2 + 1;
      weekNumber = 1;
    } else {
      weekYear = year2;
    }
    return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
  }
  function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
    let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year2;
    if (ordinal < 1) {
      year2 = weekYear - 1;
      ordinal += daysInYear(year2);
    } else if (ordinal > yearInDays) {
      year2 = weekYear + 1;
      ordinal -= daysInYear(weekYear);
    } else {
      year2 = weekYear;
    }
    const { month: month2, day: day2 } = uncomputeOrdinal(year2, ordinal);
    return { year: year2, month: month2, day: day2, ...timeObject(weekData) };
  }
  function gregorianToOrdinal(gregData) {
    const { year: year2, month: month2, day: day2 } = gregData;
    const ordinal = computeOrdinal(year2, month2, day2);
    return { year: year2, ordinal, ...timeObject(gregData) };
  }
  function ordinalToGregorian(ordinalData) {
    const { year: year2, ordinal } = ordinalData;
    const { month: month2, day: day2 } = uncomputeOrdinal(year2, ordinal);
    return { year: year2, month: month2, day: day2, ...timeObject(ordinalData) };
  }
  function usesLocalWeekValues(obj, loc) {
    const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
    if (hasLocaleWeekData) {
      const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
      if (hasIsoWeekData) {
        throw new ConflictingSpecificationError(
          "Cannot mix locale-based week fields with ISO-based week fields"
        );
      }
      if (!isUndefined(obj.localWeekday)) obj.weekday = obj.localWeekday;
      if (!isUndefined(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;
      if (!isUndefined(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;
      delete obj.localWeekday;
      delete obj.localWeekNumber;
      delete obj.localWeekYear;
      return {
        minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
        startOfWeek: loc.getStartOfWeek()
      };
    } else {
      return { minDaysInFirstWeek: 4, startOfWeek: 1 };
    }
  }
  function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
      obj.weekNumber,
      1,
      weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
    ), validWeekday = integerBetween(obj.weekday, 1, 7);
    if (!validYear) {
      return unitOutOfRange("weekYear", obj.weekYear);
    } else if (!validWeek) {
      return unitOutOfRange("week", obj.weekNumber);
    } else if (!validWeekday) {
      return unitOutOfRange("weekday", obj.weekday);
    } else return false;
  }
  function hasInvalidOrdinalData(obj) {
    const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validOrdinal) {
      return unitOutOfRange("ordinal", obj.ordinal);
    } else return false;
  }
  function hasInvalidGregorianData(obj) {
    const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validMonth) {
      return unitOutOfRange("month", obj.month);
    } else if (!validDay) {
      return unitOutOfRange("day", obj.day);
    } else return false;
  }
  function hasInvalidTimeData(obj) {
    const { hour: hour2, minute: minute2, second: second2, millisecond: millisecond2 } = obj;
    const validHour = integerBetween(hour2, 0, 23) || hour2 === 24 && minute2 === 0 && second2 === 0 && millisecond2 === 0, validMinute = integerBetween(minute2, 0, 59), validSecond = integerBetween(second2, 0, 59), validMillisecond = integerBetween(millisecond2, 0, 999);
    if (!validHour) {
      return unitOutOfRange("hour", hour2);
    } else if (!validMinute) {
      return unitOutOfRange("minute", minute2);
    } else if (!validSecond) {
      return unitOutOfRange("second", second2);
    } else if (!validMillisecond) {
      return unitOutOfRange("millisecond", millisecond2);
    } else return false;
  }

  // node_modules/luxon/src/impl/util.js
  function isUndefined(o) {
    return typeof o === "undefined";
  }
  function isNumber(o) {
    return typeof o === "number";
  }
  function isInteger(o) {
    return typeof o === "number" && o % 1 === 0;
  }
  function isString(o) {
    return typeof o === "string";
  }
  function isDate(o) {
    return Object.prototype.toString.call(o) === "[object Date]";
  }
  function hasRelative() {
    try {
      return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
    } catch (e3) {
      return false;
    }
  }
  function hasLocaleWeekInfo() {
    try {
      return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
    } catch (e3) {
      return false;
    }
  }
  function maybeArray(thing) {
    return Array.isArray(thing) ? thing : [thing];
  }
  function bestBy(arr, by, compare) {
    if (arr.length === 0) {
      return void 0;
    }
    return arr.reduce((best, next) => {
      const pair = [by(next), next];
      if (!best) {
        return pair;
      } else if (compare(best[0], pair[0]) === best[0]) {
        return best;
      } else {
        return pair;
      }
    }, null)[1];
  }
  function pick(obj, keys2) {
    return keys2.reduce((a3, k) => {
      a3[k] = obj[k];
      return a3;
    }, {});
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function validateWeekSettings(settings) {
    if (settings == null) {
      return null;
    } else if (typeof settings !== "object") {
      throw new InvalidArgumentError("Week settings must be an object");
    } else {
      if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
        throw new InvalidArgumentError("Invalid week settings");
      }
      return {
        firstDay: settings.firstDay,
        minimalDays: settings.minimalDays,
        weekend: Array.from(settings.weekend)
      };
    }
  }
  function integerBetween(thing, bottom, top) {
    return isInteger(thing) && thing >= bottom && thing <= top;
  }
  function floorMod(x3, n2) {
    return x3 - n2 * Math.floor(x3 / n2);
  }
  function padStart(input, n2 = 2) {
    const isNeg = input < 0;
    let padded;
    if (isNeg) {
      padded = "-" + ("" + -input).padStart(n2, "0");
    } else {
      padded = ("" + input).padStart(n2, "0");
    }
    return padded;
  }
  function parseInteger(string) {
    if (isUndefined(string) || string === null || string === "") {
      return void 0;
    } else {
      return parseInt(string, 10);
    }
  }
  function parseFloating(string) {
    if (isUndefined(string) || string === null || string === "") {
      return void 0;
    } else {
      return parseFloat(string);
    }
  }
  function parseMillis(fraction) {
    if (isUndefined(fraction) || fraction === null || fraction === "") {
      return void 0;
    } else {
      const f = parseFloat("0." + fraction) * 1e3;
      return Math.floor(f);
    }
  }
  function roundTo(number3, digits, towardZero = false) {
    const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
    return rounder(number3 * factor) / factor;
  }
  function isLeapYear(year2) {
    return year2 % 4 === 0 && (year2 % 100 !== 0 || year2 % 400 === 0);
  }
  function daysInYear(year2) {
    return isLeapYear(year2) ? 366 : 365;
  }
  function daysInMonth(year2, month2) {
    const modMonth = floorMod(month2 - 1, 12) + 1, modYear = year2 + (month2 - modMonth) / 12;
    if (modMonth === 2) {
      return isLeapYear(modYear) ? 29 : 28;
    } else {
      return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
    }
  }
  function objToLocalTS(obj) {
    let d3 = Date.UTC(
      obj.year,
      obj.month - 1,
      obj.day,
      obj.hour,
      obj.minute,
      obj.second,
      obj.millisecond
    );
    if (obj.year < 100 && obj.year >= 0) {
      d3 = new Date(d3);
      d3.setUTCFullYear(obj.year, obj.month - 1, obj.day);
    }
    return +d3;
  }
  function firstWeekOffset(year2, minDaysInFirstWeek, startOfWeek) {
    const fwdlw = isoWeekdayToLocal(dayOfWeek(year2, 1, minDaysInFirstWeek), startOfWeek);
    return -fwdlw + minDaysInFirstWeek - 1;
  }
  function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
    const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
    return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
  }
  function untruncateYear(year2) {
    if (year2 > 99) {
      return year2;
    } else return year2 > Settings.twoDigitCutoffYear ? 1900 + year2 : 2e3 + year2;
  }
  function parseZoneInfo(ts, offsetFormat, locale2, timeZone = null) {
    const date = new Date(ts), intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    };
    if (timeZone) {
      intlOpts.timeZone = timeZone;
    }
    const modified = { timeZoneName: offsetFormat, ...intlOpts };
    const parsed = new Intl.DateTimeFormat(locale2, modified).formatToParts(date).find((m3) => m3.type.toLowerCase() === "timezonename");
    return parsed ? parsed.value : null;
  }
  function signedOffset(offHourStr, offMinuteStr) {
    let offHour = parseInt(offHourStr, 10);
    if (Number.isNaN(offHour)) {
      offHour = 0;
    }
    const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
    return offHour * 60 + offMinSigned;
  }
  function asNumber(value2) {
    const numericValue = Number(value2);
    if (typeof value2 === "boolean" || value2 === "" || Number.isNaN(numericValue))
      throw new InvalidArgumentError(`Invalid unit value ${value2}`);
    return numericValue;
  }
  function normalizeObject(obj, normalizer) {
    const normalized = {};
    for (const u in obj) {
      if (hasOwnProperty(obj, u)) {
        const v = obj[u];
        if (v === void 0 || v === null) continue;
        normalized[normalizer(u)] = asNumber(v);
      }
    }
    return normalized;
  }
  function formatOffset(offset3, format3) {
    const hours = Math.trunc(Math.abs(offset3 / 60)), minutes = Math.trunc(Math.abs(offset3 % 60)), sign3 = offset3 >= 0 ? "+" : "-";
    switch (format3) {
      case "short":
        return `${sign3}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
      case "narrow":
        return `${sign3}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
      case "techie":
        return `${sign3}${padStart(hours, 2)}${padStart(minutes, 2)}`;
      default:
        throw new RangeError(`Value format ${format3} is out of range for property format`);
    }
  }
  function timeObject(obj) {
    return pick(obj, ["hour", "minute", "second", "millisecond"]);
  }

  // node_modules/luxon/src/impl/english.js
  var monthsLong = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  var monthsShort = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
  function months(length5) {
    switch (length5) {
      case "narrow":
        return [...monthsNarrow];
      case "short":
        return [...monthsShort];
      case "long":
        return [...monthsLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
      case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
      default:
        return null;
    }
  }
  var weekdaysLong = [
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Sunday"
  ];
  var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
  function weekdays(length5) {
    switch (length5) {
      case "narrow":
        return [...weekdaysNarrow];
      case "short":
        return [...weekdaysShort];
      case "long":
        return [...weekdaysLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
      default:
        return null;
    }
  }
  var meridiems = ["AM", "PM"];
  var erasLong = ["Before Christ", "Anno Domini"];
  var erasShort = ["BC", "AD"];
  var erasNarrow = ["B", "A"];
  function eras(length5) {
    switch (length5) {
      case "narrow":
        return [...erasNarrow];
      case "short":
        return [...erasShort];
      case "long":
        return [...erasLong];
      default:
        return null;
    }
  }
  function meridiemForDateTime(dt) {
    return meridiems[dt.hour < 12 ? 0 : 1];
  }
  function weekdayForDateTime(dt, length5) {
    return weekdays(length5)[dt.weekday - 1];
  }
  function monthForDateTime(dt, length5) {
    return months(length5)[dt.month - 1];
  }
  function eraForDateTime(dt, length5) {
    return eras(length5)[dt.year < 0 ? 0 : 1];
  }
  function formatRelativeTime(unit, count4, numeric = "always", narrow = false) {
    const units = {
      years: ["year", "yr."],
      quarters: ["quarter", "qtr."],
      months: ["month", "mo."],
      weeks: ["week", "wk."],
      days: ["day", "day", "days"],
      hours: ["hour", "hr."],
      minutes: ["minute", "min."],
      seconds: ["second", "sec."]
    };
    const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
    if (numeric === "auto" && lastable) {
      const isDay = unit === "days";
      switch (count4) {
        case 1:
          return isDay ? "tomorrow" : `next ${units[unit][0]}`;
        case -1:
          return isDay ? "yesterday" : `last ${units[unit][0]}`;
        case 0:
          return isDay ? "today" : `this ${units[unit][0]}`;
        default:
      }
    }
    const isInPast = Object.is(count4, -0) || count4 < 0, fmtValue = Math.abs(count4), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
    return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
  }

  // node_modules/luxon/src/impl/formatter.js
  function stringifyTokens(splits, tokenToString) {
    let s3 = "";
    for (const token2 of splits) {
      if (token2.literal) {
        s3 += token2.val;
      } else {
        s3 += tokenToString(token2.val);
      }
    }
    return s3;
  }
  var macroTokenToFormatOpts = {
    D: DATE_SHORT,
    DD: DATE_MED,
    DDD: DATE_FULL,
    DDDD: DATE_HUGE,
    t: TIME_SIMPLE,
    tt: TIME_WITH_SECONDS,
    ttt: TIME_WITH_SHORT_OFFSET,
    tttt: TIME_WITH_LONG_OFFSET,
    T: TIME_24_SIMPLE,
    TT: TIME_24_WITH_SECONDS,
    TTT: TIME_24_WITH_SHORT_OFFSET,
    TTTT: TIME_24_WITH_LONG_OFFSET,
    f: DATETIME_SHORT,
    ff: DATETIME_MED,
    fff: DATETIME_FULL,
    ffff: DATETIME_HUGE,
    F: DATETIME_SHORT_WITH_SECONDS,
    FF: DATETIME_MED_WITH_SECONDS,
    FFF: DATETIME_FULL_WITH_SECONDS,
    FFFF: DATETIME_HUGE_WITH_SECONDS
  };
  var Formatter = class _Formatter {
    static create(locale2, opts = {}) {
      return new _Formatter(locale2, opts);
    }
    static parseFormat(fmt) {
      let current = null, currentFull = "", bracketed = false;
      const splits = [];
      for (let i = 0; i < fmt.length; i++) {
        const c5 = fmt.charAt(i);
        if (c5 === "'") {
          if (currentFull.length > 0) {
            splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
          }
          current = null;
          currentFull = "";
          bracketed = !bracketed;
        } else if (bracketed) {
          currentFull += c5;
        } else if (c5 === current) {
          currentFull += c5;
        } else {
          if (currentFull.length > 0) {
            splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
          }
          currentFull = c5;
          current = c5;
        }
      }
      if (currentFull.length > 0) {
        splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
      }
      return splits;
    }
    static macroTokenToFormatOpts(token2) {
      return macroTokenToFormatOpts[token2];
    }
    constructor(locale2, formatOpts) {
      this.opts = formatOpts;
      this.loc = locale2;
      this.systemLoc = null;
    }
    formatWithSystemDefault(dt, opts) {
      if (this.systemLoc === null) {
        this.systemLoc = this.loc.redefaultToSystem();
      }
      const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
      return df.format();
    }
    dtFormatter(dt, opts = {}) {
      return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    }
    formatDateTime(dt, opts) {
      return this.dtFormatter(dt, opts).format();
    }
    formatDateTimeParts(dt, opts) {
      return this.dtFormatter(dt, opts).formatToParts();
    }
    formatInterval(interval2, opts) {
      const df = this.dtFormatter(interval2.start, opts);
      return df.dtf.formatRange(interval2.start.toJSDate(), interval2.end.toJSDate());
    }
    resolvedOptions(dt, opts) {
      return this.dtFormatter(dt, opts).resolvedOptions();
    }
    num(n2, p2 = 0) {
      if (this.opts.forceSimple) {
        return padStart(n2, p2);
      }
      const opts = { ...this.opts };
      if (p2 > 0) {
        opts.padTo = p2;
      }
      return this.loc.numberFormatter(opts).format(n2);
    }
    formatDateTimeFromString(dt, fmt) {
      const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }
        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month2 = (length5, standalone) => knownEnglish ? monthForDateTime(dt, length5) : string(standalone ? { month: length5 } : { month: length5, day: "numeric" }, "month"), weekday = (length5, standalone) => knownEnglish ? weekdayForDateTime(dt, length5) : string(
        standalone ? { weekday: length5 } : { weekday: length5, month: "long", day: "numeric" },
        "weekday"
      ), maybeMacro = (token2) => {
        const formatOpts = _Formatter.macroTokenToFormatOpts(token2);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token2;
        }
      }, era = (length5) => knownEnglish ? eraForDateTime(dt, length5) : string({ era: length5 }, "era"), tokenToString = (token2) => {
        switch (token2) {
          // ms
          case "S":
            return this.num(dt.millisecond);
          case "u":
          // falls through
          case "SSS":
            return this.num(dt.millisecond, 3);
          // seconds
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          // fractional seconds
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          // minutes
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          // hours
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          // offset
          case "Z":
            return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
          case "ZZ":
            return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
          case "ZZZ":
            return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
          case "ZZZZ":
            return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
          case "ZZZZZ":
            return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
          // zone
          case "z":
            return dt.zoneName;
          // meridiems
          case "a":
            return meridiem();
          // dates
          case "d":
            return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
          // weekdays - standalone
          case "c":
            return this.num(dt.weekday);
          case "ccc":
            return weekday("short", true);
          case "cccc":
            return weekday("long", true);
          case "ccccc":
            return weekday("narrow", true);
          // weekdays - format
          case "E":
            return this.num(dt.weekday);
          case "EEE":
            return weekday("short", false);
          case "EEEE":
            return weekday("long", false);
          case "EEEEE":
            return weekday("narrow", false);
          // months - standalone
          case "L":
            return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
          case "LL":
            return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
          case "LLL":
            return month2("short", true);
          case "LLLL":
            return month2("long", true);
          case "LLLLL":
            return month2("narrow", true);
          // months - format
          case "M":
            return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
          case "MM":
            return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
          case "MMM":
            return month2("short", false);
          case "MMMM":
            return month2("long", false);
          case "MMMMM":
            return month2("narrow", false);
          // years
          case "y":
            return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
          case "yy":
            return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
          case "yyyyyy":
            return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
          // eras
          case "G":
            return era("short");
          case "GG":
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "n":
            return this.num(dt.localWeekNumber);
          case "nn":
            return this.num(dt.localWeekNumber, 2);
          case "ii":
            return this.num(dt.localWeekYear.toString().slice(-2), 2);
          case "iiii":
            return this.num(dt.localWeekYear, 4);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            return this.num(dt.quarter);
          case "qq":
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1e3));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token2);
        }
      };
      return stringifyTokens(_Formatter.parseFormat(fmt), tokenToString);
    }
    formatDurationFromString(dur, fmt) {
      const tokenToField = (token2) => {
        switch (token2[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      }, tokenToString = (lildur) => (token2) => {
        const mapped = tokenToField(token2);
        if (mapped) {
          return this.num(lildur.get(mapped), token2.length);
        } else {
          return token2;
        }
      }, tokens4 = _Formatter.parseFormat(fmt), realTokens = tokens4.reduce(
        (found, { literal: literal2, val }) => literal2 ? found : found.concat(val),
        []
      ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
      return stringifyTokens(tokens4, tokenToString(collapsed));
    }
  };

  // node_modules/luxon/src/impl/regexParser.js
  var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
  function combineRegexes(...regexes) {
    const full = regexes.reduce((f, r) => f + r.source, "");
    return RegExp(`^${full}$`);
  }
  function combineExtractors(...extractors) {
    return (m3) => extractors.reduce(
      ([mergedVals, mergedZone, cursor], ex) => {
        const [val, zone, next] = ex(m3, cursor);
        return [{ ...mergedVals, ...val }, zone || mergedZone, next];
      },
      [{}, null, 1]
    ).slice(0, 2);
  }
  function parse(s3, ...patterns) {
    if (s3 == null) {
      return [null, null];
    }
    for (const [regex, extractor] of patterns) {
      const m3 = regex.exec(s3);
      if (m3) {
        return extractor(m3);
      }
    }
    return [null, null];
  }
  function simpleParse(...keys2) {
    return (match2, cursor) => {
      const ret = {};
      let i;
      for (i = 0; i < keys2.length; i++) {
        ret[keys2[i]] = parseInteger(match2[cursor + i]);
      }
      return [ret, null, cursor + i];
    };
  }
  var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
  var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
  var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
  var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
  var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
  var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
  var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
  var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
  var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
  var extractISOOrdinalData = simpleParse("year", "ordinal");
  var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
  var sqlTimeRegex = RegExp(
    `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
  );
  var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
  function int(match2, pos, fallback) {
    const m3 = match2[pos];
    return isUndefined(m3) ? fallback : parseInteger(m3);
  }
  function extractISOYmd(match2, cursor) {
    const item = {
      year: int(match2, cursor),
      month: int(match2, cursor + 1, 1),
      day: int(match2, cursor + 2, 1)
    };
    return [item, null, cursor + 3];
  }
  function extractISOTime(match2, cursor) {
    const item = {
      hours: int(match2, cursor, 0),
      minutes: int(match2, cursor + 1, 0),
      seconds: int(match2, cursor + 2, 0),
      milliseconds: parseMillis(match2[cursor + 3])
    };
    return [item, null, cursor + 4];
  }
  function extractISOOffset(match2, cursor) {
    const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
    return [{}, zone, cursor + 3];
  }
  function extractIANAZone(match2, cursor) {
    const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
    return [{}, zone, cursor + 1];
  }
  var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
  var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
  function extractISODuration(match2) {
    const [s3, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
    const hasNegativePrefix = s3[0] === "-";
    const negativeSeconds = secondStr && secondStr[0] === "-";
    const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
    return [
      {
        years: maybeNegate(parseFloating(yearStr)),
        months: maybeNegate(parseFloating(monthStr)),
        weeks: maybeNegate(parseFloating(weekStr)),
        days: maybeNegate(parseFloating(dayStr)),
        hours: maybeNegate(parseFloating(hourStr)),
        minutes: maybeNegate(parseFloating(minuteStr)),
        seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
        milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
      }
    ];
  }
  var obsOffsets = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    const result = {
      year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
      month: monthsShort.indexOf(monthStr) + 1,
      day: parseInteger(dayStr),
      hour: parseInteger(hourStr),
      minute: parseInteger(minuteStr)
    };
    if (secondStr) result.second = parseInteger(secondStr);
    if (weekdayStr) {
      result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
    }
    return result;
  }
  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
  function extractRFC2822(match2) {
    const [
      ,
      weekdayStr,
      dayStr,
      monthStr,
      yearStr,
      hourStr,
      minuteStr,
      secondStr,
      obsOffset,
      milOffset,
      offHourStr,
      offMinuteStr
    ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    let offset3;
    if (obsOffset) {
      offset3 = obsOffsets[obsOffset];
    } else if (milOffset) {
      offset3 = 0;
    } else {
      offset3 = signedOffset(offHourStr, offMinuteStr);
    }
    return [result, new FixedOffsetZone(offset3)];
  }
  function preprocessRFC2822(s3) {
    return s3.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
  }
  var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
  var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
  var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
  function extractRFC1123Or850(match2) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }
  function extractASCII(match2) {
    const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }
  var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
  var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
  var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
  var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
  var extractISOYmdTimeAndOffset = combineExtractors(
    extractISOYmd,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  var extractISOWeekTimeAndOffset = combineExtractors(
    extractISOWeekData,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  var extractISOOrdinalDateAndTime = combineExtractors(
    extractISOOrdinalData,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  var extractISOTimeAndOffset = combineExtractors(
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  function parseISODate(s3) {
    return parse(
      s3,
      [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
      [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
      [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
      [isoTimeCombinedRegex, extractISOTimeAndOffset]
    );
  }
  function parseRFC2822Date(s3) {
    return parse(preprocessRFC2822(s3), [rfc2822, extractRFC2822]);
  }
  function parseHTTPDate(s3) {
    return parse(
      s3,
      [rfc1123, extractRFC1123Or850],
      [rfc850, extractRFC1123Or850],
      [ascii, extractASCII]
    );
  }
  function parseISODuration(s3) {
    return parse(s3, [isoDuration, extractISODuration]);
  }
  var extractISOTimeOnly = combineExtractors(extractISOTime);
  function parseISOTimeOnly(s3) {
    return parse(s3, [isoTimeOnly, extractISOTimeOnly]);
  }
  var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
  var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
  var extractISOTimeOffsetAndIANAZone = combineExtractors(
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  function parseSQL(s3) {
    return parse(
      s3,
      [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
      [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
    );
  }

  // node_modules/luxon/src/duration.js
  var INVALID = "Invalid Duration";
  var lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1e3
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1e3
    },
    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
    minutes: { seconds: 60, milliseconds: 60 * 1e3 },
    seconds: { milliseconds: 1e3 }
  };
  var casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1e3
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1e3
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1e3
    },
    ...lowOrderMatrix
  };
  var daysInYearAccurate = 146097 / 400;
  var daysInMonthAccurate = 146097 / 4800;
  var accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: daysInYearAccurate * 24 / 4,
      minutes: daysInYearAccurate * 24 * 60 / 4,
      seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
    },
    ...lowOrderMatrix
  };
  var orderedUnits = [
    "years",
    "quarters",
    "months",
    "weeks",
    "days",
    "hours",
    "minutes",
    "seconds",
    "milliseconds"
  ];
  var reverseUnits = orderedUnits.slice(0).reverse();
  function clone(dur, alts, clear = false) {
    const conf = {
      values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
      loc: dur.loc.clone(alts.loc),
      conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
      matrix: alts.matrix || dur.matrix
    };
    return new Duration(conf);
  }
  function durationToMillis(matrix3, vals) {
    let sum3 = vals.milliseconds ?? 0;
    for (const unit of reverseUnits.slice(1)) {
      if (vals[unit]) {
        sum3 += vals[unit] * matrix3[unit]["milliseconds"];
      }
    }
    return sum3;
  }
  function normalizeValues(matrix3, vals) {
    const factor = durationToMillis(matrix3, vals) < 0 ? -1 : 1;
    orderedUnits.reduceRight((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const previousVal = vals[previous] * factor;
          const conv = matrix3[current][previous];
          const rollUp = Math.floor(previousVal / conv);
          vals[current] += rollUp * factor;
          vals[previous] -= rollUp * conv * factor;
        }
        return current;
      } else {
        return previous;
      }
    }, null);
    orderedUnits.reduce((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const fraction = vals[previous] % 1;
          vals[previous] -= fraction;
          vals[current] += fraction * matrix3[previous][current];
        }
        return current;
      } else {
        return previous;
      }
    }, null);
  }
  function removeZeroes(vals) {
    const newVals = {};
    for (const [key, value2] of Object.entries(vals)) {
      if (value2 !== 0) {
        newVals[key] = value2;
      }
    }
    return newVals;
  }
  var Duration = class _Duration {
    /**
     * @private
     */
    constructor(config2) {
      const accurate = config2.conversionAccuracy === "longterm" || false;
      let matrix3 = accurate ? accurateMatrix : casualMatrix;
      if (config2.matrix) {
        matrix3 = config2.matrix;
      }
      this.values = config2.values;
      this.loc = config2.loc || Locale.create();
      this.conversionAccuracy = accurate ? "longterm" : "casual";
      this.invalid = config2.invalid || null;
      this.matrix = matrix3;
      this.isLuxonDuration = true;
    }
    /**
     * Create Duration from a number of milliseconds.
     * @param {number} count of milliseconds
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @return {Duration}
     */
    static fromMillis(count4, opts) {
      return _Duration.fromObject({ milliseconds: count4 }, opts);
    }
    /**
     * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
     * If this object is empty then a zero milliseconds duration is returned.
     * @param {Object} obj - the object to create the DateTime from
     * @param {number} obj.years
     * @param {number} obj.quarters
     * @param {number} obj.months
     * @param {number} obj.weeks
     * @param {number} obj.days
     * @param {number} obj.hours
     * @param {number} obj.minutes
     * @param {number} obj.seconds
     * @param {number} obj.milliseconds
     * @param {Object} [opts=[]] - options for creating this Duration
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the custom conversion system to use
     * @return {Duration}
     */
    static fromObject(obj, opts = {}) {
      if (obj == null || typeof obj !== "object") {
        throw new InvalidArgumentError(
          `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
        );
      }
      return new _Duration({
        values: normalizeObject(obj, _Duration.normalizeUnit),
        loc: Locale.fromObject(opts),
        conversionAccuracy: opts.conversionAccuracy,
        matrix: opts.matrix
      });
    }
    /**
     * Create a Duration from DurationLike.
     *
     * @param {Object | number | Duration} durationLike
     * One of:
     * - object with keys like 'years' and 'hours'.
     * - number representing milliseconds
     * - Duration instance
     * @return {Duration}
     */
    static fromDurationLike(durationLike) {
      if (isNumber(durationLike)) {
        return _Duration.fromMillis(durationLike);
      } else if (_Duration.isDuration(durationLike)) {
        return durationLike;
      } else if (typeof durationLike === "object") {
        return _Duration.fromObject(durationLike);
      } else {
        throw new InvalidArgumentError(
          `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
        );
      }
    }
    /**
     * Create a Duration from an ISO 8601 duration string.
     * @param {string} text - text to parse
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the preset conversion system to use
     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
     * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
     * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
     * @return {Duration}
     */
    static fromISO(text, opts) {
      const [parsed] = parseISODuration(text);
      if (parsed) {
        return _Duration.fromObject(parsed, opts);
      } else {
        return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    /**
     * Create a Duration from an ISO 8601 time string.
     * @param {string} text - text to parse
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the conversion system to use
     * @see https://en.wikipedia.org/wiki/ISO_8601#Times
     * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
     * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @return {Duration}
     */
    static fromISOTime(text, opts) {
      const [parsed] = parseISOTimeOnly(text);
      if (parsed) {
        return _Duration.fromObject(parsed, opts);
      } else {
        return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    /**
     * Create an invalid Duration.
     * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {Duration}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDurationError(invalid);
      } else {
        return new _Duration({ invalid });
      }
    }
    /**
     * @private
     */
    static normalizeUnit(unit) {
      const normalized = {
        year: "years",
        years: "years",
        quarter: "quarters",
        quarters: "quarters",
        month: "months",
        months: "months",
        week: "weeks",
        weeks: "weeks",
        day: "days",
        days: "days",
        hour: "hours",
        hours: "hours",
        minute: "minutes",
        minutes: "minutes",
        second: "seconds",
        seconds: "seconds",
        millisecond: "milliseconds",
        milliseconds: "milliseconds"
      }[unit ? unit.toLowerCase() : unit];
      if (!normalized) throw new InvalidUnitError(unit);
      return normalized;
    }
    /**
     * Check if an object is a Duration. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isDuration(o) {
      return o && o.isLuxonDuration || false;
    }
    /**
     * Get  the locale of a Duration, such 'en-GB'
     * @type {string}
     */
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
     *
     * @type {string}
     */
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    /**
     * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
     * * `S` for milliseconds
     * * `s` for seconds
     * * `m` for minutes
     * * `h` for hours
     * * `d` for days
     * * `w` for weeks
     * * `M` for months
     * * `y` for years
     * Notes:
     * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
     * * Tokens can be escaped by wrapping with single quotes.
     * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
     * @param {string} fmt - the format string
     * @param {Object} opts - options
     * @param {boolean} [opts.floor=true] - floor numerical values
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
     * @return {string}
     */
    toFormat(fmt, opts = {}) {
      const fmtOpts = {
        ...opts,
        floor: opts.round !== false && opts.floor !== false
      };
      return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
    }
    /**
     * Returns a string representation of a Duration with all units included.
     * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
     * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
     * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
     * @example
     * ```js
     * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
     * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
     * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
     * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
     * ```
     */
    toHuman(opts = {}) {
      if (!this.isValid) return INVALID;
      const l2 = orderedUnits.map((unit) => {
        const val = this.values[unit];
        if (isUndefined(val)) {
          return null;
        }
        return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
      }).filter((n2) => n2);
      return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
    }
    /**
     * Returns a JavaScript object with this Duration's values.
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
     * @return {Object}
     */
    toObject() {
      if (!this.isValid) return {};
      return { ...this.values };
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Duration.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
     * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
     * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
     * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
     * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
     * @return {string}
     */
    toISO() {
      if (!this.isValid) return null;
      let s3 = "P";
      if (this.years !== 0) s3 += this.years + "Y";
      if (this.months !== 0 || this.quarters !== 0) s3 += this.months + this.quarters * 3 + "M";
      if (this.weeks !== 0) s3 += this.weeks + "W";
      if (this.days !== 0) s3 += this.days + "D";
      if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
        s3 += "T";
      if (this.hours !== 0) s3 += this.hours + "H";
      if (this.minutes !== 0) s3 += this.minutes + "M";
      if (this.seconds !== 0 || this.milliseconds !== 0)
        s3 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
      if (s3 === "P") s3 += "T0S";
      return s3;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
     * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Times
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
     * @return {string}
     */
    toISOTime(opts = {}) {
      if (!this.isValid) return null;
      const millis = this.toMillis();
      if (millis < 0 || millis >= 864e5) return null;
      opts = {
        suppressMilliseconds: false,
        suppressSeconds: false,
        includePrefix: false,
        format: "extended",
        ...opts,
        includeOffset: false
      };
      const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
      return dateTime.toISOTime(opts);
    }
    /**
     * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
     * @return {string}
     */
    toJSON() {
      return this.toISO();
    }
    /**
     * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
     * @return {string}
     */
    toString() {
      return this.toISO();
    }
    /**
     * Returns a string representation of this Duration appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Duration { values: ${JSON.stringify(this.values)} }`;
      } else {
        return `Duration { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    /**
     * Returns an milliseconds value of this Duration.
     * @return {number}
     */
    toMillis() {
      if (!this.isValid) return NaN;
      return durationToMillis(this.matrix, this.values);
    }
    /**
     * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
     * @return {number}
     */
    valueOf() {
      return this.toMillis();
    }
    /**
     * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
     * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @return {Duration}
     */
    plus(duration) {
      if (!this.isValid) return this;
      const dur = _Duration.fromDurationLike(duration), result = {};
      for (const k of orderedUnits) {
        if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
          result[k] = dur.get(k) + this.get(k);
        }
      }
      return clone(this, { values: result }, true);
    }
    /**
     * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
     * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @return {Duration}
     */
    minus(duration) {
      if (!this.isValid) return this;
      const dur = _Duration.fromDurationLike(duration);
      return this.plus(dur.negate());
    }
    /**
     * Scale this Duration by the specified amount. Return a newly-constructed Duration.
     * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
     * @return {Duration}
     */
    mapUnits(fn) {
      if (!this.isValid) return this;
      const result = {};
      for (const k of Object.keys(this.values)) {
        result[k] = asNumber(fn(this.values[k], k));
      }
      return clone(this, { values: result }, true);
    }
    /**
     * Get the value of unit.
     * @param {string} unit - a unit such as 'minute' or 'day'
     * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
     * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
     * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
     * @return {number}
     */
    get(unit) {
      return this[_Duration.normalizeUnit(unit)];
    }
    /**
     * "Set" the values of specified units. Return a newly-constructed Duration.
     * @param {Object} values - a mapping of units to numbers
     * @example dur.set({ years: 2017 })
     * @example dur.set({ hours: 8, minutes: 30 })
     * @return {Duration}
     */
    set(values) {
      if (!this.isValid) return this;
      const mixed = { ...this.values, ...normalizeObject(values, _Duration.normalizeUnit) };
      return clone(this, { values: mixed });
    }
    /**
     * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
     * @example dur.reconfigure({ locale: 'en-GB' })
     * @return {Duration}
     */
    reconfigure({ locale: locale2, numberingSystem, conversionAccuracy, matrix: matrix3 } = {}) {
      const loc = this.loc.clone({ locale: locale2, numberingSystem });
      const opts = { loc, matrix: matrix3, conversionAccuracy };
      return clone(this, opts);
    }
    /**
     * Return the length of the duration in the specified unit.
     * @param {string} unit - a unit such as 'minutes' or 'days'
     * @example Duration.fromObject({years: 1}).as('days') //=> 365
     * @example Duration.fromObject({years: 1}).as('months') //=> 12
     * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
     * @return {number}
     */
    as(unit) {
      return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
    }
    /**
     * Reduce this Duration to its canonical representation in its current units.
     * Assuming the overall value of the Duration is positive, this means:
     * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
     * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
     *   the overall value would be negative, see third example)
     * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
     *
     * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
     * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
     * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
     * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
     * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
     * @return {Duration}
     */
    normalize() {
      if (!this.isValid) return this;
      const vals = this.toObject();
      normalizeValues(this.matrix, vals);
      return clone(this, { values: vals }, true);
    }
    /**
     * Rescale units to its largest representation
     * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
     * @return {Duration}
     */
    rescale() {
      if (!this.isValid) return this;
      const vals = removeZeroes(this.normalize().shiftToAll().toObject());
      return clone(this, { values: vals }, true);
    }
    /**
     * Convert this Duration into its representation in a different set of units.
     * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
     * @return {Duration}
     */
    shiftTo(...units) {
      if (!this.isValid) return this;
      if (units.length === 0) {
        return this;
      }
      units = units.map((u) => _Duration.normalizeUnit(u));
      const built = {}, accumulated = {}, vals = this.toObject();
      let lastUnit;
      for (const k of orderedUnits) {
        if (units.indexOf(k) >= 0) {
          lastUnit = k;
          let own = 0;
          for (const ak in accumulated) {
            own += this.matrix[ak][k] * accumulated[ak];
            accumulated[ak] = 0;
          }
          if (isNumber(vals[k])) {
            own += vals[k];
          }
          const i = Math.trunc(own);
          built[k] = i;
          accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
        } else if (isNumber(vals[k])) {
          accumulated[k] = vals[k];
        }
      }
      for (const key in accumulated) {
        if (accumulated[key] !== 0) {
          built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
        }
      }
      normalizeValues(this.matrix, built);
      return clone(this, { values: built }, true);
    }
    /**
     * Shift this Duration to all available units.
     * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
     * @return {Duration}
     */
    shiftToAll() {
      if (!this.isValid) return this;
      return this.shiftTo(
        "years",
        "months",
        "weeks",
        "days",
        "hours",
        "minutes",
        "seconds",
        "milliseconds"
      );
    }
    /**
     * Return the negative of this Duration.
     * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
     * @return {Duration}
     */
    negate() {
      if (!this.isValid) return this;
      const negated = {};
      for (const k of Object.keys(this.values)) {
        negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
      }
      return clone(this, { values: negated }, true);
    }
    /**
     * Get the years.
     * @type {number}
     */
    get years() {
      return this.isValid ? this.values.years || 0 : NaN;
    }
    /**
     * Get the quarters.
     * @type {number}
     */
    get quarters() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }
    /**
     * Get the months.
     * @type {number}
     */
    get months() {
      return this.isValid ? this.values.months || 0 : NaN;
    }
    /**
     * Get the weeks
     * @type {number}
     */
    get weeks() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }
    /**
     * Get the days.
     * @type {number}
     */
    get days() {
      return this.isValid ? this.values.days || 0 : NaN;
    }
    /**
     * Get the hours.
     * @type {number}
     */
    get hours() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }
    /**
     * Get the minutes.
     * @type {number}
     */
    get minutes() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }
    /**
     * Get the seconds.
     * @return {number}
     */
    get seconds() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }
    /**
     * Get the milliseconds.
     * @return {number}
     */
    get milliseconds() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }
    /**
     * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
     * on invalid DateTimes or Intervals.
     * @return {boolean}
     */
    get isValid() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this Duration became invalid, or null if the Duration is valid
     * @return {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Equality check
     * Two Durations are equal iff they have the same units and the same values for each unit.
     * @param {Duration} other
     * @return {boolean}
     */
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      if (!this.loc.equals(other.loc)) {
        return false;
      }
      function eq(v1, v2) {
        if (v1 === void 0 || v1 === 0) return v2 === void 0 || v2 === 0;
        return v1 === v2;
      }
      for (const u of orderedUnits) {
        if (!eq(this.values[u], other.values[u])) {
          return false;
        }
      }
      return true;
    }
  };

  // node_modules/luxon/src/interval.js
  var INVALID2 = "Invalid Interval";
  function validateStartEnd(start2, end) {
    if (!start2 || !start2.isValid) {
      return Interval.invalid("missing or invalid start");
    } else if (!end || !end.isValid) {
      return Interval.invalid("missing or invalid end");
    } else if (end < start2) {
      return Interval.invalid(
        "end before start",
        `The end of an interval must be after its start, but you had start=${start2.toISO()} and end=${end.toISO()}`
      );
    } else {
      return null;
    }
  }
  var Interval = class _Interval {
    /**
     * @private
     */
    constructor(config2) {
      this.s = config2.start;
      this.e = config2.end;
      this.invalid = config2.invalid || null;
      this.isLuxonInterval = true;
    }
    /**
     * Create an invalid Interval.
     * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {Interval}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidIntervalError(invalid);
      } else {
        return new _Interval({ invalid });
      }
    }
    /**
     * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
     * @param {DateTime|Date|Object} start
     * @param {DateTime|Date|Object} end
     * @return {Interval}
     */
    static fromDateTimes(start2, end) {
      const builtStart = friendlyDateTime(start2), builtEnd = friendlyDateTime(end);
      const validateError = validateStartEnd(builtStart, builtEnd);
      if (validateError == null) {
        return new _Interval({
          start: builtStart,
          end: builtEnd
        });
      } else {
        return validateError;
      }
    }
    /**
     * Create an Interval from a start DateTime and a Duration to extend to.
     * @param {DateTime|Date|Object} start
     * @param {Duration|Object|number} duration - the length of the Interval.
     * @return {Interval}
     */
    static after(start2, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start2);
      return _Interval.fromDateTimes(dt, dt.plus(dur));
    }
    /**
     * Create an Interval from an end DateTime and a Duration to extend backwards to.
     * @param {DateTime|Date|Object} end
     * @param {Duration|Object|number} duration - the length of the Interval.
     * @return {Interval}
     */
    static before(end, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
      return _Interval.fromDateTimes(dt.minus(dur), dt);
    }
    /**
     * Create an Interval from an ISO 8601 string.
     * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
     * @param {string} text - the ISO string to parse
     * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @return {Interval}
     */
    static fromISO(text, opts) {
      const [s3, e3] = (text || "").split("/", 2);
      if (s3 && e3) {
        let start2, startIsValid;
        try {
          start2 = DateTime.fromISO(s3, opts);
          startIsValid = start2.isValid;
        } catch (e4) {
          startIsValid = false;
        }
        let end, endIsValid;
        try {
          end = DateTime.fromISO(e3, opts);
          endIsValid = end.isValid;
        } catch (e4) {
          endIsValid = false;
        }
        if (startIsValid && endIsValid) {
          return _Interval.fromDateTimes(start2, end);
        }
        if (startIsValid) {
          const dur = Duration.fromISO(e3, opts);
          if (dur.isValid) {
            return _Interval.after(start2, dur);
          }
        } else if (endIsValid) {
          const dur = Duration.fromISO(s3, opts);
          if (dur.isValid) {
            return _Interval.before(end, dur);
          }
        }
      }
      return _Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
    /**
     * Check if an object is an Interval. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isInterval(o) {
      return o && o.isLuxonInterval || false;
    }
    /**
     * Returns the start of the Interval
     * @type {DateTime}
     */
    get start() {
      return this.isValid ? this.s : null;
    }
    /**
     * Returns the end of the Interval
     * @type {DateTime}
     */
    get end() {
      return this.isValid ? this.e : null;
    }
    /**
     * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
     * @type {boolean}
     */
    get isValid() {
      return this.invalidReason === null;
    }
    /**
     * Returns an error code if this Interval is invalid, or null if the Interval is valid
     * @type {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Returns the length of the Interval in the specified unit.
     * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
     * @return {number}
     */
    length(unit = "milliseconds") {
      return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
    }
    /**
     * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
     * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
     * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
     * @param {string} [unit='milliseconds'] - the unit of time to count.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
     * @return {number}
     */
    count(unit = "milliseconds", opts) {
      if (!this.isValid) return NaN;
      const start2 = this.start.startOf(unit, opts);
      let end;
      if (opts?.useLocaleWeeks) {
        end = this.end.reconfigure({ locale: start2.locale });
      } else {
        end = this.end;
      }
      end = end.startOf(unit, opts);
      return Math.floor(end.diff(start2, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
    }
    /**
     * Returns whether this Interval's start and end are both in the same unit of time
     * @param {string} unit - the unit of time to check sameness on
     * @return {boolean}
     */
    hasSame(unit) {
      return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
    }
    /**
     * Return whether this Interval has the same start and end DateTimes.
     * @return {boolean}
     */
    isEmpty() {
      return this.s.valueOf() === this.e.valueOf();
    }
    /**
     * Return whether this Interval's start is after the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    isAfter(dateTime) {
      if (!this.isValid) return false;
      return this.s > dateTime;
    }
    /**
     * Return whether this Interval's end is before the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    isBefore(dateTime) {
      if (!this.isValid) return false;
      return this.e <= dateTime;
    }
    /**
     * Return whether this Interval contains the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    contains(dateTime) {
      if (!this.isValid) return false;
      return this.s <= dateTime && this.e > dateTime;
    }
    /**
     * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
     * @param {Object} values - the values to set
     * @param {DateTime} values.start - the starting DateTime
     * @param {DateTime} values.end - the ending DateTime
     * @return {Interval}
     */
    set({ start: start2, end } = {}) {
      if (!this.isValid) return this;
      return _Interval.fromDateTimes(start2 || this.s, end || this.e);
    }
    /**
     * Split this Interval at each of the specified DateTimes
     * @param {...DateTime} dateTimes - the unit of time to count.
     * @return {Array}
     */
    splitAt(...dateTimes) {
      if (!this.isValid) return [];
      const sorted = dateTimes.map(friendlyDateTime).filter((d3) => this.contains(d3)).sort((a3, b) => a3.toMillis() - b.toMillis()), results = [];
      let { s: s3 } = this, i = 0;
      while (s3 < this.e) {
        const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
        results.push(_Interval.fromDateTimes(s3, next));
        s3 = next;
        i += 1;
      }
      return results;
    }
    /**
     * Split this Interval into smaller Intervals, each of the specified length.
     * Left over time is grouped into a smaller interval
     * @param {Duration|Object|number} duration - The length of each resulting interval.
     * @return {Array}
     */
    splitBy(duration) {
      const dur = Duration.fromDurationLike(duration);
      if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
        return [];
      }
      let { s: s3 } = this, idx = 1, next;
      const results = [];
      while (s3 < this.e) {
        const added = this.start.plus(dur.mapUnits((x3) => x3 * idx));
        next = +added > +this.e ? this.e : added;
        results.push(_Interval.fromDateTimes(s3, next));
        s3 = next;
        idx += 1;
      }
      return results;
    }
    /**
     * Split this Interval into the specified number of smaller intervals.
     * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
     * @return {Array}
     */
    divideEqually(numberOfParts) {
      if (!this.isValid) return [];
      return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
    }
    /**
     * Return whether this Interval overlaps with the specified Interval
     * @param {Interval} other
     * @return {boolean}
     */
    overlaps(other) {
      return this.e > other.s && this.s < other.e;
    }
    /**
     * Return whether this Interval's end is adjacent to the specified Interval's start.
     * @param {Interval} other
     * @return {boolean}
     */
    abutsStart(other) {
      if (!this.isValid) return false;
      return +this.e === +other.s;
    }
    /**
     * Return whether this Interval's start is adjacent to the specified Interval's end.
     * @param {Interval} other
     * @return {boolean}
     */
    abutsEnd(other) {
      if (!this.isValid) return false;
      return +other.e === +this.s;
    }
    /**
     * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
     * @param {Interval} other
     * @return {boolean}
     */
    engulfs(other) {
      if (!this.isValid) return false;
      return this.s <= other.s && this.e >= other.e;
    }
    /**
     * Return whether this Interval has the same start and end as the specified Interval.
     * @param {Interval} other
     * @return {boolean}
     */
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      return this.s.equals(other.s) && this.e.equals(other.e);
    }
    /**
     * Return an Interval representing the intersection of this Interval and the specified Interval.
     * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
     * Returns null if the intersection is empty, meaning, the intervals don't intersect.
     * @param {Interval} other
     * @return {Interval}
     */
    intersection(other) {
      if (!this.isValid) return this;
      const s3 = this.s > other.s ? this.s : other.s, e3 = this.e < other.e ? this.e : other.e;
      if (s3 >= e3) {
        return null;
      } else {
        return _Interval.fromDateTimes(s3, e3);
      }
    }
    /**
     * Return an Interval representing the union of this Interval and the specified Interval.
     * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
     * @param {Interval} other
     * @return {Interval}
     */
    union(other) {
      if (!this.isValid) return this;
      const s3 = this.s < other.s ? this.s : other.s, e3 = this.e > other.e ? this.e : other.e;
      return _Interval.fromDateTimes(s3, e3);
    }
    /**
     * Merge an array of Intervals into a equivalent minimal set of Intervals.
     * Combines overlapping and adjacent Intervals.
     * @param {Array} intervals
     * @return {Array}
     */
    static merge(intervals) {
      const [found, final] = intervals.sort((a3, b) => a3.s - b.s).reduce(
        ([sofar, current], item) => {
          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        },
        [[], null]
      );
      if (final) {
        found.push(final);
      }
      return found;
    }
    /**
     * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
     * @param {Array} intervals
     * @return {Array}
     */
    static xor(intervals) {
      let start2 = null, currentCount = 0;
      const results = [], ends = intervals.map((i) => [
        { time: i.s, type: "s" },
        { time: i.e, type: "e" }
      ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a3, b) => a3.time - b.time);
      for (const i of arr) {
        currentCount += i.type === "s" ? 1 : -1;
        if (currentCount === 1) {
          start2 = i.time;
        } else {
          if (start2 && +start2 !== +i.time) {
            results.push(_Interval.fromDateTimes(start2, i.time));
          }
          start2 = null;
        }
      }
      return _Interval.merge(results);
    }
    /**
     * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
     * @param {...Interval} intervals
     * @return {Array}
     */
    difference(...intervals) {
      return _Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
    }
    /**
     * Returns a string representation of this Interval appropriate for debugging.
     * @return {string}
     */
    toString() {
      if (!this.isValid) return INVALID2;
      return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
    }
    /**
     * Returns a string representation of this Interval appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
      } else {
        return `Interval { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    /**
     * Returns a localized string representing this Interval. Accepts the same options as the
     * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
     * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
     * is browser-specific, but in general it will return an appropriate representation of the
     * Interval in the assigned locale. Defaults to the system's locale if no locale has been
     * specified.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
     * Intl.DateTimeFormat constructor options.
     * @param {Object} opts - Options to override the configuration of the start DateTime.
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
     * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
     * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
     * @return {string}
     */
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID2;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Interval.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @param {Object} opts - The same options as {@link DateTime#toISO}
     * @return {string}
     */
    toISO(opts) {
      if (!this.isValid) return INVALID2;
      return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
    }
    /**
     * Returns an ISO 8601-compliant string representation of date of this Interval.
     * The time components are ignored.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @return {string}
     */
    toISODate() {
      if (!this.isValid) return INVALID2;
      return `${this.s.toISODate()}/${this.e.toISODate()}`;
    }
    /**
     * Returns an ISO 8601-compliant string representation of time of this Interval.
     * The date components are ignored.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @param {Object} opts - The same options as {@link DateTime#toISO}
     * @return {string}
     */
    toISOTime(opts) {
      if (!this.isValid) return INVALID2;
      return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
    }
    /**
     * Returns a string representation of this Interval formatted according to the specified format
     * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
     * formatting tool.
     * @param {string} dateFormat - The format string. This string formats the start and end time.
     * See {@link DateTime#toFormat} for details.
     * @param {Object} opts - Options.
     * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
     * representations.
     * @return {string}
     */
    toFormat(dateFormat, { separator = " \u2013 " } = {}) {
      if (!this.isValid) return INVALID2;
      return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
    }
    /**
     * Return a Duration representing the time spanned by this interval.
     * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
     * @return {Duration}
     */
    toDuration(unit, opts) {
      if (!this.isValid) {
        return Duration.invalid(this.invalidReason);
      }
      return this.e.diff(this.s, unit, opts);
    }
    /**
     * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
     * @param {function} mapFn
     * @return {Interval}
     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
     */
    mapEndpoints(mapFn) {
      return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
    }
  };

  // node_modules/luxon/src/info.js
  var Info = class {
    /**
     * Return whether the specified zone contains a DST.
     * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
     * @return {boolean}
     */
    static hasDST(zone = Settings.defaultZone) {
      const proto = DateTime.now().setZone(zone).set({ month: 12 });
      return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
    }
    /**
     * Return whether the specified zone is a valid IANA specifier.
     * @param {string} zone - Zone to check
     * @return {boolean}
     */
    static isValidIANAZone(zone) {
      return IANAZone.isValidZone(zone);
    }
    /**
     * Converts the input into a {@link Zone} instance.
     *
     * * If `input` is already a Zone instance, it is returned unchanged.
     * * If `input` is a string containing a valid time zone name, a Zone instance
     *   with that name is returned.
     * * If `input` is a string that doesn't refer to a known time zone, a Zone
     *   instance with {@link Zone#isValid} == false is returned.
     * * If `input is a number, a Zone instance with the specified fixed offset
     *   in minutes is returned.
     * * If `input` is `null` or `undefined`, the default zone is returned.
     * @param {string|Zone|number} [input] - the value to be converted
     * @return {Zone}
     */
    static normalizeZone(input) {
      return normalizeZone(input, Settings.defaultZone);
    }
    /**
     * Get the weekday on which the week starts according to the given locale.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
     */
    static getStartOfWeek({ locale: locale2 = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale2)).getStartOfWeek();
    }
    /**
     * Get the minimum number of days necessary in a week before it is considered part of the next year according
     * to the given locale.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number}
     */
    static getMinimumDaysInFirstWeek({ locale: locale2 = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale2)).getMinDaysInFirstWeek();
    }
    /**
     * Get the weekdays, which are considered the weekend according to the given locale
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
     */
    static getWeekendWeekdays({ locale: locale2 = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale2)).getWeekendDays().slice();
    }
    /**
     * Return an array of standalone month names.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @param {string} [opts.outputCalendar='gregory'] - the calendar
     * @example Info.months()[0] //=> 'January'
     * @example Info.months('short')[0] //=> 'Jan'
     * @example Info.months('numeric')[0] //=> '1'
     * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
     * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
     * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
     * @return {Array}
     */
    static months(length5 = "long", { locale: locale2 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
      return (locObj || Locale.create(locale2, numberingSystem, outputCalendar)).months(length5);
    }
    /**
     * Return an array of format month names.
     * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
     * changes the string.
     * See {@link Info#months}
     * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @param {string} [opts.outputCalendar='gregory'] - the calendar
     * @return {Array}
     */
    static monthsFormat(length5 = "long", { locale: locale2 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
      return (locObj || Locale.create(locale2, numberingSystem, outputCalendar)).months(length5, true);
    }
    /**
     * Return an array of standalone week names.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @example Info.weekdays()[0] //=> 'Monday'
     * @example Info.weekdays('short')[0] //=> 'Mon'
     * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
     * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
     * @return {Array}
     */
    static weekdays(length5 = "long", { locale: locale2 = null, numberingSystem = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale2, numberingSystem, null)).weekdays(length5);
    }
    /**
     * Return an array of format week names.
     * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
     * changes the string.
     * See {@link Info#weekdays}
     * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale=null] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @return {Array}
     */
    static weekdaysFormat(length5 = "long", { locale: locale2 = null, numberingSystem = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale2, numberingSystem, null)).weekdays(length5, true);
    }
    /**
     * Return an array of meridiems.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @example Info.meridiems() //=> [ 'AM', 'PM' ]
     * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
     * @return {Array}
     */
    static meridiems({ locale: locale2 = null } = {}) {
      return Locale.create(locale2).meridiems();
    }
    /**
     * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
     * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @example Info.eras() //=> [ 'BC', 'AD' ]
     * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
     * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
     * @return {Array}
     */
    static eras(length5 = "short", { locale: locale2 = null } = {}) {
      return Locale.create(locale2, null, "gregory").eras(length5);
    }
    /**
     * Return the set of available features in this environment.
     * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
     * Keys:
     * * `relative`: whether this environment supports relative time formatting
     * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
     * @example Info.features() //=> { relative: false, localeWeek: true }
     * @return {Object}
     */
    static features() {
      return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
    }
  };

  // node_modules/luxon/src/impl/diff.js
  function dayDiff(earlier, later) {
    const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms2 = utcDayStart(later) - utcDayStart(earlier);
    return Math.floor(Duration.fromMillis(ms2).as("days"));
  }
  function highOrderDiffs(cursor, later, units) {
    const differs = [
      ["years", (a3, b) => b.year - a3.year],
      ["quarters", (a3, b) => b.quarter - a3.quarter + (b.year - a3.year) * 4],
      ["months", (a3, b) => b.month - a3.month + (b.year - a3.year) * 12],
      [
        "weeks",
        (a3, b) => {
          const days = dayDiff(a3, b);
          return (days - days % 7) / 7;
        }
      ],
      ["days", dayDiff]
    ];
    const results = {};
    const earlier = cursor;
    let lowestOrder, highWater;
    for (const [unit, differ] of differs) {
      if (units.indexOf(unit) >= 0) {
        lowestOrder = unit;
        results[unit] = differ(cursor, later);
        highWater = earlier.plus(results);
        if (highWater > later) {
          results[unit]--;
          cursor = earlier.plus(results);
          if (cursor > later) {
            highWater = cursor;
            results[unit]--;
            cursor = earlier.plus(results);
          }
        } else {
          cursor = highWater;
        }
      }
    }
    return [cursor, results, highWater, lowestOrder];
  }
  function diff_default(earlier, later, units, opts) {
    let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
    const remainingMillis = later - cursor;
    const lowerOrderUnits = units.filter(
      (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
    );
    if (lowerOrderUnits.length === 0) {
      if (highWater < later) {
        highWater = cursor.plus({ [lowestOrder]: 1 });
      }
      if (highWater !== cursor) {
        results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
      }
    }
    const duration = Duration.fromObject(results, opts);
    if (lowerOrderUnits.length > 0) {
      return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
    } else {
      return duration;
    }
  }

  // node_modules/luxon/src/impl/tokenParser.js
  var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
  function intUnit(regex, post = (i) => i) {
    return { regex, deser: ([s3]) => post(parseDigits(s3)) };
  }
  var NBSP = String.fromCharCode(160);
  var spaceOrNBSP = `[ ${NBSP}]`;
  var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
  function fixListRegex(s3) {
    return s3.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
  }
  function stripInsensitivities(s3) {
    return s3.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
  }
  function oneOf(strings, startIndex) {
    if (strings === null) {
      return null;
    } else {
      return {
        regex: RegExp(strings.map(fixListRegex).join("|")),
        deser: ([s3]) => strings.findIndex((i) => stripInsensitivities(s3) === stripInsensitivities(i)) + startIndex
      };
    }
  }
  function offset(regex, groups2) {
    return { regex, deser: ([, h, m3]) => signedOffset(h, m3), groups: groups2 };
  }
  function simple(regex) {
    return { regex, deser: ([s3]) => s3 };
  }
  function escapeToken(value2) {
    return value2.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }
  function unitForToken(token2, loc) {
    const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal2 = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s3]) => s3, literal: true }), unitate = (t) => {
      if (token2.literal) {
        return literal2(t);
      }
      switch (t.val) {
        // era
        case "G":
          return oneOf(loc.eras("short"), 0);
        case "GG":
          return oneOf(loc.eras("long"), 0);
        // years
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        // months
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true), 1);
        case "MMMM":
          return oneOf(loc.months("long", true), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false), 1);
        // dates
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        // ordinals
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        // time
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        // meridiem
        case "a":
          return oneOf(loc.meridiems(), 0);
        // weekYear (k)
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        // weekNumber (W)
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        // weekdays
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true), 1);
        // offset/zone
        case "Z":
        case "ZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        // we don't support ZZZZ (PST) or ZZZZZ (Pacific Standard Time) in parsing
        // because we don't have any way to figure out what they are
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        // this special-case "token" represents a place where a macro-token expanded into a white-space literal
        // in this case we accept any non-newline white-space
        case " ":
          return simple(/[^\S\n\r]/);
        default:
          return literal2(t);
      }
    };
    const unit = unitate(token2) || {
      invalidReason: MISSING_FTP
    };
    unit.token = token2;
    return unit;
  }
  var partTypeStyleToTokenVal = {
    year: {
      "2-digit": "yy",
      numeric: "yyyyy"
    },
    month: {
      numeric: "M",
      "2-digit": "MM",
      short: "MMM",
      long: "MMMM"
    },
    day: {
      numeric: "d",
      "2-digit": "dd"
    },
    weekday: {
      short: "EEE",
      long: "EEEE"
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour12: {
      numeric: "h",
      "2-digit": "hh"
    },
    hour24: {
      numeric: "H",
      "2-digit": "HH"
    },
    minute: {
      numeric: "m",
      "2-digit": "mm"
    },
    second: {
      numeric: "s",
      "2-digit": "ss"
    },
    timeZoneName: {
      long: "ZZZZZ",
      short: "ZZZ"
    }
  };
  function tokenForPart(part, formatOpts, resolvedOpts) {
    const { type, value: value2 } = part;
    if (type === "literal") {
      const isSpace2 = /^\s+$/.test(value2);
      return {
        literal: !isSpace2,
        val: isSpace2 ? " " : value2
      };
    }
    const style = formatOpts[type];
    let actualType = type;
    if (type === "hour") {
      if (formatOpts.hour12 != null) {
        actualType = formatOpts.hour12 ? "hour12" : "hour24";
      } else if (formatOpts.hourCycle != null) {
        if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
          actualType = "hour12";
        } else {
          actualType = "hour24";
        }
      } else {
        actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
      }
    }
    let val = partTypeStyleToTokenVal[actualType];
    if (typeof val === "object") {
      val = val[style];
    }
    if (val) {
      return {
        literal: false,
        val
      };
    }
    return void 0;
  }
  function buildRegex(units) {
    const re2 = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
    return [`^${re2}$`, units];
  }
  function match(input, regex, handlers) {
    const matches2 = input.match(regex);
    if (matches2) {
      const all = {};
      let matchIndex = 1;
      for (const i in handlers) {
        if (hasOwnProperty(handlers, i)) {
          const h = handlers[i], groups2 = h.groups ? h.groups + 1 : 1;
          if (!h.literal && h.token) {
            all[h.token.val[0]] = h.deser(matches2.slice(matchIndex, matchIndex + groups2));
          }
          matchIndex += groups2;
        }
      }
      return [matches2, all];
    } else {
      return [matches2, {}];
    }
  }
  function dateTimeFromMatches(matches2) {
    const toField = (token2) => {
      switch (token2) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
        case "H":
          return "hour";
        case "d":
          return "day";
        case "o":
          return "ordinal";
        case "L":
        case "M":
          return "month";
        case "y":
          return "year";
        case "E":
        case "c":
          return "weekday";
        case "W":
          return "weekNumber";
        case "k":
          return "weekYear";
        case "q":
          return "quarter";
        default:
          return null;
      }
    };
    let zone = null;
    let specificOffset;
    if (!isUndefined(matches2.z)) {
      zone = IANAZone.create(matches2.z);
    }
    if (!isUndefined(matches2.Z)) {
      if (!zone) {
        zone = new FixedOffsetZone(matches2.Z);
      }
      specificOffset = matches2.Z;
    }
    if (!isUndefined(matches2.q)) {
      matches2.M = (matches2.q - 1) * 3 + 1;
    }
    if (!isUndefined(matches2.h)) {
      if (matches2.h < 12 && matches2.a === 1) {
        matches2.h += 12;
      } else if (matches2.h === 12 && matches2.a === 0) {
        matches2.h = 0;
      }
    }
    if (matches2.G === 0 && matches2.y) {
      matches2.y = -matches2.y;
    }
    if (!isUndefined(matches2.u)) {
      matches2.S = parseMillis(matches2.u);
    }
    const vals = Object.keys(matches2).reduce((r, k) => {
      const f = toField(k);
      if (f) {
        r[f] = matches2[k];
      }
      return r;
    }, {});
    return [vals, zone, specificOffset];
  }
  var dummyDateTimeCache = null;
  function getDummyDateTime() {
    if (!dummyDateTimeCache) {
      dummyDateTimeCache = DateTime.fromMillis(1555555555555);
    }
    return dummyDateTimeCache;
  }
  function maybeExpandMacroToken(token2, locale2) {
    if (token2.literal) {
      return token2;
    }
    const formatOpts = Formatter.macroTokenToFormatOpts(token2.val);
    const tokens4 = formatOptsToTokens(formatOpts, locale2);
    if (tokens4 == null || tokens4.includes(void 0)) {
      return token2;
    }
    return tokens4;
  }
  function expandMacroTokens(tokens4, locale2) {
    return Array.prototype.concat(...tokens4.map((t) => maybeExpandMacroToken(t, locale2)));
  }
  var TokenParser = class {
    constructor(locale2, format3) {
      this.locale = locale2;
      this.format = format3;
      this.tokens = expandMacroTokens(Formatter.parseFormat(format3), locale2);
      this.units = this.tokens.map((t) => unitForToken(t, locale2));
      this.disqualifyingUnit = this.units.find((t) => t.invalidReason);
      if (!this.disqualifyingUnit) {
        const [regexString, handlers] = buildRegex(this.units);
        this.regex = RegExp(regexString, "i");
        this.handlers = handlers;
      }
    }
    explainFromTokens(input) {
      if (!this.isValid) {
        return { input, tokens: this.tokens, invalidReason: this.invalidReason };
      } else {
        const [rawMatches, matches2] = match(input, this.regex, this.handlers), [result, zone, specificOffset] = matches2 ? dateTimeFromMatches(matches2) : [null, null, void 0];
        if (hasOwnProperty(matches2, "a") && hasOwnProperty(matches2, "H")) {
          throw new ConflictingSpecificationError(
            "Can't include meridiem when specifying 24-hour format"
          );
        }
        return {
          input,
          tokens: this.tokens,
          regex: this.regex,
          rawMatches,
          matches: matches2,
          result,
          zone,
          specificOffset
        };
      }
    }
    get isValid() {
      return !this.disqualifyingUnit;
    }
    get invalidReason() {
      return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
    }
  };
  function explainFromTokens(locale2, input, format3) {
    const parser2 = new TokenParser(locale2, format3);
    return parser2.explainFromTokens(input);
  }
  function parseFromTokens(locale2, input, format3) {
    const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale2, input, format3);
    return [result, zone, specificOffset, invalidReason];
  }
  function formatOptsToTokens(formatOpts, locale2) {
    if (!formatOpts) {
      return null;
    }
    const formatter2 = Formatter.create(locale2, formatOpts);
    const df = formatter2.dtFormatter(getDummyDateTime());
    const parts = df.formatToParts();
    const resolvedOpts = df.resolvedOptions();
    return parts.map((p2) => tokenForPart(p2, formatOpts, resolvedOpts));
  }

  // node_modules/luxon/src/datetime.js
  var INVALID3 = "Invalid DateTime";
  var MAX_DATE = 864e13;
  function unsupportedZone(zone) {
    return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
  }
  function possiblyCachedWeekData(dt) {
    if (dt.weekData === null) {
      dt.weekData = gregorianToWeek(dt.c);
    }
    return dt.weekData;
  }
  function possiblyCachedLocalWeekData(dt) {
    if (dt.localWeekData === null) {
      dt.localWeekData = gregorianToWeek(
        dt.c,
        dt.loc.getMinDaysInFirstWeek(),
        dt.loc.getStartOfWeek()
      );
    }
    return dt.localWeekData;
  }
  function clone2(inst, alts) {
    const current = {
      ts: inst.ts,
      zone: inst.zone,
      c: inst.c,
      o: inst.o,
      loc: inst.loc,
      invalid: inst.invalid
    };
    return new DateTime({ ...current, ...alts, old: current });
  }
  function fixOffset(localTS, o, tz) {
    let utcGuess = localTS - o * 60 * 1e3;
    const o2 = tz.offset(utcGuess);
    if (o === o2) {
      return [utcGuess, o];
    }
    utcGuess -= (o2 - o) * 60 * 1e3;
    const o3 = tz.offset(utcGuess);
    if (o2 === o3) {
      return [utcGuess, o2];
    }
    return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
  }
  function tsToObj(ts, offset3) {
    ts += offset3 * 60 * 1e3;
    const d3 = new Date(ts);
    return {
      year: d3.getUTCFullYear(),
      month: d3.getUTCMonth() + 1,
      day: d3.getUTCDate(),
      hour: d3.getUTCHours(),
      minute: d3.getUTCMinutes(),
      second: d3.getUTCSeconds(),
      millisecond: d3.getUTCMilliseconds()
    };
  }
  function objToTS(obj, offset3, zone) {
    return fixOffset(objToLocalTS(obj), offset3, zone);
  }
  function adjustTime(inst, dur) {
    const oPre = inst.o, year2 = inst.c.year + Math.trunc(dur.years), month2 = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c5 = {
      ...inst.c,
      year: year2,
      month: month2,
      day: Math.min(inst.c.day, daysInMonth(year2, month2)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
    }, millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds
    }).as("milliseconds"), localTS = objToLocalTS(c5);
    let [ts, o] = fixOffset(localTS, oPre, inst.zone);
    if (millisToAdd !== 0) {
      ts += millisToAdd;
      o = inst.zone.offset(ts);
    }
    return { ts, o };
  }
  function parseDataToDateTime(parsed, parsedZone, opts, format3, text, specificOffset) {
    const { setZone, zone } = opts;
    if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
      const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset
      });
      return setZone ? inst : inst.setZone(zone);
    } else {
      return DateTime.invalid(
        new Invalid("unparsable", `the input "${text}" can't be parsed as ${format3}`)
      );
    }
  }
  function toTechFormat(dt, format3, allowZ = true) {
    return dt.isValid ? Formatter.create(Locale.create("en-US"), {
      allowZ,
      forceSimple: true
    }).formatDateTimeFromString(dt, format3) : null;
  }
  function toISODate(o, extended) {
    const longFormat = o.c.year > 9999 || o.c.year < 0;
    let c5 = "";
    if (longFormat && o.c.year >= 0) c5 += "+";
    c5 += padStart(o.c.year, longFormat ? 6 : 4);
    if (extended) {
      c5 += "-";
      c5 += padStart(o.c.month);
      c5 += "-";
      c5 += padStart(o.c.day);
    } else {
      c5 += padStart(o.c.month);
      c5 += padStart(o.c.day);
    }
    return c5;
  }
  function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
    let c5 = padStart(o.c.hour);
    if (extended) {
      c5 += ":";
      c5 += padStart(o.c.minute);
      if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
        c5 += ":";
      }
    } else {
      c5 += padStart(o.c.minute);
    }
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c5 += padStart(o.c.second);
      if (o.c.millisecond !== 0 || !suppressMilliseconds) {
        c5 += ".";
        c5 += padStart(o.c.millisecond, 3);
      }
    }
    if (includeOffset) {
      if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
        c5 += "Z";
      } else if (o.o < 0) {
        c5 += "-";
        c5 += padStart(Math.trunc(-o.o / 60));
        c5 += ":";
        c5 += padStart(Math.trunc(-o.o % 60));
      } else {
        c5 += "+";
        c5 += padStart(Math.trunc(o.o / 60));
        c5 += ":";
        c5 += padStart(Math.trunc(o.o % 60));
      }
    }
    if (extendedZone) {
      c5 += "[" + o.zone.ianaName + "]";
    }
    return c5;
  }
  var defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
  var orderedWeekUnits = [
    "weekYear",
    "weekNumber",
    "weekday",
    "hour",
    "minute",
    "second",
    "millisecond"
  ];
  var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
  function normalizeUnit(unit) {
    const normalized = {
      year: "year",
      years: "year",
      month: "month",
      months: "month",
      day: "day",
      days: "day",
      hour: "hour",
      hours: "hour",
      minute: "minute",
      minutes: "minute",
      quarter: "quarter",
      quarters: "quarter",
      second: "second",
      seconds: "second",
      millisecond: "millisecond",
      milliseconds: "millisecond",
      weekday: "weekday",
      weekdays: "weekday",
      weeknumber: "weekNumber",
      weeksnumber: "weekNumber",
      weeknumbers: "weekNumber",
      weekyear: "weekYear",
      weekyears: "weekYear",
      ordinal: "ordinal"
    }[unit.toLowerCase()];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }
  function normalizeUnitWithLocalWeeks(unit) {
    switch (unit.toLowerCase()) {
      case "localweekday":
      case "localweekdays":
        return "localWeekday";
      case "localweeknumber":
      case "localweeknumbers":
        return "localWeekNumber";
      case "localweekyear":
      case "localweekyears":
        return "localWeekYear";
      default:
        return normalizeUnit(unit);
    }
  }
  function guessOffsetForZone(zone) {
    if (!zoneOffsetGuessCache[zone]) {
      if (zoneOffsetTs === void 0) {
        zoneOffsetTs = Settings.now();
      }
      zoneOffsetGuessCache[zone] = zone.offset(zoneOffsetTs);
    }
    return zoneOffsetGuessCache[zone];
  }
  function quickDT(obj, opts) {
    const zone = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    }
    const loc = Locale.fromObject(opts);
    let ts, o;
    if (!isUndefined(obj.year)) {
      for (const u of orderedUnits2) {
        if (isUndefined(obj[u])) {
          obj[u] = defaultUnitValues[u];
        }
      }
      const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      const offsetProvis = guessOffsetForZone(zone);
      [ts, o] = objToTS(obj, offsetProvis, zone);
    } else {
      ts = Settings.now();
    }
    return new DateTime({ ts, zone, loc, o });
  }
  function diffRelative(start2, end, opts) {
    const round5 = isUndefined(opts.round) ? true : opts.round, format3 = (c5, unit) => {
      c5 = roundTo(c5, round5 || opts.calendary ? 0 : 2, true);
      const formatter2 = end.loc.clone(opts).relFormatter(opts);
      return formatter2.format(c5, unit);
    }, differ = (unit) => {
      if (opts.calendary) {
        if (!end.hasSame(start2, unit)) {
          return end.startOf(unit).diff(start2.startOf(unit), unit).get(unit);
        } else return 0;
      } else {
        return end.diff(start2, unit).get(unit);
      }
    };
    if (opts.unit) {
      return format3(differ(opts.unit), opts.unit);
    }
    for (const unit of opts.units) {
      const count4 = differ(unit);
      if (Math.abs(count4) >= 1) {
        return format3(count4, unit);
      }
    }
    return format3(start2 > end ? -0 : 0, opts.units[opts.units.length - 1]);
  }
  function lastOpts(argList) {
    let opts = {}, args;
    if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
      opts = argList[argList.length - 1];
      args = Array.from(argList).slice(0, argList.length - 1);
    } else {
      args = Array.from(argList);
    }
    return [opts, args];
  }
  var zoneOffsetTs;
  var zoneOffsetGuessCache = {};
  var DateTime = class _DateTime {
    /**
     * @access private
     */
    constructor(config2) {
      const zone = config2.zone || Settings.defaultZone;
      let invalid = config2.invalid || (Number.isNaN(config2.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
      this.ts = isUndefined(config2.ts) ? Settings.now() : config2.ts;
      let c5 = null, o = null;
      if (!invalid) {
        const unchanged = config2.old && config2.old.ts === this.ts && config2.old.zone.equals(zone);
        if (unchanged) {
          [c5, o] = [config2.old.c, config2.old.o];
        } else {
          const ot = isNumber(config2.o) && !config2.old ? config2.o : zone.offset(this.ts);
          c5 = tsToObj(this.ts, ot);
          invalid = Number.isNaN(c5.year) ? new Invalid("invalid input") : null;
          c5 = invalid ? null : c5;
          o = invalid ? null : ot;
        }
      }
      this._zone = zone;
      this.loc = config2.loc || Locale.create();
      this.invalid = invalid;
      this.weekData = null;
      this.localWeekData = null;
      this.c = c5;
      this.o = o;
      this.isLuxonDateTime = true;
    }
    // CONSTRUCT
    /**
     * Create a DateTime for the current instant, in the system's time zone.
     *
     * Use Settings to override these default values if needed.
     * @example DateTime.now().toISO() //~> now in the ISO format
     * @return {DateTime}
     */
    static now() {
      return new _DateTime({});
    }
    /**
     * Create a local DateTime
     * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
     * @param {number} [month=1] - The month, 1-indexed
     * @param {number} [day=1] - The day of the month, 1-indexed
     * @param {number} [hour=0] - The hour of the day, in 24-hour time
     * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
     * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
     * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
     * @example DateTime.local()                                  //~> now
     * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
     * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
     * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
     * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
     * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
     * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
     * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
     * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
     * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
     * @return {DateTime}
     */
    static local() {
      const [opts, args] = lastOpts(arguments), [year2, month2, day2, hour2, minute2, second2, millisecond2] = args;
      return quickDT({ year: year2, month: month2, day: day2, hour: hour2, minute: minute2, second: second2, millisecond: millisecond2 }, opts);
    }
    /**
     * Create a DateTime in UTC
     * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
     * @param {number} [month=1] - The month, 1-indexed
     * @param {number} [day=1] - The day of the month
     * @param {number} [hour=0] - The hour of the day, in 24-hour time
     * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
     * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
     * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
     * @param {Object} options - configuration options for the DateTime
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
     * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
     * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
     * @example DateTime.utc()                                              //~> now
     * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
     * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
     * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
     * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
     * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
     * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
     * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
     * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
     * @return {DateTime}
     */
    static utc() {
      const [opts, args] = lastOpts(arguments), [year2, month2, day2, hour2, minute2, second2, millisecond2] = args;
      opts.zone = FixedOffsetZone.utcInstance;
      return quickDT({ year: year2, month: month2, day: day2, hour: hour2, minute: minute2, second: second2, millisecond: millisecond2 }, opts);
    }
    /**
     * Create a DateTime from a JavaScript Date object. Uses the default zone.
     * @param {Date} date - a JavaScript Date object
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @return {DateTime}
     */
    static fromJSDate(date, options = {}) {
      const ts = isDate(date) ? date.valueOf() : NaN;
      if (Number.isNaN(ts)) {
        return _DateTime.invalid("invalid input");
      }
      const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return _DateTime.invalid(unsupportedZone(zoneToUse));
      }
      return new _DateTime({
        ts,
        zone: zoneToUse,
        loc: Locale.fromObject(options)
      });
    }
    /**
     * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     * @param {number} milliseconds - a number of milliseconds since 1970 UTC
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromMillis(milliseconds, options = {}) {
      if (!isNumber(milliseconds)) {
        throw new InvalidArgumentError(
          `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
        );
      } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
        return _DateTime.invalid("Timestamp out of range");
      } else {
        return new _DateTime({
          ts: milliseconds,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    /**
     * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     * @param {number} seconds - a number of seconds since 1970 UTC
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromSeconds(seconds, options = {}) {
      if (!isNumber(seconds)) {
        throw new InvalidArgumentError("fromSeconds requires a numerical input");
      } else {
        return new _DateTime({
          ts: seconds * 1e3,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    /**
     * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
     * @param {Object} obj - the object to create the DateTime from
     * @param {number} obj.year - a year, such as 1987
     * @param {number} obj.month - a month, 1-12
     * @param {number} obj.day - a day of the month, 1-31, depending on the month
     * @param {number} obj.ordinal - day of the year, 1-365 or 366
     * @param {number} obj.weekYear - an ISO week year
     * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
     * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
     * @param {number} obj.localWeekYear - a week year, according to the locale
     * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
     * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
     * @param {number} obj.hour - hour of the day, 0-23
     * @param {number} obj.minute - minute of the hour, 0-59
     * @param {number} obj.second - second of the minute, 0-59
     * @param {number} obj.millisecond - millisecond of the second, 0-999
     * @param {Object} opts - options for creating this DateTime
     * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
     * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
     * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
     * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
     * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
     * @return {DateTime}
     */
    static fromObject(obj, opts = {}) {
      obj = obj || {};
      const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return _DateTime.invalid(unsupportedZone(zoneToUse));
      }
      const loc = Locale.fromObject(opts);
      const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
      const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
      const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError(
          "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
        );
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
      let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
      if (useWeekData) {
        units = orderedWeekUnits;
        defaultValues = defaultWeekUnitValues;
        objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
      } else if (containsOrdinal) {
        units = orderedOrdinalUnits;
        defaultValues = defaultOrdinalUnitValues;
        objNow = gregorianToOrdinal(objNow);
      } else {
        units = orderedUnits2;
        defaultValues = defaultUnitValues;
      }
      let foundFirst = false;
      for (const u of units) {
        const v = normalized[u];
        if (!isUndefined(v)) {
          foundFirst = true;
        } else if (foundFirst) {
          normalized[u] = defaultValues[u];
        } else {
          normalized[u] = objNow[u];
        }
      }
      const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
      if (invalid) {
        return _DateTime.invalid(invalid);
      }
      const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc
      });
      if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
        return _DateTime.invalid(
          "mismatched weekday",
          `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
        );
      }
      if (!inst.isValid) {
        return _DateTime.invalid(inst.invalid);
      }
      return inst;
    }
    /**
     * Create a DateTime from an ISO 8601 string
     * @param {string} text - the ISO string
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
     * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
     * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromISO('2016-05-25T09:08:34.123')
     * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
     * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
     * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
     * @example DateTime.fromISO('2016-W05-4')
     * @return {DateTime}
     */
    static fromISO(text, opts = {}) {
      const [vals, parsedZone] = parseISODate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
    }
    /**
     * Create a DateTime from an RFC 2822 string
     * @param {string} text - the RFC 2822 string
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
     * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
     * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
     * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
     * @return {DateTime}
     */
    static fromRFC2822(text, opts = {}) {
      const [vals, parsedZone] = parseRFC2822Date(text);
      return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
    }
    /**
     * Create a DateTime from an HTTP header date
     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
     * @param {string} text - the HTTP header date
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
     * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
     * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
     * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
     * @return {DateTime}
     */
    static fromHTTP(text, opts = {}) {
      const [vals, parsedZone] = parseHTTPDate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
    }
    /**
     * Create a DateTime from an input string and format string.
     * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
     * @param {string} text - the string to parse
     * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
     * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromFormat(text, fmt, opts = {}) {
      if (isUndefined(text) || isUndefined(fmt)) {
        throw new InvalidArgumentError("fromFormat requires an input string and a format");
      }
      const { locale: locale2 = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
        locale: locale2,
        numberingSystem,
        defaultToEN: true
      }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
      if (invalid) {
        return _DateTime.invalid(invalid);
      } else {
        return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
      }
    }
    /**
     * @deprecated use fromFormat instead
     */
    static fromString(text, fmt, opts = {}) {
      return _DateTime.fromFormat(text, fmt, opts);
    }
    /**
     * Create a DateTime from a SQL date, time, or datetime
     * Defaults to en-US if no locale has been specified, regardless of the system's locale
     * @param {string} text - the string to parse
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
     * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @example DateTime.fromSQL('2017-05-15')
     * @example DateTime.fromSQL('2017-05-15 09:12:34')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
     * @example DateTime.fromSQL('09:12:34.342')
     * @return {DateTime}
     */
    static fromSQL(text, opts = {}) {
      const [vals, parsedZone] = parseSQL(text);
      return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
    }
    /**
     * Create an invalid DateTime.
     * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {DateTime}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDateTimeError(invalid);
      } else {
        return new _DateTime({ invalid });
      }
    }
    /**
     * Check if an object is an instance of DateTime. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isDateTime(o) {
      return o && o.isLuxonDateTime || false;
    }
    /**
     * Produce the format string for a set of options
     * @param formatOpts
     * @param localeOpts
     * @returns {string}
     */
    static parseFormatForOpts(formatOpts, localeOpts = {}) {
      const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
      return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
    }
    /**
     * Produce the the fully expanded format token for the locale
     * Does NOT quote characters, so quoted tokens will not round trip correctly
     * @param fmt
     * @param localeOpts
     * @returns {string}
     */
    static expandFormat(fmt, localeOpts = {}) {
      const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
      return expanded.map((t) => t.val).join("");
    }
    static resetCache() {
      zoneOffsetTs = void 0;
      zoneOffsetGuessCache = {};
    }
    // INFO
    /**
     * Get the value of unit.
     * @param {string} unit - a unit such as 'minute' or 'day'
     * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
     * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
     * @return {number}
     */
    get(unit) {
      return this[unit];
    }
    /**
     * Returns whether the DateTime is valid. Invalid DateTimes occur when:
     * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
     * * The DateTime was created by an operation on another invalid date
     * @type {boolean}
     */
    get isValid() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
     * @type {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
     *
     * @type {string}
     */
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
     *
     * @type {string}
     */
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    /**
     * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
     *
     * @type {string}
     */
    get outputCalendar() {
      return this.isValid ? this.loc.outputCalendar : null;
    }
    /**
     * Get the time zone associated with this DateTime.
     * @type {Zone}
     */
    get zone() {
      return this._zone;
    }
    /**
     * Get the name of the time zone.
     * @type {string}
     */
    get zoneName() {
      return this.isValid ? this.zone.name : null;
    }
    /**
     * Get the year
     * @example DateTime.local(2017, 5, 25).year //=> 2017
     * @type {number}
     */
    get year() {
      return this.isValid ? this.c.year : NaN;
    }
    /**
     * Get the quarter
     * @example DateTime.local(2017, 5, 25).quarter //=> 2
     * @type {number}
     */
    get quarter() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }
    /**
     * Get the month (1-12).
     * @example DateTime.local(2017, 5, 25).month //=> 5
     * @type {number}
     */
    get month() {
      return this.isValid ? this.c.month : NaN;
    }
    /**
     * Get the day of the month (1-30ish).
     * @example DateTime.local(2017, 5, 25).day //=> 25
     * @type {number}
     */
    get day() {
      return this.isValid ? this.c.day : NaN;
    }
    /**
     * Get the hour of the day (0-23).
     * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
     * @type {number}
     */
    get hour() {
      return this.isValid ? this.c.hour : NaN;
    }
    /**
     * Get the minute of the hour (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
     * @type {number}
     */
    get minute() {
      return this.isValid ? this.c.minute : NaN;
    }
    /**
     * Get the second of the minute (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
     * @type {number}
     */
    get second() {
      return this.isValid ? this.c.second : NaN;
    }
    /**
     * Get the millisecond of the second (0-999).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
     * @type {number}
     */
    get millisecond() {
      return this.isValid ? this.c.millisecond : NaN;
    }
    /**
     * Get the week year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
     * @type {number}
     */
    get weekYear() {
      return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
    }
    /**
     * Get the week number of the week year (1-52ish).
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
     * @type {number}
     */
    get weekNumber() {
      return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
    }
    /**
     * Get the day of the week.
     * 1 is Monday and 7 is Sunday
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 11, 31).weekday //=> 4
     * @type {number}
     */
    get weekday() {
      return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
    }
    /**
     * Returns true if this date is on a weekend according to the locale, false otherwise
     * @returns {boolean}
     */
    get isWeekend() {
      return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
    }
    /**
     * Get the day of the week according to the locale.
     * 1 is the first day of the week and 7 is the last day of the week.
     * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
     * @returns {number}
     */
    get localWeekday() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
    }
    /**
     * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
     * because the week can start on different days of the week (see localWeekday) and because a different number of days
     * is required for a week to count as the first week of a year.
     * @returns {number}
     */
    get localWeekNumber() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
    }
    /**
     * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
     * differently, see localWeekNumber.
     * @returns {number}
     */
    get localWeekYear() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
    }
    /**
     * Get the ordinal (meaning the day of the year)
     * @example DateTime.local(2017, 5, 25).ordinal //=> 145
     * @type {number|DateTime}
     */
    get ordinal() {
      return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
    }
    /**
     * Get the human readable short month name, such as 'Oct'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
     * @type {string}
     */
    get monthShort() {
      return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
    }
    /**
     * Get the human readable long month name, such as 'October'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthLong //=> October
     * @type {string}
     */
    get monthLong() {
      return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
    }
    /**
     * Get the human readable short weekday, such as 'Mon'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
     * @type {string}
     */
    get weekdayShort() {
      return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
    }
    /**
     * Get the human readable long weekday, such as 'Monday'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
     * @type {string}
     */
    get weekdayLong() {
      return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
    }
    /**
     * Get the UTC offset of this DateTime in minutes
     * @example DateTime.now().offset //=> -240
     * @example DateTime.utc().offset //=> 0
     * @type {number}
     */
    get offset() {
      return this.isValid ? +this.o : NaN;
    }
    /**
     * Get the short human name for the zone's current offset, for example "EST" or "EDT".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
    get offsetNameShort() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "short",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    /**
     * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
    get offsetNameLong() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "long",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    /**
     * Get whether this zone's offset ever changes, as in a DST.
     * @type {boolean}
     */
    get isOffsetFixed() {
      return this.isValid ? this.zone.isUniversal : null;
    }
    /**
     * Get whether the DateTime is in a DST.
     * @type {boolean}
     */
    get isInDST() {
      if (this.isOffsetFixed) {
        return false;
      } else {
        return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
      }
    }
    /**
     * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
     * in this DateTime's zone. During DST changes local time can be ambiguous, for example
     * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
     * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
     * @returns {DateTime[]}
     */
    getPossibleOffsets() {
      if (!this.isValid || this.isOffsetFixed) {
        return [this];
      }
      const dayMs = 864e5;
      const minuteMs = 6e4;
      const localTS = objToLocalTS(this.c);
      const oEarlier = this.zone.offset(localTS - dayMs);
      const oLater = this.zone.offset(localTS + dayMs);
      const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
      const o2 = this.zone.offset(localTS - oLater * minuteMs);
      if (o1 === o2) {
        return [this];
      }
      const ts1 = localTS - o1 * minuteMs;
      const ts2 = localTS - o2 * minuteMs;
      const c1 = tsToObj(ts1, o1);
      const c22 = tsToObj(ts2, o2);
      if (c1.hour === c22.hour && c1.minute === c22.minute && c1.second === c22.second && c1.millisecond === c22.millisecond) {
        return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
      }
      return [this];
    }
    /**
     * Returns true if this DateTime is in a leap year, false otherwise
     * @example DateTime.local(2016).isInLeapYear //=> true
     * @example DateTime.local(2013).isInLeapYear //=> false
     * @type {boolean}
     */
    get isInLeapYear() {
      return isLeapYear(this.year);
    }
    /**
     * Returns the number of days in this DateTime's month
     * @example DateTime.local(2016, 2).daysInMonth //=> 29
     * @example DateTime.local(2016, 3).daysInMonth //=> 31
     * @type {number}
     */
    get daysInMonth() {
      return daysInMonth(this.year, this.month);
    }
    /**
     * Returns the number of days in this DateTime's year
     * @example DateTime.local(2016).daysInYear //=> 366
     * @example DateTime.local(2013).daysInYear //=> 365
     * @type {number}
     */
    get daysInYear() {
      return this.isValid ? daysInYear(this.year) : NaN;
    }
    /**
     * Returns the number of weeks in this DateTime's year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2004).weeksInWeekYear //=> 53
     * @example DateTime.local(2013).weeksInWeekYear //=> 52
     * @type {number}
     */
    get weeksInWeekYear() {
      return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
    }
    /**
     * Returns the number of weeks in this DateTime's local week year
     * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
     * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
     * @type {number}
     */
    get weeksInLocalWeekYear() {
      return this.isValid ? weeksInWeekYear(
        this.localWeekYear,
        this.loc.getMinDaysInFirstWeek(),
        this.loc.getStartOfWeek()
      ) : NaN;
    }
    /**
     * Returns the resolved Intl options for this DateTime.
     * This is useful in understanding the behavior of formatting methods
     * @param {Object} opts - the same options as toLocaleString
     * @return {Object}
     */
    resolvedLocaleOptions(opts = {}) {
      const { locale: locale2, numberingSystem, calendar } = Formatter.create(
        this.loc.clone(opts),
        opts
      ).resolvedOptions(this);
      return { locale: locale2, numberingSystem, outputCalendar: calendar };
    }
    // TRANSFORM
    /**
     * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
     *
     * Equivalent to {@link DateTime#setZone}('utc')
     * @param {number} [offset=0] - optionally, an offset from UTC in minutes
     * @param {Object} [opts={}] - options to pass to `setZone()`
     * @return {DateTime}
     */
    toUTC(offset3 = 0, opts = {}) {
      return this.setZone(FixedOffsetZone.instance(offset3), opts);
    }
    /**
     * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
     *
     * Equivalent to `setZone('local')`
     * @return {DateTime}
     */
    toLocal() {
      return this.setZone(Settings.defaultZone);
    }
    /**
     * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
     *
     * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
     * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
     * @param {Object} opts - options
     * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
     * @return {DateTime}
     */
    setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
      zone = normalizeZone(zone, Settings.defaultZone);
      if (zone.equals(this.zone)) {
        return this;
      } else if (!zone.isValid) {
        return _DateTime.invalid(unsupportedZone(zone));
      } else {
        let newTS = this.ts;
        if (keepLocalTime || keepCalendarTime) {
          const offsetGuess = zone.offset(this.ts);
          const asObj = this.toObject();
          [newTS] = objToTS(asObj, offsetGuess, zone);
        }
        return clone2(this, { ts: newTS, zone });
      }
    }
    /**
     * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
     * @param {Object} properties - the properties to set
     * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
     * @return {DateTime}
     */
    reconfigure({ locale: locale2, numberingSystem, outputCalendar } = {}) {
      const loc = this.loc.clone({ locale: locale2, numberingSystem, outputCalendar });
      return clone2(this, { loc });
    }
    /**
     * "Set" the locale. Returns a newly-constructed DateTime.
     * Just a convenient alias for reconfigure({ locale })
     * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
     * @return {DateTime}
     */
    setLocale(locale2) {
      return this.reconfigure({ locale: locale2 });
    }
    /**
     * "Set" the values of specified units. Returns a newly-constructed DateTime.
     * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
     *
     * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
     * They cannot be mixed with ISO-week units like `weekday`.
     * @param {Object} values - a mapping of units to numbers
     * @example dt.set({ year: 2017 })
     * @example dt.set({ hour: 8, minute: 30 })
     * @example dt.set({ weekday: 5 })
     * @example dt.set({ year: 2005, ordinal: 234 })
     * @return {DateTime}
     */
    set(values) {
      if (!this.isValid) return this;
      const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
      const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
      const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError(
          "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
        );
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      let mixed;
      if (settingWeekStuff) {
        mixed = weekToGregorian(
          { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
          minDaysInFirstWeek,
          startOfWeek
        );
      } else if (!isUndefined(normalized.ordinal)) {
        mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
      } else {
        mixed = { ...this.toObject(), ...normalized };
        if (isUndefined(normalized.day)) {
          mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
        }
      }
      const [ts, o] = objToTS(mixed, this.o, this.zone);
      return clone2(this, { ts, o });
    }
    /**
     * Add a period of time to this DateTime and return the resulting DateTime
     *
     * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
     * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @example DateTime.now().plus(123) //~> in 123 milliseconds
     * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
     * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
     * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
     * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
     * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
     * @return {DateTime}
     */
    plus(duration) {
      if (!this.isValid) return this;
      const dur = Duration.fromDurationLike(duration);
      return clone2(this, adjustTime(this, dur));
    }
    /**
     * Subtract a period of time to this DateTime and return the resulting DateTime
     * See {@link DateTime#plus}
     * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     @return {DateTime}
     */
    minus(duration) {
      if (!this.isValid) return this;
      const dur = Duration.fromDurationLike(duration).negate();
      return clone2(this, adjustTime(this, dur));
    }
    /**
     * "Set" this DateTime to the beginning of a unit of time.
     * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
     * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
     * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
     * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
     * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
     * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
     * @return {DateTime}
     */
    startOf(unit, { useLocaleWeeks = false } = {}) {
      if (!this.isValid) return this;
      const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
      switch (normalizedUnit) {
        case "years":
          o.month = 1;
        // falls through
        case "quarters":
        case "months":
          o.day = 1;
        // falls through
        case "weeks":
        case "days":
          o.hour = 0;
        // falls through
        case "hours":
          o.minute = 0;
        // falls through
        case "minutes":
          o.second = 0;
        // falls through
        case "seconds":
          o.millisecond = 0;
          break;
        case "milliseconds":
          break;
      }
      if (normalizedUnit === "weeks") {
        if (useLocaleWeeks) {
          const startOfWeek = this.loc.getStartOfWeek();
          const { weekday } = this;
          if (weekday < startOfWeek) {
            o.weekNumber = this.weekNumber - 1;
          }
          o.weekday = startOfWeek;
        } else {
          o.weekday = 1;
        }
      }
      if (normalizedUnit === "quarters") {
        const q = Math.ceil(this.month / 3);
        o.month = (q - 1) * 3 + 1;
      }
      return this.set(o);
    }
    /**
     * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
     * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
     * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
     * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
     * @return {DateTime}
     */
    endOf(unit, opts) {
      return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
    }
    // OUTPUT
    /**
     * Returns a string representation of this DateTime formatted according to the specified format string.
     * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
     * Defaults to en-US if no locale has been specified, regardless of the system's locale.
     * @param {string} fmt - the format string
     * @param {Object} opts - opts to override the configuration options on this DateTime
     * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
     * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
     * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
     * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
     * @return {string}
     */
    toFormat(fmt, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
    }
    /**
     * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
     * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
     * of the DateTime in the assigned locale.
     * Defaults to the system's locale if no locale has been specified
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
     * @param {Object} opts - opts to override the configuration options on this DateTime
     * @example DateTime.now().toLocaleString(); //=> 4/20/2017
     * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
     * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
     * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
     * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
     * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
     * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
     * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
     * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
     * @return {string}
     */
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
    }
    /**
     * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
     * Defaults to the system's locale if no locale has been specified
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
     * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
     * @example DateTime.now().toLocaleParts(); //=> [
     *                                   //=>   { type: 'day', value: '25' },
     *                                   //=>   { type: 'literal', value: '/' },
     *                                   //=>   { type: 'month', value: '05' },
     *                                   //=>   { type: 'literal', value: '/' },
     *                                   //=>   { type: 'year', value: '1982' }
     *                                   //=> ]
     */
    toLocaleParts(opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
     * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
     * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
     * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
     * @return {string}
     */
    toISO({
      format: format3 = "extended",
      suppressSeconds = false,
      suppressMilliseconds = false,
      includeOffset = true,
      extendedZone = false
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      const ext = format3 === "extended";
      let c5 = toISODate(this, ext);
      c5 += "T";
      c5 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
      return c5;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's date component
     * @param {Object} opts - options
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
     * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
     * @return {string}
     */
    toISODate({ format: format3 = "extended" } = {}) {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, format3 === "extended");
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's week date
     * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
     * @return {string}
     */
    toISOWeekDate() {
      return toTechFormat(this, "kkkk-'W'WW-c");
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's time component
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
     * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
     * @return {string}
     */
    toISOTime({
      suppressMilliseconds = false,
      suppressSeconds = false,
      includeOffset = true,
      includePrefix = false,
      extendedZone = false,
      format: format3 = "extended"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      let c5 = includePrefix ? "T" : "";
      return c5 + toISOTime(
        this,
        format3 === "extended",
        suppressSeconds,
        suppressMilliseconds,
        includeOffset,
        extendedZone
      );
    }
    /**
     * Returns an RFC 2822-compatible string representation of this DateTime
     * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
     * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
     * @return {string}
     */
    toRFC2822() {
      return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
     * Specifically, the string conforms to RFC 1123.
     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
     * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
     * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
     * @return {string}
     */
    toHTTP() {
      return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL Date
     * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
     * @return {string}
     */
    toSQLDate() {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, true);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL Time
     * @param {Object} opts - options
     * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
     * @example DateTime.utc().toSQL() //=> '05:15:16.345'
     * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
     * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
     * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
     * @return {string}
     */
    toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
      let fmt = "HH:mm:ss.SSS";
      if (includeZone || includeOffset) {
        if (includeOffsetSpace) {
          fmt += " ";
        }
        if (includeZone) {
          fmt += "z";
        } else if (includeOffset) {
          fmt += "ZZ";
        }
      }
      return toTechFormat(this, fmt, true);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL DateTime
     * @param {Object} opts - options
     * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
     * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
     * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
     * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
     * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
     * @return {string}
     */
    toSQL(opts = {}) {
      if (!this.isValid) {
        return null;
      }
      return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
    }
    /**
     * Returns a string representation of this DateTime appropriate for debugging
     * @return {string}
     */
    toString() {
      return this.isValid ? this.toISO() : INVALID3;
    }
    /**
     * Returns a string representation of this DateTime appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
      } else {
        return `DateTime { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    /**
     * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
     * @return {number}
     */
    valueOf() {
      return this.toMillis();
    }
    /**
     * Returns the epoch milliseconds of this DateTime.
     * @return {number}
     */
    toMillis() {
      return this.isValid ? this.ts : NaN;
    }
    /**
     * Returns the epoch seconds of this DateTime.
     * @return {number}
     */
    toSeconds() {
      return this.isValid ? this.ts / 1e3 : NaN;
    }
    /**
     * Returns the epoch seconds (as a whole number) of this DateTime.
     * @return {number}
     */
    toUnixInteger() {
      return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
    }
    /**
     * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
     * @return {string}
     */
    toJSON() {
      return this.toISO();
    }
    /**
     * Returns a BSON serializable equivalent to this DateTime.
     * @return {Date}
     */
    toBSON() {
      return this.toJSDate();
    }
    /**
     * Returns a JavaScript object with this DateTime's year, month, day, and so on.
     * @param opts - options for generating the object
     * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
     * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
     * @return {Object}
     */
    toObject(opts = {}) {
      if (!this.isValid) return {};
      const base = { ...this.c };
      if (opts.includeConfig) {
        base.outputCalendar = this.outputCalendar;
        base.numberingSystem = this.loc.numberingSystem;
        base.locale = this.loc.locale;
      }
      return base;
    }
    /**
     * Returns a JavaScript Date equivalent to this DateTime.
     * @return {Date}
     */
    toJSDate() {
      return new Date(this.isValid ? this.ts : NaN);
    }
    // COMPARE
    /**
     * Return the difference between two DateTimes as a Duration.
     * @param {DateTime} otherDateTime - the DateTime to compare this one to
     * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @example
     * var i1 = DateTime.fromISO('1982-05-25T09:45'),
     *     i2 = DateTime.fromISO('1983-10-14T10:30');
     * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
     * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
     * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
     * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
     * @return {Duration}
     */
    diff(otherDateTime, unit = "milliseconds", opts = {}) {
      if (!this.isValid || !otherDateTime.isValid) {
        return Duration.invalid("created by diffing an invalid DateTime");
      }
      const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
      const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
      return otherIsLater ? diffed.negate() : diffed;
    }
    /**
     * Return the difference between this DateTime and right now.
     * See {@link DateTime#diff}
     * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @return {Duration}
     */
    diffNow(unit = "milliseconds", opts = {}) {
      return this.diff(_DateTime.now(), unit, opts);
    }
    /**
     * Return an Interval spanning between this DateTime and another DateTime
     * @param {DateTime} otherDateTime - the other end point of the Interval
     * @return {Interval}
     */
    until(otherDateTime) {
      return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
    }
    /**
     * Return whether this DateTime is in the same unit of time as another DateTime.
     * Higher-order units must also be identical for this function to return `true`.
     * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
     * @param {DateTime} otherDateTime - the other DateTime
     * @param {string} unit - the unit of time to check sameness on
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
     * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
     * @return {boolean}
     */
    hasSame(otherDateTime, unit, opts) {
      if (!this.isValid) return false;
      const inputMs = otherDateTime.valueOf();
      const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
      return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
    }
    /**
     * Equality check
     * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
     * To compare just the millisecond values, use `+dt1 === +dt2`.
     * @param {DateTime} other - the other DateTime
     * @return {boolean}
     */
    equals(other) {
      return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
    }
    /**
     * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
     * platform supports Intl.RelativeTimeFormat. Rounds down by default.
     * @param {Object} options - options that affect the output
     * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
     * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
     * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
     * @param {boolean} [options.round=true] - whether to round the numbers in the output.
     * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
     * @param {string} options.locale - override the locale of this DateTime
     * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
     * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
     * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
     * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
     * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
     * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
     * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
     */
    toRelative(options = {}) {
      if (!this.isValid) return null;
      const base = options.base || _DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
      let units = ["years", "months", "days", "hours", "minutes", "seconds"];
      let unit = options.unit;
      if (Array.isArray(options.unit)) {
        units = options.unit;
        unit = void 0;
      }
      return diffRelative(base, this.plus(padding), {
        ...options,
        numeric: "always",
        units,
        unit
      });
    }
    /**
     * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
     * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
     * @param {Object} options - options that affect the output
     * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
     * @param {string} options.locale - override the locale of this DateTime
     * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
     * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
     * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
     * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
     * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
     * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
     */
    toRelativeCalendar(options = {}) {
      if (!this.isValid) return null;
      return diffRelative(options.base || _DateTime.fromObject({}, { zone: this.zone }), this, {
        ...options,
        numeric: "auto",
        units: ["years", "months", "days"],
        calendary: true
      });
    }
    /**
     * Return the min of several date times
     * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
     * @return {DateTime} the min DateTime, or undefined if called with no argument
     */
    static min(...dateTimes) {
      if (!dateTimes.every(_DateTime.isDateTime)) {
        throw new InvalidArgumentError("min requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
    }
    /**
     * Return the max of several date times
     * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
     * @return {DateTime} the max DateTime, or undefined if called with no argument
     */
    static max(...dateTimes) {
      if (!dateTimes.every(_DateTime.isDateTime)) {
        throw new InvalidArgumentError("max requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
    }
    // MISC
    /**
     * Explain how a string would be parsed by fromFormat()
     * @param {string} text - the string to parse
     * @param {string} fmt - the format the string is expected to be in (see description)
     * @param {Object} options - options taken by fromFormat()
     * @return {Object}
     */
    static fromFormatExplain(text, fmt, options = {}) {
      const { locale: locale2 = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
        locale: locale2,
        numberingSystem,
        defaultToEN: true
      });
      return explainFromTokens(localeToUse, text, fmt);
    }
    /**
     * @deprecated use fromFormatExplain instead
     */
    static fromStringExplain(text, fmt, options = {}) {
      return _DateTime.fromFormatExplain(text, fmt, options);
    }
    /**
     * Build a parser for `fmt` using the given locale. This parser can be passed
     * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
     * can be used to optimize cases where many dates need to be parsed in a
     * specific format.
     *
     * @param {String} fmt - the format the string is expected to be in (see
     * description)
     * @param {Object} options - options used to set locale and numberingSystem
     * for parser
     * @returns {TokenParser} - opaque object to be used
     */
    static buildFormatParser(fmt, options = {}) {
      const { locale: locale2 = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
        locale: locale2,
        numberingSystem,
        defaultToEN: true
      });
      return new TokenParser(localeToUse, fmt);
    }
    /**
     * Create a DateTime from an input string and format parser.
     *
     * The format parser must have been created with the same locale as this call.
     *
     * @param {String} text - the string to parse
     * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
     * @param {Object} opts - options taken by fromFormat()
     * @returns {DateTime}
     */
    static fromFormatParser(text, formatParser, opts = {}) {
      if (isUndefined(text) || isUndefined(formatParser)) {
        throw new InvalidArgumentError(
          "fromFormatParser requires an input string and a format parser"
        );
      }
      const { locale: locale2 = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
        locale: locale2,
        numberingSystem,
        defaultToEN: true
      });
      if (!localeToUse.equals(formatParser.locale)) {
        throw new InvalidArgumentError(
          `fromFormatParser called with a locale of ${localeToUse}, but the format parser was created for ${formatParser.locale}`
        );
      }
      const { result, zone, specificOffset, invalidReason } = formatParser.explainFromTokens(text);
      if (invalidReason) {
        return _DateTime.invalid(invalidReason);
      } else {
        return parseDataToDateTime(
          result,
          zone,
          opts,
          `format ${formatParser.format}`,
          text,
          specificOffset
        );
      }
    }
    // FORMAT PRESETS
    /**
     * {@link DateTime#toLocaleString} format like 10/14/1983
     * @type {Object}
     */
    static get DATE_SHORT() {
      return DATE_SHORT;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
     * @type {Object}
     */
    static get DATE_MED() {
      return DATE_MED;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
     * @type {Object}
     */
    static get DATE_MED_WITH_WEEKDAY() {
      return DATE_MED_WITH_WEEKDAY;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983'
     * @type {Object}
     */
    static get DATE_FULL() {
      return DATE_FULL;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
     * @type {Object}
     */
    static get DATE_HUGE() {
      return DATE_HUGE;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_SIMPLE() {
      return TIME_SIMPLE;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_SECONDS() {
      return TIME_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_SHORT_OFFSET() {
      return TIME_WITH_SHORT_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_LONG_OFFSET() {
      return TIME_WITH_LONG_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_SIMPLE() {
      return TIME_24_SIMPLE;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_SECONDS() {
      return TIME_24_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_SHORT_OFFSET() {
      return TIME_24_WITH_SHORT_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_LONG_OFFSET() {
      return TIME_24_WITH_LONG_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_SHORT() {
      return DATETIME_SHORT;
    }
    /**
     * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_SHORT_WITH_SECONDS() {
      return DATETIME_SHORT_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED() {
      return DATETIME_MED;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED_WITH_SECONDS() {
      return DATETIME_MED_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED_WITH_WEEKDAY() {
      return DATETIME_MED_WITH_WEEKDAY;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_FULL() {
      return DATETIME_FULL;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_FULL_WITH_SECONDS() {
      return DATETIME_FULL_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_HUGE() {
      return DATETIME_HUGE;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_HUGE_WITH_SECONDS() {
      return DATETIME_HUGE_WITH_SECONDS;
    }
  };
  function friendlyDateTime(dateTimeish) {
    if (DateTime.isDateTime(dateTimeish)) {
      return dateTimeish;
    } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
      return DateTime.fromJSDate(dateTimeish);
    } else if (dateTimeish && typeof dateTimeish === "object") {
      return DateTime.fromObject(dateTimeish);
    } else {
      throw new InvalidArgumentError(
        `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
      );
    }
  }

  // engine/rails_design/app/javascripts/stimulus_com/slide.js
  var slide_default = class extends touch_default {
    static values = {
      delay: { type: Number, default: 0 }
      // 是否循环播放，延迟时间，单位为秒
    };
    static targets = ["container", "dot"];
    connect() {
      this.element.addEventListener("touchstart", (event) => {
        this.start(event);
      }, { passive: true });
      this.element.addEventListener("dragstart", (event) => {
        this.start(event);
      });
      const ele = this.containerTarget.firstElementChild;
      ele.classList.add("is-active");
      if (this.containerTarget.childElementCount > 1 && this.hasDelayValue && this.delayValue > 0) {
        ele.style.left = 0;
        this.mode(ele);
      }
    }
    mode(ele) {
      const next = this.next(ele);
      next.style.left = this.containerTarget.clientWidth + "px";
      this.timerId = setTimeout(() => {
        this.direction = "left";
        this.shiftLeft(ele);
        console.debug("Time:", DateTime.now().toFormat("TT"), "Timer Id:", this.timerId);
      }, this.delayValue * 1e3, ele);
    }
    start(event) {
      if (this.containerTarget.childElementCount <= 1) {
        return;
      }
      this.initStatus(event);
      if (this.timerId) {
        clearTimeout(this.timerId);
      }
      const ele = event.target.closest("[data-index]");
      this.left = ele.offsetLeft;
      ele.style.left = this.left + "px";
      ele.classList.remove("transition");
      if (this.direction === "left") {
        const next = this.next(ele);
        if (next) {
          next.style.left = this.containerTarget.clientWidth + this.left + "px";
          next.classList.remove("transition");
        }
      } else if (this.direction === "right") {
        const prev = this.prev(ele);
        if (prev) {
          prev.style.left = this.left - this.containerTarget.clientWidth + "px";
          prev.classList.remove("transition");
        }
      }
      ele.removeEventListener("transitioncancel", this.beenCurrentAfter);
      ele.removeEventListener("transitionend", this.beenCurrentAfter);
    }
    // data-action="touchmove->slide#move:passive"
    // data-action="onmousemove->slide"
    move(event) {
      event.stopPropagation();
      const ele = event.currentTarget;
      console.debug("moved by element:", ele.dataset.index);
      if (this.zoomed(event) || this.containerTarget.childElementCount <= 1) {
        return;
      }
      const offset3 = this.offset(event);
      const pad3 = Math.abs(offset3.x);
      if (!this.isHorizontal(pad3, offset3)) {
        return;
      }
      ele.style.left = this.left + offset3.x + "px";
      let along;
      if (offset3.x < 0) {
        along = this.next(ele);
        if (along) {
          if (this.direction === "left") {
            along.style.left = this.containerTarget.clientWidth + this.left + offset3.x + "px";
          } else if (this.direction === "right") {
            along.style.left = this.containerTarget.clientWidth + this.left + offset3.x + "px";
          } else {
            along.style.left = this.containerTarget.clientWidth + this.left + offset3.x + "px";
          }
        }
      } else if (offset3.x > 0) {
        along = this.prev(ele);
        if (along) {
          if (this.direction === "left") {
            along.style.left = this.containerTarget.clientWidth + this.left + offset3.x + "px";
          } else if (this.direction === "right") {
            along.style.left = -this.containerTarget.clientWidth + this.left + offset3.x + "px";
          } else {
            along.style.left = -this.containerTarget.clientWidth + this.left + offset3.x + "px";
          }
        }
      }
      if (along) {
        along.classList.add("is-active");
      }
    }
    // data-action="touchend->slide#end:passive"
    end(event) {
      if (this.zoomed(event) || this.containerTarget.childElementCount <= 1) {
        return;
      }
      const ele = event.currentTarget;
      const offset3 = this.offset(event);
      const pad3 = Math.abs(offset3.x);
      if (!this.isHorizontal(pad3, offset3)) {
        console.debug("not scrolling", offset3);
        this.rollback(offset3, ele);
      } else {
        if (this.effective(pad3)) {
          this.going(offset3, ele);
        } else {
          if (this.direction === "left") {
            this.shiftLeft(ele);
          } else if (this.direction === "right") {
            this.shiftRight(ele);
          } else {
            this.rollback(offset3, ele);
          }
        }
      }
    }
    // 执行翻页
    going(offset3, ele) {
      if (offset3.x < 0) {
        this.direction = "left";
        this.shiftLeft(ele);
      }
      if (offset3.x > 0) {
        if (this.direction === "left") {
          this.direction = "right";
          this.shiftRight(this.next(ele), ele);
        } else {
          this.direction = "right";
          this.shiftRight(ele);
        }
      }
    }
    // 回退到之前的状态
    rollback(offset3, ele) {
      const next = this.next(ele);
      if (offset3.x < 0 && next) {
        this.shiftRight(next);
      }
      const prev = this.prev(ele);
      if (offset3.x > 0 && prev) {
        this.shiftLeft(prev);
      }
    }
    // ele 向左滑出
    shiftLeft(left2, right2 = this.next(left2)) {
      if (right2) {
        left2.classList.add("transition");
        this.beenCurrent(left2);
        right2.classList.add("transition");
        this.toCurrent(right2);
      } else {
        left2.classList.add("transition");
        this.toCurrent(left2);
      }
    }
    // ele 向右滑出
    shiftRight(right2, left2 = this.prev(right2)) {
      if (left2) {
        left2.classList.add("transition");
        this.toCurrent(left2);
        right2.classList.add("transition");
        this.beenCurrent(right2, this.containerTarget.clientWidth + "px");
      } else {
        right2.classList.add("transition");
        this.toCurrent(right2);
      }
    }
    // 不再展示
    beenCurrent(ele, left2 = -this.containerTarget.clientWidth + "px") {
      console.debug("add transition event beenCurrentAfter for been", ele.dataset.index);
      ele.style.left = left2;
      if (this.hasDotTarget) {
        const dot8 = this.dotTarget.children[ele.dataset.index];
        dot8.classList.replace("has-text-white", "has-text-black");
      }
      ele.addEventListener("transitionend", this.beenCurrentAfter, { once: true });
      ele.addEventListener("transitioncancel", this.beenCurrentAfter, { once: true });
    }
    // this become event.target
    beenCurrentAfter(event) {
      const ele = event.currentTarget;
      console.debug(ele.dataset.index, "been Current After", event.type);
      ele.classList.remove("is-active");
      const controller = ele.closest("[data-controller~=slide]").getController("slide");
      controller.direction = null;
      if (!controller) {
        return;
      }
      if (event.type === "transitionend") {
        ele.classList.remove("transition");
        ele.removeEventListener("transitioncancel", controller.beenCurrentAfter);
      } else if (event.type === "transitioncancel") {
        ele.removeEventListener("transitionend", controller.beenCurrentAfter);
      }
    }
    // 即将展示
    toCurrent(ele) {
      ele.classList.add("is-active");
      ele.style.left = 0;
      if (this.hasDotTarget) {
        const dot8 = this.dotTarget.children[ele.dataset.index];
        dot8.classList.replace("has-text-black", "has-text-white");
      }
      console.debug("add transition event toCurrentAfter for to", ele.dataset.index);
      ele.addEventListener("transitionend", this.toCurrentAfter, { once: true });
      ele.addEventListener("transitioncancel", this.toCurrentAfter, { once: true });
    }
    toCurrentAfter(event) {
      const ele = event.currentTarget;
      console.debug(ele.dataset.index, "to Current after", event.type);
      const controller = ele.closest("[data-controller~=slide]").getController("slide");
      controller.direction = null;
      if (!controller) {
        return;
      }
      if (event.type === "transitionend") {
        ele.classList.remove("transition");
        if (controller.hasDelayValue && controller.delayValue > 0) {
          controller.mode(ele);
        }
        ele.removeEventListener("transitioncancel", controller.toCurrentAfter);
      } else if (event.type === "transitioncancel") {
        ele.removeEventListener("transitionend", controller.toCurrentAfter);
      }
    }
    next(ele) {
      if (this.hasDelayValue) {
        return ele.nextElementSibling || this.containerTarget.firstElementChild;
      } else {
        return ele.nextElementSibling;
      }
    }
    prev(ele) {
      if (this.hasDelayValue) {
        return ele.previousElementSibling || this.containerTarget.lastElementChild;
      } else {
        return ele.previousElementSibling;
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/slide_y.js
  var slide_y_default = class extends slide_default {
    connect() {
      super.connect();
    }
    // data-action="touchmove->slide-y#move:passive"
    move(event) {
      const ele = event.currentTarget;
      console.debug("touch moved by:", ele.dataset.index);
      if (this.zoomed(event)) {
        console.error("scale");
        return;
      }
      let offset3 = this.offset(event);
      let pad_y = Math.abs(offset3.y);
      let isScrolling = pad_y > Math.abs(offset3.x) ? 1 : 0;
      if (isScrolling === 0) {
        return;
      }
      if (offset3.y < 0) {
        let next = ele.nextElementSibling;
        if (next) {
          this.slidingToTop(ele, next, pad_y);
        }
      } else if (offset3.y > 0) {
        let prev = ele.previousElementSibling;
        if (prev) {
          this.slidingToBottom(ele, prev, pad_y);
        }
      }
    }
    // data-action="touchend->slide-y#end:passive"
    end(event) {
      if (this.zoomed(event)) {
        return;
      }
      let ele = event.currentTarget;
      let offset3 = this.offset(event);
      let pad_y = Math.abs(offset3.y);
      let isScrolling = pad_y > Math.abs(offset3.x) ? 1 : 0;
      if (isScrolling === 0) {
        console.debug("not scrolling");
        this.rollback(offset3, ele);
      }
      if (this.effective(pad_y, false)) {
        this.going(offset3, ele);
      } else {
        this.rollback(offset3, ele);
      }
    }
    // 执行翻页
    going(offset3, ele) {
      const next = ele.nextElementSibling;
      const prev = ele.previousElementSibling;
      if (offset3.y < 0 && next) {
        this.closeToTop(next);
        next.style.zIndex = 0;
        this.toCurrent(next);
        this.awayFromBottom(ele);
        ele.style.zIndex = -1;
        this.beenCurrent(ele);
      }
      if (offset3.y > 0 && prev) {
        this.closeToBottom(prev);
        prev.style.zIndex = 0;
        this.toCurrent(prev);
        this.awayFromTop(ele);
        ele.style.zIndex = -1;
        this.beenCurrent(ele);
      }
    }
    // 回退到之前的状态
    rollback(offset3, ele) {
      const next = ele.nextElementSibling;
      const prev = ele.previousElementSibling;
      if (offset3.y < 0 && next) {
        this.closeToBottom(ele);
        this.toCurrent(ele);
        this.awayFromTop(next);
        this.beenCurrent(next);
      }
      if (offset3.y > 0 && prev) {
        this.closeToTop(ele);
        this.toCurrent(ele);
        this.awayFromBottom(prev);
        this.beenCurrent(prev);
      }
    }
    // 上滑
    slidingToTop(ele, next, pad3) {
      ele.style.bottom = pad3 + "px";
      next.style.zIndex = -1;
      next.style.top = this.element.clientHeight - pad3 + "px";
    }
    // 下滑
    slidingToBottom(ele, prev, pad3) {
      ele.style.top = pad3 + "px";
      prev.style.zIndex = -1;
      prev.style.bottom = this.element.clientHeight - pad3 + "px";
    }
    // xx
    resetIndex(event) {
      ["top", "bottom", "transition-property", "transition-duration"].forEach((rule) => {
        event.currentTarget.style.removeProperty(rule);
      });
      event.currentTarget.style.zIndex = -2;
    }
    // 不再展示
    beenCurrent(ele) {
      console.debug("add transition event listener for been", ele.dataset.index);
      ele.addEventListener("transitionend", this.resetIndex, { once: true });
      ele.addEventListener("transitioncancel", (event) => {
        this.resetIndex(event);
        ele.removeEventListener("transitionend", this.resetIndex);
      }, { once: true });
    }
    // 即将展示
    toCurrent(ele) {
      console.debug("add transition event listener for to", ele.dataset.index);
      ele.addEventListener("transitionend", (event) => {
        this.clearStyle(event.currentTarget);
      }, { once: true });
      ele.addEventListener("transitioncancel", (event) => {
        this.clearStyle(event.currentTarget);
      }, { once: true });
    }
    // 接近上侧
    closeToTop(ele) {
      ele.style.top = 0;
      ele.style.transitionProperty = "top";
      ele.style.transitionDuration = this.duration;
    }
    // 接近下侧
    closeToBottom(ele) {
      ele.style.bottom = 0;
      ele.style.transitionProperty = "bottom";
      ele.style.transitionDuration = this.duration;
    }
    // 远离下侧
    awayFromBottom(ele) {
      ele.style.bottom = this.element.clientHeight + "px";
      ele.style.transitionProperty = "bottom";
      ele.style.transitionDuration = this.duration;
    }
    // 远离上侧
    awayFromTop(ele) {
      ele.style.top = this.element.clientHeight + "px";
      ele.style.transitionProperty = "top";
      ele.style.transitionDuration = this.duration;
    }
    clearStyle(ele) {
      ["top", "bottom", "transition-property", "transition-duration"].forEach((rule) => {
        ele.style.removeProperty(rule);
      });
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/sticky-bottom.js
  var sticky_bottom_default = class extends Controller {
    static targets = ["order", "children"];
    static values = {
      threshold: { type: Number, default: 0.35 },
      delay: { type: Number, default: 0.2 }
    };
    connect() {
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((el) => {
            console.debug("--------", el.intersectionRatio);
            el.target.classList.toggle("is-active", el.intersectionRatio < 1);
          });
        },
        {
          threshold: 1,
          root: this.element.parentNode
        }
      );
      this.observer.observe(this.element);
    }
    disconnect() {
      this.observer.disconnect();
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/swipe.js
  var swipe_default = class extends touch_default {
    static targets = ["open"];
    // data-action="touchstart->swipe#start:passive"
    start(event) {
      this.initStatus(event);
      this.barWidth = this.element.clientWidth;
      this.swiperWidth = this.openTarget.clientWidth;
    }
    // data-action="touchmove->swipe#move touchstart->swipe#move"
    move(event) {
      if (this.zoomed(event)) {
        return;
      }
      const offset3 = this.offset(event);
      const pad3 = Math.abs(offset3.x);
      const isScrolling = pad3 > Math.abs(offset3.y) ? 1 : 0;
      if (isScrolling === 0) {
        return;
      }
      if (offset3.x < 0) {
        this.openTarget.style.width = `${this.swiperWidth + pad3}px`;
        let styles = {
          width: `${this.barWidth - this.swiperWidth + this.openTarget.clientWidth}px`,
          left: `-${this.openTarget.clientWidth}px`
        };
        Object.assign(this.element.style, styles);
      } else if (offset3.x > 0) {
        let x3 = pad3 < this.swiperWidth ? this.swiperWidth - pad3 : 0;
        this.openTarget.style.width = `${x3}px`;
        let styles = {
          width: `${this.barWidth - (pad3 < this.swiperWidth ? pad3 : this.swiperWidth)}px`,
          left: `-${x3}px`
        };
        Object.assign(this.element.style, styles);
      }
    }
    end(event) {
      this.openTarget.style.width = `${this.openTarget.clientWidth}px`;
    }
    get leftPos() {
      let left2 = this.element.style.left.replace(/px$/, "");
      return parseFloat(left2);
    }
    get barWidth() {
      return parseFloat(this.data.get("barWidth"));
    }
    set barWidth(value2) {
      this.data.set("barWidth", value2);
    }
    get swiperWidth() {
      return parseFloat(this.data.get("swiperWidth"));
    }
    set swiperWidth(value2) {
      this.data.set("swiperWidth", value2);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/switch.js
  var switch_default = class extends Controller {
    static targets = ["src"];
    toggle(event) {
      this.srcTargets.forEach((el) => {
        el.classList.toggle("display-none");
      });
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/time.js
  window.DateTime = DateTime;
  var time_default = class extends Controller {
    static values = {
      localized: Boolean
    };
    connect() {
      this.parse();
    }
    parse() {
      if (this.localizedValue) {
        return;
      }
      if (this.str) {
        const time = DateTime.fromISO(this.str);
        this.element.innerText = time.toFormat(this.format);
        this.localizedValue = true;
      }
    }
    get str() {
      const value2 = this.element.dataset["value"];
      if (value2) {
        return value2;
      } else if (this.element.innerText.length > 0) {
        return this.element.innerText;
      }
    }
    // xx => 'yyyy-MM-dd HH:mm:ss'
    get format() {
      let fmt = this.element.dataset["format"];
      if (fmt === "human") {
        return "yyyy-MM-dd HH:mm:ss";
      } else {
        return fmt || "yyyy-MM-dd HH:mm";
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/time-count.js
  window.Duration = Duration;
  var time_count_default = class extends Controller {
    static values = {
      time: String,
      diff: { type: Array, default: ["years", "months", "days", "hours", "minutes", "seconds"] }
    };
    connect() {
      this.count();
    }
    count() {
      const time = DateTime.fromISO(this.timeValue);
      const now4 = DateTime.now();
      let result;
      if (time > now4) {
        result = time.diff(now4, this.diffValue);
      } else {
        result = now4.diff(time, this.diffValue);
      }
      let format3 = ["y\u5E74", "M\u6708", "d\u5929", "h\u65F6", "mm\u5206", "ss\u79D2"];
      let result_format;
      const timer2 = setInterval(() => {
        let step2;
        if (result > 0) {
          step2 = 1;
        } else {
          step2 = -1;
        }
        result = result.plus({ seconds: step2 });
        for (const [index4, value2] of Object.values(result.values).entries()) {
          if (value2 > 0) {
            result_format = format3.slice(index4);
            break;
          }
        }
        if (result <= 0) {
          this.element.textContent = result.toFormat(result_format.join(""));
          clearInterval(timer2);
        } else {
          this.element.textContent = result.toFormat(result_format.join(""));
        }
      }, 1e3, result);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/tree.js
  var tree_default = class extends Controller {
    static targets = ["item"];
    collapse(event) {
      const ele = event.currentTarget;
      const par = this.itemTarget;
      let el = par.nextElementSibling;
      while (el && el.dataset["depth"] !== par.dataset["depth"] && par.dataset["depth"].endsWith(el.dataset["depth"])) {
        el.style.display = "none";
        el = el.nextElementSibling;
      }
      ele.classList.replace("fa-caret-down", "fa-caret-right");
      ele.dataset["action"] = "click->tree#expand";
    }
    expand(event) {
      const ele = event.currentTarget;
      const par = this.itemTarget;
      let el = par.nextElementSibling;
      while (el && el.dataset["depth"] !== par.dataset["depth"] && par.dataset["depth"].endsWith(el.dataset["depth"])) {
        el.style.display = "table-row";
        el = el.nextElementSibling;
      }
      ele.classList.replace("fa-caret-right", "fa-caret-down");
      ele.dataset["action"] = "click->tree#collapse";
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/tree_remote.js
  var tree_remote_default = class extends Controller {
    static targets = ["item", "checkbox"];
    static values = {
      hide: Boolean
    };
    connect() {
      if (this.hideValue) {
        this.collapseDirect();
      }
    }
    collapseDirect() {
      let el = this.element.nextElementSibling;
      while (el && el.id.startsWith(this.element.id)) {
        let to_remove = el;
        el = el.nextElementSibling;
        to_remove.remove();
      }
    }
    collapseCheckbox() {
      this.checkboxTargets.forEach((el) => {
        if (el.elements["expand"]) {
          el.elements["expand"].value = null;
        }
      });
    }
    collapse(event) {
      const ele = event.currentTarget;
      const par = this.itemTarget;
      ele.parentNode.addEventListener("click", this.disableLink);
      let el = par.nextElementSibling;
      while (el && el.id.startsWith(par.id)) {
        let to_remove = el;
        el = el.nextElementSibling;
        to_remove.remove();
      }
      this.collapseCheckbox();
      ele.classList.replace("fa-caret-down", "fa-caret-right");
      ele.dataset["action"] = "click->tree-remote#expand";
    }
    expand(event) {
      const ele = event.currentTarget;
      ele.parentNode.removeEventListener("click", this.disableLink);
      ele.classList.replace("fa-caret-right", "fa-caret-down");
      ele.dataset["action"] = "click->tree-remote#collapse";
    }
    disableLink(event) {
      event.stopPropagation();
      event.preventDefault();
      return false;
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/video.js
  var video_default = class extends audio_player_default {
    connect() {
      if (["VIDEO", "AUDIO"].includes(this.element.tagName) && this.element.autoplay) {
        if (this.element.played.length === 0) {
          this.element.play();
        }
      } else {
        this.element.querySelectorAll("audio[autoplay=autoplay], video[autoplay=autoplay]").forEach((el) => {
          if (el.played.length === 0) {
            el.play();
          }
        });
      }
    }
    disconnect() {
      super.disconnect();
      if (["VIDEO", "AUDIO"].includes(this.element.tagName)) {
        this.element.remove();
      } else {
        this.element.querySelectorAll("audio, video").forEach((el) => el.remove());
      }
    }
    enableLink(event) {
      const ele = event.currentTarget.closest("a[disabled=disabled]");
      if (ele) {
        ele.removeAttribute("disabled");
      }
    }
    playNext(event) {
      let ele = event.currentTarget;
      console.debug(ele);
      const controller = ele.closest("[data-controller~=video]").getController("video");
      controller.playAnd(ele);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/visit.js
  var visit_default = class extends base_controller_default {
    static values = {
      url: String,
      frame: String,
      reload: Boolean,
      method: String,
      params: Object,
      headers: { type: Object, default: {} }
    };
    connect() {
      if (this.hasFrameValue) {
        this.visit();
      } else if (this.hasMethodValue && this.methodValue && this.methodValue.toUpperCase() !== "GET") {
        this.request(
          this.urlValue,
          this.methodValue,
          JSON.stringify(this.paramsValue),
          { "Content-Type": "application/json", "X-CSRF-Token": this.csrfToken(), ...this.headersValue }
        );
      } else {
        this.addEvent(this.headersValue);
        this.topVisit();
      }
      if (this.hasReloadValue && this.reloadValue) {
        this.replaceAction();
      }
      document.documentElement.classList.remove("is-clipped");
      this.element.remove();
    }
    addEvent(headers) {
      document.addEventListener("turbo:before-fetch-request", (event) => {
        const xhr = event.detail.fetchOptions;
        Object.assign(xhr.headers, headers);
      }, { once: true });
    }
    topVisit() {
      if (this.hasUrlValue) {
        Turbo.visit(this.urlValue, { action: "replace" });
      } else {
        Turbo.visit(location.href, { action: "replace" });
      }
    }
    visit() {
      this.modal.visit(this.urlValue);
    }
    replaceAction() {
      this.modalWrapper.querySelectorAll('[data-action$="modal#close"]').forEach((ele) => {
        ele.dataset.replace("action", "modal#close", "modal#reloadClose");
      });
    }
    get modal() {
      return document.getElementById(this.frameValue).delegate;
    }
    get modalWrapper() {
      return document.getElementById("modal_wrapper");
    }
  };

  // node_modules/sortablejs/modular/sortable.esm.js
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  var version = "1.15.6";
  function userAgent(pattern) {
    if (typeof window !== "undefined" && window.navigator) {
      return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
    }
  }
  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
  var Edge = userAgent(/Edge/i);
  var FireFox = userAgent(/firefox/i);
  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
  var IOS = userAgent(/iP(ad|od|hone)/i);
  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
  var captureMode = {
    capture: false,
    passive: false
  };
  function on(el, event, fn) {
    el.addEventListener(event, fn, !IE11OrLess && captureMode);
  }
  function off(el, event, fn) {
    el.removeEventListener(event, fn, !IE11OrLess && captureMode);
  }
  function matches(el, selector) {
    if (!selector) return;
    selector[0] === ">" && (selector = selector.substring(1));
    if (el) {
      try {
        if (el.matches) {
          return el.matches(selector);
        } else if (el.msMatchesSelector) {
          return el.msMatchesSelector(selector);
        } else if (el.webkitMatchesSelector) {
          return el.webkitMatchesSelector(selector);
        }
      } catch (_2) {
        return false;
      }
    }
    return false;
  }
  function getParentOrHost(el) {
    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
  }
  function closest(el, selector, ctx2, includeCTX) {
    if (el) {
      ctx2 = ctx2 || document;
      do {
        if (selector != null && (selector[0] === ">" ? el.parentNode === ctx2 && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx2) {
          return el;
        }
        if (el === ctx2) break;
      } while (el = getParentOrHost(el));
    }
    return null;
  }
  var R_SPACE = /\s+/g;
  function toggleClass(el, name2, state) {
    if (el && name2) {
      if (el.classList) {
        el.classList[state ? "add" : "remove"](name2);
      } else {
        var className2 = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name2 + " ", " ");
        el.className = (className2 + (state ? " " + name2 : "")).replace(R_SPACE, " ");
      }
    }
  }
  function css(el, prop, val) {
    var style = el && el.style;
    if (style) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el, "");
        } else if (el.currentStyle) {
          val = el.currentStyle;
        }
        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style) && prop.indexOf("webkit") === -1) {
          prop = "-webkit-" + prop;
        }
        style[prop] = val + (typeof val === "string" ? "" : "px");
      }
    }
  }
  function matrix(el, selfOnly) {
    var appliedTransforms = "";
    if (typeof el === "string") {
      appliedTransforms = el;
    } else {
      do {
        var transform = css(el, "transform");
        if (transform && transform !== "none") {
          appliedTransforms = transform + " " + appliedTransforms;
        }
      } while (!selfOnly && (el = el.parentNode));
    }
    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
    return matrixFn && new matrixFn(appliedTransforms);
  }
  function find(ctx2, tagName, iterator) {
    if (ctx2) {
      var list = ctx2.getElementsByTagName(tagName), i = 0, n2 = list.length;
      if (iterator) {
        for (; i < n2; i++) {
          iterator(list[i], i);
        }
      }
      return list;
    }
    return [];
  }
  function getWindowScrollingElement() {
    var scrollingElement = document.scrollingElement;
    if (scrollingElement) {
      return scrollingElement;
    } else {
      return document.documentElement;
    }
  }
  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
    if (!el.getBoundingClientRect && el !== window) return;
    var elRect, top, left2, bottom, right2, height, width;
    if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
      elRect = el.getBoundingClientRect();
      top = elRect.top;
      left2 = elRect.left;
      bottom = elRect.bottom;
      right2 = elRect.right;
      height = elRect.height;
      width = elRect.width;
    } else {
      top = 0;
      left2 = 0;
      bottom = window.innerHeight;
      right2 = window.innerWidth;
      height = window.innerHeight;
      width = window.innerWidth;
    }
    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
      container = container || el.parentNode;
      if (!IE11OrLess) {
        do {
          if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
            var containerRect = container.getBoundingClientRect();
            top -= containerRect.top + parseInt(css(container, "border-top-width"));
            left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
            bottom = top + elRect.height;
            right2 = left2 + elRect.width;
            break;
          }
        } while (container = container.parentNode);
      }
    }
    if (undoScale && el !== window) {
      var elMatrix = matrix(container || el), scaleX2 = elMatrix && elMatrix.a, scaleY2 = elMatrix && elMatrix.d;
      if (elMatrix) {
        top /= scaleY2;
        left2 /= scaleX2;
        width /= scaleX2;
        height /= scaleY2;
        bottom = top + height;
        right2 = left2 + width;
      }
    }
    return {
      top,
      left: left2,
      bottom,
      right: right2,
      width,
      height
    };
  }
  function isScrolledPast(el, elSide, parentSide) {
    var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
    while (parent) {
      var parentSideVal = getRect(parent)[parentSide], visible = void 0;
      if (parentSide === "top" || parentSide === "left") {
        visible = elSideVal >= parentSideVal;
      } else {
        visible = elSideVal <= parentSideVal;
      }
      if (!visible) return parent;
      if (parent === getWindowScrollingElement()) break;
      parent = getParentAutoScrollElement(parent, false);
    }
    return false;
  }
  function getChild(el, childNum, options, includeDragEl) {
    var currentChild = 0, i = 0, children = el.children;
    while (i < children.length) {
      if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
        if (currentChild === childNum) {
          return children[i];
        }
        currentChild++;
      }
      i++;
    }
    return null;
  }
  function lastChild(el, selector) {
    var last4 = el.lastElementChild;
    while (last4 && (last4 === Sortable.ghost || css(last4, "display") === "none" || selector && !matches(last4, selector))) {
      last4 = last4.previousElementSibling;
    }
    return last4 || null;
  }
  function index(el, selector) {
    var index4 = 0;
    if (!el || !el.parentNode) {
      return -1;
    }
    while (el = el.previousElementSibling) {
      if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
        index4++;
      }
    }
    return index4;
  }
  function getRelativeScrollOffset(el) {
    var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
    if (el) {
      do {
        var elMatrix = matrix(el), scaleX2 = elMatrix.a, scaleY2 = elMatrix.d;
        offsetLeft += el.scrollLeft * scaleX2;
        offsetTop += el.scrollTop * scaleY2;
      } while (el !== winScroller && (el = el.parentNode));
    }
    return [offsetLeft, offsetTop];
  }
  function indexOfObject(arr, obj) {
    for (var i in arr) {
      if (!arr.hasOwnProperty(i)) continue;
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
      }
    }
    return -1;
  }
  function getParentAutoScrollElement(el, includeSelf) {
    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
    var elem = el;
    var gotSelf = false;
    do {
      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
        var elemCSS = css(elem);
        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
          if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
          if (gotSelf || includeSelf) return elem;
          gotSelf = true;
        }
      }
    } while (elem = elem.parentNode);
    return getWindowScrollingElement();
  }
  function extend3(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }
    return dst;
  }
  function isRectEqual(rect1, rect22) {
    return Math.round(rect1.top) === Math.round(rect22.top) && Math.round(rect1.left) === Math.round(rect22.left) && Math.round(rect1.height) === Math.round(rect22.height) && Math.round(rect1.width) === Math.round(rect22.width);
  }
  var _throttleTimeout;
  function throttle(callback, ms2) {
    return function() {
      if (!_throttleTimeout) {
        var args = arguments, _this = this;
        if (args.length === 1) {
          callback.call(_this, args[0]);
        } else {
          callback.apply(_this, args);
        }
        _throttleTimeout = setTimeout(function() {
          _throttleTimeout = void 0;
        }, ms2);
      }
    };
  }
  function cancelThrottle() {
    clearTimeout(_throttleTimeout);
    _throttleTimeout = void 0;
  }
  function scrollBy(el, x3, y3) {
    el.scrollLeft += x3;
    el.scrollTop += y3;
  }
  function clone3(el) {
    var Polymer = window.Polymer;
    var $ = window.jQuery || window.Zepto;
    if (Polymer && Polymer.dom) {
      return Polymer.dom(el).cloneNode(true);
    } else if ($) {
      return $(el).clone(true)[0];
    } else {
      return el.cloneNode(true);
    }
  }
  function getChildContainingRectFromElement(container, options, ghostEl2) {
    var rect4 = {};
    Array.from(container.children).forEach(function(child) {
      var _rect$left, _rect$top, _rect$right, _rect$bottom;
      if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl2) return;
      var childRect = getRect(child);
      rect4.left = Math.min((_rect$left = rect4.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
      rect4.top = Math.min((_rect$top = rect4.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
      rect4.right = Math.max((_rect$right = rect4.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
      rect4.bottom = Math.max((_rect$bottom = rect4.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
    });
    rect4.width = rect4.right - rect4.left;
    rect4.height = rect4.bottom - rect4.top;
    rect4.x = rect4.left;
    rect4.y = rect4.top;
    return rect4;
  }
  var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
  function AnimationStateManager() {
    var animationStates = [], animationCallbackId;
    return {
      captureAnimationState: function captureAnimationState() {
        animationStates = [];
        if (!this.options.animation) return;
        var children = [].slice.call(this.el.children);
        children.forEach(function(child) {
          if (css(child, "display") === "none" || child === Sortable.ghost) return;
          animationStates.push({
            target: child,
            rect: getRect(child)
          });
          var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
          if (child.thisAnimationDuration) {
            var childMatrix = matrix(child, true);
            if (childMatrix) {
              fromRect.top -= childMatrix.f;
              fromRect.left -= childMatrix.e;
            }
          }
          child.fromRect = fromRect;
        });
      },
      addAnimationState: function addAnimationState(state) {
        animationStates.push(state);
      },
      removeAnimationState: function removeAnimationState(target) {
        animationStates.splice(indexOfObject(animationStates, {
          target
        }), 1);
      },
      animateAll: function animateAll(callback) {
        var _this = this;
        if (!this.options.animation) {
          clearTimeout(animationCallbackId);
          if (typeof callback === "function") callback();
          return;
        }
        var animating = false, animationTime = 0;
        animationStates.forEach(function(state) {
          var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
          if (targetMatrix) {
            toRect.top -= targetMatrix.f;
            toRect.left -= targetMatrix.e;
          }
          target.toRect = toRect;
          if (target.thisAnimationDuration) {
            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
            }
          }
          if (!isRectEqual(toRect, fromRect)) {
            target.prevFromRect = fromRect;
            target.prevToRect = toRect;
            if (!time) {
              time = _this.options.animation;
            }
            _this.animate(target, animatingRect, toRect, time);
          }
          if (time) {
            animating = true;
            animationTime = Math.max(animationTime, time);
            clearTimeout(target.animationResetTimer);
            target.animationResetTimer = setTimeout(function() {
              target.animationTime = 0;
              target.prevFromRect = null;
              target.fromRect = null;
              target.prevToRect = null;
              target.thisAnimationDuration = null;
            }, time);
            target.thisAnimationDuration = time;
          }
        });
        clearTimeout(animationCallbackId);
        if (!animating) {
          if (typeof callback === "function") callback();
        } else {
          animationCallbackId = setTimeout(function() {
            if (typeof callback === "function") callback();
          }, animationTime);
        }
        animationStates = [];
      },
      animate: function animate2(target, currentRect, toRect, duration) {
        if (duration) {
          css(target, "transition", "");
          css(target, "transform", "");
          var elMatrix = matrix(this.el), scaleX2 = elMatrix && elMatrix.a, scaleY2 = elMatrix && elMatrix.d, translateX2 = (currentRect.left - toRect.left) / (scaleX2 || 1), translateY2 = (currentRect.top - toRect.top) / (scaleY2 || 1);
          target.animatingX = !!translateX2;
          target.animatingY = !!translateY2;
          css(target, "transform", "translate3d(" + translateX2 + "px," + translateY2 + "px,0)");
          this.forRepaintDummy = repaint(target);
          css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
          css(target, "transform", "translate3d(0,0,0)");
          typeof target.animated === "number" && clearTimeout(target.animated);
          target.animated = setTimeout(function() {
            css(target, "transition", "");
            css(target, "transform", "");
            target.animated = false;
            target.animatingX = false;
            target.animatingY = false;
          }, duration);
        }
      }
    };
  }
  function repaint(target) {
    return target.offsetWidth;
  }
  function calculateRealTime(animatingRect, fromRect, toRect, options) {
    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
  }
  var plugins = [];
  var defaults = {
    initializeByDefault: true
  };
  var PluginManager = {
    mount: function mount(plugin) {
      for (var option2 in defaults) {
        if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
          plugin[option2] = defaults[option2];
        }
      }
      plugins.forEach(function(p2) {
        if (p2.pluginName === plugin.pluginName) {
          throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
        }
      });
      plugins.push(plugin);
    },
    pluginEvent: function pluginEvent(eventName, sortable, evt) {
      var _this = this;
      this.eventCanceled = false;
      evt.cancel = function() {
        _this.eventCanceled = true;
      };
      var eventNameGlobal = eventName + "Global";
      plugins.forEach(function(plugin) {
        if (!sortable[plugin.pluginName]) return;
        if (sortable[plugin.pluginName][eventNameGlobal]) {
          sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
            sortable
          }, evt));
        }
        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
          sortable[plugin.pluginName][eventName](_objectSpread2({
            sortable
          }, evt));
        }
      });
    },
    initializePlugins: function initializePlugins(sortable, el, defaults5, options) {
      plugins.forEach(function(plugin) {
        var pluginName = plugin.pluginName;
        if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
        var initialized = new plugin(sortable, el, sortable.options);
        initialized.sortable = sortable;
        initialized.options = sortable.options;
        sortable[pluginName] = initialized;
        _extends(defaults5, initialized.defaults);
      });
      for (var option2 in sortable.options) {
        if (!sortable.options.hasOwnProperty(option2)) continue;
        var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
        if (typeof modified !== "undefined") {
          sortable.options[option2] = modified;
        }
      }
    },
    getEventProperties: function getEventProperties(name2, sortable) {
      var eventProperties = {};
      plugins.forEach(function(plugin) {
        if (typeof plugin.eventProperties !== "function") return;
        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name2));
      });
      return eventProperties;
    },
    modifyOption: function modifyOption(sortable, name2, value2) {
      var modifiedValue;
      plugins.forEach(function(plugin) {
        if (!sortable[plugin.pluginName]) return;
        if (plugin.optionListeners && typeof plugin.optionListeners[name2] === "function") {
          modifiedValue = plugin.optionListeners[name2].call(sortable[plugin.pluginName], value2);
        }
      });
      return modifiedValue;
    }
  };
  function dispatchEvent2(_ref) {
    var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name2 = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || rootEl2 && rootEl2[expando];
    if (!sortable) return;
    var evt, options = sortable.options, onName = "on" + name2.charAt(0).toUpperCase() + name2.substr(1);
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent(name2, {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent(name2, true, true);
    }
    evt.to = toEl || rootEl2;
    evt.from = fromEl || rootEl2;
    evt.item = targetEl || rootEl2;
    evt.clone = cloneEl2;
    evt.oldIndex = oldIndex2;
    evt.newIndex = newIndex2;
    evt.oldDraggableIndex = oldDraggableIndex2;
    evt.newDraggableIndex = newDraggableIndex2;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
    var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name2, sortable));
    for (var option2 in allEventProperties) {
      evt[option2] = allEventProperties[option2];
    }
    if (rootEl2) {
      rootEl2.dispatchEvent(evt);
    }
    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }
  var _excluded = ["evt"];
  var pluginEvent2 = function pluginEvent3(eventName, sortable) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data2 = _objectWithoutProperties(_ref, _excluded);
    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
      dragEl,
      parentEl,
      ghostEl,
      rootEl,
      nextEl,
      lastDownEl,
      cloneEl,
      cloneHidden,
      dragStarted: moved,
      putSortable,
      activeSortable: Sortable.active,
      originalEvent,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex,
      hideGhostForTarget: _hideGhostForTarget,
      unhideGhostForTarget: _unhideGhostForTarget,
      cloneNowHidden: function cloneNowHidden() {
        cloneHidden = true;
      },
      cloneNowShown: function cloneNowShown() {
        cloneHidden = false;
      },
      dispatchSortableEvent: function dispatchSortableEvent(name2) {
        _dispatchEvent({
          sortable,
          name: name2,
          originalEvent
        });
      }
    }, data2));
  };
  function _dispatchEvent(info) {
    dispatchEvent2(_objectSpread2({
      putSortable,
      cloneEl,
      targetEl: dragEl,
      rootEl,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex
    }, info));
  }
  var dragEl;
  var parentEl;
  var ghostEl;
  var rootEl;
  var nextEl;
  var lastDownEl;
  var cloneEl;
  var cloneHidden;
  var oldIndex;
  var newIndex;
  var oldDraggableIndex;
  var newDraggableIndex;
  var activeGroup;
  var putSortable;
  var awaitingDragStarted = false;
  var ignoreNextClick = false;
  var sortables = [];
  var tapEvt;
  var touchEvt;
  var lastDx;
  var lastDy;
  var tapDistanceLeft;
  var tapDistanceTop;
  var moved;
  var lastTarget;
  var lastDirection;
  var pastFirstInvertThresh = false;
  var isCircumstantialInvert = false;
  var targetMoveDistance;
  var ghostRelativeParent;
  var ghostRelativeParentInitialScroll = [];
  var _silent = false;
  var savedInputChecked = [];
  var documentExists = typeof document !== "undefined";
  var PositionGhostAbsolutely = IOS;
  var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
  var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
  var supportCssPointerEvents = function() {
    if (!documentExists) return;
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement("x");
    el.style.cssText = "pointer-events:auto";
    return el.style.pointerEvents === "auto";
  }();
  var _detectDirection = function _detectDirection2(el, options) {
    var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === "flex") {
      return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
    }
    if (elCSS.display === "grid") {
      return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
      var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
      return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
    }
    return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
  };
  var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical2) {
    var dragElS1Opp = vertical2 ? dragRect.left : dragRect.top, dragElS2Opp = vertical2 ? dragRect.right : dragRect.bottom, dragElOppLength = vertical2 ? dragRect.width : dragRect.height, targetS1Opp = vertical2 ? targetRect.left : targetRect.top, targetS2Opp = vertical2 ? targetRect.right : targetRect.bottom, targetOppLength = vertical2 ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  };
  var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x3, y3) {
    var ret;
    sortables.some(function(sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect4 = getRect(sortable), insideHorizontally = x3 >= rect4.left - threshold && x3 <= rect4.right + threshold, insideVertically = y3 >= rect4.top - threshold && y3 <= rect4.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  };
  var _prepareGroup = function _prepareGroup2(options) {
    function toFn(value2, pull) {
      return function(to, from, dragEl2, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value2 == null && (pull || sameGroup)) {
          return true;
        } else if (value2 == null || value2 === false) {
          return false;
        } else if (pull && value2 === "clone") {
          return value2;
        } else if (typeof value2 === "function") {
          return toFn(value2(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value2 === true || typeof value2 === "string" && value2 === otherGroup || value2.join && value2.indexOf(otherGroup) > -1;
        }
      };
    }
    var group3 = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != "object") {
      originalGroup = {
        name: originalGroup
      };
    }
    group3.name = originalGroup.name;
    group3.checkPull = toFn(originalGroup.pull, true);
    group3.checkPut = toFn(originalGroup.put);
    group3.revertClone = originalGroup.revertClone;
    options.group = group3;
  };
  var _hideGhostForTarget = function _hideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "none");
    }
  };
  var _unhideGhostForTarget = function _unhideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "");
    }
  };
  if (documentExists && !ChromeForAndroid) {
    document.addEventListener("click", function(evt) {
      if (ignoreNextClick) {
        evt.preventDefault();
        evt.stopPropagation && evt.stopPropagation();
        evt.stopImmediatePropagation && evt.stopImmediatePropagation();
        ignoreNextClick = false;
        return false;
      }
    }, true);
  }
  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
    if (dragEl) {
      evt = evt.touches ? evt.touches[0] : evt;
      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
      if (nearest) {
        var event = {};
        for (var i in evt) {
          if (evt.hasOwnProperty(i)) {
            event[i] = evt[i];
          }
        }
        event.target = event.rootEl = nearest;
        event.preventDefault = void 0;
        event.stopPropagation = void 0;
        nearest[expando]._onDragOver(event);
      }
    }
  };
  var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
    if (dragEl) {
      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
    }
  };
  function Sortable(el, options) {
    if (!(el && el.nodeType && el.nodeType === 1)) {
      throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
    }
    this.el = el;
    this.options = options = _extends({}, options);
    el[expando] = this;
    var defaults5 = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
      swapThreshold: 1,
      // percentage; 0 <= x <= 1
      invertSwap: false,
      // invert always
      invertedSwapThreshold: null,
      // will be set to same as swapThreshold if default
      removeCloneOnHide: true,
      direction: function direction2() {
        return _detectDirection(el, this.options);
      },
      ghostClass: "sortable-ghost",
      chosenClass: "sortable-chosen",
      dragClass: "sortable-drag",
      ignore: "a, img",
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: function setData3(dataTransfer, dragEl2) {
        dataTransfer.setData("Text", dragEl2.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: "data-id",
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
      forceFallback: false,
      fallbackClass: "sortable-fallback",
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      // Disabled on Safari: #1571; Enabled on Safari IOS: #2244
      supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && (!Safari || IOS),
      emptyInsertThreshold: 5
    };
    PluginManager.initializePlugins(this, el, defaults5);
    for (var name2 in defaults5) {
      !(name2 in options) && (options[name2] = defaults5[name2]);
    }
    _prepareGroup(options);
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
    this.nativeDraggable = options.forceFallback ? false : supportDraggable;
    if (this.nativeDraggable) {
      this.options.touchStartThreshold = 1;
    }
    if (options.supportPointer) {
      on(el, "pointerdown", this._onTapStart);
    } else {
      on(el, "mousedown", this._onTapStart);
      on(el, "touchstart", this._onTapStart);
    }
    if (this.nativeDraggable) {
      on(el, "dragover", this);
      on(el, "dragenter", this);
    }
    sortables.push(this.el);
    options.store && options.store.get && this.sort(options.store.get(this) || []);
    _extends(this, AnimationStateManager());
  }
  Sortable.prototype = /** @lends Sortable.prototype */
  {
    constructor: Sortable,
    _isOutsideThisEl: function _isOutsideThisEl(target) {
      if (!this.el.contains(target) && target !== this.el) {
        lastTarget = null;
      }
    },
    _getDirection: function _getDirection(evt, target) {
      return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
    },
    _onTapStart: function _onTapStart(evt) {
      if (!evt.cancelable) return;
      var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter2 = options.filter;
      _saveInputCheckedState(el);
      if (dragEl) {
        return;
      }
      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
        return;
      }
      if (originalTarget.isContentEditable) {
        return;
      }
      if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
        return;
      }
      target = closest(target, options.draggable, el, false);
      if (target && target.animated) {
        return;
      }
      if (lastDownEl === target) {
        return;
      }
      oldIndex = index(target);
      oldDraggableIndex = index(target, options.draggable);
      if (typeof filter2 === "function") {
        if (filter2.call(this, evt, target, this)) {
          _dispatchEvent({
            sortable: _this,
            rootEl: originalTarget,
            name: "filter",
            targetEl: target,
            toEl: el,
            fromEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          preventOnFilter && evt.preventDefault();
          return;
        }
      } else if (filter2) {
        filter2 = filter2.split(",").some(function(criteria) {
          criteria = closest(originalTarget, criteria.trim(), el, false);
          if (criteria) {
            _dispatchEvent({
              sortable: _this,
              rootEl: criteria,
              name: "filter",
              targetEl: target,
              fromEl: el,
              toEl: el
            });
            pluginEvent2("filter", _this, {
              evt
            });
            return true;
          }
        });
        if (filter2) {
          preventOnFilter && evt.preventDefault();
          return;
        }
      }
      if (options.handle && !closest(originalTarget, options.handle, el, false)) {
        return;
      }
      this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart(evt, touch, target) {
      var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
      if (target && !dragEl && target.parentNode === el) {
        var dragRect = getRect(target);
        rootEl = el;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options.group;
        Sortable.dragged = dragEl;
        tapEvt = {
          target: dragEl,
          clientX: (touch || evt).clientX,
          clientY: (touch || evt).clientY
        };
        tapDistanceLeft = tapEvt.clientX - dragRect.left;
        tapDistanceTop = tapEvt.clientY - dragRect.top;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style["will-change"] = "all";
        dragStartFn = function dragStartFn2() {
          pluginEvent2("delayEnded", _this, {
            evt
          });
          if (Sortable.eventCanceled) {
            _this._onDrop();
            return;
          }
          _this._disableDelayedDragEvents();
          if (!FireFox && _this.nativeDraggable) {
            dragEl.draggable = true;
          }
          _this._triggerDragStart(evt, touch);
          _dispatchEvent({
            sortable: _this,
            name: "choose",
            originalEvent: evt
          });
          toggleClass(dragEl, options.chosenClass, true);
        };
        options.ignore.split(",").forEach(function(criteria) {
          find(dragEl, criteria.trim(), _disableDraggable);
        });
        on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
        if (options.supportPointer) {
          on(ownerDocument, "pointerup", _this._onDrop);
          !this.nativeDraggable && on(ownerDocument, "pointercancel", _this._onDrop);
        } else {
          on(ownerDocument, "mouseup", _this._onDrop);
          on(ownerDocument, "touchend", _this._onDrop);
          on(ownerDocument, "touchcancel", _this._onDrop);
        }
        if (FireFox && this.nativeDraggable) {
          this.options.touchStartThreshold = 4;
          dragEl.draggable = true;
        }
        pluginEvent2("delayStart", this, {
          evt
        });
        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
          if (Sortable.eventCanceled) {
            this._onDrop();
            return;
          }
          if (options.supportPointer) {
            on(ownerDocument, "pointerup", _this._disableDelayedDrag);
            on(ownerDocument, "pointercancel", _this._disableDelayedDrag);
          } else {
            on(ownerDocument, "mouseup", _this._disableDelayedDrag);
            on(ownerDocument, "touchend", _this._disableDelayedDrag);
            on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
          }
          on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
          on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
          options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
        } else {
          dragStartFn();
        }
      }
    },
    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e3) {
      var touch = e3.touches ? e3.touches[0] : e3;
      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
        this._disableDelayedDrag();
      }
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
      dragEl && _disableDraggable(dragEl);
      clearTimeout(this._dragStartTimer);
      this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function _disableDelayedDragEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._disableDelayedDrag);
      off(ownerDocument, "touchend", this._disableDelayedDrag);
      off(ownerDocument, "touchcancel", this._disableDelayedDrag);
      off(ownerDocument, "pointerup", this._disableDelayedDrag);
      off(ownerDocument, "pointercancel", this._disableDelayedDrag);
      off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function _triggerDragStart(evt, touch) {
      touch = touch || evt.pointerType == "touch" && evt;
      if (!this.nativeDraggable || touch) {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._onTouchMove);
        } else if (touch) {
          on(document, "touchmove", this._onTouchMove);
        } else {
          on(document, "mousemove", this._onTouchMove);
        }
      } else {
        on(dragEl, "dragend", this);
        on(rootEl, "dragstart", this._onDragStart);
      }
      try {
        if (document.selection) {
          _nextTick(function() {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {
      }
    },
    _dragStarted: function _dragStarted(fallback, evt) {
      awaitingDragStarted = false;
      if (rootEl && dragEl) {
        pluginEvent2("dragStarted", this, {
          evt
        });
        if (this.nativeDraggable) {
          on(document, "dragover", _checkOutsideTargetEl);
        }
        var options = this.options;
        !fallback && toggleClass(dragEl, options.dragClass, false);
        toggleClass(dragEl, options.ghostClass, true);
        Sortable.active = this;
        fallback && this._appendGhost();
        _dispatchEvent({
          sortable: this,
          name: "start",
          originalEvent: evt
        });
      } else {
        this._nulling();
      }
    },
    _emulateDragOver: function _emulateDragOver() {
      if (touchEvt) {
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;
        _hideGhostForTarget();
        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        var parent = target;
        while (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          if (target === parent) break;
          parent = target;
        }
        dragEl.parentNode[expando]._isOutsideThisEl(target);
        if (parent) {
          do {
            if (parent[expando]) {
              var inserted = void 0;
              inserted = parent[expando]._onDragOver({
                clientX: touchEvt.clientX,
                clientY: touchEvt.clientY,
                target,
                rootEl: parent
              });
              if (inserted && !this.options.dragoverBubble) {
                break;
              }
            }
            target = parent;
          } while (parent = getParentOrHost(parent));
        }
        _unhideGhostForTarget();
      }
    },
    _onTouchMove: function _onTouchMove(evt) {
      if (tapEvt) {
        var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX2 = ghostEl && ghostMatrix && ghostMatrix.a, scaleY2 = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX2 || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX2 || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY2 || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY2 || 1);
        if (!Sortable.active && !awaitingDragStarted) {
          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
            return;
          }
          this._onDragStart(evt, true);
        }
        if (ghostEl) {
          if (ghostMatrix) {
            ghostMatrix.e += dx - (lastDx || 0);
            ghostMatrix.f += dy - (lastDy || 0);
          } else {
            ghostMatrix = {
              a: 1,
              b: 0,
              c: 0,
              d: 1,
              e: dx,
              f: dy
            };
          }
          var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
          css(ghostEl, "webkitTransform", cssMatrix);
          css(ghostEl, "mozTransform", cssMatrix);
          css(ghostEl, "msTransform", cssMatrix);
          css(ghostEl, "transform", cssMatrix);
          lastDx = dx;
          lastDy = dy;
          touchEvt = touch;
        }
        evt.cancelable && evt.preventDefault();
      }
    },
    _appendGhost: function _appendGhost() {
      if (!ghostEl) {
        var container = this.options.fallbackOnBody ? document.body : rootEl, rect4 = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
        if (PositionGhostAbsolutely) {
          ghostRelativeParent = container;
          while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
            ghostRelativeParent = ghostRelativeParent.parentNode;
          }
          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
            rect4.top += ghostRelativeParent.scrollTop;
            rect4.left += ghostRelativeParent.scrollLeft;
          } else {
            ghostRelativeParent = getWindowScrollingElement();
          }
          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
        }
        ghostEl = dragEl.cloneNode(true);
        toggleClass(ghostEl, options.ghostClass, false);
        toggleClass(ghostEl, options.fallbackClass, true);
        toggleClass(ghostEl, options.dragClass, true);
        css(ghostEl, "transition", "");
        css(ghostEl, "transform", "");
        css(ghostEl, "box-sizing", "border-box");
        css(ghostEl, "margin", 0);
        css(ghostEl, "top", rect4.top);
        css(ghostEl, "left", rect4.left);
        css(ghostEl, "width", rect4.width);
        css(ghostEl, "height", rect4.height);
        css(ghostEl, "opacity", "0.8");
        css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
        css(ghostEl, "zIndex", "100000");
        css(ghostEl, "pointerEvents", "none");
        Sortable.ghost = ghostEl;
        container.appendChild(ghostEl);
        css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
      }
    },
    _onDragStart: function _onDragStart(evt, fallback) {
      var _this = this;
      var dataTransfer = evt.dataTransfer;
      var options = _this.options;
      pluginEvent2("dragStart", this, {
        evt
      });
      if (Sortable.eventCanceled) {
        this._onDrop();
        return;
      }
      pluginEvent2("setupClone", this);
      if (!Sortable.eventCanceled) {
        cloneEl = clone3(dragEl);
        cloneEl.removeAttribute("id");
        cloneEl.draggable = false;
        cloneEl.style["will-change"] = "";
        this._hideClone();
        toggleClass(cloneEl, this.options.chosenClass, false);
        Sortable.clone = cloneEl;
      }
      _this.cloneId = _nextTick(function() {
        pluginEvent2("clone", _this);
        if (Sortable.eventCanceled) return;
        if (!_this.options.removeCloneOnHide) {
          rootEl.insertBefore(cloneEl, dragEl);
        }
        _this._hideClone();
        _dispatchEvent({
          sortable: _this,
          name: "clone"
        });
      });
      !fallback && toggleClass(dragEl, options.dragClass, true);
      if (fallback) {
        ignoreNextClick = true;
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        off(document, "mouseup", _this._onDrop);
        off(document, "touchend", _this._onDrop);
        off(document, "touchcancel", _this._onDrop);
        if (dataTransfer) {
          dataTransfer.effectAllowed = "move";
          options.setData && options.setData.call(_this, dataTransfer, dragEl);
        }
        on(document, "drop", _this);
        css(dragEl, "transform", "translateZ(0)");
      }
      awaitingDragStarted = true;
      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
      on(document, "selectstart", _this);
      moved = true;
      window.getSelection().removeAllRanges();
      if (Safari) {
        css(document.body, "user-select", "none");
      }
    },
    // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: function _onDragOver(evt) {
      var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group3 = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group3, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical2, _this = this, completedFired = false;
      if (_silent) return;
      function dragOverEvent(name2, extra) {
        pluginEvent2(name2, _this, _objectSpread2({
          evt,
          isOwner,
          axis: vertical2 ? "vertical" : "horizontal",
          revert,
          dragRect,
          targetRect,
          canSort,
          fromSortable,
          target,
          completed,
          onMove: function onMove(target2, after2) {
            return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
          },
          changed
        }, extra));
      }
      function capture() {
        dragOverEvent("dragOverAnimationCapture");
        _this.captureAnimationState();
        if (_this !== fromSortable) {
          fromSortable.captureAnimationState();
        }
      }
      function completed(insertion) {
        dragOverEvent("dragOverCompleted", {
          insertion
        });
        if (insertion) {
          if (isOwner) {
            activeSortable._hideClone();
          } else {
            activeSortable._showClone(_this);
          }
          if (_this !== fromSortable) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
            toggleClass(dragEl, options.ghostClass, true);
          }
          if (putSortable !== _this && _this !== Sortable.active) {
            putSortable = _this;
          } else if (_this === Sortable.active && putSortable) {
            putSortable = null;
          }
          if (fromSortable === _this) {
            _this._ignoreWhileAnimating = target;
          }
          _this.animateAll(function() {
            dragOverEvent("dragOverAnimationComplete");
            _this._ignoreWhileAnimating = null;
          });
          if (_this !== fromSortable) {
            fromSortable.animateAll();
            fromSortable._ignoreWhileAnimating = null;
          }
        }
        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
          lastTarget = null;
        }
        if (!options.dragoverBubble && !evt.rootEl && target !== document) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
          !insertion && nearestEmptyInsertDetectEvent(evt);
        }
        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
        return completedFired = true;
      }
      function changed() {
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);
        _dispatchEvent({
          sortable: _this,
          name: "change",
          toEl: el,
          newIndex,
          newDraggableIndex,
          originalEvent: evt
        });
      }
      if (evt.preventDefault !== void 0) {
        evt.cancelable && evt.preventDefault();
      }
      target = closest(target, options.draggable, el, true);
      dragOverEvent("dragOver");
      if (Sortable.eventCanceled) return completedFired;
      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
        return completed(false);
      }
      ignoreNextClick = false;
      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group3.checkPut(this, activeSortable, dragEl, evt))) {
        vertical2 = this._getDirection(evt, target) === "vertical";
        dragRect = getRect(dragEl);
        dragOverEvent("dragOverValid");
        if (Sortable.eventCanceled) return completedFired;
        if (revert) {
          parentEl = rootEl;
          capture();
          this._hideClone();
          dragOverEvent("revert");
          if (!Sortable.eventCanceled) {
            if (nextEl) {
              rootEl.insertBefore(dragEl, nextEl);
            } else {
              rootEl.appendChild(dragEl);
            }
          }
          return completed(true);
        }
        var elLastChild = lastChild(el, options.draggable);
        if (!elLastChild || _ghostIsLast(evt, vertical2, this) && !elLastChild.animated) {
          if (elLastChild === dragEl) {
            return completed(false);
          }
          if (elLastChild && el === evt.target) {
            target = elLastChild;
          }
          if (target) {
            targetRect = getRect(target);
          }
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
            capture();
            if (elLastChild && elLastChild.nextSibling) {
              el.insertBefore(dragEl, elLastChild.nextSibling);
            } else {
              el.appendChild(dragEl);
            }
            parentEl = el;
            changed();
            return completed(true);
          }
        } else if (elLastChild && _ghostIsFirst(evt, vertical2, this)) {
          var firstChild = getChild(el, 0, options, true);
          if (firstChild === dragEl) {
            return completed(false);
          }
          target = firstChild;
          targetRect = getRect(target);
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
            capture();
            el.insertBefore(dragEl, firstChild);
            parentEl = el;
            changed();
            return completed(true);
          }
        } else if (target.parentNode === el) {
          targetRect = getRect(target);
          var direction2 = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical2), side1 = vertical2 ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
          if (lastTarget !== target) {
            targetBeforeFirstSwap = targetRect[side1];
            pastFirstInvertThresh = false;
            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
          }
          direction2 = _getSwapDirection(evt, target, targetRect, vertical2, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
          var sibling;
          if (direction2 !== 0) {
            var dragIndex = index(dragEl);
            do {
              dragIndex -= direction2;
              sibling = parentEl.children[dragIndex];
            } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
          }
          if (direction2 === 0 || sibling === target) {
            return completed(false);
          }
          lastTarget = target;
          lastDirection = direction2;
          var nextSibling = target.nextElementSibling, after = false;
          after = direction2 === 1;
          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            }
            _silent = true;
            setTimeout(_unsilent, 30);
            capture();
            if (after && !nextSibling) {
              el.appendChild(dragEl);
            } else {
              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
            }
            if (scrolledPastTop) {
              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
            }
            parentEl = dragEl.parentNode;
            if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
            }
            changed();
            return completed(true);
          }
        }
        if (el.contains(dragEl)) {
          return completed(false);
        }
      }
      return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function _offMoveEvents() {
      off(document, "mousemove", this._onTouchMove);
      off(document, "touchmove", this._onTouchMove);
      off(document, "pointermove", this._onTouchMove);
      off(document, "dragover", nearestEmptyInsertDetectEvent);
      off(document, "mousemove", nearestEmptyInsertDetectEvent);
      off(document, "touchmove", nearestEmptyInsertDetectEvent);
    },
    _offUpEvents: function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._onDrop);
      off(ownerDocument, "touchend", this._onDrop);
      off(ownerDocument, "pointerup", this._onDrop);
      off(ownerDocument, "pointercancel", this._onDrop);
      off(ownerDocument, "touchcancel", this._onDrop);
      off(document, "selectstart", this);
    },
    _onDrop: function _onDrop(evt) {
      var el = this.el, options = this.options;
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      pluginEvent2("drop", this, {
        evt
      });
      parentEl = dragEl && dragEl.parentNode;
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      if (Sortable.eventCanceled) {
        this._nulling();
        return;
      }
      awaitingDragStarted = false;
      isCircumstantialInvert = false;
      pastFirstInvertThresh = false;
      clearInterval(this._loopId);
      clearTimeout(this._dragStartTimer);
      _cancelNextTick(this.cloneId);
      _cancelNextTick(this._dragStartId);
      if (this.nativeDraggable) {
        off(document, "drop", this);
        off(el, "dragstart", this._onDragStart);
      }
      this._offMoveEvents();
      this._offUpEvents();
      if (Safari) {
        css(document.body, "user-select", "");
      }
      css(dragEl, "transform", "");
      if (evt) {
        if (moved) {
          evt.cancelable && evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }
        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
        }
        if (dragEl) {
          if (this.nativeDraggable) {
            off(dragEl, "dragend", this);
          }
          _disableDraggable(dragEl);
          dragEl.style["will-change"] = "";
          if (moved && !awaitingDragStarted) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
          }
          toggleClass(dragEl, this.options.chosenClass, false);
          _dispatchEvent({
            sortable: this,
            name: "unchoose",
            toEl: parentEl,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: evt
          });
          if (rootEl !== parentEl) {
            if (newIndex >= 0) {
              _dispatchEvent({
                rootEl: parentEl,
                name: "add",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "remove",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                rootEl: parentEl,
                name: "sort",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
            putSortable && putSortable.save();
          } else {
            if (newIndex !== oldIndex) {
              if (newIndex >= 0) {
                _dispatchEvent({
                  sortable: this,
                  name: "update",
                  toEl: parentEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "sort",
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
            }
          }
          if (Sortable.active) {
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
              newDraggableIndex = oldDraggableIndex;
            }
            _dispatchEvent({
              sortable: this,
              name: "end",
              toEl: parentEl,
              originalEvent: evt
            });
            this.save();
          }
        }
      }
      this._nulling();
    },
    _nulling: function _nulling() {
      pluginEvent2("nulling", this);
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
      savedInputChecked.forEach(function(el) {
        el.checked = true;
      });
      savedInputChecked.length = lastDx = lastDy = 0;
    },
    handleEvent: function handleEvent(evt) {
      switch (evt.type) {
        case "drop":
        case "dragend":
          this._onDrop(evt);
          break;
        case "dragenter":
        case "dragover":
          if (dragEl) {
            this._onDragOver(evt);
            _globalDragOver(evt);
          }
          break;
        case "selectstart":
          evt.preventDefault();
          break;
      }
    },
    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */
    toArray: function toArray() {
      var order = [], el, children = this.el.children, i = 0, n2 = children.length, options = this.options;
      for (; i < n2; i++) {
        el = children[i];
        if (closest(el, options.draggable, this.el, false)) {
          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
        }
      }
      return order;
    },
    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */
    sort: function sort(order, useAnimation) {
      var items = {}, rootEl2 = this.el;
      this.toArray().forEach(function(id5, i) {
        var el = rootEl2.children[i];
        if (closest(el, this.options.draggable, rootEl2, false)) {
          items[id5] = el;
        }
      }, this);
      useAnimation && this.captureAnimationState();
      order.forEach(function(id5) {
        if (items[id5]) {
          rootEl2.removeChild(items[id5]);
          rootEl2.appendChild(items[id5]);
        }
      });
      useAnimation && this.animateAll();
    },
    /**
     * Save the current sorting
     */
    save: function save() {
      var store = this.options.store;
      store && store.set && store.set(this);
    },
    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */
    closest: function closest$1(el, selector) {
      return closest(el, selector || this.options.draggable, this.el, false);
    },
    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */
    option: function option(name2, value2) {
      var options = this.options;
      if (value2 === void 0) {
        return options[name2];
      } else {
        var modifiedValue = PluginManager.modifyOption(this, name2, value2);
        if (typeof modifiedValue !== "undefined") {
          options[name2] = modifiedValue;
        } else {
          options[name2] = value2;
        }
        if (name2 === "group") {
          _prepareGroup(options);
        }
      }
    },
    /**
     * Destroy
     */
    destroy: function destroy() {
      pluginEvent2("destroy", this);
      var el = this.el;
      el[expando] = null;
      off(el, "mousedown", this._onTapStart);
      off(el, "touchstart", this._onTapStart);
      off(el, "pointerdown", this._onTapStart);
      if (this.nativeDraggable) {
        off(el, "dragover", this);
        off(el, "dragenter", this);
      }
      Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
        el2.removeAttribute("draggable");
      });
      this._onDrop();
      this._disableDelayedDragEvents();
      sortables.splice(sortables.indexOf(this.el), 1);
      this.el = el = null;
    },
    _hideClone: function _hideClone() {
      if (!cloneHidden) {
        pluginEvent2("hideClone", this);
        if (Sortable.eventCanceled) return;
        css(cloneEl, "display", "none");
        if (this.options.removeCloneOnHide && cloneEl.parentNode) {
          cloneEl.parentNode.removeChild(cloneEl);
        }
        cloneHidden = true;
      }
    },
    _showClone: function _showClone(putSortable2) {
      if (putSortable2.lastPutMode !== "clone") {
        this._hideClone();
        return;
      }
      if (cloneHidden) {
        pluginEvent2("showClone", this);
        if (Sortable.eventCanceled) return;
        if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
          rootEl.insertBefore(cloneEl, dragEl);
        } else if (nextEl) {
          rootEl.insertBefore(cloneEl, nextEl);
        } else {
          rootEl.appendChild(cloneEl);
        }
        if (this.options.group.revertClone) {
          this.animate(dragEl, cloneEl);
        }
        css(cloneEl, "display", "");
        cloneHidden = false;
      }
    }
  };
  function _globalDragOver(evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = "move";
    }
    evt.cancelable && evt.preventDefault();
  }
  function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
    var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent("move", {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent("move", true, true);
    }
    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl2;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);
    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvent);
    }
    return retVal;
  }
  function _disableDraggable(el) {
    el.draggable = false;
  }
  function _unsilent() {
    _silent = false;
  }
  function _ghostIsFirst(evt, vertical2, sortable) {
    var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical2 ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
  }
  function _ghostIsLast(evt, vertical2, sortable) {
    var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical2 ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
  }
  function _getSwapDirection(evt, target, targetRect, vertical2, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
    var mouseOnAxis = vertical2 ? evt.clientY : evt.clientX, targetLength = vertical2 ? targetRect.height : targetRect.width, targetS1 = vertical2 ? targetRect.top : targetRect.left, targetS2 = vertical2 ? targetRect.bottom : targetRect.right, invert5 = false;
    if (!invertSwap) {
      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
          pastFirstInvertThresh = true;
        }
        if (!pastFirstInvertThresh) {
          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
            return -lastDirection;
          }
        } else {
          invert5 = true;
        }
      } else {
        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
          return _getInsertDirection(target);
        }
      }
    }
    invert5 = invert5 || invertSwap;
    if (invert5) {
      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
      }
    }
    return 0;
  }
  function _getInsertDirection(target) {
    if (index(dragEl) < index(target)) {
      return 1;
    } else {
      return -1;
    }
  }
  function _generateId(el) {
    var str7 = el.tagName + el.className + el.src + el.href + el.textContent, i = str7.length, sum3 = 0;
    while (i--) {
      sum3 += str7.charCodeAt(i);
    }
    return sum3.toString(36);
  }
  function _saveInputCheckedState(root2) {
    savedInputChecked.length = 0;
    var inputs = root2.getElementsByTagName("input");
    var idx = inputs.length;
    while (idx--) {
      var el = inputs[idx];
      el.checked && savedInputChecked.push(el);
    }
  }
  function _nextTick(fn) {
    return setTimeout(fn, 0);
  }
  function _cancelNextTick(id5) {
    return clearTimeout(id5);
  }
  if (documentExists) {
    on(document, "touchmove", function(evt) {
      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
        evt.preventDefault();
      }
    });
  }
  Sortable.utils = {
    on,
    off,
    css,
    find,
    is: function is(el, selector) {
      return !!closest(el, selector, el, false);
    },
    extend: extend3,
    throttle,
    closest,
    toggleClass,
    clone: clone3,
    index,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild,
    expando
  };
  Sortable.get = function(element) {
    return element[expando];
  };
  Sortable.mount = function() {
    for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins2[_key] = arguments[_key];
    }
    if (plugins2[0].constructor === Array) plugins2 = plugins2[0];
    plugins2.forEach(function(plugin) {
      if (!plugin.prototype || !plugin.prototype.constructor) {
        throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
      }
      if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
      PluginManager.mount(plugin);
    });
  };
  Sortable.create = function(el, options) {
    return new Sortable(el, options);
  };
  Sortable.version = version;
  var autoScrolls = [];
  var scrollEl;
  var scrollRootEl;
  var scrolling = false;
  var lastAutoScrollX;
  var lastAutoScrollY;
  var touchEvt$1;
  var pointerElemChangedInterval;
  function AutoScrollPlugin() {
    function AutoScroll() {
      this.defaults = {
        scroll: true,
        forceAutoScrollFallback: false,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        bubbleScroll: true
      };
      for (var fn in this) {
        if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
          this[fn] = this[fn].bind(this);
        }
      }
    }
    AutoScroll.prototype = {
      dragStarted: function dragStarted(_ref) {
        var originalEvent = _ref.originalEvent;
        if (this.sortable.nativeDraggable) {
          on(document, "dragover", this._handleAutoScroll);
        } else {
          if (this.options.supportPointer) {
            on(document, "pointermove", this._handleFallbackAutoScroll);
          } else if (originalEvent.touches) {
            on(document, "touchmove", this._handleFallbackAutoScroll);
          } else {
            on(document, "mousemove", this._handleFallbackAutoScroll);
          }
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref2) {
        var originalEvent = _ref2.originalEvent;
        if (!this.options.dragOverBubble && !originalEvent.rootEl) {
          this._handleAutoScroll(originalEvent);
        }
      },
      drop: function drop3() {
        if (this.sortable.nativeDraggable) {
          off(document, "dragover", this._handleAutoScroll);
        } else {
          off(document, "pointermove", this._handleFallbackAutoScroll);
          off(document, "touchmove", this._handleFallbackAutoScroll);
          off(document, "mousemove", this._handleFallbackAutoScroll);
        }
        clearPointerElemChangedInterval();
        clearAutoScrolls();
        cancelThrottle();
      },
      nulling: function nulling() {
        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
        autoScrolls.length = 0;
      },
      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
        this._handleAutoScroll(evt, true);
      },
      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
        var _this = this;
        var x3 = (evt.touches ? evt.touches[0] : evt).clientX, y3 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x3, y3);
        touchEvt$1 = evt;
        if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
          autoScroll(evt, this.options, elem, fallback);
          var ogElemScroller = getParentAutoScrollElement(elem, true);
          if (scrolling && (!pointerElemChangedInterval || x3 !== lastAutoScrollX || y3 !== lastAutoScrollY)) {
            pointerElemChangedInterval && clearPointerElemChangedInterval();
            pointerElemChangedInterval = setInterval(function() {
              var newElem = getParentAutoScrollElement(document.elementFromPoint(x3, y3), true);
              if (newElem !== ogElemScroller) {
                ogElemScroller = newElem;
                clearAutoScrolls();
              }
              autoScroll(evt, _this.options, newElem, fallback);
            }, 10);
            lastAutoScrollX = x3;
            lastAutoScrollY = y3;
          }
        } else {
          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
            clearAutoScrolls();
            return;
          }
          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
        }
      }
    };
    return _extends(AutoScroll, {
      pluginName: "scroll",
      initializeByDefault: true
    });
  }
  function clearAutoScrolls() {
    autoScrolls.forEach(function(autoScroll2) {
      clearInterval(autoScroll2.pid);
    });
    autoScrolls = [];
  }
  function clearPointerElemChangedInterval() {
    clearInterval(pointerElemChangedInterval);
  }
  var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
    if (!options.scroll) return;
    var x3 = (evt.touches ? evt.touches[0] : evt).clientX, y3 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
    var scrollThisInstance = false, scrollCustomFn;
    if (scrollRootEl !== rootEl2) {
      scrollRootEl = rootEl2;
      clearAutoScrolls();
      scrollEl = options.scroll;
      scrollCustomFn = options.scrollFn;
      if (scrollEl === true) {
        scrollEl = getParentAutoScrollElement(rootEl2, true);
      }
    }
    var layersOut = 0;
    var currentParent = scrollEl;
    do {
      var el = currentParent, rect4 = getRect(el), top = rect4.top, bottom = rect4.bottom, left2 = rect4.left, right2 = rect4.right, width = rect4.width, height = rect4.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
      if (el === winScroller) {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
      } else {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
      }
      var vx = canScrollX && (Math.abs(right2 - x3) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left2 - x3) <= sens && !!scrollPosX);
      var vy = canScrollY && (Math.abs(bottom - y3) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y3) <= sens && !!scrollPosY);
      if (!autoScrolls[layersOut]) {
        for (var i = 0; i <= layersOut; i++) {
          if (!autoScrolls[i]) {
            autoScrolls[i] = {};
          }
        }
      }
      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
        autoScrolls[layersOut].el = el;
        autoScrolls[layersOut].vx = vx;
        autoScrolls[layersOut].vy = vy;
        clearInterval(autoScrolls[layersOut].pid);
        if (vx != 0 || vy != 0) {
          scrollThisInstance = true;
          autoScrolls[layersOut].pid = setInterval(function() {
            if (isFallback && this.layer === 0) {
              Sortable.active._onTouchMove(touchEvt$1);
            }
            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
            if (typeof scrollCustomFn === "function") {
              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
                return;
              }
            }
            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
          }.bind({
            layer: layersOut
          }), 24);
        }
      }
      layersOut++;
    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
    scrolling = scrollThisInstance;
  }, 30);
  var drop = function drop2(_ref) {
    var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent) return;
    var toSortable = putSortable2 || activeSortable;
    hideGhostForTarget();
    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();
    if (toSortable && !toSortable.el.contains(target)) {
      dispatchSortableEvent("spill");
      this.onSpill({
        dragEl: dragEl2,
        putSortable: putSortable2
      });
    }
  };
  function Revert() {
  }
  Revert.prototype = {
    startIndex: null,
    dragStart: function dragStart(_ref2) {
      var oldDraggableIndex2 = _ref2.oldDraggableIndex;
      this.startIndex = oldDraggableIndex2;
    },
    onSpill: function onSpill(_ref3) {
      var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
      this.sortable.captureAnimationState();
      if (putSortable2) {
        putSortable2.captureAnimationState();
      }
      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
      if (nextSibling) {
        this.sortable.el.insertBefore(dragEl2, nextSibling);
      } else {
        this.sortable.el.appendChild(dragEl2);
      }
      this.sortable.animateAll();
      if (putSortable2) {
        putSortable2.animateAll();
      }
    },
    drop
  };
  _extends(Revert, {
    pluginName: "revertOnSpill"
  });
  function Remove() {
  }
  Remove.prototype = {
    onSpill: function onSpill2(_ref4) {
      var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
      var parentSortable = putSortable2 || this.sortable;
      parentSortable.captureAnimationState();
      dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
      parentSortable.animateAll();
    },
    drop
  };
  _extends(Remove, {
    pluginName: "removeOnSpill"
  });
  Sortable.mount(new AutoScrollPlugin());
  Sortable.mount(Remove, Revert);
  var sortable_esm_default = Sortable;

  // engine/rails_design/app/javascripts/stimulus_com/sortable.js
  var sortable_default = class extends base_controller_default {
    static values = {
      handle: { type: String, default: ".is-drawable" }
    };
    connect() {
      sortable_esm_default.create(this.element, {
        handle: this.handleValue,
        onEnd: (evt) => {
          const body = {
            old_index: evt.oldIndex,
            new_index: evt.newIndex
          };
          if (evt.newIndex === evt.oldIndex) {
            return;
          } else if (evt.newIndex > evt.oldIndex) {
            body.prior_id = evt.item.previousElementSibling.dataset.id;
          } else {
            body.subsequent_id = evt.item.nextElementSibling.dataset.id;
          }
          const url = evt.item.dataset["url"];
          this.patch(url, JSON.stringify(body));
        }
      });
    }
    disconnect() {
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/choice.js
  var import_choices = __toESM(require_choices());
  var choice_default = class extends Controller {
    connect() {
      this.reload(this.element);
    }
    reload(element) {
      new import_choices.default(element, {
        noChoicesText: "\u65E0\u53EF\u9009\u9879",
        itemSelectText: "\u70B9\u51FB\u9009\u62E9",
        removeItemButton: true
      });
    }
  };

  // engine/rails_design/app/javascripts/stimulus_com/index.js
  application.register("alert", alert_default);
  application.register("animate-typer", animate_typer_default);
  application.register("audio-player", audio_player_default);
  application.register("cable", cable_default);
  application.register("common", common_default);
  application.register("clipboard", clipboard_default);
  application.register("count-down", count_down_default);
  application.register("custom", custom_default);
  application.register("dispatch", dispatch_default);
  application.register("draw-line", draw_line_default);
  application.register("empty", empty_default);
  application.register("enter-section", enter_section_default);
  application.register("fixed-width", fixed_width_default);
  application.register("hover", hover_default);
  application.register("gif", gif_default);
  application.register("notice", notice_default);
  application.register("page", page_default);
  application.register("player", player_default);
  application.register("print", print_default);
  application.register("qy-login", qy_login_default);
  application.register("scroll", scroll_default);
  application.register("scroll-next", scroll_next_default);
  application.register("show", show_default);
  application.register("showcase", showcase_default);
  application.register("slide", slide_default);
  application.register("slide-y", slide_y_default);
  application.register("sticky-bottom", sticky_bottom_default);
  application.register("swipe", swipe_default);
  application.register("switch", switch_default);
  application.register("time", time_default);
  application.register("time-count", time_count_default);
  application.register("tree", tree_default);
  application.register("tree-remote", tree_remote_default);
  application.register("video", video_default);
  application.register("visit", visit_default);
  application.register("sortable", sortable_default);
  application.register("sort", sortable_default);
  application.register("choice", choice_default);

  // engine/rails_design/app/javascripts/stimulus_channels/base_cable.js
  init_src();
  var BaseCable = class extends Controller {
    static consumer = createConsumer();
  };
  window.consumer = BaseCable.consumer;

  // engine/rails_design/app/javascripts/stimulus_channels/log_channel.js
  var log_channel_default = class extends BaseCable {
    connect() {
      const element = this.element;
      this.subscription = BaseCable.consumer.subscriptions.create({ channel: "Com::LogChannel", room: "room" }, {
        received(data2) {
          const p2 = document.createElement("p");
          p2.innerText = data2;
          element.appendChild(p2);
          p2.scrollIntoView({ behavior: "smooth", block: "end" });
        }
      });
    }
    disconnect() {
      this.subscription.unsubscribe();
    }
  };

  // engine/rails_design/app/javascripts/stimulus_channels/notice_channel.js
  var notice_channel_default = class extends BaseCable {
    connect() {
      this.subscription = BaseCable.consumer.subscriptions.create({ channel: "Notice::ReceiverChannel", room: "room" }, {
        received(data2) {
          Turbo.renderStreamMessage(data2);
          document.getElementById("notice_show").classList.add("color-danger");
        }
      });
    }
    disconnect() {
      this.subscription.unsubscribe();
    }
  };

  // engine/rails_design/app/javascripts/stimulus_channels/session_channel.js
  var session_channel_default = class extends BaseCable {
    connect() {
      this.subscription = BaseCable.consumer.subscriptions.create(
        {
          channel: "Com::SessionChannel",
          room: "room"
        },
        {
          received(data2) {
            const url = data2.url || "/";
            if (data2.auth_token) {
              document.addEventListener("turbo:before-fetch-request", (event) => {
                const xhr = event.detail.fetchOptions;
                xhr.headers["Authorization"] = data2.auth_token;
              });
            }
            Turbo.visit(url);
          },
          connected() {
            console.debug("connected:", this.identifier);
          },
          disconnected() {
            console.debug("disconnected:", this.identifier);
          }
        }
      );
    }
    disconnect() {
      this.subscription.unsubscribe();
    }
  };

  // engine/rails_design/app/javascripts/stimulus_channels/done_channel.js
  var done_channel_default = class extends BaseCable {
    static values = {
      content: String
    };
    connect() {
      this.subscription = BaseCable.consumer.subscriptions.create({ channel: "Datum::DoneChannel" }, {
        received(data2) {
          Turbo.renderStreamMessage(data2);
        }
      });
    }
    disconnect() {
      this.subscription.unsubscribe();
    }
  };

  // engine/rails_design/app/javascripts/stimulus_channels/index.js
  application.register("log-channel", log_channel_default);
  application.register("notice-channel", notice_channel_default);
  application.register("session-channel", session_channel_default);
  application.register("done", done_channel_default);

  // node_modules/@antv/g2/esm/coordinate/cartesian.js
  var Cartesian = () => [["cartesian"]];
  Cartesian.props = {};

  // node_modules/@antv/g2/esm/utils/angle.js
  function convertAngles(startAngle, endAngle) {
    startAngle = startAngle % (2 * Math.PI);
    endAngle = endAngle % (2 * Math.PI);
    if (startAngle < 0) {
      startAngle = 2 * Math.PI + startAngle;
    }
    if (endAngle < 0) {
      endAngle = 2 * Math.PI + endAngle;
    }
    if (startAngle >= endAngle) {
      endAngle = endAngle + 2 * Math.PI;
    }
    return {
      startAngle,
      endAngle
    };
  }

  // node_modules/@antv/g2/esm/coordinate/polar.js
  var getPolarOptions = (options = {}) => {
    const defaultOptions2 = {
      startAngle: -Math.PI / 2,
      endAngle: Math.PI * 3 / 2,
      innerRadius: 0,
      outerRadius: 1
    };
    const polarOption = Object.assign(Object.assign({}, defaultOptions2), options);
    return Object.assign(Object.assign({}, polarOption), convertAngles(polarOption.startAngle, polarOption.endAngle));
  };
  var Polar = (options) => {
    const { startAngle, endAngle, innerRadius, outerRadius } = getPolarOptions(options);
    return [
      ["translate", 0, 0.5],
      ["reflect.y"],
      ["translate", 0, -0.5],
      ["polar", startAngle, endAngle, innerRadius, outerRadius]
    ];
  };
  Polar.props = {};

  // node_modules/@antv/g2/esm/coordinate/transpose.js
  var Transpose = () => [
    ["transpose"],
    ["translate", 0.5, 0.5],
    ["reflect.x"],
    ["translate", -0.5, -0.5]
  ];
  Transpose.props = { transform: true };

  // node_modules/@antv/g2/esm/coordinate/theta.js
  var getThetaOptions = (options = {}) => {
    const defaultOptions2 = {
      startAngle: -Math.PI / 2,
      endAngle: Math.PI * 3 / 2,
      innerRadius: 0,
      outerRadius: 1
    };
    return Object.assign(Object.assign({}, defaultOptions2), options);
  };
  var Theta = (options) => {
    const { startAngle, endAngle, innerRadius, outerRadius } = getThetaOptions(options);
    return [
      ...Transpose(),
      ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
    ];
  };
  Theta.props = {};

  // node_modules/@antv/g2/esm/coordinate/radial.js
  var getRadialOptions = (options = {}) => {
    const defaultOptions2 = {
      startAngle: -Math.PI / 2,
      endAngle: Math.PI * 3 / 2,
      innerRadius: 0,
      outerRadius: 1
    };
    return Object.assign(Object.assign({}, defaultOptions2), options);
  };
  var Radial = (options) => {
    const { startAngle, endAngle, innerRadius, outerRadius } = getRadialOptions(options);
    return [
      ["transpose"],
      ["translate", 0.5, 0.5],
      ["reflect"],
      ["translate", -0.5, -0.5],
      ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
    ];
  };
  Radial.props = {};

  // node_modules/@antv/g2/esm/coordinate/parallel.js
  var Parallel = () => [["parallel", 0, 1, 0, 1]];
  Parallel.props = {};

  // node_modules/@antv/g2/esm/coordinate/fisheye.js
  var Fisheye = ({ focusX = 0, focusY = 0, distortionX = 2, distortionY = 2, visual = false }) => [["fisheye", focusX, focusY, distortionX, distortionY, visual]];
  Fisheye.props = { transform: true };

  // node_modules/@antv/g2/esm/coordinate/radar.js
  var Radar = (options) => {
    const { startAngle = -Math.PI / 2, endAngle = Math.PI * 3 / 2, innerRadius = 0, outerRadius = 1 } = options;
    return [
      ...Parallel(),
      ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
    ];
  };
  Radar.props = {};

  // node_modules/@antv/g2/esm/encode/constant.js
  var Constant = ({ value: value2 }) => {
    return (data2) => data2.map(() => value2);
  };
  Constant.props = {};

  // node_modules/@antv/g2/esm/encode/transform.js
  var Transform = ({ value: value2 }) => {
    return (data2) => data2.map(value2);
  };
  Transform.props = {};

  // node_modules/@antv/g2/esm/encode/field.js
  var Field = ({ value: value2 }) => {
    return (data2) => data2.map((d3) => d3[value2]);
  };
  Field.props = {};

  // node_modules/@antv/g2/esm/encode/column.js
  var Column = ({ value: value2 }) => {
    return () => value2;
  };
  Column.props = {};

  // node_modules/@antv/util/esm/lodash/is-array-like.js
  var isArrayLike = function(value2) {
    return value2 !== null && typeof value2 !== "function" && isFinite(value2.length);
  };
  var is_array_like_default = isArrayLike;

  // node_modules/@antv/util/esm/lodash/filter.js
  var filter = function(arr, func) {
    if (!is_array_like_default(arr)) {
      return arr;
    }
    var result = [];
    for (var index4 = 0; index4 < arr.length; index4++) {
      var value2 = arr[index4];
      if (func(value2, index4)) {
        result.push(value2);
      }
    }
    return result;
  };
  var filter_default = filter;

  // node_modules/@antv/util/esm/lodash/is-function.js
  function isFunction(value2) {
    return typeof value2 === "function";
  }

  // node_modules/@antv/util/esm/lodash/is-nil.js
  function isNil(value2) {
    return value2 === null || value2 === void 0;
  }

  // node_modules/@antv/util/esm/lodash/is-array.js
  function isArray(value2) {
    return Array.isArray(value2);
  }

  // node_modules/@antv/util/esm/lodash/is-object.js
  var is_object_default = function(value2) {
    var type = typeof value2;
    return value2 !== null && type === "object" || type === "function";
  };

  // node_modules/@antv/util/esm/lodash/each.js
  function each(elements, func) {
    if (!elements) {
      return;
    }
    var rst;
    if (isArray(elements)) {
      for (var i = 0, len5 = elements.length; i < len5; i++) {
        rst = func(elements[i], i);
        if (rst === false) {
          break;
        }
      }
    } else if (is_object_default(elements)) {
      for (var k in elements) {
        if (elements.hasOwnProperty(k)) {
          rst = func(elements[k], k);
          if (rst === false) {
            break;
          }
        }
      }
    }
  }
  var each_default = each;

  // node_modules/@antv/util/esm/lodash/keys.js
  var keys = Object.keys ? function(obj) {
    return Object.keys(obj);
  } : function(obj) {
    var result = [];
    each_default(obj, function(value2, key) {
      if (!(isFunction(obj) && key === "prototype")) {
        result.push(key);
      }
    });
    return result;
  };
  var keys_default = keys;

  // node_modules/@antv/util/esm/lodash/is-match.js
  function isMatch(obj, attrs) {
    var _keys = keys_default(attrs);
    var length5 = _keys.length;
    if (isNil(obj))
      return !length5;
    for (var i = 0; i < length5; i += 1) {
      var key = _keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) {
        return false;
      }
    }
    return true;
  }
  var is_match_default = isMatch;

  // node_modules/@antv/util/esm/lodash/is-object-like.js
  var isObjectLike = function(value2) {
    return typeof value2 === "object" && value2 !== null;
  };
  var is_object_like_default = isObjectLike;

  // node_modules/@antv/util/esm/lodash/is-type.js
  var toString = {}.toString;
  var isType = function(value2, type) {
    return toString.call(value2) === "[object " + type + "]";
  };
  var is_type_default = isType;

  // node_modules/@antv/util/esm/lodash/is-plain-object.js
  var isPlainObject = function(value2) {
    if (!is_object_like_default(value2) || !is_type_default(value2, "Object")) {
      return false;
    }
    if (Object.getPrototypeOf(value2) === null) {
      return true;
    }
    var proto = value2;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value2) === proto;
  };
  var is_plain_object_default = isPlainObject;

  // node_modules/@antv/util/esm/lodash/find.js
  function find2(arr, predicate) {
    if (!isArray(arr))
      return null;
    var _predicate;
    if (isFunction(predicate)) {
      _predicate = predicate;
    }
    if (is_plain_object_default(predicate)) {
      _predicate = function(a3) {
        return is_match_default(a3, predicate);
      };
    }
    if (_predicate) {
      for (var i = 0; i < arr.length; i += 1) {
        if (_predicate(arr[i])) {
          return arr[i];
        }
      }
    }
    return null;
  }
  var find_default = find2;

  // node_modules/@antv/util/esm/lodash/max.js
  function max(arr) {
    if (!Array.isArray(arr))
      return -Infinity;
    var length5 = arr.length;
    if (!length5)
      return -Infinity;
    var max11 = arr[0];
    for (var i = 1; i < length5; i++) {
      max11 = Math.max(max11, arr[i]);
    }
    return max11;
  }

  // node_modules/@antv/util/esm/lodash/min.js
  var min_default = function(arr) {
    if (!isArray(arr)) {
      return void 0;
    }
    return arr.reduce(function(prev, curr) {
      return Math.min(prev, curr);
    }, arr[0]);
  };

  // node_modules/@antv/util/esm/lodash/reduce.js
  var reduce = function(arr, fn, init) {
    if (!isArray(arr) && !is_plain_object_default(arr)) {
      return arr;
    }
    var result = init;
    each_default(arr, function(data2, i) {
      result = fn(result, data2, i);
    });
    return result;
  };
  var reduce_default = reduce;

  // node_modules/@antv/util/esm/lodash/is-string.js
  function isString2(value2) {
    return typeof value2 === "string";
  }

  // node_modules/@antv/util/esm/lodash/last.js
  function last(o) {
    if (is_array_like_default(o)) {
      var arr = o;
      return arr[arr.length - 1];
    }
    return void 0;
  }

  // node_modules/@antv/util/esm/lodash/clamp.js
  var clamp = function(a3, min10, max11) {
    if (a3 < min10) {
      return min10;
    } else if (a3 > max11) {
      return max11;
    }
    return a3;
  };
  var clamp_default = clamp;

  // node_modules/@antv/util/esm/lodash/is-number.js
  function isNumber2(value2) {
    return typeof value2 === "number";
  }

  // node_modules/@antv/util/esm/lodash/is-number-equal.js
  var PRECISION = 1e-5;
  function isNumberEqual(a3, b, precision) {
    if (precision === void 0) {
      precision = PRECISION;
    }
    return a3 === b || Math.abs(a3 - b) < precision;
  }

  // node_modules/@antv/util/esm/lodash/max-by.js
  var max_by_default = function(arr, fn) {
    if (!isArray(arr)) {
      return void 0;
    }
    var maxItem;
    var max11 = -Infinity;
    for (var i = 0; i < arr.length; i++) {
      var item = arr[i];
      var v = isFunction(fn) ? fn(item) : item[fn];
      if (v > max11) {
        maxItem = item;
        max11 = v;
      }
    }
    return maxItem;
  };

  // node_modules/@antv/util/esm/lodash/min-by.js
  var min_by_default = function(arr, fn) {
    if (!isArray(arr)) {
      return void 0;
    }
    var minItem;
    var min10 = Infinity;
    for (var i = 0; i < arr.length; i++) {
      var item = arr[i];
      var v = isFunction(fn) ? fn(item) : item[fn];
      if (v < min10) {
        minItem = item;
        min10 = v;
      }
    }
    return minItem;
  };

  // node_modules/@antv/util/esm/lodash/mod.js
  var mod = function(n2, m3) {
    return (n2 % m3 + m3) % m3;
  };
  var mod_default = mod;

  // node_modules/@antv/util/esm/lodash/to-string.js
  var to_string_default = function(value2) {
    if (isNil(value2))
      return "";
    return value2.toString();
  };

  // node_modules/@antv/util/esm/lodash/lower-first.js
  var lowerFirst = function(value2) {
    var str7 = to_string_default(value2);
    return str7.charAt(0).toLowerCase() + str7.substring(1);
  };
  var lower_first_default = lowerFirst;

  // node_modules/@antv/util/esm/lodash/substitute.js
  function substitute(str7, o) {
    if (!str7 || !o) {
      return str7;
    }
    return str7.replace(/\\?\{([^{}]+)\}/g, function(match2, name2) {
      if (match2.charAt(0) === "\\") {
        return match2.slice(1);
      }
      return o[name2] === void 0 ? "" : o[name2];
    });
  }
  var substitute_default = substitute;

  // node_modules/@antv/util/esm/lodash/upper-first.js
  var upperFirst = function(value2) {
    var str7 = to_string_default(value2);
    return str7.charAt(0).toUpperCase() + str7.substring(1);
  };
  var upper_first_default = upperFirst;

  // node_modules/@antv/util/esm/lodash/is-boolean.js
  var isBoolean = function(value2) {
    return is_type_default(value2, "Boolean");
  };
  var is_boolean_default = isBoolean;

  // node_modules/@antv/util/esm/lodash/is-null.js
  function isNull(value2) {
    return value2 === null;
  }

  // node_modules/@antv/util/esm/lodash/is-undefined.js
  var isUndefined2 = function(value2) {
    return value2 === void 0;
  };
  var is_undefined_default = isUndefined2;

  // node_modules/@antv/util/esm/lodash/clone.js
  var clone4 = function(obj) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    var rst;
    if (isArray(obj)) {
      rst = [];
      for (var i = 0, l2 = obj.length; i < l2; i++) {
        if (typeof obj[i] === "object" && obj[i] != null) {
          rst[i] = clone4(obj[i]);
        } else {
          rst[i] = obj[i];
        }
      }
    } else {
      rst = {};
      for (var k in obj) {
        if (typeof obj[k] === "object" && obj[k] != null) {
          rst[k] = clone4(obj[k]);
        } else {
          rst[k] = obj[k];
        }
      }
    }
    return rst;
  };
  var clone_default = clone4;

  // node_modules/@antv/util/esm/lodash/debounce.js
  function debounce2(func, wait, immediate) {
    var timeout2;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout2 = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout2;
      clearTimeout(timeout2);
      timeout2 = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
  }
  var debounce_default = debounce2;

  // node_modules/@antv/util/esm/lodash/memoize.js
  function flru(max11) {
    var num, curr, prev;
    var limit = max11 || 1;
    function keep(key, value2) {
      if (++num > limit) {
        prev = curr;
        reset(1);
        ++num;
      }
      curr[key] = value2;
    }
    function reset(isPartial) {
      num = 0;
      curr = /* @__PURE__ */ Object.create(null);
      isPartial || (prev = /* @__PURE__ */ Object.create(null));
    }
    reset();
    return {
      clear: reset,
      has: function(key) {
        return curr[key] !== void 0 || prev[key] !== void 0;
      },
      get: function(key) {
        var val = curr[key];
        if (val !== void 0)
          return val;
        if ((val = prev[key]) !== void 0) {
          keep(key, val);
          return val;
        }
      },
      set: function(key, value2) {
        if (curr[key] !== void 0) {
          curr[key] = value2;
        } else {
          keep(key, value2);
        }
      }
    };
  }
  var CacheMap = /* @__PURE__ */ new Map();
  function memoize(fn, resolver, maxSize) {
    if (maxSize === void 0) {
      maxSize = 128;
    }
    var memoized = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var key = resolver ? resolver.apply(this, args) : args[0];
      if (!CacheMap.has(fn))
        CacheMap.set(fn, flru(maxSize));
      var cache3 = CacheMap.get(fn);
      if (cache3.has(key))
        return cache3.get(key);
      var result = fn.apply(this, args);
      cache3.set(key, result);
      return result;
    };
    return memoized;
  }

  // node_modules/@antv/util/esm/lodash/deep-mix.js
  var MAX_MIX_LEVEL = 5;
  function hasOwn(object, property) {
    if (Object.hasOwn) {
      return Object.hasOwn(object, property);
    }
    if (object == null) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    return Object.prototype.hasOwnProperty.call(Object(object), property);
  }
  function _deepMix(dist5, src, level, maxLevel) {
    level = level || 0;
    maxLevel = maxLevel || MAX_MIX_LEVEL;
    for (var key in src) {
      if (hasOwn(src, key)) {
        var value2 = src[key];
        if (value2 !== null && is_plain_object_default(value2)) {
          if (!is_plain_object_default(dist5[key])) {
            dist5[key] = {};
          }
          if (level < maxLevel) {
            _deepMix(dist5[key], value2, level + 1, maxLevel);
          } else {
            dist5[key] = src[key];
          }
        } else if (isArray(value2)) {
          dist5[key] = [];
          dist5[key] = dist5[key].concat(value2);
        } else if (value2 !== void 0) {
          dist5[key] = value2;
        }
      }
    }
  }
  var deepMix = function(rst) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i += 1) {
      _deepMix(rst, args[i]);
    }
    return rst;
  };
  var deep_mix_default = deepMix;

  // node_modules/@antv/util/esm/lodash/index-of.js
  var indexOf2 = function(arr, obj) {
    if (!is_array_like_default(arr)) {
      return -1;
    }
    var m3 = Array.prototype.indexOf;
    if (m3) {
      return m3.call(arr, obj);
    }
    var index4 = -1;
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] === obj) {
        index4 = i;
        break;
      }
    }
    return index4;
  };
  var index_of_default = indexOf2;

  // node_modules/@antv/util/esm/lodash/is-equal.js
  var isEqual = function(value2, other) {
    if (value2 === other) {
      return true;
    }
    if (!value2 || !other) {
      return false;
    }
    if (isString2(value2) || isString2(other)) {
      return false;
    }
    if (is_array_like_default(value2) || is_array_like_default(other)) {
      if (value2.length !== other.length) {
        return false;
      }
      var rst = true;
      for (var i = 0; i < value2.length; i++) {
        rst = isEqual(value2[i], other[i]);
        if (!rst) {
          break;
        }
      }
      return rst;
    }
    if (is_object_like_default(value2) || is_object_like_default(other)) {
      var valueKeys = Object.keys(value2);
      var otherKeys = Object.keys(other);
      if (valueKeys.length !== otherKeys.length) {
        return false;
      }
      var rst = true;
      for (var i = 0; i < valueKeys.length; i++) {
        rst = isEqual(value2[valueKeys[i]], other[valueKeys[i]]);
        if (!rst) {
          break;
        }
      }
      return rst;
    }
    return false;
  };
  var is_equal_default = isEqual;

  // node_modules/@antv/util/esm/lodash/get.js
  var get_default = function(obj, key, defaultValue) {
    var p2 = 0;
    var keyArr = isString2(key) ? key.split(".") : key;
    while (obj && p2 < keyArr.length) {
      obj = obj[keyArr[p2++]];
    }
    return obj === void 0 || p2 < keyArr.length ? defaultValue : obj;
  };

  // node_modules/@antv/util/esm/lodash/set.js
  var set_default = function(obj, path2, value2) {
    var o = obj;
    var keyArr = isString2(path2) ? path2.split(".") : path2;
    keyArr.forEach(function(key, idx) {
      if (idx < keyArr.length - 1) {
        if (!is_object_default(o[key])) {
          o[key] = isNumber2(keyArr[idx + 1]) ? [] : {};
        }
        o = o[key];
      } else {
        o[key] = value2;
      }
    });
    return obj;
  };

  // node_modules/@antv/util/esm/lodash/pick.js
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var pick_default = function(object, keys2) {
    if (object === null || !is_plain_object_default(object)) {
      return {};
    }
    var result = {};
    each_default(keys2, function(key) {
      if (hasOwnProperty2.call(object, key)) {
        result[key] = object[key];
      }
    });
    return result;
  };

  // node_modules/@antv/util/esm/lodash/omit.js
  var omit_default = function(obj, keys2) {
    return reduce_default(obj, function(r, curr, key) {
      if (!keys2.includes(key)) {
        r[key] = curr;
      }
      return r;
    }, {});
  };

  // node_modules/@antv/util/esm/lodash/throttle.js
  var throttle_default = function(func, wait, options) {
    var timeout2, context, args, result;
    var previous = 0;
    if (!options)
      options = {};
    var later = function() {
      previous = options.leading === false ? 0 : Date.now();
      timeout2 = null;
      result = func.apply(context, args);
      if (!timeout2)
        context = args = null;
    };
    var throttled = function() {
      var now4 = Date.now();
      if (!previous && options.leading === false)
        previous = now4;
      var remaining = wait - (now4 - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout2) {
          clearTimeout(timeout2);
          timeout2 = null;
        }
        previous = now4;
        result = func.apply(context, args);
        if (!timeout2)
          context = args = null;
      } else if (!timeout2 && options.trailing !== false) {
        timeout2 = setTimeout(later, remaining);
      }
      return result;
    };
    throttled.cancel = function() {
      clearTimeout(timeout2);
      previous = 0;
      timeout2 = context = args = null;
    };
    return throttled;
  };

  // node_modules/@antv/util/esm/lodash/noop.js
  var noop_default = function() {
  };

  // node_modules/@antv/util/esm/lodash/identity.js
  var identity_default = function(v) {
    return v;
  };

  // node_modules/@antv/util/esm/lodash/size.js
  function size(o) {
    if (isNil(o)) {
      return 0;
    }
    if (is_array_like_default(o)) {
      return o.length;
    }
    return Object.keys(o).length;
  }

  // node_modules/gl-matrix/esm/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var RANDOM = Math.random;
  var degree = Math.PI / 180;
  if (!Math.hypot) Math.hypot = function() {
    var y3 = 0, i = arguments.length;
    while (i--) {
      y3 += arguments[i] * arguments[i];
    }
    return Math.sqrt(y3);
  };

  // node_modules/gl-matrix/esm/mat3.js
  var mat3_exports = {};
  __export(mat3_exports, {
    add: () => add2,
    adjoint: () => adjoint,
    clone: () => clone5,
    copy: () => copy,
    create: () => create,
    determinant: () => determinant,
    equals: () => equals,
    exactEquals: () => exactEquals,
    frob: () => frob,
    fromMat2d: () => fromMat2d,
    fromMat4: () => fromMat4,
    fromQuat: () => fromQuat,
    fromRotation: () => fromRotation,
    fromScaling: () => fromScaling,
    fromTranslation: () => fromTranslation,
    fromValues: () => fromValues,
    identity: () => identity,
    invert: () => invert,
    mul: () => mul,
    multiply: () => multiply,
    multiplyScalar: () => multiplyScalar,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd,
    normalFromMat4: () => normalFromMat4,
    projection: () => projection,
    rotate: () => rotate,
    scale: () => scale,
    set: () => set,
    str: () => str,
    sub: () => sub,
    subtract: () => subtract,
    translate: () => translate,
    transpose: () => transpose
  });
  function create() {
    var out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function fromMat4(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[4];
    out[4] = a3[5];
    out[5] = a3[6];
    out[6] = a3[8];
    out[7] = a3[9];
    out[8] = a3[10];
    return out;
  }
  function clone5(a3) {
    var out = new ARRAY_TYPE(9);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    return out;
  }
  function copy(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    return out;
  }
  function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function transpose(out, a3) {
    if (out === a3) {
      var a01 = a3[1], a02 = a3[2], a12 = a3[5];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a01;
      out[5] = a3[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a3[0];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a3[1];
      out[4] = a3[4];
      out[5] = a3[7];
      out[6] = a3[2];
      out[7] = a3[5];
      out[8] = a3[8];
    }
    return out;
  }
  function invert(out, a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2];
    var a10 = a3[3], a11 = a3[4], a12 = a3[5];
    var a20 = a3[6], a21 = a3[7], a22 = a3[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function adjoint(out, a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2];
    var a10 = a3[3], a11 = a3[4], a12 = a3[5];
    var a20 = a3[6], a21 = a3[7], a22 = a3[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  function determinant(a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2];
    var a10 = a3[3], a11 = a3[4], a12 = a3[5];
    var a20 = a3[6], a21 = a3[7], a22 = a3[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply(out, a3, b) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2];
    var a10 = a3[3], a11 = a3[4], a12 = a3[5];
    var a20 = a3[6], a21 = a3[7], a22 = a3[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate(out, a3, v) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a10 = a3[3], a11 = a3[4], a12 = a3[5], a20 = a3[6], a21 = a3[7], a22 = a3[8], x3 = v[0], y3 = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x3 * a00 + y3 * a10 + a20;
    out[7] = x3 * a01 + y3 * a11 + a21;
    out[8] = x3 * a02 + y3 * a12 + a22;
    return out;
  }
  function rotate(out, a3, rad2) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a10 = a3[3], a11 = a3[4], a12 = a3[5], a20 = a3[6], a21 = a3[7], a22 = a3[8], s3 = Math.sin(rad2), c5 = Math.cos(rad2);
    out[0] = c5 * a00 + s3 * a10;
    out[1] = c5 * a01 + s3 * a11;
    out[2] = c5 * a02 + s3 * a12;
    out[3] = c5 * a10 - s3 * a00;
    out[4] = c5 * a11 - s3 * a01;
    out[5] = c5 * a12 - s3 * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale(out, a3, v) {
    var x3 = v[0], y3 = v[1];
    out[0] = x3 * a3[0];
    out[1] = x3 * a3[1];
    out[2] = x3 * a3[2];
    out[3] = y3 * a3[3];
    out[4] = y3 * a3[4];
    out[5] = y3 * a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    return out;
  }
  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  function fromRotation(out, rad2) {
    var s3 = Math.sin(rad2), c5 = Math.cos(rad2);
    out[0] = c5;
    out[1] = s3;
    out[2] = 0;
    out[3] = -s3;
    out[4] = c5;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromMat2d(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = 0;
    out[3] = a3[2];
    out[4] = a3[3];
    out[5] = 0;
    out[6] = a3[4];
    out[7] = a3[5];
    out[8] = 1;
    return out;
  }
  function fromQuat(out, q) {
    var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
    var x22 = x3 + x3;
    var y22 = y3 + y3;
    var z2 = z + z;
    var xx = x3 * x22;
    var yx = y3 * x22;
    var yy = y3 * y22;
    var zx = z * x22;
    var zy = z * y22;
    var zz = z * z2;
    var wx2 = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx2;
    out[2] = zx - wy;
    out[5] = zy + wx2;
    out[8] = 1 - xx - yy;
    return out;
  }
  function normalFromMat4(out, a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
    var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
    var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
    var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
  }
  function str(a3) {
    return "mat3(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ", " + a3[4] + ", " + a3[5] + ", " + a3[6] + ", " + a3[7] + ", " + a3[8] + ")";
  }
  function frob(a3) {
    return Math.hypot(a3[0], a3[1], a3[2], a3[3], a3[4], a3[5], a3[6], a3[7], a3[8]);
  }
  function add2(out, a3, b) {
    out[0] = a3[0] + b[0];
    out[1] = a3[1] + b[1];
    out[2] = a3[2] + b[2];
    out[3] = a3[3] + b[3];
    out[4] = a3[4] + b[4];
    out[5] = a3[5] + b[5];
    out[6] = a3[6] + b[6];
    out[7] = a3[7] + b[7];
    out[8] = a3[8] + b[8];
    return out;
  }
  function subtract(out, a3, b) {
    out[0] = a3[0] - b[0];
    out[1] = a3[1] - b[1];
    out[2] = a3[2] - b[2];
    out[3] = a3[3] - b[3];
    out[4] = a3[4] - b[4];
    out[5] = a3[5] - b[5];
    out[6] = a3[6] - b[6];
    out[7] = a3[7] - b[7];
    out[8] = a3[8] - b[8];
    return out;
  }
  function multiplyScalar(out, a3, b) {
    out[0] = a3[0] * b;
    out[1] = a3[1] * b;
    out[2] = a3[2] * b;
    out[3] = a3[3] * b;
    out[4] = a3[4] * b;
    out[5] = a3[5] * b;
    out[6] = a3[6] * b;
    out[7] = a3[7] * b;
    out[8] = a3[8] * b;
    return out;
  }
  function multiplyScalarAndAdd(out, a3, b, scale10) {
    out[0] = a3[0] + b[0] * scale10;
    out[1] = a3[1] + b[1] * scale10;
    out[2] = a3[2] + b[2] * scale10;
    out[3] = a3[3] + b[3] * scale10;
    out[4] = a3[4] + b[4] * scale10;
    out[5] = a3[5] + b[5] * scale10;
    out[6] = a3[6] + b[6] * scale10;
    out[7] = a3[7] + b[7] * scale10;
    out[8] = a3[8] + b[8] * scale10;
    return out;
  }
  function exactEquals(a3, b) {
    return a3[0] === b[0] && a3[1] === b[1] && a3[2] === b[2] && a3[3] === b[3] && a3[4] === b[4] && a3[5] === b[5] && a3[6] === b[6] && a3[7] === b[7] && a3[8] === b[8];
  }
  function equals(a3, b) {
    var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3], a4 = a3[4], a5 = a3[5], a6 = a3[6], a7 = a3[7], a8 = a3[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
  }
  var mul = multiply;
  var sub = subtract;

  // node_modules/gl-matrix/esm/mat4.js
  var mat4_exports = {};
  __export(mat4_exports, {
    add: () => add3,
    adjoint: () => adjoint2,
    clone: () => clone6,
    copy: () => copy2,
    create: () => create2,
    determinant: () => determinant2,
    equals: () => equals2,
    exactEquals: () => exactEquals2,
    frob: () => frob2,
    fromQuat: () => fromQuat3,
    fromQuat2: () => fromQuat2,
    fromRotation: () => fromRotation2,
    fromRotationTranslation: () => fromRotationTranslation,
    fromRotationTranslationScale: () => fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
    fromScaling: () => fromScaling2,
    fromTranslation: () => fromTranslation2,
    fromValues: () => fromValues2,
    fromXRotation: () => fromXRotation,
    fromYRotation: () => fromYRotation,
    fromZRotation: () => fromZRotation,
    frustum: () => frustum,
    getRotation: () => getRotation,
    getScaling: () => getScaling,
    getTranslation: () => getTranslation,
    identity: () => identity2,
    invert: () => invert2,
    lookAt: () => lookAt,
    mul: () => mul2,
    multiply: () => multiply2,
    multiplyScalar: () => multiplyScalar2,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
    ortho: () => ortho,
    orthoNO: () => orthoNO,
    orthoZO: () => orthoZO,
    perspective: () => perspective,
    perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
    perspectiveNO: () => perspectiveNO,
    perspectiveZO: () => perspectiveZO,
    rotate: () => rotate2,
    rotateX: () => rotateX,
    rotateY: () => rotateY,
    rotateZ: () => rotateZ,
    scale: () => scale2,
    set: () => set2,
    str: () => str2,
    sub: () => sub2,
    subtract: () => subtract2,
    targetTo: () => targetTo,
    translate: () => translate2,
    transpose: () => transpose2
  });
  function create2() {
    var out = new ARRAY_TYPE(16);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  function clone6(a3) {
    var out = new ARRAY_TYPE(16);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    out[9] = a3[9];
    out[10] = a3[10];
    out[11] = a3[11];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function copy2(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    out[9] = a3[9];
    out[10] = a3[10];
    out[11] = a3[11];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function identity2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose2(out, a3) {
    if (out === a3) {
      var a01 = a3[1], a02 = a3[2], a03 = a3[3];
      var a12 = a3[6], a13 = a3[7];
      var a23 = a3[11];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a01;
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a3[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a3[0];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a3[1];
      out[5] = a3[5];
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a3[2];
      out[9] = a3[6];
      out[10] = a3[10];
      out[11] = a3[14];
      out[12] = a3[3];
      out[13] = a3[7];
      out[14] = a3[11];
      out[15] = a3[15];
    }
    return out;
  }
  function invert2(out, a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
    var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
    var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
    var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function adjoint2(out, a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
    var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
    var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
    var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  function determinant2(a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
    var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
    var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
    var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  function multiply2(out, a3, b) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
    var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
    var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
    var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate2(out, a3, v) {
    var x3 = v[0], y3 = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a3 === out) {
      out[12] = a3[0] * x3 + a3[4] * y3 + a3[8] * z + a3[12];
      out[13] = a3[1] * x3 + a3[5] * y3 + a3[9] * z + a3[13];
      out[14] = a3[2] * x3 + a3[6] * y3 + a3[10] * z + a3[14];
      out[15] = a3[3] * x3 + a3[7] * y3 + a3[11] * z + a3[15];
    } else {
      a00 = a3[0];
      a01 = a3[1];
      a02 = a3[2];
      a03 = a3[3];
      a10 = a3[4];
      a11 = a3[5];
      a12 = a3[6];
      a13 = a3[7];
      a20 = a3[8];
      a21 = a3[9];
      a22 = a3[10];
      a23 = a3[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x3 + a10 * y3 + a20 * z + a3[12];
      out[13] = a01 * x3 + a11 * y3 + a21 * z + a3[13];
      out[14] = a02 * x3 + a12 * y3 + a22 * z + a3[14];
      out[15] = a03 * x3 + a13 * y3 + a23 * z + a3[15];
    }
    return out;
  }
  function scale2(out, a3, v) {
    var x3 = v[0], y3 = v[1], z = v[2];
    out[0] = a3[0] * x3;
    out[1] = a3[1] * x3;
    out[2] = a3[2] * x3;
    out[3] = a3[3] * x3;
    out[4] = a3[4] * y3;
    out[5] = a3[5] * y3;
    out[6] = a3[6] * y3;
    out[7] = a3[7] * y3;
    out[8] = a3[8] * z;
    out[9] = a3[9] * z;
    out[10] = a3[10] * z;
    out[11] = a3[11] * z;
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function rotate2(out, a3, rad2, axis) {
    var x3 = axis[0], y3 = axis[1], z = axis[2];
    var len5 = Math.hypot(x3, y3, z);
    var s3, c5, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len5 < EPSILON) {
      return null;
    }
    len5 = 1 / len5;
    x3 *= len5;
    y3 *= len5;
    z *= len5;
    s3 = Math.sin(rad2);
    c5 = Math.cos(rad2);
    t = 1 - c5;
    a00 = a3[0];
    a01 = a3[1];
    a02 = a3[2];
    a03 = a3[3];
    a10 = a3[4];
    a11 = a3[5];
    a12 = a3[6];
    a13 = a3[7];
    a20 = a3[8];
    a21 = a3[9];
    a22 = a3[10];
    a23 = a3[11];
    b00 = x3 * x3 * t + c5;
    b01 = y3 * x3 * t + z * s3;
    b02 = z * x3 * t - y3 * s3;
    b10 = x3 * y3 * t - z * s3;
    b11 = y3 * y3 * t + c5;
    b12 = z * y3 * t + x3 * s3;
    b20 = x3 * z * t + y3 * s3;
    b21 = y3 * z * t - x3 * s3;
    b22 = z * z * t + c5;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a3 !== out) {
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    return out;
  }
  function rotateX(out, a3, rad2) {
    var s3 = Math.sin(rad2);
    var c5 = Math.cos(rad2);
    var a10 = a3[4];
    var a11 = a3[5];
    var a12 = a3[6];
    var a13 = a3[7];
    var a20 = a3[8];
    var a21 = a3[9];
    var a22 = a3[10];
    var a23 = a3[11];
    if (a3 !== out) {
      out[0] = a3[0];
      out[1] = a3[1];
      out[2] = a3[2];
      out[3] = a3[3];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[4] = a10 * c5 + a20 * s3;
    out[5] = a11 * c5 + a21 * s3;
    out[6] = a12 * c5 + a22 * s3;
    out[7] = a13 * c5 + a23 * s3;
    out[8] = a20 * c5 - a10 * s3;
    out[9] = a21 * c5 - a11 * s3;
    out[10] = a22 * c5 - a12 * s3;
    out[11] = a23 * c5 - a13 * s3;
    return out;
  }
  function rotateY(out, a3, rad2) {
    var s3 = Math.sin(rad2);
    var c5 = Math.cos(rad2);
    var a00 = a3[0];
    var a01 = a3[1];
    var a02 = a3[2];
    var a03 = a3[3];
    var a20 = a3[8];
    var a21 = a3[9];
    var a22 = a3[10];
    var a23 = a3[11];
    if (a3 !== out) {
      out[4] = a3[4];
      out[5] = a3[5];
      out[6] = a3[6];
      out[7] = a3[7];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c5 - a20 * s3;
    out[1] = a01 * c5 - a21 * s3;
    out[2] = a02 * c5 - a22 * s3;
    out[3] = a03 * c5 - a23 * s3;
    out[8] = a00 * s3 + a20 * c5;
    out[9] = a01 * s3 + a21 * c5;
    out[10] = a02 * s3 + a22 * c5;
    out[11] = a03 * s3 + a23 * c5;
    return out;
  }
  function rotateZ(out, a3, rad2) {
    var s3 = Math.sin(rad2);
    var c5 = Math.cos(rad2);
    var a00 = a3[0];
    var a01 = a3[1];
    var a02 = a3[2];
    var a03 = a3[3];
    var a10 = a3[4];
    var a11 = a3[5];
    var a12 = a3[6];
    var a13 = a3[7];
    if (a3 !== out) {
      out[8] = a3[8];
      out[9] = a3[9];
      out[10] = a3[10];
      out[11] = a3[11];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c5 + a10 * s3;
    out[1] = a01 * c5 + a11 * s3;
    out[2] = a02 * c5 + a12 * s3;
    out[3] = a03 * c5 + a13 * s3;
    out[4] = a10 * c5 - a00 * s3;
    out[5] = a11 * c5 - a01 * s3;
    out[6] = a12 * c5 - a02 * s3;
    out[7] = a13 * c5 - a03 * s3;
    return out;
  }
  function fromTranslation2(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromScaling2(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotation2(out, rad2, axis) {
    var x3 = axis[0], y3 = axis[1], z = axis[2];
    var len5 = Math.hypot(x3, y3, z);
    var s3, c5, t;
    if (len5 < EPSILON) {
      return null;
    }
    len5 = 1 / len5;
    x3 *= len5;
    y3 *= len5;
    z *= len5;
    s3 = Math.sin(rad2);
    c5 = Math.cos(rad2);
    t = 1 - c5;
    out[0] = x3 * x3 * t + c5;
    out[1] = y3 * x3 * t + z * s3;
    out[2] = z * x3 * t - y3 * s3;
    out[3] = 0;
    out[4] = x3 * y3 * t - z * s3;
    out[5] = y3 * y3 * t + c5;
    out[6] = z * y3 * t + x3 * s3;
    out[7] = 0;
    out[8] = x3 * z * t + y3 * s3;
    out[9] = y3 * z * t - x3 * s3;
    out[10] = z * z * t + c5;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromXRotation(out, rad2) {
    var s3 = Math.sin(rad2);
    var c5 = Math.cos(rad2);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c5;
    out[6] = s3;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s3;
    out[10] = c5;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromYRotation(out, rad2) {
    var s3 = Math.sin(rad2);
    var c5 = Math.cos(rad2);
    out[0] = c5;
    out[1] = 0;
    out[2] = -s3;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s3;
    out[9] = 0;
    out[10] = c5;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromZRotation(out, rad2) {
    var s3 = Math.sin(rad2);
    var c5 = Math.cos(rad2);
    out[0] = c5;
    out[1] = s3;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s3;
    out[5] = c5;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotationTranslation(out, q, v) {
    var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
    var x22 = x3 + x3;
    var y22 = y3 + y3;
    var z2 = z + z;
    var xx = x3 * x22;
    var xy = x3 * y22;
    var xz = x3 * z2;
    var yy = y3 * y22;
    var yz = y3 * z2;
    var zz = z * z2;
    var wx2 = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx2;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx2;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromQuat2(out, a3) {
    var translation = new ARRAY_TYPE(3);
    var bx = -a3[0], by = -a3[1], bz = -a3[2], bw = a3[3], ax = a3[4], ay = a3[5], az = a3[6], aw = a3[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw;
    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    fromRotationTranslation(out, a3, translation);
    return out;
  }
  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  function getRotation(out, mat) {
    var scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;
    if (trace > 0) {
      S = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }
    return out;
  }
  function fromRotationTranslationScale(out, q, v, s3) {
    var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
    var x22 = x3 + x3;
    var y22 = y3 + y3;
    var z2 = z + z;
    var xx = x3 * x22;
    var xy = x3 * y22;
    var xz = x3 * z2;
    var yy = y3 * y22;
    var yz = y3 * z2;
    var zz = z * z2;
    var wx2 = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    var sx = s3[0];
    var sy = s3[1];
    var sz = s3[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx2) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx2) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromRotationTranslationScaleOrigin(out, q, v, s3, o) {
    var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
    var x22 = x3 + x3;
    var y22 = y3 + y3;
    var z2 = z + z;
    var xx = x3 * x22;
    var xy = x3 * y22;
    var xz = x3 * z2;
    var yy = y3 * y22;
    var yz = y3 * z2;
    var zz = z * z2;
    var wx2 = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    var sx = s3[0];
    var sy = s3[1];
    var sz = s3[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx2) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx2) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  function fromQuat3(out, q) {
    var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
    var x22 = x3 + x3;
    var y22 = y3 + y3;
    var z2 = z + z;
    var xx = x3 * x22;
    var yx = y3 * x22;
    var yy = y3 * y22;
    var zx = z * x22;
    var zy = z * y22;
    var zz = z * z2;
    var wx2 = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx2;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx2;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left2, right2, bottom, top, near, far) {
    var rl = 1 / (right2 - left2);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right2 + left2) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function perspectiveZO(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = far * nf;
      out[14] = far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -near;
    }
    return out;
  }
  function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    var xScale = 2 / (leftTan + rightTan);
    var yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
  }
  function orthoNO(out, left2, right2, bottom, top, near, far) {
    var lr = 1 / (left2 - right2);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left2 + right2) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho = orthoNO;
  function orthoZO(out, left2, right2, bottom, top, near, far) {
    var lr = 1 / (left2 - right2);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left2 + right2) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
  }
  function lookAt(out, eye, center2, up) {
    var x05, x12, x22, y05, y12, y22, z0, z1, z2, len5;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center2[0];
    var centery = center2[1];
    var centerz = center2[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity2(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len5 = 1 / Math.hypot(z0, z1, z2);
    z0 *= len5;
    z1 *= len5;
    z2 *= len5;
    x05 = upy * z2 - upz * z1;
    x12 = upz * z0 - upx * z2;
    x22 = upx * z1 - upy * z0;
    len5 = Math.hypot(x05, x12, x22);
    if (!len5) {
      x05 = 0;
      x12 = 0;
      x22 = 0;
    } else {
      len5 = 1 / len5;
      x05 *= len5;
      x12 *= len5;
      x22 *= len5;
    }
    y05 = z1 * x22 - z2 * x12;
    y12 = z2 * x05 - z0 * x22;
    y22 = z0 * x12 - z1 * x05;
    len5 = Math.hypot(y05, y12, y22);
    if (!len5) {
      y05 = 0;
      y12 = 0;
      y22 = 0;
    } else {
      len5 = 1 / len5;
      y05 *= len5;
      y12 *= len5;
      y22 *= len5;
    }
    out[0] = x05;
    out[1] = y05;
    out[2] = z0;
    out[3] = 0;
    out[4] = x12;
    out[5] = y12;
    out[6] = z1;
    out[7] = 0;
    out[8] = x22;
    out[9] = y22;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x05 * eyex + x12 * eyey + x22 * eyez);
    out[13] = -(y05 * eyex + y12 * eyey + y22 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  function targetTo(out, eye, target, up) {
    var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
    var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
    var len5 = z0 * z0 + z1 * z1 + z2 * z2;
    if (len5 > 0) {
      len5 = 1 / Math.sqrt(len5);
      z0 *= len5;
      z1 *= len5;
      z2 *= len5;
    }
    var x05 = upy * z2 - upz * z1, x12 = upz * z0 - upx * z2, x22 = upx * z1 - upy * z0;
    len5 = x05 * x05 + x12 * x12 + x22 * x22;
    if (len5 > 0) {
      len5 = 1 / Math.sqrt(len5);
      x05 *= len5;
      x12 *= len5;
      x22 *= len5;
    }
    out[0] = x05;
    out[1] = x12;
    out[2] = x22;
    out[3] = 0;
    out[4] = z1 * x22 - z2 * x12;
    out[5] = z2 * x05 - z0 * x22;
    out[6] = z0 * x12 - z1 * x05;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  function str2(a3) {
    return "mat4(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ", " + a3[4] + ", " + a3[5] + ", " + a3[6] + ", " + a3[7] + ", " + a3[8] + ", " + a3[9] + ", " + a3[10] + ", " + a3[11] + ", " + a3[12] + ", " + a3[13] + ", " + a3[14] + ", " + a3[15] + ")";
  }
  function frob2(a3) {
    return Math.hypot(a3[0], a3[1], a3[2], a3[3], a3[4], a3[5], a3[6], a3[7], a3[8], a3[9], a3[10], a3[11], a3[12], a3[13], a3[14], a3[15]);
  }
  function add3(out, a3, b) {
    out[0] = a3[0] + b[0];
    out[1] = a3[1] + b[1];
    out[2] = a3[2] + b[2];
    out[3] = a3[3] + b[3];
    out[4] = a3[4] + b[4];
    out[5] = a3[5] + b[5];
    out[6] = a3[6] + b[6];
    out[7] = a3[7] + b[7];
    out[8] = a3[8] + b[8];
    out[9] = a3[9] + b[9];
    out[10] = a3[10] + b[10];
    out[11] = a3[11] + b[11];
    out[12] = a3[12] + b[12];
    out[13] = a3[13] + b[13];
    out[14] = a3[14] + b[14];
    out[15] = a3[15] + b[15];
    return out;
  }
  function subtract2(out, a3, b) {
    out[0] = a3[0] - b[0];
    out[1] = a3[1] - b[1];
    out[2] = a3[2] - b[2];
    out[3] = a3[3] - b[3];
    out[4] = a3[4] - b[4];
    out[5] = a3[5] - b[5];
    out[6] = a3[6] - b[6];
    out[7] = a3[7] - b[7];
    out[8] = a3[8] - b[8];
    out[9] = a3[9] - b[9];
    out[10] = a3[10] - b[10];
    out[11] = a3[11] - b[11];
    out[12] = a3[12] - b[12];
    out[13] = a3[13] - b[13];
    out[14] = a3[14] - b[14];
    out[15] = a3[15] - b[15];
    return out;
  }
  function multiplyScalar2(out, a3, b) {
    out[0] = a3[0] * b;
    out[1] = a3[1] * b;
    out[2] = a3[2] * b;
    out[3] = a3[3] * b;
    out[4] = a3[4] * b;
    out[5] = a3[5] * b;
    out[6] = a3[6] * b;
    out[7] = a3[7] * b;
    out[8] = a3[8] * b;
    out[9] = a3[9] * b;
    out[10] = a3[10] * b;
    out[11] = a3[11] * b;
    out[12] = a3[12] * b;
    out[13] = a3[13] * b;
    out[14] = a3[14] * b;
    out[15] = a3[15] * b;
    return out;
  }
  function multiplyScalarAndAdd2(out, a3, b, scale10) {
    out[0] = a3[0] + b[0] * scale10;
    out[1] = a3[1] + b[1] * scale10;
    out[2] = a3[2] + b[2] * scale10;
    out[3] = a3[3] + b[3] * scale10;
    out[4] = a3[4] + b[4] * scale10;
    out[5] = a3[5] + b[5] * scale10;
    out[6] = a3[6] + b[6] * scale10;
    out[7] = a3[7] + b[7] * scale10;
    out[8] = a3[8] + b[8] * scale10;
    out[9] = a3[9] + b[9] * scale10;
    out[10] = a3[10] + b[10] * scale10;
    out[11] = a3[11] + b[11] * scale10;
    out[12] = a3[12] + b[12] * scale10;
    out[13] = a3[13] + b[13] * scale10;
    out[14] = a3[14] + b[14] * scale10;
    out[15] = a3[15] + b[15] * scale10;
    return out;
  }
  function exactEquals2(a3, b) {
    return a3[0] === b[0] && a3[1] === b[1] && a3[2] === b[2] && a3[3] === b[3] && a3[4] === b[4] && a3[5] === b[5] && a3[6] === b[6] && a3[7] === b[7] && a3[8] === b[8] && a3[9] === b[9] && a3[10] === b[10] && a3[11] === b[11] && a3[12] === b[12] && a3[13] === b[13] && a3[14] === b[14] && a3[15] === b[15];
  }
  function equals2(a3, b) {
    var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
    var a4 = a3[4], a5 = a3[5], a6 = a3[6], a7 = a3[7];
    var a8 = a3[8], a9 = a3[9], a10 = a3[10], a11 = a3[11];
    var a12 = a3[12], a13 = a3[13], a14 = a3[14], a15 = a3[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
  }
  var mul2 = multiply2;
  var sub2 = subtract2;

  // node_modules/gl-matrix/esm/quat.js
  var quat_exports = {};
  __export(quat_exports, {
    add: () => add6,
    calculateW: () => calculateW,
    clone: () => clone9,
    conjugate: () => conjugate,
    copy: () => copy5,
    create: () => create5,
    dot: () => dot3,
    equals: () => equals5,
    exactEquals: () => exactEquals5,
    exp: () => exp,
    fromEuler: () => fromEuler,
    fromMat3: () => fromMat3,
    fromValues: () => fromValues5,
    getAngle: () => getAngle,
    getAxisAngle: () => getAxisAngle,
    identity: () => identity3,
    invert: () => invert3,
    len: () => len3,
    length: () => length3,
    lerp: () => lerp3,
    ln: () => ln,
    mul: () => mul5,
    multiply: () => multiply5,
    normalize: () => normalize3,
    pow: () => pow,
    random: () => random3,
    rotateX: () => rotateX3,
    rotateY: () => rotateY3,
    rotateZ: () => rotateZ3,
    rotationTo: () => rotationTo,
    scale: () => scale5,
    set: () => set5,
    setAxes: () => setAxes,
    setAxisAngle: () => setAxisAngle,
    slerp: () => slerp,
    sqlerp: () => sqlerp,
    sqrLen: () => sqrLen3,
    squaredLength: () => squaredLength3,
    str: () => str5
  });

  // node_modules/gl-matrix/esm/vec3.js
  var vec3_exports = {};
  __export(vec3_exports, {
    add: () => add4,
    angle: () => angle,
    bezier: () => bezier,
    ceil: () => ceil,
    clone: () => clone7,
    copy: () => copy3,
    create: () => create3,
    cross: () => cross,
    dist: () => dist,
    distance: () => distance,
    div: () => div,
    divide: () => divide,
    dot: () => dot,
    equals: () => equals3,
    exactEquals: () => exactEquals3,
    floor: () => floor,
    forEach: () => forEach,
    fromValues: () => fromValues3,
    hermite: () => hermite,
    inverse: () => inverse,
    len: () => len,
    length: () => length,
    lerp: () => lerp,
    max: () => max2,
    min: () => min,
    mul: () => mul3,
    multiply: () => multiply3,
    negate: () => negate,
    normalize: () => normalize,
    random: () => random,
    rotateX: () => rotateX2,
    rotateY: () => rotateY2,
    rotateZ: () => rotateZ2,
    round: () => round,
    scale: () => scale3,
    scaleAndAdd: () => scaleAndAdd,
    set: () => set3,
    sqrDist: () => sqrDist,
    sqrLen: () => sqrLen,
    squaredDistance: () => squaredDistance,
    squaredLength: () => squaredLength,
    str: () => str3,
    sub: () => sub3,
    subtract: () => subtract3,
    transformMat3: () => transformMat3,
    transformMat4: () => transformMat4,
    transformQuat: () => transformQuat,
    zero: () => zero
  });
  function create3() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function clone7(a3) {
    var out = new ARRAY_TYPE(3);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    return out;
  }
  function length(a3) {
    var x3 = a3[0];
    var y3 = a3[1];
    var z = a3[2];
    return Math.hypot(x3, y3, z);
  }
  function fromValues3(x3, y3, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x3;
    out[1] = y3;
    out[2] = z;
    return out;
  }
  function copy3(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    return out;
  }
  function set3(out, x3, y3, z) {
    out[0] = x3;
    out[1] = y3;
    out[2] = z;
    return out;
  }
  function add4(out, a3, b) {
    out[0] = a3[0] + b[0];
    out[1] = a3[1] + b[1];
    out[2] = a3[2] + b[2];
    return out;
  }
  function subtract3(out, a3, b) {
    out[0] = a3[0] - b[0];
    out[1] = a3[1] - b[1];
    out[2] = a3[2] - b[2];
    return out;
  }
  function multiply3(out, a3, b) {
    out[0] = a3[0] * b[0];
    out[1] = a3[1] * b[1];
    out[2] = a3[2] * b[2];
    return out;
  }
  function divide(out, a3, b) {
    out[0] = a3[0] / b[0];
    out[1] = a3[1] / b[1];
    out[2] = a3[2] / b[2];
    return out;
  }
  function ceil(out, a3) {
    out[0] = Math.ceil(a3[0]);
    out[1] = Math.ceil(a3[1]);
    out[2] = Math.ceil(a3[2]);
    return out;
  }
  function floor(out, a3) {
    out[0] = Math.floor(a3[0]);
    out[1] = Math.floor(a3[1]);
    out[2] = Math.floor(a3[2]);
    return out;
  }
  function min(out, a3, b) {
    out[0] = Math.min(a3[0], b[0]);
    out[1] = Math.min(a3[1], b[1]);
    out[2] = Math.min(a3[2], b[2]);
    return out;
  }
  function max2(out, a3, b) {
    out[0] = Math.max(a3[0], b[0]);
    out[1] = Math.max(a3[1], b[1]);
    out[2] = Math.max(a3[2], b[2]);
    return out;
  }
  function round(out, a3) {
    out[0] = Math.round(a3[0]);
    out[1] = Math.round(a3[1]);
    out[2] = Math.round(a3[2]);
    return out;
  }
  function scale3(out, a3, b) {
    out[0] = a3[0] * b;
    out[1] = a3[1] * b;
    out[2] = a3[2] * b;
    return out;
  }
  function scaleAndAdd(out, a3, b, scale10) {
    out[0] = a3[0] + b[0] * scale10;
    out[1] = a3[1] + b[1] * scale10;
    out[2] = a3[2] + b[2] * scale10;
    return out;
  }
  function distance(a3, b) {
    var x3 = b[0] - a3[0];
    var y3 = b[1] - a3[1];
    var z = b[2] - a3[2];
    return Math.hypot(x3, y3, z);
  }
  function squaredDistance(a3, b) {
    var x3 = b[0] - a3[0];
    var y3 = b[1] - a3[1];
    var z = b[2] - a3[2];
    return x3 * x3 + y3 * y3 + z * z;
  }
  function squaredLength(a3) {
    var x3 = a3[0];
    var y3 = a3[1];
    var z = a3[2];
    return x3 * x3 + y3 * y3 + z * z;
  }
  function negate(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    return out;
  }
  function inverse(out, a3) {
    out[0] = 1 / a3[0];
    out[1] = 1 / a3[1];
    out[2] = 1 / a3[2];
    return out;
  }
  function normalize(out, a3) {
    var x3 = a3[0];
    var y3 = a3[1];
    var z = a3[2];
    var len5 = x3 * x3 + y3 * y3 + z * z;
    if (len5 > 0) {
      len5 = 1 / Math.sqrt(len5);
    }
    out[0] = a3[0] * len5;
    out[1] = a3[1] * len5;
    out[2] = a3[2] * len5;
    return out;
  }
  function dot(a3, b) {
    return a3[0] * b[0] + a3[1] * b[1] + a3[2] * b[2];
  }
  function cross(out, a3, b) {
    var ax = a3[0], ay = a3[1], az = a3[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function lerp(out, a3, b, t) {
    var ax = a3[0];
    var ay = a3[1];
    var az = a3[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  function hermite(out, a3, b, c5, d3, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a3[0] * factor1 + b[0] * factor2 + c5[0] * factor3 + d3[0] * factor4;
    out[1] = a3[1] * factor1 + b[1] * factor2 + c5[1] * factor3 + d3[1] * factor4;
    out[2] = a3[2] * factor1 + b[2] * factor2 + c5[2] * factor3 + d3[2] * factor4;
    return out;
  }
  function bezier(out, a3, b, c5, d3, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a3[0] * factor1 + b[0] * factor2 + c5[0] * factor3 + d3[0] * factor4;
    out[1] = a3[1] * factor1 + b[1] * factor2 + c5[1] * factor3 + d3[1] * factor4;
    out[2] = a3[2] * factor1 + b[2] * factor2 + c5[2] * factor3 + d3[2] * factor4;
    return out;
  }
  function random(out, scale10) {
    scale10 = scale10 || 1;
    var r = RANDOM() * 2 * Math.PI;
    var z = RANDOM() * 2 - 1;
    var zScale = Math.sqrt(1 - z * z) * scale10;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale10;
    return out;
  }
  function transformMat4(out, a3, m3) {
    var x3 = a3[0], y3 = a3[1], z = a3[2];
    var w = m3[3] * x3 + m3[7] * y3 + m3[11] * z + m3[15];
    w = w || 1;
    out[0] = (m3[0] * x3 + m3[4] * y3 + m3[8] * z + m3[12]) / w;
    out[1] = (m3[1] * x3 + m3[5] * y3 + m3[9] * z + m3[13]) / w;
    out[2] = (m3[2] * x3 + m3[6] * y3 + m3[10] * z + m3[14]) / w;
    return out;
  }
  function transformMat3(out, a3, m3) {
    var x3 = a3[0], y3 = a3[1], z = a3[2];
    out[0] = x3 * m3[0] + y3 * m3[3] + z * m3[6];
    out[1] = x3 * m3[1] + y3 * m3[4] + z * m3[7];
    out[2] = x3 * m3[2] + y3 * m3[5] + z * m3[8];
    return out;
  }
  function transformQuat(out, a3, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x3 = a3[0], y3 = a3[1], z = a3[2];
    var uvx = qy * z - qz * y3, uvy = qz * x3 - qx * z, uvz = qx * y3 - qy * x3;
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x3 + uvx + uuvx;
    out[1] = y3 + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX2(out, a3, b, rad2) {
    var p2 = [], r = [];
    p2[0] = a3[0] - b[0];
    p2[1] = a3[1] - b[1];
    p2[2] = a3[2] - b[2];
    r[0] = p2[0];
    r[1] = p2[1] * Math.cos(rad2) - p2[2] * Math.sin(rad2);
    r[2] = p2[1] * Math.sin(rad2) + p2[2] * Math.cos(rad2);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateY2(out, a3, b, rad2) {
    var p2 = [], r = [];
    p2[0] = a3[0] - b[0];
    p2[1] = a3[1] - b[1];
    p2[2] = a3[2] - b[2];
    r[0] = p2[2] * Math.sin(rad2) + p2[0] * Math.cos(rad2);
    r[1] = p2[1];
    r[2] = p2[2] * Math.cos(rad2) - p2[0] * Math.sin(rad2);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateZ2(out, a3, b, rad2) {
    var p2 = [], r = [];
    p2[0] = a3[0] - b[0];
    p2[1] = a3[1] - b[1];
    p2[2] = a3[2] - b[2];
    r[0] = p2[0] * Math.cos(rad2) - p2[1] * Math.sin(rad2);
    r[1] = p2[0] * Math.sin(rad2) + p2[1] * Math.cos(rad2);
    r[2] = p2[2];
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function angle(a3, b) {
    var ax = a3[0], ay = a3[1], az = a3[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a3, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  function str3(a3) {
    return "vec3(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ")";
  }
  function exactEquals3(a3, b) {
    return a3[0] === b[0] && a3[1] === b[1] && a3[2] === b[2];
  }
  function equals3(a3, b) {
    var a0 = a3[0], a1 = a3[1], a22 = a3[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2));
  }
  var sub3 = subtract3;
  var mul3 = multiply3;
  var div = divide;
  var dist = distance;
  var sqrDist = squaredDistance;
  var len = length;
  var sqrLen = squaredLength;
  var forEach = function() {
    var vec = create3();
    return function(a3, stride, offset3, count4, fn, arg) {
      var i, l2;
      if (!stride) {
        stride = 3;
      }
      if (!offset3) {
        offset3 = 0;
      }
      if (count4) {
        l2 = Math.min(count4 * stride + offset3, a3.length);
      } else {
        l2 = a3.length;
      }
      for (i = offset3; i < l2; i += stride) {
        vec[0] = a3[i];
        vec[1] = a3[i + 1];
        vec[2] = a3[i + 2];
        fn(vec, vec, arg);
        a3[i] = vec[0];
        a3[i + 1] = vec[1];
        a3[i + 2] = vec[2];
      }
      return a3;
    };
  }();

  // node_modules/gl-matrix/esm/vec4.js
  var vec4_exports = {};
  __export(vec4_exports, {
    add: () => add5,
    ceil: () => ceil2,
    clone: () => clone8,
    copy: () => copy4,
    create: () => create4,
    cross: () => cross2,
    dist: () => dist2,
    distance: () => distance2,
    div: () => div2,
    divide: () => divide2,
    dot: () => dot2,
    equals: () => equals4,
    exactEquals: () => exactEquals4,
    floor: () => floor2,
    forEach: () => forEach2,
    fromValues: () => fromValues4,
    inverse: () => inverse2,
    len: () => len2,
    length: () => length2,
    lerp: () => lerp2,
    max: () => max3,
    min: () => min2,
    mul: () => mul4,
    multiply: () => multiply4,
    negate: () => negate2,
    normalize: () => normalize2,
    random: () => random2,
    round: () => round2,
    scale: () => scale4,
    scaleAndAdd: () => scaleAndAdd2,
    set: () => set4,
    sqrDist: () => sqrDist2,
    sqrLen: () => sqrLen2,
    squaredDistance: () => squaredDistance2,
    squaredLength: () => squaredLength2,
    str: () => str4,
    sub: () => sub4,
    subtract: () => subtract4,
    transformMat4: () => transformMat42,
    transformQuat: () => transformQuat2,
    zero: () => zero2
  });
  function create4() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function clone8(a3) {
    var out = new ARRAY_TYPE(4);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    return out;
  }
  function fromValues4(x3, y3, z, w) {
    var out = new ARRAY_TYPE(4);
    out[0] = x3;
    out[1] = y3;
    out[2] = z;
    out[3] = w;
    return out;
  }
  function copy4(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    return out;
  }
  function set4(out, x3, y3, z, w) {
    out[0] = x3;
    out[1] = y3;
    out[2] = z;
    out[3] = w;
    return out;
  }
  function add5(out, a3, b) {
    out[0] = a3[0] + b[0];
    out[1] = a3[1] + b[1];
    out[2] = a3[2] + b[2];
    out[3] = a3[3] + b[3];
    return out;
  }
  function subtract4(out, a3, b) {
    out[0] = a3[0] - b[0];
    out[1] = a3[1] - b[1];
    out[2] = a3[2] - b[2];
    out[3] = a3[3] - b[3];
    return out;
  }
  function multiply4(out, a3, b) {
    out[0] = a3[0] * b[0];
    out[1] = a3[1] * b[1];
    out[2] = a3[2] * b[2];
    out[3] = a3[3] * b[3];
    return out;
  }
  function divide2(out, a3, b) {
    out[0] = a3[0] / b[0];
    out[1] = a3[1] / b[1];
    out[2] = a3[2] / b[2];
    out[3] = a3[3] / b[3];
    return out;
  }
  function ceil2(out, a3) {
    out[0] = Math.ceil(a3[0]);
    out[1] = Math.ceil(a3[1]);
    out[2] = Math.ceil(a3[2]);
    out[3] = Math.ceil(a3[3]);
    return out;
  }
  function floor2(out, a3) {
    out[0] = Math.floor(a3[0]);
    out[1] = Math.floor(a3[1]);
    out[2] = Math.floor(a3[2]);
    out[3] = Math.floor(a3[3]);
    return out;
  }
  function min2(out, a3, b) {
    out[0] = Math.min(a3[0], b[0]);
    out[1] = Math.min(a3[1], b[1]);
    out[2] = Math.min(a3[2], b[2]);
    out[3] = Math.min(a3[3], b[3]);
    return out;
  }
  function max3(out, a3, b) {
    out[0] = Math.max(a3[0], b[0]);
    out[1] = Math.max(a3[1], b[1]);
    out[2] = Math.max(a3[2], b[2]);
    out[3] = Math.max(a3[3], b[3]);
    return out;
  }
  function round2(out, a3) {
    out[0] = Math.round(a3[0]);
    out[1] = Math.round(a3[1]);
    out[2] = Math.round(a3[2]);
    out[3] = Math.round(a3[3]);
    return out;
  }
  function scale4(out, a3, b) {
    out[0] = a3[0] * b;
    out[1] = a3[1] * b;
    out[2] = a3[2] * b;
    out[3] = a3[3] * b;
    return out;
  }
  function scaleAndAdd2(out, a3, b, scale10) {
    out[0] = a3[0] + b[0] * scale10;
    out[1] = a3[1] + b[1] * scale10;
    out[2] = a3[2] + b[2] * scale10;
    out[3] = a3[3] + b[3] * scale10;
    return out;
  }
  function distance2(a3, b) {
    var x3 = b[0] - a3[0];
    var y3 = b[1] - a3[1];
    var z = b[2] - a3[2];
    var w = b[3] - a3[3];
    return Math.hypot(x3, y3, z, w);
  }
  function squaredDistance2(a3, b) {
    var x3 = b[0] - a3[0];
    var y3 = b[1] - a3[1];
    var z = b[2] - a3[2];
    var w = b[3] - a3[3];
    return x3 * x3 + y3 * y3 + z * z + w * w;
  }
  function length2(a3) {
    var x3 = a3[0];
    var y3 = a3[1];
    var z = a3[2];
    var w = a3[3];
    return Math.hypot(x3, y3, z, w);
  }
  function squaredLength2(a3) {
    var x3 = a3[0];
    var y3 = a3[1];
    var z = a3[2];
    var w = a3[3];
    return x3 * x3 + y3 * y3 + z * z + w * w;
  }
  function negate2(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    out[3] = -a3[3];
    return out;
  }
  function inverse2(out, a3) {
    out[0] = 1 / a3[0];
    out[1] = 1 / a3[1];
    out[2] = 1 / a3[2];
    out[3] = 1 / a3[3];
    return out;
  }
  function normalize2(out, a3) {
    var x3 = a3[0];
    var y3 = a3[1];
    var z = a3[2];
    var w = a3[3];
    var len5 = x3 * x3 + y3 * y3 + z * z + w * w;
    if (len5 > 0) {
      len5 = 1 / Math.sqrt(len5);
    }
    out[0] = x3 * len5;
    out[1] = y3 * len5;
    out[2] = z * len5;
    out[3] = w * len5;
    return out;
  }
  function dot2(a3, b) {
    return a3[0] * b[0] + a3[1] * b[1] + a3[2] * b[2] + a3[3] * b[3];
  }
  function cross2(out, u, v, w) {
    var A5 = v[0] * w[1] - v[1] * w[0], B4 = v[0] * w[2] - v[2] * w[0], C4 = v[0] * w[3] - v[3] * w[0], D2 = v[1] * w[2] - v[2] * w[1], E2 = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E2 + J * D2;
    out[1] = -(G * F) + I * C4 - J * B4;
    out[2] = G * E2 - H * C4 + J * A5;
    out[3] = -(G * D2) + H * B4 - I * A5;
    return out;
  }
  function lerp2(out, a3, b, t) {
    var ax = a3[0];
    var ay = a3[1];
    var az = a3[2];
    var aw = a3[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
  }
  function random2(out, scale10) {
    scale10 = scale10 || 1;
    var v1, v2, v3, v4;
    var s1, s22;
    do {
      v1 = RANDOM() * 2 - 1;
      v2 = RANDOM() * 2 - 1;
      s1 = v1 * v1 + v2 * v2;
    } while (s1 >= 1);
    do {
      v3 = RANDOM() * 2 - 1;
      v4 = RANDOM() * 2 - 1;
      s22 = v3 * v3 + v4 * v4;
    } while (s22 >= 1);
    var d3 = Math.sqrt((1 - s1) / s22);
    out[0] = scale10 * v1;
    out[1] = scale10 * v2;
    out[2] = scale10 * v3 * d3;
    out[3] = scale10 * v4 * d3;
    return out;
  }
  function transformMat42(out, a3, m3) {
    var x3 = a3[0], y3 = a3[1], z = a3[2], w = a3[3];
    out[0] = m3[0] * x3 + m3[4] * y3 + m3[8] * z + m3[12] * w;
    out[1] = m3[1] * x3 + m3[5] * y3 + m3[9] * z + m3[13] * w;
    out[2] = m3[2] * x3 + m3[6] * y3 + m3[10] * z + m3[14] * w;
    out[3] = m3[3] * x3 + m3[7] * y3 + m3[11] * z + m3[15] * w;
    return out;
  }
  function transformQuat2(out, a3, q) {
    var x3 = a3[0], y3 = a3[1], z = a3[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var ix = qw * x3 + qy * z - qz * y3;
    var iy = qw * y3 + qz * x3 - qx * z;
    var iz = qw * z + qx * y3 - qy * x3;
    var iw = -qx * x3 - qy * y3 - qz * z;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a3[3];
    return out;
  }
  function zero2(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
  }
  function str4(a3) {
    return "vec4(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ")";
  }
  function exactEquals4(a3, b) {
    return a3[0] === b[0] && a3[1] === b[1] && a3[2] === b[2] && a3[3] === b[3];
  }
  function equals4(a3, b) {
    var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3));
  }
  var sub4 = subtract4;
  var mul4 = multiply4;
  var div2 = divide2;
  var dist2 = distance2;
  var sqrDist2 = squaredDistance2;
  var len2 = length2;
  var sqrLen2 = squaredLength2;
  var forEach2 = function() {
    var vec = create4();
    return function(a3, stride, offset3, count4, fn, arg) {
      var i, l2;
      if (!stride) {
        stride = 4;
      }
      if (!offset3) {
        offset3 = 0;
      }
      if (count4) {
        l2 = Math.min(count4 * stride + offset3, a3.length);
      } else {
        l2 = a3.length;
      }
      for (i = offset3; i < l2; i += stride) {
        vec[0] = a3[i];
        vec[1] = a3[i + 1];
        vec[2] = a3[i + 2];
        vec[3] = a3[i + 3];
        fn(vec, vec, arg);
        a3[i] = vec[0];
        a3[i + 1] = vec[1];
        a3[i + 2] = vec[2];
        a3[i + 3] = vec[3];
      }
      return a3;
    };
  }();

  // node_modules/gl-matrix/esm/quat.js
  function create5() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity3(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle(out, axis, rad2) {
    rad2 = rad2 * 0.5;
    var s3 = Math.sin(rad2);
    out[0] = s3 * axis[0];
    out[1] = s3 * axis[1];
    out[2] = s3 * axis[2];
    out[3] = Math.cos(rad2);
    return out;
  }
  function getAxisAngle(out_axis, q) {
    var rad2 = Math.acos(q[3]) * 2;
    var s3 = Math.sin(rad2 / 2);
    if (s3 > EPSILON) {
      out_axis[0] = q[0] / s3;
      out_axis[1] = q[1] / s3;
      out_axis[2] = q[2] / s3;
    } else {
      out_axis[0] = 1;
      out_axis[1] = 0;
      out_axis[2] = 0;
    }
    return rad2;
  }
  function getAngle(a3, b) {
    var dotproduct = dot3(a3, b);
    return Math.acos(2 * dotproduct * dotproduct - 1);
  }
  function multiply5(out, a3, b) {
    var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX3(out, a3, rad2) {
    rad2 *= 0.5;
    var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
    var bx = Math.sin(rad2), bw = Math.cos(rad2);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY3(out, a3, rad2) {
    rad2 *= 0.5;
    var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
    var by = Math.sin(rad2), bw = Math.cos(rad2);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ3(out, a3, rad2) {
    rad2 *= 0.5;
    var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
    var bz = Math.sin(rad2), bw = Math.cos(rad2);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW(out, a3) {
    var x3 = a3[0], y3 = a3[1], z = a3[2];
    out[0] = x3;
    out[1] = y3;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1 - x3 * x3 - y3 * y3 - z * z));
    return out;
  }
  function exp(out, a3) {
    var x3 = a3[0], y3 = a3[1], z = a3[2], w = a3[3];
    var r = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
    var et = Math.exp(w);
    var s3 = r > 0 ? et * Math.sin(r) / r : 0;
    out[0] = x3 * s3;
    out[1] = y3 * s3;
    out[2] = z * s3;
    out[3] = et * Math.cos(r);
    return out;
  }
  function ln(out, a3) {
    var x3 = a3[0], y3 = a3[1], z = a3[2], w = a3[3];
    var r = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
    var t = r > 0 ? Math.atan2(r, w) / r : 0;
    out[0] = x3 * t;
    out[1] = y3 * t;
    out[2] = z * t;
    out[3] = 0.5 * Math.log(x3 * x3 + y3 * y3 + z * z + w * w);
    return out;
  }
  function pow(out, a3, b) {
    ln(out, a3);
    scale5(out, out, b);
    exp(out, out);
    return out;
  }
  function slerp(out, a3, b, t) {
    var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega, cosom, sinom, scale0, scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1 - t;
      scale1 = t;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function random3(out) {
    var u1 = RANDOM();
    var u2 = RANDOM();
    var u3 = RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
    return out;
  }
  function invert3(out, a3) {
    var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
    var dot8 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
    var invDot = dot8 ? 1 / dot8 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a22 * invDot;
    out[3] = a32 * invDot;
    return out;
  }
  function conjugate(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    out[3] = a3[3];
    return out;
  }
  function fromMat3(out, m3) {
    var fTrace = m3[0] + m3[4] + m3[8];
    var fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m3[5] - m3[7]) * fRoot;
      out[1] = (m3[6] - m3[2]) * fRoot;
      out[2] = (m3[1] - m3[3]) * fRoot;
    } else {
      var i = 0;
      if (m3[4] > m3[0]) i = 1;
      if (m3[8] > m3[i * 3 + i]) i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m3[i * 3 + i] - m3[j * 3 + j] - m3[k * 3 + k] + 1);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m3[j * 3 + k] - m3[k * 3 + j]) * fRoot;
      out[j] = (m3[j * 3 + i] + m3[i * 3 + j]) * fRoot;
      out[k] = (m3[k * 3 + i] + m3[i * 3 + k]) * fRoot;
    }
    return out;
  }
  function fromEuler(out, x3, y3, z) {
    var halfToRad = 0.5 * Math.PI / 180;
    x3 *= halfToRad;
    y3 *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x3);
    var cx = Math.cos(x3);
    var sy = Math.sin(y3);
    var cy = Math.cos(y3);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  function str5(a3) {
    return "quat(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ")";
  }
  var clone9 = clone8;
  var fromValues5 = fromValues4;
  var copy5 = copy4;
  var set5 = set4;
  var add6 = add5;
  var mul5 = multiply5;
  var scale5 = scale4;
  var dot3 = dot2;
  var lerp3 = lerp2;
  var length3 = length2;
  var len3 = length3;
  var squaredLength3 = squaredLength2;
  var sqrLen3 = squaredLength3;
  var normalize3 = normalize2;
  var exactEquals5 = exactEquals4;
  var equals5 = equals4;
  var rotationTo = function() {
    var tmpvec3 = create3();
    var xUnitVec3 = fromValues3(1, 0, 0);
    var yUnitVec3 = fromValues3(0, 1, 0);
    return function(out, a3, b) {
      var dot8 = dot(a3, b);
      if (dot8 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a3);
        if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a3);
        normalize(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot8 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a3, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot8;
        return normalize3(out, out);
      }
    };
  }();
  var sqlerp = function() {
    var temp1 = create5();
    var temp2 = create5();
    return function(out, a3, b, c5, d3, t) {
      slerp(temp1, a3, d3, t);
      slerp(temp2, b, c5, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  }();
  var setAxes = function() {
    var matr = create();
    return function(out, view, right2, up) {
      matr[0] = right2[0];
      matr[3] = right2[1];
      matr[6] = right2[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize3(out, fromMat3(out, matr));
    };
  }();

  // node_modules/gl-matrix/esm/vec2.js
  var vec2_exports = {};
  __export(vec2_exports, {
    add: () => add7,
    angle: () => angle2,
    ceil: () => ceil3,
    clone: () => clone10,
    copy: () => copy6,
    create: () => create6,
    cross: () => cross3,
    dist: () => dist3,
    distance: () => distance3,
    div: () => div3,
    divide: () => divide3,
    dot: () => dot4,
    equals: () => equals6,
    exactEquals: () => exactEquals6,
    floor: () => floor3,
    forEach: () => forEach3,
    fromValues: () => fromValues6,
    inverse: () => inverse3,
    len: () => len4,
    length: () => length4,
    lerp: () => lerp4,
    max: () => max4,
    min: () => min3,
    mul: () => mul6,
    multiply: () => multiply6,
    negate: () => negate3,
    normalize: () => normalize4,
    random: () => random4,
    rotate: () => rotate3,
    round: () => round3,
    scale: () => scale6,
    scaleAndAdd: () => scaleAndAdd3,
    set: () => set6,
    sqrDist: () => sqrDist3,
    sqrLen: () => sqrLen4,
    squaredDistance: () => squaredDistance3,
    squaredLength: () => squaredLength4,
    str: () => str6,
    sub: () => sub5,
    subtract: () => subtract5,
    transformMat2: () => transformMat2,
    transformMat2d: () => transformMat2d,
    transformMat3: () => transformMat32,
    transformMat4: () => transformMat43,
    zero: () => zero3
  });
  function create6() {
    var out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function clone10(a3) {
    var out = new ARRAY_TYPE(2);
    out[0] = a3[0];
    out[1] = a3[1];
    return out;
  }
  function fromValues6(x3, y3) {
    var out = new ARRAY_TYPE(2);
    out[0] = x3;
    out[1] = y3;
    return out;
  }
  function copy6(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    return out;
  }
  function set6(out, x3, y3) {
    out[0] = x3;
    out[1] = y3;
    return out;
  }
  function add7(out, a3, b) {
    out[0] = a3[0] + b[0];
    out[1] = a3[1] + b[1];
    return out;
  }
  function subtract5(out, a3, b) {
    out[0] = a3[0] - b[0];
    out[1] = a3[1] - b[1];
    return out;
  }
  function multiply6(out, a3, b) {
    out[0] = a3[0] * b[0];
    out[1] = a3[1] * b[1];
    return out;
  }
  function divide3(out, a3, b) {
    out[0] = a3[0] / b[0];
    out[1] = a3[1] / b[1];
    return out;
  }
  function ceil3(out, a3) {
    out[0] = Math.ceil(a3[0]);
    out[1] = Math.ceil(a3[1]);
    return out;
  }
  function floor3(out, a3) {
    out[0] = Math.floor(a3[0]);
    out[1] = Math.floor(a3[1]);
    return out;
  }
  function min3(out, a3, b) {
    out[0] = Math.min(a3[0], b[0]);
    out[1] = Math.min(a3[1], b[1]);
    return out;
  }
  function max4(out, a3, b) {
    out[0] = Math.max(a3[0], b[0]);
    out[1] = Math.max(a3[1], b[1]);
    return out;
  }
  function round3(out, a3) {
    out[0] = Math.round(a3[0]);
    out[1] = Math.round(a3[1]);
    return out;
  }
  function scale6(out, a3, b) {
    out[0] = a3[0] * b;
    out[1] = a3[1] * b;
    return out;
  }
  function scaleAndAdd3(out, a3, b, scale10) {
    out[0] = a3[0] + b[0] * scale10;
    out[1] = a3[1] + b[1] * scale10;
    return out;
  }
  function distance3(a3, b) {
    var x3 = b[0] - a3[0], y3 = b[1] - a3[1];
    return Math.hypot(x3, y3);
  }
  function squaredDistance3(a3, b) {
    var x3 = b[0] - a3[0], y3 = b[1] - a3[1];
    return x3 * x3 + y3 * y3;
  }
  function length4(a3) {
    var x3 = a3[0], y3 = a3[1];
    return Math.hypot(x3, y3);
  }
  function squaredLength4(a3) {
    var x3 = a3[0], y3 = a3[1];
    return x3 * x3 + y3 * y3;
  }
  function negate3(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    return out;
  }
  function inverse3(out, a3) {
    out[0] = 1 / a3[0];
    out[1] = 1 / a3[1];
    return out;
  }
  function normalize4(out, a3) {
    var x3 = a3[0], y3 = a3[1];
    var len5 = x3 * x3 + y3 * y3;
    if (len5 > 0) {
      len5 = 1 / Math.sqrt(len5);
    }
    out[0] = a3[0] * len5;
    out[1] = a3[1] * len5;
    return out;
  }
  function dot4(a3, b) {
    return a3[0] * b[0] + a3[1] * b[1];
  }
  function cross3(out, a3, b) {
    var z = a3[0] * b[1] - a3[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
  }
  function lerp4(out, a3, b, t) {
    var ax = a3[0], ay = a3[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
  }
  function random4(out, scale10) {
    scale10 = scale10 || 1;
    var r = RANDOM() * 2 * Math.PI;
    out[0] = Math.cos(r) * scale10;
    out[1] = Math.sin(r) * scale10;
    return out;
  }
  function transformMat2(out, a3, m3) {
    var x3 = a3[0], y3 = a3[1];
    out[0] = m3[0] * x3 + m3[2] * y3;
    out[1] = m3[1] * x3 + m3[3] * y3;
    return out;
  }
  function transformMat2d(out, a3, m3) {
    var x3 = a3[0], y3 = a3[1];
    out[0] = m3[0] * x3 + m3[2] * y3 + m3[4];
    out[1] = m3[1] * x3 + m3[3] * y3 + m3[5];
    return out;
  }
  function transformMat32(out, a3, m3) {
    var x3 = a3[0], y3 = a3[1];
    out[0] = m3[0] * x3 + m3[3] * y3 + m3[6];
    out[1] = m3[1] * x3 + m3[4] * y3 + m3[7];
    return out;
  }
  function transformMat43(out, a3, m3) {
    var x3 = a3[0];
    var y3 = a3[1];
    out[0] = m3[0] * x3 + m3[4] * y3 + m3[12];
    out[1] = m3[1] * x3 + m3[5] * y3 + m3[13];
    return out;
  }
  function rotate3(out, a3, b, rad2) {
    var p0 = a3[0] - b[0], p1 = a3[1] - b[1], sinC = Math.sin(rad2), cosC = Math.cos(rad2);
    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
  }
  function angle2(a3, b) {
    var x12 = a3[0], y12 = a3[1], x22 = b[0], y22 = b[1], mag = Math.sqrt(x12 * x12 + y12 * y12) * Math.sqrt(x22 * x22 + y22 * y22), cosine = mag && (x12 * x22 + y12 * y22) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero3(out) {
    out[0] = 0;
    out[1] = 0;
    return out;
  }
  function str6(a3) {
    return "vec2(" + a3[0] + ", " + a3[1] + ")";
  }
  function exactEquals6(a3, b) {
    return a3[0] === b[0] && a3[1] === b[1];
  }
  function equals6(a3, b) {
    var a0 = a3[0], a1 = a3[1];
    var b0 = b[0], b1 = b[1];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
  }
  var len4 = length4;
  var sub5 = subtract5;
  var mul6 = multiply6;
  var div3 = divide3;
  var dist3 = distance3;
  var sqrDist3 = squaredDistance3;
  var sqrLen4 = squaredLength4;
  var forEach3 = function() {
    var vec = create6();
    return function(a3, stride, offset3, count4, fn, arg) {
      var i, l2;
      if (!stride) {
        stride = 2;
      }
      if (!offset3) {
        offset3 = 0;
      }
      if (count4) {
        l2 = Math.min(count4 * stride + offset3, a3.length);
      } else {
        l2 = a3.length;
      }
      for (i = offset3; i < l2; i += stride) {
        vec[0] = a3[i];
        vec[1] = a3[i + 1];
        fn(vec, vec, arg);
        a3[i] = vec[0];
        a3[i + 1] = vec[1];
      }
      return a3;
    };
  }();

  // node_modules/tslib/tslib.es6.mjs
  var extendStatics = function(d3, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d4[p2] = b2[p2];
    };
    return extendStatics(d3, b);
  };
  function __extends(d3, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d3, b);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = function() {
    __assign = Object.assign || function __assign2(t) {
      for (var s3, i = 1, n2 = arguments.length; i < n2; i++) {
        s3 = arguments[i];
        for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2)) t[p2] = s3[p2];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  }
  function __values(o) {
    var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i = 0;
    if (m3) return m3.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n2) {
    var m3 = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m3) return o;
    var i = m3.call(o), r, ar = [], e3;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error4) {
      e3 = { error: error4 };
    } finally {
      try {
        if (r && !r.done && (m3 = i["return"])) m3.call(i);
      } finally {
        if (e3) throw e3.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from, pack3) {
    if (pack3 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  }

  // node_modules/@antv/util/esm/path/parser/params-parser.js
  var paramsParser = {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    x: 0,
    y: 0,
    qx: null,
    qy: null
  };

  // node_modules/@antv/util/esm/path/process/fix-arc.js
  function fixArc(pathArray, allPathCommands, i) {
    if (pathArray[i].length > 7) {
      pathArray[i].shift();
      var pi4 = pathArray[i];
      var ni = i;
      while (pi4.length) {
        allPathCommands[i] = "A";
        pathArray.splice(ni += 1, 0, ["C"].concat(pi4.splice(0, 6)));
      }
      pathArray.splice(i, 1);
    }
  }

  // node_modules/@antv/util/esm/path/parser/params-count.js
  var paramsCount = {
    a: 7,
    c: 6,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    z: 0
  };

  // node_modules/@antv/util/esm/path/util/is-path-array.js
  function isPathArray(path2) {
    return Array.isArray(path2) && path2.every(function(seg) {
      var lk = seg[0].toLowerCase();
      return paramsCount[lk] === seg.length - 1 && "achlmqstvz".includes(lk);
    });
  }

  // node_modules/@antv/util/esm/path/util/is-absolute-array.js
  function isAbsoluteArray(path2) {
    return isPathArray(path2) && // @ts-ignore -- `isPathArray` also checks if it's `Array`
    path2.every(function(_a) {
      var x3 = _a[0];
      return x3 === x3.toUpperCase();
    });
  }

  // node_modules/@antv/util/esm/path/util/is-normalized-array.js
  function isNormalizedArray(path2) {
    return isAbsoluteArray(path2) && path2.every(function(_a) {
      var pc = _a[0];
      return "ACLMQZ".includes(pc);
    });
  }

  // node_modules/@antv/util/esm/path/parser/finalize-segment.js
  function finalizeSegment(path2) {
    var pathCommand = path2.pathValue[path2.segmentStart];
    var LK = pathCommand.toLowerCase();
    var data2 = path2.data;
    while (data2.length >= paramsCount[LK]) {
      if (LK === "m" && data2.length > 2) {
        path2.segments.push([pathCommand].concat(data2.splice(0, 2)));
        LK = "l";
        pathCommand = pathCommand === "m" ? "l" : "L";
      } else {
        path2.segments.push([pathCommand].concat(data2.splice(0, paramsCount[LK])));
      }
      if (!paramsCount[LK]) {
        break;
      }
    }
  }

  // node_modules/@antv/util/esm/path/parser/scan-flag.js
  function scanFlag(path2) {
    var index4 = path2.index, pathValue = path2.pathValue;
    var code = pathValue.charCodeAt(index4);
    if (code === 48) {
      path2.param = 0;
      path2.index += 1;
      return;
    }
    if (code === 49) {
      path2.param = 1;
      path2.index += 1;
      return;
    }
    path2.err = '[path-util]: invalid Arc flag "'.concat(pathValue[index4], '", expecting 0 or 1 at index ').concat(index4);
  }

  // node_modules/@antv/util/esm/path/parser/is-digit-start.js
  function isDigitStart(code) {
    return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
  }
  function isDigit(code) {
    return code >= 48 && code <= 57;
  }

  // node_modules/@antv/util/esm/path/parser/scan-param.js
  function scanParam(path2) {
    var max11 = path2.max, pathValue = path2.pathValue, start2 = path2.index;
    var index4 = start2;
    var zeroFirst = false;
    var hasCeiling = false;
    var hasDecimal = false;
    var hasDot = false;
    var ch2;
    if (index4 >= max11) {
      path2.err = "[path-util]: Invalid path value at index ".concat(index4, ', "pathValue" is missing param');
      return;
    }
    ch2 = pathValue.charCodeAt(index4);
    if (ch2 === 43 || ch2 === 45) {
      index4 += 1;
      ch2 = pathValue.charCodeAt(index4);
    }
    if (!isDigit(ch2) && ch2 !== 46) {
      path2.err = "[path-util]: Invalid path value at index ".concat(index4, ', "').concat(pathValue[index4], '" is not a number');
      return;
    }
    if (ch2 !== 46) {
      zeroFirst = ch2 === 48;
      index4 += 1;
      ch2 = pathValue.charCodeAt(index4);
      if (zeroFirst && index4 < max11) {
        if (ch2 && isDigit(ch2)) {
          path2.err = "[path-util]: Invalid path value at index ".concat(start2, ', "').concat(pathValue[start2], '" illegal number');
          return;
        }
      }
      while (index4 < max11 && isDigit(pathValue.charCodeAt(index4))) {
        index4 += 1;
        hasCeiling = true;
      }
      ch2 = pathValue.charCodeAt(index4);
    }
    if (ch2 === 46) {
      hasDot = true;
      index4 += 1;
      while (isDigit(pathValue.charCodeAt(index4))) {
        index4 += 1;
        hasDecimal = true;
      }
      ch2 = pathValue.charCodeAt(index4);
    }
    if (ch2 === 101 || ch2 === 69) {
      if (hasDot && !hasCeiling && !hasDecimal) {
        path2.err = "[path-util]: Invalid path value at index ".concat(index4, ', "').concat(pathValue[index4], '" invalid float exponent');
        return;
      }
      index4 += 1;
      ch2 = pathValue.charCodeAt(index4);
      if (ch2 === 43 || ch2 === 45) {
        index4 += 1;
      }
      if (index4 < max11 && isDigit(pathValue.charCodeAt(index4))) {
        while (index4 < max11 && isDigit(pathValue.charCodeAt(index4))) {
          index4 += 1;
        }
      } else {
        path2.err = "[path-util]: Invalid path value at index ".concat(index4, ', "').concat(pathValue[index4], '" invalid integer exponent');
        return;
      }
    }
    path2.index = index4;
    path2.param = +path2.pathValue.slice(start2, index4);
  }

  // node_modules/@antv/util/esm/path/parser/is-space.js
  function isSpace(ch2) {
    var specialSpaces = [
      5760,
      6158,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ];
    return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233 || // Line terminators
    // White spaces
    ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && specialSpaces.includes(ch2);
  }

  // node_modules/@antv/util/esm/path/parser/skip-spaces.js
  function skipSpaces(path2) {
    var pathValue = path2.pathValue, max11 = path2.max;
    while (path2.index < max11 && isSpace(pathValue.charCodeAt(path2.index))) {
      path2.index += 1;
    }
  }

  // node_modules/@antv/util/esm/path/parser/is-path-command.js
  function isPathCommand(code) {
    switch (code | 32) {
      case 109:
      case 122:
      case 108:
      case 104:
      case 118:
      case 99:
      case 115:
      case 113:
      case 116:
      case 97:
        return true;
      default:
        return false;
    }
  }

  // node_modules/@antv/util/esm/path/parser/is-arc-command.js
  function isArcCommand(code) {
    return (code | 32) === 97;
  }

  // node_modules/@antv/util/esm/path/parser/scan-segment.js
  function scanSegment(path2) {
    var max11 = path2.max, pathValue = path2.pathValue, index4 = path2.index;
    var cmdCode = pathValue.charCodeAt(index4);
    var reqParams = paramsCount[pathValue[index4].toLowerCase()];
    path2.segmentStart = index4;
    if (!isPathCommand(cmdCode)) {
      path2.err = '[path-util]: Invalid path value "'.concat(pathValue[index4], '" is not a path command');
      return;
    }
    path2.index += 1;
    skipSpaces(path2);
    path2.data = [];
    if (!reqParams) {
      finalizeSegment(path2);
      return;
    }
    for (; ; ) {
      for (var i = reqParams; i > 0; i -= 1) {
        if (isArcCommand(cmdCode) && (i === 3 || i === 4))
          scanFlag(path2);
        else
          scanParam(path2);
        if (path2.err.length) {
          return;
        }
        path2.data.push(path2.param);
        skipSpaces(path2);
        if (path2.index < max11 && pathValue.charCodeAt(path2.index) === 44) {
          path2.index += 1;
          skipSpaces(path2);
        }
      }
      if (path2.index >= path2.max) {
        break;
      }
      if (!isDigitStart(pathValue.charCodeAt(path2.index))) {
        break;
      }
    }
    finalizeSegment(path2);
  }

  // node_modules/@antv/util/esm/path/parser/path-parser.js
  var PathParser = (
    /** @class */
    /* @__PURE__ */ function() {
      function PathParser2(pathString) {
        this.pathValue = pathString;
        this.segments = [];
        this.max = pathString.length;
        this.index = 0;
        this.param = 0;
        this.segmentStart = 0;
        this.data = [];
        this.err = "";
      }
      return PathParser2;
    }()
  );

  // node_modules/@antv/util/esm/path/parser/parse-path-string.js
  function parsePathString(pathInput) {
    if (isPathArray(pathInput)) {
      return [].concat(pathInput);
    }
    var path2 = new PathParser(pathInput);
    skipSpaces(path2);
    while (path2.index < path2.max && !path2.err.length) {
      scanSegment(path2);
    }
    return path2.err ? path2.err : path2.segments;
  }

  // node_modules/@antv/util/esm/path/convert/path-2-absolute.js
  function path2Absolute(pathInput) {
    if (isAbsoluteArray(pathInput)) {
      return [].concat(pathInput);
    }
    var path2 = parsePathString(pathInput);
    var x3 = 0;
    var y3 = 0;
    var mx = 0;
    var my = 0;
    return path2.map(function(segment) {
      var values = segment.slice(1).map(Number);
      var pathCommand = segment[0];
      var absCommand = pathCommand.toUpperCase();
      if (pathCommand === "M") {
        x3 = values[0], y3 = values[1];
        mx = x3;
        my = y3;
        return ["M", x3, y3];
      }
      var absoluteSegment;
      if (pathCommand !== absCommand) {
        switch (absCommand) {
          case "A":
            absoluteSegment = [
              absCommand,
              values[0],
              values[1],
              values[2],
              values[3],
              values[4],
              values[5] + x3,
              values[6] + y3
            ];
            break;
          case "V":
            absoluteSegment = [absCommand, values[0] + y3];
            break;
          case "H":
            absoluteSegment = [absCommand, values[0] + x3];
            break;
          default: {
            var absValues = values.map(function(n2, j) {
              return n2 + (j % 2 ? y3 : x3);
            });
            absoluteSegment = [absCommand].concat(absValues);
          }
        }
      } else {
        absoluteSegment = [absCommand].concat(values);
      }
      var segLength = absoluteSegment.length;
      switch (absCommand) {
        case "Z":
          x3 = mx;
          y3 = my;
          break;
        case "H":
          x3 = absoluteSegment[1];
          break;
        case "V":
          y3 = absoluteSegment[1];
          break;
        default:
          x3 = absoluteSegment[segLength - 2];
          y3 = absoluteSegment[segLength - 1];
          if (absCommand === "M") {
            mx = x3;
            my = y3;
          }
      }
      return absoluteSegment;
    });
  }

  // node_modules/@antv/util/esm/path/process/normalize-segment.js
  function normalizeSegment(segment, params) {
    var pathCommand = segment[0];
    var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
    var values = segment.slice(1).map(Number);
    var result = segment;
    if (!"TQ".includes(pathCommand)) {
      params.qx = null;
      params.qy = null;
    }
    if (pathCommand === "H") {
      result = ["L", segment[1], py1];
    } else if (pathCommand === "V") {
      result = ["L", px1, segment[1]];
    } else if (pathCommand === "S") {
      var x12 = px1 * 2 - px2;
      var y12 = py1 * 2 - py2;
      params.x1 = x12;
      params.y1 = y12;
      result = ["C", x12, y12].concat(values);
    } else if (pathCommand === "T") {
      var qx = px1 * 2 - params.qx;
      var qy = py1 * 2 - params.qy;
      params.qx = qx;
      params.qy = qy;
      result = ["Q", qx, qy].concat(values);
    } else if (pathCommand === "Q") {
      var nqx = values[0], nqy = values[1];
      params.qx = nqx;
      params.qy = nqy;
    }
    return result;
  }

  // node_modules/@antv/util/esm/path/process/normalize-path.js
  function normalizePath(pathInput) {
    if (isNormalizedArray(pathInput)) {
      return [].concat(pathInput);
    }
    var path2 = path2Absolute(pathInput);
    var params = __assign({}, paramsParser);
    for (var i = 0; i < path2.length; i += 1) {
      path2[i] = normalizeSegment(path2[i], params);
      var segment = path2[i];
      var seglen = segment.length;
      params.x1 = +segment[seglen - 2];
      params.y1 = +segment[seglen - 1];
      params.x2 = +segment[seglen - 4] || params.x1;
      params.y2 = +segment[seglen - 3] || params.y1;
    }
    return path2;
  }

  // node_modules/@antv/util/esm/path/util/is-curve-array.js
  function isCurveArray(path2) {
    return isNormalizedArray(path2) && path2.every(function(_a) {
      var pc = _a[0];
      return "MC".includes(pc);
    });
  }

  // node_modules/@antv/util/esm/path/util/rotate-vector.js
  function rotateVector(x3, y3, rad2) {
    var X = x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
    var Y = x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
    return { x: X, y: Y };
  }

  // node_modules/@antv/util/esm/path/process/arc-2-cubic.js
  function arcToCubic(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, recursive) {
    var x12 = X12;
    var y12 = Y12;
    var rx = RX;
    var ry = RY;
    var x22 = X22;
    var y22 = Y22;
    var d120 = Math.PI * 120 / 180;
    var rad2 = Math.PI / 180 * (+angle4 || 0);
    var res = [];
    var xy;
    var f1;
    var f2;
    var cx;
    var cy;
    if (!recursive) {
      xy = rotateVector(x12, y12, -rad2);
      x12 = xy.x;
      y12 = xy.y;
      xy = rotateVector(x22, y22, -rad2);
      x22 = xy.x;
      y22 = xy.y;
      var x3 = (x12 - x22) / 2;
      var y3 = (y12 - y22) / 2;
      var h = x3 * x3 / (rx * rx) + y3 * y3 / (ry * ry);
      if (h > 1) {
        h = Math.sqrt(h);
        rx *= h;
        ry *= h;
      }
      var rx2 = rx * rx;
      var ry2 = ry * ry;
      var k = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y3 * y3 - ry2 * x3 * x3) / (rx2 * y3 * y3 + ry2 * x3 * x3)));
      cx = k * rx * y3 / ry + (x12 + x22) / 2;
      cy = k * -ry * x3 / rx + (y12 + y22) / 2;
      f1 = Math.asin(((y12 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
      f2 = Math.asin(((y22 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
      f1 = x12 < cx ? Math.PI - f1 : f1;
      f2 = x22 < cx ? Math.PI - f2 : f2;
      if (f1 < 0)
        f1 = Math.PI * 2 + f1;
      if (f2 < 0)
        f2 = Math.PI * 2 + f2;
      if (SF && f1 > f2) {
        f1 -= Math.PI * 2;
      }
      if (!SF && f2 > f1) {
        f2 -= Math.PI * 2;
      }
    } else {
      f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
    }
    var df = f2 - f1;
    if (Math.abs(df) > d120) {
      var f2old = f2;
      var x2old = x22;
      var y2old = y22;
      f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
      x22 = cx + rx * Math.cos(f2);
      y22 = cy + ry * Math.sin(f2);
      res = arcToCubic(x22, y22, rx, ry, angle4, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
    }
    df = f2 - f1;
    var c1 = Math.cos(f1);
    var s1 = Math.sin(f1);
    var c22 = Math.cos(f2);
    var s22 = Math.sin(f2);
    var t = Math.tan(df / 4);
    var hx = 4 / 3 * rx * t;
    var hy = 4 / 3 * ry * t;
    var m1 = [x12, y12];
    var m22 = [x12 + hx * s1, y12 - hy * c1];
    var m3 = [x22 + hx * s22, y22 - hy * c22];
    var m4 = [x22, y22];
    m22[0] = 2 * m1[0] - m22[0];
    m22[1] = 2 * m1[1] - m22[1];
    if (recursive) {
      return m22.concat(m3, m4, res);
    }
    res = m22.concat(m3, m4, res);
    var newres = [];
    for (var i = 0, ii = res.length; i < ii; i += 1) {
      newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad2).y : rotateVector(res[i], res[i + 1], rad2).x;
    }
    return newres;
  }

  // node_modules/@antv/util/esm/path/process/quad-2-cubic.js
  function quadToCubic(x12, y12, qx, qy, x22, y22) {
    var r13 = 1 / 3;
    var r23 = 2 / 3;
    return [
      r13 * x12 + r23 * qx,
      // cpx1
      r13 * y12 + r23 * qy,
      // cpy1
      r13 * x22 + r23 * qx,
      // cpx2
      r13 * y22 + r23 * qy,
      // cpy2
      x22,
      y22
      // x,y
    ];
  }

  // node_modules/@antv/util/esm/path/util/mid-point.js
  function midPoint(a3, b, t) {
    var ax = a3[0];
    var ay = a3[1];
    var bx = b[0];
    var by = b[1];
    return [ax + (bx - ax) * t, ay + (by - ay) * t];
  }

  // node_modules/@antv/util/esm/path/process/line-2-cubic.js
  var lineToCubic = function(x12, y12, x22, y22) {
    var t = 0.5;
    var mid2 = midPoint([x12, y12], [x22, y22], t);
    return __spreadArray(__spreadArray([], mid2, true), [x22, y22, x22, y22], false);
  };

  // node_modules/@antv/util/esm/path/process/segment-2-cubic.js
  function segmentToCubic(segment, params) {
    var pathCommand = segment[0];
    var values = segment.slice(1).map(Number);
    var x3 = values[0], y3 = values[1];
    var args;
    var px1 = params.x1, py1 = params.y1, px2 = params.x, py = params.y;
    if (!"TQ".includes(pathCommand)) {
      params.qx = null;
      params.qy = null;
    }
    switch (pathCommand) {
      case "M":
        params.x = x3;
        params.y = y3;
        return segment;
      case "A":
        args = [px1, py1].concat(values);
        return ["C"].concat(arcToCubic(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
      case "Q":
        params.qx = x3;
        params.qy = y3;
        args = [px1, py1].concat(values);
        return ["C"].concat(quadToCubic(args[0], args[1], args[2], args[3], args[4], args[5]));
      case "L":
        return ["C"].concat(lineToCubic(px1, py1, x3, y3));
      case "Z":
        if (px1 === px2 && py1 === py) {
          return ["C", px1, py1, px2, py, px2, py];
        }
        return ["C"].concat(lineToCubic(px1, py1, px2, py));
      default:
    }
    return segment;
  }

  // node_modules/@antv/util/esm/path/convert/path-2-curve.js
  function path2Curve(pathInput, needZCommandIndexes) {
    if (needZCommandIndexes === void 0) {
      needZCommandIndexes = false;
    }
    if (isCurveArray(pathInput)) {
      var cloned = [].concat(pathInput);
      if (needZCommandIndexes) {
        return [cloned, []];
      } else {
        return cloned;
      }
    }
    var path2 = normalizePath(pathInput);
    var params = __assign({}, paramsParser);
    var allPathCommands = [];
    var pathCommand = "";
    var ii = path2.length;
    var segment;
    var seglen;
    var zCommandIndexes = [];
    for (var i = 0; i < ii; i += 1) {
      if (path2[i])
        pathCommand = path2[i][0];
      allPathCommands[i] = pathCommand;
      var curveSegment = segmentToCubic(path2[i], params);
      path2[i] = curveSegment;
      fixArc(path2, allPathCommands, i);
      ii = path2.length;
      if (pathCommand === "Z") {
        zCommandIndexes.push(i);
      }
      segment = path2[i];
      seglen = segment.length;
      params.x1 = +segment[seglen - 2];
      params.y1 = +segment[seglen - 1];
      params.x2 = +segment[seglen - 4] || params.x1;
      params.y2 = +segment[seglen - 3] || params.y1;
    }
    if (needZCommandIndexes) {
      return [path2, zCommandIndexes];
    } else {
      return path2;
    }
  }

  // node_modules/@antv/util/esm/path/process/clone-path.js
  function clonePath(path2) {
    return path2.map(function(x3) {
      return Array.isArray(x3) ? [].concat(x3) : x3;
    });
  }

  // node_modules/@antv/util/esm/path/process/reverse-curve.js
  function reverseCurve(pathArray) {
    var rotatedCurve = pathArray.slice(1).map(function(x3, i, curveOnly) {
      return !i ? pathArray[0].slice(1).concat(x3.slice(1)) : curveOnly[i - 1].slice(-2).concat(x3.slice(1));
    }).map(function(x3) {
      return x3.map(function(y3, i) {
        return x3[x3.length - i - 2 * (1 - i % 2)];
      });
    }).reverse();
    return [["M"].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function(x3) {
      return ["C"].concat(x3.slice(2));
    }));
  }

  // node_modules/@antv/util/esm/path/util/distance-square-root.js
  function distanceSquareRoot(a3, b) {
    return Math.sqrt((a3[0] - b[0]) * (a3[0] - b[0]) + (a3[1] - b[1]) * (a3[1] - b[1]));
  }

  // node_modules/@antv/util/esm/path/util/segment-line-factory.js
  function segmentLineFactory(x12, y12, x22, y22, distance7) {
    var length5 = distanceSquareRoot([x12, y12], [x22, y22]);
    var point6 = { x: 0, y: 0 };
    if (typeof distance7 === "number") {
      if (distance7 <= 0) {
        point6 = { x: x12, y: y12 };
      } else if (distance7 >= length5) {
        point6 = { x: x22, y: y22 };
      } else {
        var _a = midPoint([x12, y12], [x22, y22], distance7 / length5), x3 = _a[0], y3 = _a[1];
        point6 = { x: x3, y: y3 };
      }
    }
    return {
      length: length5,
      point: point6,
      min: {
        x: Math.min(x12, x22),
        y: Math.min(y12, y22)
      },
      max: {
        x: Math.max(x12, x22),
        y: Math.max(y12, y22)
      }
    };
  }

  // node_modules/@antv/util/esm/path/util/segment-arc-factory.js
  function angleBetween(v0, v1) {
    var v0x = v0.x, v0y = v0.y;
    var v1x = v1.x, v1y = v1.y;
    var p2 = v0x * v1x + v0y * v1y;
    var n2 = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
    var sign3 = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
    var angle4 = sign3 * Math.acos(p2 / n2);
    return angle4;
  }
  function getPointAtArcSegmentLength(x12, y12, RX, RY, angle4, LAF, SF, x3, y3, t) {
    var abs3 = Math.abs, sin3 = Math.sin, cos3 = Math.cos, sqrt3 = Math.sqrt, PI = Math.PI;
    var rx = abs3(RX);
    var ry = abs3(RY);
    var xRot = (angle4 % 360 + 360) % 360;
    var xRotRad = xRot * (PI / 180);
    if (x12 === x3 && y12 === y3) {
      return { x: x12, y: y12 };
    }
    if (rx === 0 || ry === 0) {
      return segmentLineFactory(x12, y12, x3, y3, t).point;
    }
    var dx = (x12 - x3) / 2;
    var dy = (y12 - y3) / 2;
    var transformedPoint = {
      x: cos3(xRotRad) * dx + sin3(xRotRad) * dy,
      y: -sin3(xRotRad) * dx + cos3(xRotRad) * dy
    };
    var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
    if (radiiCheck > 1) {
      rx *= sqrt3(radiiCheck);
      ry *= sqrt3(radiiCheck);
    }
    var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
    var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
    var cRadicand = cSquareNumerator / cSquareRootDenom;
    cRadicand = cRadicand < 0 ? 0 : cRadicand;
    var cCoef = (LAF !== SF ? 1 : -1) * sqrt3(cRadicand);
    var transformedCenter = {
      x: cCoef * (rx * transformedPoint.y / ry),
      y: cCoef * (-(ry * transformedPoint.x) / rx)
    };
    var center2 = {
      x: cos3(xRotRad) * transformedCenter.x - sin3(xRotRad) * transformedCenter.y + (x12 + x3) / 2,
      y: sin3(xRotRad) * transformedCenter.x + cos3(xRotRad) * transformedCenter.y + (y12 + y3) / 2
    };
    var startVector = {
      x: (transformedPoint.x - transformedCenter.x) / rx,
      y: (transformedPoint.y - transformedCenter.y) / ry
    };
    var startAngle = angleBetween({ x: 1, y: 0 }, startVector);
    var endVector = {
      x: (-transformedPoint.x - transformedCenter.x) / rx,
      y: (-transformedPoint.y - transformedCenter.y) / ry
    };
    var sweepAngle = angleBetween(startVector, endVector);
    if (!SF && sweepAngle > 0) {
      sweepAngle -= 2 * PI;
    } else if (SF && sweepAngle < 0) {
      sweepAngle += 2 * PI;
    }
    sweepAngle %= 2 * PI;
    var alpha = startAngle + sweepAngle * t;
    var ellipseComponentX = rx * cos3(alpha);
    var ellipseComponentY = ry * sin3(alpha);
    var point6 = {
      x: cos3(xRotRad) * ellipseComponentX - sin3(xRotRad) * ellipseComponentY + center2.x,
      y: sin3(xRotRad) * ellipseComponentX + cos3(xRotRad) * ellipseComponentY + center2.y
    };
    return point6;
  }
  function segmentArcFactory(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, distance7, options) {
    var _a;
    var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 30 : _d;
    var distanceIsNumber = typeof distance7 === "number";
    var x3 = X12;
    var y3 = Y12;
    var LENGTH = 0;
    var prev = [x3, y3, LENGTH];
    var cur = [x3, y3];
    var t = 0;
    var POINT = { x: 0, y: 0 };
    var POINTS = [{ x: x3, y: y3 }];
    if (distanceIsNumber && distance7 <= 0) {
      POINT = { x: x3, y: y3 };
    }
    for (var j = 0; j <= sampleSize; j += 1) {
      t = j / sampleSize;
      _a = getPointAtArcSegmentLength(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, t), x3 = _a.x, y3 = _a.y;
      if (bbox) {
        POINTS.push({ x: x3, y: y3 });
      }
      if (length5) {
        LENGTH += distanceSquareRoot(cur, [x3, y3]);
      }
      cur = [x3, y3];
      if (distanceIsNumber && LENGTH >= distance7 && distance7 > prev[2]) {
        var dv = (LENGTH - distance7) / (LENGTH - prev[2]);
        POINT = {
          x: cur[0] * (1 - dv) + prev[0] * dv,
          y: cur[1] * (1 - dv) + prev[1] * dv
        };
      }
      prev = [x3, y3, LENGTH];
    }
    if (distanceIsNumber && distance7 >= LENGTH) {
      POINT = { x: X22, y: Y22 };
    }
    return {
      length: LENGTH,
      point: POINT,
      min: {
        x: Math.min.apply(null, POINTS.map(function(n2) {
          return n2.x;
        })),
        y: Math.min.apply(null, POINTS.map(function(n2) {
          return n2.y;
        }))
      },
      max: {
        x: Math.max.apply(null, POINTS.map(function(n2) {
          return n2.x;
        })),
        y: Math.max.apply(null, POINTS.map(function(n2) {
          return n2.y;
        }))
      }
    };
  }

  // node_modules/@antv/util/esm/path/util/segment-cubic-factory.js
  function getPointAtCubicSegmentLength(x12, y12, c1x, c1y, c2x, c2y, x22, y22, t) {
    var t1 = 1 - t;
    return {
      x: Math.pow(t1, 3) * x12 + 3 * Math.pow(t1, 2) * t * c1x + 3 * t1 * Math.pow(t, 2) * c2x + Math.pow(t, 3) * x22,
      y: Math.pow(t1, 3) * y12 + 3 * Math.pow(t1, 2) * t * c1y + 3 * t1 * Math.pow(t, 2) * c2y + Math.pow(t, 3) * y22
    };
  }
  function segmentCubicFactory(x12, y12, c1x, c1y, c2x, c2y, x22, y22, distance7, options) {
    var _a;
    var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
    var distanceIsNumber = typeof distance7 === "number";
    var x3 = x12;
    var y3 = y12;
    var LENGTH = 0;
    var prev = [x3, y3, LENGTH];
    var cur = [x3, y3];
    var t = 0;
    var POINT = { x: 0, y: 0 };
    var POINTS = [{ x: x3, y: y3 }];
    if (distanceIsNumber && distance7 <= 0) {
      POINT = { x: x3, y: y3 };
    }
    for (var j = 0; j <= sampleSize; j += 1) {
      t = j / sampleSize;
      _a = getPointAtCubicSegmentLength(x12, y12, c1x, c1y, c2x, c2y, x22, y22, t), x3 = _a.x, y3 = _a.y;
      if (bbox) {
        POINTS.push({ x: x3, y: y3 });
      }
      if (length5) {
        LENGTH += distanceSquareRoot(cur, [x3, y3]);
      }
      cur = [x3, y3];
      if (distanceIsNumber && LENGTH >= distance7 && distance7 > prev[2]) {
        var dv = (LENGTH - distance7) / (LENGTH - prev[2]);
        POINT = {
          x: cur[0] * (1 - dv) + prev[0] * dv,
          y: cur[1] * (1 - dv) + prev[1] * dv
        };
      }
      prev = [x3, y3, LENGTH];
    }
    if (distanceIsNumber && distance7 >= LENGTH) {
      POINT = { x: x22, y: y22 };
    }
    return {
      length: LENGTH,
      point: POINT,
      min: {
        x: Math.min.apply(null, POINTS.map(function(n2) {
          return n2.x;
        })),
        y: Math.min.apply(null, POINTS.map(function(n2) {
          return n2.y;
        }))
      },
      max: {
        x: Math.max.apply(null, POINTS.map(function(n2) {
          return n2.x;
        })),
        y: Math.max.apply(null, POINTS.map(function(n2) {
          return n2.y;
        }))
      }
    };
  }

  // node_modules/@antv/util/esm/path/util/segment-quad-factory.js
  function getPointAtQuadSegmentLength(x12, y12, cx, cy, x22, y22, t) {
    var t1 = 1 - t;
    return {
      x: Math.pow(t1, 2) * x12 + 2 * t1 * t * cx + Math.pow(t, 2) * x22,
      y: Math.pow(t1, 2) * y12 + 2 * t1 * t * cy + Math.pow(t, 2) * y22
    };
  }
  function segmentQuadFactory(x12, y12, qx, qy, x22, y22, distance7, options) {
    var _a;
    var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
    var distanceIsNumber = typeof distance7 === "number";
    var x3 = x12;
    var y3 = y12;
    var LENGTH = 0;
    var prev = [x3, y3, LENGTH];
    var cur = [x3, y3];
    var t = 0;
    var POINT = { x: 0, y: 0 };
    var POINTS = [{ x: x3, y: y3 }];
    if (distanceIsNumber && distance7 <= 0) {
      POINT = { x: x3, y: y3 };
    }
    for (var j = 0; j <= sampleSize; j += 1) {
      t = j / sampleSize;
      _a = getPointAtQuadSegmentLength(x12, y12, qx, qy, x22, y22, t), x3 = _a.x, y3 = _a.y;
      if (bbox) {
        POINTS.push({ x: x3, y: y3 });
      }
      if (length5) {
        LENGTH += distanceSquareRoot(cur, [x3, y3]);
      }
      cur = [x3, y3];
      if (distanceIsNumber && LENGTH >= distance7 && distance7 > prev[2]) {
        var dv = (LENGTH - distance7) / (LENGTH - prev[2]);
        POINT = {
          x: cur[0] * (1 - dv) + prev[0] * dv,
          y: cur[1] * (1 - dv) + prev[1] * dv
        };
      }
      prev = [x3, y3, LENGTH];
    }
    if (distanceIsNumber && distance7 >= LENGTH) {
      POINT = { x: x22, y: y22 };
    }
    return {
      length: LENGTH,
      point: POINT,
      min: {
        x: Math.min.apply(null, POINTS.map(function(n2) {
          return n2.x;
        })),
        y: Math.min.apply(null, POINTS.map(function(n2) {
          return n2.y;
        }))
      },
      max: {
        x: Math.max.apply(null, POINTS.map(function(n2) {
          return n2.x;
        })),
        y: Math.max.apply(null, POINTS.map(function(n2) {
          return n2.y;
        }))
      }
    };
  }

  // node_modules/@antv/util/esm/path/util/path-length-factory.js
  function pathLengthFactory(pathInput, distance7, options) {
    var _a, _b, _c, _d, _e, _f;
    var path2 = normalizePath(pathInput);
    var distanceIsNumber = typeof distance7 === "number";
    var isM;
    var data2 = [];
    var pathCommand;
    var x3 = 0;
    var y3 = 0;
    var mx = 0;
    var my = 0;
    var seg;
    var MIN = [];
    var MAX = [];
    var length5 = 0;
    var min10 = { x: 0, y: 0 };
    var max11 = min10;
    var point6 = min10;
    var POINT = min10;
    var LENGTH = 0;
    for (var i = 0, ll = path2.length; i < ll; i += 1) {
      seg = path2[i];
      pathCommand = seg[0];
      isM = pathCommand === "M";
      data2 = !isM ? [x3, y3].concat(seg.slice(1)) : data2;
      if (isM) {
        mx = seg[1], my = seg[2];
        min10 = { x: mx, y: my };
        max11 = min10;
        length5 = 0;
        if (distanceIsNumber && distance7 < 1e-3) {
          POINT = min10;
        }
      } else if (pathCommand === "L") {
        _a = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance7 || 0) - LENGTH), length5 = _a.length, min10 = _a.min, max11 = _a.max, point6 = _a.point;
      } else if (pathCommand === "A") {
        _b = segmentArcFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], data2[8], (distance7 || 0) - LENGTH, options || {}), length5 = _b.length, min10 = _b.min, max11 = _b.max, point6 = _b.point;
      } else if (pathCommand === "C") {
        _c = segmentCubicFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], (distance7 || 0) - LENGTH, options || {}), length5 = _c.length, min10 = _c.min, max11 = _c.max, point6 = _c.point;
      } else if (pathCommand === "Q") {
        _d = segmentQuadFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], (distance7 || 0) - LENGTH, options || {}), length5 = _d.length, min10 = _d.min, max11 = _d.max, point6 = _d.point;
      } else if (pathCommand === "Z") {
        data2 = [x3, y3, mx, my];
        _e = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance7 || 0) - LENGTH), length5 = _e.length, min10 = _e.min, max11 = _e.max, point6 = _e.point;
      }
      if (distanceIsNumber && LENGTH < distance7 && LENGTH + length5 >= distance7) {
        POINT = point6;
      }
      MAX.push(max11);
      MIN.push(min10);
      LENGTH += length5;
      _f = pathCommand !== "Z" ? seg.slice(-2) : [mx, my], x3 = _f[0], y3 = _f[1];
    }
    if (distanceIsNumber && distance7 >= LENGTH) {
      POINT = { x: x3, y: y3 };
    }
    return {
      length: LENGTH,
      point: POINT,
      min: {
        x: Math.min.apply(null, MIN.map(function(n2) {
          return n2.x;
        })),
        y: Math.min.apply(null, MIN.map(function(n2) {
          return n2.y;
        }))
      },
      max: {
        x: Math.max.apply(null, MAX.map(function(n2) {
          return n2.x;
        })),
        y: Math.max.apply(null, MAX.map(function(n2) {
          return n2.y;
        }))
      }
    };
  }

  // node_modules/@antv/util/esm/path/util/get-total-length.js
  function getTotalLength(pathInput, options) {
    return pathLengthFactory(pathInput, void 0, __assign(__assign({}, options), { bbox: false, length: true })).length;
  }

  // node_modules/@antv/util/esm/path/util/get-rotated-curve.js
  function getRotations(a3) {
    var segCount = a3.length;
    var pointCount = segCount - 1;
    return a3.map(function(f, idx) {
      return a3.map(function(p2, i) {
        var oldSegIdx = idx + i;
        var seg;
        if (i === 0 || a3[oldSegIdx] && a3[oldSegIdx][0] === "M") {
          seg = a3[oldSegIdx];
          return ["M"].concat(seg.slice(-2));
        }
        if (oldSegIdx >= segCount)
          oldSegIdx -= pointCount;
        return a3[oldSegIdx];
      });
    });
  }
  function getRotatedCurve(a3, b) {
    var segCount = a3.length - 1;
    var lineLengths = [];
    var computedIndex = 0;
    var sumLensSqrd = 0;
    var rotations = getRotations(a3);
    rotations.forEach(function(r, i) {
      a3.slice(1).forEach(function(s3, j) {
        sumLensSqrd += distanceSquareRoot(a3[(i + j) % segCount].slice(-2), b[j % segCount].slice(-2));
      });
      lineLengths[i] = sumLensSqrd;
      sumLensSqrd = 0;
    });
    computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
    return rotations[computedIndex];
  }

  // node_modules/@antv/util/esm/path/util/get-path-area.js
  function getCubicSegArea(x12, y12, c1x, c1y, c2x, c2y, x22, y22) {
    return 3 * ((y22 - y12) * (c1x + c2x) - (x22 - x12) * (c1y + c2y) + c1y * (x12 - c2x) - c1x * (y12 - c2y) + y22 * (c2x + x12 / 3) - x22 * (c2y + y12 / 3)) / 20;
  }
  function getPathArea(path2) {
    var x3 = 0;
    var y3 = 0;
    var len5 = 0;
    return path2Curve(path2).map(function(seg) {
      var _a;
      switch (seg[0]) {
        case "M":
          x3 = seg[1], y3 = seg[2];
          return 0;
        default:
          var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x22 = _b[4], y22 = _b[5];
          len5 = getCubicSegArea(x3, y3, c1x, c1y, c2x, c2y, x22, y22);
          _a = seg.slice(-2), x3 = _a[0], y3 = _a[1];
          return len5;
      }
    }).reduce(function(a3, b) {
      return a3 + b;
    }, 0);
  }

  // node_modules/@antv/util/esm/path/util/get-draw-direction.js
  function getDrawDirection(pathArray) {
    return getPathArea(pathArray) >= 0;
  }

  // node_modules/@antv/util/esm/path/util/get-point-at-length.js
  function getPointAtLength(pathInput, distance7, options) {
    return pathLengthFactory(pathInput, distance7, __assign(__assign({}, options), { bbox: false, length: true })).point;
  }

  // node_modules/@antv/util/esm/path/util/equalize-segments.js
  function splitCubic(pts, t) {
    if (t === void 0) {
      t = 0.5;
    }
    var p0 = pts.slice(0, 2);
    var p1 = pts.slice(2, 4);
    var p2 = pts.slice(4, 6);
    var p3 = pts.slice(6, 8);
    var p4 = midPoint(p0, p1, t);
    var p5 = midPoint(p1, p2, t);
    var p6 = midPoint(p2, p3, t);
    var p7 = midPoint(p4, p5, t);
    var p8 = midPoint(p5, p6, t);
    var p9 = midPoint(p7, p8, t);
    return [
      // @ts-ignore
      ["C"].concat(p4, p7, p9),
      // @ts-ignore
      ["C"].concat(p8, p6, p3)
    ];
  }
  function getCurveArray(segments) {
    return segments.map(function(segment, i, pathArray) {
      var segmentData = i && pathArray[i - 1].slice(-2).concat(segment.slice(1));
      var curveLength = i ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length : 0;
      var subsegs;
      if (i) {
        subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
      } else {
        subsegs = [segment];
      }
      return {
        s: segment,
        ss: subsegs,
        l: curveLength
      };
    });
  }
  function equalizeSegments(path1, path2, TL) {
    var c1 = getCurveArray(path1);
    var c22 = getCurveArray(path2);
    var L1 = c1.length;
    var L2 = c22.length;
    var l1 = c1.filter(function(x3) {
      return x3.l;
    }).length;
    var l2 = c22.filter(function(x3) {
      return x3.l;
    }).length;
    var m1 = c1.filter(function(x3) {
      return x3.l;
    }).reduce(function(a3, _a) {
      var l3 = _a.l;
      return a3 + l3;
    }, 0) / l1 || 0;
    var m22 = c22.filter(function(x3) {
      return x3.l;
    }).reduce(function(a3, _a) {
      var l3 = _a.l;
      return a3 + l3;
    }, 0) / l2 || 0;
    var tl = TL || Math.max(L1, L2);
    var mm = [m1, m22];
    var dif = [tl - L1, tl - L2];
    var canSplit = 0;
    var result = [c1, c22].map(function(x3, i) {
      return x3.l === tl ? x3.map(function(y3) {
        return y3.s;
      }) : x3.map(function(y3, j) {
        canSplit = j && dif[i] && y3.l >= mm[i];
        dif[i] -= canSplit ? 1 : 0;
        return canSplit ? y3.ss : [y3.s];
      }).flat();
    });
    return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl);
  }

  // node_modules/@antv/util/esm/dom/create-dom.js
  function createDOM(str7) {
    var container = document.createElement("div");
    container.innerHTML = str7;
    var dom2 = container.childNodes[0];
    if (dom2 && container.contains(dom2)) {
      container.removeChild(dom2);
    }
    return dom2;
  }

  // node_modules/@antv/g2/esm/transform/utils/helper.js
  function column(value2, field3) {
    if (value2 === null)
      return void 0;
    return { type: "column", value: value2, field: field3 };
  }
  function inferredColumn(value2, field3) {
    const c5 = column(value2, field3);
    return Object.assign(Object.assign({}, c5), { inferred: true });
  }
  function visualColumn(value2, field3) {
    if (value2 === null)
      return void 0;
    return { type: "column", value: value2, field: field3, visual: true };
  }
  function nonConstantColumn(value2, field3) {
    const c5 = column(value2, field3);
    return Object.assign(Object.assign({}, c5), { constant: false });
  }
  function constant(I, value2) {
    const array2 = [];
    for (const i of I)
      array2[i] = value2;
    return array2;
  }
  function columnOf(encode, key) {
    const channel = encode[key];
    if (!channel)
      return [null, null];
    const { value: value2, field: field3 = null } = channel;
    return [value2, field3];
  }
  function maybeColumnOf(encode, ...K) {
    for (const key of K) {
      if (typeof key === "string") {
        const [KV, fv] = columnOf(encode, key);
        if (KV !== null)
          return [KV, fv];
      } else {
        return [key, null];
      }
    }
    return [null, null];
  }
  function isObject(d3) {
    if (d3 instanceof Date)
      return false;
    return typeof d3 === "object";
  }

  // node_modules/@antv/g2/esm/transform/maybeZeroY1.js
  var MaybeZeroY1 = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { y1: y12 } = encode;
      if (y12 !== void 0)
        return [I, mark];
      return [
        I,
        deep_mix_default({}, mark, {
          encode: { y1: inferredColumn(constant(I, 0)) }
        })
      ];
    };
  };
  MaybeZeroY1.props = {};

  // node_modules/d3-array/src/ascending.js
  function ascending(a3, b) {
    return a3 == null || b == null ? NaN : a3 < b ? -1 : a3 > b ? 1 : a3 >= b ? 0 : NaN;
  }

  // node_modules/d3-array/src/descending.js
  function descending(a3, b) {
    return a3 == null || b == null ? NaN : b < a3 ? -1 : b > a3 ? 1 : b >= a3 ? 0 : NaN;
  }

  // node_modules/d3-array/src/bisector.js
  function bisector(f) {
    let compare1, compare2, delta;
    if (f.length !== 2) {
      compare1 = ascending;
      compare2 = (d3, x3) => ascending(f(d3), x3);
      delta = (d3, x3) => f(d3) - x3;
    } else {
      compare1 = f === ascending || f === descending ? f : zero4;
      compare2 = f;
      delta = f;
    }
    function left2(a3, x3, lo = 0, hi = a3.length) {
      if (lo < hi) {
        if (compare1(x3, x3) !== 0) return hi;
        do {
          const mid2 = lo + hi >>> 1;
          if (compare2(a3[mid2], x3) < 0) lo = mid2 + 1;
          else hi = mid2;
        } while (lo < hi);
      }
      return lo;
    }
    function right2(a3, x3, lo = 0, hi = a3.length) {
      if (lo < hi) {
        if (compare1(x3, x3) !== 0) return hi;
        do {
          const mid2 = lo + hi >>> 1;
          if (compare2(a3[mid2], x3) <= 0) lo = mid2 + 1;
          else hi = mid2;
        } while (lo < hi);
      }
      return lo;
    }
    function center2(a3, x3, lo = 0, hi = a3.length) {
      const i = left2(a3, x3, lo, hi - 1);
      return i > lo && delta(a3[i - 1], x3) > -delta(a3[i], x3) ? i - 1 : i;
    }
    return { left: left2, center: center2, right: right2 };
  }
  function zero4() {
    return 0;
  }

  // node_modules/d3-array/src/number.js
  function number(x3) {
    return x3 === null ? NaN : +x3;
  }
  function* numbers(values, valueof2) {
    if (valueof2 === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          yield value2;
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (value2 = +value2) >= value2) {
          yield value2;
        }
      }
    }
  }

  // node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;
  var bisectCenter = bisector(number).center;
  var bisect_default = bisectRight;

  // node_modules/d3-array/src/count.js
  function count(values, valueof2) {
    let count4 = 0;
    if (valueof2 === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          ++count4;
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (value2 = +value2) >= value2) {
          ++count4;
        }
      }
    }
    return count4;
  }

  // node_modules/d3-array/src/variance.js
  function variance(values, valueof2) {
    let count4 = 0;
    let delta;
    let mean3 = 0;
    let sum3 = 0;
    if (valueof2 === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          delta = value2 - mean3;
          mean3 += delta / ++count4;
          sum3 += delta * (value2 - mean3);
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (value2 = +value2) >= value2) {
          delta = value2 - mean3;
          mean3 += delta / ++count4;
          sum3 += delta * (value2 - mean3);
        }
      }
    }
    if (count4 > 1) return sum3 / (count4 - 1);
  }

  // node_modules/d3-array/src/deviation.js
  function deviation(values, valueof2) {
    const v = variance(values, valueof2);
    return v ? Math.sqrt(v) : v;
  }

  // node_modules/d3-array/src/extent.js
  function extent(values, valueof2) {
    let min10;
    let max11;
    if (valueof2 === void 0) {
      for (const value2 of values) {
        if (value2 != null) {
          if (min10 === void 0) {
            if (value2 >= value2) min10 = max11 = value2;
          } else {
            if (min10 > value2) min10 = value2;
            if (max11 < value2) max11 = value2;
          }
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null) {
          if (min10 === void 0) {
            if (value2 >= value2) min10 = max11 = value2;
          } else {
            if (min10 > value2) min10 = value2;
            if (max11 < value2) max11 = value2;
          }
        }
      }
    }
    return [min10, max11];
  }

  // node_modules/d3-array/src/fsum.js
  var Adder = class {
    constructor() {
      this._partials = new Float64Array(32);
      this._n = 0;
    }
    add(x3) {
      const p2 = this._partials;
      let i = 0;
      for (let j = 0; j < this._n && j < 32; j++) {
        const y3 = p2[j], hi = x3 + y3, lo = Math.abs(x3) < Math.abs(y3) ? x3 - (hi - y3) : y3 - (hi - x3);
        if (lo) p2[i++] = lo;
        x3 = hi;
      }
      p2[i] = x3;
      this._n = i + 1;
      return this;
    }
    valueOf() {
      const p2 = this._partials;
      let n2 = this._n, x3, y3, lo, hi = 0;
      if (n2 > 0) {
        hi = p2[--n2];
        while (n2 > 0) {
          x3 = hi;
          y3 = p2[--n2];
          hi = x3 + y3;
          lo = y3 - (hi - x3);
          if (lo) break;
        }
        if (n2 > 0 && (lo < 0 && p2[n2 - 1] < 0 || lo > 0 && p2[n2 - 1] > 0)) {
          y3 = lo * 2;
          x3 = hi + y3;
          if (y3 == x3 - hi) hi = x3;
        }
      }
      return hi;
    }
  };

  // node_modules/internmap/src/index.js
  var InternMap = class extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null) for (const [key2, value2] of entries) this.set(key2, value2);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value2) {
      return super.set(intern_set(this, key), value2);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  };
  function intern_get({ _intern, _key }, value2) {
    const key = _key(value2);
    return _intern.has(key) ? _intern.get(key) : value2;
  }
  function intern_set({ _intern, _key }, value2) {
    const key = _key(value2);
    if (_intern.has(key)) return _intern.get(key);
    _intern.set(key, value2);
    return value2;
  }
  function intern_delete({ _intern, _key }, value2) {
    const key = _key(value2);
    if (_intern.has(key)) {
      value2 = _intern.get(key);
      _intern.delete(key);
    }
    return value2;
  }
  function keyof(value2) {
    return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
  }

  // node_modules/d3-array/src/identity.js
  function identity4(x3) {
    return x3;
  }

  // node_modules/d3-array/src/group.js
  function group(values, ...keys2) {
    return nest(values, identity4, identity4, keys2);
  }
  function groups(values, ...keys2) {
    return nest(values, Array.from, identity4, keys2);
  }
  function rollup(values, reduce2, ...keys2) {
    return nest(values, identity4, reduce2, keys2);
  }
  function rollups(values, reduce2, ...keys2) {
    return nest(values, Array.from, reduce2, keys2);
  }
  function nest(values, map3, reduce2, keys2) {
    return function regroup(values2, i) {
      if (i >= keys2.length) return reduce2(values2);
      const groups2 = new InternMap();
      const keyof3 = keys2[i++];
      let index4 = -1;
      for (const value2 of values2) {
        const key = keyof3(value2, ++index4, values2);
        const group3 = groups2.get(key);
        if (group3) group3.push(value2);
        else groups2.set(key, [value2]);
      }
      for (const [key, values3] of groups2) {
        groups2.set(key, regroup(values3, i));
      }
      return map3(groups2);
    }(values, 0);
  }

  // node_modules/d3-array/src/permute.js
  function permute(source, keys2) {
    return Array.from(keys2, (key) => source[key]);
  }

  // node_modules/d3-array/src/sort.js
  function sort2(values, ...F) {
    if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    values = Array.from(values);
    let [f] = F;
    if (f && f.length !== 2 || F.length > 1) {
      const index4 = Uint32Array.from(values, (d3, i) => i);
      if (F.length > 1) {
        F = F.map((f2) => values.map(f2));
        index4.sort((i, j) => {
          for (const f2 of F) {
            const c5 = ascendingDefined(f2[i], f2[j]);
            if (c5) return c5;
          }
        });
      } else {
        f = values.map(f);
        index4.sort((i, j) => ascendingDefined(f[i], f[j]));
      }
      return permute(values, index4);
    }
    return values.sort(compareDefined(f));
  }
  function compareDefined(compare = ascending) {
    if (compare === ascending) return ascendingDefined;
    if (typeof compare !== "function") throw new TypeError("compare is not a function");
    return (a3, b) => {
      const x3 = compare(a3, b);
      if (x3 || x3 === 0) return x3;
      return (compare(b, b) === 0) - (compare(a3, a3) === 0);
    };
  }
  function ascendingDefined(a3, b) {
    return (a3 == null || !(a3 >= a3)) - (b == null || !(b >= b)) || (a3 < b ? -1 : a3 > b ? 1 : 0);
  }

  // node_modules/d3-array/src/groupSort.js
  function groupSort(values, reduce2, key) {
    return (reduce2.length !== 2 ? sort2(rollup(values, reduce2, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort2(group(values, key), ([ak, av], [bk, bv]) => reduce2(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
  }

  // node_modules/d3-array/src/array.js
  var array = Array.prototype;
  var slice = array.slice;
  var map = array.map;

  // node_modules/d3-array/src/constant.js
  function constant2(x3) {
    return () => x3;
  }

  // node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function tickSpec(start2, stop, count4) {
    const step2 = (stop - start2) / Math.max(0, count4), power = Math.floor(Math.log10(step2)), error4 = step2 / Math.pow(10, power), factor = error4 >= e10 ? 10 : error4 >= e5 ? 5 : error4 >= e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
      inc = Math.pow(10, -power) / factor;
      i1 = Math.round(start2 * inc);
      i2 = Math.round(stop * inc);
      if (i1 / inc < start2) ++i1;
      if (i2 / inc > stop) --i2;
      inc = -inc;
    } else {
      inc = Math.pow(10, power) * factor;
      i1 = Math.round(start2 / inc);
      i2 = Math.round(stop / inc);
      if (i1 * inc < start2) ++i1;
      if (i2 * inc > stop) --i2;
    }
    if (i2 < i1 && 0.5 <= count4 && count4 < 2) return tickSpec(start2, stop, count4 * 2);
    return [i1, i2, inc];
  }
  function ticks(start2, stop, count4) {
    stop = +stop, start2 = +start2, count4 = +count4;
    if (!(count4 > 0)) return [];
    if (start2 === stop) return [start2];
    const reverse = stop < start2, [i1, i2, inc] = reverse ? tickSpec(stop, start2, count4) : tickSpec(start2, stop, count4);
    if (!(i2 >= i1)) return [];
    const n2 = i2 - i1 + 1, ticks2 = new Array(n2);
    if (reverse) {
      if (inc < 0) for (let i = 0; i < n2; ++i) ticks2[i] = (i2 - i) / -inc;
      else for (let i = 0; i < n2; ++i) ticks2[i] = (i2 - i) * inc;
    } else {
      if (inc < 0) for (let i = 0; i < n2; ++i) ticks2[i] = (i1 + i) / -inc;
      else for (let i = 0; i < n2; ++i) ticks2[i] = (i1 + i) * inc;
    }
    return ticks2;
  }
  function tickIncrement(start2, stop, count4) {
    stop = +stop, start2 = +start2, count4 = +count4;
    return tickSpec(start2, stop, count4)[2];
  }

  // node_modules/d3-array/src/nice.js
  function nice(start2, stop, count4) {
    let prestep;
    while (true) {
      const step2 = tickIncrement(start2, stop, count4);
      if (step2 === prestep || step2 === 0 || !isFinite(step2)) {
        return [start2, stop];
      } else if (step2 > 0) {
        start2 = Math.floor(start2 / step2) * step2;
        stop = Math.ceil(stop / step2) * step2;
      } else if (step2 < 0) {
        start2 = Math.ceil(start2 * step2) / step2;
        stop = Math.floor(stop * step2) / step2;
      }
      prestep = step2;
    }
  }

  // node_modules/d3-array/src/threshold/sturges.js
  function thresholdSturges(values) {
    return Math.max(1, Math.ceil(Math.log(count(values)) / Math.LN2) + 1);
  }

  // node_modules/d3-array/src/bin.js
  function bin() {
    var value2 = identity4, domain = extent, threshold = thresholdSturges;
    function histogram(data2) {
      if (!Array.isArray(data2)) data2 = Array.from(data2);
      var i, n2 = data2.length, x3, step2, values = new Array(n2);
      for (i = 0; i < n2; ++i) {
        values[i] = value2(data2[i], i, data2);
      }
      var xz = domain(values), x05 = xz[0], x12 = xz[1], tz = threshold(values, x05, x12);
      if (!Array.isArray(tz)) {
        const max11 = x12, tn = +tz;
        if (domain === extent) [x05, x12] = nice(x05, x12, tn);
        tz = ticks(x05, x12, tn);
        if (tz[0] <= x05) step2 = tickIncrement(x05, x12, tn);
        if (tz[tz.length - 1] >= x12) {
          if (max11 >= x12 && domain === extent) {
            const step3 = tickIncrement(x05, x12, tn);
            if (isFinite(step3)) {
              if (step3 > 0) {
                x12 = (Math.floor(x12 / step3) + 1) * step3;
              } else if (step3 < 0) {
                x12 = (Math.ceil(x12 * -step3) + 1) / -step3;
              }
            }
          } else {
            tz.pop();
          }
        }
      }
      var m3 = tz.length, a3 = 0, b = m3;
      while (tz[a3] <= x05) ++a3;
      while (tz[b - 1] > x12) --b;
      if (a3 || b < m3) tz = tz.slice(a3, b), m3 = b - a3;
      var bins = new Array(m3 + 1), bin2;
      for (i = 0; i <= m3; ++i) {
        bin2 = bins[i] = [];
        bin2.x0 = i > 0 ? tz[i - 1] : x05;
        bin2.x1 = i < m3 ? tz[i] : x12;
      }
      if (isFinite(step2)) {
        if (step2 > 0) {
          for (i = 0; i < n2; ++i) {
            if ((x3 = values[i]) != null && x05 <= x3 && x3 <= x12) {
              bins[Math.min(m3, Math.floor((x3 - x05) / step2))].push(data2[i]);
            }
          }
        } else if (step2 < 0) {
          for (i = 0; i < n2; ++i) {
            if ((x3 = values[i]) != null && x05 <= x3 && x3 <= x12) {
              const j = Math.floor((x05 - x3) * step2);
              bins[Math.min(m3, j + (tz[j] <= x3))].push(data2[i]);
            }
          }
        }
      } else {
        for (i = 0; i < n2; ++i) {
          if ((x3 = values[i]) != null && x05 <= x3 && x3 <= x12) {
            bins[bisect_default(tz, x3, 0, m3)].push(data2[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(_2) {
      return arguments.length ? (value2 = typeof _2 === "function" ? _2 : constant2(_2), histogram) : value2;
    };
    histogram.domain = function(_2) {
      return arguments.length ? (domain = typeof _2 === "function" ? _2 : constant2([_2[0], _2[1]]), histogram) : domain;
    };
    histogram.thresholds = function(_2) {
      return arguments.length ? (threshold = typeof _2 === "function" ? _2 : constant2(Array.isArray(_2) ? slice.call(_2) : _2), histogram) : threshold;
    };
    return histogram;
  }

  // node_modules/d3-array/src/max.js
  function max5(values, valueof2) {
    let max11;
    if (valueof2 === void 0) {
      for (const value2 of values) {
        if (value2 != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
          max11 = value2;
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
          max11 = value2;
        }
      }
    }
    return max11;
  }

  // node_modules/d3-array/src/maxIndex.js
  function maxIndex(values, valueof2) {
    let max11;
    let maxIndex2 = -1;
    let index4 = -1;
    if (valueof2 === void 0) {
      for (const value2 of values) {
        ++index4;
        if (value2 != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
          max11 = value2, maxIndex2 = index4;
        }
      }
    } else {
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (max11 < value2 || max11 === void 0 && value2 >= value2)) {
          max11 = value2, maxIndex2 = index4;
        }
      }
    }
    return maxIndex2;
  }

  // node_modules/d3-array/src/min.js
  function min4(values, valueof2) {
    let min10;
    if (valueof2 === void 0) {
      for (const value2 of values) {
        if (value2 != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
          min10 = value2;
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
          min10 = value2;
        }
      }
    }
    return min10;
  }

  // node_modules/d3-array/src/minIndex.js
  function minIndex(values, valueof2) {
    let min10;
    let minIndex2 = -1;
    let index4 = -1;
    if (valueof2 === void 0) {
      for (const value2 of values) {
        ++index4;
        if (value2 != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
          min10 = value2, minIndex2 = index4;
        }
      }
    } else {
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
          min10 = value2, minIndex2 = index4;
        }
      }
    }
    return minIndex2;
  }

  // node_modules/d3-array/src/quickselect.js
  function quickselect(array2, k, left2 = 0, right2 = Infinity, compare) {
    k = Math.floor(k);
    left2 = Math.floor(Math.max(0, left2));
    right2 = Math.floor(Math.min(array2.length - 1, right2));
    if (!(left2 <= k && k <= right2)) return array2;
    compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
    while (right2 > left2) {
      if (right2 - left2 > 600) {
        const n2 = right2 - left2 + 1;
        const m3 = k - left2 + 1;
        const z = Math.log(n2);
        const s3 = 0.5 * Math.exp(2 * z / 3);
        const sd = 0.5 * Math.sqrt(z * s3 * (n2 - s3) / n2) * (m3 - n2 / 2 < 0 ? -1 : 1);
        const newLeft = Math.max(left2, Math.floor(k - m3 * s3 / n2 + sd));
        const newRight = Math.min(right2, Math.floor(k + (n2 - m3) * s3 / n2 + sd));
        quickselect(array2, k, newLeft, newRight, compare);
      }
      const t = array2[k];
      let i = left2;
      let j = right2;
      swap(array2, left2, k);
      if (compare(array2[right2], t) > 0) swap(array2, left2, right2);
      while (i < j) {
        swap(array2, i, j), ++i, --j;
        while (compare(array2[i], t) < 0) ++i;
        while (compare(array2[j], t) > 0) --j;
      }
      if (compare(array2[left2], t) === 0) swap(array2, left2, j);
      else ++j, swap(array2, j, right2);
      if (j <= k) left2 = j + 1;
      if (k <= j) right2 = j - 1;
    }
    return array2;
  }
  function swap(array2, i, j) {
    const t = array2[i];
    array2[i] = array2[j];
    array2[j] = t;
  }

  // node_modules/d3-array/src/greatest.js
  function greatest(values, compare = ascending) {
    let max11;
    let defined4 = false;
    if (compare.length === 1) {
      let maxValue;
      for (const element of values) {
        const value2 = compare(element);
        if (defined4 ? ascending(value2, maxValue) > 0 : ascending(value2, value2) === 0) {
          max11 = element;
          maxValue = value2;
          defined4 = true;
        }
      }
    } else {
      for (const value2 of values) {
        if (defined4 ? compare(value2, max11) > 0 : compare(value2, value2) === 0) {
          max11 = value2;
          defined4 = true;
        }
      }
    }
    return max11;
  }

  // node_modules/d3-array/src/quantile.js
  function quantile(values, p2, valueof2) {
    values = Float64Array.from(numbers(values, valueof2));
    if (!(n2 = values.length) || isNaN(p2 = +p2)) return;
    if (p2 <= 0 || n2 < 2) return min4(values);
    if (p2 >= 1) return max5(values);
    var n2, i = (n2 - 1) * p2, i0 = Math.floor(i), value0 = max5(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min4(values.subarray(i0 + 1));
    return value0 + (value1 - value0) * (i - i0);
  }
  function quantileIndex(values, p2, valueof2 = number) {
    if (isNaN(p2 = +p2)) return;
    numbers2 = Float64Array.from(values, (_2, i2) => number(valueof2(values[i2], i2, values)));
    if (p2 <= 0) return minIndex(numbers2);
    if (p2 >= 1) return maxIndex(numbers2);
    var numbers2, index4 = Uint32Array.from(values, (_2, i2) => i2), j = numbers2.length - 1, i = Math.floor(j * p2);
    quickselect(index4, i, 0, j, (i2, j2) => ascendingDefined(numbers2[i2], numbers2[j2]));
    i = greatest(index4.subarray(0, i + 1), (i2) => numbers2[i2]);
    return i >= 0 ? i : -1;
  }

  // node_modules/d3-array/src/threshold/scott.js
  function thresholdScott(values, min10, max11) {
    const c5 = count(values), d3 = deviation(values);
    return c5 && d3 ? Math.ceil((max11 - min10) * Math.cbrt(c5) / (3.49 * d3)) : 1;
  }

  // node_modules/d3-array/src/mean.js
  function mean(values, valueof2) {
    let count4 = 0;
    let sum3 = 0;
    if (valueof2 === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          ++count4, sum3 += value2;
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (value2 = +value2) >= value2) {
          ++count4, sum3 += value2;
        }
      }
    }
    if (count4) return sum3 / count4;
  }

  // node_modules/d3-array/src/median.js
  function median(values, valueof2) {
    return quantile(values, 0.5, valueof2);
  }
  function medianIndex(values, valueof2) {
    return quantileIndex(values, 0.5, valueof2);
  }

  // node_modules/d3-array/src/merge.js
  function* flatten(arrays) {
    for (const array2 of arrays) {
      yield* array2;
    }
  }
  function merge(arrays) {
    return Array.from(flatten(arrays));
  }

  // node_modules/d3-array/src/range.js
  function range(start2, stop, step2) {
    start2 = +start2, stop = +stop, step2 = (n2 = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n2 < 3 ? 1 : +step2;
    var i = -1, n2 = Math.max(0, Math.ceil((stop - start2) / step2)) | 0, range3 = new Array(n2);
    while (++i < n2) {
      range3[i] = start2 + i * step2;
    }
    return range3;
  }

  // node_modules/d3-array/src/sum.js
  function sum(values, valueof2) {
    let sum3 = 0;
    if (valueof2 === void 0) {
      for (let value2 of values) {
        if (value2 = +value2) {
          sum3 += value2;
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if (value2 = +valueof2(value2, ++index4, values)) {
          sum3 += value2;
        }
      }
    }
    return sum3;
  }

  // node_modules/@antv/g2/esm/utils/helper.js
  var __awaiter = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function identity5(x3) {
    return x3;
  }
  function compose(fns) {
    return fns.reduce((composed, fn) => (x3, ...args) => fn(composed(x3, ...args), ...args), identity5);
  }
  function composeAsync(fns) {
    return fns.reduce((composed, fn) => (x3) => __awaiter(this, void 0, void 0, function* () {
      const value2 = yield composed(x3);
      return fn(value2);
    }), identity5);
  }
  function capitalizeFirst(str7) {
    return str7.replace(/( |^)[a-z]/g, (L) => L.toUpperCase());
  }
  function error2(message = "") {
    throw new Error(message);
  }
  function copyAttributes(target, source) {
    const { attributes } = source;
    const exclude = /* @__PURE__ */ new Set(["id", "className"]);
    for (const [key, value2] of Object.entries(attributes)) {
      if (!exclude.has(key)) {
        target.attr(key, value2);
      }
    }
  }
  function defined(x3) {
    return x3 !== void 0 && x3 !== null && !Number.isNaN(x3);
  }
  function useMemo(compute2) {
    const map3 = /* @__PURE__ */ new Map();
    return (key) => {
      if (map3.has(key))
        return map3.get(key);
      const value2 = compute2(key);
      map3.set(key, value2);
      return value2;
    };
  }
  function appendTransform(node, transform) {
    const { transform: preTransform } = node.style;
    const unset = (d3) => d3 === "none" || d3 === void 0;
    const prefix = unset(preTransform) ? "" : preTransform;
    node.style.transform = `${prefix} ${transform}`.trimStart();
  }
  function subObject(obj, prefix) {
    return maybeSubObject(obj, prefix) || {};
  }
  function maybeSubObject(obj, prefix) {
    const entries = Object.entries(obj || {}).filter(([key]) => key.startsWith(prefix)).map(([key, value2]) => [lower_first_default(key.replace(prefix, "").trim()), value2]).filter(([key]) => !!key);
    return entries.length === 0 ? null : Object.fromEntries(entries);
  }
  function filterPrefixObject(obj, prefix) {
    return Object.fromEntries(Object.entries(obj).filter(([key]) => prefix.find((p2) => key.startsWith(p2))));
  }
  function omitPrefixObject(obj, ...prefixes2) {
    return Object.fromEntries(Object.entries(obj).filter(([key]) => prefixes2.every((prefix) => !key.startsWith(prefix))));
  }
  function maybePercentage(x3, size2) {
    if (x3 === void 0)
      return null;
    if (typeof x3 === "number")
      return x3;
    const px2 = +x3.replace("%", "");
    return Number.isNaN(px2) ? null : px2 / 100 * size2;
  }
  function isStrictObject(d3) {
    return typeof d3 === "object" && !(d3 instanceof Date) && d3 !== null && !Array.isArray(d3);
  }
  function isUnset(value2) {
    return value2 === null || value2 === false;
  }
  function deepAssign(dist5, src, maxLevel = 5, level = 0) {
    if (level >= maxLevel)
      return;
    for (const key of Object.keys(src)) {
      const value2 = src[key];
      if (!is_plain_object_default(value2) || !is_plain_object_default(dist5[key])) {
        dist5[key] = value2;
      } else {
        deepAssign(dist5[key], value2, maxLevel, level + 1);
      }
    }
    return dist5;
  }

  // node_modules/@antv/g2/esm/utils/array.js
  function mapObject(object, callbackfn) {
    return Object.entries(object).reduce((obj, [key, value2]) => {
      obj[key] = callbackfn(value2, key, object);
      return obj;
    }, {});
  }
  function indexOf3(array2) {
    return array2.map((_2, i) => i);
  }
  function firstOf(array2) {
    return array2[0];
  }
  function lastOf(array2) {
    return array2[array2.length - 1];
  }
  function unique(array2) {
    return Array.from(new Set(array2));
  }
  function divide4(array2, callbackfn) {
    const result = [[], []];
    array2.forEach((item) => {
      result[callbackfn(item) ? 0 : 1].push(item);
    });
    return result;
  }
  function comb(array2, len5 = array2.length) {
    if (len5 === 1)
      return array2.map((item) => [item]);
    const result = [];
    for (let i = 0; i < array2.length; i++) {
      const rest = array2.slice(i + 1);
      const restComb = comb(rest, len5 - 1);
      restComb.forEach((comb2) => {
        result.push([array2[i], ...comb2]);
      });
    }
    return result;
  }
  function combine(array2) {
    if (array2.length === 1)
      return [array2];
    const result = [];
    for (let i = 1; i <= array2.length; i++) {
      result.push(...comb(array2, i));
    }
    return result;
  }

  // node_modules/@antv/g2/esm/transform/utils/order.js
  function createGroups(groupBy2, I, mark) {
    const { encode } = mark;
    if (groupBy2 === null)
      return [I];
    const G = normalizeGroupBy(groupBy2).map((k) => {
      var _a;
      return [k, (_a = columnOf(encode, k)) === null || _a === void 0 ? void 0 : _a[0]];
    }).filter(([, column2]) => defined(column2));
    const key = (i) => G.map(([, V]) => V[i]).join("-");
    return Array.from(group(I, key).values());
  }
  function normalizeComparator(order) {
    if (Array.isArray(order))
      return createFieldsOrder(order);
    if (typeof order === "function")
      return createFunctionOrder(order);
    if (order === "series")
      return createSeriesOrder;
    if (order === "value")
      return createValueOrder;
    if (order === "sum")
      return createSumOrder;
    if (order === "maxIndex")
      return createMaxIndexOrder;
    return null;
  }
  function applyOrder(groups2, comparator) {
    for (const group3 of groups2) {
      group3.sort(comparator);
    }
  }
  function domainOf(value2, scale10) {
    return (scale10 === null || scale10 === void 0 ? void 0 : scale10.domain) || Array.from(new Set(value2));
  }
  function normalizeGroupBy(groupBy2) {
    if (Array.isArray(groupBy2))
      return groupBy2;
    return [groupBy2];
  }
  function createSeriesOrder(data2, Y, S) {
    return ascendingComparator((i) => S[i]);
  }
  function createFunctionOrder(order) {
    return (data2, Y, S) => {
      return ascendingComparator((i) => order(data2[i]));
    };
  }
  function createFieldsOrder(order) {
    return (data2, Y, S) => {
      return (i, j) => order.reduce((eq, f) => eq !== 0 ? eq : ascending(data2[i][f], data2[j][f]), 0);
    };
  }
  function createValueOrder(data2, Y, S) {
    return ascendingComparator((i) => Y[i]);
  }
  function createSumOrder(data2, Y, S) {
    const I = indexOf3(data2);
    const groups2 = Array.from(group(I, (i) => S[+i]).entries());
    const seriesSum = new Map(groups2.map(([k, GI]) => [k, GI.reduce((s3, i) => s3 + +Y[i])]));
    return ascendingComparator((i) => seriesSum.get(S[i]));
  }
  function createMaxIndexOrder(data2, Y, S) {
    const I = indexOf3(data2);
    const groups2 = Array.from(group(I, (i) => S[+i]).entries());
    const seriesMaxIndex = new Map(groups2.map(([k, GI]) => [k, maxIndex(GI, (i) => Y[i])]));
    return ascendingComparator((i) => seriesMaxIndex.get(S[i]));
  }
  function ascendingComparator(order) {
    return (i, j) => ascending(order(i), order(j));
  }

  // node_modules/@antv/g2/esm/transform/stackY.js
  var StackY = (options = {}) => {
    const { groupBy: groupBy2 = "x", orderBy = null, reverse = false, y: fromY = "y", y1: fromY1 = "y1", series = true } = options;
    return (I, mark) => {
      var _a;
      const { data: data2, encode, style = {} } = mark;
      const [Y, fy] = columnOf(encode, "y");
      const [Y12, fy1] = columnOf(encode, "y1");
      const [S] = series ? maybeColumnOf(encode, "series", "color") : columnOf(encode, "color");
      const groups2 = createGroups(groupBy2, I, mark);
      const createComparator = (_a = normalizeComparator(orderBy)) !== null && _a !== void 0 ? _a : () => null;
      const comparator = createComparator(data2, Y, S);
      if (comparator)
        applyOrder(groups2, comparator);
      const newY = new Array(I.length);
      const newY1 = new Array(I.length);
      const TY = new Array(I.length);
      const F = [];
      const L = [];
      for (const G of groups2) {
        if (reverse)
          G.reverse();
        const start2 = Y12 ? +Y12[G[0]] : 0;
        const PG = [];
        const NG = [];
        for (const i2 of G) {
          const y3 = TY[i2] = +Y[i2] - start2;
          if (y3 < 0)
            NG.push(i2);
          else if (y3 >= 0)
            PG.push(i2);
        }
        const FG = PG.length > 0 ? PG : NG;
        const LG = NG.length > 0 ? NG : PG;
        let i = PG.length - 1;
        let j = 0;
        while (i > 0 && Y[FG[i]] === 0)
          i--;
        while (j < LG.length - 1 && Y[LG[j]] === 0)
          j++;
        F.push(FG[i]);
        L.push(LG[j]);
        let ny = start2;
        for (const i2 of NG.reverse()) {
          const y3 = TY[i2];
          ny = newY[i2] = (newY1[i2] = ny) + y3;
        }
        let py = start2;
        for (const i2 of PG) {
          const y3 = TY[i2];
          if (y3 > 0)
            py = newY[i2] = (newY1[i2] = py) + y3;
          else
            newY[i2] = newY1[i2] = py;
        }
      }
      const FS = new Set(F);
      const LS = new Set(L);
      const V = fromY === "y" ? newY : newY1;
      const V1 = fromY1 === "y" ? newY : newY1;
      let newEncode;
      if (mark.type === "point") {
        newEncode = {
          y0: inferredColumn(Y, fy),
          y: column(V, fy)
        };
      } else {
        newEncode = {
          y0: inferredColumn(Y, fy),
          y: column(V, fy),
          y1: column(V1, fy1)
        };
      }
      return [
        I,
        deep_mix_default({}, mark, {
          encode: Object.assign({}, newEncode),
          style: Object.assign({ first: (_2, i) => FS.has(i), last: (_2, i) => LS.has(i) }, style)
        })
      ];
    };
  };
  StackY.props = {};

  // node_modules/@antv/g2/esm/utils/dateFormat.js
  function fillZero(digit) {
    if (Math.abs(digit) > 10)
      return String(digit);
    return digit.toString().padStart(2, "0");
  }
  function dynamicFormatDateTime(date) {
    const year2 = date.getFullYear();
    const month2 = fillZero(date.getMonth() + 1);
    const day2 = fillZero(date.getDate());
    const yyyyMMDD = `${year2}-${month2}-${day2}`;
    const hour2 = date.getHours();
    const minutes = date.getMinutes();
    const seconds = date.getSeconds();
    if (hour2 || minutes || seconds)
      return `${yyyyMMDD} ${fillZero(hour2)}:${fillZero(minutes)}:${fillZero(seconds)}`;
    return yyyyMMDD;
  }

  // node_modules/@antv/g2/esm/transform/maybeTitle.js
  var MaybeTitle = (options = {}) => {
    const { channel = "x" } = options;
    return (I, mark) => {
      const { encode } = mark;
      const { tooltip: tooltip2 } = mark;
      if (isUnset(tooltip2))
        return [I, mark];
      const { title } = tooltip2;
      if (title !== void 0)
        return [I, mark];
      const titles = Object.keys(encode).filter((key) => key.startsWith(channel)).filter((key) => !encode[key].inferred).map((key) => columnOf(encode, key)).filter(([T2]) => T2).map((d3) => d3[0]);
      if (titles.length === 0)
        return [I, mark];
      const T = [];
      for (const i of I) {
        T[i] = {
          value: titles.map((t) => t[i] instanceof Date ? dynamicFormatDateTime(t[i]) : t[i]).join(", ")
        };
      }
      return [
        I,
        deep_mix_default({}, mark, {
          tooltip: {
            title: T
          }
        })
      ];
    };
  };
  MaybeTitle.props = {};

  // node_modules/@antv/g2/esm/transform/maybeZeroX.js
  var MaybeZeroX = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { x: x3 } = encode;
      if (x3 !== void 0)
        return [I, mark];
      return [
        I,
        deep_mix_default({}, mark, {
          encode: { x: inferredColumn(constant(I, 0)) },
          scale: { x: { guide: null } }
        })
      ];
    };
  };
  MaybeZeroX.props = {};

  // node_modules/@antv/g2/esm/transform/maybeZeroY.js
  var MaybeZeroY = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { y: y3 } = encode;
      if (y3 !== void 0)
        return [I, mark];
      return [
        I,
        deep_mix_default({}, mark, {
          encode: { y: inferredColumn(constant(I, 0)) },
          scale: { y: { guide: null } }
        })
      ];
    };
  };
  MaybeZeroY.props = {};

  // node_modules/@antv/g2/esm/transform/maybeSize.js
  var MaybeSize = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { size: size2 } = encode;
      if (size2 !== void 0)
        return [I, mark];
      return [
        I,
        deep_mix_default({}, mark, { encode: { size: visualColumn(constant(I, 3)) } })
      ];
    };
  };
  MaybeSize.props = {};

  // node_modules/@antv/g2/esm/transform/maybeKey.js
  var __rest2 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var MaybeKey = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { key } = encode, rest = __rest2(encode, ["key"]);
      if (key !== void 0)
        return [I, mark];
      const values = Object.values(rest).map(({ value: value2 }) => value2);
      const K = I.map((i) => values.filter(Array.isArray).map((V) => V[i]).join("-"));
      return [I, deep_mix_default({}, mark, { encode: { key: column(K) } })];
    };
  };
  MaybeKey.props = {};

  // node_modules/@antv/g2/esm/transform/maybeSeries.js
  var MaybeSeries = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { series, color: color2 } = encode;
      if (series !== void 0 || color2 === void 0)
        return [I, mark];
      const [C4, fc] = columnOf(encode, "color");
      return [I, deep_mix_default({}, mark, { encode: { series: column(C4, fc) } })];
    };
  };
  MaybeSeries.props = {};

  // node_modules/@antv/g2/esm/transform/maybeTupleY.js
  var MaybeTupleY = () => {
    return (I, mark) => {
      const { data: data2 } = mark;
      if (!Array.isArray(data2) || data2.some(isObject))
        return [I, mark];
      return [I, deep_mix_default({}, mark, { encode: { y: column(data2) } })];
    };
  };
  MaybeTupleY.props = {};

  // node_modules/@antv/g2/esm/transform/maybeTupleX.js
  var MaybeTupleX = () => {
    return (I, mark) => {
      const { data: data2 } = mark;
      if (!Array.isArray(data2) || data2.some(isObject))
        return [I, mark];
      return [I, deep_mix_default({}, mark, { encode: { x: column(data2) } })];
    };
  };
  MaybeTupleX.props = {};

  // node_modules/@antv/g2/esm/transform/maybeIdentityY.js
  var MaybeIdentityY = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { y1: y12 } = encode;
      if (y12)
        return [I, mark];
      const [Y] = columnOf(encode, "y");
      return [I, deep_mix_default({}, mark, { encode: { y1: column([...Y]) } })];
    };
  };
  MaybeIdentityY.props = {};

  // node_modules/@antv/g2/esm/transform/maybeIdentityX.js
  var MaybeIdentityX = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { x1: x12 } = encode;
      if (x12)
        return [I, mark];
      const [X] = columnOf(encode, "x");
      return [I, deep_mix_default({}, mark, { encode: { x1: column([...X]) } })];
    };
  };
  MaybeIdentityX.props = {};

  // node_modules/@antv/g2/esm/transform/maybeDefaultX.js
  var MaybeDefaultX = () => {
    return (I, mark) => {
      const { data: data2 } = mark;
      if (Array.isArray(data2) && (data2.every(Array.isArray) || !data2.some(isObject))) {
        const extractX = (data3, index4) => Array.isArray(data3[0]) ? data3.map((item) => item[index4]) : [data3[index4]];
        return [
          I,
          deep_mix_default({}, mark, {
            encode: {
              x: column(extractX(data2, 0)),
              x1: column(extractX(data2, 1))
            }
          })
        ];
      }
      return [I, mark];
    };
  };
  MaybeDefaultX.props = {};

  // node_modules/@antv/g2/esm/transform/maybeDefaultY.js
  var MaybeDefaultY = () => {
    return (I, mark) => {
      const { data: data2 } = mark;
      if (Array.isArray(data2) && (data2.every(Array.isArray) || !data2.some(isObject))) {
        const extractY = (data3, index4) => Array.isArray(data3[0]) ? data3.map((item) => item[index4]) : [data3[index4]];
        return [
          I,
          deep_mix_default({}, mark, {
            encode: {
              y: column(extractY(data2, 0)),
              y1: column(extractY(data2, 1))
            }
          })
        ];
      }
      return [I, mark];
    };
  };
  MaybeDefaultY.props = {};

  // node_modules/@antv/g2/esm/transform/maybeTooltip.js
  var MaybeTooltip = (options) => {
    const { channel } = options;
    return (I, mark) => {
      const { encode, tooltip: tooltip2 } = mark;
      if (isUnset(tooltip2))
        return [I, mark];
      const { items = [] } = tooltip2;
      if (!items || items.length > 0)
        return [I, mark];
      const channels = Array.isArray(channel) ? channel : [channel];
      const newItems = channels.flatMap((channel2) => Object.keys(encode).filter((key) => key.startsWith(channel2)).map((key) => {
        const { field: field3, value: value2, inferred = false, aggregate } = encode[key];
        if (inferred)
          return null;
        if (aggregate && value2)
          return { channel: key };
        if (field3)
          return { field: field3 };
        if (value2)
          return { channel: key };
        return null;
      }).filter((d3) => d3 !== null));
      return [I, deep_mix_default({}, mark, { tooltip: { items: newItems } })];
    };
  };
  MaybeTooltip.props = {};

  // node_modules/@antv/g2/esm/transform/maybeZeroPadding.js
  var MaybeZeroPadding = () => {
    return (I, mark) => {
      return [
        I,
        deep_mix_default({ scale: { x: { padding: 0 }, y: { padding: 0 } } }, mark)
      ];
    };
  };
  MaybeZeroPadding.props = {};

  // node_modules/@antv/g2/esm/transform/maybeVisualPosition.js
  var __rest3 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var MaybeVisualPosition = () => {
    return (I, mark) => {
      const { data: data2, style = {} } = mark, restMark = __rest3(mark, ["data", "style"]);
      const { x: x05, y: y05 } = style, rest = __rest3(style, ["x", "y"]);
      if (x05 == void 0 || y05 == void 0)
        return [I, mark];
      const x3 = x05 || 0;
      const y3 = y05 || 0;
      return [
        [0],
        deep_mix_default({}, restMark, {
          data: [0],
          cartesian: true,
          encode: {
            x: column([x3]),
            y: column([y3])
          },
          scale: {
            x: { type: "identity", independent: true, guide: null },
            y: { type: "identity", independent: true, guide: null }
            // hide axis
          },
          style: rest
        })
      ];
    };
  };
  MaybeVisualPosition.props = {};

  // node_modules/@antv/g2/esm/transform/maybeFunctionAttribute.js
  var MaybeFunctionAttribute = () => {
    return (I, mark) => {
      const { style = {} } = mark;
      return [
        I,
        deep_mix_default({}, mark, {
          style: Object.assign(Object.assign({}, style), Object.fromEntries(Object.entries(style).filter(([, v]) => typeof v === "function").map(([k, v]) => [k, () => v])))
        })
      ];
    };
  };
  MaybeFunctionAttribute.props = {};

  // node_modules/@antv/g2/esm/transform/maybeTuple.js
  var MaybeTuple = () => {
    return (I, mark) => {
      const { data: data2 } = mark;
      if (!Array.isArray(data2) || data2.some(isObject))
        return [I, mark];
      const position = Array.isArray(data2[0]) ? data2 : [data2];
      const X = position.map((d3) => d3[0]);
      const Y = position.map((d3) => d3[1]);
      return [I, deep_mix_default({}, mark, { encode: { x: column(X), y: column(Y) } })];
    };
  };
  MaybeTuple.props = {};

  // node_modules/@antv/g2/esm/transform/maybeGradient.js
  var MaybeGradient = () => {
    return (I, mark) => {
      const { style = {}, encode } = mark;
      const { series } = encode;
      const { gradient } = style;
      if (!gradient || series)
        return [I, mark];
      return [
        I,
        deep_mix_default({}, mark, {
          encode: {
            series: visualColumn(constant(I, void 0))
          }
        })
      ];
    };
  };
  MaybeGradient.props = {};

  // node_modules/@antv/g2/esm/transform/dodgeX.js
  var __rest4 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var DodgeX = (options = {}) => {
    const { groupBy: groupBy2 = "x", reverse = false, orderBy, padding } = options, rest = __rest4(options, ["groupBy", "reverse", "orderBy", "padding"]);
    return (I, mark) => {
      const { data: data2, encode, scale: scale10 } = mark;
      const { series: scaleSeries } = scale10;
      const [Y] = columnOf(encode, "y");
      const [S] = maybeColumnOf(encode, "series", "color");
      const domainSeries = domainOf(S, scaleSeries);
      const newMark = deep_mix_default({}, mark, {
        scale: {
          series: {
            domain: domainSeries,
            paddingInner: padding
          }
        }
      });
      const groups2 = createGroups(groupBy2, I, mark);
      const createComparator = normalizeComparator(orderBy);
      if (!createComparator) {
        return [I, deep_mix_default(newMark, { encode: { series: column(S) } })];
      }
      const comparator = createComparator(data2, Y, S);
      if (comparator)
        applyOrder(groups2, comparator);
      const newS = new Array(I.length);
      for (const G of groups2) {
        if (reverse)
          G.reverse();
        for (let i = 0; i < G.length; i++) {
          newS[G[i]] = domainSeries[i];
        }
      }
      return [
        I,
        deep_mix_default(newMark, {
          encode: {
            series: column(orderBy ? newS : S)
          }
        })
      ];
    };
  };
  DodgeX.props = {};

  // node_modules/@antv/g2/esm/transform/stackEnter.js
  var StackEnter = (options) => {
    const { groupBy: groupBy2 = ["x"], reducer = (I, V) => V[I[0]], orderBy = null, reverse = false, duration } = options;
    return (I, mark) => {
      const { encode } = mark;
      const by = Array.isArray(groupBy2) ? groupBy2 : [groupBy2];
      const groupEntries = by.map((k) => [k, columnOf(encode, k)[0]]);
      if (groupEntries.length === 0)
        return [I, mark];
      let groups2 = [I];
      for (const [, V] of groupEntries) {
        const newGroups = [];
        for (const I2 of groups2) {
          const G = Array.from(group(I2, (i) => V[i]).values());
          newGroups.push(...G);
        }
        groups2 = newGroups;
      }
      if (orderBy) {
        const [V] = columnOf(encode, orderBy);
        if (V)
          groups2.sort((I2, J) => reducer(I2, V) - reducer(J, V));
        if (reverse)
          groups2.reverse();
      }
      const t = (duration || 3e3) / groups2.length;
      const [ED2] = duration ? [constant(I, t)] : maybeColumnOf(encode, "enterDuration", constant(I, t));
      const [EDL] = maybeColumnOf(encode, "enterDelay", constant(I, 0));
      const newEnterDelay = new Array(I.length);
      for (let i = 0, pd = 0; i < groups2.length; i++) {
        const I2 = groups2[i];
        const maxDuration = max5(I2, (i2) => +ED2[i2]);
        for (const j of I2)
          newEnterDelay[j] = +EDL[j] + pd;
        pd += maxDuration;
      }
      return [
        I,
        deep_mix_default({}, mark, {
          encode: {
            enterDuration: visualColumn(ED2),
            enterDelay: visualColumn(newEnterDelay)
          }
        })
      ];
    };
  };
  StackEnter.props = {};

  // node_modules/@antv/g2/esm/transform/normalizeY.js
  var __rest5 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function normalizeBasis(basis2) {
    if (typeof basis2 === "function")
      return basis2;
    const registry = {
      min: (I, Y) => min4(I, (i) => Y[+i]),
      max: (I, Y) => max5(I, (i) => Y[+i]),
      first: (I, Y) => Y[I[0]],
      last: (I, Y) => Y[I[I.length - 1]],
      mean: (I, Y) => mean(I, (i) => Y[+i]),
      median: (I, Y) => median(I, (i) => Y[+i]),
      sum: (I, Y) => sum(I, (i) => Y[+i]),
      deviation: (I, Y) => deviation(I, (i) => Y[+i])
    };
    return registry[basis2] || max5;
  }
  var NormalizeY = (options = {}) => {
    const { groupBy: groupBy2 = "x", basis: basis2 = "max" } = options;
    return (I, mark) => {
      const { encode, tooltip: tooltip2 } = mark;
      const { x: x3 } = encode, rest = __rest5(encode, ["x"]);
      const Yn = Object.entries(rest).filter(([k]) => k.startsWith("y")).map(([k]) => [k, columnOf(encode, k)[0]]);
      const [, Y] = Yn.find(([k]) => k === "y");
      const newYn = Yn.map(([k]) => [k, new Array(I.length)]);
      const groups2 = createGroups(groupBy2, I, mark);
      const basisFunction = normalizeBasis(basis2);
      for (const I2 of groups2) {
        const basisValue = basisFunction(I2, Y);
        for (const i of I2) {
          for (let j = 0; j < Yn.length; j++) {
            const [, V] = Yn[j];
            const [, newV] = newYn[j];
            newV[i] = +V[i] / basisValue;
          }
        }
      }
      const specifiedTooltip = isUnset(tooltip2) || (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items) && (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items.length) !== 0;
      return [
        I,
        deep_mix_default({}, mark, Object.assign({ encode: Object.fromEntries(newYn.map(([k, v]) => [k, column(v, columnOf(encode, k)[1])])) }, !specifiedTooltip && encode.y0 && {
          tooltip: { items: [{ channel: "y0" }] }
        }))
      ];
    };
  };
  NormalizeY.props = {};

  // node_modules/@antv/scale/esm/utils/compose.js
  function compose2(fn, ...rest) {
    return rest.reduce((pre, cur) => (x3) => pre(cur(x3)), fn);
  }

  // node_modules/@antv/scale/esm/utils/normalize.js
  function createNormalize(a3, b) {
    return b - a3 ? (t) => (t - a3) / (b - a3) : (_2) => 0.5;
  }

  // node_modules/@antv/scale/esm/utils/clamp.js
  function createClamp(a3, b) {
    const lo = b < a3 ? b : a3;
    const hi = a3 > b ? a3 : b;
    return (x3) => Math.min(Math.max(lo, x3), hi);
  }

  // node_modules/@antv/scale/esm/utils/bisect.js
  function bisect(array2, x3, lo, hi, getter) {
    let i = lo || 0;
    let j = hi || array2.length;
    const get2 = getter || ((x4) => x4);
    while (i < j) {
      const mid2 = Math.floor((i + j) / 2);
      if (get2(array2[mid2]) > x3) {
        j = mid2;
      } else {
        i = mid2 + 1;
      }
    }
    return i;
  }

  // node_modules/@antv/scale/esm/utils/ticks.js
  var e102 = Math.sqrt(50);
  var e52 = Math.sqrt(10);
  var e22 = Math.sqrt(2);
  function tickIncrement2(start2, stop, count4) {
    const step2 = (stop - start2) / Math.max(0, count4);
    const power = Math.floor(Math.log(step2) / Math.LN10);
    const error4 = step2 / 10 ** power;
    if (power >= 0) {
      return (error4 >= e102 ? 10 : error4 >= e52 ? 5 : error4 >= e22 ? 2 : 1) * 10 ** power;
    }
    return -(10 ** -power) / (error4 >= e102 ? 10 : error4 >= e52 ? 5 : error4 >= e22 ? 2 : 1);
  }
  function tickStep(start2, stop, count4) {
    const step0 = Math.abs(stop - start2) / Math.max(0, count4);
    let step1 = 10 ** Math.floor(Math.log(step0) / Math.LN10);
    const error4 = step0 / step1;
    if (error4 >= e102)
      step1 *= 10;
    else if (error4 >= e52)
      step1 *= 5;
    else if (error4 >= e22)
      step1 *= 2;
    return stop < start2 ? -step1 : step1;
  }

  // node_modules/@antv/scale/esm/utils/d3-linear-nice.js
  var d3LinearNice = (min10, max11, count4 = 5) => {
    const d3 = [min10, max11];
    let i0 = 0;
    let i1 = d3.length - 1;
    let start2 = d3[i0];
    let stop = d3[i1];
    let step2;
    if (stop < start2) {
      [start2, stop] = [stop, start2];
      [i0, i1] = [i1, i0];
    }
    step2 = tickIncrement2(start2, stop, count4);
    if (step2 > 0) {
      start2 = Math.floor(start2 / step2) * step2;
      stop = Math.ceil(stop / step2) * step2;
      step2 = tickIncrement2(start2, stop, count4);
    } else if (step2 < 0) {
      start2 = Math.ceil(start2 * step2) / step2;
      stop = Math.floor(stop * step2) / step2;
      step2 = tickIncrement2(start2, stop, count4);
    }
    if (step2 > 0) {
      d3[i0] = Math.floor(start2 / step2) * step2;
      d3[i1] = Math.ceil(stop / step2) * step2;
    } else if (step2 < 0) {
      d3[i0] = Math.ceil(start2 * step2) / step2;
      d3[i1] = Math.floor(stop * step2) / step2;
    }
    return d3;
  };

  // node_modules/@antv/scale/esm/utils/time-interval.js
  var DURATION_SECOND = 1e3;
  var DURATION_MINUTE = DURATION_SECOND * 60;
  var DURATION_HOUR = DURATION_MINUTE * 60;
  var DURATION_DAY = DURATION_HOUR * 24;
  var DURATION_WEEK = DURATION_DAY * 7;
  var DURATION_MONTH = DURATION_DAY * 30;
  var DURATION_YEAR = DURATION_DAY * 365;
  function createInterval(duration, floorish, offseti, field3) {
    const adjust = (date, step2) => {
      const test = (date2) => field3(date2) % step2 === 0;
      let i = step2;
      while (i && !test(date)) {
        offseti(date, -1);
        i -= 1;
      }
      return date;
    };
    const floori = (date, step2) => {
      if (step2)
        adjust(date, step2);
      floorish(date);
    };
    const floor4 = (date, step2) => {
      const d3 = /* @__PURE__ */ new Date(+date);
      floori(d3, step2);
      return d3;
    };
    const ceil5 = (date, step2) => {
      const d3 = new Date(+date - 1);
      floori(d3, step2);
      offseti(d3, step2);
      floori(d3);
      return d3;
    };
    const range3 = (start2, stop, step2, shouldAdjust) => {
      const ticks2 = [];
      const roundStep = Math.floor(step2);
      const t = shouldAdjust ? ceil5(start2, step2) : ceil5(start2);
      for (let i = t; i < stop; offseti(i, roundStep), floori(i)) {
        ticks2.push(/* @__PURE__ */ new Date(+i));
      }
      return ticks2;
    };
    return {
      ceil: ceil5,
      floor: floor4,
      range: range3,
      duration
    };
  }
  var millisecond = createInterval(1, (date) => date, (date, step2 = 1) => {
    date.setTime(+date + step2);
  }, (date) => date.getTime());
  var second = createInterval(DURATION_SECOND, (date) => {
    date.setMilliseconds(0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_SECOND * step2);
  }, (date) => date.getSeconds());
  var minute = createInterval(DURATION_MINUTE, (date) => {
    date.setSeconds(0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_MINUTE * step2);
  }, (date) => date.getMinutes());
  var hour = createInterval(DURATION_HOUR, (date) => {
    date.setMinutes(0, 0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_HOUR * step2);
  }, (date) => date.getHours());
  var day = createInterval(DURATION_DAY, (date) => {
    date.setHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_DAY * step2);
  }, (date) => date.getDate() - 1);
  var month = createInterval(DURATION_MONTH, (date) => {
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    const month2 = date.getMonth();
    date.setMonth(month2 + step2);
  }, (date) => date.getMonth());
  var week = createInterval(DURATION_WEEK, (date) => {
    date.setDate(date.getDate() - date.getDay() % 7);
    date.setHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    date.setDate(date.getDate() + 7 * step2);
  }, (date) => {
    const start2 = month.floor(date);
    const end = /* @__PURE__ */ new Date(+date);
    return Math.floor((+end - +start2) / DURATION_WEEK);
  });
  var year = createInterval(DURATION_YEAR, (date) => {
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    const year2 = date.getFullYear();
    date.setFullYear(year2 + step2);
  }, (date) => date.getFullYear());
  var localIntervalMap = {
    millisecond,
    second,
    minute,
    hour,
    day,
    week,
    month,
    year
  };

  // node_modules/@antv/scale/esm/utils/utc-interval.js
  var utcMillisecond = createInterval(1, (date) => date, (date, step2 = 1) => {
    date.setTime(+date + step2);
  }, (date) => date.getTime());
  var utcSecond = createInterval(DURATION_SECOND, (date) => {
    date.setUTCMilliseconds(0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_SECOND * step2);
  }, (date) => date.getUTCSeconds());
  var utcMinute = createInterval(DURATION_MINUTE, (date) => {
    date.setUTCSeconds(0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_MINUTE * step2);
  }, (date) => date.getUTCMinutes());
  var utcHour = createInterval(DURATION_HOUR, (date) => {
    date.setUTCMinutes(0, 0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_HOUR * step2);
  }, (date) => date.getUTCHours());
  var utcDay = createInterval(DURATION_DAY, (date) => {
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_DAY * step2);
  }, (date) => date.getUTCDate() - 1);
  var utcMonth = createInterval(DURATION_MONTH, (date) => {
    date.setUTCDate(1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    const month2 = date.getUTCMonth();
    date.setUTCMonth(month2 + step2);
  }, (date) => date.getUTCMonth());
  var utcWeek = createInterval(DURATION_WEEK, (date) => {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_WEEK * step2);
  }, (date) => {
    const start2 = utcMonth.floor(date);
    const end = /* @__PURE__ */ new Date(+date);
    return Math.floor((+end - +start2) / DURATION_WEEK);
  });
  var utcYear = createInterval(DURATION_YEAR, (date) => {
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    const year2 = date.getUTCFullYear();
    date.setUTCFullYear(year2 + step2);
  }, (date) => date.getUTCFullYear());
  var utcIntervalMap = {
    millisecond: utcMillisecond,
    second: utcSecond,
    minute: utcMinute,
    hour: utcHour,
    day: utcDay,
    week: utcWeek,
    month: utcMonth,
    year: utcYear
  };

  // node_modules/@antv/scale/esm/utils/find-tick-interval.js
  function chooseTickIntervals(utc) {
    const intervalMap = utc ? utcIntervalMap : localIntervalMap;
    const { year: year2, month: month2, week: week2, day: day2, hour: hour2, minute: minute2, second: second2, millisecond: millisecond2 } = intervalMap;
    const tickIntervals = [
      [second2, 1],
      [second2, 5],
      [second2, 15],
      [second2, 30],
      [minute2, 1],
      [minute2, 5],
      [minute2, 15],
      [minute2, 30],
      [hour2, 1],
      [hour2, 3],
      [hour2, 6],
      [hour2, 12],
      [day2, 1],
      [day2, 2],
      [week2, 1],
      [month2, 1],
      [month2, 3],
      [year2, 1]
    ];
    return {
      tickIntervals,
      year: year2,
      millisecond: millisecond2
    };
  }
  function findTickInterval(start2, stop, count4, interval2, utc) {
    const lo = +start2;
    const hi = +stop;
    const { tickIntervals, year: year2, millisecond: millisecond2 } = chooseTickIntervals(utc);
    const getter = ([interval3, count5]) => interval3.duration * count5;
    const targetCount = interval2 ? (hi - lo) / interval2 : count4 || 5;
    const targetInterval = interval2 || (hi - lo) / targetCount;
    const len5 = tickIntervals.length;
    const i = bisect(tickIntervals, targetInterval, 0, len5, getter);
    let matchInterval;
    if (i === len5) {
      const step2 = tickStep(lo / year2.duration, hi / year2.duration, targetCount);
      matchInterval = [year2, step2];
    } else if (i) {
      const closeToLow = targetInterval / getter(tickIntervals[i - 1]) < getter(tickIntervals[i]) / targetInterval;
      const [timeInterval, targetStep] = closeToLow ? tickIntervals[i - 1] : tickIntervals[i];
      const step2 = interval2 ? Math.ceil(interval2 / timeInterval.duration) : targetStep;
      matchInterval = [timeInterval, step2];
    } else {
      const step2 = Math.max(tickStep(lo, hi, targetCount), 1);
      matchInterval = [millisecond2, step2];
    }
    return matchInterval;
  }

  // node_modules/@antv/scale/esm/utils/d3-time-nice.js
  var d3TimeNice = (min10, max11, count4, interval2, utc) => {
    const r = min10 > max11;
    const lo = r ? max11 : min10;
    const hi = r ? min10 : max11;
    const [tickInterval, step2] = findTickInterval(lo, hi, count4, interval2, utc);
    const domain = [tickInterval.floor(lo, step2), tickInterval.ceil(hi, step2)];
    return r ? domain.reverse() : domain;
  };

  // node_modules/@antv/scale/esm/utils/is-valid.js
  function isValid(x3) {
    return !is_undefined_default(x3) && !isNull(x3) && !Number.isNaN(x3);
  }

  // node_modules/@antv/scale/esm/utils/log.js
  var reflect = (f) => {
    return (x3) => -f(-x3);
  };
  var logs = (base, shouldReflect) => {
    const baseCache = Math.log(base);
    const log2 = base === Math.E ? Math.log : base === 10 ? Math.log10 : base === 2 ? Math.log2 : (x3) => Math.log(x3) / baseCache;
    return shouldReflect ? reflect(log2) : log2;
  };
  var pows = (base, shouldReflect) => {
    const pow3 = base === Math.E ? Math.exp : (x3) => base ** x3;
    return shouldReflect ? reflect(pow3) : pow3;
  };

  // node_modules/@antv/scale/esm/utils/d3-log-nice.js
  var d3LogNice = (a3, b, _2, base) => {
    const shouldReflect = a3 < 0;
    const log2 = logs(base, shouldReflect);
    const pow3 = pows(base, shouldReflect);
    const r = a3 > b;
    const min10 = r ? b : a3;
    const max11 = r ? a3 : b;
    const niceDomain = [pow3(Math.floor(log2(min10))), pow3(Math.ceil(log2(max11)))];
    return r ? niceDomain.reverse() : niceDomain;
  };

  // node_modules/@antv/scale/esm/utils/interpolatize.js
  var createInterpolatorRound = (interpolator) => {
    return (t) => {
      const res = interpolator(t);
      return isNumber2(res) ? Math.round(res) : res;
    };
  };
  function interpolatize(rangeOf4, normalizeDomain2) {
    return (Scale) => {
      Scale.prototype.rescale = function() {
        this.initRange();
        this.nice();
        const [transform] = this.chooseTransforms();
        this.composeOutput(transform, this.chooseClamp(transform));
      };
      Scale.prototype.initRange = function() {
        const { interpolator } = this.options;
        this.options.range = rangeOf4(interpolator);
      };
      Scale.prototype.composeOutput = function(transform, clamp3) {
        const { domain, interpolator, round: round5 } = this.getOptions();
        const normalize9 = normalizeDomain2(domain.map(transform));
        const interpolate5 = round5 ? createInterpolatorRound(interpolator) : interpolator;
        this.output = compose2(interpolate5, normalize9, clamp3, transform);
      };
      Scale.prototype.invert = void 0;
    };
  }

  // node_modules/@antv/scale/esm/utils/color.js
  var import_color_string = __toESM(require_color_string());
  function hue2rgb(p2, q, m3) {
    let t = m3;
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p2 + (q - p2) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p2 + (q - p2) * (2 / 3 - t) * 6;
    return p2;
  }
  function hsl2rbg(hsl2) {
    const h = hsl2[0] / 360;
    const s3 = hsl2[1] / 100;
    const l2 = hsl2[2] / 100;
    const a3 = hsl2[3];
    if (s3 === 0)
      return [l2 * 255, l2 * 255, l2 * 255, a3];
    const q = l2 < 0.5 ? l2 * (1 + s3) : l2 + s3 - l2 * s3;
    const p2 = 2 * l2 - q;
    const r = hue2rgb(p2, q, h + 1 / 3);
    const g = hue2rgb(p2, q, h);
    const b = hue2rgb(p2, q, h - 1 / 3);
    return [r * 255, g * 255, b * 255, a3];
  }
  function string2rbg(s3) {
    const color2 = import_color_string.default.get(s3);
    if (!color2)
      return null;
    const { model, value: value2 } = color2;
    if (model === "rgb")
      return value2;
    if (model === "hsl")
      return hsl2rbg(value2);
    return null;
  }

  // node_modules/@antv/scale/esm/utils/interpolate.js
  var createInterpolateNumber = (a3, b) => {
    return (t) => a3 * (1 - t) + b * t;
  };
  var createInterpolateColor = (a3, b) => {
    const c1 = string2rbg(a3);
    const c22 = string2rbg(b);
    if (c1 === null || c22 === null)
      return c1 ? () => a3 : () => b;
    return (t) => {
      const values = new Array(4);
      for (let i = 0; i < 4; i += 1) {
        const from = c1[i];
        const to = c22[i];
        values[i] = from * (1 - t) + to * t;
      }
      const [r, g, b2, a4] = values;
      return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b2)}, ${a4})`;
    };
  };
  var createInterpolateValue = (a3, b) => {
    if (typeof a3 === "number" && typeof b === "number")
      return createInterpolateNumber(a3, b);
    if (typeof a3 === "string" && typeof b === "string")
      return createInterpolateColor(a3, b);
    return () => a3;
  };
  var createInterpolateRound = (a3, b) => {
    const interpolateNumber = createInterpolateNumber(a3, b);
    return (t) => Math.round(interpolateNumber(t));
  };

  // node_modules/@antv/scale/esm/utils/choose-mask.js
  function chooseNiceTimeMask(date, intervalMap) {
    const { second: second2, minute: minute2, hour: hour2, day: day2, week: week2, month: month2, year: year2 } = intervalMap;
    if (second2.floor(date) < date)
      return ".SSS";
    if (minute2.floor(date) < date)
      return ":ss";
    if (hour2.floor(date) < date)
      return "hh:mm";
    if (day2.floor(date) < date)
      return "hh A";
    if (month2.floor(date) < date) {
      if (week2.floor(date) < date)
        return "MMM DD";
      return "ddd DD";
    }
    if (year2.floor(date) < date)
      return "MMMM";
    return "YYYY";
  }

  // node_modules/@antv/scale/esm/utils/internMap.js
  function internGet({ map: map3, initKey }, value2) {
    const key = initKey(value2);
    return map3.has(key) ? map3.get(key) : value2;
  }
  function internSet({ map: map3, initKey }, value2) {
    const key = initKey(value2);
    if (map3.has(key))
      return map3.get(key);
    map3.set(key, value2);
    return value2;
  }
  function internDelete({ map: map3, initKey }, value2) {
    const key = initKey(value2);
    if (map3.has(key)) {
      value2 = map3.get(key);
      map3.delete(key);
    }
    return value2;
  }
  function keyof2(value2) {
    return typeof value2 === "object" ? value2.valueOf() : value2;
  }
  var InternMap2 = class extends Map {
    constructor(entries) {
      super();
      this.map = /* @__PURE__ */ new Map();
      this.initKey = keyof2;
      if (entries !== null) {
        for (const [key, value2] of entries) {
          this.set(key, value2);
        }
      }
    }
    get(key) {
      return super.get(internGet({ map: this.map, initKey: this.initKey }, key));
    }
    has(key) {
      return super.has(internGet({ map: this.map, initKey: this.initKey }, key));
    }
    set(key, value2) {
      return super.set(internSet({ map: this.map, initKey: this.initKey }, key), value2);
    }
    delete(key) {
      return super.delete(internDelete({ map: this.map, initKey: this.initKey }, key));
    }
  };

  // node_modules/@antv/scale/esm/scales/base.js
  var Base = class {
    /**
     * 构造函数，根据自定义的选项和默认选项生成当前选项
     * @param options 需要自定义配置的选项
     */
    constructor(options) {
      this.options = deep_mix_default({}, this.getDefaultOptions());
      this.update(options);
    }
    /**
     * 返回当前的所有选项
     * @returns 当前的所有选项
     */
    getOptions() {
      return this.options;
    }
    /**
     * 更新选项和比例尺的内部状态
     * @param updateOptions 需要更新的选项
     */
    update(updateOptions = {}) {
      this.options = deep_mix_default({}, this.options, updateOptions);
      this.rescale(updateOptions);
    }
    /**
     * 根据需要更新 options 和更新后的 options 更新 scale 的内部状态，
     * 在函数内部可以用 this.options 获得更新后的 options
     * @param options 需要更新的 options
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    rescale(options) {
    }
  };

  // node_modules/@antv/scale/esm/scales/ordinal.js
  var defaultUnknown = Symbol("defaultUnknown");
  function updateIndexMap(target, arr, key) {
    for (let i = 0; i < arr.length; i += 1) {
      if (!target.has(arr[i])) {
        target.set(key(arr[i]), i);
      }
    }
  }
  function mapBetweenArrByMapIndex(options) {
    const { value: value2, from, to, mapper, notFoundReturn } = options;
    let mappedIndex = mapper.get(value2);
    if (mappedIndex === void 0) {
      if (notFoundReturn !== defaultUnknown) {
        return notFoundReturn;
      }
      mappedIndex = from.push(value2) - 1;
      mapper.set(value2, mappedIndex);
    }
    return to[mappedIndex % to.length];
  }
  function createKey(d3) {
    if (d3 instanceof Date)
      return (d4) => `${d4}`;
    if (typeof d3 === "object")
      return (d4) => JSON.stringify(d4);
    return (d4) => d4;
  }
  var Ordinal = class _Ordinal extends Base {
    // 覆盖默认配置
    getDefaultOptions() {
      return {
        domain: [],
        range: [],
        unknown: defaultUnknown
      };
    }
    // 显示指定 options 的类型为 OrdinalOptions，从而推断出 O 的类型
    constructor(options) {
      super(options);
    }
    map(x3) {
      if (this.domainIndexMap.size === 0) {
        updateIndexMap(this.domainIndexMap, this.getDomain(), this.domainKey);
      }
      return mapBetweenArrByMapIndex({
        value: this.domainKey(x3),
        mapper: this.domainIndexMap,
        from: this.getDomain(),
        to: this.getRange(),
        notFoundReturn: this.options.unknown
      });
    }
    invert(y3) {
      if (this.rangeIndexMap.size === 0) {
        updateIndexMap(this.rangeIndexMap, this.getRange(), this.rangeKey);
      }
      return mapBetweenArrByMapIndex({
        value: this.rangeKey(y3),
        mapper: this.rangeIndexMap,
        from: this.getRange(),
        to: this.getDomain(),
        notFoundReturn: this.options.unknown
      });
    }
    // 因为 ordinal 比例尺更新内部状态的开销较大，所以按需更新
    rescale(options) {
      const [d3] = this.options.domain;
      const [r] = this.options.range;
      this.domainKey = createKey(d3);
      this.rangeKey = createKey(r);
      if (!this.rangeIndexMap) {
        this.rangeIndexMap = /* @__PURE__ */ new Map();
        this.domainIndexMap = /* @__PURE__ */ new Map();
        return;
      }
      if (!options || options.range) {
        this.rangeIndexMap.clear();
      }
      if (!options || options.domain || options.compare) {
        this.domainIndexMap.clear();
        this.sortedDomain = void 0;
      }
    }
    clone() {
      return new _Ordinal(this.options);
    }
    getRange() {
      return this.options.range;
    }
    getDomain() {
      if (this.sortedDomain)
        return this.sortedDomain;
      const { domain, compare } = this.options;
      this.sortedDomain = compare ? [...domain].sort(compare) : domain;
      return this.sortedDomain;
    }
  };

  // node_modules/@antv/scale/esm/scales/band.js
  function normalize5(array2) {
    const min10 = Math.min(...array2);
    return array2.map((d3) => d3 / min10);
  }
  function splice(array2, n2) {
    const sn = array2.length;
    const diff = n2 - sn;
    return diff > 0 ? [...array2, ...new Array(diff).fill(1)] : diff < 0 ? array2.slice(0, n2) : array2;
  }
  function pretty(n2) {
    return Math.round(n2 * 1e12) / 1e12;
  }
  function computeFlexBandState(options) {
    const { domain, range: range3, paddingOuter, paddingInner, flex: F, round: round5, align } = options;
    const n2 = domain.length;
    const flex2 = splice(F, n2);
    const [start2, end] = range3;
    const width = end - start2;
    const ratio = 2 / n2 * paddingOuter + 1 - 1 / n2 * paddingInner;
    const stepSum = width / ratio;
    const PI = stepSum * paddingInner / n2;
    const bandWidthSum = stepSum - n2 * PI;
    const normalizedFlex = normalize5(flex2);
    const flexSum = normalizedFlex.reduce((sum3, value2) => sum3 + value2);
    const minBandWidth = bandWidthSum / flexSum;
    const valueBandWidth = new InternMap2(domain.map((d3, i) => {
      const bandWidth3 = normalizedFlex[i] * minBandWidth;
      return [d3, round5 ? Math.floor(bandWidth3) : bandWidth3];
    }));
    const valueStep = new InternMap2(domain.map((d3, i) => {
      const bandWidth3 = normalizedFlex[i] * minBandWidth;
      const step2 = bandWidth3 + PI;
      return [d3, round5 ? Math.floor(step2) : step2];
    }));
    const finalStepSum = Array.from(valueStep.values()).reduce((sum3, value2) => sum3 + value2);
    const outerPaddingSum = width - (finalStepSum - finalStepSum / n2 * paddingInner);
    const offset3 = outerPaddingSum * align;
    const bandStart = start2 + offset3;
    let prev = round5 ? Math.round(bandStart) : bandStart;
    const adjustedRange = new Array(n2);
    for (let i = 0; i < n2; i += 1) {
      adjustedRange[i] = pretty(prev);
      const value2 = domain[i];
      prev += valueStep.get(value2);
    }
    return {
      valueBandWidth,
      valueStep,
      adjustedRange
    };
  }
  function computeBandState(options) {
    var _a;
    const { domain } = options;
    const n2 = domain.length;
    if (n2 === 0) {
      return {
        valueBandWidth: void 0,
        valueStep: void 0,
        adjustedRange: []
      };
    }
    const hasFlex = !!((_a = options.flex) === null || _a === void 0 ? void 0 : _a.length);
    if (hasFlex) {
      return computeFlexBandState(options);
    }
    const { range: range3, paddingOuter, paddingInner, round: round5, align } = options;
    let step2;
    let bandWidth3;
    let rangeStart = range3[0];
    const rangeEnd = range3[1];
    const deltaRange = rangeEnd - rangeStart;
    const outerTotal = paddingOuter * 2;
    const innerTotal = n2 - paddingInner;
    step2 = deltaRange / Math.max(1, outerTotal + innerTotal);
    if (round5) {
      step2 = Math.floor(step2);
    }
    rangeStart += (deltaRange - step2 * (n2 - paddingInner)) * align;
    bandWidth3 = step2 * (1 - paddingInner);
    if (round5) {
      rangeStart = Math.round(rangeStart);
      bandWidth3 = Math.round(bandWidth3);
    }
    const adjustedRange = new Array(n2).fill(0).map((_2, i) => rangeStart + i * step2);
    return {
      valueStep: step2,
      valueBandWidth: bandWidth3,
      adjustedRange
    };
  }
  var Band = class _Band extends Ordinal {
    // 覆盖默认配置
    getDefaultOptions() {
      return {
        domain: [],
        range: [0, 1],
        align: 0.5,
        round: false,
        paddingInner: 0,
        paddingOuter: 0,
        padding: 0,
        unknown: defaultUnknown,
        flex: []
      };
    }
    // 显示指定 options 的类型为 OrdinalOptions，从而推断出 O 的类型
    constructor(options) {
      super(options);
    }
    clone() {
      return new _Band(this.options);
    }
    getStep(x3) {
      if (this.valueStep === void 0)
        return 1;
      if (typeof this.valueStep === "number") {
        return this.valueStep;
      }
      if (x3 === void 0)
        return Array.from(this.valueStep.values())[0];
      return this.valueStep.get(x3);
    }
    getBandWidth(x3) {
      if (this.valueBandWidth === void 0)
        return 1;
      if (typeof this.valueBandWidth === "number") {
        return this.valueBandWidth;
      }
      if (x3 === void 0)
        return Array.from(this.valueBandWidth.values())[0];
      return this.valueBandWidth.get(x3);
    }
    getRange() {
      return this.adjustedRange;
    }
    getPaddingInner() {
      const { padding, paddingInner } = this.options;
      return padding > 0 ? padding : paddingInner;
    }
    getPaddingOuter() {
      const { padding, paddingOuter } = this.options;
      return padding > 0 ? padding : paddingOuter;
    }
    rescale() {
      super.rescale();
      const { align, domain, range: range3, round: round5, flex: flex2 } = this.options;
      const { adjustedRange, valueBandWidth, valueStep } = computeBandState({
        align,
        range: range3,
        round: round5,
        flex: flex2,
        paddingInner: this.getPaddingInner(),
        paddingOuter: this.getPaddingOuter(),
        domain
      });
      this.valueStep = valueStep;
      this.valueBandWidth = valueBandWidth;
      this.adjustedRange = adjustedRange;
    }
  };

  // node_modules/@antv/scale/esm/tick-methods/d3-ticks.js
  var d3Ticks = (begin, end, count4) => {
    let n2;
    let ticks2;
    let start2 = begin;
    let stop = end;
    if (start2 === stop && count4 > 0) {
      return [start2];
    }
    let step2 = tickIncrement2(start2, stop, count4);
    if (step2 === 0 || !Number.isFinite(step2)) {
      return [];
    }
    if (step2 > 0) {
      start2 = Math.ceil(start2 / step2);
      stop = Math.floor(stop / step2);
      ticks2 = new Array(n2 = Math.ceil(stop - start2 + 1));
      for (let i = 0; i < n2; i += 1) {
        ticks2[i] = (start2 + i) * step2;
      }
    } else {
      step2 = -step2;
      start2 = Math.ceil(start2 * step2);
      stop = Math.floor(stop * step2);
      ticks2 = new Array(n2 = Math.ceil(stop - start2 + 1));
      for (let i = 0; i < n2; i += 1) {
        ticks2[i] = (start2 + i) / step2;
      }
    }
    return ticks2;
  };

  // node_modules/@antv/scale/esm/scales/constant.js
  var Constant2 = class _Constant extends Base {
    /**
     * 返回需要覆盖的默认选项
     * @returns 需要覆盖的默认选项
     */
    getDefaultOptions() {
      return {
        range: [0],
        domain: [0, 1],
        unknown: void 0,
        tickCount: 5,
        tickMethod: d3Ticks
      };
    }
    /**
     * 输入和输出满足：y = b，其中 b 是一个常量，是 options.range 的第一个元素
     * @param _ 输入值
     * @returns 输出值（常量）
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    map(_2) {
      const [v] = this.options.range;
      return v !== void 0 ? v : this.options.unknown;
    }
    /**
     * 如果 x 是该比例尺的常量（x === b），返回输入值的范围（即定义域），否者返回 []
     * @param x 输出值 (常量）
     * @returns 定义域
     */
    invert(x3) {
      const [v] = this.options.range;
      return x3 === v && v !== void 0 ? this.options.domain : [];
    }
    getTicks() {
      const { tickMethod, domain, tickCount } = this.options;
      const [a3, b] = domain;
      if (!isNumber2(a3) || !isNumber2(b))
        return [];
      return tickMethod(a3, b, tickCount);
    }
    /**
     * 克隆 Constant Scale
     * @returns 拥有相同选项且独立的 Constant Scale
     */
    clone() {
      return new _Constant(this.options);
    }
  };

  // node_modules/@antv/scale/esm/utils/pretty-number.js
  function prettyNumber(n2) {
    return Math.abs(n2) < 1e-14 ? n2 : parseFloat(n2.toFixed(14));
  }

  // node_modules/@antv/scale/esm/tick-methods/wilkinson-extended.js
  var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
  var eps = Number.EPSILON * 100;
  function mod2(n2, m3) {
    return (n2 % m3 + m3) % m3;
  }
  function round4(n2) {
    return Math.round(n2 * 1e12) / 1e12;
  }
  function simplicity(q, Q, j, lmin, lmax, lstep) {
    const n2 = size(Q);
    const i = index_of_default(Q, q);
    let v = 0;
    const m3 = mod2(lmin, lstep);
    if ((m3 < eps || lstep - m3 < eps) && lmin <= 0 && lmax >= 0) {
      v = 1;
    }
    return 1 - i / (n2 - 1) - j + v;
  }
  function simplicityMax(q, Q, j) {
    const n2 = size(Q);
    const i = index_of_default(Q, q);
    const v = 1;
    return 1 - i / (n2 - 1) - j + v;
  }
  function density(k, m3, dMin, dMax, lMin, lMax) {
    const r = (k - 1) / (lMax - lMin);
    const rt = (m3 - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
    return 2 - Math.max(r / rt, rt / r);
  }
  function densityMax(k, m3) {
    if (k >= m3) {
      return 2 - (k - 1) / (m3 - 1);
    }
    return 1;
  }
  function coverage(dMin, dMax, lMin, lMax) {
    const range3 = dMax - dMin;
    return 1 - 0.5 * ((dMax - lMax) ** 2 + (dMin - lMin) ** 2) / (0.1 * range3) ** 2;
  }
  function coverageMax(dMin, dMax, span) {
    const range3 = dMax - dMin;
    if (span > range3) {
      const half = (span - range3) / 2;
      return 1 - half ** 2 / (0.1 * range3) ** 2;
    }
    return 1;
  }
  function legibility() {
    return 1;
  }
  var wilkinsonExtended = (dMin, dMax, n2 = 5, onlyLoose = true, Q = DEFAULT_Q, w = [0.25, 0.2, 0.5, 0.05]) => {
    const m3 = n2 < 0 ? 0 : Math.round(n2);
    if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m3) {
      return [];
    }
    if (dMax - dMin < 1e-15 || m3 === 1) {
      return [dMin];
    }
    const best = {
      score: -2,
      lmin: 0,
      lmax: 0,
      lstep: 0
    };
    let j = 1;
    while (j < Infinity) {
      for (let i = 0; i < Q.length; i += 1) {
        const q = Q[i];
        const sm = simplicityMax(q, Q, j);
        if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
          j = Infinity;
          break;
        }
        let k = 2;
        while (k < Infinity) {
          const dm = densityMax(k, m3);
          if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {
            break;
          }
          const delta = (dMax - dMin) / (k + 1) / j / q;
          let z = Math.ceil(Math.log10(delta));
          while (z < Infinity) {
            const step2 = j * q * 10 ** z;
            const cm = coverageMax(dMin, dMax, step2 * (k - 1));
            if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {
              break;
            }
            const minStart = Math.floor(dMax / step2) * j - (k - 1) * j;
            const maxStart = Math.ceil(dMin / step2) * j;
            if (minStart <= maxStart) {
              const count4 = maxStart - minStart;
              for (let i2 = 0; i2 <= count4; i2 += 1) {
                const start2 = minStart + i2;
                const lMin = start2 * (step2 / j);
                const lMax = lMin + step2 * (k - 1);
                const lStep = step2;
                const s3 = simplicity(q, Q, j, lMin, lMax, lStep);
                const c5 = coverage(dMin, dMax, lMin, lMax);
                const g = density(k, m3, dMin, dMax, lMin, lMax);
                const l2 = legibility();
                const score2 = w[0] * s3 + w[1] * c5 + w[2] * g + w[3] * l2;
                if (score2 > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                  best.lmin = lMin;
                  best.lmax = lMax;
                  best.lstep = lStep;
                  best.score = score2;
                }
              }
            }
            z += 1;
          }
          k += 1;
        }
      }
      j += 1;
    }
    const lmax = prettyNumber(best.lmax);
    const lmin = prettyNumber(best.lmin);
    const lstep = prettyNumber(best.lstep);
    const tickCount = Math.floor(round4((lmax - lmin) / lstep)) + 1;
    const ticks2 = new Array(tickCount);
    ticks2[0] = prettyNumber(lmin);
    for (let i = 1; i < tickCount; i += 1) {
      ticks2[i] = prettyNumber(ticks2[i - 1] + lstep);
    }
    return ticks2;
  };

  // node_modules/@antv/scale/esm/scales/identity.js
  var Identity = class _Identity extends Base {
    /**
     * 返回需要覆盖的默认选项
     * @returns 需要覆盖的默认选项
     */
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        tickCount: 5,
        unknown: void 0,
        tickMethod: wilkinsonExtended
      };
    }
    /**
     * 输入和输出满足：y = x
     * @param x 输入值
     * @returns 输出值
     */
    map(x3) {
      return isValid(x3) ? x3 : this.options.unknown;
    }
    /**
     * map 的逆运算：x = y，在这里和 map 是相同方法
     * @param x 输出值
     * @returns 输入值
     */
    invert(x3) {
      return this.map(x3);
    }
    /**
     * 克隆 Identity Scale
     * @returns 拥有相同选项且独立的 Identity Scale
     */
    clone() {
      return new _Identity(this.options);
    }
    /**
     * 根据比例尺的配置去生成 ticks，该 ticks 主要用于生成坐标轴
     * @returns 返回一个 ticks 的数组
     */
    getTicks() {
      const { domain, tickCount, tickMethod } = this.options;
      const [min10, max11] = domain;
      if (!isNumber2(min10) || !isNumber2(max11))
        return [];
      return tickMethod(min10, max11, tickCount);
    }
  };

  // node_modules/@antv/scale/esm/scales/continuous.js
  var createBiMap = (domain, range3, createInterpolate) => {
    const [d0, d1] = domain;
    const [r0, r1] = range3;
    let normalize9;
    let interpolate5;
    if (d0 < d1) {
      normalize9 = createNormalize(d0, d1);
      interpolate5 = createInterpolate(r0, r1);
    } else {
      normalize9 = createNormalize(d1, d0);
      interpolate5 = createInterpolate(r1, r0);
    }
    return compose2(interpolate5, normalize9);
  };
  var createPolyMap = (domain, range3, createInterpolate) => {
    const len5 = Math.min(domain.length, range3.length) - 1;
    const normalizeList = new Array(len5);
    const interpolateList = new Array(len5);
    const reverse = domain[0] > domain[len5];
    const ascendingDomain = reverse ? [...domain].reverse() : domain;
    const ascendingRange = reverse ? [...range3].reverse() : range3;
    for (let i = 0; i < len5; i += 1) {
      normalizeList[i] = createNormalize(ascendingDomain[i], ascendingDomain[i + 1]);
      interpolateList[i] = createInterpolate(ascendingRange[i], ascendingRange[i + 1]);
    }
    return (x3) => {
      const i = bisect(domain, x3, 1, len5) - 1;
      const normalize9 = normalizeList[i];
      const interpolate5 = interpolateList[i];
      return compose2(interpolate5, normalize9)(x3);
    };
  };
  var choosePiecewise = (domain, range3, interpolate5, shouldRound) => {
    const n2 = Math.min(domain.length, range3.length);
    const createPiecewise = n2 > 2 ? createPolyMap : createBiMap;
    const createInterpolate = shouldRound ? createInterpolateRound : interpolate5;
    return createPiecewise(domain, range3, createInterpolate);
  };
  var Continuous = class extends Base {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        nice: false,
        clamp: false,
        round: false,
        interpolate: createInterpolateNumber,
        tickCount: 5
      };
    }
    /**
     * y = interpolate(normalize(clamp(transform(x))))
     */
    map(x3) {
      if (!isValid(x3))
        return this.options.unknown;
      return this.output(x3);
    }
    /**
     * x = transform(clamp(interpolate(normalize(y))))
     */
    invert(x3) {
      if (!isValid(x3))
        return this.options.unknown;
      return this.input(x3);
    }
    nice() {
      if (!this.options.nice)
        return;
      const [min10, max11, tickCount, ...rest] = this.getTickMethodOptions();
      this.options.domain = this.chooseNice()(min10, max11, tickCount, ...rest);
    }
    getTicks() {
      const { tickMethod } = this.options;
      const [min10, max11, tickCount, ...rest] = this.getTickMethodOptions();
      return tickMethod(min10, max11, tickCount, ...rest);
    }
    getTickMethodOptions() {
      const { domain, tickCount } = this.options;
      const min10 = domain[0];
      const max11 = domain[domain.length - 1];
      return [min10, max11, tickCount];
    }
    chooseNice() {
      return d3LinearNice;
    }
    rescale() {
      this.nice();
      const [transform, untransform] = this.chooseTransforms();
      this.composeOutput(transform, this.chooseClamp(transform));
      this.composeInput(transform, untransform, this.chooseClamp(untransform));
    }
    chooseClamp(transform) {
      const { clamp: shouldClamp, range: range3 } = this.options;
      const domain = this.options.domain.map(transform);
      const n2 = Math.min(domain.length, range3.length);
      return shouldClamp ? createClamp(domain[0], domain[n2 - 1]) : identity_default;
    }
    composeOutput(transform, clamp3) {
      const { domain, range: range3, round: round5, interpolate: interpolate5 } = this.options;
      const piecewise = choosePiecewise(domain.map(transform), range3, interpolate5, round5);
      this.output = compose2(piecewise, clamp3, transform);
    }
    composeInput(transform, untransform, clamp3) {
      const { domain, range: range3 } = this.options;
      const piecewise = choosePiecewise(range3, domain.map(transform), createInterpolateNumber);
      this.input = compose2(untransform, clamp3, piecewise);
    }
  };

  // node_modules/@antv/scale/esm/scales/linear.js
  var Linear = class _Linear extends Continuous {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        unknown: void 0,
        nice: false,
        clamp: false,
        round: false,
        interpolate: createInterpolateValue,
        tickMethod: d3Ticks,
        tickCount: 5
      };
    }
    chooseTransforms() {
      return [identity_default, identity_default];
    }
    clone() {
      return new _Linear(this.options);
    }
  };

  // node_modules/@antv/scale/esm/scales/point.js
  var Point = class _Point extends Band {
    // 覆盖默认配置
    getDefaultOptions() {
      return {
        domain: [],
        range: [0, 1],
        align: 0.5,
        round: false,
        padding: 0,
        unknown: defaultUnknown,
        paddingInner: 1,
        paddingOuter: 0
      };
    }
    // 能接受的参数只是 PointOptions，不能有 paddingInner 这些属性
    constructor(options) {
      super(options);
    }
    // Point 的 paddingInner 只能是1，不能被覆盖
    getPaddingInner() {
      return 1;
    }
    clone() {
      return new _Point(this.options);
    }
    update(options) {
      super.update(options);
    }
    getPaddingOuter() {
      return this.options.padding;
    }
  };

  // node_modules/@antv/scale/esm/scales/pow.js
  var transformPow = (exponent) => {
    return (x3) => {
      return x3 < 0 ? -((-x3) ** exponent) : x3 ** exponent;
    };
  };
  var transformPowInvert = (exponent) => {
    return (x3) => {
      return x3 < 0 ? -((-x3) ** (1 / exponent)) : x3 ** (1 / exponent);
    };
  };
  var transformSqrt = (x3) => {
    return x3 < 0 ? -Math.sqrt(-x3) : Math.sqrt(x3);
  };
  var Pow = class _Pow extends Continuous {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        nice: false,
        clamp: false,
        round: false,
        exponent: 2,
        interpolate: createInterpolateValue,
        tickMethod: d3Ticks,
        tickCount: 5
      };
    }
    // 显示指定 options 的类型为 PowOptions O 的类型
    constructor(options) {
      super(options);
    }
    chooseTransforms() {
      const { exponent } = this.options;
      if (exponent === 1)
        return [identity_default, identity_default];
      const transform = exponent === 0.5 ? transformSqrt : transformPow(exponent);
      const untransform = transformPowInvert(exponent);
      return [transform, untransform];
    }
    clone() {
      return new _Pow(this.options);
    }
  };

  // node_modules/@antv/scale/esm/scales/sqrt.js
  var Sqrt = class _Sqrt extends Pow {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        nice: false,
        clamp: false,
        round: false,
        interpolate: createInterpolateValue,
        tickMethod: d3Ticks,
        tickCount: 5,
        exponent: 0.5
      };
    }
    constructor(options) {
      super(options);
    }
    update(options) {
      super.update(options);
    }
    clone() {
      return new _Sqrt(this.options);
    }
  };

  // node_modules/@antv/scale/esm/scales/threshold.js
  var Threshold = class _Threshold extends Base {
    getDefaultOptions() {
      return {
        domain: [0.5],
        range: [0, 1]
      };
    }
    constructor(options) {
      super(options);
    }
    /**
     * 二分查找到输入值在哪一段，返回对应的值域中的值
     */
    map(x3) {
      if (!isValid(x3))
        return this.options.unknown;
      const index4 = bisect(this.thresholds, x3, 0, this.n);
      return this.options.range[index4];
    }
    /**
     * 在值域中找到对应的值，并返回在定义域中属于哪一段
     */
    invert(y3) {
      const { range: range3 } = this.options;
      const index4 = range3.indexOf(y3);
      const domain = this.thresholds;
      return [domain[index4 - 1], domain[index4]];
    }
    clone() {
      return new _Threshold(this.options);
    }
    rescale() {
      const { domain, range: range3 } = this.options;
      this.n = Math.min(domain.length, range3.length - 1);
      this.thresholds = domain;
    }
  };

  // node_modules/@antv/scale/esm/tick-methods/d3-log.js
  var d3Log = (a3, b, n2, base = 10) => {
    const shouldReflect = a3 < 0;
    const pow3 = pows(base, shouldReflect);
    const log2 = logs(base, shouldReflect);
    const r = b < a3;
    const min10 = r ? b : a3;
    const max11 = r ? a3 : b;
    let i = log2(min10);
    let j = log2(max11);
    let ticks2 = [];
    if (!(base % 1) && j - i < n2) {
      i = Math.floor(i);
      j = Math.ceil(j);
      if (shouldReflect) {
        for (; i <= j; i += 1) {
          const p2 = pow3(i);
          for (let k = base - 1; k >= 1; k -= 1) {
            const t = p2 * k;
            if (t > max11)
              break;
            if (t >= min10)
              ticks2.push(t);
          }
        }
      } else {
        for (; i <= j; i += 1) {
          const p2 = pow3(i);
          for (let k = 1; k < base; k += 1) {
            const t = p2 * k;
            if (t > max11)
              break;
            if (t >= min10)
              ticks2.push(t);
          }
        }
      }
      if (ticks2.length * 2 < n2)
        ticks2 = d3Ticks(min10, max11, n2);
    } else {
      const count4 = n2 === -1 ? j - i : Math.min(j - i, n2);
      ticks2 = d3Ticks(i, j, count4).map(pow3);
    }
    return r ? ticks2.reverse() : ticks2;
  };

  // node_modules/@antv/scale/esm/scales/log.js
  var Log = class _Log extends Continuous {
    getDefaultOptions() {
      return {
        domain: [1, 10],
        range: [0, 1],
        base: 10,
        interpolate: createInterpolateValue,
        tickMethod: d3Log,
        tickCount: 5
      };
    }
    chooseNice() {
      return d3LogNice;
    }
    getTickMethodOptions() {
      const { domain, tickCount, base } = this.options;
      const min10 = domain[0];
      const max11 = domain[domain.length - 1];
      return [min10, max11, tickCount, base];
    }
    chooseTransforms() {
      const { base, domain } = this.options;
      const shouldReflect = domain[0] < 0;
      return [logs(base, shouldReflect), pows(base, shouldReflect)];
    }
    clone() {
      return new _Log(this.options);
    }
  };

  // node_modules/@antv/scale/esm/scales/quantize.js
  var Quantize = class _Quantize extends Threshold {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0.5],
        nice: false,
        tickCount: 5,
        tickMethod: wilkinsonExtended
      };
    }
    constructor(options) {
      super(options);
    }
    nice() {
      const { nice: nice2 } = this.options;
      if (nice2) {
        const [min10, max11, tickCount] = this.getTickMethodOptions();
        this.options.domain = d3LinearNice(min10, max11, tickCount);
      }
    }
    getTicks() {
      const { tickMethod } = this.options;
      const [min10, max11, tickCount] = this.getTickMethodOptions();
      return tickMethod(min10, max11, tickCount);
    }
    getTickMethodOptions() {
      const { domain, tickCount } = this.options;
      const min10 = domain[0];
      const max11 = domain[domain.length - 1];
      return [min10, max11, tickCount];
    }
    rescale() {
      this.nice();
      const { range: range3, domain } = this.options;
      const [x05, x12] = domain;
      this.n = range3.length - 1;
      this.thresholds = new Array(this.n);
      for (let i = 0; i < this.n; i += 1) {
        this.thresholds[i] = ((i + 1) * x12 - (i - this.n) * x05) / (this.n + 1);
      }
    }
    /**
     * 如果是在第一段后或者最后一段就把两端的值添加上
     */
    invert(y3) {
      const [a3, b] = super.invert(y3);
      const [x05, x12] = this.options.domain;
      return a3 === void 0 && b === void 0 ? [a3, b] : [a3 || x05, b || x12];
    }
    getThresholds() {
      return this.thresholds;
    }
    clone() {
      return new _Quantize(this.options);
    }
  };

  // node_modules/@antv/scale/esm/utils/create-quartile.js
  function quantileSorted2(arr, percentage) {
    const len5 = arr.length;
    if (!len5) {
      return void 0;
    }
    if (len5 < 2) {
      return arr[len5 - 1];
    }
    const i = (len5 - 1) * percentage;
    const i0 = Math.floor(i);
    const v0 = arr[i0];
    const v1 = arr[i0 + 1];
    return v0 + (v1 - v0) * (i - i0);
  }
  function createQuartile(arr, n2, isSorted = false) {
    const numberArr = arr;
    if (!isSorted) {
      numberArr.sort((a3, b) => a3 - b);
    }
    const tmp2 = [];
    for (let i = 1; i < n2; i += 1) {
      tmp2.push(quantileSorted2(numberArr, i / n2));
    }
    return tmp2;
  }

  // node_modules/@antv/scale/esm/scales/quantile.js
  var Quantile = class _Quantile extends Threshold {
    getDefaultOptions() {
      return {
        domain: [],
        range: [],
        tickCount: 5,
        unknown: void 0,
        tickMethod: wilkinsonExtended
      };
    }
    constructor(options) {
      super(options);
    }
    rescale() {
      const { domain, range: range3 } = this.options;
      this.n = range3.length - 1;
      this.thresholds = createQuartile(domain, this.n + 1, false);
    }
    /**
     * 如果是在第一段后或者最后一段就把两端的值添加上
     */
    invert(y3) {
      const [a3, b] = super.invert(y3);
      const { domain } = this.options;
      const dMin = domain[0];
      const dMax = domain[domain.length - 1];
      return a3 === void 0 && b === void 0 ? [a3, b] : [a3 || dMin, b || dMax];
    }
    getThresholds() {
      return this.thresholds;
    }
    clone() {
      return new _Quantile(this.options);
    }
    getTicks() {
      const { tickCount, domain, tickMethod } = this.options;
      const lastIndex = domain.length - 1;
      const min10 = domain[0];
      const max11 = domain[lastIndex];
      return tickMethod(min10, max11, tickCount);
    }
  };

  // node_modules/fecha/lib/fecha.js
  var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigitsOptional = "\\d\\d?";
  var twoDigits = "\\d\\d";
  var threeDigits = "\\d{3}";
  var fourDigits = "\\d{4}";
  var word = "[^\\s]+";
  var literal = /\[([^]*?)\]/gm;
  function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len5 = arr.length; i < len5; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  }
  var monthUpdate = function(arrName) {
    return function(v, i18n) {
      var lowerCaseArr = i18n[arrName].map(function(v2) {
        return v2.toLowerCase();
      });
      var index4 = lowerCaseArr.indexOf(v.toLowerCase());
      if (index4 > -1) {
        return index4;
      }
      return null;
    };
  };
  function assign(origObj) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var obj = args_1[_a];
      for (var key in obj) {
        origObj[key] = obj[key];
      }
    }
    return origObj;
  }
  var dayNames = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ];
  var monthNames = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  var defaultI18n = {
    dayNamesShort,
    dayNames,
    monthNamesShort,
    monthNames,
    amPm: ["am", "pm"],
    DoFn: function(dayOfMonth) {
      return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
    }
  };
  var globalI18n = assign({}, defaultI18n);
  var pad = function(val, len5) {
    if (len5 === void 0) {
      len5 = 2;
    }
    val = String(val);
    while (val.length < len5) {
      val = "0" + val;
    }
    return val;
  };
  var formatFlags = {
    D: function(dateObj) {
      return String(dateObj.getDate());
    },
    DD: function(dateObj) {
      return pad(dateObj.getDate());
    },
    Do: function(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function(dateObj) {
      return String(dateObj.getDay());
    },
    dd: function(dateObj) {
      return pad(dateObj.getDay());
    },
    ddd: function(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function(dateObj) {
      return String(dateObj.getMonth() + 1);
    },
    MM: function(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    YY: function(dateObj) {
      return pad(String(dateObj.getFullYear()), 4).substr(2);
    },
    YYYY: function(dateObj) {
      return pad(dateObj.getFullYear(), 4);
    },
    h: function(dateObj) {
      return String(dateObj.getHours() % 12 || 12);
    },
    hh: function(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function(dateObj) {
      return String(dateObj.getHours());
    },
    HH: function(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function(dateObj) {
      return String(dateObj.getMinutes());
    },
    mm: function(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function(dateObj) {
      return String(dateObj.getSeconds());
    },
    ss: function(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function(dateObj) {
      return String(Math.round(dateObj.getMilliseconds() / 100));
    },
    SS: function(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function(dateObj) {
      var offset3 = dateObj.getTimezoneOffset();
      return (offset3 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset3) / 60) * 100 + Math.abs(offset3) % 60, 4);
    },
    Z: function(dateObj) {
      var offset3 = dateObj.getTimezoneOffset();
      return (offset3 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset3) / 60), 2) + ":" + pad(Math.abs(offset3) % 60, 2);
    }
  };
  var monthParse = function(v) {
    return +v - 1;
  };
  var emptyDigits = [null, twoDigitsOptional];
  var emptyWord = [null, word];
  var amPm = [
    "isPm",
    word,
    function(v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        return 0;
      } else if (val === i18n.amPm[1]) {
        return 1;
      }
      return null;
    }
  ];
  var timezoneOffset = [
    "timezoneOffset",
    "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
    function(v) {
      var parts = (v + "").match(/([+-]|\d\d)/gi);
      if (parts) {
        var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
        return parts[0] === "+" ? minutes : -minutes;
      }
      return 0;
    }
  ];
  var parseFlags = {
    D: ["day", twoDigitsOptional],
    DD: ["day", twoDigits],
    Do: ["day", twoDigitsOptional + word, function(v) {
      return parseInt(v, 10);
    }],
    M: ["month", twoDigitsOptional, monthParse],
    MM: ["month", twoDigits, monthParse],
    YY: [
      "year",
      twoDigits,
      function(v) {
        var now4 = /* @__PURE__ */ new Date();
        var cent = +("" + now4.getFullYear()).substr(0, 2);
        return +("" + (+v > 68 ? cent - 1 : cent) + v);
      }
    ],
    h: ["hour", twoDigitsOptional, void 0, "isPm"],
    hh: ["hour", twoDigits, void 0, "isPm"],
    H: ["hour", twoDigitsOptional],
    HH: ["hour", twoDigits],
    m: ["minute", twoDigitsOptional],
    mm: ["minute", twoDigits],
    s: ["second", twoDigitsOptional],
    ss: ["second", twoDigits],
    YYYY: ["year", fourDigits],
    S: ["millisecond", "\\d", function(v) {
      return +v * 100;
    }],
    SS: ["millisecond", twoDigits, function(v) {
      return +v * 10;
    }],
    SSS: ["millisecond", threeDigits],
    d: emptyDigits,
    dd: emptyDigits,
    ddd: emptyWord,
    dddd: emptyWord,
    MMM: ["month", word, monthUpdate("monthNamesShort")],
    MMMM: ["month", word, monthUpdate("monthNames")],
    a: amPm,
    A: amPm,
    ZZ: timezoneOffset,
    Z: timezoneOffset
  };
  var globalMasks = {
    default: "ddd MMM DD YYYY HH:mm:ss",
    shortDate: "M/D/YY",
    mediumDate: "MMM D, YYYY",
    longDate: "MMMM D, YYYY",
    fullDate: "dddd, MMMM D, YYYY",
    isoDate: "YYYY-MM-DD",
    isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
    shortTime: "HH:mm",
    mediumTime: "HH:mm:ss",
    longTime: "HH:mm:ss.SSS"
  };
  var format = function(dateObj, mask, i18n) {
    if (mask === void 0) {
      mask = globalMasks["default"];
    }
    if (i18n === void 0) {
      i18n = {};
    }
    if (typeof dateObj === "number") {
      dateObj = new Date(dateObj);
    }
    if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
      throw new Error("Invalid Date pass to format");
    }
    mask = globalMasks[mask] || mask;
    var literals = [];
    mask = mask.replace(literal, function($0, $1) {
      literals.push($1);
      return "@@@";
    });
    var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
    mask = mask.replace(token, function($0) {
      return formatFlags[$0](dateObj, combinedI18nSettings);
    });
    return mask.replace(/@@@/g, function() {
      return literals.shift();
    });
  };

  // node_modules/@antv/scale/esm/tick-methods/d3-time.js
  var d3Time = (min10, max11, count4, interval2, utc) => {
    const r = min10 > max11;
    const lo = r ? max11 : min10;
    const hi = r ? min10 : max11;
    const [tickInterval, step2] = findTickInterval(lo, hi, count4, interval2, utc);
    const ticks2 = tickInterval.range(lo, /* @__PURE__ */ new Date(+hi + 1), step2, true);
    return r ? ticks2.reverse() : ticks2;
  };

  // node_modules/@antv/scale/esm/scales/time.js
  function offset2(date) {
    const minuteOffset = date.getTimezoneOffset();
    const d3 = new Date(date);
    d3.setMinutes(d3.getMinutes() + minuteOffset, d3.getSeconds(), d3.getMilliseconds());
    return d3;
  }
  var Time = class _Time extends Continuous {
    getDefaultOptions() {
      return {
        domain: [new Date(2e3, 0, 1), new Date(2e3, 0, 2)],
        range: [0, 1],
        nice: false,
        tickCount: 5,
        tickInterval: void 0,
        unknown: void 0,
        clamp: false,
        tickMethod: d3Time,
        interpolate: createInterpolateNumber,
        mask: void 0,
        utc: false
      };
    }
    chooseTransforms() {
      const transform = (x3) => +x3;
      const untransform = (x3) => new Date(x3);
      return [transform, untransform];
    }
    chooseNice() {
      return d3TimeNice;
    }
    getTickMethodOptions() {
      const { domain, tickCount, tickInterval, utc } = this.options;
      const min10 = domain[0];
      const max11 = domain[domain.length - 1];
      return [min10, max11, tickCount, tickInterval, utc];
    }
    getFormatter() {
      const { mask, utc } = this.options;
      const maskMap = utc ? utcIntervalMap : localIntervalMap;
      const time = utc ? offset2 : identity_default;
      return (d3) => format(time(d3), mask || chooseNiceTimeMask(d3, maskMap));
    }
    clone() {
      return new _Time(this.options);
    }
  };

  // node_modules/@antv/scale/esm/scales/sequential.js
  var __decorate = function(decorators, target, key, desc) {
    var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d3 = decorators[i]) r = (c5 < 3 ? d3(r) : c5 > 3 ? d3(target, key, r) : d3(target, key)) || r;
    return c5 > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var Sequential_1;
  function rangeOf(interpolator) {
    return [interpolator(0), interpolator(1)];
  }
  var normalizeDomain = (domain) => {
    const [d0, d1] = domain;
    const normalize9 = compose2(createInterpolateNumber(0, 1), createNormalize(d0, d1));
    return normalize9;
  };
  var Sequential = Sequential_1 = class Sequential2 extends Linear {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        unknown: void 0,
        nice: false,
        clamp: false,
        round: false,
        interpolator: identity_default,
        tickMethod: d3Ticks,
        tickCount: 5
      };
    }
    constructor(options) {
      super(options);
    }
    clone() {
      return new Sequential_1(this.options);
    }
  };
  Sequential = Sequential_1 = __decorate([
    interpolatize(rangeOf, normalizeDomain)
  ], Sequential);

  // node_modules/@antv/g2/esm/transform/jitter.js
  function rangeOf2(value2, scaleOptions, padding) {
    if (value2 === null)
      return [-0.5, 0.5];
    const domain = domainOf(value2, scaleOptions);
    const scale10 = new Band({ domain, range: [0, 1], padding });
    const step2 = scale10.getBandWidth();
    return [-step2 / 2, step2 / 2];
  }
  function interpolate2(t, a3, b) {
    return a3 * (1 - t) + b * t;
  }
  var Jitter = (options = {}) => {
    const { padding = 0, paddingX = padding, paddingY = padding, random: random5 = Math.random } = options;
    return (I, mark) => {
      const { encode, scale: scale10 } = mark;
      const { x: scaleX2, y: scaleY2 } = scale10;
      const [X] = columnOf(encode, "x");
      const [Y] = columnOf(encode, "y");
      const rangeX = rangeOf2(X, scaleX2, paddingX);
      const rangeY = rangeOf2(Y, scaleY2, paddingY);
      const DY = I.map(() => interpolate2(random5(), ...rangeY));
      const DX = I.map(() => interpolate2(random5(), ...rangeX));
      return [
        I,
        deep_mix_default({
          scale: {
            x: { padding: 0.5 },
            y: { padding: 0.5 }
          }
        }, mark, {
          encode: { dy: column(DY), dx: column(DX) }
        })
      ];
    };
  };
  Jitter.props = {};

  // node_modules/@antv/g2/esm/transform/jitterX.js
  var JitterX = (options = {}) => {
    const { padding = 0, random: random5 = Math.random } = options;
    return (I, mark) => {
      const { encode, scale: scale10 } = mark;
      const { x: scaleX2 } = scale10;
      const [X] = columnOf(encode, "x");
      const rangeX = rangeOf2(X, scaleX2, padding);
      const DX = I.map(() => interpolate2(random5(), ...rangeX));
      return [
        I,
        deep_mix_default({ scale: { x: { padding: 0.5 } } }, mark, {
          encode: { dx: column(DX) }
        })
      ];
    };
  };
  JitterX.props = {};

  // node_modules/@antv/g2/esm/transform/jitterY.js
  var JitterY = (options = {}) => {
    const { padding = 0, random: random5 = Math.random } = options;
    return (I, mark) => {
      const { encode, scale: scale10 } = mark;
      const { y: scaleY2 } = scale10;
      const [Y] = columnOf(encode, "y");
      const rangeY = rangeOf2(Y, scaleY2, padding);
      const DY = I.map(() => interpolate2(random5(), ...rangeY));
      return [
        I,
        deep_mix_default({ scale: { y: { padding: 0.5 } } }, mark, {
          encode: { dy: column(DY) }
        })
      ];
    };
  };
  JitterY.props = {};

  // node_modules/@antv/g2/esm/transform/symmetryY.js
  var __rest6 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var SymmetryY = (options = {}) => {
    const { groupBy: groupBy2 = "x" } = options;
    return (I, mark) => {
      const { encode } = mark;
      const { x: x3 } = encode, rest = __rest6(encode, ["x"]);
      const Yn = Object.entries(rest).filter(([k]) => k.startsWith("y")).map(([k]) => [k, columnOf(encode, k)[0]]);
      const newYn = Yn.map(([k]) => [k, new Array(I.length)]);
      const groups2 = createGroups(groupBy2, I, mark);
      const MY = new Array(groups2.length);
      for (let i = 0; i < groups2.length; i++) {
        const I2 = groups2[i];
        const Y = I2.flatMap((i2) => Yn.map(([, V]) => +V[i2]));
        const [minY, maxY2] = extent(Y);
        MY[i] = (minY + maxY2) / 2;
      }
      const maxMiddleY = Math.max(...MY);
      for (let m3 = 0; m3 < groups2.length; m3++) {
        const offset3 = maxMiddleY - MY[m3];
        const I2 = groups2[m3];
        for (const i of I2) {
          for (let j = 0; j < Yn.length; j++) {
            const [, V] = Yn[j];
            const [, newV] = newYn[j];
            newV[i] = +V[i] + offset3;
          }
        }
      }
      return [
        I,
        deep_mix_default({}, mark, {
          encode: Object.fromEntries(newYn.map(([k, v]) => [k, column(v, columnOf(encode, k)[1])]))
        })
      ];
    };
  };
  SymmetryY.props = {};

  // node_modules/@antv/g2/esm/transform/diffY.js
  var DiffY = (options = {}) => {
    const { groupBy: groupBy2 = "x", series = true } = options;
    return (I, mark) => {
      const { encode } = mark;
      const [Y] = columnOf(encode, "y");
      const [_2, fy1] = columnOf(encode, "y1");
      const [S] = series ? maybeColumnOf(encode, "series", "color") : columnOf(encode, "color");
      const groups2 = createGroups(groupBy2, I, mark);
      const newY1 = new Array(I.length);
      for (const G of groups2) {
        const YG = G.map((i) => +Y[i]);
        for (let idx = 0; idx < G.length; idx++) {
          const i = G[idx];
          const max11 = Math.max(...YG.filter((_3, _i) => _i !== idx));
          newY1[i] = +Y[i] > max11 ? max11 : Y[i];
        }
      }
      return [
        I,
        deep_mix_default({}, mark, {
          encode: {
            y1: column(newY1, fy1)
          }
        })
      ];
    };
  };
  DiffY.props = {};

  // node_modules/@antv/g2/esm/transform/select.js
  function first(I, V) {
    return [I[0]];
  }
  function last2(I, V) {
    const i = I.length - 1;
    return [I[i]];
  }
  function max6(I, V) {
    const i = maxIndex(I, (i2) => V[i2]);
    return [I[i]];
  }
  function min5(I, V) {
    const i = minIndex(I, (i2) => V[i2]);
    return [I[i]];
  }
  function normalizeSelector(selector) {
    if (typeof selector === "function")
      return selector;
    const registry = { first, last: last2, max: max6, min: min5 };
    return registry[selector] || first;
  }
  var Select = (options = {}) => {
    const { groupBy: groupBy2 = "series", channel, selector } = options;
    return (I, mark) => {
      const { encode } = mark;
      const groups2 = createGroups(groupBy2, I, mark);
      const [V] = columnOf(encode, channel);
      const selectFunction = normalizeSelector(selector);
      return [groups2.flatMap((GI) => selectFunction(GI, V)), mark];
    };
  };
  Select.props = {};

  // node_modules/@antv/g2/esm/transform/selectX.js
  var __rest7 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var SelectX = (options = {}) => {
    const { selector } = options, rest = __rest7(options, ["selector"]);
    return Select(Object.assign({ channel: "x", selector }, rest));
  };
  SelectX.props = {};

  // node_modules/@antv/g2/esm/transform/selectY.js
  var __rest8 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var SelectY = (options = {}) => {
    const { selector } = options, rest = __rest8(options, ["selector"]);
    return Select(Object.assign({ channel: "y", selector }, rest));
  };
  SelectY.props = {};

  // node_modules/@antv/g2/esm/transform/groupN.js
  var __rest9 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function builtinFormatter(summary) {
    return (d3) => d3 === null ? summary : `${summary} of ${d3}`;
  }
  function normalizeReducer(reducer) {
    if (typeof reducer === "function")
      return [reducer, null];
    const registry = { mean: mean2, max: max7, count: count2, first: first2, last: last3, sum: sum2, min: min6, median: median2 };
    const reducerFunction = registry[reducer];
    if (!reducerFunction)
      throw new Error(`Unknown reducer: ${reducer}.`);
    return reducerFunction();
  }
  function mean2() {
    const reducer = (I, V) => mean(I, (i) => +V[i]);
    const formatter2 = builtinFormatter("mean");
    return [reducer, formatter2];
  }
  function median2() {
    const reducer = (I, V) => median(I, (i) => +V[i]);
    const formatter2 = builtinFormatter("median");
    return [reducer, formatter2];
  }
  function max7() {
    const reducer = (I, V) => max5(I, (i) => +V[i]);
    const formatter2 = builtinFormatter("max");
    return [reducer, formatter2];
  }
  function min6() {
    const reducer = (I, V) => min4(I, (i) => +V[i]);
    const formatter2 = builtinFormatter("min");
    return [reducer, formatter2];
  }
  function count2() {
    const reducer = (I, V) => I.length;
    const formatter2 = builtinFormatter("count");
    return [reducer, formatter2];
  }
  function sum2() {
    const reducer = (I, V) => sum(I, (i) => +V[i]);
    const formatter2 = builtinFormatter("sum");
    return [reducer, formatter2];
  }
  function first2() {
    const reducer = (I, V) => V[I[0]];
    const formatter2 = builtinFormatter("first");
    return [reducer, formatter2];
  }
  function last3() {
    const reducer = (I, V) => V[I[I.length - 1]];
    const formatter2 = builtinFormatter("last");
    return [reducer, formatter2];
  }
  var GroupN = (options = {}) => {
    const { groupBy: groupBy2 } = options, rest = __rest9(options, ["groupBy"]);
    return (I, mark) => {
      const { data: data2, encode } = mark;
      const groups2 = groupBy2(I, mark);
      if (!groups2)
        return [I, mark];
      const maybeFrom = (field3, reducer) => {
        if (field3)
          return field3;
        const { from } = reducer;
        if (!from)
          return field3;
        const [, field1] = columnOf(encode, from);
        return field1;
      };
      const outputs = Object.entries(rest).map(([channel, reducer]) => {
        const [reducerFunction, formatter2] = normalizeReducer(reducer);
        const [V, field3] = columnOf(encode, channel);
        const field1 = maybeFrom(field3, reducer);
        const RV = groups2.map((I2) => reducerFunction(I2, V !== null && V !== void 0 ? V : data2));
        return [
          channel,
          Object.assign(Object.assign({}, nonConstantColumn(RV, (formatter2 === null || formatter2 === void 0 ? void 0 : formatter2(field1)) || field1)), { aggregate: true })
        ];
      });
      const reducedColumns = Object.keys(encode).map((key) => {
        const [V, fv] = columnOf(encode, key);
        const GV = groups2.map((I2) => V[I2[0]]);
        return [key, column(GV, fv)];
      });
      const GD = groups2.map((I2) => data2[I2[0]]);
      const GI = indexOf3(groups2);
      return [
        GI,
        deep_mix_default({}, mark, {
          data: GD,
          encode: Object.fromEntries([...reducedColumns, ...outputs])
        })
      ];
    };
  };
  GroupN.props = {};

  // node_modules/@antv/g2/esm/transform/group.js
  var __rest10 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var Group = (options = {}) => {
    const { channels = ["x", "y"] } = options, rest = __rest10(options, ["channels"]);
    const groupBy2 = (I, mark) => createGroups(channels, I, mark);
    return GroupN(Object.assign(Object.assign({}, rest), { groupBy: groupBy2 }));
  };
  Group.props = {};

  // node_modules/@antv/g2/esm/transform/groupX.js
  var GroupX = (options = {}) => {
    return Group(Object.assign(Object.assign({}, options), { channels: ["x", "color", "series"] }));
  };
  GroupX.props = {};

  // node_modules/@antv/g2/esm/transform/groupY.js
  var GroupY = (options = {}) => {
    return Group(Object.assign(Object.assign({}, options), { channels: ["y", "color", "series"] }));
  };
  GroupY.props = {};

  // node_modules/@antv/g2/esm/transform/groupColor.js
  var GroupColor = (options = {}) => {
    return Group(Object.assign(Object.assign({}, options), { channels: ["color"] }));
  };
  GroupColor.props = {};

  // node_modules/@antv/g2/esm/transform/sort.js
  var __rest11 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function createReducer(channel, options, encode) {
    const { by = channel, reducer = "max" } = options;
    const [V] = columnOf(encode, by);
    if (typeof reducer === "function")
      return (GI) => reducer(GI, V);
    if (reducer === "max")
      return (GI) => max5(GI, (i) => +V[i]);
    if (reducer === "min")
      return (GI) => min4(GI, (i) => +V[i]);
    if (reducer === "sum")
      return (GI) => sum(GI, (i) => +V[i]);
    if (reducer === "median")
      return (GI) => median(GI, (i) => +V[i]);
    if (reducer === "mean")
      return (GI) => mean(GI, (i) => +V[i]);
    if (reducer === "first")
      return (GI) => V[GI[0]];
    if (reducer === "last")
      return (GI) => V[GI[GI.length - 1]];
    throw new Error(`Unknown reducer: ${reducer}`);
  }
  function sortQuantitative(I, mark, options) {
    const { reverse, channel } = options;
    const { encode } = mark;
    const [V] = columnOf(encode, channel);
    const sortedI = sort2(I, (i) => V[i]);
    if (reverse)
      sortedI.reverse();
    return [sortedI, mark];
  }
  function filterIndex(I, values, specifiedDomain) {
    if (!Array.isArray(specifiedDomain))
      return I;
    const domain = new Set(specifiedDomain);
    return I.filter((i) => domain.has(values[i]));
  }
  function sortOrdinal(I, mark, options) {
    var _a;
    const { reverse, slice: slice3, channel } = options, rest = __rest11(options, ["reverse", "slice", "channel"]);
    const { encode, scale: scale10 = {} } = mark;
    const domain = (_a = scale10[channel]) === null || _a === void 0 ? void 0 : _a.domain;
    const [T] = columnOf(encode, channel);
    const normalizeReducer2 = createReducer(channel, rest, encode);
    const SI = filterIndex(I, T, domain);
    const sortedDomain = groupSort(SI, normalizeReducer2, (i) => T[i]);
    if (reverse)
      sortedDomain.reverse();
    const s3 = typeof slice3 === "number" ? [0, slice3] : slice3;
    const slicedDomain = slice3 ? sortedDomain.slice(...s3) : sortedDomain;
    return [
      I,
      deep_mix_default(mark, {
        scale: {
          [channel]: {
            domain: slicedDomain
          }
        }
      })
    ];
  }
  var Sort = (options = {}) => {
    const { reverse = false, slice: slice3, channel, ordinal = true } = options, rest = __rest11(options, ["reverse", "slice", "channel", "ordinal"]);
    return (I, mark) => {
      if (!ordinal) {
        return sortQuantitative(I, mark, Object.assign({
          reverse,
          slice: slice3,
          channel
        }, rest));
      }
      return sortOrdinal(I, mark, Object.assign({ reverse, slice: slice3, channel }, rest));
    };
  };
  Sort.props = {};

  // node_modules/@antv/g2/esm/transform/sortX.js
  var SortX = (options = {}) => {
    return Sort(Object.assign(Object.assign({}, options), { channel: "x" }));
  };
  SortX.props = {};

  // node_modules/@antv/g2/esm/transform/sortColor.js
  var SortColor = (options = {}) => {
    return Sort(Object.assign(Object.assign({}, options), { channel: "color" }));
  };
  SortColor.props = {};

  // node_modules/@antv/g2/esm/transform/sortY.js
  var SortY = (options = {}) => {
    return Sort(Object.assign(Object.assign({}, options), { channel: "y" }));
  };
  SortY.props = {};

  // node_modules/@antv/g2/esm/transform/flexX.js
  function valueOf(data2, field3) {
    if (typeof field3 === "string")
      return data2.map((d3) => d3[field3]);
    return data2.map(field3);
  }
  function createReducer2(reducer, V) {
    if (typeof reducer === "function")
      return (GI) => reducer(GI, V);
    if (reducer === "sum")
      return (GI) => sum(GI, (i) => +V[i]);
    throw new Error(`Unknown reducer: ${reducer}`);
  }
  var FlexX = (options = {}) => {
    const { field: field3, channel = "y", reducer = "sum" } = options;
    return (I, mark) => {
      const { data: data2, encode } = mark;
      const [x3] = columnOf(encode, "x");
      const V = field3 ? valueOf(data2, field3) : columnOf(encode, channel)[0];
      const reducerFunction = createReducer2(reducer, V);
      const flex2 = rollups(I, reducerFunction, (i) => x3[i]).map((d3) => d3[1]);
      return [I, deep_mix_default({}, mark, { scale: { x: { flex: flex2 } } })];
    };
  };
  FlexX.props = {};

  // node_modules/@antv/g2/esm/utils/vector.js
  function sub6([x12, y12], [x22, y22]) {
    return [x12 - x22, y12 - y22];
  }
  function add8([x12, y12], [x22, y22]) {
    return [x12 + x22, y12 + y22];
  }
  function dist4([x05, y05], [x12, y12]) {
    return Math.sqrt(Math.pow(x05 - x12, 2) + Math.pow(y05 - y12, 2));
  }
  function angle3([x3, y3]) {
    return Math.atan2(y3, x3);
  }
  function angleWithQuadrant([x3, y3]) {
    return angle3([x3, y3]) + Math.PI / 2;
  }
  function angleBetween2(v0, v1) {
    const a0 = angle3(v0);
    const a1 = angle3(v1);
    if (a0 < a1)
      return a1 - a0;
    return Math.PI * 2 - (a0 - a1);
  }
  function calcBBox(points) {
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY2 = -Infinity;
    for (const [x3, y3] of points) {
      minX = Math.min(x3, minX);
      maxX = Math.max(x3, maxX);
      minY = Math.min(y3, minY);
      maxY2 = Math.max(y3, maxY2);
    }
    const width = maxX - minX;
    const height = maxY2 - minY;
    return [minX, minY, width, height];
  }
  function mid([x12, y12], [x22, y22]) {
    return [(x12 + x22) / 2, (y12 + y22) / 2];
  }

  // node_modules/@antv/g2/esm/transform/pack.js
  function pack(options) {
    const { padding = 0, direction: direction2 = "col" } = options;
    return (P, count4, layout) => {
      const pcount = P.length;
      if (pcount === 0)
        return [];
      const { innerWidth, innerHeight } = layout;
      const aspect = innerHeight / innerWidth;
      let col = Math.ceil(Math.sqrt(count4 / aspect));
      let size2 = innerWidth / col;
      let row2 = Math.ceil(count4 / col);
      let h0 = row2 * size2;
      while (h0 > innerHeight) {
        col = col + 1;
        size2 = innerWidth / col;
        row2 = Math.ceil(count4 / col);
        h0 = row2 * size2;
      }
      const space = innerHeight - row2 * size2;
      const intervalY = row2 <= 1 ? 0 : space / (row2 - 1);
      const [offsetX, offsetY] = row2 <= 1 ? [
        (innerWidth - pcount * size2) / (pcount - 1),
        (innerHeight - size2) / 2
      ] : [0, 0];
      return P.map((points, m3) => {
        const [x3, y3, width, height] = calcBBox(points);
        const i = direction2 === "col" ? m3 % col : Math.floor(m3 / row2);
        const j = direction2 === "col" ? Math.floor(m3 / col) : m3 % row2;
        const newX = i * size2;
        const newY = (row2 - j - 1) * size2 + space;
        const sx = (size2 - padding) / width;
        const sy = (size2 - padding) / height;
        const tx = newX - x3 + offsetX * i + 1 / 2 * padding;
        const ty = newY - y3 - intervalY * j - offsetY + 1 / 2 * padding;
        return `translate(${tx}, ${ty}) scale(${sx}, ${sy})`;
      });
    };
  }
  var Pack = (options) => {
    return (I, mark) => {
      return [I, deep_mix_default({}, mark, { modifier: pack(options), axis: false })];
    };
  };
  Pack.props = {};

  // node_modules/@antv/g2/esm/transform/bin.js
  var __rest12 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var THRESHOLD = "thresholds";
  function thresholdAuto(values) {
    const [min10, max11] = extent(values);
    return Math.min(200, thresholdScott(values, min10, max11));
  }
  var Bin = (options = {}) => {
    const { groupChannels = ["color"], binChannels = ["x", "y"] } = options, rest = __rest12(options, ["groupChannels", "binChannels"]);
    const channelIndexKey = {};
    const groupBy2 = (I, mark) => {
      const { encode } = mark;
      const binValues = binChannels.map((channel) => {
        const [V] = columnOf(encode, channel);
        return V;
      });
      const thresholds = subObject(rest, THRESHOLD);
      const DI = I.filter((i) => binValues.every((V) => defined(V[i])));
      const groupKeys = [
        // For discrete channels, use value as group key.
        ...groupChannels.map((d3) => {
          const [V] = columnOf(encode, d3);
          return V;
        }).filter(defined).map((V) => (i) => V[i]),
        // For quantitative channels, use extent of bin as group key.
        ...binChannels.map((d3, i) => {
          const V = binValues[i];
          const t = thresholds[d3] || thresholdAuto(V);
          const bins = bin().thresholds(t).value((i2) => +V[i2])(DI);
          const indexKey = new Map(bins.flatMap((bin2) => {
            const { x0: x05, x1: x12 } = bin2;
            const key2 = `${x05},${x12}`;
            return bin2.map((i2) => [i2, key2]);
          }));
          channelIndexKey[d3] = indexKey;
          return (i2) => indexKey.get(i2);
        })
      ];
      const key = (i) => groupKeys.map((key2) => key2(i)).join("-");
      return Array.from(group(DI, key).values());
    };
    return GroupN(Object.assign(Object.assign(Object.assign({}, Object.fromEntries(Object.entries(rest).filter(([k]) => !k.startsWith(THRESHOLD)))), Object.fromEntries(binChannels.flatMap((channel) => {
      const start2 = ([i]) => +channelIndexKey[channel].get(i).split(",")[0];
      const end = ([i]) => +channelIndexKey[channel].get(i).split(",")[1];
      end.from = channel;
      return [
        [channel, start2],
        [`${channel}1`, end]
      ];
    }))), { groupBy: groupBy2 }));
  };
  Bin.props = {};

  // node_modules/@antv/g2/esm/transform/binX.js
  var BinX = (options = {}) => {
    const { thresholds } = options;
    return Bin(Object.assign(Object.assign({}, options), { thresholdsX: thresholds, groupChannels: ["color"], binChannels: ["x"] }));
  };
  BinX.props = {};

  // node_modules/@antv/g2/esm/transform/utils/lttb.js
  function lttb(I, X, Y, thresholds) {
    const length5 = I.length;
    if (thresholds >= length5 || thresholds === 0) {
      return I;
    }
    const x3 = (i) => X[I[i]] * 1;
    const y3 = (i) => Y[I[i]] * 1;
    const sampled = [];
    const every = (length5 - 2) / (thresholds - 2);
    let a3 = 0;
    let maxArea;
    let area2;
    let nextA;
    sampled.push(a3);
    for (let i = 0; i < thresholds - 2; i++) {
      let avgX = 0;
      let avgY = 0;
      let start2 = Math.floor((i + 1) * every) + 1;
      let end = Math.floor((i + 2) * every) + 1;
      end = Math.min(end, length5);
      const size2 = end - start2;
      for (; start2 < end; start2++) {
        avgX += x3(start2);
        avgY += y3(start2);
      }
      avgX /= size2;
      avgY /= size2;
      let frameStart = Math.floor((i + 0) * every) + 1;
      const frameEnd = Math.floor((i + 1) * every) + 1;
      const pointA = [x3(a3), y3(a3)];
      maxArea = area2 = -1;
      for (; frameStart < frameEnd; frameStart++) {
        area2 = Math.abs((pointA[0] - avgX) * (x3(frameStart) - pointA[1]) - (pointA[0] - y3(frameStart)) * (avgY - pointA[0])) * 0.5;
        if (area2 > maxArea) {
          maxArea = area2;
          nextA = frameStart;
        }
      }
      sampled.push(nextA);
      a3 = nextA;
    }
    sampled.push(length5 - 1);
    return sampled.map((a4) => I[a4]);
  }

  // node_modules/@antv/g2/esm/transform/sample.js
  function normalizeSample(strategy) {
    if (typeof strategy === "function")
      return strategy;
    if (strategy === "lttb")
      return lttb;
    const strategies = {
      first: (f) => [f[0]],
      last: (f) => [f[f.length - 1]],
      min: (f, X, Y) => [
        f[minIndex(f, (i) => Y[i])]
      ],
      max: (f, X, Y) => [
        f[maxIndex(f, (i) => Y[i])]
      ],
      median: (f, X, Y) => [
        f[medianIndex(f, (i) => Y[i])]
      ]
    };
    const sampleFunction = strategies[strategy] || strategies.median;
    return (I, X, Y, thresholds) => {
      const frameSize = Math.max(1, Math.floor(I.length / thresholds));
      const frames = getFrames(I, frameSize);
      return frames.flatMap((frame2) => sampleFunction(frame2, X, Y));
    };
  }
  function getFrames(I, frameSize) {
    const size2 = I.length;
    const frames = [];
    let i = 0;
    while (i < size2) {
      frames.push(I.slice(i, i += frameSize));
    }
    return frames;
  }
  var Sample = (options = {}) => {
    const { strategy = "median", thresholds = 2e3, groupBy: groupBy2 = ["series", "color"] } = options;
    const sampleFunction = normalizeSample(strategy);
    return (I, mark) => {
      const { encode } = mark;
      const groups2 = createGroups(groupBy2, I, mark);
      const [X] = columnOf(encode, "x");
      const [Y] = columnOf(encode, "y");
      return [
        groups2.flatMap((g) => sampleFunction(g, X, Y, thresholds)),
        mark
      ];
    };
  };
  Sample.props = {};

  // node_modules/@antv/g2/esm/transform/filter.js
  function normalizeValue(value2) {
    if (typeof value2 === "object")
      return [value2.value, value2.ordinal];
    else
      return [value2, true];
  }
  function filterWhenNoElements(mark) {
    var _a;
    const { encode } = mark;
    const noElementMark = Object.assign(Object.assign({}, mark), { encode: Object.assign(Object.assign({}, mark.encode), { y: Object.assign(Object.assign({}, mark.encode.y), { value: [] }) }) });
    const targetField = (_a = encode === null || encode === void 0 ? void 0 : encode.color) === null || _a === void 0 ? void 0 : _a.field;
    if (!encode || !targetField) {
      return noElementMark;
    }
    let filterObject;
    for (const [key, v] of Object.entries(encode)) {
      if ((key === "x" || key === "y") && v.field === targetField) {
        filterObject = Object.assign(Object.assign({}, filterObject), { [key]: Object.assign(Object.assign({}, v), { value: [] }) });
      }
    }
    if (!filterObject) {
      return noElementMark;
    }
    return Object.assign(Object.assign({}, mark), { encode: Object.assign(Object.assign({}, mark.encode), filterObject) });
  }
  var Filter = (options = {}) => {
    return (I, mark) => {
      const { encode, data: data2 } = mark;
      const filters = Object.entries(options).map(([key, v]) => {
        const [V] = columnOf(encode, key);
        if (!V)
          return null;
        const [value2, ordinal = true] = normalizeValue(v);
        if (typeof value2 === "function")
          return (i) => value2(V[i]);
        if (ordinal) {
          const expectedValues = Array.isArray(value2) ? value2 : [value2];
          if (expectedValues.length === 0)
            return null;
          return (i) => expectedValues.includes(V[i]);
        } else {
          const [start2, end] = value2;
          return (i) => V[i] >= start2 && V[i] <= end;
        }
      }).filter(defined);
      const totalFilter = (i) => filters.every((f) => f(i));
      const FI = I.filter(totalFilter);
      const newIndex2 = FI.map((_2, i) => i);
      if (filters.length === 0) {
        const targetMark = filterWhenNoElements(mark);
        return [I, targetMark];
      }
      const newEncodes = Object.entries(encode).map(([key, encode2]) => {
        return [
          key,
          Object.assign(Object.assign({}, encode2), { value: newIndex2.map((i) => encode2.value[FI[i]]).filter((v) => v !== void 0) })
        ];
      });
      return [
        newIndex2,
        deep_mix_default({}, mark, {
          encode: Object.fromEntries(newEncodes),
          // Filter data for tooltip item.
          data: FI.map((i) => data2[i])
        })
      ];
    };
  };
  Filter.props = {};

  // node_modules/d3-shape/src/constant.js
  function constant_default(x3) {
    return function constant4() {
      return x3;
    };
  }

  // node_modules/d3-shape/src/math.js
  var abs = Math.abs;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var max8 = Math.max;
  var min7 = Math.min;
  var sin = Math.sin;
  var sqrt = Math.sqrt;
  var epsilon = 1e-12;
  var pi = Math.PI;
  var halfPi = pi / 2;
  var tau = 2 * pi;
  function acos(x3) {
    return x3 > 1 ? 0 : x3 < -1 ? pi : Math.acos(x3);
  }
  function asin(x3) {
    return x3 >= 1 ? halfPi : x3 <= -1 ? -halfPi : Math.asin(x3);
  }

  // node_modules/d3-path/src/path.js
  var pi2 = Math.PI;
  var tau2 = 2 * pi2;
  var epsilon2 = 1e-6;
  var tauEpsilon = tau2 - epsilon2;
  function append(strings) {
    this._ += strings[0];
    for (let i = 1, n2 = strings.length; i < n2; ++i) {
      this._ += arguments[i] + strings[i];
    }
  }
  function appendRound(digits) {
    let d3 = Math.floor(digits);
    if (!(d3 >= 0)) throw new Error(`invalid digits: ${digits}`);
    if (d3 > 15) return append;
    const k = 10 ** d3;
    return function(strings) {
      this._ += strings[0];
      for (let i = 1, n2 = strings.length; i < n2; ++i) {
        this._ += Math.round(arguments[i] * k) / k + strings[i];
      }
    };
  }
  var Path = class {
    constructor(digits) {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null;
      this._ = "";
      this._append = digits == null ? append : appendRound(digits);
    }
    moveTo(x3, y3) {
      this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}`;
    }
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._append`Z`;
      }
    }
    lineTo(x3, y3) {
      this._append`L${this._x1 = +x3},${this._y1 = +y3}`;
    }
    quadraticCurveTo(x12, y12, x3, y3) {
      this._append`Q${+x12},${+y12},${this._x1 = +x3},${this._y1 = +y3}`;
    }
    bezierCurveTo(x12, y12, x22, y22, x3, y3) {
      this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x3},${this._y1 = +y3}`;
    }
    arcTo(x12, y12, x22, y22, r) {
      x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;
      if (r < 0) throw new Error(`negative radius: ${r}`);
      let x05 = this._x1, y05 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x05 - x12, y01 = y05 - y12, l01_2 = x01 * x01 + y01 * y01;
      if (this._x1 === null) {
        this._append`M${this._x1 = x12},${this._y1 = y12}`;
      } else if (!(l01_2 > epsilon2)) ;
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r) {
        this._append`L${this._x1 = x12},${this._y1 = y12}`;
      } else {
        let x20 = x22 - x05, y20 = y22 - y05, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
        if (Math.abs(t01 - 1) > epsilon2) {
          this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
        }
        this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
      }
    }
    arc(x3, y3, r, a0, a1, ccw) {
      x3 = +x3, y3 = +y3, r = +r, ccw = !!ccw;
      if (r < 0) throw new Error(`negative radius: ${r}`);
      let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x05 = x3 + dx, y05 = y3 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
      if (this._x1 === null) {
        this._append`M${x05},${y05}`;
      } else if (Math.abs(this._x1 - x05) > epsilon2 || Math.abs(this._y1 - y05) > epsilon2) {
        this._append`L${x05},${y05}`;
      }
      if (!r) return;
      if (da < 0) da = da % tau2 + tau2;
      if (da > tauEpsilon) {
        this._append`A${r},${r},0,1,${cw2},${x3 - dx},${y3 - dy}A${r},${r},0,1,${cw2},${this._x1 = x05},${this._y1 = y05}`;
      } else if (da > epsilon2) {
        this._append`A${r},${r},0,${+(da >= pi2)},${cw2},${this._x1 = x3 + r * Math.cos(a1)},${this._y1 = y3 + r * Math.sin(a1)}`;
      }
    }
    rect(x3, y3, w, h) {
      this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}h${w = +w}v${+h}h${-w}Z`;
    }
    toString() {
      return this._;
    }
  };
  function path() {
    return new Path();
  }
  path.prototype = Path.prototype;

  // node_modules/d3-shape/src/path.js
  function withPath(shape23) {
    let digits = 3;
    shape23.digits = function(_2) {
      if (!arguments.length) return digits;
      if (_2 == null) {
        digits = null;
      } else {
        const d3 = Math.floor(_2);
        if (!(d3 >= 0)) throw new RangeError(`invalid digits: ${_2}`);
        digits = d3;
      }
      return shape23;
    };
    return () => new Path(digits);
  }

  // node_modules/d3-shape/src/arc.js
  function arcInnerRadius(d3) {
    return d3.innerRadius;
  }
  function arcOuterRadius(d3) {
    return d3.outerRadius;
  }
  function arcStartAngle(d3) {
    return d3.startAngle;
  }
  function arcEndAngle(d3) {
    return d3.endAngle;
  }
  function arcPadAngle(d3) {
    return d3 && d3.padAngle;
  }
  function intersect(x05, y05, x12, y12, x22, y22, x3, y3) {
    var x10 = x12 - x05, y10 = y12 - y05, x32 = x3 - x22, y32 = y3 - y22, t = y32 * x10 - x32 * y10;
    if (t * t < epsilon) return;
    t = (x32 * (y05 - y22) - y32 * (x05 - x22)) / t;
    return [x05 + t * x10, y05 + t * y10];
  }
  function cornerTangents(x05, y05, x12, y12, r1, rc, cw2) {
    var x01 = x05 - x12, y01 = y05 - y12, lo = (cw2 ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x05 + ox, y11 = y05 + oy, x10 = x12 + ox, y10 = y12 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d22 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d3 = (dy < 0 ? -1 : 1) * sqrt(max8(0, r * r * d22 - D2 * D2)), cx0 = (D2 * dy - dx * d3) / d22, cy0 = (-D2 * dx - dy * d3) / d22, cx1 = (D2 * dy + dx * d3) / d22, cy1 = (-D2 * dx + dy * d3) / d22, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return {
      cx: cx0,
      cy: cy0,
      x01: -ox,
      y01: -oy,
      x11: cx0 * (r1 / r - 1),
      y11: cy0 * (r1 / r - 1)
    };
  }
  function arc_default() {
    var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);
    function arc() {
      var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw2 = a1 > a0;
      if (!context) context = buffer = path2();
      if (r1 < r0) r = r1, r1 = r0, r0 = r;
      if (!(r1 > epsilon)) context.moveTo(0, 0);
      else if (da > tau - epsilon) {
        context.moveTo(r1 * cos(a0), r1 * sin(a0));
        context.arc(0, 0, r1, a0, a1, !cw2);
        if (r0 > epsilon) {
          context.moveTo(r0 * cos(a1), r0 * sin(a1));
          context.arc(0, 0, r0, a1, a0, cw2);
        }
      } else {
        var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min7(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
        if (rp > epsilon) {
          var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
          if ((da0 -= p0 * 2) > epsilon) p0 *= cw2 ? 1 : -1, a00 += p0, a10 -= p0;
          else da0 = 0, a00 = a10 = (a0 + a1) / 2;
          if ((da1 -= p1 * 2) > epsilon) p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
          else da1 = 0, a01 = a11 = (a0 + a1) / 2;
        }
        var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
        if (rc > epsilon) {
          var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x004 = r0 * cos(a00), y004 = r0 * sin(a00), oc;
          if (da < pi) {
            if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {
              var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min7(rc, (r0 - lc) / (kc - 1));
              rc1 = min7(rc, (r1 - lc) / (kc + 1));
            } else {
              rc0 = rc1 = 0;
            }
          }
        }
        if (!(da1 > epsilon)) context.moveTo(x01, y01);
        else if (rc1 > epsilon) {
          t0 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw2);
          t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
          context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
          if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw2);
          else {
            context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw2);
            context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw2);
            context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw2);
          }
        } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw2);
        if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);
        else if (rc0 > epsilon) {
          t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
          t1 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw2);
          context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
          if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw2);
          else {
            context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw2);
            context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw2);
            context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw2);
          }
        } else context.arc(0, 0, r0, a10, a00, cw2);
      }
      context.closePath();
      if (buffer) return context = null, buffer + "" || null;
    }
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a3 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
      return [cos(a3) * r, sin(a3) * r];
    };
    arc.innerRadius = function(_2) {
      return arguments.length ? (innerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : innerRadius;
    };
    arc.outerRadius = function(_2) {
      return arguments.length ? (outerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : outerRadius;
    };
    arc.cornerRadius = function(_2) {
      return arguments.length ? (cornerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : cornerRadius;
    };
    arc.padRadius = function(_2) {
      return arguments.length ? (padRadius = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), arc) : padRadius;
    };
    arc.startAngle = function(_2) {
      return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : startAngle;
    };
    arc.endAngle = function(_2) {
      return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : endAngle;
    };
    arc.padAngle = function(_2) {
      return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : padAngle;
    };
    arc.context = function(_2) {
      return arguments.length ? (context = _2 == null ? null : _2, arc) : context;
    };
    return arc;
  }

  // node_modules/d3-shape/src/array.js
  var slice2 = Array.prototype.slice;
  function array_default(x3) {
    return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
  }

  // node_modules/d3-shape/src/curve/linear.js
  function Linear2(context) {
    this._context = context;
  }
  Linear2.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
        // falls through
        default:
          this._context.lineTo(x3, y3);
          break;
      }
    }
  };
  function linear_default(context) {
    return new Linear2(context);
  }

  // node_modules/d3-shape/src/point.js
  function x(p2) {
    return p2[0];
  }
  function y(p2) {
    return p2[1];
  }

  // node_modules/d3-shape/src/line.js
  function line_default(x3, y3) {
    var defined4 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(line4);
    x3 = typeof x3 === "function" ? x3 : x3 === void 0 ? x : constant_default(x3);
    y3 = typeof y3 === "function" ? y3 : y3 === void 0 ? y : constant_default(y3);
    function line4(data2) {
      var i, n2 = (data2 = array_default(data2)).length, d3, defined0 = false, buffer;
      if (context == null) output = curve(buffer = path2());
      for (i = 0; i <= n2; ++i) {
        if (!(i < n2 && defined4(d3 = data2[i], i, data2)) === defined0) {
          if (defined0 = !defined0) output.lineStart();
          else output.lineEnd();
        }
        if (defined0) output.point(+x3(d3, i, data2), +y3(d3, i, data2));
      }
      if (buffer) return output = null, buffer + "" || null;
    }
    line4.x = function(_2) {
      return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default(+_2), line4) : x3;
    };
    line4.y = function(_2) {
      return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default(+_2), line4) : y3;
    };
    line4.defined = function(_2) {
      return arguments.length ? (defined4 = typeof _2 === "function" ? _2 : constant_default(!!_2), line4) : defined4;
    };
    line4.curve = function(_2) {
      return arguments.length ? (curve = _2, context != null && (output = curve(context)), line4) : curve;
    };
    line4.context = function(_2) {
      return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line4) : context;
    };
    return line4;
  }

  // node_modules/d3-shape/src/area.js
  function area_default(x05, y05, y12) {
    var x12 = null, defined4 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(area2);
    x05 = typeof x05 === "function" ? x05 : x05 === void 0 ? x : constant_default(+x05);
    y05 = typeof y05 === "function" ? y05 : y05 === void 0 ? constant_default(0) : constant_default(+y05);
    y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y : constant_default(+y12);
    function area2(data2) {
      var i, j, k, n2 = (data2 = array_default(data2)).length, d3, defined0 = false, buffer, x0z = new Array(n2), y0z = new Array(n2);
      if (context == null) output = curve(buffer = path2());
      for (i = 0; i <= n2; ++i) {
        if (!(i < n2 && defined4(d3 = data2[i], i, data2)) === defined0) {
          if (defined0 = !defined0) {
            j = i;
            output.areaStart();
            output.lineStart();
          } else {
            output.lineEnd();
            output.lineStart();
            for (k = i - 1; k >= j; --k) {
              output.point(x0z[k], y0z[k]);
            }
            output.lineEnd();
            output.areaEnd();
          }
        }
        if (defined0) {
          x0z[i] = +x05(d3, i, data2), y0z[i] = +y05(d3, i, data2);
          output.point(x12 ? +x12(d3, i, data2) : x0z[i], y12 ? +y12(d3, i, data2) : y0z[i]);
        }
      }
      if (buffer) return output = null, buffer + "" || null;
    }
    function arealine() {
      return line_default().defined(defined4).curve(curve).context(context);
    }
    area2.x = function(_2) {
      return arguments.length ? (x05 = typeof _2 === "function" ? _2 : constant_default(+_2), x12 = null, area2) : x05;
    };
    area2.x0 = function(_2) {
      return arguments.length ? (x05 = typeof _2 === "function" ? _2 : constant_default(+_2), area2) : x05;
    };
    area2.x1 = function(_2) {
      return arguments.length ? (x12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), area2) : x12;
    };
    area2.y = function(_2) {
      return arguments.length ? (y05 = typeof _2 === "function" ? _2 : constant_default(+_2), y12 = null, area2) : y05;
    };
    area2.y0 = function(_2) {
      return arguments.length ? (y05 = typeof _2 === "function" ? _2 : constant_default(+_2), area2) : y05;
    };
    area2.y1 = function(_2) {
      return arguments.length ? (y12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), area2) : y12;
    };
    area2.lineX0 = area2.lineY0 = function() {
      return arealine().x(x05).y(y05);
    };
    area2.lineY1 = function() {
      return arealine().x(x05).y(y12);
    };
    area2.lineX1 = function() {
      return arealine().x(x12).y(y05);
    };
    area2.defined = function(_2) {
      return arguments.length ? (defined4 = typeof _2 === "function" ? _2 : constant_default(!!_2), area2) : defined4;
    };
    area2.curve = function(_2) {
      return arguments.length ? (curve = _2, context != null && (output = curve(context)), area2) : curve;
    };
    area2.context = function(_2) {
      return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), area2) : context;
    };
    return area2;
  }

  // node_modules/d3-shape/src/curve/radial.js
  var curveRadialLinear = curveRadial(linear_default);
  function Radial2(curve) {
    this._curve = curve;
  }
  Radial2.prototype = {
    areaStart: function() {
      this._curve.areaStart();
    },
    areaEnd: function() {
      this._curve.areaEnd();
    },
    lineStart: function() {
      this._curve.lineStart();
    },
    lineEnd: function() {
      this._curve.lineEnd();
    },
    point: function(a3, r) {
      this._curve.point(r * Math.sin(a3), r * -Math.cos(a3));
    }
  };
  function curveRadial(curve) {
    function radial(context) {
      return new Radial2(curve(context));
    }
    radial._curve = curve;
    return radial;
  }

  // node_modules/d3-shape/src/lineRadial.js
  function lineRadial(l2) {
    var c5 = l2.curve;
    l2.angle = l2.x, delete l2.x;
    l2.radius = l2.y, delete l2.y;
    l2.curve = function(_2) {
      return arguments.length ? c5(curveRadial(_2)) : c5()._curve;
    };
    return l2;
  }
  function lineRadial_default() {
    return lineRadial(line_default().curve(curveRadialLinear));
  }

  // node_modules/d3-shape/src/areaRadial.js
  function areaRadial_default() {
    var a3 = area_default().curve(curveRadialLinear), c5 = a3.curve, x05 = a3.lineX0, x12 = a3.lineX1, y05 = a3.lineY0, y12 = a3.lineY1;
    a3.angle = a3.x, delete a3.x;
    a3.startAngle = a3.x0, delete a3.x0;
    a3.endAngle = a3.x1, delete a3.x1;
    a3.radius = a3.y, delete a3.y;
    a3.innerRadius = a3.y0, delete a3.y0;
    a3.outerRadius = a3.y1, delete a3.y1;
    a3.lineStartAngle = function() {
      return lineRadial(x05());
    }, delete a3.lineX0;
    a3.lineEndAngle = function() {
      return lineRadial(x12());
    }, delete a3.lineX1;
    a3.lineInnerRadius = function() {
      return lineRadial(y05());
    }, delete a3.lineY0;
    a3.lineOuterRadius = function() {
      return lineRadial(y12());
    }, delete a3.lineY1;
    a3.curve = function(_2) {
      return arguments.length ? c5(curveRadial(_2)) : c5()._curve;
    };
    return a3;
  }

  // node_modules/d3-shape/src/noop.js
  function noop_default2() {
  }

  // node_modules/d3-shape/src/curve/cardinal.js
  function point(that, x3, y3) {
    that._context.bezierCurveTo(
      that._x1 + that._k * (that._x2 - that._x0),
      that._y1 + that._k * (that._y2 - that._y0),
      that._x2 + that._k * (that._x1 - x3),
      that._y2 + that._k * (that._y1 - y3),
      that._x2,
      that._y2
    );
  }
  function Cardinal(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  Cardinal.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          point(this, this._x1, this._y1);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
          this._x1 = x3, this._y1 = y3;
          break;
        case 2:
          this._point = 3;
        // falls through
        default:
          point(this, x3, y3);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var cardinal_default = function custom(tension) {
    function cardinal(context) {
      return new Cardinal(context, tension);
    }
    cardinal.tension = function(tension2) {
      return custom(+tension2);
    };
    return cardinal;
  }(0);

  // node_modules/d3-shape/src/curve/cardinalClosed.js
  function CardinalClosed(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  CardinalClosed.prototype = {
    areaStart: noop_default2,
    areaEnd: noop_default2,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x3, this._y3 = y3;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x3, this._y4 = y3);
          break;
        case 2:
          this._point = 3;
          this._x5 = x3, this._y5 = y3;
          break;
        default:
          point(this, x3, y3);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var cardinalClosed_default = function custom2(tension) {
    function cardinal(context) {
      return new CardinalClosed(context, tension);
    }
    cardinal.tension = function(tension2) {
      return custom2(+tension2);
    };
    return cardinal;
  }(0);

  // node_modules/d3-shape/src/curve/catmullRom.js
  function point2(that, x3, y3) {
    var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
    if (that._l01_a > epsilon) {
      var a3 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
      x12 = (x12 * a3 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2;
      y12 = (y12 * a3 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
    }
    if (that._l23_a > epsilon) {
      var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);
      x22 = (x22 * b + that._x1 * that._l23_2a - x3 * that._l12_2a) / m3;
      y22 = (y22 * b + that._y1 * that._l23_2a - y3 * that._l12_2a) / m3;
    }
    that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
  }
  function CatmullRom(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRom.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          this.point(this._x2, this._y2);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      if (this._point) {
        var x23 = this._x2 - x3, y23 = this._y2 - y3;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
        // falls through
        default:
          point2(this, x3, y3);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var catmullRom_default = function custom3(alpha) {
    function catmullRom(context) {
      return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
    }
    catmullRom.alpha = function(alpha2) {
      return custom3(+alpha2);
    };
    return catmullRom;
  }(0.5);

  // node_modules/d3-shape/src/curve/catmullRomClosed.js
  function CatmullRomClosed(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRomClosed.prototype = {
    areaStart: noop_default2,
    areaEnd: noop_default2,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      if (this._point) {
        var x23 = this._x2 - x3, y23 = this._y2 - y3;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x3, this._y3 = y3;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x3, this._y4 = y3);
          break;
        case 2:
          this._point = 3;
          this._x5 = x3, this._y5 = y3;
          break;
        default:
          point2(this, x3, y3);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var catmullRomClosed_default = function custom4(alpha) {
    function catmullRom(context) {
      return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
    }
    catmullRom.alpha = function(alpha2) {
      return custom4(+alpha2);
    };
    return catmullRom;
  }(0.5);

  // node_modules/d3-shape/src/curve/linearClosed.js
  function LinearClosed(context) {
    this._context = context;
  }
  LinearClosed.prototype = {
    areaStart: noop_default2,
    areaEnd: noop_default2,
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._point) this._context.closePath();
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      if (this._point) this._context.lineTo(x3, y3);
      else this._point = 1, this._context.moveTo(x3, y3);
    }
  };
  function linearClosed_default(context) {
    return new LinearClosed(context);
  }

  // node_modules/d3-shape/src/curve/monotone.js
  function sign(x3) {
    return x3 < 0 ? -1 : 1;
  }
  function slope3(that, x22, y22) {
    var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
  }
  function slope2(that, t) {
    var h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
  }
  function point3(that, t0, t1) {
    var x05 = that._x0, y05 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x05) / 3;
    that._context.bezierCurveTo(x05 + dx, y05 + dx * t0, x12 - dx, y12 - dx * t1, x12, y12);
  }
  function MonotoneX(context) {
    this._context = context;
  }
  MonotoneX.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
        case 3:
          point3(this, this._t0, slope2(this, this._t0));
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      var t1 = NaN;
      x3 = +x3, y3 = +y3;
      if (x3 === this._x1 && y3 === this._y1) return;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          point3(this, slope2(this, t1 = slope3(this, x3, y3)), t1);
          break;
        default:
          point3(this, this._t0, t1 = slope3(this, x3, y3));
          break;
      }
      this._x0 = this._x1, this._x1 = x3;
      this._y0 = this._y1, this._y1 = y3;
      this._t0 = t1;
    }
  };
  function MonotoneY(context) {
    this._context = new ReflectContext(context);
  }
  (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x3, y3) {
    MonotoneX.prototype.point.call(this, y3, x3);
  };
  function ReflectContext(context) {
    this._context = context;
  }
  ReflectContext.prototype = {
    moveTo: function(x3, y3) {
      this._context.moveTo(y3, x3);
    },
    closePath: function() {
      this._context.closePath();
    },
    lineTo: function(x3, y3) {
      this._context.lineTo(y3, x3);
    },
    bezierCurveTo: function(x12, y12, x22, y22, x3, y3) {
      this._context.bezierCurveTo(y12, x12, y22, x22, y3, x3);
    }
  };
  function monotoneX(context) {
    return new MonotoneX(context);
  }
  function monotoneY(context) {
    return new MonotoneY(context);
  }

  // node_modules/d3-shape/src/curve/step.js
  function Step(context, t) {
    this._context = context;
    this._t = t;
  }
  Step.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = this._y = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
        // falls through
        default: {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y3);
            this._context.lineTo(x3, y3);
          } else {
            var x12 = this._x * (1 - this._t) + x3 * this._t;
            this._context.lineTo(x12, this._y);
            this._context.lineTo(x12, y3);
          }
          break;
        }
      }
      this._x = x3, this._y = y3;
    }
  };
  function step_default(context) {
    return new Step(context, 0.5);
  }
  function stepBefore(context) {
    return new Step(context, 0);
  }
  function stepAfter(context) {
    return new Step(context, 1);
  }

  // node_modules/@antv/g2/esm/utils/coordinate.js
  function isTranspose(coordinate) {
    const { transformations } = coordinate.getOptions();
    const transposes = transformations.map(([type]) => type).filter((type) => type === "transpose");
    return transposes.length % 2 !== 0;
  }
  function isPolar(coordinate) {
    const { transformations } = coordinate.getOptions();
    return transformations.some(([type]) => type === "polar");
  }
  function isRadial(coordinate) {
    const { transformations } = coordinate.getOptions();
    return (
      // distinguish radial from theta.
      transformations.some(([type]) => type === "reflect") && transformations.some(([type]) => type.startsWith("transpose"))
    );
  }
  function isHelix(coordinate) {
    const { transformations } = coordinate.getOptions();
    return transformations.some(([type]) => type === "helix");
  }
  function isParallel(coordinate) {
    const { transformations } = coordinate.getOptions();
    return transformations.some(([type]) => type === "parallel");
  }
  function isFisheye(coordinate) {
    const { transformations } = coordinate.getOptions();
    return transformations.some(([type]) => type === "fisheye");
  }
  function isRadar(coordinate) {
    return isParallel(coordinate) && isPolar(coordinate);
  }
  function isCircular(coordinate) {
    return isHelix(coordinate) || isPolar(coordinate);
  }
  function isTheta(coordinate) {
    return isPolar(coordinate) && isTranspose(coordinate);
  }
  function getRadius(coordinate) {
    if (isCircular(coordinate)) {
      const [width, height] = coordinate.getSize();
      const polar = coordinate.getOptions().transformations.find((t) => t[0] === "polar");
      if (polar)
        return Math.max(width, height) / 2 * polar[4];
    }
    return 0;
  }
  function radiusOf(coordinate) {
    const { transformations } = coordinate.getOptions();
    const [, , , innerRadius, outerRadius] = transformations.find((d3) => d3[0] === "polar");
    return [+innerRadius, +outerRadius];
  }
  function angleOf(coordinate, isRadius = true) {
    const { transformations } = coordinate.getOptions();
    const [, startAngle, endAngle] = transformations.find((d3) => d3[0] === "polar");
    return isRadius ? [+startAngle * 180 / Math.PI, +endAngle * 180 / Math.PI] : [startAngle, endAngle];
  }
  function getTransformOptions(coordinate, type) {
    const { transformations } = coordinate.getOptions();
    const [, ...args] = transformations.find((d3) => d3[0] === type);
    return args;
  }

  // node_modules/@babel/runtime/helpers/esm/typeof.js
  function _typeof2(o) {
    "@babel/helpers - typeof";
    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
      return typeof o2;
    } : function(o2) {
      return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
    }, _typeof2(o);
  }

  // node_modules/@babel/runtime/helpers/esm/toPrimitive.js
  function toPrimitive(t, r) {
    if ("object" != _typeof2(t) || !t) return t;
    var e3 = t[Symbol.toPrimitive];
    if (void 0 !== e3) {
      var i = e3.call(t, r || "default");
      if ("object" != _typeof2(i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }

  // node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  function toPropertyKey(t) {
    var i = toPrimitive(t, "string");
    return "symbol" == _typeof2(i) ? i : i + "";
  }

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty2(e3, r, t) {
    return (r = toPropertyKey(r)) in e3 ? Object.defineProperty(e3, r, {
      value: t,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e3[r] = t, e3;
  }

  // node_modules/@babel/runtime/helpers/esm/objectSpread2.js
  function ownKeys2(e3, r) {
    var t = Object.keys(e3);
    if (Object.getOwnPropertySymbols) {
      var o = Object.getOwnPropertySymbols(e3);
      r && (o = o.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e3, r2).enumerable;
      })), t.push.apply(t, o);
    }
    return t;
  }
  function _objectSpread22(e3) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
        _defineProperty2(e3, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
        Object.defineProperty(e3, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e3;
  }

  // node_modules/@babel/runtime/helpers/esm/classCallCheck.js
  function _classCallCheck(a3, n2) {
    if (!(a3 instanceof n2)) throw new TypeError("Cannot call a class as a function");
  }

  // node_modules/@babel/runtime/helpers/esm/createClass.js
  function _defineProperties(e3, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e3, toPropertyKey(o.key), o);
    }
  }
  function _createClass(e3, r, t) {
    return r && _defineProperties(e3.prototype, r), t && _defineProperties(e3, t), Object.defineProperty(e3, "prototype", {
      writable: false
    }), e3;
  }

  // node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
  function _arrayLikeToArray(r, a3) {
    (null == a3 || a3 > r.length) && (a3 = r.length);
    for (var e3 = 0, n2 = Array(a3); e3 < a3; e3++) n2[e3] = r[e3];
    return n2;
  }

  // node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _arrayLikeToArray(r);
  }

  // node_modules/@babel/runtime/helpers/esm/iterableToArray.js
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }

  // node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js
  function _unsupportedIterableToArray(r, a3) {
    if (r) {
      if ("string" == typeof r) return _arrayLikeToArray(r, a3);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a3) : void 0;
    }
  }

  // node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/@babel/runtime/helpers/esm/toConsumableArray.js
  function _toConsumableArray(r) {
    return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
  }

  // node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
  function _getPrototypeOf(t) {
    return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
      return t2.__proto__ || Object.getPrototypeOf(t2);
    }, _getPrototypeOf(t);
  }

  // node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
    } catch (t2) {
    }
    return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
      return !!t;
    })();
  }

  // node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
  function _assertThisInitialized(e3) {
    if (void 0 === e3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e3;
  }

  // node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
  function _possibleConstructorReturn(t, e3) {
    if (e3 && ("object" == _typeof2(e3) || "function" == typeof e3)) return e3;
    if (void 0 !== e3) throw new TypeError("Derived constructors may only return object or undefined");
    return _assertThisInitialized(t);
  }

  // node_modules/@babel/runtime/helpers/esm/callSuper.js
  function _callSuper(t, o, e3) {
    return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e3 || [], _getPrototypeOf(t).constructor) : o.apply(t, e3));
  }

  // node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  function _setPrototypeOf(t, e3) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e4) {
      return t2.__proto__ = e4, t2;
    }, _setPrototypeOf(t, e3);
  }

  // node_modules/@babel/runtime/helpers/esm/inherits.js
  function _inherits(t, e3) {
    if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e3 && e3.prototype, {
      constructor: {
        value: t,
        writable: true,
        configurable: true
      }
    }), Object.defineProperty(t, "prototype", {
      writable: false
    }), e3 && _setPrototypeOf(t, e3);
  }

  // node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }

  // node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
  function _iterableToArrayLimit(r, l2) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e3, n2, i, u, a3 = [], f = true, o = false;
      try {
        if (i = (t = t.call(r)).next, 0 === l2) {
          if (Object(t) !== t) return;
          f = false;
        } else for (; !(f = (e3 = i.call(t)).done) && (a3.push(e3.value), a3.length !== l2); f = true) ;
      } catch (r2) {
        o = true, n2 = r2;
      } finally {
        try {
          if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
        } finally {
          if (o) throw n2;
        }
      }
      return a3;
    }
  }

  // node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  // node_modules/@babel/runtime/helpers/esm/slicedToArray.js
  function _slicedToArray(r, e3) {
    return _arrayWithHoles(r) || _iterableToArrayLimit(r, e3) || _unsupportedIterableToArray(r, e3) || _nonIterableRest();
  }

  // node_modules/eventemitter3/index.mjs
  var import_index = __toESM(require_eventemitter3(), 1);
  var eventemitter3_default = import_index.default;

  // node_modules/@babel/runtime/helpers/esm/superPropBase.js
  function _superPropBase(t, o) {
    for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
    return t;
  }

  // node_modules/@babel/runtime/helpers/esm/get.js
  function _get() {
    return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e3, t, r) {
      var p2 = _superPropBase(e3, t);
      if (p2) {
        var n2 = Object.getOwnPropertyDescriptor(p2, t);
        return n2.get ? n2.get.call(arguments.length < 3 ? e3 : r) : n2.value;
      }
    }, _get.apply(null, arguments);
  }

  // node_modules/@babel/runtime/helpers/esm/superPropGet.js
  function _superPropGet(t, o, e3, r) {
    var p2 = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e3);
    return 2 & r && "function" == typeof p2 ? function(t2) {
      return p2.apply(e3, t2);
    } : p2;
  }

  // node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend4(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format3) {
    var m3, l2;
    format3 = (format3 + "").trim().toLowerCase();
    return (m3 = reHex.exec(format3)) ? (l2 = m3[1].length, m3 = parseInt(m3[1], 16), l2 === 6 ? rgbn(m3) : l2 === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l2 === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l2 === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n2) {
    return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
  }
  function rgba(r, g, b, a3) {
    if (a3 <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a3);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend4(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a3 = clampa(this.opacity);
    return `${a3 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a3 === 1 ? ")" : `, ${a3})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value2) {
    return Math.max(0, Math.min(255, Math.round(value2) || 0));
  }
  function hex(value2) {
    value2 = clampi(value2);
    return (value2 < 16 ? "0" : "") + value2.toString(16);
  }
  function hsla(h, s3, l2, a3) {
    if (a3 <= 0) h = s3 = l2 = NaN;
    else if (l2 <= 0 || l2 >= 1) h = s3 = NaN;
    else if (s3 <= 0) h = NaN;
    return new Hsl(h, s3, l2, a3);
  }
  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl();
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min10 = Math.min(r, g, b), max11 = Math.max(r, g, b), h = NaN, s3 = max11 - min10, l2 = (max11 + min10) / 2;
    if (s3) {
      if (r === max11) h = (g - b) / s3 + (g < b) * 6;
      else if (g === max11) h = (b - r) / s3 + 2;
      else h = (r - g) / s3 + 4;
      s3 /= l2 < 0.5 ? max11 + min10 : 2 - max11 - min10;
      h *= 60;
    } else {
      s3 = l2 > 0 && l2 < 1 ? 0 : h;
    }
    return new Hsl(h, s3, l2, o.opacity);
  }
  function hsl(h, s3, l2, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s3, l2, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s3, l2, opacity) {
    this.h = +h;
    this.s = +s3;
    this.l = +l2;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend4(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s3 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m22 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s3, m1 = 2 * l2 - m22;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m22),
        hsl2rgb(h, m1, m22),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m22),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a3 = clampa(this.opacity);
      return `${a3 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a3 === 1 ? ")" : `, ${a3})`}`;
    }
  }));
  function clamph(value2) {
    value2 = (value2 || 0) % 360;
    return value2 < 0 ? value2 + 360 : value2;
  }
  function clampt(value2) {
    return Math.max(0, Math.min(1, value2 || 0));
  }
  function hsl2rgb(h, m1, m22) {
    return (h < 60 ? m1 + (m22 - m1) * h / 60 : h < 180 ? m22 : h < 240 ? m1 + (m22 - m1) * (240 - h) / 60 : m1) * 255;
  }

  // node_modules/d3-color/src/math.js
  var radians = Math.PI / 180;
  var degrees = 180 / Math.PI;

  // node_modules/d3-color/src/cubehelix.js
  var A = -0.14861;
  var B = 1.78277;
  var C = -0.29227;
  var D = -0.90649;
  var E = 1.97294;
  var ED = E * D;
  var EB = E * B;
  var BC_DA = B * C - D * A;
  function cubehelixConvert(o) {
    if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Rgb)) o = rgbConvert(o);
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, l2 = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l2, k = (E * (g - l2) - C * bl) / D, s3 = Math.sqrt(k * k + bl * bl) / (E * l2 * (1 - l2)), h = s3 ? Math.atan2(k, bl) * degrees - 120 : NaN;
    return new Cubehelix(h < 0 ? h + 360 : h, s3, l2, o.opacity);
  }
  function cubehelix(h, s3, l2, opacity) {
    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s3, l2, opacity == null ? 1 : opacity);
  }
  function Cubehelix(h, s3, l2, opacity) {
    this.h = +h;
    this.s = +s3;
    this.l = +l2;
    this.opacity = +opacity;
  }
  define_default(Cubehelix, cubehelix, extend4(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l2 = +this.l, a3 = isNaN(this.s) ? 0 : this.s * l2 * (1 - l2), cosh = Math.cos(h), sinh = Math.sin(h);
      return new Rgb(
        255 * (l2 + a3 * (A * cosh + B * sinh)),
        255 * (l2 + a3 * (C * cosh + D * sinh)),
        255 * (l2 + a3 * (E * cosh)),
        this.opacity
      );
    }
  }));

  // node_modules/@antv/g-math/dist/index.esm.js
  function distance4(x12, y12, x22, y22) {
    var dx = x12 - x22;
    var dy = y12 - y22;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function getBBoxByArray(xArr, yArr) {
    var minX = Math.min.apply(Math, __spreadArray([], __read(xArr), false));
    var minY = Math.min.apply(Math, __spreadArray([], __read(yArr), false));
    var maxX = Math.max.apply(Math, __spreadArray([], __read(xArr), false));
    var maxY2 = Math.max.apply(Math, __spreadArray([], __read(yArr), false));
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  }
  function xExtrema(rx, ry, xRotation) {
    return Math.atan(-ry / rx * Math.tan(xRotation));
  }
  function yExtrema(rx, ry, xRotation) {
    return Math.atan(ry / (rx * Math.tan(xRotation)));
  }
  function xAt(cx, cy, rx, ry, xRotation, angle4) {
    return rx * Math.cos(xRotation) * Math.cos(angle4) - ry * Math.sin(xRotation) * Math.sin(angle4) + cx;
  }
  function yAt(cx, cy, rx, ry, xRotation, angle4) {
    return rx * Math.sin(xRotation) * Math.cos(angle4) + ry * Math.cos(xRotation) * Math.sin(angle4) + cy;
  }
  function box$5(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var xAngle = xDim + i;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }
    for (var i = 0; i < xs.length; i++) {
      var x3 = xAt(cx, cy, rx, ry, xRotation, xs[i]);
      if (x3 < minX) {
        minX = x3;
      }
      if (x3 > maxX) {
        maxX = x3;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY2 = -Infinity;
    var ys = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var yAngle = yDim + i;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }
    for (var i = 0; i < ys.length; i++) {
      var y3 = yAt(cx, cy, rx, ry, xRotation, ys[i]);
      if (y3 < minY) {
        minY = y3;
      }
      if (y3 > maxY2) {
        maxY2 = y3;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  }
  var EPSILON2 = 1e-4;
  function nearestPoint$2(xArr, yArr, x3, y3, tCallback, length5) {
    var t = -1;
    var d3 = Infinity;
    var v0 = [x3, y3];
    var segNum = 20;
    if (length5 && length5 > 200) {
      segNum = length5 / 10;
    }
    var increaseRate = 1 / segNum;
    var interval2 = increaseRate / 10;
    for (var i = 0; i <= segNum; i++) {
      var _t = i * increaseRate;
      var v1 = [
        tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([_t])), false)),
        tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([_t])), false))
      ];
      var d1 = distance4(v0[0], v0[1], v1[0], v1[1]);
      if (d1 < d3) {
        t = _t;
        d3 = d1;
      }
    }
    if (t === 0) {
      return {
        x: xArr[0],
        y: yArr[0]
      };
    }
    if (t === 1) {
      var count4 = xArr.length;
      return {
        x: xArr[count4 - 1],
        y: yArr[count4 - 1]
      };
    }
    d3 = Infinity;
    for (var i = 0; i < 32; i++) {
      if (interval2 < EPSILON2) {
        break;
      }
      var prev = t - interval2;
      var next = t + interval2;
      var v1 = [
        tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([prev])), false)),
        tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([prev])), false))
      ];
      var d1 = distance4(v0[0], v0[1], v1[0], v1[1]);
      if (prev >= 0 && d1 < d3) {
        t = prev;
        d3 = d1;
      } else {
        var v2 = [
          tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([next])), false)),
          tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([next])), false))
        ];
        var d22 = distance4(v0[0], v0[1], v2[0], v2[1]);
        if (next <= 1 && d22 < d3) {
          t = next;
          d3 = d22;
        } else {
          interval2 *= 0.5;
        }
      }
    }
    return {
      x: tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([t])), false)),
      y: tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([t])), false))
    };
  }
  function length$4(x12, y12, x22, y22) {
    return distance4(x12, y12, x22, y22);
  }
  function pointAt$3(x12, y12, x22, y22, t) {
    return {
      x: (1 - t) * x12 + t * x22,
      y: (1 - t) * y12 + t * y22
    };
  }
  function pointToLine(x12, y12, x22, y22, x3, y3) {
    var d3 = [x22 - x12, y22 - y12];
    if (vec2_exports.exactEquals(d3, [0, 0])) {
      return Math.sqrt((x3 - x12) * (x3 - x12) + (y3 - y12) * (y3 - y12));
    }
    var u = [-d3[1], d3[0]];
    vec2_exports.normalize(u, u);
    var a3 = [x3 - x12, y3 - y12];
    return Math.abs(vec2_exports.dot(a3, u));
  }
  function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
  }
  function extrema$1(p0, p1, p2, p3) {
    var a3 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
    var b = 6 * p0 - 12 * p1 + 6 * p2;
    var c5 = 3 * p1 - 3 * p0;
    var extremas = [];
    var t1;
    var t2;
    var discSqrt;
    if (isNumberEqual(a3, 0)) {
      if (!isNumberEqual(b, 0)) {
        t1 = -c5 / b;
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
      }
    } else {
      var disc = b * b - 4 * a3 * c5;
      if (isNumberEqual(disc, 0)) {
        extremas.push(-b / (2 * a3));
      } else if (disc > 0) {
        discSqrt = Math.sqrt(disc);
        t1 = (-b + discSqrt) / (2 * a3);
        t2 = (-b - discSqrt) / (2 * a3);
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
        if (t2 >= 0 && t2 <= 1) {
          extremas.push(t2);
        }
      }
    }
    return extremas;
  }
  function box$3(x12, y12, x22, y22, x3, y3, x4, y4) {
    var xArr = [x12, x4];
    var yArr = [y12, y4];
    var xExtrema2 = extrema$1(x12, x22, x3, x4);
    var yExtrema2 = extrema$1(y12, y22, y3, y4);
    for (var i = 0; i < xExtrema2.length; i++) {
      xArr.push(cubicAt(x12, x22, x3, x4, xExtrema2[i]));
    }
    for (var i = 0; i < yExtrema2.length; i++) {
      yArr.push(cubicAt(y12, y22, y3, y4, yExtrema2[i]));
    }
    return getBBoxByArray(xArr, yArr);
  }
  function nearestPoint$1(x12, y12, x22, y22, x3, y3, x4, y4, x05, y05, length5) {
    return nearestPoint$2([x12, x22, x3, x4], [y12, y22, y3, y4], x05, y05, cubicAt, length5);
  }
  function pointDistance$3(x12, y12, x22, y22, x3, y3, x4, y4, x05, y05, length5) {
    var point6 = nearestPoint$1(x12, y12, x22, y22, x3, y3, x4, y4, x05, y05, length5);
    return distance4(point6.x, point6.y, x05, y05);
  }
  function lengthOfSegment(points) {
    if (points.length < 2) {
      return 0;
    }
    var totalLength = 0;
    for (var i = 0; i < points.length - 1; i++) {
      var from = points[i];
      var to = points[i + 1];
      totalLength += distance4(from[0], from[1], to[0], to[1]);
    }
    return totalLength;
  }
  function length$2(points) {
    return lengthOfSegment(points);
  }
  function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
  }
  function extrema(p0, p1, p2) {
    var a3 = p0 + p2 - 2 * p1;
    if (isNumberEqual(a3, 0)) {
      return [0.5];
    }
    var rst = (p0 - p1) / a3;
    if (rst <= 1 && rst >= 0) {
      return [rst];
    }
    return [];
  }
  function box(x12, y12, x22, y22, x3, y3) {
    var xExtrema2 = extrema(x12, x22, x3)[0];
    var yExtrema2 = extrema(y12, y22, y3)[0];
    var xArr = [x12, x3];
    var yArr = [y12, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x12, x22, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y12, y22, y3, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  }
  function nearestPoint(x12, y12, x22, y22, x3, y3, x05, y05) {
    return nearestPoint$2([x12, x22, x3], [y12, y22, y3], x05, y05, quadraticAt);
  }
  function pointDistance(x12, y12, x22, y22, x3, y3, x05, y05) {
    var point6 = nearestPoint(x12, y12, x22, y22, x3, y3, x05, y05);
    return distance4(point6.x, point6.y, x05, y05);
  }

  // node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js
  function _regeneratorRuntime() {
    "use strict";
    _regeneratorRuntime = function _regeneratorRuntime2() {
      return e3;
    };
    var t, e3 = {}, r = Object.prototype, n2 = r.hasOwnProperty, o = Object.defineProperty || function(t2, e4, r2) {
      t2[e4] = r2.value;
    }, i = "function" == typeof Symbol ? Symbol : {}, a3 = i.iterator || "@@iterator", c5 = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
    function define2(t2, e4, r2) {
      return Object.defineProperty(t2, e4, {
        value: r2,
        enumerable: true,
        configurable: true,
        writable: true
      }), t2[e4];
    }
    try {
      define2({}, "");
    } catch (t2) {
      define2 = function define3(t3, e4, r2) {
        return t3[e4] = r2;
      };
    }
    function wrap(t2, e4, r2, n3) {
      var i2 = e4 && e4.prototype instanceof Generator ? e4 : Generator, a4 = Object.create(i2.prototype), c6 = new Context2(n3 || []);
      return o(a4, "_invoke", {
        value: makeInvokeMethod(t2, r2, c6)
      }), a4;
    }
    function tryCatch(t2, e4, r2) {
      try {
        return {
          type: "normal",
          arg: t2.call(e4, r2)
        };
      } catch (t3) {
        return {
          type: "throw",
          arg: t3
        };
      }
    }
    e3.wrap = wrap;
    var h = "suspendedStart", l2 = "suspendedYield", f = "executing", s3 = "completed", y3 = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var p2 = {};
    define2(p2, a3, function() {
      return this;
    });
    var d3 = Object.getPrototypeOf, v = d3 && d3(d3(values([])));
    v && v !== r && n2.call(v, a3) && (p2 = v);
    var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p2);
    function defineIteratorMethods(t2) {
      ["next", "throw", "return"].forEach(function(e4) {
        define2(t2, e4, function(t3) {
          return this._invoke(e4, t3);
        });
      });
    }
    function AsyncIterator(t2, e4) {
      function invoke(r3, o2, i2, a4) {
        var c6 = tryCatch(t2[r3], t2, o2);
        if ("throw" !== c6.type) {
          var u2 = c6.arg, h2 = u2.value;
          return h2 && "object" == _typeof2(h2) && n2.call(h2, "__await") ? e4.resolve(h2.__await).then(function(t3) {
            invoke("next", t3, i2, a4);
          }, function(t3) {
            invoke("throw", t3, i2, a4);
          }) : e4.resolve(h2).then(function(t3) {
            u2.value = t3, i2(u2);
          }, function(t3) {
            return invoke("throw", t3, i2, a4);
          });
        }
        a4(c6.arg);
      }
      var r2;
      o(this, "_invoke", {
        value: function value2(t3, n3) {
          function callInvokeWithMethodAndArg() {
            return new e4(function(e6, r3) {
              invoke(t3, n3, e6, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(e4, r2, n3) {
      var o2 = h;
      return function(i2, a4) {
        if (o2 === f) throw Error("Generator is already running");
        if (o2 === s3) {
          if ("throw" === i2) throw a4;
          return {
            value: t,
            done: true
          };
        }
        for (n3.method = i2, n3.arg = a4; ; ) {
          var c6 = n3.delegate;
          if (c6) {
            var u2 = maybeInvokeDelegate(c6, n3);
            if (u2) {
              if (u2 === y3) continue;
              return u2;
            }
          }
          if ("next" === n3.method) n3.sent = n3._sent = n3.arg;
          else if ("throw" === n3.method) {
            if (o2 === h) throw o2 = s3, n3.arg;
            n3.dispatchException(n3.arg);
          } else "return" === n3.method && n3.abrupt("return", n3.arg);
          o2 = f;
          var p3 = tryCatch(e4, r2, n3);
          if ("normal" === p3.type) {
            if (o2 = n3.done ? s3 : l2, p3.arg === y3) continue;
            return {
              value: p3.arg,
              done: n3.done
            };
          }
          "throw" === p3.type && (o2 = s3, n3.method = "throw", n3.arg = p3.arg);
        }
      };
    }
    function maybeInvokeDelegate(e4, r2) {
      var n3 = r2.method, o2 = e4.iterator[n3];
      if (o2 === t) return r2.delegate = null, "throw" === n3 && e4.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e4, r2), "throw" === r2.method) || "return" !== n3 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n3 + "' method")), y3;
      var i2 = tryCatch(o2, e4.iterator, r2.arg);
      if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y3;
      var a4 = i2.arg;
      return a4 ? a4.done ? (r2[e4.resultName] = a4.value, r2.next = e4.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y3) : a4 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y3);
    }
    function pushTryEntry(t2) {
      var e4 = {
        tryLoc: t2[0]
      };
      1 in t2 && (e4.catchLoc = t2[1]), 2 in t2 && (e4.finallyLoc = t2[2], e4.afterLoc = t2[3]), this.tryEntries.push(e4);
    }
    function resetTryEntry(t2) {
      var e4 = t2.completion || {};
      e4.type = "normal", delete e4.arg, t2.completion = e4;
    }
    function Context2(t2) {
      this.tryEntries = [{
        tryLoc: "root"
      }], t2.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(e4) {
      if (e4 || "" === e4) {
        var r2 = e4[a3];
        if (r2) return r2.call(e4);
        if ("function" == typeof e4.next) return e4;
        if (!isNaN(e4.length)) {
          var o2 = -1, i2 = function next() {
            for (; ++o2 < e4.length; ) if (n2.call(e4, o2)) return next.value = e4[o2], next.done = false, next;
            return next.value = t, next.done = true, next;
          };
          return i2.next = i2;
        }
      }
      throw new TypeError(_typeof2(e4) + " is not iterable");
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    }), o(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e3.isGeneratorFunction = function(t2) {
      var e4 = "function" == typeof t2 && t2.constructor;
      return !!e4 && (e4 === GeneratorFunction || "GeneratorFunction" === (e4.displayName || e4.name));
    }, e3.mark = function(t2) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
    }, e3.awrap = function(t2) {
      return {
        __await: t2
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c5, function() {
      return this;
    }), e3.AsyncIterator = AsyncIterator, e3.async = function(t2, r2, n3, o2, i2) {
      void 0 === i2 && (i2 = Promise);
      var a4 = new AsyncIterator(wrap(t2, r2, n3, o2), i2);
      return e3.isGeneratorFunction(r2) ? a4 : a4.next().then(function(t3) {
        return t3.done ? t3.value : a4.next();
      });
    }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a3, function() {
      return this;
    }), define2(g, "toString", function() {
      return "[object Generator]";
    }), e3.keys = function(t2) {
      var e4 = Object(t2), r2 = [];
      for (var n3 in e4) r2.push(n3);
      return r2.reverse(), function next() {
        for (; r2.length; ) {
          var t3 = r2.pop();
          if (t3 in e4) return next.value = t3, next.done = false, next;
        }
        return next.done = true, next;
      };
    }, e3.values = values, Context2.prototype = {
      constructor: Context2,
      reset: function reset(e4) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e4) for (var r2 in this) "t" === r2.charAt(0) && n2.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      },
      stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(e4) {
        if (this.done) throw e4;
        var r2 = this;
        function handle(n3, o3) {
          return a4.type = "throw", a4.arg = e4, r2.next = n3, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a4 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c6 = n2.call(i2, "catchLoc"), u2 = n2.call(i2, "finallyLoc");
            if (c6 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c6) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(t2, e4) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n2.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e4 && e4 <= i2.finallyLoc && (i2 = null);
        var a4 = i2 ? i2.completion : {};
        return a4.type = t2, a4.arg = e4, i2 ? (this.method = "next", this.next = i2.finallyLoc, y3) : this.complete(a4);
      },
      complete: function complete(t2, e4) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e4 && (this.next = e4), y3;
      },
      finish: function finish(t2) {
        for (var e4 = this.tryEntries.length - 1; e4 >= 0; --e4) {
          var r2 = this.tryEntries[e4];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y3;
        }
      },
      "catch": function _catch(t2) {
        for (var e4 = this.tryEntries.length - 1; e4 >= 0; --e4) {
          var r2 = this.tryEntries[e4];
          if (r2.tryLoc === t2) {
            var n3 = r2.completion;
            if ("throw" === n3.type) {
              var o2 = n3.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(e4, r2, n3) {
        return this.delegate = {
          iterator: values(e4),
          resultName: r2,
          nextLoc: n3
        }, "next" === this.method && (this.arg = t), y3;
      }
    }, e3;
  }

  // node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
  function asyncGeneratorStep(n2, t, e3, r, o, a3, c5) {
    try {
      var i = n2[a3](c5), u = i.value;
    } catch (n3) {
      return void e3(n3);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
  }
  function _asyncToGenerator(n2) {
    return function() {
      var t = this, e3 = arguments;
      return new Promise(function(r, o) {
        var a3 = n2.apply(t, e3);
        function _next(n3) {
          asyncGeneratorStep(a3, r, o, _next, _throw, "next", n3);
        }
        function _throw(n3) {
          asyncGeneratorStep(a3, r, o, _next, _throw, "throw", n3);
        }
        _next(void 0);
      });
    };
  }

  // node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js
  function _createForOfIteratorHelper(r, e3) {
    var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (!t) {
      if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e3 && r && "number" == typeof r.length) {
        t && (r = t);
        var _n = 0, F = function F2() {
        };
        return {
          s: F,
          n: function n2() {
            return _n >= r.length ? {
              done: true
            } : {
              done: false,
              value: r[_n++]
            };
          },
          e: function e4(r2) {
            throw r2;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var o, a3 = true, u = false;
    return {
      s: function s3() {
        t = t.call(r);
      },
      n: function n2() {
        var r2 = t.next();
        return a3 = r2.done, r2;
      },
      e: function e4(r2) {
        u = true, o = r2;
      },
      f: function f() {
        try {
          a3 || null == t["return"] || t["return"]();
        } finally {
          if (u) throw o;
        }
      }
    };
  }

  // node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
  function _objectWithoutPropertiesLoose2(r, e3) {
    if (null == r) return {};
    var t = {};
    for (var n2 in r) if ({}.hasOwnProperty.call(r, n2)) {
      if (e3.includes(n2)) continue;
      t[n2] = r[n2];
    }
    return t;
  }

  // node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js
  function _objectWithoutProperties2(e3, t) {
    if (null == e3) return {};
    var o, r, i = _objectWithoutPropertiesLoose2(e3, t);
    if (Object.getOwnPropertySymbols) {
      var s3 = Object.getOwnPropertySymbols(e3);
      for (r = 0; r < s3.length; r++) o = s3[r], t.includes(o) || {}.propertyIsEnumerable.call(e3, o) && (i[o] = e3[o]);
    }
    return i;
  }

  // node_modules/@antv/g-lite/dist/index.esm.js
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var rbush = { exports: {} };
  (function(module, exports) {
    (function(global2, factory) {
      module.exports = factory();
    })(commonjsGlobal, function() {
      function quickselect2(arr, k, left2, right2, compare) {
        quickselectStep(arr, k, left2 || 0, right2 || arr.length - 1, compare || defaultCompare);
      }
      function quickselectStep(arr, k, left2, right2, compare) {
        while (right2 > left2) {
          if (right2 - left2 > 600) {
            var n2 = right2 - left2 + 1;
            var m3 = k - left2 + 1;
            var z = Math.log(n2);
            var s3 = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s3 * (n2 - s3) / n2) * (m3 - n2 / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left2, Math.floor(k - m3 * s3 / n2 + sd));
            var newRight = Math.min(right2, Math.floor(k + (n2 - m3) * s3 / n2 + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
          }
          var t = arr[k];
          var i = left2;
          var j = right2;
          swap2(arr, left2, k);
          if (compare(arr[right2], t) > 0) {
            swap2(arr, left2, right2);
          }
          while (i < j) {
            swap2(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) {
              i++;
            }
            while (compare(arr[j], t) > 0) {
              j--;
            }
          }
          if (compare(arr[left2], t) === 0) {
            swap2(arr, left2, j);
          } else {
            j++;
            swap2(arr, j, right2);
          }
          if (j <= k) {
            left2 = j + 1;
          }
          if (k <= j) {
            right2 = j - 1;
          }
        }
      }
      function swap2(arr, i, j) {
        var tmp2 = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp2;
      }
      function defaultCompare(a3, b) {
        return a3 < b ? -1 : a3 > b ? 1 : 0;
      }
      var RBush2 = function RBush3(maxEntries) {
        if (maxEntries === void 0) maxEntries = 9;
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
      };
      RBush2.prototype.all = function all() {
        return this._all(this.data, []);
      };
      RBush2.prototype.search = function search2(bbox) {
        var node = this.data;
        var result = [];
        if (!intersects2(bbox, node)) {
          return result;
        }
        var toBBox = this.toBBox;
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? toBBox(child) : child;
            if (intersects2(bbox, childBBox)) {
              if (node.leaf) {
                result.push(child);
              } else if (contains(bbox, childBBox)) {
                this._all(child, result);
              } else {
                nodesToSearch.push(child);
              }
            }
          }
          node = nodesToSearch.pop();
        }
        return result;
      };
      RBush2.prototype.collides = function collides(bbox) {
        var node = this.data;
        if (!intersects2(bbox, node)) {
          return false;
        }
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? this.toBBox(child) : child;
            if (intersects2(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) {
                return true;
              }
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      };
      RBush2.prototype.load = function load(data2) {
        if (!(data2 && data2.length)) {
          return this;
        }
        if (data2.length < this._minEntries) {
          for (var i = 0; i < data2.length; i++) {
            this.insert(data2[i]);
          }
          return this;
        }
        var node = this._build(data2.slice(), 0, data2.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      };
      RBush2.prototype.insert = function insert(item) {
        if (item) {
          this._insert(item, this.data.height - 1);
        }
        return this;
      };
      RBush2.prototype.clear = function clear() {
        this.data = createNode2([]);
        return this;
      };
      RBush2.prototype.remove = function remove(item, equalsFn) {
        if (!item) {
          return this;
        }
        var node = this.data;
        var bbox = this.toBBox(item);
        var path2 = [];
        var indexes2 = [];
        var i, parent, goingUp;
        while (node || path2.length) {
          if (!node) {
            node = path2.pop();
            parent = path2[path2.length - 1];
            i = indexes2.pop();
            goingUp = true;
          }
          if (node.leaf) {
            var index4 = findItem(item, node.children, equalsFn);
            if (index4 !== -1) {
              node.children.splice(index4, 1);
              path2.push(node);
              this._condense(path2);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains(node, bbox)) {
            path2.push(node);
            indexes2.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else {
            node = null;
          }
        }
        return this;
      };
      RBush2.prototype.toBBox = function toBBox(item) {
        return item;
      };
      RBush2.prototype.compareMinX = function compareMinX(a3, b) {
        return a3.minX - b.minX;
      };
      RBush2.prototype.compareMinY = function compareMinY(a3, b) {
        return a3.minY - b.minY;
      };
      RBush2.prototype.toJSON = function toJSON() {
        return this.data;
      };
      RBush2.prototype.fromJSON = function fromJSON(data2) {
        this.data = data2;
        return this;
      };
      RBush2.prototype._all = function _all(node, result) {
        var nodesToSearch = [];
        while (node) {
          if (node.leaf) {
            result.push.apply(result, node.children);
          } else {
            nodesToSearch.push.apply(nodesToSearch, node.children);
          }
          node = nodesToSearch.pop();
        }
        return result;
      };
      RBush2.prototype._build = function _build(items, left2, right2, height) {
        var N = right2 - left2 + 1;
        var M2 = this._maxEntries;
        var node;
        if (N <= M2) {
          node = createNode2(items.slice(left2, right2 + 1));
          calcBBox2(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N) / Math.log(M2));
          M2 = Math.ceil(N / Math.pow(M2, height - 1));
        }
        node = createNode2([]);
        node.leaf = false;
        node.height = height;
        var N2 = Math.ceil(N / M2);
        var N1 = N2 * Math.ceil(Math.sqrt(M2));
        multiSelect(items, left2, right2, N1, this.compareMinX);
        for (var i = left2; i <= right2; i += N1) {
          var right22 = Math.min(i + N1 - 1, right2);
          multiSelect(items, i, right22, N2, this.compareMinY);
          for (var j = i; j <= right22; j += N2) {
            var right3 = Math.min(j + N2 - 1, right22);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        calcBBox2(node, this.toBBox);
        return node;
      };
      RBush2.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path2) {
        while (true) {
          path2.push(node);
          if (node.leaf || path2.length - 1 === level) {
            break;
          }
          var minArea = Infinity;
          var minEnlargement = Infinity;
          var targetNode = void 0;
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var area2 = bboxArea(child);
            var enlargement = enlargedArea(bbox, child) - area2;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area2 < minArea ? area2 : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area2 < minArea) {
                minArea = area2;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      };
      RBush2.prototype._insert = function _insert(item, level, isNode) {
        var bbox = isNode ? item : this.toBBox(item);
        var insertPath = [];
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);
        node.children.push(item);
        extend7(node, bbox);
        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);
            level--;
          } else {
            break;
          }
        }
        this._adjustParentBBoxes(bbox, insertPath, level);
      };
      RBush2.prototype._split = function _split(insertPath, level) {
        var node = insertPath[level];
        var M2 = node.children.length;
        var m3 = this._minEntries;
        this._chooseSplitAxis(node, m3, M2);
        var splitIndex = this._chooseSplitIndex(node, m3, M2);
        var newNode = createNode2(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox2(node, this.toBBox);
        calcBBox2(newNode, this.toBBox);
        if (level) {
          insertPath[level - 1].children.push(newNode);
        } else {
          this._splitRoot(node, newNode);
        }
      };
      RBush2.prototype._splitRoot = function _splitRoot(node, newNode) {
        this.data = createNode2([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox2(this.data, this.toBBox);
      };
      RBush2.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m3, M2) {
        var index4;
        var minOverlap = Infinity;
        var minArea = Infinity;
        for (var i = m3; i <= M2 - m3; i++) {
          var bbox1 = distBBox(node, 0, i, this.toBBox);
          var bbox2 = distBBox(node, i, M2, this.toBBox);
          var overlap = intersectionArea2(bbox1, bbox2);
          var area2 = bboxArea(bbox1) + bboxArea(bbox2);
          if (overlap < minOverlap) {
            minOverlap = overlap;
            index4 = i;
            minArea = area2 < minArea ? area2 : minArea;
          } else if (overlap === minOverlap) {
            if (area2 < minArea) {
              minArea = area2;
              index4 = i;
            }
          }
        }
        return index4 || M2 - m3;
      };
      RBush2.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m3, M2) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        var xMargin = this._allDistMargin(node, m3, M2, compareMinX);
        var yMargin = this._allDistMargin(node, m3, M2, compareMinY);
        if (xMargin < yMargin) {
          node.children.sort(compareMinX);
        }
      };
      RBush2.prototype._allDistMargin = function _allDistMargin(node, m3, M2, compare) {
        node.children.sort(compare);
        var toBBox = this.toBBox;
        var leftBBox = distBBox(node, 0, m3, toBBox);
        var rightBBox = distBBox(node, M2 - m3, M2, toBBox);
        var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
        for (var i = m3; i < M2 - m3; i++) {
          var child = node.children[i];
          extend7(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (var i$1 = M2 - m3 - 1; i$1 >= m3; i$1--) {
          var child$1 = node.children[i$1];
          extend7(rightBBox, node.leaf ? toBBox(child$1) : child$1);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      };
      RBush2.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path2, level) {
        for (var i = level; i >= 0; i--) {
          extend7(path2[i], bbox);
        }
      };
      RBush2.prototype._condense = function _condense(path2) {
        for (var i = path2.length - 1, siblings = void 0; i >= 0; i--) {
          if (path2[i].children.length === 0) {
            if (i > 0) {
              siblings = path2[i - 1].children;
              siblings.splice(siblings.indexOf(path2[i]), 1);
            } else {
              this.clear();
            }
          } else {
            calcBBox2(path2[i], this.toBBox);
          }
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn) {
          return items.indexOf(item);
        }
        for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) {
            return i;
          }
        }
        return -1;
      }
      function calcBBox2(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p2, toBBox, destNode) {
        if (!destNode) {
          destNode = createNode2(null);
        }
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k; i < p2; i++) {
          var child = node.children[i];
          extend7(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend7(a3, b) {
        a3.minX = Math.min(a3.minX, b.minX);
        a3.minY = Math.min(a3.minY, b.minY);
        a3.maxX = Math.max(a3.maxX, b.maxX);
        a3.maxY = Math.max(a3.maxY, b.maxY);
        return a3;
      }
      function compareNodeMinX(a3, b) {
        return a3.minX - b.minX;
      }
      function compareNodeMinY(a3, b) {
        return a3.minY - b.minY;
      }
      function bboxArea(a3) {
        return (a3.maxX - a3.minX) * (a3.maxY - a3.minY);
      }
      function bboxMargin(a3) {
        return a3.maxX - a3.minX + (a3.maxY - a3.minY);
      }
      function enlargedArea(a3, b) {
        return (Math.max(b.maxX, a3.maxX) - Math.min(b.minX, a3.minX)) * (Math.max(b.maxY, a3.maxY) - Math.min(b.minY, a3.minY));
      }
      function intersectionArea2(a3, b) {
        var minX = Math.max(a3.minX, b.minX);
        var minY = Math.max(a3.minY, b.minY);
        var maxX = Math.min(a3.maxX, b.maxX);
        var maxY2 = Math.min(a3.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY2 - minY);
      }
      function contains(a3, b) {
        return a3.minX <= b.minX && a3.minY <= b.minY && b.maxX <= a3.maxX && b.maxY <= a3.maxY;
      }
      function intersects2(a3, b) {
        return b.minX <= a3.maxX && b.minY <= a3.maxY && b.maxX >= a3.minX && b.maxY >= a3.minY;
      }
      function createNode2(children) {
        return {
          children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr, left2, right2, n2, compare) {
        var stack = [left2, right2];
        while (stack.length) {
          right2 = stack.pop();
          left2 = stack.pop();
          if (right2 - left2 <= n2) {
            continue;
          }
          var mid2 = left2 + Math.ceil((right2 - left2) / n2 / 2) * n2;
          quickselect2(arr, mid2, left2, right2, compare);
          stack.push(left2, mid2, mid2, right2);
        }
      }
      return RBush2;
    });
  })(rbush);
  var RBush = rbush.exports;
  var Shape = /* @__PURE__ */ function(Shape4) {
    Shape4["GROUP"] = "g";
    Shape4["FRAGMENT"] = "fragment";
    Shape4["CIRCLE"] = "circle";
    Shape4["ELLIPSE"] = "ellipse";
    Shape4["IMAGE"] = "image";
    Shape4["RECT"] = "rect";
    Shape4["LINE"] = "line";
    Shape4["POLYLINE"] = "polyline";
    Shape4["POLYGON"] = "polygon";
    Shape4["TEXT"] = "text";
    Shape4["PATH"] = "path";
    Shape4["HTML"] = "html";
    Shape4["MESH"] = "mesh";
    return Shape4;
  }({});
  var ClipSpaceNearZ = /* @__PURE__ */ function(ClipSpaceNearZ2) {
    ClipSpaceNearZ2[ClipSpaceNearZ2["ZERO"] = 0] = "ZERO";
    ClipSpaceNearZ2[ClipSpaceNearZ2["NEGATIVE_ONE"] = 1] = "NEGATIVE_ONE";
    return ClipSpaceNearZ2;
  }({});
  var AbstractRendererPlugin = /* @__PURE__ */ function() {
    function AbstractRendererPlugin2() {
      _classCallCheck(this, AbstractRendererPlugin2);
      this.plugins = [];
    }
    return _createClass(AbstractRendererPlugin2, [{
      key: "addRenderingPlugin",
      value: function addRenderingPlugin(plugin) {
        this.plugins.push(plugin);
        this.context.renderingPlugins.push(plugin);
      }
    }, {
      key: "removeAllRenderingPlugins",
      value: function removeAllRenderingPlugins() {
        var _this = this;
        this.plugins.forEach(function(plugin) {
          var index4 = _this.context.renderingPlugins.indexOf(plugin);
          if (index4 >= 0) {
            _this.context.renderingPlugins.splice(index4, 1);
          }
        });
      }
    }]);
  }();
  var AbstractRenderer = /* @__PURE__ */ function() {
    function AbstractRenderer2(config2) {
      _classCallCheck(this, AbstractRenderer2);
      this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
      this.plugins = [];
      this.config = _objectSpread22({
        /**
         * only dirty object will cause re-render
         */
        enableDirtyCheck: true,
        enableCulling: false,
        /**
         * enable auto rendering by default
         */
        enableAutoRendering: true,
        /**
         * enable dirty rectangle rendering by default
         */
        enableDirtyRectangleRendering: true,
        enableDirtyRectangleRenderingDebug: false,
        enableSizeAttenuation: true,
        enableRenderingOptimization: false
      }, config2);
    }
    return _createClass(AbstractRenderer2, [{
      key: "registerPlugin",
      value: function registerPlugin(plugin) {
        var index4 = this.plugins.findIndex(function(p2) {
          return p2 === plugin;
        });
        if (index4 === -1) {
          this.plugins.push(plugin);
        }
      }
    }, {
      key: "unregisterPlugin",
      value: function unregisterPlugin(plugin) {
        var index4 = this.plugins.findIndex(function(p2) {
          return p2 === plugin;
        });
        if (index4 > -1) {
          this.plugins.splice(index4, 1);
        }
      }
    }, {
      key: "getPlugins",
      value: function getPlugins() {
        return this.plugins;
      }
    }, {
      key: "getPlugin",
      value: function getPlugin(name2) {
        return this.plugins.find(function(plugin) {
          return plugin.name === name2;
        });
      }
    }, {
      key: "getConfig",
      value: function getConfig2() {
        return this.config;
      }
    }, {
      key: "setConfig",
      value: function setConfig(config2) {
        Object.assign(this.config, config2);
      }
    }]);
  }();
  var addVec3 = vec3_exports.add;
  var copyVec3 = vec3_exports.copy;
  var maxVec3 = vec3_exports.max;
  var minVec3 = vec3_exports.min;
  var scaleVec3 = vec3_exports.scale;
  var subVec3 = vec3_exports.sub;
  var AABB = /* @__PURE__ */ function() {
    function AABB2() {
      _classCallCheck(this, AABB2);
      this.center = [0, 0, 0];
      this.halfExtents = [0, 0, 0];
      this.min = [0, 0, 0];
      this.max = [0, 0, 0];
    }
    return _createClass(AABB2, [{
      key: "update",
      value: function update(center2, halfExtents) {
        copyVec3(this.center, center2);
        copyVec3(this.halfExtents, halfExtents);
        subVec3(this.min, this.center, this.halfExtents);
        addVec3(this.max, this.center, this.halfExtents);
      }
    }, {
      key: "setMinMax",
      value: function setMinMax(min10, max11) {
        addVec3(this.center, max11, min10);
        scaleVec3(this.center, this.center, 0.5);
        subVec3(this.halfExtents, max11, min10);
        scaleVec3(this.halfExtents, this.halfExtents, 0.5);
        copyVec3(this.min, min10);
        copyVec3(this.max, max11);
      }
    }, {
      key: "getMin",
      value: function getMin() {
        return this.min;
      }
    }, {
      key: "getMax",
      value: function getMax() {
        return this.max;
      }
    }, {
      key: "add",
      value: function add11(aabb) {
        if (AABB2.isEmpty(aabb)) {
          return;
        }
        if (AABB2.isEmpty(this)) {
          this.setMinMax(aabb.getMin(), aabb.getMax());
          return;
        }
        var tc = this.center;
        var tcx = tc[0];
        var tcy = tc[1];
        var tcz = tc[2];
        var th = this.halfExtents;
        var thx = th[0];
        var thy = th[1];
        var thz = th[2];
        var tminx = tcx - thx;
        var tmaxx = tcx + thx;
        var tminy = tcy - thy;
        var tmaxy = tcy + thy;
        var tminz = tcz - thz;
        var tmaxz = tcz + thz;
        var oc = aabb.center;
        var ocx = oc[0];
        var ocy = oc[1];
        var ocz = oc[2];
        var oh = aabb.halfExtents;
        var ohx = oh[0];
        var ohy = oh[1];
        var ohz = oh[2];
        var ominx = ocx - ohx;
        var omaxx = ocx + ohx;
        var ominy = ocy - ohy;
        var omaxy = ocy + ohy;
        var ominz = ocz - ohz;
        var omaxz = ocz + ohz;
        if (ominx < tminx) {
          tminx = ominx;
        }
        if (omaxx > tmaxx) {
          tmaxx = omaxx;
        }
        if (ominy < tminy) {
          tminy = ominy;
        }
        if (omaxy > tmaxy) {
          tmaxy = omaxy;
        }
        if (ominz < tminz) {
          tminz = ominz;
        }
        if (omaxz > tmaxz) {
          tmaxz = omaxz;
        }
        tc[0] = (tminx + tmaxx) * 0.5;
        tc[1] = (tminy + tmaxy) * 0.5;
        tc[2] = (tminz + tmaxz) * 0.5;
        th[0] = (tmaxx - tminx) * 0.5;
        th[1] = (tmaxy - tminy) * 0.5;
        th[2] = (tmaxz - tminz) * 0.5;
        this.min[0] = tminx;
        this.min[1] = tminy;
        this.min[2] = tminz;
        this.max[0] = tmaxx;
        this.max[1] = tmaxy;
        this.max[2] = tmaxz;
      }
    }, {
      key: "setFromTransformedAABB",
      value: function setFromTransformedAABB(aabb, m3) {
        var bc = this.center;
        var br = this.halfExtents;
        var ac = aabb.center;
        var ar = aabb.halfExtents;
        var mx0 = m3[0];
        var mx1 = m3[4];
        var mx2 = m3[8];
        var my0 = m3[1];
        var my1 = m3[5];
        var my2 = m3[9];
        var mz0 = m3[2];
        var mz1 = m3[6];
        var mz2 = m3[10];
        var mx0a = Math.abs(mx0);
        var mx1a = Math.abs(mx1);
        var mx2a = Math.abs(mx2);
        var my0a = Math.abs(my0);
        var my1a = Math.abs(my1);
        var my2a = Math.abs(my2);
        var mz0a = Math.abs(mz0);
        var mz1a = Math.abs(mz1);
        var mz2a = Math.abs(mz2);
        bc[0] = m3[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
        bc[1] = m3[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
        bc[2] = m3[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
        br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
        br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
        br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
        subVec3(this.min, bc, br);
        addVec3(this.max, bc, br);
      }
    }, {
      key: "intersects",
      value: function intersects2(aabb) {
        var aMax = this.getMax();
        var aMin = this.getMin();
        var bMax = aabb.getMax();
        var bMin = aabb.getMin();
        return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
      }
    }, {
      key: "intersection",
      value: function intersection(aabb) {
        if (!this.intersects(aabb)) {
          return null;
        }
        var intersection2 = new AABB2();
        var min10 = maxVec3([0, 0, 0], this.getMin(), aabb.getMin());
        var max11 = minVec3([0, 0, 0], this.getMax(), aabb.getMax());
        intersection2.setMinMax(min10, max11);
        return intersection2;
      }
      /**
       * get n-vertex
       * @param plane plane of CullingVolume
       */
    }, {
      key: "getNegativeFarPoint",
      value: function getNegativeFarPoint(plane) {
        if (plane.pnVertexFlag === 273) {
          return copyVec3([0, 0, 0], this.min);
        }
        if (plane.pnVertexFlag === 272) {
          return [this.min[0], this.min[1], this.max[2]];
        }
        if (plane.pnVertexFlag === 257) {
          return [this.min[0], this.max[1], this.min[2]];
        }
        if (plane.pnVertexFlag === 256) {
          return [this.min[0], this.max[1], this.max[2]];
        }
        if (plane.pnVertexFlag === 17) {
          return [this.max[0], this.min[1], this.min[2]];
        }
        if (plane.pnVertexFlag === 16) {
          return [this.max[0], this.min[1], this.max[2]];
        }
        if (plane.pnVertexFlag === 1) {
          return [this.max[0], this.max[1], this.min[2]];
        }
        return [this.max[0], this.max[1], this.max[2]];
      }
      /**
       * get p-vertex
       * @param plane plane of CullingVolume
       */
    }, {
      key: "getPositiveFarPoint",
      value: function getPositiveFarPoint(plane) {
        if (plane.pnVertexFlag === 273) {
          return copyVec3([0, 0, 0], this.max);
        }
        if (plane.pnVertexFlag === 272) {
          return [this.max[0], this.max[1], this.min[2]];
        }
        if (plane.pnVertexFlag === 257) {
          return [this.max[0], this.min[1], this.max[2]];
        }
        if (plane.pnVertexFlag === 256) {
          return [this.max[0], this.min[1], this.min[2]];
        }
        if (plane.pnVertexFlag === 17) {
          return [this.min[0], this.max[1], this.max[2]];
        }
        if (plane.pnVertexFlag === 16) {
          return [this.min[0], this.max[1], this.min[2]];
        }
        if (plane.pnVertexFlag === 1) {
          return [this.min[0], this.min[1], this.max[2]];
        }
        return [this.min[0], this.min[1], this.min[2]];
      }
    }], [{
      key: "isEmpty",
      value: function isEmpty3(aabb) {
        return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
      }
    }]);
  }();
  var Plane = /* @__PURE__ */ function() {
    function Plane2(distance7, normal) {
      _classCallCheck(this, Plane2);
      this.distance = distance7 || 0;
      this.normal = normal || vec3_exports.fromValues(0, 1, 0);
      this.updatePNVertexFlag();
    }
    return _createClass(Plane2, [{
      key: "updatePNVertexFlag",
      value: function updatePNVertexFlag() {
        this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
      }
    }, {
      key: "distanceToPoint",
      value: function distanceToPoint(point6) {
        return vec3_exports.dot(point6, this.normal) - this.distance;
      }
    }, {
      key: "normalize",
      value: function normalize9() {
        var invLen = 1 / vec3_exports.len(this.normal);
        vec3_exports.scale(this.normal, this.normal, invLen);
        this.distance *= invLen;
      }
    }, {
      key: "intersectsLine",
      value: function intersectsLine(start2, end, point6) {
        var d0 = this.distanceToPoint(start2);
        var d1 = this.distanceToPoint(end);
        var t = d0 / (d0 - d1);
        var intersects2 = t >= 0 && t <= 1;
        if (intersects2 && point6) {
          vec3_exports.lerp(point6, start2, end, t);
        }
        return intersects2;
      }
    }]);
  }();
  var Mask = /* @__PURE__ */ function(Mask2) {
    Mask2[Mask2["OUTSIDE"] = 4294967295] = "OUTSIDE";
    Mask2[Mask2["INSIDE"] = 0] = "INSIDE";
    Mask2[Mask2["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
    return Mask2;
  }({});
  var Frustum = /* @__PURE__ */ function() {
    function Frustum2(planes) {
      _classCallCheck(this, Frustum2);
      this.planes = [];
      if (planes) {
        this.planes = planes;
      } else {
        for (var i = 0; i < 6; i++) {
          this.planes.push(new Plane());
        }
      }
    }
    return _createClass(Frustum2, [{
      key: "extractFromVPMatrix",
      value: function extractFromVPMatrix(projectionMatrix) {
        var _projectionMatrix = _slicedToArray(projectionMatrix, 16), m0 = _projectionMatrix[0], m1 = _projectionMatrix[1], m22 = _projectionMatrix[2], m3 = _projectionMatrix[3], m4 = _projectionMatrix[4], m5 = _projectionMatrix[5], m6 = _projectionMatrix[6], m7 = _projectionMatrix[7], m8 = _projectionMatrix[8], m9 = _projectionMatrix[9], m10 = _projectionMatrix[10], m11 = _projectionMatrix[11], m12 = _projectionMatrix[12], m13 = _projectionMatrix[13], m14 = _projectionMatrix[14], m15 = _projectionMatrix[15];
        vec3_exports.set(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
        this.planes[0].distance = m15 - m12;
        vec3_exports.set(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
        this.planes[1].distance = m15 + m12;
        vec3_exports.set(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
        this.planes[2].distance = m15 + m13;
        vec3_exports.set(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
        this.planes[3].distance = m15 - m13;
        vec3_exports.set(this.planes[4].normal, m3 - m22, m7 - m6, m11 - m10);
        this.planes[4].distance = m15 - m14;
        vec3_exports.set(this.planes[5].normal, m3 + m22, m7 + m6, m11 + m10);
        this.planes[5].distance = m15 + m14;
        this.planes.forEach(function(plane) {
          plane.normalize();
          plane.updatePNVertexFlag();
        });
      }
    }]);
  }();
  var Point2 = /* @__PURE__ */ function() {
    function Point6() {
      var x3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      _classCallCheck(this, Point6);
      this.x = 0;
      this.y = 0;
      this.x = x3;
      this.y = y3;
    }
    return _createClass(Point6, [{
      key: "clone",
      value: function clone11() {
        return new Point6(this.x, this.y);
      }
    }, {
      key: "copyFrom",
      value: function copyFrom(p2) {
        this.x = p2.x;
        this.y = p2.y;
      }
    }]);
  }();
  var Rectangle = /* @__PURE__ */ function() {
    function Rectangle2(x3, y3, width, height) {
      _classCallCheck(this, Rectangle2);
      this.x = x3;
      this.y = y3;
      this.width = width;
      this.height = height;
      this.left = x3;
      this.right = x3 + width;
      this.top = y3;
      this.bottom = y3 + height;
    }
    return _createClass(Rectangle2, [{
      key: "toJSON",
      value: function toJSON() {
      }
    }], [{
      key: "fromRect",
      value: (
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMRect/fromRect_static
         */
        function fromRect(rect4) {
          return new Rectangle2(rect4.x, rect4.y, rect4.width, rect4.height);
        }
      )
      /**
       * will return a new rect instance
       */
    }, {
      key: "applyTransform",
      value: function applyTransform2(rect4, matrix3) {
        var topLeft = vec4_exports.fromValues(rect4.x, rect4.y, 0, 1);
        var topRight = vec4_exports.fromValues(rect4.x + rect4.width, rect4.y, 0, 1);
        var bottomLeft = vec4_exports.fromValues(rect4.x, rect4.y + rect4.height, 0, 1);
        var bottomRight = vec4_exports.fromValues(rect4.x + rect4.width, rect4.y + rect4.height, 0, 1);
        var transformedTopLeft = vec4_exports.create();
        var transformedTopRight = vec4_exports.create();
        var transformedBottomLeft = vec4_exports.create();
        var transformedBottomRight = vec4_exports.create();
        vec4_exports.transformMat4(transformedTopLeft, topLeft, matrix3);
        vec4_exports.transformMat4(transformedTopRight, topRight, matrix3);
        vec4_exports.transformMat4(transformedBottomLeft, bottomLeft, matrix3);
        vec4_exports.transformMat4(transformedBottomRight, bottomRight, matrix3);
        var minX = Math.min(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
        var minY = Math.min(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
        var maxX = Math.max(transformedTopLeft[0], transformedTopRight[0], transformedBottomLeft[0], transformedBottomRight[0]);
        var maxY2 = Math.max(transformedTopLeft[1], transformedTopRight[1], transformedBottomLeft[1], transformedBottomRight[1]);
        return Rectangle2.fromRect({
          x: minX,
          y: minY,
          width: maxX - minX,
          height: maxY2 - minY
        });
      }
    }]);
  }();
  var ERROR_MSG_METHOD_NOT_IMPLEMENTED = "Method not implemented.";
  var ERROR_MSG_USE_DOCUMENT_ELEMENT = "Use document.documentElement instead.";
  var ERROR_MSG_APPEND_DESTROYED_ELEMENT = "Cannot append a destroyed element.";
  function getAngle2(angle4) {
    if (angle4 === void 0) {
      return 0;
    }
    if (angle4 > 360 || angle4 < -360) {
      return angle4 % 360;
    }
    return angle4;
  }
  var $vec3$2 = vec3_exports.create();
  function createVec3(x3) {
    var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
    var clone11 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
    if (Array.isArray(x3) && x3.length === 3) {
      return clone11 ? vec3_exports.clone(x3) : vec3_exports.copy($vec3$2, x3);
    }
    if (isNumber2(x3)) {
      return clone11 ? vec3_exports.fromValues(x3, y3, z) : vec3_exports.set($vec3$2, x3, y3, z);
    }
    return clone11 ? vec3_exports.fromValues(x3[0], x3[1] || y3, x3[2] || z) : vec3_exports.set($vec3$2, x3[0], x3[1] || y3, x3[2] || z);
  }
  var DEG_RAD = Math.PI / 180;
  function deg2rad(deg2) {
    return deg2 * DEG_RAD;
  }
  var RAD_DEG = 180 / Math.PI;
  function rad2deg(rad2) {
    return rad2 * RAD_DEG;
  }
  function turn2deg(turn2) {
    return 360 * turn2;
  }
  var HALF_PI = Math.PI / 2;
  function getEulerFromQuat(out, quat2) {
    var x3 = quat2[0];
    var y3 = quat2[1];
    var z = quat2[2];
    var w = quat2[3];
    var x22 = x3 * x3;
    var y22 = y3 * y3;
    var z2 = z * z;
    var w2 = w * w;
    var unit = x22 + y22 + z2 + w2;
    var test = x3 * w - y3 * z;
    if (test > 0.499995 * unit) {
      out[0] = HALF_PI;
      out[1] = 2 * Math.atan2(y3, x3);
      out[2] = 0;
    } else if (test < -0.499995 * unit) {
      out[0] = -HALF_PI;
      out[1] = 2 * Math.atan2(y3, x3);
      out[2] = 0;
    } else {
      out[0] = Math.asin(2 * (x3 * z - w * y3));
      out[1] = Math.atan2(2 * (x3 * w + y3 * z), 1 - 2 * (z2 + w2));
      out[2] = Math.atan2(2 * (x3 * y3 + z * w), 1 - 2 * (y22 + z2));
    }
    return out;
  }
  function getEulerFromMat4(out, m3) {
    var x3;
    var z;
    var _mat4$getScaling = mat4_exports.getScaling(vec3_exports.create(), m3), _mat4$getScaling2 = _slicedToArray(_mat4$getScaling, 3), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1], sz = _mat4$getScaling2[2];
    var y3 = Math.asin(-m3[2] / sx);
    if (y3 < HALF_PI) {
      if (y3 > -HALF_PI) {
        x3 = Math.atan2(m3[6] / sy, m3[10] / sz);
        z = Math.atan2(m3[1] / sx, m3[0] / sx);
      } else {
        z = 0;
        x3 = -Math.atan2(m3[4] / sy, m3[5] / sy);
      }
    } else {
      z = 0;
      x3 = Math.atan2(m3[4] / sy, m3[5] / sy);
    }
    out[0] = x3;
    out[1] = y3;
    out[2] = z;
    return out;
  }
  function getEuler(out, quat2) {
    if (quat2.length === 16) {
      return getEulerFromMat4(out, quat2);
    }
    return getEulerFromQuat(out, quat2);
  }
  function fromRotationTranslationScale2(rotation, x3, y3, scaleX2, scaleY2) {
    var cos3 = Math.cos(rotation);
    var sin3 = Math.sin(rotation);
    return mat3_exports.fromValues(scaleX2 * cos3, scaleY2 * sin3, 0, -scaleX2 * sin3, scaleY2 * cos3, 0, x3, y3, 1);
  }
  function makePerspective(out, left2, right2, top, bottom, near, far) {
    var zero5 = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
    var twoNear = 2 * near;
    var rightMinusLeft = right2 - left2;
    var topMinusBottom = top - bottom;
    var x3 = twoNear / rightMinusLeft;
    var y3 = twoNear / topMinusBottom;
    var a3 = (right2 + left2) / rightMinusLeft;
    var b = (top + bottom) / topMinusBottom;
    var c5;
    var d3;
    var farMinusNear = far - near;
    var farMulNear = far * near;
    if (zero5) {
      c5 = -far / farMinusNear;
      d3 = -farMulNear / farMinusNear;
    } else {
      c5 = -(far + near) / farMinusNear;
      d3 = -2 * farMulNear / farMinusNear;
    }
    out[0] = x3;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = y3;
    out[6] = 0;
    out[7] = 0;
    out[8] = a3;
    out[9] = b;
    out[10] = c5;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = d3;
    out[15] = 0;
    return out;
  }
  function decompose(mat) {
    var row0x = mat[0];
    var row0y = mat[1];
    var row1x = mat[3];
    var row1y = mat[4];
    var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
    var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
    var determinant3 = row0x * row1y - row0y * row1x;
    if (determinant3 < 0) {
      if (row0x < row1y) {
        scalingX = -scalingX;
      } else {
        scalingY = -scalingY;
      }
    }
    if (scalingX) {
      var invScalingX = 1 / scalingX;
      row0x *= invScalingX;
      row0y *= invScalingX;
    }
    if (scalingY) {
      var invScalingY = 1 / scalingY;
      row1x *= invScalingY;
      row1y *= invScalingY;
    }
    var rotation = Math.atan2(row0y, row0x);
    var angle4 = rad2deg(rotation);
    return [mat[6], mat[7], scalingX, scalingY, angle4];
  }
  var tmp = mat4_exports.create();
  var perspectiveMatrix = mat4_exports.create();
  var tmpVec4 = vec4_exports.create();
  var row = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()];
  var pdum3 = vec3_exports.create();
  function decomposeMat4(matrix3, translation, scale10, skew2, perspective2, quaternion) {
    if (!normalize6(tmp, matrix3)) return false;
    mat4_exports.copy(perspectiveMatrix, tmp);
    perspectiveMatrix[3] = 0;
    perspectiveMatrix[7] = 0;
    perspectiveMatrix[11] = 0;
    perspectiveMatrix[15] = 1;
    if (Math.abs(mat4_exports.determinant(perspectiveMatrix)) < 1e-8) return false;
    var a03 = tmp[3];
    var a13 = tmp[7];
    var a23 = tmp[11];
    var a30 = tmp[12];
    var a31 = tmp[13];
    var a32 = tmp[14];
    var a33 = tmp[15];
    if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
      tmpVec4[0] = a03;
      tmpVec4[1] = a13;
      tmpVec4[2] = a23;
      tmpVec4[3] = a33;
      var ret = mat4_exports.invert(perspectiveMatrix, perspectiveMatrix);
      if (!ret) return false;
      mat4_exports.transpose(perspectiveMatrix, perspectiveMatrix);
      vec4_exports.transformMat4(perspective2, tmpVec4, perspectiveMatrix);
    } else {
      perspective2[0] = perspective2[1] = perspective2[2] = 0;
      perspective2[3] = 1;
    }
    translation[0] = a30;
    translation[1] = a31;
    translation[2] = a32;
    mat3from4(row, tmp);
    scale10[0] = vec3_exports.length(row[0]);
    vec3_exports.normalize(row[0], row[0]);
    skew2[0] = vec3_exports.dot(row[0], row[1]);
    combine2(row[1], row[1], row[0], 1, -skew2[0]);
    scale10[1] = vec3_exports.length(row[1]);
    vec3_exports.normalize(row[1], row[1]);
    skew2[0] /= scale10[1];
    skew2[1] = vec3_exports.dot(row[0], row[2]);
    combine2(row[2], row[2], row[0], 1, -skew2[1]);
    skew2[2] = vec3_exports.dot(row[1], row[2]);
    combine2(row[2], row[2], row[1], 1, -skew2[2]);
    scale10[2] = vec3_exports.length(row[2]);
    vec3_exports.normalize(row[2], row[2]);
    skew2[1] /= scale10[2];
    skew2[2] /= scale10[2];
    vec3_exports.cross(pdum3, row[1], row[2]);
    if (vec3_exports.dot(row[0], pdum3) < 0) {
      for (var i = 0; i < 3; i++) {
        scale10[i] *= -1;
        row[i][0] *= -1;
        row[i][1] *= -1;
        row[i][2] *= -1;
      }
    }
    quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
    quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
    quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
    quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
    if (row[2][1] > row[1][2]) quaternion[0] = -quaternion[0];
    if (row[0][2] > row[2][0]) quaternion[1] = -quaternion[1];
    if (row[1][0] > row[0][1]) quaternion[2] = -quaternion[2];
    return true;
  }
  function normalize6(out, mat) {
    var m44 = mat[15];
    if (m44 === 0) return false;
    var scale10 = 1 / m44;
    for (var i = 0; i < 16; i++) out[i] = mat[i] * scale10;
    return true;
  }
  function mat3from4(out, mat4x4) {
    out[0][0] = mat4x4[0];
    out[0][1] = mat4x4[1];
    out[0][2] = mat4x4[2];
    out[1][0] = mat4x4[4];
    out[1][1] = mat4x4[5];
    out[1][2] = mat4x4[6];
    out[2][0] = mat4x4[8];
    out[2][1] = mat4x4[9];
    out[2][2] = mat4x4[10];
  }
  function combine2(out, a3, b, scale1, scale22) {
    out[0] = a3[0] * scale1 + b[0] * scale22;
    out[1] = a3[1] * scale1 + b[1] * scale22;
    out[2] = a3[2] * scale1 + b[2] * scale22;
  }
  var CameraType = /* @__PURE__ */ function(CameraType2) {
    CameraType2[CameraType2["ORBITING"] = 0] = "ORBITING";
    CameraType2[CameraType2["EXPLORING"] = 1] = "EXPLORING";
    CameraType2[CameraType2["TRACKING"] = 2] = "TRACKING";
    return CameraType2;
  }({});
  var CameraTrackingMode = /* @__PURE__ */ function(CameraTrackingMode2) {
    CameraTrackingMode2[CameraTrackingMode2["DEFAULT"] = 0] = "DEFAULT";
    CameraTrackingMode2[CameraTrackingMode2["ROTATIONAL"] = 1] = "ROTATIONAL";
    CameraTrackingMode2[CameraTrackingMode2["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
    CameraTrackingMode2[CameraTrackingMode2["CINEMATIC"] = 3] = "CINEMATIC";
    return CameraTrackingMode2;
  }({});
  var CameraProjectionMode = /* @__PURE__ */ function(CameraProjectionMode2) {
    CameraProjectionMode2[CameraProjectionMode2["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
    CameraProjectionMode2[CameraProjectionMode2["PERSPECTIVE"] = 1] = "PERSPECTIVE";
    return CameraProjectionMode2;
  }({});
  var CameraEvent = {
    UPDATED: "updated"
  };
  var MIN_DISTANCE = 2e-4;
  var Camera = /* @__PURE__ */ function() {
    function Camera2() {
      _classCallCheck(this, Camera2);
      this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
      this.eventEmitter = new eventemitter3_default();
      this.matrix = mat4_exports.create();
      this.right = vec3_exports.fromValues(1, 0, 0);
      this.up = vec3_exports.fromValues(0, 1, 0);
      this.forward = vec3_exports.fromValues(0, 0, 1);
      this.position = vec3_exports.fromValues(0, 0, 1);
      this.focalPoint = vec3_exports.fromValues(0, 0, 0);
      this.distanceVector = vec3_exports.fromValues(0, 0, -1);
      this.distance = 1;
      this.azimuth = 0;
      this.elevation = 0;
      this.roll = 0;
      this.relAzimuth = 0;
      this.relElevation = 0;
      this.relRoll = 0;
      this.dollyingStep = 0;
      this.maxDistance = Infinity;
      this.minDistance = -Infinity;
      this.zoom = 1;
      this.rotateWorld = false;
      this.fov = 30;
      this.near = 0.1;
      this.far = 1e3;
      this.aspect = 1;
      this.projectionMatrix = mat4_exports.create();
      this.projectionMatrixInverse = mat4_exports.create();
      this.jitteredProjectionMatrix = void 0;
      this.enableUpdate = true;
      this.type = CameraType.EXPLORING;
      this.trackingMode = CameraTrackingMode.DEFAULT;
      this.projectionMode = CameraProjectionMode.PERSPECTIVE;
      this.frustum = new Frustum();
      this.orthoMatrix = mat4_exports.create();
    }
    return _createClass(Camera2, [{
      key: "isOrtho",
      value: (
        // constructor(type = CameraType.EXPLORING, trackingMode = CameraTrackingMode.DEFAULT) {
        //   this.setType(type, trackingMode);
        // }
        function isOrtho() {
          return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;
        }
      )
    }, {
      key: "getProjectionMode",
      value: function getProjectionMode() {
        return this.projectionMode;
      }
    }, {
      key: "getPerspective",
      value: function getPerspective() {
        return this.jitteredProjectionMatrix || this.projectionMatrix;
      }
    }, {
      key: "getPerspectiveInverse",
      value: function getPerspectiveInverse() {
        return this.projectionMatrixInverse;
      }
    }, {
      key: "getFrustum",
      value: function getFrustum() {
        return this.frustum;
      }
    }, {
      key: "getPosition",
      value: function getPosition() {
        return this.position;
      }
    }, {
      key: "getFocalPoint",
      value: function getFocalPoint() {
        return this.focalPoint;
      }
    }, {
      key: "getDollyingStep",
      value: function getDollyingStep() {
        return this.dollyingStep;
      }
    }, {
      key: "getNear",
      value: function getNear() {
        return this.near;
      }
    }, {
      key: "getFar",
      value: function getFar() {
        return this.far;
      }
    }, {
      key: "getZoom",
      value: function getZoom() {
        return this.zoom;
      }
    }, {
      key: "getOrthoMatrix",
      value: function getOrthoMatrix() {
        return this.orthoMatrix;
      }
    }, {
      key: "getView",
      value: function getView() {
        return this.view;
      }
    }, {
      key: "setEnableUpdate",
      value: function setEnableUpdate(enabled) {
        this.enableUpdate = enabled;
      }
    }, {
      key: "setType",
      value: function setType(type, trackingMode) {
        this.type = type;
        if (this.type === CameraType.EXPLORING) {
          this.setWorldRotation(true);
        } else {
          this.setWorldRotation(false);
        }
        this._getAngles();
        if (this.type === CameraType.TRACKING && trackingMode !== void 0) {
          this.setTrackingMode(trackingMode);
        }
        return this;
      }
    }, {
      key: "setProjectionMode",
      value: function setProjectionMode(projectionMode) {
        this.projectionMode = projectionMode;
        return this;
      }
    }, {
      key: "setTrackingMode",
      value: function setTrackingMode(trackingMode) {
        if (this.type !== CameraType.TRACKING) {
          throw new Error("Impossible to set a tracking mode if the camera is not of tracking type");
        }
        this.trackingMode = trackingMode;
        return this;
      }
      /**
       * If flag is true, it reverses the azimuth and elevation angles.
       * Subsequent calls to rotate, setAzimuth, setElevation,
       * changeAzimuth or changeElevation will cause the inverted effect.
       * setRoll or changeRoll is not affected by this method.
       *
       * This inversion is useful when one wants to simulate that the world
       * is moving, instead of the camera.
       *
       * By default the camera angles are not reversed.
       * @param {Boolean} flag the boolean flag to reverse the angles.
       */
    }, {
      key: "setWorldRotation",
      value: function setWorldRotation(flag) {
        this.rotateWorld = flag;
        this._getAngles();
        return this;
      }
      /**
       * 计算 MV 矩阵，为相机矩阵的逆矩阵
       */
    }, {
      key: "getViewTransform",
      value: function getViewTransform() {
        return mat4_exports.invert(mat4_exports.create(), this.matrix);
      }
    }, {
      key: "getWorldTransform",
      value: function getWorldTransform() {
        return this.matrix;
      }
    }, {
      key: "jitterProjectionMatrix",
      value: function jitterProjectionMatrix(x3, y3) {
        var translation = mat4_exports.fromTranslation(mat4_exports.create(), [x3, y3, 0]);
        this.jitteredProjectionMatrix = mat4_exports.multiply(mat4_exports.create(), translation, this.projectionMatrix);
      }
    }, {
      key: "clearJitterProjectionMatrix",
      value: function clearJitterProjectionMatrix() {
        this.jitteredProjectionMatrix = void 0;
      }
      /**
       * 设置相机矩阵
       */
    }, {
      key: "setMatrix",
      value: function setMatrix(matrix3) {
        this.matrix = matrix3;
        this._update();
        return this;
      }
      /**
       * Set projection matrix manually.
       */
    }, {
      key: "setProjectionMatrix",
      value: function setProjectionMatrix(matrix3) {
        this.projectionMatrix = matrix3;
      }
    }, {
      key: "setFov",
      value: function setFov(fov) {
        this.setPerspective(this.near, this.far, fov, this.aspect);
        return this;
      }
    }, {
      key: "setAspect",
      value: function setAspect(aspect) {
        this.setPerspective(this.near, this.far, this.fov, aspect);
        return this;
      }
    }, {
      key: "setNear",
      value: function setNear(near) {
        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(near, this.far, this.fov, this.aspect);
        } else {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
        }
        return this;
      }
    }, {
      key: "setFar",
      value: function setFar(far) {
        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(this.near, far, this.fov, this.aspect);
        } else {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
        }
        return this;
      }
      /**
       * Sets an offset in a larger frustum, used in PixelPicking
       */
    }, {
      key: "setViewOffset",
      value: function setViewOffset(fullWidth, fullHeight, x3, y3, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === void 0) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x3;
        this.view.offsetY = y3;
        this.view.width = width;
        this.view.height = height;
        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(this.near, this.far, this.fov, this.aspect);
        } else {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
        }
        return this;
      }
    }, {
      key: "clearViewOffset",
      value: function clearViewOffset() {
        if (this.view !== void 0) {
          this.view.enabled = false;
        }
        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(this.near, this.far, this.fov, this.aspect);
        } else {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
        }
        return this;
      }
    }, {
      key: "setZoom",
      value: function setZoom(zoom) {
        this.zoom = zoom;
        if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
        } else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(this.near, this.far, this.fov, this.aspect);
        }
        return this;
      }
      /**
       * Zoom by specified point in viewport coordinates.
       */
    }, {
      key: "setZoomByViewportPoint",
      value: function setZoomByViewportPoint(zoom, viewportPoint) {
        var _this$canvas$viewport = this.canvas.viewport2Canvas({
          x: viewportPoint[0],
          y: viewportPoint[1]
        }), ox = _this$canvas$viewport.x, oy = _this$canvas$viewport.y;
        var roll = this.roll;
        this.rotate(0, 0, -roll);
        this.setPosition(ox, oy);
        this.setFocalPoint(ox, oy);
        this.setZoom(zoom);
        this.rotate(0, 0, roll);
        var _this$canvas$viewport2 = this.canvas.viewport2Canvas({
          x: viewportPoint[0],
          y: viewportPoint[1]
        }), cx = _this$canvas$viewport2.x, cy = _this$canvas$viewport2.y;
        var dvec = vec3_exports.fromValues(cx - ox, cy - oy, 0);
        var dx = vec3_exports.dot(dvec, this.right) / vec3_exports.length(this.right);
        var dy = vec3_exports.dot(dvec, this.up) / vec3_exports.length(this.up);
        var _this$getPosition = this.getPosition(), _this$getPosition2 = _slicedToArray(_this$getPosition, 2), px2 = _this$getPosition2[0], py = _this$getPosition2[1];
        var _this$getFocalPoint = this.getFocalPoint(), _this$getFocalPoint2 = _slicedToArray(_this$getFocalPoint, 2), fx = _this$getFocalPoint2[0], fy = _this$getFocalPoint2[1];
        this.setPosition(px2 - dx, py - dy);
        this.setFocalPoint(fx - dx, fy - dy);
        return this;
      }
    }, {
      key: "setPerspective",
      value: function setPerspective(near, far, fov, aspect) {
        var _this$view;
        this.projectionMode = CameraProjectionMode.PERSPECTIVE;
        this.fov = fov;
        this.near = near;
        this.far = far;
        this.aspect = aspect;
        var top = this.near * Math.tan(deg2rad(0.5 * this.fov)) / this.zoom;
        var height = 2 * top;
        var width = this.aspect * height;
        var left2 = -0.5 * width;
        if ((_this$view = this.view) !== null && _this$view !== void 0 && _this$view.enabled) {
          var fullWidth = this.view.fullWidth;
          var fullHeight = this.view.fullHeight;
          left2 += this.view.offsetX * width / fullWidth;
          top -= this.view.offsetY * height / fullHeight;
          width *= this.view.width / fullWidth;
          height *= this.view.height / fullHeight;
        }
        makePerspective(this.projectionMatrix, left2, left2 + width, top - height, top, near, this.far, this.clipSpaceNearZ === ClipSpaceNearZ.ZERO);
        mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "setOrthographic",
      value: function setOrthographic(l2, r, t, b, near, far) {
        var _this$view2;
        this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;
        this.rright = r;
        this.left = l2;
        this.top = t;
        this.bottom = b;
        this.near = near;
        this.far = far;
        var dx = (this.rright - this.left) / (2 * this.zoom);
        var dy = (this.top - this.bottom) / (2 * this.zoom);
        var cx = (this.rright + this.left) / 2;
        var cy = (this.top + this.bottom) / 2;
        var left2 = cx - dx;
        var right2 = cx + dx;
        var top = cy + dy;
        var bottom = cy - dy;
        if ((_this$view2 = this.view) !== null && _this$view2 !== void 0 && _this$view2.enabled) {
          var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
          var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          left2 += scaleW * this.view.offsetX;
          right2 = left2 + scaleW * this.view.width;
          top -= scaleH * this.view.offsetY;
          bottom = top - scaleH * this.view.height;
        }
        if (this.clipSpaceNearZ === ClipSpaceNearZ.NEGATIVE_ONE) {
          mat4_exports.ortho(this.projectionMatrix, left2, right2, top, bottom, near, far);
        } else {
          mat4_exports.orthoZO(this.projectionMatrix, left2, right2, top, bottom, near, far);
        }
        mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
        this._getOrthoMatrix();
        this.triggerUpdate();
        return this;
      }
      /**
       * Move the camera in world coordinates.
       * It will keep looking at the current focal point.
       *
       * support scalars or vectors.
       * @example
       * setPosition(1, 2, 3);
       * setPosition([1, 2, 3]);
       */
    }, {
      key: "setPosition",
      value: function setPosition(x3) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.position[1];
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.position[2];
        var position = createVec3(x3, y3, z);
        this._setPosition(position);
        this.setFocalPoint(this.focalPoint);
        this.triggerUpdate();
        return this;
      }
      /**
       * Sets the focal point of this camera in world coordinates.
       *
       * support scalars or vectors.
       * @example
       * setFocalPoint(1, 2, 3);
       * setFocalPoint([1, 2, 3]);
       */
    }, {
      key: "setFocalPoint",
      value: function setFocalPoint(x3) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.focalPoint[1];
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : this.focalPoint[2];
        var up = vec3_exports.fromValues(0, 1, 0);
        this.focalPoint = createVec3(x3, y3, z);
        if (this.trackingMode === CameraTrackingMode.CINEMATIC) {
          var d3 = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
          x3 = d3[0];
          y3 = d3[1];
          z = d3[2];
          var r = vec3_exports.length(d3);
          var el = rad2deg(Math.asin(y3 / r));
          var az = 90 + rad2deg(Math.atan2(z, x3));
          var m3 = mat4_exports.create();
          mat4_exports.rotateY(m3, m3, deg2rad(az));
          mat4_exports.rotateX(m3, m3, deg2rad(el));
          up = vec3_exports.transformMat4(vec3_exports.create(), [0, 1, 0], m3);
        }
        mat4_exports.invert(this.matrix, mat4_exports.lookAt(mat4_exports.create(), this.position, this.focalPoint, up));
        this._getAxes();
        this._getDistance();
        this._getAngles();
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "getDistance",
      value: function getDistance() {
        return this.distance;
      }
    }, {
      key: "getDistanceVector",
      value: function getDistanceVector() {
        return this.distanceVector;
      }
      /**
       * Moves the camera towards/from the focal point.
       */
    }, {
      key: "setDistance",
      value: function setDistance(d3) {
        if (this.distance === d3 || d3 < 0) {
          return this;
        }
        this.distance = d3;
        if (this.distance < MIN_DISTANCE) {
          this.distance = MIN_DISTANCE;
        }
        this.dollyingStep = this.distance / 100;
        var pos = vec3_exports.create();
        d3 = this.distance;
        var n2 = this.forward;
        var f = this.focalPoint;
        pos[0] = d3 * n2[0] + f[0];
        pos[1] = d3 * n2[1] + f[1];
        pos[2] = d3 * n2[2] + f[2];
        this._setPosition(pos);
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "setMaxDistance",
      value: function setMaxDistance(d3) {
        this.maxDistance = d3;
        return this;
      }
    }, {
      key: "setMinDistance",
      value: function setMinDistance(d3) {
        this.minDistance = d3;
        return this;
      }
      /**
       * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
       * the azimuth in degrees
       */
    }, {
      key: "setAzimuth",
      value: function setAzimuth(az) {
        this.azimuth = getAngle2(az);
        this.computeMatrix();
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "getAzimuth",
      value: function getAzimuth() {
        return this.azimuth;
      }
      /**
       * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
       */
    }, {
      key: "setElevation",
      value: function setElevation(el) {
        this.elevation = getAngle2(el);
        this.computeMatrix();
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "getElevation",
      value: function getElevation() {
        return this.elevation;
      }
      /**
       * 设置相机方位角，不同相机模式下需要重新计算相机位置或者是视点位置
       */
    }, {
      key: "setRoll",
      value: function setRoll(angle4) {
        this.roll = getAngle2(angle4);
        this.computeMatrix();
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "getRoll",
      value: function getRoll() {
        return this.roll;
      }
      /**
       * 根据相机矩阵重新计算各种相机参数
       */
    }, {
      key: "_update",
      value: function _update() {
        this._getAxes();
        this._getPosition();
        this._getDistance();
        this._getAngles();
        this._getOrthoMatrix();
        this.triggerUpdate();
      }
      /**
       * 计算相机矩阵
       */
    }, {
      key: "computeMatrix",
      value: function computeMatrix() {
        var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad(this.roll));
        mat4_exports.identity(this.matrix);
        var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.elevation));
        var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.azimuth));
        var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
        rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
        var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          mat4_exports.translate(this.matrix, this.matrix, this.focalPoint);
          mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
          mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
        } else if (this.type === CameraType.TRACKING) {
          mat4_exports.translate(this.matrix, this.matrix, this.position);
          mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
        }
      }
      /**
       * Sets the camera position in the camera matrix
       */
    }, {
      key: "_setPosition",
      value: function _setPosition(x3, y3, z) {
        this.position = createVec3(x3, y3, z);
        var m3 = this.matrix;
        m3[12] = this.position[0];
        m3[13] = this.position[1];
        m3[14] = this.position[2];
        m3[15] = 1;
        this._getOrthoMatrix();
      }
      /**
       * Recalculates axes based on the current matrix
       */
    }, {
      key: "_getAxes",
      value: function _getAxes() {
        vec3_exports.copy(this.right, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [1, 0, 0, 0], this.matrix)));
        vec3_exports.copy(this.up, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 1, 0, 0], this.matrix)));
        vec3_exports.copy(this.forward, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 1, 0], this.matrix)));
        vec3_exports.normalize(this.right, this.right);
        vec3_exports.normalize(this.up, this.up);
        vec3_exports.normalize(this.forward, this.forward);
      }
      /**
       * Recalculates euler angles based on the current state
       */
    }, {
      key: "_getAngles",
      value: function _getAngles() {
        var x3 = this.distanceVector[0];
        var y3 = this.distanceVector[1];
        var z = this.distanceVector[2];
        var r = vec3_exports.length(this.distanceVector);
        if (r === 0) {
          this.elevation = 0;
          this.azimuth = 0;
          return;
        }
        if (this.type === CameraType.TRACKING) {
          this.elevation = rad2deg(Math.asin(y3 / r));
          this.azimuth = rad2deg(Math.atan2(-x3, -z));
        } else if (this.rotateWorld) {
          this.elevation = rad2deg(Math.asin(y3 / r));
          this.azimuth = rad2deg(Math.atan2(-x3, -z));
        } else {
          this.elevation = -rad2deg(Math.asin(y3 / r));
          this.azimuth = -rad2deg(Math.atan2(-x3, -z));
        }
      }
      /**
       * 重新计算相机位置，只有 ORBITING 模式相机位置才会发生变化
       */
    }, {
      key: "_getPosition",
      value: function _getPosition() {
        vec3_exports.copy(this.position, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 0, 1], this.matrix)));
        this._getDistance();
      }
      /**
       * 重新计算视点，只有 TRACKING 模式视点才会发生变化
       */
    }, {
      key: "_getFocalPoint",
      value: function _getFocalPoint() {
        vec3_exports.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3_exports.fromMat4(mat3_exports.create(), this.matrix));
        vec3_exports.add(this.focalPoint, this.position, this.distanceVector);
        this._getDistance();
      }
      /**
       * 重新计算视距
       */
    }, {
      key: "_getDistance",
      value: function _getDistance() {
        this.distanceVector = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
        this.distance = vec3_exports.length(this.distanceVector);
        this.dollyingStep = this.distance / 100;
      }
    }, {
      key: "_getOrthoMatrix",
      value: function _getOrthoMatrix() {
        if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {
          return;
        }
        var position = this.position;
        var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], -this.roll * Math.PI / 180);
        mat4_exports.fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, vec3_exports.fromValues((this.rright - this.left) / 2 - position[0], (this.top - this.bottom) / 2 - position[1], 0), vec3_exports.fromValues(this.zoom, this.zoom, 1), position);
      }
    }, {
      key: "triggerUpdate",
      value: function triggerUpdate() {
        if (this.enableUpdate) {
          var viewMatrix = this.getViewTransform();
          var vpMatrix = mat4_exports.multiply(mat4_exports.create(), this.getPerspective(), viewMatrix);
          this.getFrustum().extractFromVPMatrix(vpMatrix);
          this.eventEmitter.emit(CameraEvent.UPDATED);
        }
      }
    }, {
      key: "rotate",
      value: function rotate5(azimuth, elevation, roll) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "pan",
      value: function pan(tx, ty) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "dolly",
      value: function dolly(value2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "createLandmark",
      value: function createLandmark(name2, params) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "gotoLandmark",
      value: function gotoLandmark(name2, options) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "cancelLandmarkAnimation",
      value: function cancelLandmarkAnimation() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }]);
  }();
  var Strategy = /* @__PURE__ */ function(Strategy2) {
    Strategy2[Strategy2["Standard"] = 0] = "Standard";
    return Strategy2;
  }({});
  var SortReason = /* @__PURE__ */ function(SortReason2) {
    SortReason2[SortReason2["ADDED"] = 0] = "ADDED";
    SortReason2[SortReason2["REMOVED"] = 1] = "REMOVED";
    SortReason2[SortReason2["Z_INDEX_CHANGED"] = 2] = "Z_INDEX_CHANGED";
    return SortReason2;
  }({});
  var EMPTY_PARSED_PATH = {
    absolutePath: [],
    hasArc: false,
    segments: [],
    polygons: [],
    polylines: [],
    curve: null,
    totalLength: 0,
    rect: new Rectangle(0, 0, 0, 0)
  };
  var PropertySyntax = /* @__PURE__ */ function(PropertySyntax2) {
    PropertySyntax2["COORDINATE"] = "<coordinate>";
    PropertySyntax2["COLOR"] = "<color>";
    PropertySyntax2["PAINT"] = "<paint>";
    PropertySyntax2["NUMBER"] = "<number>";
    PropertySyntax2["ANGLE"] = "<angle>";
    PropertySyntax2["OPACITY_VALUE"] = "<opacity-value>";
    PropertySyntax2["SHADOW_BLUR"] = "<shadow-blur>";
    PropertySyntax2["LENGTH"] = "<length>";
    PropertySyntax2["PERCENTAGE"] = "<percentage>";
    PropertySyntax2["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
    PropertySyntax2["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
    PropertySyntax2["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
    PropertySyntax2["LIST_OF_POINTS"] = "<list-of-points>";
    PropertySyntax2["PATH"] = "<path>";
    PropertySyntax2["FILTER"] = "<filter>";
    PropertySyntax2["Z_INDEX"] = "<z-index>";
    PropertySyntax2["OFFSET_DISTANCE"] = "<offset-distance>";
    PropertySyntax2["DEFINED_PATH"] = "<defined-path>";
    PropertySyntax2["MARKER"] = "<marker>";
    PropertySyntax2["TRANSFORM"] = "<transform>";
    PropertySyntax2["TRANSFORM_ORIGIN"] = "<transform-origin>";
    PropertySyntax2["TEXT"] = "<text>";
    PropertySyntax2["TEXT_TRANSFORM"] = "<text-transform>";
    return PropertySyntax2;
  }({});
  function memoize2(func, resolver) {
    if (typeof func !== "function" || resolver != null && typeof resolver !== "function") {
      throw new TypeError("Expected a function");
    }
    var _memoized = function memoized() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var key = resolver ? resolver.apply(this, args) : args[0];
      var cache3 = _memoized.cache;
      if (cache3.has(key)) {
        return cache3.get(key);
      }
      var result = func.apply(this, args);
      _memoized.cache = cache3.set(key, result) || cache3;
      return result;
    };
    _memoized.cache = new (memoize2.Cache || Map)();
    return _memoized;
  }
  memoize2.Cache = Map;
  var UnitType = /* @__PURE__ */ function(UnitType2) {
    UnitType2[UnitType2["kUnknown"] = 0] = "kUnknown";
    UnitType2[UnitType2["kNumber"] = 1] = "kNumber";
    UnitType2[UnitType2["kPercentage"] = 2] = "kPercentage";
    UnitType2[UnitType2["kEms"] = 3] = "kEms";
    UnitType2[UnitType2["kPixels"] = 4] = "kPixels";
    UnitType2[UnitType2["kRems"] = 5] = "kRems";
    UnitType2[UnitType2["kDegrees"] = 6] = "kDegrees";
    UnitType2[UnitType2["kRadians"] = 7] = "kRadians";
    UnitType2[UnitType2["kGradians"] = 8] = "kGradians";
    UnitType2[UnitType2["kTurns"] = 9] = "kTurns";
    UnitType2[UnitType2["kMilliseconds"] = 10] = "kMilliseconds";
    UnitType2[UnitType2["kSeconds"] = 11] = "kSeconds";
    UnitType2[UnitType2["kInteger"] = 12] = "kInteger";
    return UnitType2;
  }({});
  var UnitCategory = /* @__PURE__ */ function(UnitCategory2) {
    UnitCategory2[UnitCategory2["kUNumber"] = 0] = "kUNumber";
    UnitCategory2[UnitCategory2["kUPercent"] = 1] = "kUPercent";
    UnitCategory2[UnitCategory2["kULength"] = 2] = "kULength";
    UnitCategory2[UnitCategory2["kUAngle"] = 3] = "kUAngle";
    UnitCategory2[UnitCategory2["kUTime"] = 4] = "kUTime";
    UnitCategory2[UnitCategory2["kUOther"] = 5] = "kUOther";
    return UnitCategory2;
  }({});
  var Nested = /* @__PURE__ */ function(Nested2) {
    Nested2[Nested2["kYes"] = 0] = "kYes";
    Nested2[Nested2["kNo"] = 1] = "kNo";
    return Nested2;
  }({});
  var ParenLess = /* @__PURE__ */ function(ParenLess2) {
    ParenLess2[ParenLess2["kYes"] = 0] = "kYes";
    ParenLess2[ParenLess2["kNo"] = 1] = "kNo";
    return ParenLess2;
  }({});
  var data = [
    {
      name: "em",
      unit_type: UnitType.kEms
    },
    // {
    //   name: 'ex',
    //   unit_type: UnitType.kExs,
    // },
    {
      name: "px",
      unit_type: UnitType.kPixels
    },
    // {
    //   name: "cm",
    //   unit_type: UnitType.kCentimeters,
    // },
    // {
    //   name: "mm",
    //   unit_type: UnitType.kMillimeters,
    // },
    // {
    //   name: "q",
    //   unit_type: UnitType.kQuarterMillimeters,
    // },
    // {
    //   name: "in",
    //   unit_type: UnitType.kInches,
    // },
    // {
    //   name: "pt",
    //   unit_type: UnitType.kPoints,
    // },
    // {
    //   name: "pc",
    //   unit_type: UnitType.kPicas,
    // },
    {
      name: "deg",
      unit_type: UnitType.kDegrees
    },
    {
      name: "rad",
      unit_type: UnitType.kRadians
    },
    {
      name: "grad",
      unit_type: UnitType.kGradians
    },
    {
      name: "ms",
      unit_type: UnitType.kMilliseconds
    },
    {
      name: "s",
      unit_type: UnitType.kSeconds
    },
    // {
    //   name: "hz",
    //   unit_type: UnitType.kHertz,
    // },
    // {
    //   name: "khz",
    //   unit_type: UnitType.kKilohertz,
    // },
    // {
    //   name: "dpi",
    //   unit_type: "kDotsPerInch",
    // },
    // {
    //   name: "dpcm",
    //   unit_type: "kDotsPerCentimeter",
    // },
    // {
    //   name: "dppx",
    //   unit_type: "kDotsPerPixel",
    // },
    // {
    //   name: "x",
    //   unit_type: "kDotsPerPixel",
    // },
    // {
    //   name: "vw",
    //   unit_type: "kViewportWidth",
    // },
    // {
    //   name: "vh",
    //   unit_type: "kViewportHeight",
    // },
    // {
    //   name: "vi",
    //   unit_type: "kViewportInlineSize",
    // },
    // {
    //   name: "vb",
    //   unit_type: "kViewportBlockSize",
    // },
    // {
    //   name: "vmin",
    //   unit_type: UnitType.kViewportMin,
    // },
    // {
    //   name: "vmax",
    //   unit_type: UnitType.kViewportMax,
    // },
    // {
    //   name: "svw",
    //   unit_type: "kSmallViewportWidth",
    // },
    // {
    //   name: "svh",
    //   unit_type: "kSmallViewportHeight",
    // },
    // {
    //   name: "svi",
    //   unit_type: "kSmallViewportInlineSize",
    // },
    // {
    //   name: "svb",
    //   unit_type: "kSmallViewportBlockSize",
    // },
    // {
    //   name: "svmin",
    //   unit_type: "kSmallViewportMin",
    // },
    // {
    //   name: "svmax",
    //   unit_type: "kSmallViewportMax",
    // },
    // {
    //   name: "lvw",
    //   unit_type: "kLargeViewportWidth",
    // },
    // {
    //   name: "lvh",
    //   unit_type: "kLargeViewportHeight",
    // },
    // {
    //   name: "lvi",
    //   unit_type: "kLargeViewportInlineSize",
    // },
    // {
    //   name: "lvb",
    //   unit_type: "kLargeViewportBlockSize",
    // },
    // {
    //   name: "lvmin",
    //   unit_type: UnitType.kLargeViewportMin,
    // },
    // {
    //   name: "lvmax",
    //   unit_type: UnitType.kLargeViewportMax,
    // },
    // {
    //   name: "dvw",
    //   unit_type: UnitType.kDynamicViewportWidth,
    // },
    // {
    //   name: "dvh",
    //   unit_type: UnitType.kDynamicViewportHeight,
    // },
    // {
    //   name: "dvi",
    //   unit_type: UnitType.kDynamicViewportInlineSize,
    // },
    // {
    //   name: "dvb",
    //   unit_type: UnitType.kDynamicViewportBlockSize,
    // },
    // {
    //   name: "dvmin",
    //   unit_type: UnitType.kDynamicViewportMin,
    // },
    // {
    //   name: "dvmax",
    //   unit_type: UnitType.kDynamicViewportMax,
    // },
    // {
    //   name: "cqw",
    //   unit_type: UnitType.kContainerWidth,
    // },
    // {
    //   name: "cqh",
    //   unit_type: UnitType.kContainerHeight,
    // },
    // {
    //   name: "cqi",
    //   unit_type: UnitType.kContainerInlineSize,
    // },
    // {
    //   name: "cqb",
    //   unit_type: UnitType.kContainerBlockSize,
    // },
    // {
    //   name: "cqmin",
    //   unit_type: UnitType.kContainerMin,
    // },
    // {
    //   name: "cqmax",
    //   unit_type: UnitType.kContainerMax,
    // },
    {
      name: "rem",
      unit_type: UnitType.kRems
    },
    // {
    //   name: 'fr',
    //   unit_type: UnitType.kFraction,
    // },
    {
      name: "turn",
      unit_type: UnitType.kTurns
    }
    // {
    //   name: 'ch',
    //   unit_type: UnitType.kChs,
    // },
    // {
    //   name: '__qem',
    //   unit_type: UnitType.kQuirkyEms,
    // },
  ];
  var CSSStyleValueType = /* @__PURE__ */ function(CSSStyleValueType2) {
    CSSStyleValueType2[CSSStyleValueType2["kUnknownType"] = 0] = "kUnknownType";
    CSSStyleValueType2[CSSStyleValueType2["kUnparsedType"] = 1] = "kUnparsedType";
    CSSStyleValueType2[CSSStyleValueType2["kKeywordType"] = 2] = "kKeywordType";
    CSSStyleValueType2[CSSStyleValueType2["kUnitType"] = 3] = "kUnitType";
    CSSStyleValueType2[CSSStyleValueType2["kSumType"] = 4] = "kSumType";
    CSSStyleValueType2[CSSStyleValueType2["kProductType"] = 5] = "kProductType";
    CSSStyleValueType2[CSSStyleValueType2["kNegateType"] = 6] = "kNegateType";
    CSSStyleValueType2[CSSStyleValueType2["kInvertType"] = 7] = "kInvertType";
    CSSStyleValueType2[CSSStyleValueType2["kMinType"] = 8] = "kMinType";
    CSSStyleValueType2[CSSStyleValueType2["kMaxType"] = 9] = "kMaxType";
    CSSStyleValueType2[CSSStyleValueType2["kClampType"] = 10] = "kClampType";
    CSSStyleValueType2[CSSStyleValueType2["kTransformType"] = 11] = "kTransformType";
    CSSStyleValueType2[CSSStyleValueType2["kPositionType"] = 12] = "kPositionType";
    CSSStyleValueType2[CSSStyleValueType2["kURLImageType"] = 13] = "kURLImageType";
    CSSStyleValueType2[CSSStyleValueType2["kColorType"] = 14] = "kColorType";
    CSSStyleValueType2[CSSStyleValueType2["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
    return CSSStyleValueType2;
  }({});
  var stringToUnitType = function stringToUnitType2(name2) {
    return data.find(function(item) {
      return item.name === name2;
    }).unit_type;
  };
  var unitFromName = function unitFromName2(name2) {
    if (!name2) {
      return UnitType.kUnknown;
    }
    if (name2 === "number") {
      return UnitType.kNumber;
    }
    if (name2 === "percent" || name2 === "%") {
      return UnitType.kPercentage;
    }
    return stringToUnitType(name2);
  };
  var unitTypeToUnitCategory = function unitTypeToUnitCategory2(type) {
    switch (type) {
      case UnitType.kNumber:
      case UnitType.kInteger:
        return UnitCategory.kUNumber;
      case UnitType.kPercentage:
        return UnitCategory.kUPercent;
      case UnitType.kPixels:
        return UnitCategory.kULength;
      case UnitType.kMilliseconds:
      case UnitType.kSeconds:
        return UnitCategory.kUTime;
      case UnitType.kDegrees:
      case UnitType.kRadians:
      case UnitType.kGradians:
      case UnitType.kTurns:
        return UnitCategory.kUAngle;
      // case UnitType.kHertz:
      // case UnitType.kKilohertz:
      //   return UnitCategory.kUFrequency;
      // case UnitType.kDotsPerPixel:
      // case UnitType.kDotsPerInch:
      // case UnitType.kDotsPerCentimeter:
      //   return UnitCategory.kUResolution;
      default:
        return UnitCategory.kUOther;
    }
  };
  var canonicalUnitTypeForCategory = function canonicalUnitTypeForCategory2(category) {
    switch (category) {
      case UnitCategory.kUNumber:
        return UnitType.kNumber;
      case UnitCategory.kULength:
        return UnitType.kPixels;
      case UnitCategory.kUPercent:
        return UnitType.kPercentage;
      // return UnitType.kUnknown; // Cannot convert between numbers and percent.
      case UnitCategory.kUTime:
        return UnitType.kSeconds;
      case UnitCategory.kUAngle:
        return UnitType.kDegrees;
      // case UnitCategory.kUFrequency:
      //   return UnitType.kHertz;
      // case UnitCategory.kUResolution:
      //   return UnitType.kDotsPerPixel;
      default:
        return UnitType.kUnknown;
    }
  };
  var conversionToCanonicalUnitsScaleFactor = function conversionToCanonicalUnitsScaleFactor2(unit_type) {
    var factor = 1;
    switch (unit_type) {
      // These are "canonical" units in their respective categories.
      case UnitType.kPixels:
      // case UnitType.kUserUnits:
      case UnitType.kDegrees:
      case UnitType.kSeconds:
        break;
      case UnitType.kMilliseconds:
        factor = 1e-3;
        break;
      // case UnitType.kCentimeters:
      //   // factor = kCssPixelsPerCentimeter;
      //   break;
      // case UnitType.kDotsPerCentimeter:
      //   // factor = 1 / kCssPixelsPerCentimeter;
      //   break;
      // case UnitType.kMillimeters:
      //   // factor = kCssPixelsPerMillimeter;
      //   break;
      // case UnitType.kQuarterMillimeters:
      //   // factor = kCssPixelsPerQuarterMillimeter;
      //   break;
      // case UnitType.kInches:
      //   // factor = kCssPixelsPerInch;
      //   break;
      // case UnitType.kDotsPerInch:
      //   // factor = 1 / kCssPixelsPerInch;
      //   break;
      // case UnitType.kPoints:
      //   // factor = kCssPixelsPerPoint;
      //   break;
      // case UnitType.kPicas:
      //   // factor = kCssPixelsPerPica;
      //   break;
      case UnitType.kRadians:
        factor = 180 / Math.PI;
        break;
      case UnitType.kGradians:
        factor = 0.9;
        break;
      case UnitType.kTurns:
        factor = 360;
        break;
    }
    return factor;
  };
  var unitTypeToString = function unitTypeToString2(type) {
    switch (type) {
      case UnitType.kNumber:
      case UnitType.kInteger:
        return "";
      case UnitType.kPercentage:
        return "%";
      case UnitType.kEms:
        return "em";
      // case UnitType.kExs:
      //   return 'ex';
      case UnitType.kRems:
        return "rem";
      // case UnitType.kChs:
      //   return 'ch';
      case UnitType.kPixels:
        return "px";
      // case UnitType.kCentimeters:
      //   return 'cm';
      // case UnitType.kDotsPerPixel:
      //   return 'dppx';
      // case UnitType.kDotsPerInch:
      //   return 'dpi';
      // case UnitType.kDotsPerCentimeter:
      //   return 'dpcm';
      // case UnitType.kMillimeters:
      //   return 'mm';
      // case UnitType.kQuarterMillimeters:
      //   return 'q';
      // case UnitType.kInches:
      //   return 'in';
      // case UnitType.kPoints:
      //   return 'pt';
      // case UnitType.kPicas:
      //   return 'pc';
      case UnitType.kDegrees:
        return "deg";
      case UnitType.kRadians:
        return "rad";
      case UnitType.kGradians:
        return "grad";
      case UnitType.kMilliseconds:
        return "ms";
      case UnitType.kSeconds:
        return "s";
      // case UnitType.kHertz:
      //   return 'hz';
      // case UnitType.kKilohertz:
      //   return 'khz';
      case UnitType.kTurns:
        return "turn";
    }
    return "";
  };
  var CSSStyleValue = /* @__PURE__ */ function() {
    function CSSStyleValue2() {
      _classCallCheck(this, CSSStyleValue2);
    }
    return _createClass(CSSStyleValue2, [{
      key: "toString",
      value: (
        // protected abstract toCSSValue(): CSSValue;
        function toString2() {
          return this.buildCSSText(Nested.kNo, ParenLess.kNo, "");
        }
      )
    }, {
      key: "isNumericValue",
      value: function isNumericValue() {
        return this.getType() >= CSSStyleValueType.kUnitType && this.getType() <= CSSStyleValueType.kClampType;
      }
    }], [{
      key: "isAngle",
      value: (
        // static parse(propertyName: string, value: string): CSSStyleValue {
        //   return parseCSSStyleValue(propertyName, value)[0];
        // }
        // static parseAll(propertyName: string, value: string): CSSStyleValue[] {
        //   return parseCSSStyleValue(propertyName, value);
        // }
        function isAngle(unit) {
          return unit === UnitType.kDegrees || unit === UnitType.kRadians || unit === UnitType.kGradians || unit === UnitType.kTurns;
        }
      )
      // static isViewportPercentageLength(type: UnitType) {
      //   return type >= UnitType.kViewportWidth && type <= UnitType.kDynamicViewportMax;
      // }
      // static isContainerPercentageLength(type: UnitType) {
      //   return type >= UnitType.kContainerWidth && type <= UnitType.kContainerMax;
      // }
    }, {
      key: "isLength",
      value: function isLength(type) {
        return type >= UnitType.kEms && type < UnitType.kDegrees;
      }
    }, {
      key: "isRelativeUnit",
      value: function isRelativeUnit(type) {
        return type === UnitType.kPercentage || type === UnitType.kEms || // type === UnitType.kExs ||
        type === UnitType.kRems;
      }
    }, {
      key: "isTime",
      value: function isTime(unit) {
        return unit === UnitType.kSeconds || unit === UnitType.kMilliseconds;
      }
      // static isFrequency(unit: UnitType) {
      //   return unit == UnitType.kHertz || unit == UnitType.kKilohertz;
      // }
      // static isResolution(type: UnitType) {
      //   return type >= UnitType.kDotsPerPixel && type <= UnitType.kDotsPerCentimeter;
      // }
      // static isFlex(unit: UnitType) {
      //   return unit === UnitType.kFraction;
      // }
    }]);
  }();
  var CSSColorValue = /* @__PURE__ */ function(_CSSStyleValue) {
    function CSSColorValue2(colorSpace) {
      var _this;
      _classCallCheck(this, CSSColorValue2);
      _this = _callSuper(this, CSSColorValue2);
      _this.colorSpace = colorSpace;
      return _this;
    }
    _inherits(CSSColorValue2, _CSSStyleValue);
    return _createClass(CSSColorValue2, [{
      key: "getType",
      value: function getType2() {
        return CSSStyleValueType.kColorType;
      }
      /**
       * @see https://drafts.css-houdini.org/css-typed-om-1/#dom-csscolorvalue-to
       */
    }, {
      key: "to",
      value: function to(colorSpace) {
        return this;
      }
    }]);
  }(CSSStyleValue);
  var GradientType = /* @__PURE__ */ function(GradientType2) {
    GradientType2[GradientType2["Constant"] = 0] = "Constant";
    GradientType2[GradientType2["LinearGradient"] = 1] = "LinearGradient";
    GradientType2[GradientType2["RadialGradient"] = 2] = "RadialGradient";
    return GradientType2;
  }({});
  var CSSGradientValue = /* @__PURE__ */ function(_CSSStyleValue) {
    function CSSGradientValue2(type, value2) {
      var _this;
      _classCallCheck(this, CSSGradientValue2);
      _this = _callSuper(this, CSSGradientValue2);
      _this.type = type;
      _this.value = value2;
      return _this;
    }
    _inherits(CSSGradientValue2, _CSSStyleValue);
    return _createClass(CSSGradientValue2, [{
      key: "clone",
      value: function clone11() {
        return new CSSGradientValue2(this.type, this.value);
      }
    }, {
      key: "buildCSSText",
      value: function buildCSSText(n2, p2, result) {
        return result;
      }
    }, {
      key: "getType",
      value: function getType2() {
        return CSSStyleValueType.kColorType;
      }
    }]);
  }(CSSStyleValue);
  var CSSKeywordValue = /* @__PURE__ */ function(_CSSStyleValue) {
    function CSSKeywordValue2(value2) {
      var _this;
      _classCallCheck(this, CSSKeywordValue2);
      _this = _callSuper(this, CSSKeywordValue2);
      _this.value = value2;
      return _this;
    }
    _inherits(CSSKeywordValue2, _CSSStyleValue);
    return _createClass(CSSKeywordValue2, [{
      key: "clone",
      value: function clone11() {
        return new CSSKeywordValue2(this.value);
      }
    }, {
      key: "getType",
      value: function getType2() {
        return CSSStyleValueType.kKeywordType;
      }
    }, {
      key: "buildCSSText",
      value: function buildCSSText(n2, p2, result) {
        return result + this.value;
      }
    }]);
  }(CSSStyleValue);
  var formatInfinityOrNaN = function formatInfinityOrNaN2(number3) {
    var suffix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    var result = "";
    if (!Number.isFinite(number3)) {
      if (number3 > 0) result = "infinity";
      else result = "-infinity";
    } else {
      result = "NaN";
    }
    return result += suffix;
  };
  var toCanonicalUnit = function toCanonicalUnit2(unit) {
    return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));
  };
  var CSSUnitValue = /* @__PURE__ */ function(_CSSStyleValue) {
    function CSSUnitValue2(value2) {
      var _this;
      var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType.kNumber;
      _classCallCheck(this, CSSUnitValue2);
      _this = _callSuper(this, CSSUnitValue2);
      var unit;
      if (typeof unitOrName === "string") {
        unit = unitFromName(unitOrName);
      } else {
        unit = unitOrName;
      }
      _this.unit = unit;
      _this.value = value2;
      return _this;
    }
    _inherits(CSSUnitValue2, _CSSStyleValue);
    return _createClass(CSSUnitValue2, [{
      key: "clone",
      value: function clone11() {
        return new CSSUnitValue2(this.value, this.unit);
      }
    }, {
      key: "equals",
      value: function equals7(other) {
        var other_unit_value = other;
        return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
      }
    }, {
      key: "getType",
      value: function getType2() {
        return CSSStyleValueType.kUnitType;
      }
    }, {
      key: "convertTo",
      value: function convertTo(target_unit) {
        if (this.unit === target_unit) {
          return new CSSUnitValue2(this.value, this.unit);
        }
        var canonical_unit = toCanonicalUnit(this.unit);
        if (canonical_unit !== toCanonicalUnit(target_unit) || canonical_unit === UnitType.kUnknown) {
          return null;
        }
        var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) / conversionToCanonicalUnitsScaleFactor(target_unit);
        return new CSSUnitValue2(this.value * scale_factor, target_unit);
      }
    }, {
      key: "buildCSSText",
      value: function buildCSSText(n2, p2, result) {
        var text;
        switch (this.unit) {
          case UnitType.kUnknown:
            break;
          case UnitType.kInteger:
            text = Number(this.value).toFixed(0);
            break;
          case UnitType.kNumber:
          case UnitType.kPercentage:
          case UnitType.kEms:
          // case UnitType.kQuirkyEms:
          // case UnitType.kExs:
          case UnitType.kRems:
          // case UnitType.kChs:
          case UnitType.kPixels:
          // case UnitType.kCentimeters:
          // case UnitType.kDotsPerPixel:
          // case UnitType.kDotsPerInch:
          // case UnitType.kDotsPerCentimeter:
          // case UnitType.kMillimeters:
          // case UnitType.kQuarterMillimeters:
          // case UnitType.kInches:
          // case UnitType.kPoints:
          // case UnitType.kPicas:
          // case UnitType.kUserUnits:
          case UnitType.kDegrees:
          case UnitType.kRadians:
          case UnitType.kGradians:
          case UnitType.kMilliseconds:
          case UnitType.kSeconds:
          // case UnitType.kHertz:
          // case UnitType.kKilohertz:
          case UnitType.kTurns: {
            var kMinInteger = -999999;
            var kMaxInteger = 999999;
            var value2 = this.value;
            var unit = unitTypeToString(this.unit);
            if (value2 < kMinInteger || value2 > kMaxInteger) {
              var _unit = unitTypeToString(this.unit);
              if (!Number.isFinite(value2) || Number.isNaN(value2)) {
                text = formatInfinityOrNaN(value2, _unit);
              } else {
                text = value2 + (_unit || "");
              }
            } else {
              text = "".concat(value2).concat(unit);
            }
          }
        }
        result += text;
        return result;
      }
    }]);
  }(CSSStyleValue);
  var Opx = new CSSUnitValue(0, "px");
  new CSSUnitValue(1, "px");
  var Odeg = new CSSUnitValue(0, "deg");
  var CSSRGB = /* @__PURE__ */ function(_CSSColorValue) {
    function CSSRGB2(r, g, b) {
      var _this;
      var alpha = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
      var isNone = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      _classCallCheck(this, CSSRGB2);
      _this = _callSuper(this, CSSRGB2, ["rgb"]);
      _this.r = r;
      _this.g = g;
      _this.b = b;
      _this.alpha = alpha;
      _this.isNone = isNone;
      return _this;
    }
    _inherits(CSSRGB2, _CSSColorValue);
    return _createClass(CSSRGB2, [{
      key: "clone",
      value: function clone11() {
        return new CSSRGB2(this.r, this.g, this.b, this.alpha);
      }
    }, {
      key: "buildCSSText",
      value: function buildCSSText(n2, p2, result) {
        return "".concat(result, "rgba(").concat(this.r, ",").concat(this.g, ",").concat(this.b, ",").concat(this.alpha, ")");
      }
    }]);
  }(CSSColorValue);
  var unsetKeywordValue = new CSSKeywordValue("unset");
  var initialKeywordValue = new CSSKeywordValue("initial");
  var inheritKeywordValue = new CSSKeywordValue("inherit");
  var keywordCache = {
    "": unsetKeywordValue,
    unset: unsetKeywordValue,
    initial: initialKeywordValue,
    inherit: inheritKeywordValue
  };
  var getOrCreateKeyword = function getOrCreateKeyword2(name2) {
    if (!keywordCache[name2]) {
      keywordCache[name2] = new CSSKeywordValue(name2);
    }
    return keywordCache[name2];
  };
  var noneColor = new CSSRGB(0, 0, 0, 0, true);
  var transparentColor = new CSSRGB(0, 0, 0, 0);
  var getOrCreateRGBA = memoize2(function(r, g, b, a3) {
    return new CSSRGB(r, g, b, a3);
  }, function(r, g, b, a3) {
    return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a3, ")");
  });
  var getOrCreateUnitValue = function getOrCreateUnitValue2(value2) {
    var unitOrName = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : UnitType.kNumber;
    return new CSSUnitValue(value2, unitOrName);
  };
  new CSSUnitValue(50, "%");
  function colorStopToString(colorStop) {
    var type = colorStop.type, value2 = colorStop.value;
    if (type === "hex") {
      return "#".concat(value2);
    }
    if (type === "literal") {
      return value2;
    }
    if (type === "rgb") {
      return "rgb(".concat(value2.join(","), ")");
    }
    return "rgba(".concat(value2.join(","), ")");
  }
  var parseGradient$1 = /* @__PURE__ */ function() {
    var tokens4 = {
      linearGradient: /^(linear\-gradient)/i,
      repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
      radialGradient: /^(radial\-gradient)/i,
      repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
      /**
       * @see https://projects.verou.me/conic-gradient/
       */
      conicGradient: /^(conic\-gradient)/i,
      sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
      extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
      positionKeywords: /^(left|center|right|top|bottom)/i,
      pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
      percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
      emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
      angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
      startCall: /^\(/,
      endCall: /^\)/,
      comma: /^,/,
      hexColor: /^\#([0-9a-fA-F]+)/,
      literalColor: /^([a-zA-Z]+)/,
      rgbColor: /^rgb/i,
      rgbaColor: /^rgba/i,
      number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
    };
    var input = "";
    function error4(msg) {
      throw new Error("".concat(input, ": ").concat(msg));
    }
    function getAST() {
      var ast = matchListDefinitions();
      if (input.length > 0) {
        error4("Invalid input not EOF");
      }
      return ast;
    }
    function matchListDefinitions() {
      return matchListing(matchDefinition);
    }
    function matchDefinition() {
      return matchGradient("linear-gradient", tokens4.linearGradient, matchLinearOrientation) || matchGradient("repeating-linear-gradient", tokens4.repeatingLinearGradient, matchLinearOrientation) || matchGradient("radial-gradient", tokens4.radialGradient, matchListRadialOrientations) || matchGradient("repeating-radial-gradient", tokens4.repeatingRadialGradient, matchListRadialOrientations) || matchGradient("conic-gradient", tokens4.conicGradient, matchListRadialOrientations);
    }
    function matchGradient(gradientType, pattern, orientationMatcher) {
      return matchCall(pattern, function(captures) {
        var orientation = orientationMatcher();
        if (orientation) {
          if (!scan(tokens4.comma)) {
            error4("Missing comma before color stops");
          }
        }
        return {
          type: gradientType,
          orientation,
          colorStops: matchListing(matchColorStop)
        };
      });
    }
    function matchCall(pattern, callback) {
      var captures = scan(pattern);
      if (captures) {
        if (!scan(tokens4.startCall)) {
          error4("Missing (");
        }
        var result = callback(captures);
        if (!scan(tokens4.endCall)) {
          error4("Missing )");
        }
        return result;
      }
    }
    function matchLinearOrientation() {
      return matchSideOrCorner() || matchAngle();
    }
    function matchSideOrCorner() {
      return match2("directional", tokens4.sideOrCorner, 1);
    }
    function matchAngle() {
      return match2("angular", tokens4.angleValue, 1);
    }
    function matchListRadialOrientations() {
      var radialOrientations;
      var radialOrientation = matchRadialOrientation();
      var lookaheadCache;
      if (radialOrientation) {
        radialOrientations = [];
        radialOrientations.push(radialOrientation);
        lookaheadCache = input;
        if (scan(tokens4.comma)) {
          radialOrientation = matchRadialOrientation();
          if (radialOrientation) {
            radialOrientations.push(radialOrientation);
          } else {
            input = lookaheadCache;
          }
        }
      }
      return radialOrientations;
    }
    function matchRadialOrientation() {
      var radialType = matchCircle() || matchEllipse();
      if (radialType) {
        radialType.at = matchAtPosition();
      } else {
        var extent2 = matchExtentKeyword();
        if (extent2) {
          radialType = extent2;
          var positionAt = matchAtPosition();
          if (positionAt) {
            radialType.at = positionAt;
          }
        } else {
          var defaultPosition = matchPositioning();
          if (defaultPosition) {
            radialType = {
              type: "default-radial",
              // @ts-ignore
              at: defaultPosition
            };
          }
        }
      }
      return radialType;
    }
    function matchCircle() {
      var circle3 = match2("shape", /^(circle)/i, 0);
      if (circle3) {
        circle3.style = matchLength() || matchExtentKeyword();
      }
      return circle3;
    }
    function matchEllipse() {
      var ellipse = match2("shape", /^(ellipse)/i, 0);
      if (ellipse) {
        ellipse.style = matchDistance() || matchExtentKeyword();
      }
      return ellipse;
    }
    function matchExtentKeyword() {
      return match2("extent-keyword", tokens4.extentKeywords, 1);
    }
    function matchAtPosition() {
      if (match2("position", /^at/, 0)) {
        var positioning = matchPositioning();
        if (!positioning) {
          error4("Missing positioning value");
        }
        return positioning;
      }
    }
    function matchPositioning() {
      var location2 = matchCoordinates();
      if (location2.x || location2.y) {
        return {
          type: "position",
          value: location2
        };
      }
    }
    function matchCoordinates() {
      return {
        x: matchDistance(),
        y: matchDistance()
      };
    }
    function matchListing(matcher) {
      var captures = matcher();
      var result = [];
      if (captures) {
        result.push(captures);
        while (scan(tokens4.comma)) {
          captures = matcher();
          if (captures) {
            result.push(captures);
          } else {
            error4("One extra comma");
          }
        }
      }
      return result;
    }
    function matchColorStop() {
      var color2 = matchColor();
      if (!color2) {
        error4("Expected color definition");
      }
      color2.length = matchDistance();
      return color2;
    }
    function matchColor() {
      return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
    }
    function matchLiteralColor() {
      return match2("literal", tokens4.literalColor, 0);
    }
    function matchHexColor() {
      return match2("hex", tokens4.hexColor, 1);
    }
    function matchRGBColor() {
      return matchCall(tokens4.rgbColor, function() {
        return {
          type: "rgb",
          value: matchListing(matchNumber)
        };
      });
    }
    function matchRGBAColor() {
      return matchCall(tokens4.rgbaColor, function() {
        return {
          type: "rgba",
          value: matchListing(matchNumber)
        };
      });
    }
    function matchNumber() {
      return scan(tokens4.number)[1];
    }
    function matchDistance() {
      return match2("%", tokens4.percentageValue, 1) || matchPositionKeyword() || matchLength();
    }
    function matchPositionKeyword() {
      return match2("position-keyword", tokens4.positionKeywords, 1);
    }
    function matchLength() {
      return match2("px", tokens4.pixelValue, 1) || match2("em", tokens4.emValue, 1);
    }
    function match2(type, pattern, captureIndex) {
      var captures = scan(pattern);
      if (captures) {
        return {
          type,
          value: captures[captureIndex]
        };
      }
    }
    function scan(regexp) {
      var blankCaptures = /^[\n\r\t\s]+/.exec(input);
      if (blankCaptures) {
        consume(blankCaptures[0].length);
      }
      var captures = regexp.exec(input);
      if (captures) {
        consume(captures[0].length);
      }
      return captures;
    }
    function consume(size2) {
      input = input.substring(size2);
    }
    return function(code) {
      input = code;
      return getAST();
    };
  }();
  function computeLinearGradient(min10, width, height, angle4) {
    var rad2 = deg2rad(angle4.value);
    var rx = 0;
    var ry = 0;
    var rcx = rx + width / 2;
    var rcy = ry + height / 2;
    var length5 = Math.abs(width * Math.cos(rad2)) + Math.abs(height * Math.sin(rad2));
    var x12 = min10[0] + rcx - Math.cos(rad2) * length5 / 2;
    var y12 = min10[1] + rcy - Math.sin(rad2) * length5 / 2;
    var x22 = min10[0] + rcx + Math.cos(rad2) * length5 / 2;
    var y22 = min10[1] + rcy + Math.sin(rad2) * length5 / 2;
    return {
      x1: x12,
      y1: y12,
      x2: x22,
      y2: y22
    };
  }
  function computeRadialGradient(min10, width, height, cx, cy, size2) {
    var x3 = cx.value;
    var y3 = cy.value;
    if (cx.unit === UnitType.kPercentage) {
      x3 = cx.value / 100 * width;
    }
    if (cy.unit === UnitType.kPercentage) {
      y3 = cy.value / 100 * height;
    }
    var r = Math.max(distanceSquareRoot([0, 0], [x3, y3]), distanceSquareRoot([0, height], [x3, y3]), distanceSquareRoot([width, height], [x3, y3]), distanceSquareRoot([width, 0], [x3, y3]));
    if (size2) {
      if (size2 instanceof CSSUnitValue) {
        r = size2.value;
      } else if (size2 instanceof CSSKeywordValue) {
        if (size2.value === "closest-side") {
          r = Math.min(x3, width - x3, y3, height - y3);
        } else if (size2.value === "farthest-side") {
          r = Math.max(x3, width - x3, y3, height - y3);
        } else if (size2.value === "closest-corner") {
          r = Math.min(distanceSquareRoot([0, 0], [x3, y3]), distanceSquareRoot([0, height], [x3, y3]), distanceSquareRoot([width, height], [x3, y3]), distanceSquareRoot([width, 0], [x3, y3]));
        }
      }
    }
    return {
      x: x3 + min10[0],
      y: y3 + min10[1],
      r
    };
  }
  var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
  var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
  function spaceColorStops(colorStops) {
    var _colorStops$length;
    var length5 = colorStops.length;
    colorStops[length5 - 1].length = (_colorStops$length = colorStops[length5 - 1].length) !== null && _colorStops$length !== void 0 ? _colorStops$length : {
      type: "%",
      value: "100"
    };
    if (length5 > 1) {
      var _colorStops$0$length;
      colorStops[0].length = (_colorStops$0$length = colorStops[0].length) !== null && _colorStops$0$length !== void 0 ? _colorStops$0$length : {
        type: "%",
        value: "0"
      };
    }
    var previousIndex = 0;
    var previousOffset = Number(colorStops[0].length.value);
    for (var i = 1; i < length5; i++) {
      var _colorStops$i$length;
      var offset3 = (_colorStops$i$length = colorStops[i].length) === null || _colorStops$i$length === void 0 ? void 0 : _colorStops$i$length.value;
      if (!isNil(offset3) && !isNil(previousOffset)) {
        for (var j = 1; j < i - previousIndex; j++) colorStops[previousIndex + j].length = {
          type: "%",
          value: "".concat(previousOffset + (Number(offset3) - previousOffset) * j / (i - previousIndex))
        };
        previousIndex = i;
        previousOffset = Number(offset3);
      }
    }
  }
  var SideOrCornerToDegMap = {
    left: 270 - 90,
    top: 0 - 90,
    bottom: 180 - 90,
    right: 90 - 90,
    "left top": 315 - 90,
    "top left": 315 - 90,
    "left bottom": 225 - 90,
    "bottom left": 225 - 90,
    "right top": 45 - 90,
    "top right": 45 - 90,
    "right bottom": 135 - 90,
    "bottom right": 135 - 90
  };
  var angleToDeg = memoize2(function(orientation) {
    var angle4;
    if (orientation.type === "angular") {
      angle4 = Number(orientation.value);
    } else {
      angle4 = SideOrCornerToDegMap[orientation.value] || 0;
    }
    return getOrCreateUnitValue(angle4, "deg");
  });
  var positonToCSSUnitValue = memoize2(function(position) {
    var cx = 50;
    var cy = 50;
    var unitX = "%";
    var unitY = "%";
    if ((position === null || position === void 0 ? void 0 : position.type) === "position") {
      var _position$value = position.value, x3 = _position$value.x, y3 = _position$value.y;
      if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "position-keyword") {
        if (x3.value === "left") {
          cx = 0;
        } else if (x3.value === "center") {
          cx = 50;
        } else if (x3.value === "right") {
          cx = 100;
        } else if (x3.value === "top") {
          cy = 0;
        } else if (x3.value === "bottom") {
          cy = 100;
        }
      }
      if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "position-keyword") {
        if (y3.value === "left") {
          cx = 0;
        } else if (y3.value === "center") {
          cy = 50;
        } else if (y3.value === "right") {
          cx = 100;
        } else if (y3.value === "top") {
          cy = 0;
        } else if (y3.value === "bottom") {
          cy = 100;
        }
      }
      if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "px" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "%" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "em") {
        unitX = x3 === null || x3 === void 0 ? void 0 : x3.type;
        cx = Number(x3.value);
      }
      if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "px" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "%" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "em") {
        unitY = y3 === null || y3 === void 0 ? void 0 : y3.type;
        cy = Number(y3.value);
      }
    }
    return {
      cx: getOrCreateUnitValue(cx, unitX),
      cy: getOrCreateUnitValue(cy, unitY)
    };
  });
  var parseGradient = memoize2(function(colorStr) {
    if (colorStr.indexOf("linear") > -1 || colorStr.indexOf("radial") > -1) {
      var ast = parseGradient$1(colorStr);
      return ast.map(function(_ref) {
        var type2 = _ref.type, orientation = _ref.orientation, colorStops = _ref.colorStops;
        spaceColorStops(colorStops);
        var steps2 = colorStops.map(function(colorStop) {
          return {
            offset: getOrCreateUnitValue(Number(colorStop.length.value), "%"),
            color: colorStopToString(colorStop)
          };
        });
        if (type2 === "linear-gradient") {
          return new CSSGradientValue(GradientType.LinearGradient, {
            angle: orientation ? angleToDeg(orientation) : Odeg,
            steps: steps2
          });
        }
        if (type2 === "radial-gradient") {
          if (!orientation) {
            orientation = [{
              type: "shape",
              value: "circle"
            }];
          }
          if (orientation[0].type === "shape" && orientation[0].value === "circle") {
            var _positonToCSSUnitValu = positonToCSSUnitValue(orientation[0].at), cx = _positonToCSSUnitValu.cx, cy = _positonToCSSUnitValu.cy;
            var size2;
            if (orientation[0].style) {
              var _orientation$0$style = orientation[0].style, _type = _orientation$0$style.type, value2 = _orientation$0$style.value;
              if (_type === "extent-keyword") {
                size2 = getOrCreateKeyword(value2);
              } else {
                size2 = getOrCreateUnitValue(value2, _type);
              }
            }
            return new CSSGradientValue(GradientType.RadialGradient, {
              cx,
              cy,
              size: size2,
              steps: steps2
            });
          }
        }
        return void 0;
      });
    }
    var type = colorStr[0];
    if (colorStr[1] === "(" || colorStr[2] === "(") {
      if (type === "l") {
        var arr = regexLG.exec(colorStr);
        if (arr) {
          var _arr$2$match;
          var steps = ((_arr$2$match = arr[2].match(regexColorStop)) === null || _arr$2$match === void 0 ? void 0 : _arr$2$match.map(function(stop) {
            return stop.split(":");
          })) || [];
          return [new CSSGradientValue(GradientType.LinearGradient, {
            angle: getOrCreateUnitValue(parseFloat(arr[1]), "deg"),
            steps: steps.map(function(_ref2) {
              var _ref3 = _slicedToArray(_ref2, 2), offset3 = _ref3[0], color2 = _ref3[1];
              return {
                offset: getOrCreateUnitValue(Number(offset3) * 100, "%"),
                color: color2
              };
            })
          })];
        }
      } else if (type === "r") {
        var parsedRadialGradient = parseRadialGradient(colorStr);
        if (parsedRadialGradient) {
          if (isString2(parsedRadialGradient)) {
            colorStr = parsedRadialGradient;
          } else {
            return [new CSSGradientValue(GradientType.RadialGradient, parsedRadialGradient)];
          }
        }
      } else if (type === "p") {
        return parsePattern(colorStr);
      }
    }
  });
  function parseRadialGradient(gradientStr) {
    var arr = regexRG.exec(gradientStr);
    if (arr) {
      var _arr$4$match;
      var steps = ((_arr$4$match = arr[4].match(regexColorStop)) === null || _arr$4$match === void 0 ? void 0 : _arr$4$match.map(function(stop) {
        return stop.split(":");
      })) || [];
      return {
        cx: getOrCreateUnitValue(50, "%"),
        cy: getOrCreateUnitValue(50, "%"),
        steps: steps.map(function(_ref4) {
          var _ref5 = _slicedToArray(_ref4, 2), offset3 = _ref5[0], color2 = _ref5[1];
          return {
            offset: getOrCreateUnitValue(Number(offset3) * 100, "%"),
            color: color2
          };
        })
      };
    }
    return null;
  }
  function parsePattern(patternStr) {
    var arr = regexPR.exec(patternStr);
    if (arr) {
      var repetition = arr[1];
      var src = arr[2];
      switch (repetition) {
        case "a":
          repetition = "repeat";
          break;
        case "x":
          repetition = "repeat-x";
          break;
        case "y":
          repetition = "repeat-y";
          break;
        case "n":
          repetition = "no-repeat";
          break;
        default:
          repetition = "no-repeat";
      }
      return {
        image: src,
        // @ts-ignore
        repetition
      };
    }
    return null;
  }
  function isPattern(object) {
    return object && !!object.image;
  }
  function isCSSRGB(object) {
    return object && !isNil(object.r) && !isNil(object.g) && !isNil(object.b);
  }
  var parseColor = memoize2(function(colorStr) {
    if (isPattern(colorStr)) {
      return _objectSpread22({
        repetition: "repeat"
      }, colorStr);
    }
    if (isNil(colorStr)) {
      colorStr = "";
    }
    if (colorStr === "transparent") {
      return transparentColor;
    }
    if (colorStr === "currentColor") {
      colorStr = "black";
    } else if (colorStr === "none") {
      return noneColor;
    }
    var g = parseGradient(colorStr);
    if (g) {
      return g;
    }
    var color2 = color(colorStr);
    var rgba2 = [0, 0, 0, 0];
    if (color2 !== null) {
      rgba2[0] = color2.r || 0;
      rgba2[1] = color2.g || 0;
      rgba2[2] = color2.b || 0;
      rgba2[3] = color2.opacity;
    }
    return getOrCreateRGBA.apply(void 0, rgba2);
  });
  function mergeColors(left2, right2) {
    if (!isCSSRGB(left2) || !isCSSRGB(right2)) {
      return;
    }
    return [[Number(left2.r), Number(left2.g), Number(left2.b), Number(left2.alpha)], [Number(right2.r), Number(right2.g), Number(right2.b), Number(right2.alpha)], function(color2) {
      var rgba2 = color2.slice();
      if (rgba2[3]) {
        for (var i = 0; i < 3; i++) rgba2[i] = Math.round(clamp_default(rgba2[i], 0, 255));
      }
      rgba2[3] = clamp_default(rgba2[3], 0, 1);
      return "rgba(".concat(rgba2.join(","), ")");
    }];
  }
  function parseDimension(unitRegExp, string) {
    if (isNil(string)) {
      return getOrCreateUnitValue(0, "px");
    }
    string = "".concat(string).trim().toLowerCase();
    if (isFinite(Number(string))) {
      if ("px".search(unitRegExp) >= 0) {
        return getOrCreateUnitValue(Number(string), "px");
      }
      if ("deg".search(unitRegExp) >= 0) {
        return getOrCreateUnitValue(Number(string), "deg");
      }
    }
    var matchedUnits = [];
    string = string.replace(unitRegExp, function(match2) {
      matchedUnits.push(match2);
      return "U".concat(match2);
    });
    var taggedUnitRegExp = "U(".concat(unitRegExp.source, ")");
    return matchedUnits.map(function(unit) {
      return getOrCreateUnitValue(Number(string.replace(new RegExp("U".concat(unit), "g"), "").replace(new RegExp(taggedUnitRegExp, "g"), "*0")), unit);
    })[0];
  }
  var parseLengthUnmemoize = function parseLengthUnmemoize2(css2) {
    return parseDimension(new RegExp("px", "g"), css2);
  };
  var parseLength = memoize2(parseLengthUnmemoize);
  var parserPercentageUnmemoize = function parserPercentageUnmemoize2(css2) {
    return parseDimension(new RegExp("%", "g"), css2);
  };
  memoize2(parserPercentageUnmemoize);
  var parseLengthOrPercentageUnmemoize = function parseLengthOrPercentageUnmemoize2(css2) {
    if (isNumber2(css2) || isFinite(Number(css2))) {
      return getOrCreateUnitValue(Number(css2) || 0, "px");
    }
    return parseDimension(new RegExp("px|%|em|rem", "g"), css2);
  };
  var parseLengthOrPercentage = memoize2(parseLengthOrPercentageUnmemoize);
  var parseAngleUnmemoize = function parseAngleUnmemoize2(css2) {
    return parseDimension(new RegExp("deg|rad|grad|turn", "g"), css2);
  };
  var parseAngle = memoize2(parseAngleUnmemoize);
  function mergeDimensions(left2, right2, target, nonNegative) {
    var index4 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
    var unit = "";
    var leftValue = left2.value || 0;
    var rightValue = right2.value || 0;
    var canonicalUnit = toCanonicalUnit(left2.unit);
    var leftCanonicalUnitValue = left2.convertTo(canonicalUnit);
    var rightCanonicalUnitValue = right2.convertTo(canonicalUnit);
    if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
      leftValue = leftCanonicalUnitValue.value;
      rightValue = rightCanonicalUnitValue.value;
      unit = unitTypeToString(left2.unit);
    } else if (CSSUnitValue.isLength(left2.unit) || CSSUnitValue.isLength(right2.unit)) {
      leftValue = convertPercentUnit(left2, index4, target);
      rightValue = convertPercentUnit(right2, index4, target);
      unit = "px";
    }
    return [leftValue, rightValue, function(value2) {
      if (nonNegative) {
        value2 = Math.max(value2, 0);
      }
      return value2 + unit;
    }];
  }
  function convertAngleUnit(value2) {
    var deg2 = 0;
    if (value2.unit === UnitType.kDegrees) {
      deg2 = value2.value;
    } else if (value2.unit === UnitType.kRadians) {
      deg2 = rad2deg(Number(value2.value));
    } else if (value2.unit === UnitType.kTurns) {
      deg2 = turn2deg(Number(value2.value));
    } else if (value2.value) {
      deg2 = value2.value;
    }
    return deg2;
  }
  function parseDimensionArrayFormat(string, size2) {
    var parsed;
    if (Array.isArray(string)) {
      parsed = string.map(function(segment) {
        return Number(segment);
      });
    } else if (isString2(string)) {
      parsed = string.split(" ").map(function(segment) {
        return Number(segment);
      });
    } else if (isNumber2(string)) {
      parsed = [string];
    }
    if (size2 === 2) {
      if (parsed.length === 1) {
        return [parsed[0], parsed[0]];
      }
      return [parsed[0], parsed[1]];
    }
    if (size2 === 4) {
      if (parsed.length === 1) {
        return [parsed[0], parsed[0], parsed[0], parsed[0]];
      }
      if (parsed.length === 2) {
        return [parsed[0], parsed[1], parsed[0], parsed[1]];
      }
      if (parsed.length === 3) {
        return [parsed[0], parsed[1], parsed[2], parsed[1]];
      }
      return [parsed[0], parsed[1], parsed[2], parsed[3]];
    }
    if (size2 === "even" && parsed.length % 2 === 1) {
      return [].concat(_toConsumableArray(parsed), _toConsumableArray(parsed));
    }
    return parsed;
  }
  function convertPercentUnit(valueWithUnit, vec3Index, target) {
    var useMin = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (valueWithUnit.unit === UnitType.kPixels) {
      return Number(valueWithUnit.value);
    }
    if (valueWithUnit.unit === UnitType.kPercentage && target) {
      var bounds = target.nodeName === Shape.GROUP ? target.getLocalBounds() : target.getGeometryBounds();
      return (useMin ? bounds.min[vec3Index] : 0) + valueWithUnit.value / 100 * bounds.halfExtents[vec3Index] * 2;
    }
    return 0;
  }
  var parseParam = function parseParam2(css2) {
    return parseDimension(/deg|rad|grad|turn|px|%/g, css2);
  };
  var supportedFilters = ["blur", "brightness", "drop-shadow", "contrast", "grayscale", "sepia", "saturate", "hue-rotate", "invert"];
  function parseFilter() {
    var filterStr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    filterStr = filterStr.toLowerCase().trim();
    if (filterStr === "none") {
      return [];
    }
    var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
    var result = [];
    var match2;
    var prevLastIndex = 0;
    while (match2 = filterRegExp.exec(filterStr)) {
      if (match2.index !== prevLastIndex) {
        return [];
      }
      prevLastIndex = match2.index + match2[0].length;
      if (supportedFilters.indexOf(match2[1]) > -1) {
        result.push({
          name: match2[1],
          params: match2[2].split(" ").map(function(p2) {
            return parseParam(p2) || parseColor(p2);
          })
        });
      }
      if (filterRegExp.lastIndex === filterStr.length) {
        return result;
      }
    }
    return [];
  }
  function numberToString(x3) {
    return x3.toString();
  }
  var parseNumberUnmemoize = function parseNumberUnmemoize2(string) {
    if (typeof string === "number") {
      return getOrCreateUnitValue(string);
    }
    if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
      return getOrCreateUnitValue(Number(string));
    }
    return getOrCreateUnitValue(0);
  };
  var parseNumber = memoize2(parseNumberUnmemoize);
  memoize2(function(string) {
    if (isString2(string)) {
      return string.split(" ").map(parseNumber);
    }
    return string.map(parseNumber);
  });
  function mergeNumbers(left2, right2) {
    return [left2, right2, numberToString];
  }
  function clampedMergeNumbers(min10, max11) {
    return function(left2, right2) {
      return [left2, right2, function(x3) {
        return numberToString(clamp_default(x3, min10, max11));
      }];
    };
  }
  function mergeNumberLists(left2, right2) {
    if (left2.length !== right2.length) {
      return;
    }
    return [left2, right2, function(numberList) {
      return numberList;
    }];
  }
  function getOrCalculatePathTotalLength(path2) {
    if (path2.parsedStyle.d.totalLength === 0) {
      path2.parsedStyle.d.totalLength = getTotalLength(path2.parsedStyle.d.absolutePath);
    }
    return path2.parsedStyle.d.totalLength;
  }
  function getOrCalculatePolylineTotalLength(polyline) {
    if (polyline.parsedStyle.points.totalLength === 0) {
      polyline.parsedStyle.points.totalLength = length$2(polyline.parsedStyle.points.points);
    }
    return polyline.parsedStyle.points.totalLength;
  }
  function removeRedundantMCommand(path2) {
    for (var i = 0; i < path2.length; i++) {
      var prevSegment = path2[i - 1];
      var segment = path2[i];
      var cmd = segment[0];
      if (cmd === "M") {
        if (prevSegment) {
          var prevCmd = prevSegment[0];
          var srcPoint = [segment[1], segment[2]];
          var destPoint = void 0;
          if (prevCmd === "L" || prevCmd === "M") {
            destPoint = [prevSegment[1], prevSegment[2]];
          } else if (prevCmd === "C" || prevCmd === "A" || prevCmd === "Q") {
            destPoint = [prevSegment[prevSegment.length - 2], prevSegment[prevSegment.length - 1]];
          }
          if (destPoint && isSamePoint(srcPoint, destPoint)) {
            path2.splice(i, 1);
            i--;
          }
        }
      }
    }
  }
  function hasArcOrBezier(path2) {
    var hasArc = false;
    var count4 = path2.length;
    for (var i = 0; i < count4; i++) {
      var params = path2[i];
      var cmd = params[0];
      if (cmd === "C" || cmd === "A" || cmd === "Q") {
        hasArc = true;
        break;
      }
    }
    return hasArc;
  }
  function extractPolygons(pathArray) {
    var polygons = [];
    var polylines = [];
    var points = [];
    for (var i = 0; i < pathArray.length; i++) {
      var params = pathArray[i];
      var cmd = params[0];
      if (cmd === "M") {
        if (points.length) {
          polylines.push(points);
          points = [];
        }
        points.push([params[1], params[2]]);
      } else if (cmd === "Z") {
        if (points.length) {
          polygons.push(points);
          points = [];
        }
      } else {
        points.push([params[1], params[2]]);
      }
    }
    if (points.length > 0) {
      polylines.push(points);
    }
    return {
      polygons,
      polylines
    };
  }
  function isSamePoint(point1, point22) {
    return point1[0] === point22[0] && point1[1] === point22[1];
  }
  function getPathBBox(segments, lineWidth) {
    var xArr = [];
    var yArr = [];
    var segmentsWithAngle = [];
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
      var box2 = void 0;
      switch (segment.command) {
        case "Q":
          box2 = box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
          break;
        case "C":
          box2 = box$3(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
          break;
        case "A":
          var arcParams = segment.arcParams;
          box2 = box$5(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
          break;
        default:
          xArr.push(currentPoint[0]);
          yArr.push(currentPoint[1]);
          break;
      }
      if (box2) {
        segment.box = box2;
        xArr.push(box2.x, box2.x + box2.width);
        yArr.push(box2.y, box2.y + box2.height);
      }
      if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
        segmentsWithAngle.push(segment);
      }
    }
    xArr = xArr.filter(function(item) {
      return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
    });
    yArr = yArr.filter(function(item) {
      return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
    });
    var minX = min_default(xArr);
    var minY = min_default(yArr);
    var maxX = max(xArr);
    var maxY2 = max(yArr);
    if (segmentsWithAngle.length === 0) {
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY2 - minY
      };
    }
    for (var _i = 0; _i < segmentsWithAngle.length; _i++) {
      var _segment = segmentsWithAngle[_i];
      var _currentPoint = _segment.currentPoint;
      var extra = void 0;
      if (_currentPoint[0] === minX) {
        extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
        minX -= extra.xExtra;
      } else if (_currentPoint[0] === maxX) {
        extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
        maxX += extra.xExtra;
      }
      if (_currentPoint[1] === minY) {
        extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
        minY -= extra.yExtra;
      } else if (_currentPoint[1] === maxY2) {
        extra = getExtraFromSegmentWithAngle(_segment, lineWidth);
        maxY2 += extra.yExtra;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  }
  function getExtraFromSegmentWithAngle(segment, lineWidth) {
    var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
    var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
    var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
    var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
    var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
    if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
      return {
        xExtra: 0,
        yExtra: 0
      };
    }
    var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
    var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
    xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
    yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
    var extra = {
      // 水平方向投影
      xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
      // 垂直方向投影
      yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
    };
    return extra;
  }
  function toSymmetry(point6, center2) {
    return [center2[0] + (center2[0] - point6[0]), center2[1] + (center2[1] - point6[1])];
  }
  var angleBetween3 = function angleBetween4(v0, v1) {
    var p2 = v0.x * v1.x + v0.y * v1.y;
    var n2 = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
    var sign3 = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
    var angle4 = sign3 * Math.acos(p2 / n2);
    return angle4;
  };
  var pointOnEllipticalArc = function pointOnEllipticalArc2(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    xAxisRotation = mod_default(xAxisRotation, 360);
    var xAxisRotationRadians = deg2rad(xAxisRotation);
    if (p0.x === p1.x && p0.y === p1.y) {
      return {
        x: p0.x,
        y: p0.y,
        ellipticalArcAngle: 0
      };
    }
    if (rx === 0 || ry === 0) {
      return {
        x: 0,
        y: 0,
        ellipticalArcAngle: 0
      };
    }
    var dx = (p0.x - p1.x) / 2;
    var dy = (p0.y - p1.y) / 2;
    var transformedPoint = {
      x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
      y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy
    };
    var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
    if (radiiCheck > 1) {
      rx *= Math.sqrt(radiiCheck);
      ry *= Math.sqrt(radiiCheck);
    }
    var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
    var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
    var cRadicand = cSquareNumerator / cSquareRootDenom;
    cRadicand = cRadicand < 0 ? 0 : cRadicand;
    var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
    var transformedCenter = {
      x: cCoef * (rx * transformedPoint.y / ry),
      y: cCoef * (-(ry * transformedPoint.x) / rx)
    };
    var center2 = {
      x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,
      y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2
    };
    var startVector = {
      x: (transformedPoint.x - transformedCenter.x) / rx,
      y: (transformedPoint.y - transformedCenter.y) / ry
    };
    var startAngle = angleBetween3({
      x: 1,
      y: 0
    }, startVector);
    var endVector = {
      x: (-transformedPoint.x - transformedCenter.x) / rx,
      y: (-transformedPoint.y - transformedCenter.y) / ry
    };
    var sweepAngle = angleBetween3(startVector, endVector);
    if (!sweepFlag && sweepAngle > 0) {
      sweepAngle -= 2 * Math.PI;
    } else if (sweepFlag && sweepAngle < 0) {
      sweepAngle += 2 * Math.PI;
    }
    sweepAngle %= 2 * Math.PI;
    var angle4 = startAngle + sweepAngle * t;
    var ellipseComponentX = rx * Math.cos(angle4);
    var ellipseComponentY = ry * Math.sin(angle4);
    var point6 = {
      x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center2.x,
      y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center2.y,
      ellipticalArcStartAngle: startAngle,
      ellipticalArcEndAngle: startAngle + sweepAngle,
      ellipticalArcAngle: angle4,
      ellipticalArcCenter: center2,
      resultantRx: rx,
      resultantRy: ry
    };
    return point6;
  };
  function path2Segments(path2) {
    var segments = [];
    var currentPoint = null;
    var nextParams = null;
    var startMovePoint = null;
    var lastStartMovePointIndex = 0;
    var count4 = path2.length;
    for (var i = 0; i < count4; i++) {
      var params = path2[i];
      nextParams = path2[i + 1];
      var command = params[0];
      var segment = {
        command,
        prePoint: currentPoint,
        params,
        startTangent: null,
        endTangent: null,
        currentPoint: null,
        nextPoint: null,
        arcParams: null,
        box: null,
        cubicParams: null
      };
      switch (command) {
        case "M":
          startMovePoint = [params[1], params[2]];
          lastStartMovePointIndex = i;
          break;
        case "A":
          var arcParams = getArcParams(currentPoint, params);
          segment.arcParams = arcParams;
          break;
      }
      if (command === "Z") {
        currentPoint = startMovePoint;
        nextParams = path2[lastStartMovePointIndex + 1];
      } else {
        var len5 = params.length;
        currentPoint = [params[len5 - 2], params[len5 - 1]];
      }
      if (nextParams && nextParams[0] === "Z") {
        nextParams = path2[lastStartMovePointIndex];
        if (segments[lastStartMovePointIndex]) {
          segments[lastStartMovePointIndex].prePoint = currentPoint;
        }
      }
      segment.currentPoint = currentPoint;
      if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
        segments[lastStartMovePointIndex].prePoint = segment.prePoint;
      }
      var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
      segment.nextPoint = nextPoint;
      var prePoint = segment.prePoint;
      if (["L", "H", "V"].includes(command)) {
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      } else if (command === "Q") {
        var cp = [params[1], params[2]];
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else if (command === "T") {
        var preSegment = segments[i - 1];
        var _cp = toSymmetry(preSegment.currentPoint, prePoint);
        if (preSegment.command === "Q") {
          segment.command = "Q";
          segment.startTangent = [prePoint[0] - _cp[0], prePoint[1] - _cp[1]];
          segment.endTangent = [currentPoint[0] - _cp[0], currentPoint[1] - _cp[1]];
        } else {
          segment.command = "TL";
          segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
          segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
        }
      } else if (command === "C") {
        var cp1 = [params[1], params[2]];
        var cp2 = [params[3], params[4]];
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
        if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
          segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
        }
        if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
          segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
        }
      } else if (command === "S") {
        var _preSegment = segments[i - 1];
        var _cp2 = toSymmetry(_preSegment.currentPoint, prePoint);
        var _cp3 = [params[1], params[2]];
        if (_preSegment.command === "C") {
          segment.command = "C";
          segment.startTangent = [prePoint[0] - _cp2[0], prePoint[1] - _cp2[1]];
          segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
        } else {
          segment.command = "SQ";
          segment.startTangent = [prePoint[0] - _cp3[0], prePoint[1] - _cp3[1]];
          segment.endTangent = [currentPoint[0] - _cp3[0], currentPoint[1] - _cp3[1]];
        }
      } else if (command === "A") {
        var _getTangentAtRatio = getTangentAtRatio(segment, 0), dx1 = _getTangentAtRatio.x, dy1 = _getTangentAtRatio.y;
        var _getTangentAtRatio2 = getTangentAtRatio(segment, 1, false), dx2 = _getTangentAtRatio2.x, dy2 = _getTangentAtRatio2.y;
        segment.startTangent = [dx1, dy1];
        segment.endTangent = [dx2, dy2];
      }
      segments.push(segment);
    }
    return segments;
  }
  function getTangentAtRatio(segment, ratio) {
    var sign3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
    var _segment$arcParams = segment.arcParams, _segment$arcParams$rx = _segment$arcParams.rx, rx = _segment$arcParams$rx === void 0 ? 0 : _segment$arcParams$rx, _segment$arcParams$ry = _segment$arcParams.ry, ry = _segment$arcParams$ry === void 0 ? 0 : _segment$arcParams$ry, xRotation = _segment$arcParams.xRotation, arcFlag = _segment$arcParams.arcFlag, sweepFlag = _segment$arcParams.sweepFlag;
    var p1 = pointOnEllipticalArc({
      x: segment.prePoint[0],
      y: segment.prePoint[1]
    }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
      x: segment.currentPoint[0],
      y: segment.currentPoint[1]
    }, ratio);
    var p2 = pointOnEllipticalArc({
      x: segment.prePoint[0],
      y: segment.prePoint[1]
    }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, {
      x: segment.currentPoint[0],
      y: segment.currentPoint[1]
    }, sign3 ? ratio + 5e-3 : ratio - 5e-3);
    var xDist = p2.x - p1.x;
    var yDist = p2.y - p1.y;
    var dist5 = Math.sqrt(xDist * xDist + yDist * yDist);
    return {
      x: -xDist / dist5,
      y: -yDist / dist5
    };
  }
  function vMag(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  }
  function vRatio(u, v) {
    return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
  }
  function vAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
  }
  function getArcParams(startPoint, params) {
    var rx = params[1];
    var ry = params[2];
    var xRotation = mod_default(deg2rad(params[3]), Math.PI * 2);
    var arcFlag = params[4];
    var sweepFlag = params[5];
    var x12 = startPoint[0];
    var y12 = startPoint[1];
    var x22 = params[6];
    var y22 = params[7];
    var xp = Math.cos(xRotation) * (x12 - x22) / 2 + Math.sin(xRotation) * (y12 - y22) / 2;
    var yp = -1 * Math.sin(xRotation) * (x12 - x22) / 2 + Math.cos(xRotation) * (y12 - y22) / 2;
    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
    var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
    if (arcFlag === sweepFlag) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }
    var cxp = ry ? f * rx * yp / ry : 0;
    var cyp = rx ? f * -ry * xp / rx : 0;
    var cx = (x12 + x22) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
    var cy = (y12 + y22) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var theta = vAngle([1, 0], u);
    var dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (sweepFlag === 0 && dTheta > 0) {
      dTheta -= 2 * Math.PI;
    }
    if (sweepFlag === 1 && dTheta < 0) {
      dTheta += 2 * Math.PI;
    }
    return {
      cx,
      cy,
      // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
      rx: isSamePoint(startPoint, [x22, y22]) ? 0 : rx,
      ry: isSamePoint(startPoint, [x22, y22]) ? 0 : ry,
      startAngle: theta,
      endAngle: theta + dTheta,
      xRotation,
      arcFlag,
      sweepFlag
    };
  }
  function commandsToPathString(commands, object, transform) {
    return commands.reduce(function(prev, cur) {
      var path2 = "";
      if (cur[0] === "M" || cur[0] === "L") {
        var p2 = vec3_exports.fromValues(cur[1], cur[2], 0);
        if (transform) {
          vec3_exports.transformMat4(p2, p2, transform);
        }
        path2 = "".concat(cur[0]).concat(p2[0], ",").concat(p2[1]);
      } else if (cur[0] === "Z") {
        path2 = cur[0];
      } else if (cur[0] === "C") {
        var p1 = vec3_exports.fromValues(cur[1], cur[2], 0);
        var p22 = vec3_exports.fromValues(cur[3], cur[4], 0);
        var p3 = vec3_exports.fromValues(cur[5], cur[6], 0);
        if (transform) {
          vec3_exports.transformMat4(p1, p1, transform);
          vec3_exports.transformMat4(p22, p22, transform);
          vec3_exports.transformMat4(p3, p3, transform);
        }
        path2 = "".concat(cur[0]).concat(p1[0], ",").concat(p1[1], ",").concat(p22[0], ",").concat(p22[1], ",").concat(p3[0], ",").concat(p3[1]);
      } else if (cur[0] === "A") {
        var c5 = vec3_exports.fromValues(cur[6], cur[7], 0);
        if (transform) {
          vec3_exports.transformMat4(c5, c5, transform);
        }
        path2 = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], ",").concat(cur[5], ",").concat(c5[0], ",").concat(c5[1]);
      } else if (cur[0] === "Q") {
        var _p = vec3_exports.fromValues(cur[1], cur[2], 0);
        var _p2 = vec3_exports.fromValues(cur[3], cur[4], 0);
        if (transform) {
          vec3_exports.transformMat4(_p, _p, transform);
          vec3_exports.transformMat4(_p2, _p2, transform);
        }
        path2 = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], "}");
      }
      return prev += path2;
    }, "");
  }
  function lineToCommands(x12, y12, x22, y22) {
    return [["M", x12, y12], ["L", x22, y22]];
  }
  function ellipseToCommands(rx, ry, cx, cy) {
    var factor = (-1 + Math.sqrt(2)) / 3 * 4;
    var dx = rx * factor;
    var dy = ry * factor;
    var left2 = cx - rx;
    var right2 = cx + rx;
    var top = cy - ry;
    var bottom = cy + ry;
    return [["M", left2, cy], ["C", left2, cy - dy, cx - dx, top, cx, top], ["C", cx + dx, top, right2, cy - dy, right2, cy], ["C", right2, cy + dy, cx + dx, bottom, cx, bottom], ["C", cx - dx, bottom, left2, cy + dy, left2, cy], ["Z"]];
  }
  function polygonToCommands(points, closed) {
    var result = points.map(function(point6, i) {
      return [i === 0 ? "M" : "L", point6[0], point6[1]];
    });
    if (closed) {
      result.push(["Z"]);
    }
    return result;
  }
  function rectToCommands(width, height, x3, y3, radius) {
    if (radius) {
      var _radius = _slicedToArray(radius, 4), tlr = _radius[0], trr = _radius[1], brr = _radius[2], blr = _radius[3];
      var signX = width > 0 ? 1 : -1;
      var signY = height > 0 ? 1 : -1;
      var sweepFlag = signX + signY !== 0 ? 1 : 0;
      return [["M", signX * tlr + x3, y3], ["L", width - signX * trr + x3, y3], trr ? ["A", trr, trr, 0, 0, sweepFlag, width + x3, signY * trr + y3] : null, ["L", width + x3, height - signY * brr + y3], brr ? ["A", brr, brr, 0, 0, sweepFlag, width + x3 - signX * brr, height + y3] : null, ["L", x3 + signX * blr, height + y3], blr ? ["A", blr, blr, 0, 0, sweepFlag, x3, height + y3 - signY * blr] : null, ["L", x3, signY * tlr + y3], tlr ? ["A", tlr, tlr, 0, 0, sweepFlag, signX * tlr + x3, y3] : null, ["Z"]].filter(function(command) {
        return command;
      });
    }
    return [["M", x3, y3], ["L", x3 + width, y3], ["L", x3 + width, y3 + height], ["L", x3, y3 + height], ["Z"]];
  }
  function convertToPath(object) {
    var transform = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : object.getLocalTransform();
    var commands = [];
    switch (object.nodeName) {
      case Shape.LINE:
        var _parsedStyle = object.parsedStyle, _parsedStyle$x = _parsedStyle.x1, x12 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = _parsedStyle.y1, y12 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$x2 = _parsedStyle.x2, x22 = _parsedStyle$x2 === void 0 ? 0 : _parsedStyle$x2, _parsedStyle$y2 = _parsedStyle.y2, y22 = _parsedStyle$y2 === void 0 ? 0 : _parsedStyle$y2;
        commands = lineToCommands(x12, y12, x22, y22);
        break;
      case Shape.CIRCLE: {
        var _parsedStyle2 = object.parsedStyle, _parsedStyle2$r = _parsedStyle2.r, r = _parsedStyle2$r === void 0 ? 0 : _parsedStyle2$r, _parsedStyle2$cx = _parsedStyle2.cx, cx = _parsedStyle2$cx === void 0 ? 0 : _parsedStyle2$cx, _parsedStyle2$cy = _parsedStyle2.cy, cy = _parsedStyle2$cy === void 0 ? 0 : _parsedStyle2$cy;
        commands = ellipseToCommands(r, r, cx, cy);
        break;
      }
      case Shape.ELLIPSE: {
        var _parsedStyle3 = object.parsedStyle, _parsedStyle3$rx = _parsedStyle3.rx, rx = _parsedStyle3$rx === void 0 ? 0 : _parsedStyle3$rx, _parsedStyle3$ry = _parsedStyle3.ry, ry = _parsedStyle3$ry === void 0 ? 0 : _parsedStyle3$ry, _parsedStyle3$cx = _parsedStyle3.cx, _cx = _parsedStyle3$cx === void 0 ? 0 : _parsedStyle3$cx, _parsedStyle3$cy = _parsedStyle3.cy, _cy = _parsedStyle3$cy === void 0 ? 0 : _parsedStyle3$cy;
        commands = ellipseToCommands(rx, ry, _cx, _cy);
        break;
      }
      case Shape.POLYLINE:
      case Shape.POLYGON:
        var points = object.parsedStyle.points;
        commands = polygonToCommands(points.points, object.nodeName === Shape.POLYGON);
        break;
      case Shape.RECT:
        var _parsedStyle4 = object.parsedStyle, _parsedStyle4$width = _parsedStyle4.width, width = _parsedStyle4$width === void 0 ? 0 : _parsedStyle4$width, _parsedStyle4$height = _parsedStyle4.height, height = _parsedStyle4$height === void 0 ? 0 : _parsedStyle4$height, _parsedStyle4$x = _parsedStyle4.x, x3 = _parsedStyle4$x === void 0 ? 0 : _parsedStyle4$x, _parsedStyle4$y = _parsedStyle4.y, y3 = _parsedStyle4$y === void 0 ? 0 : _parsedStyle4$y, radius = _parsedStyle4.radius;
        var hasRadius = radius && radius.some(function(r2) {
          return r2 !== 0;
        });
        commands = rectToCommands(width, height, x3, y3, hasRadius && radius.map(function(r2) {
          return clamp_default(r2, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
        }));
        break;
      case Shape.PATH:
        var absolutePath = object.parsedStyle.d.absolutePath;
        commands = _toConsumableArray(absolutePath);
        break;
    }
    if (commands.length) {
      return commandsToPathString(commands, object, transform);
    }
  }
  var internalParsePath = function internalParsePath2(path2) {
    if (path2 === "" || Array.isArray(path2) && path2.length === 0) {
      return {
        absolutePath: [],
        hasArc: false,
        segments: [],
        polygons: [],
        polylines: [],
        curve: null,
        totalLength: 0,
        rect: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }
      };
    }
    var absolutePath;
    try {
      absolutePath = normalizePath(path2);
    } catch (_unused) {
      absolutePath = normalizePath("");
      console.error("[g]: Invalid SVG Path definition: ".concat(path2));
    }
    removeRedundantMCommand(absolutePath);
    var hasArc = hasArcOrBezier(absolutePath);
    var _extractPolygons = extractPolygons(absolutePath), polygons = _extractPolygons.polygons, polylines = _extractPolygons.polylines;
    var segments = path2Segments(absolutePath);
    var _getPathBBox = getPathBBox(segments, 0), x3 = _getPathBBox.x, y3 = _getPathBBox.y, width = _getPathBBox.width, height = _getPathBBox.height;
    return {
      absolutePath,
      hasArc,
      segments,
      polygons,
      polylines,
      // curve,
      // Delay the calculation of length.
      totalLength: 0,
      rect: {
        x: Number.isFinite(x3) ? x3 : 0,
        y: Number.isFinite(y3) ? y3 : 0,
        width: Number.isFinite(width) ? width : 0,
        height: Number.isFinite(height) ? height : 0
      }
    };
  };
  var memoizedParsePath = memoize2(internalParsePath);
  function parsePath(path2) {
    return isString2(path2) ? memoizedParsePath(path2) : internalParsePath(path2);
  }
  function mergePaths(left2, right2, object) {
    var curve1 = left2.curve;
    var curve2 = right2.curve;
    if (!curve1 || curve1.length === 0) {
      curve1 = path2Curve(left2.absolutePath, false);
      left2.curve = curve1;
    }
    if (!curve2 || curve2.length === 0) {
      curve2 = path2Curve(right2.absolutePath, false);
      right2.curve = curve2;
    }
    var curves = [curve1, curve2];
    if (curve1.length !== curve2.length) {
      curves = equalizeSegments(curve1, curve2);
    }
    var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1]) ? reverseCurve(curves[0]) : clonePath(curves[0]);
    return [curve0, getRotatedCurve(curves[1], curve0), function(pathArray) {
      return pathArray;
    }];
  }
  function parsePoints(pointsOrStr, object) {
    var points;
    if (isString2(pointsOrStr)) {
      points = pointsOrStr.split(" ").map(function(pointStr) {
        var _pointStr$split = pointStr.split(","), _pointStr$split2 = _slicedToArray(_pointStr$split, 2), x3 = _pointStr$split2[0], y3 = _pointStr$split2[1];
        return [Number(x3), Number(y3)];
      });
    } else {
      points = pointsOrStr;
    }
    return {
      points,
      totalLength: 0,
      segments: []
    };
  }
  function mergePoints(left2, right2) {
    return [left2.points, right2.points, function(points) {
      return points;
    }];
  }
  var _ = null;
  var TRANSFORM_REGEXP = /\s*(\w+)\(([^)]*)\)/g;
  function cast(pattern) {
    return function(contents) {
      var i = 0;
      return pattern.map(function(x3) {
        return x3 === _ ? contents[i++] : x3;
      });
    };
  }
  function id(x3) {
    return x3;
  }
  var transformFunctions = {
    // @ts-ignore
    matrix: ["NNNNNN", [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],
    matrix3d: ["NNNNNNNNNNNNNNNN", id],
    rotate: ["A"],
    rotateX: ["A"],
    rotateY: ["A"],
    rotateZ: ["A"],
    rotate3d: ["NNNA"],
    perspective: ["L"],
    scale: ["Nn", cast([_, _, new CSSUnitValue(1)]), id],
    scaleX: ["N", cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]), cast([_, new CSSUnitValue(1)])],
    scaleY: ["N", cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]), cast([new CSSUnitValue(1), _])],
    scaleZ: ["N", cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],
    scale3d: ["NNN", id],
    skew: ["Aa", null, id],
    skewX: ["A", null, cast([_, Odeg])],
    skewY: ["A", null, cast([Odeg, _])],
    translate: ["Tt", cast([_, _, Opx]), id],
    translateX: ["T", cast([_, Opx, Opx]), cast([_, Opx])],
    translateY: ["T", cast([Opx, _, Opx]), cast([Opx, _])],
    translateZ: ["L", cast([Opx, Opx, _])],
    translate3d: ["TTL", id]
  };
  function parseArrayTransform(transform) {
    var result = [];
    var length5 = transform.length;
    for (var i = 0; i < length5; i++) {
      var item = transform[i];
      var name2 = item[0];
      var args = item.slice(1);
      if (name2 === "translate" || name2 === "skew") {
        if (args.length === 1) args.push(0);
      } else if (name2 === "scale") {
        if (args.length === 1) args.push(args[0]);
      }
      var functionData = transformFunctions[name2];
      if (!functionData) return [];
      var parsedArgs = args.map(function(value2) {
        return getOrCreateUnitValue(value2);
      });
      result.push({
        t: name2,
        d: parsedArgs
      });
    }
    return result;
  }
  function parseTransform(transform) {
    if (Array.isArray(transform)) {
      return parseArrayTransform(transform);
    }
    transform = (transform || "none").trim();
    if (transform === "none") {
      return [];
    }
    var result = [];
    var match2;
    var prevLastIndex = 0;
    TRANSFORM_REGEXP.lastIndex = 0;
    while (match2 = TRANSFORM_REGEXP.exec(transform)) {
      if (match2.index !== prevLastIndex) {
        return [];
      }
      prevLastIndex = match2.index + match2[0].length;
      var functionName = match2[1];
      var functionData = transformFunctions[functionName];
      if (!functionData) {
        return [];
      }
      var args = match2[2].split(",");
      var argTypes = functionData[0];
      if (argTypes.length < args.length) {
        return [];
      }
      var parsedArgs = [];
      for (var i = 0; i < argTypes.length; i++) {
        var arg = args[i];
        var type = argTypes[i];
        var parsedArg = void 0;
        if (!arg) {
          parsedArg = {
            a: Odeg,
            n: parsedArgs[0],
            t: Opx
          }[type];
        } else {
          parsedArg = {
            A: function A5(s3) {
              return s3.trim() === "0" ? Odeg : parseAngle(s3);
            },
            N: parseNumber,
            T: parseLengthOrPercentage,
            L: parseLength
          }[type.toUpperCase()](arg);
        }
        if (parsedArg === void 0) {
          return [];
        }
        parsedArgs.push(parsedArg);
      }
      result.push({
        t: functionName,
        d: parsedArgs
      });
      if (TRANSFORM_REGEXP.lastIndex === transform.length) {
        return result;
      }
    }
    return [];
  }
  function parseTransformUnmemoize(transform) {
    if (Array.isArray(transform)) {
      return parseArrayTransform(transform);
    }
    transform = (transform || "none").trim();
    if (transform === "none") {
      return [];
    }
    var result = [];
    var match2;
    var prevLastIndex = 0;
    TRANSFORM_REGEXP.lastIndex = 0;
    while (match2 = TRANSFORM_REGEXP.exec(transform)) {
      if (match2.index !== prevLastIndex) {
        return [];
      }
      prevLastIndex = match2.index + match2[0].length;
      var functionName = match2[1];
      var functionData = transformFunctions[functionName];
      if (!functionData) {
        return [];
      }
      var args = match2[2].split(",");
      var argTypes = functionData[0];
      if (argTypes.length < args.length) {
        return [];
      }
      var parsedArgs = [];
      for (var i = 0; i < argTypes.length; i++) {
        var arg = args[i];
        var type = argTypes[i];
        var parsedArg = void 0;
        if (!arg) {
          parsedArg = {
            a: Odeg,
            n: parsedArgs[0],
            t: Opx
          }[type];
        } else {
          parsedArg = {
            A: function A5(s3) {
              return s3.trim() === "0" ? Odeg : parseAngleUnmemoize(s3);
            },
            N: parseNumberUnmemoize,
            T: parseLengthOrPercentageUnmemoize,
            L: parseLengthUnmemoize
          }[type.toUpperCase()](arg);
        }
        if (parsedArg === void 0) {
          return [];
        }
        parsedArgs.push(parsedArg);
      }
      result.push({
        t: functionName,
        d: parsedArgs
      });
      if (TRANSFORM_REGEXP.lastIndex === transform.length) {
        return result;
      }
    }
    return [];
  }
  function convertItemToMatrix(item) {
    var x3;
    var y3;
    var z;
    var angle4;
    switch (item.t) {
      case "rotateX":
        angle4 = deg2rad(convertAngleUnit(item.d[0]));
        return [1, 0, 0, 0, 0, Math.cos(angle4), Math.sin(angle4), 0, 0, -Math.sin(angle4), Math.cos(angle4), 0, 0, 0, 0, 1];
      case "rotateY":
        angle4 = deg2rad(convertAngleUnit(item.d[0]));
        return [Math.cos(angle4), 0, -Math.sin(angle4), 0, 0, 1, 0, 0, Math.sin(angle4), 0, Math.cos(angle4), 0, 0, 0, 0, 1];
      case "rotate":
      case "rotateZ":
        angle4 = deg2rad(convertAngleUnit(item.d[0]));
        return [Math.cos(angle4), Math.sin(angle4), 0, 0, -Math.sin(angle4), Math.cos(angle4), 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "rotate3d":
        x3 = item.d[0].value;
        y3 = item.d[1].value;
        z = item.d[2].value;
        angle4 = deg2rad(convertAngleUnit(item.d[3]));
        var sqrLength = x3 * x3 + y3 * y3 + z * z;
        if (sqrLength === 0) {
          x3 = 1;
          y3 = 0;
          z = 0;
        } else if (sqrLength !== 1) {
          var length5 = Math.sqrt(sqrLength);
          x3 /= length5;
          y3 /= length5;
          z /= length5;
        }
        var s3 = Math.sin(angle4 / 2);
        var sc = s3 * Math.cos(angle4 / 2);
        var sq = s3 * s3;
        return [1 - 2 * (y3 * y3 + z * z) * sq, 2 * (x3 * y3 * sq + z * sc), 2 * (x3 * z * sq - y3 * sc), 0, 2 * (x3 * y3 * sq - z * sc), 1 - 2 * (x3 * x3 + z * z) * sq, 2 * (y3 * z * sq + x3 * sc), 0, 2 * (x3 * z * sq + y3 * sc), 2 * (y3 * z * sq - x3 * sc), 1 - 2 * (x3 * x3 + y3 * y3) * sq, 0, 0, 0, 0, 1];
      case "scale":
        return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "scaleX":
        return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "scaleY":
        return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "scaleZ":
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
      case "scale3d":
        return [item.d[0].value, 0, 0, 0, 0, item.d[1].value, 0, 0, 0, 0, item.d[2].value, 0, 0, 0, 0, 1];
      case "skew":
        var xAngle = deg2rad(convertAngleUnit(item.d[0]));
        var yAngle = deg2rad(convertAngleUnit(item.d[1]));
        return [1, Math.tan(yAngle), 0, 0, Math.tan(xAngle), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "skewX":
        angle4 = deg2rad(convertAngleUnit(item.d[0]));
        return [1, 0, 0, 0, Math.tan(angle4), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "skewY":
        angle4 = deg2rad(convertAngleUnit(item.d[0]));
        return [1, Math.tan(angle4), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "translate":
        x3 = convertPercentUnit(item.d[0], 0, null) || 0;
        y3 = convertPercentUnit(item.d[1], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, 0, 1];
      case "translateX":
        x3 = convertPercentUnit(item.d[0], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, 0, 0, 1];
      case "translateY":
        y3 = convertPercentUnit(item.d[0], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y3, 0, 1];
      case "translateZ":
        z = convertPercentUnit(item.d[0], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
      case "translate3d":
        x3 = convertPercentUnit(item.d[0], 0, null) || 0;
        y3 = convertPercentUnit(item.d[1], 0, null) || 0;
        z = convertPercentUnit(item.d[2], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, z, 1];
      case "perspective":
        var t = convertPercentUnit(item.d[0], 0, null) || 0;
        var p2 = t ? -1 / t : 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p2, 0, 0, 0, 1];
      case "matrix":
        return [item.d[0].value, item.d[1].value, 0, 0, item.d[2].value, item.d[3].value, 0, 0, 0, 0, 1, 0, item.d[4].value, item.d[5].value, 0, 1];
      case "matrix3d":
        return item.d.map(function(d3) {
          return d3.value;
        });
    }
  }
  function multiplyMatrices(a3, b) {
    return [a3[0] * b[0] + a3[4] * b[1] + a3[8] * b[2] + a3[12] * b[3], a3[1] * b[0] + a3[5] * b[1] + a3[9] * b[2] + a3[13] * b[3], a3[2] * b[0] + a3[6] * b[1] + a3[10] * b[2] + a3[14] * b[3], a3[3] * b[0] + a3[7] * b[1] + a3[11] * b[2] + a3[15] * b[3], a3[0] * b[4] + a3[4] * b[5] + a3[8] * b[6] + a3[12] * b[7], a3[1] * b[4] + a3[5] * b[5] + a3[9] * b[6] + a3[13] * b[7], a3[2] * b[4] + a3[6] * b[5] + a3[10] * b[6] + a3[14] * b[7], a3[3] * b[4] + a3[7] * b[5] + a3[11] * b[6] + a3[15] * b[7], a3[0] * b[8] + a3[4] * b[9] + a3[8] * b[10] + a3[12] * b[11], a3[1] * b[8] + a3[5] * b[9] + a3[9] * b[10] + a3[13] * b[11], a3[2] * b[8] + a3[6] * b[9] + a3[10] * b[10] + a3[14] * b[11], a3[3] * b[8] + a3[7] * b[9] + a3[11] * b[10] + a3[15] * b[11], a3[0] * b[12] + a3[4] * b[13] + a3[8] * b[14] + a3[12] * b[15], a3[1] * b[12] + a3[5] * b[13] + a3[9] * b[14] + a3[13] * b[15], a3[2] * b[12] + a3[6] * b[13] + a3[10] * b[14] + a3[14] * b[15], a3[3] * b[12] + a3[7] * b[13] + a3[11] * b[14] + a3[15] * b[15]];
  }
  function convertToMatrix(transformList) {
    if (transformList.length === 0) {
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }
    return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);
  }
  function makeMatrixDecomposition(transformList) {
    var translate5 = [0, 0, 0];
    var scale10 = [1, 1, 1];
    var skew2 = [0, 0, 0];
    var perspective2 = [0, 0, 0, 1];
    var quaternion = [0, 0, 0, 1];
    decomposeMat4(
      // @ts-ignore
      convertToMatrix(transformList),
      translate5,
      scale10,
      skew2,
      perspective2,
      quaternion
    );
    return [[translate5, scale10, skew2, quaternion, perspective2]];
  }
  var composeMatrix = /* @__PURE__ */ function() {
    function multiply7(a3, b) {
      var result = [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]];
      for (var i = 0; i < 4; i++) {
        for (var j = 0; j < 4; j++) {
          for (var k = 0; k < 4; k++) {
            result[i][j] += b[i][k] * a3[k][j];
          }
        }
      }
      return result;
    }
    function is2D(m3) {
      return m3[0][2] === 0 && m3[0][3] === 0 && m3[1][2] === 0 && m3[1][3] === 0 && m3[2][0] === 0 && m3[2][1] === 0 && m3[2][2] === 1 && m3[2][3] === 0 && m3[3][2] === 0 && m3[3][3] === 1;
    }
    function composeMatrix2(translate5, scale10, skew2, quat2, perspective2) {
      var matrix3 = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
      for (var i = 0; i < 4; i++) {
        matrix3[i][3] = perspective2[i];
      }
      for (var _i = 0; _i < 3; _i++) {
        for (var j = 0; j < 3; j++) {
          matrix3[3][_i] += translate5[j] * matrix3[j][_i];
        }
      }
      var x3 = quat2[0];
      var y3 = quat2[1];
      var z = quat2[2];
      var w = quat2[3];
      var rotMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
      rotMatrix[0][0] = 1 - 2 * (y3 * y3 + z * z);
      rotMatrix[0][1] = 2 * (x3 * y3 - z * w);
      rotMatrix[0][2] = 2 * (x3 * z + y3 * w);
      rotMatrix[1][0] = 2 * (x3 * y3 + z * w);
      rotMatrix[1][1] = 1 - 2 * (x3 * x3 + z * z);
      rotMatrix[1][2] = 2 * (y3 * z - x3 * w);
      rotMatrix[2][0] = 2 * (x3 * z - y3 * w);
      rotMatrix[2][1] = 2 * (y3 * z + x3 * w);
      rotMatrix[2][2] = 1 - 2 * (x3 * x3 + y3 * y3);
      matrix3 = multiply7(matrix3, rotMatrix);
      var temp = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
      if (skew2[2]) {
        temp[2][1] = skew2[2];
        matrix3 = multiply7(matrix3, temp);
      }
      if (skew2[1]) {
        temp[2][1] = 0;
        temp[2][0] = skew2[0];
        matrix3 = multiply7(matrix3, temp);
      }
      if (skew2[0]) {
        temp[2][0] = 0;
        temp[1][0] = skew2[0];
        matrix3 = multiply7(matrix3, temp);
      }
      for (var _i2 = 0; _i2 < 3; _i2++) {
        for (var _j = 0; _j < 3; _j++) {
          matrix3[_i2][_j] *= scale10[_i2];
        }
      }
      if (is2D(matrix3)) {
        return [matrix3[0][0], matrix3[0][1], matrix3[1][0], matrix3[1][1], matrix3[3][0], matrix3[3][1]];
      }
      return matrix3[0].concat(matrix3[1], matrix3[2], matrix3[3]);
    }
    return composeMatrix2;
  }();
  function numberToLongString(x3) {
    return x3.toFixed(6).replace(".000000", "");
  }
  function mergeMatrices(left2, right2) {
    var leftArgs;
    var rightArgs;
    if (left2.decompositionPair !== right2) {
      left2.decompositionPair = right2;
      leftArgs = makeMatrixDecomposition(left2);
    }
    if (right2.decompositionPair !== left2) {
      right2.decompositionPair = left2;
      rightArgs = makeMatrixDecomposition(right2);
    }
    if (leftArgs[0] === null || rightArgs[0] === null) return [
      // @ts-ignore
      [false],
      // @ts-ignore
      [true],
      // @ts-ignore
      function(x3) {
        return x3 ? right2[0].d : left2[0].d;
      }
    ];
    leftArgs[0].push(0);
    rightArgs[0].push(1);
    return [
      leftArgs,
      rightArgs,
      // @ts-ignore
      function(list) {
        var q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);
        var mat = composeMatrix(list[0], list[1], list[2], q, list[4]);
        var stringifiedArgs = mat.map(numberToLongString).join(",");
        return stringifiedArgs;
      }
    ];
  }
  function dot5(v1, v2) {
    var result = 0;
    for (var i = 0; i < v1.length; i++) {
      result += v1[i] * v2[i];
    }
    return result;
  }
  function quat(fromQ, toQ, f) {
    var product = dot5(fromQ, toQ);
    product = clamp_default(product, -1, 1);
    var quat2 = [];
    if (product === 1) {
      quat2 = fromQ;
    } else {
      var theta = Math.acos(product);
      var w = Math.sin(f * theta) * 1 / Math.sqrt(1 - product * product);
      for (var i = 0; i < 4; i++) {
        quat2.push(fromQ[i] * (Math.cos(f * theta) - product * w) + toQ[i] * w);
      }
    }
    return quat2;
  }
  function typeTo2D(type) {
    return type.replace(/[XY]/, "");
  }
  function typeTo3D(type) {
    return type.replace(/(X|Y|Z|3d)?$/, "3d");
  }
  var isMatrixOrPerspective = function isMatrixOrPerspective2(lt, rt) {
    return lt === "perspective" && rt === "perspective" || (lt === "matrix" || lt === "matrix3d") && (rt === "matrix" || rt === "matrix3d");
  };
  function mergeTransforms(left2, right2, target) {
    var flipResults = false;
    if (!left2.length || !right2.length) {
      if (!left2.length) {
        flipResults = true;
        left2 = right2;
        right2 = [];
      }
      var _loop = function _loop2() {
        var _left$i = left2[i], type2 = _left$i.t, args = _left$i.d;
        var defaultValue = type2.substring(0, 5) === "scale" ? 1 : 0;
        right2.push({
          t: type2,
          d: args.map(function(arg) {
            if (typeof arg === "number") {
              return getOrCreateUnitValue(defaultValue);
            }
            return getOrCreateUnitValue(defaultValue, arg.unit);
          })
        });
      };
      for (var i = 0; i < left2.length; i++) {
        _loop();
      }
    }
    var leftResult = [];
    var rightResult = [];
    var types = [];
    if (left2.length !== right2.length) {
      var merged = mergeMatrices(left2, right2);
      leftResult = [merged[0]];
      rightResult = [merged[1]];
      types = [["matrix", [merged[2]]]];
    } else {
      for (var _i3 = 0; _i3 < left2.length; _i3++) {
        var leftType = left2[_i3].t;
        var rightType = right2[_i3].t;
        var leftArgs = left2[_i3].d;
        var rightArgs = right2[_i3].d;
        var leftFunctionData = transformFunctions[leftType];
        var rightFunctionData = transformFunctions[rightType];
        var type = void 0;
        if (isMatrixOrPerspective(leftType, rightType)) {
          var _merged = mergeMatrices([left2[_i3]], [right2[_i3]]);
          leftResult.push(_merged[0]);
          rightResult.push(_merged[1]);
          types.push(["matrix", [_merged[2]]]);
          continue;
        } else if (leftType === rightType) {
          type = leftType;
        } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {
          type = typeTo2D(leftType);
          leftArgs = leftFunctionData[2](leftArgs);
          rightArgs = rightFunctionData[2](rightArgs);
        } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {
          type = typeTo3D(leftType);
          leftArgs = leftFunctionData[1](leftArgs);
          rightArgs = rightFunctionData[1](rightArgs);
        } else {
          var _merged2 = mergeMatrices(left2, right2);
          leftResult = [_merged2[0]];
          rightResult = [_merged2[1]];
          types = [["matrix", [_merged2[2]]]];
          break;
        }
        var leftArgsCopy = [];
        var rightArgsCopy = [];
        var stringConversions = [];
        for (var j = 0; j < leftArgs.length; j++) {
          var _merged3 = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);
          leftArgsCopy[j] = _merged3[0];
          rightArgsCopy[j] = _merged3[1];
          stringConversions.push(_merged3[2]);
        }
        leftResult.push(leftArgsCopy);
        rightResult.push(rightArgsCopy);
        types.push([type, stringConversions]);
      }
    }
    if (flipResults) {
      var tmp2 = leftResult;
      leftResult = rightResult;
      rightResult = tmp2;
    }
    return [leftResult, rightResult, function(list) {
      return list.map(function(args, i2) {
        var stringifiedArgs = args.map(function(arg, j2) {
          return types[i2][1][j2](arg);
        }).join(",");
        if (types[i2][0] === "matrix" && stringifiedArgs.split(",").length === 16) {
          types[i2][0] = "matrix3d";
        }
        if (types[i2][0] === "matrix3d" && stringifiedArgs.split(",").length === 6) {
          types[i2][0] = "matrix";
        }
        return "".concat(types[i2][0], "(").concat(stringifiedArgs, ")");
      }).join(" ");
    }];
  }
  var parseTransformOrigin = memoize2(function(value2) {
    if (isString2(value2)) {
      if (value2 === "text-anchor") {
        return [getOrCreateUnitValue(0, "px"), getOrCreateUnitValue(0, "px")];
      }
      var values = value2.split(" ");
      if (values.length === 1) {
        if (values[0] === "top" || values[0] === "bottom") {
          values[1] = values[0];
          values[0] = "center";
        } else {
          values[1] = "center";
        }
      }
      if (values.length !== 2) {
        return null;
      }
      return [parseLengthOrPercentage(convertKeyword2Percent(values[0])), parseLengthOrPercentage(convertKeyword2Percent(values[1]))];
    }
    return [getOrCreateUnitValue(value2[0] || 0, "px"), getOrCreateUnitValue(value2[1] || 0, "px")];
  });
  function convertKeyword2Percent(keyword) {
    if (keyword === "center") {
      return "50%";
    }
    if (keyword === "left" || keyword === "top") {
      return "0%";
    }
    if (keyword === "right" || keyword === "bottom") {
      return "100%";
    }
    return keyword;
  }
  var BUILT_IN_PROPERTIES = [
    {
      /**
       * used in CSS Layout API
       * eg. `display: 'flex'`
       */
      n: "display",
      k: ["none"]
    },
    {
      /**
       * range [0.0, 1.0]
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
       */
      n: "opacity",
      "int": true,
      inh: true,
      d: "1",
      syntax: PropertySyntax.OPACITY_VALUE
    },
    {
      /**
       * inheritable, range [0.0, 1.0]
       * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
       * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
       */
      n: "fillOpacity",
      "int": true,
      inh: true,
      d: "1",
      syntax: PropertySyntax.OPACITY_VALUE
    },
    {
      /**
       * inheritable, range [0.0, 1.0]
       * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
       * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
       */
      n: "strokeOpacity",
      "int": true,
      inh: true,
      d: "1",
      syntax: PropertySyntax.OPACITY_VALUE
    },
    {
      /**
       * background-color is not inheritable
       * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
       */
      n: "fill",
      "int": true,
      k: ["none"],
      d: "none",
      syntax: PropertySyntax.PAINT
    },
    {
      n: "fillRule",
      k: ["nonzero", "evenodd"],
      d: "nonzero"
    },
    /**
     * default to none
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
     */
    {
      n: "stroke",
      "int": true,
      k: ["none"],
      d: "none",
      syntax: PropertySyntax.PAINT,
      /**
       * Stroke 'none' won't affect geometry but others will.
       */
      l: true
    },
    {
      n: "shadowType",
      k: ["inner", "outer", "both"],
      d: "outer",
      l: true
    },
    {
      n: "shadowColor",
      "int": true,
      syntax: PropertySyntax.COLOR
    },
    {
      n: "shadowOffsetX",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "shadowOffsetY",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "shadowBlur",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.SHADOW_BLUR
    },
    {
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
       */
      n: "lineWidth",
      "int": true,
      inh: true,
      d: "1",
      l: true,
      a: ["strokeWidth"],
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "increasedLineWidthForHitTesting",
      inh: true,
      d: "0",
      l: true,
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "lineJoin",
      inh: true,
      l: true,
      a: ["strokeLinejoin"],
      k: ["miter", "bevel", "round"],
      d: "miter"
    },
    {
      n: "lineCap",
      inh: true,
      l: true,
      a: ["strokeLinecap"],
      k: ["butt", "round", "square"],
      d: "butt"
    },
    {
      n: "lineDash",
      "int": true,
      inh: true,
      k: ["none"],
      a: ["strokeDasharray"],
      syntax: PropertySyntax.LENGTH_PERCENTAGE_12
    },
    {
      n: "lineDashOffset",
      "int": true,
      inh: true,
      d: "0",
      a: ["strokeDashoffset"],
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "offsetPath",
      syntax: PropertySyntax.DEFINED_PATH
    },
    {
      n: "offsetDistance",
      "int": true,
      syntax: PropertySyntax.OFFSET_DISTANCE
    },
    {
      n: "dx",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "dy",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "zIndex",
      ind: true,
      "int": true,
      d: "0",
      k: ["auto"],
      syntax: PropertySyntax.Z_INDEX
    },
    {
      n: "visibility",
      k: ["visible", "hidden"],
      ind: true,
      inh: true,
      /**
       * support interpolation
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
       */
      "int": true,
      d: "visible"
    },
    {
      n: "pointerEvents",
      inh: true,
      k: [
        "none",
        "auto",
        "stroke",
        "fill",
        "painted",
        "visible",
        "visiblestroke",
        "visiblefill",
        "visiblepainted",
        // 'bounding-box',
        "all"
      ],
      d: "auto"
    },
    {
      n: "filter",
      ind: true,
      l: true,
      k: ["none"],
      d: "none",
      syntax: PropertySyntax.FILTER
    },
    {
      n: "clipPath",
      syntax: PropertySyntax.DEFINED_PATH
    },
    {
      n: "textPath",
      syntax: PropertySyntax.DEFINED_PATH
    },
    {
      n: "textPathSide",
      k: ["left", "right"],
      d: "left"
    },
    {
      n: "textPathStartOffset",
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "transform",
      p: 100,
      "int": true,
      k: ["none"],
      d: "none",
      syntax: PropertySyntax.TRANSFORM
    },
    {
      n: "transformOrigin",
      p: 100,
      d: "0 0",
      // // int: true,
      // d: (nodeName: string) => {
      //   if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
      //     return 'center';
      //   }
      //   if (nodeName === Shape.TEXT) {
      //     return 'text-anchor';
      //   }
      //   return 'left top';
      // },
      l: true,
      syntax: PropertySyntax.TRANSFORM_ORIGIN
    },
    {
      n: "cx",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "cy",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "cz",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "r",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "rx",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "ry",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    // Rect Image Group
    {
      // x in local space
      n: "x",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      // y in local space
      n: "y",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      // z in local space
      n: "z",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "width",
      "int": true,
      l: true,
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
       */
      k: ["auto", "fit-content", "min-content", "max-content"],
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "height",
      "int": true,
      l: true,
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
       */
      k: ["auto", "fit-content", "min-content", "max-content"],
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "radius",
      "int": true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE_14
    },
    // Line
    {
      n: "x1",
      "int": true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "y1",
      "int": true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "z1",
      "int": true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "x2",
      "int": true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "y2",
      "int": true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "z2",
      "int": true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    // Path
    {
      n: "d",
      "int": true,
      l: true,
      d: "",
      syntax: PropertySyntax.PATH,
      p: 50
    },
    // Polyline & Polygon
    {
      n: "points",
      /**
       * support interpolation
       */
      "int": true,
      l: true,
      syntax: PropertySyntax.LIST_OF_POINTS,
      p: 50
    },
    // Text
    {
      n: "text",
      l: true,
      d: "",
      syntax: PropertySyntax.TEXT,
      p: 50
    },
    {
      n: "textTransform",
      l: true,
      inh: true,
      k: ["capitalize", "uppercase", "lowercase", "none"],
      d: "none",
      syntax: PropertySyntax.TEXT_TRANSFORM,
      p: 51
      // it must get parsed after text
    },
    {
      n: "font",
      l: true
    },
    {
      n: "fontSize",
      "int": true,
      inh: true,
      /**
       * @see https://www.w3schools.com/css/css_font_size.asp
       */
      d: "16px",
      l: true,
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "fontFamily",
      l: true,
      inh: true,
      d: "sans-serif"
    },
    {
      n: "fontStyle",
      l: true,
      inh: true,
      k: ["normal", "italic", "oblique"],
      d: "normal"
    },
    {
      n: "fontWeight",
      l: true,
      inh: true,
      k: ["normal", "bold", "bolder", "lighter"],
      d: "normal"
    },
    {
      n: "fontVariant",
      l: true,
      inh: true,
      k: ["normal", "small-caps"],
      d: "normal"
    },
    {
      n: "lineHeight",
      l: true,
      syntax: PropertySyntax.LENGTH,
      "int": true,
      d: "0"
    },
    {
      n: "letterSpacing",
      l: true,
      syntax: PropertySyntax.LENGTH,
      "int": true,
      d: "0"
    },
    {
      n: "miterLimit",
      l: true,
      syntax: PropertySyntax.NUMBER,
      d: function d(nodeName) {
        if (nodeName === Shape.PATH || nodeName === Shape.POLYGON || nodeName === Shape.POLYLINE) {
          return "4";
        }
        return "10";
      }
    },
    {
      n: "wordWrap",
      l: true
    },
    {
      n: "wordWrapWidth",
      l: true
    },
    {
      n: "maxLines",
      l: true
    },
    {
      n: "textOverflow",
      l: true,
      d: "clip"
    },
    {
      n: "leading",
      l: true
    },
    {
      n: "textBaseline",
      l: true,
      inh: true,
      k: ["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"],
      d: "alphabetic"
    },
    {
      n: "textAlign",
      l: true,
      inh: true,
      k: ["start", "center", "middle", "end", "left", "right"],
      d: "start"
    },
    // {
    //   n: 'whiteSpace',
    //   l: true,
    // },
    {
      n: "markerStart",
      syntax: PropertySyntax.MARKER
    },
    {
      n: "markerEnd",
      syntax: PropertySyntax.MARKER
    },
    {
      n: "markerMid",
      syntax: PropertySyntax.MARKER
    },
    {
      n: "markerStartOffset",
      syntax: PropertySyntax.LENGTH,
      l: true,
      "int": true,
      d: "0"
    },
    {
      n: "markerEndOffset",
      syntax: PropertySyntax.LENGTH,
      l: true,
      "int": true,
      d: "0"
    }
  ];
  var GEOMETRY_ATTRIBUTE_NAMES = new Set(BUILT_IN_PROPERTIES.filter(function(n2) {
    return !!n2.l;
  }).map(function(n2) {
    return n2.n;
  }));
  var propertyMetadataCache = {};
  var DefaultStyleValueRegistry = /* @__PURE__ */ function() {
    function DefaultStyleValueRegistry2(runtime2) {
      var _this = this;
      _classCallCheck(this, DefaultStyleValueRegistry2);
      this.runtime = runtime2;
      BUILT_IN_PROPERTIES.forEach(function(property) {
        _this.registerMetadata(property);
      });
    }
    return _createClass(DefaultStyleValueRegistry2, [{
      key: "registerMetadata",
      value: function registerMetadata(metadata) {
        [metadata.n].concat(_toConsumableArray(metadata.a || [])).forEach(function(name2) {
          propertyMetadataCache[name2] = metadata;
        });
      }
    }, {
      key: "getPropertySyntax",
      value: function getPropertySyntax(syntax) {
        return this.runtime.CSSPropertySyntaxFactory[syntax];
      }
      /**
       * * parse value, eg.
       * fill: 'red' => CSSRGB
       * translateX: '10px' => CSSUnitValue { unit: 'px', value: 10 }
       * fontSize: '2em' => { unit: 'px', value: 32 }
       *
       * * calculate used value
       * * post process
       */
    }, {
      key: "processProperties",
      value: function processProperties(object, attributes) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
          skipUpdateAttribute: false,
          skipParse: false,
          forceUpdateGeometry: false,
          usedAttributes: [],
          memoize: true
        };
        Object.assign(object.attributes, attributes);
        var oldClipPath = object.parsedStyle.clipPath;
        var oldOffsetPath = object.parsedStyle.offsetPath;
        assignParsedStyle(object, attributes);
        var needUpdateGeometry = !!options.forceUpdateGeometry;
        if (!needUpdateGeometry) {
          for (var i in attributes) {
            if (GEOMETRY_ATTRIBUTE_NAMES.has(i)) {
              needUpdateGeometry = true;
              break;
            }
          }
        }
        var list = getParsedStyleListOf(object);
        if (list.has("fill") && attributes.fill) {
          object.parsedStyle.fill = parseColor(attributes.fill);
        }
        if (list.has("stroke") && attributes.stroke) {
          object.parsedStyle.stroke = parseColor(attributes.stroke);
        }
        if (list.has("shadowColor") && attributes.shadowColor) {
          object.parsedStyle.shadowColor = parseColor(attributes.shadowColor);
        }
        if (list.has("filter") && attributes.filter) {
          object.parsedStyle.filter = parseFilter(attributes.filter);
        }
        if (list.has("radius") && !isNil(attributes.radius)) {
          object.parsedStyle.radius = parseDimensionArrayFormat(
            // @ts-ignore
            attributes.radius,
            4
          );
        }
        if (list.has("lineDash") && !isNil(attributes.lineDash)) {
          object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, "even");
        }
        if (list.has("points") && attributes.points) {
          object.parsedStyle.points = parsePoints(attributes.points);
        }
        if (list.has("d") && attributes.d === "") {
          object.parsedStyle.d = _objectSpread22({}, EMPTY_PARSED_PATH);
        }
        if (list.has("d") && attributes.d) {
          object.parsedStyle.d = parsePath(
            // @ts-ignore
            attributes.d
          );
        }
        if (list.has("textTransform") && attributes.textTransform) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TEXT_TRANSFORM].calculator(null, null, {
            value: attributes.textTransform
          }, object, null);
        }
        if (list.has("clipPath") && !is_undefined_default(attributes.clipPath)) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator("clipPath", oldClipPath, attributes.clipPath, object, this.runtime);
        }
        if (list.has("offsetPath") && attributes.offsetPath) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.DEFINED_PATH].calculator("offsetPath", oldOffsetPath, attributes.offsetPath, object, this.runtime);
        }
        if (list.has("transform") && attributes.transform) {
          object.parsedStyle.transform = parseTransform(attributes.transform);
        }
        if (list.has("transformOrigin") && attributes.transformOrigin) {
          object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);
        }
        if (list.has("markerStart") && attributes.markerStart) {
          object.parsedStyle.markerStart = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
            null,
            // @ts-ignore
            attributes.markerStart,
            // @ts-ignore
            attributes.markerStart,
            null,
            null
          );
        }
        if (list.has("markerEnd") && attributes.markerEnd) {
          object.parsedStyle.markerEnd = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
            null,
            // @ts-ignore
            attributes.markerEnd,
            // @ts-ignore
            attributes.markerEnd,
            null,
            null
          );
        }
        if (list.has("markerMid") && attributes.markerMid) {
          object.parsedStyle.markerMid = this.runtime.CSSPropertySyntaxFactory[PropertySyntax.MARKER].calculator(
            "",
            // @ts-ignore
            attributes.markerMid,
            // @ts-ignore
            attributes.markerMid,
            null,
            null
          );
        }
        if (list.has("zIndex") && !isNil(attributes.zIndex)) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.Z_INDEX].postProcessor(object);
        }
        if (list.has("offsetDistance") && !isNil(attributes.offsetDistance)) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.OFFSET_DISTANCE].postProcessor(object);
        }
        if (list.has("transform") && attributes.transform) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM].postProcessor(object);
        }
        if (list.has("transformOrigin") && attributes.transformOrigin) {
          this.runtime.CSSPropertySyntaxFactory[PropertySyntax.TRANSFORM_ORIGIN].postProcessor(object);
        }
        if (needUpdateGeometry) {
          object.geometry.dirty = true;
          object.renderable.boundsDirty = true;
          object.renderable.renderBoundsDirty = true;
          if (!options.forceUpdateGeometry) {
            this.runtime.sceneGraphService.dirtifyToRoot(object);
          }
        }
      }
      /**
       * update geometry when relative props changed,
       * eg. r of Circle, width/height of Rect
       */
    }, {
      key: "updateGeometry",
      value: function updateGeometry(object) {
        var nodeName = object.nodeName;
        var geometryUpdater = this.runtime.geometryUpdaterFactory[nodeName];
        if (geometryUpdater) {
          var geometry = object.geometry;
          if (!geometry.contentBounds) {
            geometry.contentBounds = new AABB();
          }
          if (!geometry.renderBounds) {
            geometry.renderBounds = new AABB();
          }
          var parsedStyle = object.parsedStyle;
          var _geometryUpdater$upda = geometryUpdater.update(parsedStyle, object), _geometryUpdater$upda2 = _geometryUpdater$upda.cx, cx = _geometryUpdater$upda2 === void 0 ? 0 : _geometryUpdater$upda2, _geometryUpdater$upda3 = _geometryUpdater$upda.cy, cy = _geometryUpdater$upda3 === void 0 ? 0 : _geometryUpdater$upda3, _geometryUpdater$upda4 = _geometryUpdater$upda.cz, cz = _geometryUpdater$upda4 === void 0 ? 0 : _geometryUpdater$upda4, _geometryUpdater$upda5 = _geometryUpdater$upda.hwidth, hwidth = _geometryUpdater$upda5 === void 0 ? 0 : _geometryUpdater$upda5, _geometryUpdater$upda6 = _geometryUpdater$upda.hheight, hheight = _geometryUpdater$upda6 === void 0 ? 0 : _geometryUpdater$upda6, _geometryUpdater$upda7 = _geometryUpdater$upda.hdepth, hdepth = _geometryUpdater$upda7 === void 0 ? 0 : _geometryUpdater$upda7;
          var halfExtents = [Math.abs(hwidth), Math.abs(hheight), hdepth];
          var stroke2 = parsedStyle.stroke, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$increase = parsedStyle.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _parsedStyle$increase === void 0 ? 0 : _parsedStyle$increase, _parsedStyle$shadowTy = parsedStyle.shadowType, shadowType = _parsedStyle$shadowTy === void 0 ? "outer" : _parsedStyle$shadowTy, shadowColor = parsedStyle.shadowColor, _parsedStyle$filter = parsedStyle.filter, filter2 = _parsedStyle$filter === void 0 ? [] : _parsedStyle$filter, transformOrigin = parsedStyle.transformOrigin;
          var center2 = [cx, cy, cz];
          geometry.contentBounds.update(center2, halfExtents);
          var expansion = nodeName === Shape.POLYLINE || nodeName === Shape.POLYGON || nodeName === Shape.PATH ? Math.SQRT2 : 0.5;
          var hasStroke = stroke2 && !stroke2.isNone;
          if (hasStroke) {
            var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;
            halfExtents[0] += halfLineWidth;
            halfExtents[1] += halfLineWidth;
          }
          geometry.renderBounds.update(center2, halfExtents);
          if (shadowColor && shadowType && shadowType !== "inner") {
            var _geometry$renderBound = geometry.renderBounds, min10 = _geometry$renderBound.min, max11 = _geometry$renderBound.max;
            var shadowBlur = parsedStyle.shadowBlur, shadowOffsetX = parsedStyle.shadowOffsetX, shadowOffsetY = parsedStyle.shadowOffsetY;
            var shadowBlurInPixels = shadowBlur || 0;
            var shadowOffsetXInPixels = shadowOffsetX || 0;
            var shadowOffsetYInPixels = shadowOffsetY || 0;
            var shadowLeft = min10[0] - shadowBlurInPixels + shadowOffsetXInPixels;
            var shadowRight = max11[0] + shadowBlurInPixels + shadowOffsetXInPixels;
            var shadowTop = min10[1] - shadowBlurInPixels + shadowOffsetYInPixels;
            var shadowBottom = max11[1] + shadowBlurInPixels + shadowOffsetYInPixels;
            min10[0] = Math.min(min10[0], shadowLeft);
            max11[0] = Math.max(max11[0], shadowRight);
            min10[1] = Math.min(min10[1], shadowTop);
            max11[1] = Math.max(max11[1], shadowBottom);
            geometry.renderBounds.setMinMax(min10, max11);
          }
          filter2.forEach(function(_ref) {
            var name2 = _ref.name, params = _ref.params;
            if (name2 === "blur") {
              var blurRadius = params[0].value;
              geometry.renderBounds.update(geometry.renderBounds.center, vec3_exports.add(geometry.renderBounds.halfExtents, geometry.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
            } else if (name2 === "drop-shadow") {
              var _shadowOffsetX = params[0].value;
              var _shadowOffsetY = params[1].value;
              var _shadowBlur = params[2].value;
              var _geometry$renderBound2 = geometry.renderBounds, _min = _geometry$renderBound2.min, _max = _geometry$renderBound2.max;
              var _shadowLeft = _min[0] - _shadowBlur + _shadowOffsetX;
              var _shadowRight = _max[0] + _shadowBlur + _shadowOffsetX;
              var _shadowTop = _min[1] - _shadowBlur + _shadowOffsetY;
              var _shadowBottom = _max[1] + _shadowBlur + _shadowOffsetY;
              _min[0] = Math.min(_min[0], _shadowLeft);
              _max[0] = Math.max(_max[0], _shadowRight);
              _min[1] = Math.min(_min[1], _shadowTop);
              _max[1] = Math.max(_max[1], _shadowBottom);
              geometry.renderBounds.setMinMax(_min, _max);
            }
          });
          object.geometry.dirty = false;
          var flipY = hwidth < 0;
          var flipX = hheight < 0;
          var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[0], 0, object, true) : 0);
          var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[1], 1, object, true) : 0);
          if (usedOriginXValue || usedOriginYValue) {
            object.setOrigin(usedOriginXValue, usedOriginYValue);
          }
        }
      }
    }, {
      key: "updateSizeAttenuation",
      value: function updateSizeAttenuation(node, zoom) {
        if (node.style.isSizeAttenuation) {
          if (!node.style.rawLineWidth) {
            node.style.rawLineWidth = node.style.lineWidth;
          }
          node.style.lineWidth = (node.style.rawLineWidth || 1) / zoom;
          if (node.nodeName === Shape.CIRCLE) {
            if (!node.style.rawR) {
              node.style.rawR = node.style.r;
            }
            node.style.r = (node.style.rawR || 1) / zoom;
          }
        } else {
          if (node.style.rawLineWidth) {
            node.style.lineWidth = node.style.rawLineWidth;
            delete node.style.rawLineWidth;
          }
          if (node.nodeName === Shape.CIRCLE) {
            if (node.style.rawR) {
              node.style.r = node.style.rawR;
              delete node.style.rawR;
            }
          }
        }
      }
    }]);
  }();
  function assignParsedStyle(object, attributes) {
    var list = getParsedStyleListOf(object);
    for (var key in attributes) {
      if (list.has(key)) {
        object.parsedStyle[key] = attributes[key];
      }
    }
  }
  function getParsedStyleListOf(object) {
    return object.constructor.PARSED_STYLE_LIST;
  }
  var CSSPropertyAngle = /* @__PURE__ */ function() {
    function CSSPropertyAngle2() {
      _classCallCheck(this, CSSPropertyAngle2);
      this.mixer = mergeNumbers;
    }
    return _createClass(CSSPropertyAngle2, [{
      key: "calculator",
      value: function calculator(name2, oldParsed, parsed, object) {
        return convertAngleUnit(parsed);
      }
    }]);
  }();
  var CSSPropertyClipPath = /* @__PURE__ */ function() {
    function CSSPropertyClipPath2() {
      _classCallCheck(this, CSSPropertyClipPath2);
    }
    return _createClass(CSSPropertyClipPath2, [{
      key: "calculator",
      value: function calculator(name2, oldPath, newPath, object, runtime2) {
        if (newPath instanceof CSSKeywordValue) {
          newPath = null;
        }
        runtime2.sceneGraphService.updateDisplayObjectDependency(name2, oldPath, newPath, object);
        if (name2 === "clipPath") {
          object.forEach(function(leaf) {
            if (leaf.childNodes.length === 0) {
              runtime2.sceneGraphService.dirtifyToRoot(leaf);
            }
          });
        }
        return newPath;
      }
    }]);
  }();
  var CSSPropertyColor = /* @__PURE__ */ function() {
    function CSSPropertyColor2() {
      _classCallCheck(this, CSSPropertyColor2);
      this.parser = parseColor;
      this.mixer = mergeColors;
    }
    return _createClass(CSSPropertyColor2, [{
      key: "calculator",
      value: function calculator(name2, oldParsed, parsed, object) {
        if (parsed instanceof CSSKeywordValue) {
          return parsed.value === "none" ? noneColor : transparentColor;
        }
        return parsed;
      }
    }]);
  }();
  var CSSPropertyFilter = /* @__PURE__ */ function() {
    function CSSPropertyFilter2() {
      _classCallCheck(this, CSSPropertyFilter2);
    }
    return _createClass(CSSPropertyFilter2, [{
      key: "calculator",
      value: function calculator(name2, oldParsed, parsed) {
        if (parsed instanceof CSSKeywordValue) {
          return [];
        }
        return parsed;
      }
    }]);
  }();
  function getFontSize(object) {
    var _ref = object.parsedStyle, fontSize = _ref.fontSize;
    return isNil(fontSize) ? null : fontSize;
  }
  var CSSPropertyLengthOrPercentage = /* @__PURE__ */ function() {
    function CSSPropertyLengthOrPercentage2() {
      _classCallCheck(this, CSSPropertyLengthOrPercentage2);
      this.mixer = mergeNumbers;
    }
    return _createClass(CSSPropertyLengthOrPercentage2, [{
      key: "calculator",
      value: (
        /**
         * according to parent's bounds
         *
         * @example
         * CSS.percent(50) -> CSS.px(0.5 * parent.width)
         */
        function calculator(name2, oldParsed, computed, object, runtime2) {
          if (isNumber2(computed)) {
            return computed;
          }
          if (CSSUnitValue.isRelativeUnit(computed.unit)) {
            if (computed.unit === UnitType.kPercentage) {
              return 0;
            }
            if (computed.unit === UnitType.kEms) {
              if (object.parentNode) {
                var fontSize = getFontSize(object.parentNode);
                if (fontSize) {
                  fontSize *= computed.value;
                  return fontSize;
                }
              }
              return 0;
            }
            if (computed.unit === UnitType.kRems) {
              var _object$ownerDocument;
              if (object !== null && object !== void 0 && (_object$ownerDocument = object.ownerDocument) !== null && _object$ownerDocument !== void 0 && _object$ownerDocument.documentElement) {
                var _fontSize = getFontSize(object.ownerDocument.documentElement);
                if (_fontSize) {
                  _fontSize *= computed.value;
                  return _fontSize;
                }
              }
              return 0;
            }
          } else {
            return computed.value;
          }
        }
      )
    }]);
  }();
  var CSSPropertyLengthOrPercentage12 = /* @__PURE__ */ function() {
    function CSSPropertyLengthOrPercentage122() {
      _classCallCheck(this, CSSPropertyLengthOrPercentage122);
      this.mixer = mergeNumberLists;
    }
    return _createClass(CSSPropertyLengthOrPercentage122, [{
      key: "calculator",
      value: function calculator(name2, oldParsed, computed) {
        return computed.map(function(c5) {
          return c5.value;
        });
      }
    }]);
  }();
  var CSSPropertyLengthOrPercentage14 = /* @__PURE__ */ function() {
    function CSSPropertyLengthOrPercentage142() {
      _classCallCheck(this, CSSPropertyLengthOrPercentage142);
      this.mixer = mergeNumberLists;
    }
    return _createClass(CSSPropertyLengthOrPercentage142, [{
      key: "calculator",
      value: function calculator(name2, oldParsed, computed) {
        return computed.map(function(c5) {
          return c5.value;
        });
      }
    }]);
  }();
  var CSSPropertyMarker = /* @__PURE__ */ function() {
    function CSSPropertyMarker2() {
      _classCallCheck(this, CSSPropertyMarker2);
    }
    return _createClass(CSSPropertyMarker2, [{
      key: "calculator",
      value: function calculator(name2, oldMarker, newMarker, object) {
        var _newMarker;
        if (newMarker instanceof CSSKeywordValue) {
          newMarker = null;
        }
        var cloned = (_newMarker = newMarker) === null || _newMarker === void 0 ? void 0 : _newMarker.cloneNode(true);
        if (cloned) {
          cloned.style.isMarker = true;
        }
        return cloned;
      }
    }]);
  }();
  var CSSPropertyNumber = /* @__PURE__ */ function() {
    function CSSPropertyNumber2() {
      _classCallCheck(this, CSSPropertyNumber2);
      this.mixer = mergeNumbers;
    }
    return _createClass(CSSPropertyNumber2, [{
      key: "calculator",
      value: function calculator(name2, oldParsed, computed) {
        return computed.value;
      }
    }]);
  }();
  var CSSPropertyOffsetDistance = /* @__PURE__ */ function() {
    function CSSPropertyOffsetDistance2() {
      _classCallCheck(this, CSSPropertyOffsetDistance2);
      this.mixer = clampedMergeNumbers(0, 1);
    }
    return _createClass(CSSPropertyOffsetDistance2, [{
      key: "calculator",
      value: function calculator(name2, oldParsed, computed) {
        return computed.value;
      }
    }, {
      key: "postProcessor",
      value: function postProcessor(object) {
        var _object$parsedStyle = object.parsedStyle, offsetPath = _object$parsedStyle.offsetPath, offsetDistance = _object$parsedStyle.offsetDistance;
        if (!offsetPath) {
          return;
        }
        var nodeName = offsetPath.nodeName;
        if (nodeName === Shape.LINE || nodeName === Shape.PATH || nodeName === Shape.POLYLINE) {
          var point6 = offsetPath.getPoint(offsetDistance);
          if (point6) {
            object.setLocalPosition(point6.x, point6.y);
          }
        }
      }
    }]);
  }();
  var CSSPropertyOpacity = /* @__PURE__ */ function() {
    function CSSPropertyOpacity2() {
      _classCallCheck(this, CSSPropertyOpacity2);
      this.mixer = clampedMergeNumbers(0, 1);
    }
    return _createClass(CSSPropertyOpacity2, [{
      key: "calculator",
      value: function calculator(name2, oldParsed, computed) {
        return computed.value;
      }
    }]);
  }();
  var CSSPropertyPath = /* @__PURE__ */ function() {
    function CSSPropertyPath2() {
      _classCallCheck(this, CSSPropertyPath2);
      this.parser = parsePath;
      this.mixer = mergePaths;
    }
    return _createClass(CSSPropertyPath2, [{
      key: "calculator",
      value: function calculator(name2, oldParsed, parsed) {
        if (parsed instanceof CSSKeywordValue && parsed.value === "unset") {
          return {
            absolutePath: [],
            hasArc: false,
            segments: [],
            polygons: [],
            polylines: [],
            curve: null,
            totalLength: 0,
            rect: new Rectangle(0, 0, 0, 0)
          };
        }
        return parsed;
      }
    }]);
  }();
  var CSSPropertyPoints = /* @__PURE__ */ _createClass(function CSSPropertyPoints2() {
    _classCallCheck(this, CSSPropertyPoints2);
    this.mixer = mergePoints;
  });
  var CSSPropertyShadowBlur = /* @__PURE__ */ function(_CSSPropertyLengthOrP) {
    function CSSPropertyShadowBlur2() {
      var _this;
      _classCallCheck(this, CSSPropertyShadowBlur2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, CSSPropertyShadowBlur2, [].concat(args));
      _this.mixer = clampedMergeNumbers(0, Infinity);
      return _this;
    }
    _inherits(CSSPropertyShadowBlur2, _CSSPropertyLengthOrP);
    return _createClass(CSSPropertyShadowBlur2);
  }(CSSPropertyLengthOrPercentage);
  var CSSPropertyText = /* @__PURE__ */ function() {
    function CSSPropertyText2() {
      _classCallCheck(this, CSSPropertyText2);
    }
    return _createClass(CSSPropertyText2, [{
      key: "calculator",
      value: function calculator(name2, oldParsed, parsed, object) {
        if (parsed instanceof CSSKeywordValue) {
          if (parsed.value === "unset") {
            return "";
          }
          return parsed.value;
        }
        return "".concat(parsed);
      }
    }, {
      key: "postProcessor",
      value: function postProcessor(object) {
        object.nodeValue = "".concat(object.parsedStyle.text) || "";
      }
    }]);
  }();
  var CSSPropertyTextTransform = /* @__PURE__ */ function() {
    function CSSPropertyTextTransform2() {
      _classCallCheck(this, CSSPropertyTextTransform2);
    }
    return _createClass(CSSPropertyTextTransform2, [{
      key: "calculator",
      value: function calculator(name2, oldParsed, parsed, object) {
        var rawText = object.getAttribute("text");
        if (rawText) {
          var transformedText = rawText;
          if (parsed.value === "capitalize") {
            transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
          } else if (parsed.value === "lowercase") {
            transformedText = rawText.toLowerCase();
          } else if (parsed.value === "uppercase") {
            transformedText = rawText.toUpperCase();
          }
          object.parsedStyle.text = transformedText;
        }
        return parsed.value;
      }
    }]);
  }();
  var CANVAS_Map = /* @__PURE__ */ new WeakMap();
  function cleanExistedCanvas(container, canvas, cleanUp) {
    if (container) {
      var $dom = typeof container === "string" ? document.getElementById(container) : container;
      if (CANVAS_Map.has($dom)) CANVAS_Map.get($dom).destroy(cleanUp);
      CANVAS_Map.set($dom, canvas);
    }
  }
  var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  function isElement(target) {
    return !!target.getAttribute;
  }
  function sortedIndex(array2, value2) {
    var low = 0;
    var high = array2.length;
    while (low < high) {
      var mid2 = low + high >>> 1;
      if (sortByZIndex(array2[mid2], value2) < 0) {
        low = mid2 + 1;
      } else {
        high = mid2;
      }
    }
    return low;
  }
  function sortByZIndex(o1, o2) {
    var zIndex1 = Number(o1.parsedStyle.zIndex || 0);
    var zIndex2 = Number(o2.parsedStyle.zIndex || 0);
    if (zIndex1 === zIndex2) {
      var parent = o1.parentNode;
      if (parent) {
        var children = parent.childNodes || [];
        return children.indexOf(o1) - children.indexOf(o2);
      }
    }
    return zIndex1 - zIndex2;
  }
  function findClosestClipPathTarget(object) {
    var el = object;
    do {
      var _el$parsedStyle;
      var clipPath = (_el$parsedStyle = el.parsedStyle) === null || _el$parsedStyle === void 0 ? void 0 : _el$parsedStyle.clipPath;
      if (clipPath) return el;
      el = el.parentElement;
    } while (el !== null);
    return null;
  }
  var PX_SUFFIX = "px";
  function setDOMSize($el, width, height) {
    if (isBrowser && $el.style) {
      $el.style.width = width + PX_SUFFIX;
      $el.style.height = height + PX_SUFFIX;
    }
  }
  function getStyle($el, property) {
    if (isBrowser) {
      return document.defaultView.getComputedStyle($el, null).getPropertyValue(property);
    }
  }
  function getWidth($el) {
    var width = getStyle($el, "width");
    if (width === "auto") {
      return $el.offsetWidth;
    }
    return parseFloat(width);
  }
  function getHeight($el) {
    var height = getStyle($el, "height");
    if (height === "auto") {
      return $el.offsetHeight;
    }
    return parseFloat(height);
  }
  var MOUSE_POINTER_ID = 1;
  var TOUCH_TO_POINTER = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
  };
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  function isInFragment(node) {
    if (node.nodeName === Shape.FRAGMENT) return true;
    return node.getRootNode().nodeName === Shape.FRAGMENT;
  }
  function isFillOrStrokeAffected() {
    var pointerEvents = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "auto";
    var fill = arguments.length > 1 ? arguments[1] : void 0;
    var stroke2 = arguments.length > 2 ? arguments[2] : void 0;
    var hasFill = false;
    var hasStroke = false;
    var isFillOtherThanNone = !!fill && !fill.isNone;
    var isStrokeOtherThanNone = !!stroke2 && !stroke2.isNone;
    if (pointerEvents === "visiblepainted" || pointerEvents === "painted" || pointerEvents === "auto") {
      hasFill = isFillOtherThanNone;
      hasStroke = isStrokeOtherThanNone;
    } else if (pointerEvents === "visiblefill" || pointerEvents === "fill") {
      hasFill = true;
    } else if (pointerEvents === "visiblestroke" || pointerEvents === "stroke") {
      hasStroke = true;
    } else if (pointerEvents === "visible" || pointerEvents === "all") {
      hasFill = true;
      hasStroke = true;
    }
    return [hasFill, hasStroke];
  }
  var uId = 1;
  var uniqueId = function uniqueId2() {
    return uId++;
  };
  var root = (
    // eslint-disable-next-line no-nested-ternary
    typeof self === "object" && self.self === self ? self : (
      // @ts-ignore
      typeof global === "object" && global.global === global ? (
        // @ts-ignore
        global
      ) : {}
    )
  );
  var nowOffset = Date.now();
  var pnow = function pnow2() {
    if (root.performance && typeof root.performance.now === "function") {
      return root.performance.now();
    }
    return Date.now() - nowOffset;
  };
  var reservedCBs = {};
  var lastTime = Date.now();
  var polyfillRaf = function polyfillRaf2(callback) {
    if (typeof callback !== "function") {
      throw new TypeError("".concat(callback, " is not a function"));
    }
    var currentTime = Date.now();
    var gap = currentTime - lastTime;
    var delay = gap > 16 ? 0 : 16 - gap;
    var id5 = uniqueId();
    reservedCBs[id5] = callback;
    if (Object.keys(reservedCBs).length > 1) return id5;
    setTimeout(function() {
      lastTime = currentTime;
      var copied = reservedCBs;
      reservedCBs = {};
      Object.keys(copied).forEach(function(key) {
        return copied[key](pnow());
      });
    }, delay);
    return id5;
  };
  var polyfillCaf = function polyfillCaf2(id5) {
    delete reservedCBs[id5];
  };
  var vendorPrefixes = ["", "webkit", "moz", "ms", "o"];
  var getRequestAnimationFrame = function getRequestAnimationFrame2(vp2) {
    if (typeof vp2 !== "string") return polyfillRaf;
    if (vp2 === "") return root.requestAnimationFrame;
    return root["".concat(vp2, "RequestAnimationFrame")];
  };
  var getCancelAnimationFrame = function getCancelAnimationFrame2(vp2) {
    if (typeof vp2 !== "string") return polyfillCaf;
    if (vp2 === "") return root.cancelAnimationFrame;
    return root["".concat(vp2, "CancelAnimationFrame")] || root["".concat(vp2, "CancelRequestAnimationFrame")];
  };
  var find3 = function find4(arr, predicate) {
    var i = 0;
    while (arr[i] !== void 0) {
      if (predicate(arr[i])) return arr[i];
      i += 1;
    }
  };
  var vp = find3(vendorPrefixes, function(vp2) {
    return !!getRequestAnimationFrame(vp2);
  });
  var raf = getRequestAnimationFrame(vp);
  var caf = getCancelAnimationFrame(vp);
  root.requestAnimationFrame = raf;
  root.cancelAnimationFrame = caf;
  var AsyncParallelHook = /* @__PURE__ */ function() {
    function AsyncParallelHook2() {
      _classCallCheck(this, AsyncParallelHook2);
      this.callbacks = [];
    }
    return _createClass(AsyncParallelHook2, [{
      key: "getCallbacksNum",
      value: function getCallbacksNum() {
        return this.callbacks.length;
      }
    }, {
      key: "tapPromise",
      value: function tapPromise(options, fn) {
        this.callbacks.push(fn);
      }
    }, {
      key: "promise",
      value: function promise() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return Promise.all(this.callbacks.map(function(callback) {
          return callback.apply(void 0, args);
        }));
      }
    }]);
  }();
  var AsyncSeriesWaterfallHook = /* @__PURE__ */ function() {
    function AsyncSeriesWaterfallHook2() {
      _classCallCheck(this, AsyncSeriesWaterfallHook2);
      this.callbacks = [];
    }
    return _createClass(AsyncSeriesWaterfallHook2, [{
      key: "tapPromise",
      value: function tapPromise(options, fn) {
        this.callbacks.push(fn);
      }
    }, {
      key: "promise",
      value: function() {
        var _promise = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
          var _this$callbacks, result, i, callback, _args = arguments;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                if (!this.callbacks.length) {
                  _context.next = 14;
                  break;
                }
                _context.next = 3;
                return (_this$callbacks = this.callbacks)[0].apply(_this$callbacks, _args);
              case 3:
                result = _context.sent;
                i = 0;
              case 5:
                if (!(i < this.callbacks.length - 1)) {
                  _context.next = 13;
                  break;
                }
                callback = this.callbacks[i];
                _context.next = 9;
                return callback(result);
              case 9:
                result = _context.sent;
              case 10:
                i++;
                _context.next = 5;
                break;
              case 13:
                return _context.abrupt("return", result);
              case 14:
                return _context.abrupt("return", null);
              case 15:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function promise() {
          return _promise.apply(this, arguments);
        }
        return promise;
      }()
    }]);
  }();
  var SyncHook = /* @__PURE__ */ function() {
    function SyncHook2() {
      _classCallCheck(this, SyncHook2);
      this.callbacks = [];
    }
    return _createClass(SyncHook2, [{
      key: "tap",
      value: function tap(options, fn) {
        this.callbacks.push(fn);
      }
    }, {
      key: "call",
      value: function call() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var argsArr = arguments;
        this.callbacks.forEach(function(callback) {
          callback.apply(void 0, argsArr);
        });
      }
    }]);
  }();
  var SyncWaterfallHook = /* @__PURE__ */ function() {
    function SyncWaterfallHook2() {
      _classCallCheck(this, SyncWaterfallHook2);
      this.callbacks = [];
    }
    return _createClass(SyncWaterfallHook2, [{
      key: "tap",
      value: function tap(options, fn) {
        this.callbacks.push(fn);
      }
    }, {
      key: "call",
      value: function call() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (this.callbacks.length) {
          var argsArr = arguments;
          var result = this.callbacks[0].apply(void 0, argsArr);
          for (var i = 0; i < this.callbacks.length - 1; i++) {
            var callback = this.callbacks[i];
            result = callback(result);
          }
          return result;
        }
        return null;
      }
    }]);
  }();
  var genericFontFamilies = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"];
  var stringRegExp = /([\"\'])[^\'\"]+\1/;
  function toFontString(attributes) {
    var _attributes$fontSize = attributes.fontSize, fontSize = _attributes$fontSize === void 0 ? 16 : _attributes$fontSize, _attributes$fontFamil = attributes.fontFamily, fontFamily = _attributes$fontFamil === void 0 ? "sans-serif" : _attributes$fontFamil, _attributes$fontStyle = attributes.fontStyle, fontStyle = _attributes$fontStyle === void 0 ? "normal" : _attributes$fontStyle, _attributes$fontVaria = attributes.fontVariant, fontVariant = _attributes$fontVaria === void 0 ? "normal" : _attributes$fontVaria, _attributes$fontWeigh = attributes.fontWeight, fontWeight = _attributes$fontWeigh === void 0 ? "normal" : _attributes$fontWeigh;
    var fontSizeString = isNumber2(fontSize) && "".concat(fontSize, "px") || "16px";
    var fontFamilies = fontFamily.split(",");
    for (var i = fontFamilies.length - 1; i >= 0; i--) {
      var _fontFamily = fontFamilies[i].trim();
      if (!stringRegExp.test(_fontFamily) && genericFontFamilies.indexOf(_fontFamily) < 0) {
        _fontFamily = '"'.concat(_fontFamily, '"');
      }
      fontFamilies[i] = _fontFamily;
    }
    return "".concat(fontStyle, " ").concat(fontVariant, " ").concat(fontWeight, " ").concat(fontSizeString, " ").concat(fontFamilies.join(","));
  }
  function createSkewMatrix(skewMatrix, skewX2, skewY2) {
    mat4_exports.identity(skewMatrix);
    skewMatrix[4] = Math.tan(skewX2);
    skewMatrix[1] = Math.tan(skewY2);
    return skewMatrix;
  }
  var $mat4_1 = mat4_exports.create();
  var $mat4_2 = mat4_exports.create();
  var parser = {
    scale: function scale7(d3) {
      mat4_exports.fromScaling($mat4_1, [d3[0].value, d3[1].value, 1]);
    },
    scaleX: function scaleX(d3) {
      mat4_exports.fromScaling($mat4_1, [d3[0].value, 1, 1]);
    },
    scaleY: function scaleY(d3) {
      mat4_exports.fromScaling($mat4_1, [1, d3[0].value, 1]);
    },
    scaleZ: function scaleZ(d3) {
      mat4_exports.fromScaling($mat4_1, [1, 1, d3[0].value]);
    },
    scale3d: function scale3d(d3) {
      mat4_exports.fromScaling($mat4_1, [d3[0].value, d3[1].value, d3[2].value]);
    },
    translate: function translate3(d3) {
      mat4_exports.fromTranslation($mat4_1, [d3[0].value, d3[1].value, 0]);
    },
    translateX: function translateX(d3) {
      mat4_exports.fromTranslation($mat4_1, [d3[0].value, 0, 0]);
    },
    translateY: function translateY(d3) {
      mat4_exports.fromTranslation($mat4_1, [0, d3[0].value, 0]);
    },
    translateZ: function translateZ(d3) {
      mat4_exports.fromTranslation($mat4_1, [0, 0, d3[0].value]);
    },
    translate3d: function translate3d(d3) {
      mat4_exports.fromTranslation($mat4_1, [d3[0].value, d3[1].value, d3[2].value]);
    },
    rotate: function rotate4(d3) {
      mat4_exports.fromZRotation($mat4_1, deg2rad(convertAngleUnit(d3[0])));
    },
    rotateX: function rotateX4(d3) {
      mat4_exports.fromXRotation($mat4_1, deg2rad(convertAngleUnit(d3[0])));
    },
    rotateY: function rotateY4(d3) {
      mat4_exports.fromYRotation($mat4_1, deg2rad(convertAngleUnit(d3[0])));
    },
    rotateZ: function rotateZ4(d3) {
      mat4_exports.fromZRotation($mat4_1, deg2rad(convertAngleUnit(d3[0])));
    },
    rotate3d: function rotate3d(d3) {
      mat4_exports.fromRotation($mat4_1, deg2rad(convertAngleUnit(d3[3])), [d3[0].value, d3[1].value, d3[2].value]);
    },
    skew: function skew(d3) {
      createSkewMatrix($mat4_1, deg2rad(d3[0].value), deg2rad(d3[1].value));
    },
    skewX: function skewX(d3) {
      createSkewMatrix($mat4_1, deg2rad(d3[0].value), 0);
    },
    skewY: function skewY(d3) {
      createSkewMatrix($mat4_1, 0, deg2rad(d3[0].value));
    },
    matrix: function matrix2(d3) {
      mat4_exports.set($mat4_1, d3[0].value, d3[1].value, 0, 0, d3[2].value, d3[3].value, 0, 0, 0, 0, 1, 0, d3[4].value, d3[5].value, 0, 1);
    },
    matrix3d: function matrix3d(d3) {
      mat4_exports.set.apply(mat4_exports, [$mat4_1].concat(_toConsumableArray(d3.map(function(s3) {
        return s3.value;
      }))));
    }
  };
  var $vec3One$1 = vec3_exports.fromValues(1, 1, 1);
  var $vec3Zero$1 = vec3_exports.create();
  var optimizer = {
    translate: function translate4(object, d3) {
      runtime.sceneGraphService.setLocalScale(object, $vec3One$1, false);
      runtime.sceneGraphService.setLocalEulerAngles(object, $vec3Zero$1, void 0, void 0, false);
      runtime.sceneGraphService.setLocalPosition(object, [d3[0].value, d3[1].value, 0], false);
      runtime.sceneGraphService.dirtifyLocal(object, object.transformable);
    }
  };
  function parsedTransformToMat4(transform, object) {
    if (transform.length) {
      if (transform.length === 1 && optimizer[transform[0].t]) {
        optimizer[transform[0].t](object, transform[0].d);
        return;
      }
      var m3 = mat4_exports.identity($mat4_2);
      for (var i = 0; i < transform.length; i++) {
        var _transform$i = transform[i], t = _transform$i.t, d3 = _transform$i.d;
        var p2 = parser[t];
        if (p2) {
          p2(d3);
          mat4_exports.mul(m3, m3, $mat4_1);
        }
      }
      object.setLocalTransform(m3);
    } else {
      object.resetLocalTransform();
    }
    return object.getLocalTransform();
  }
  var CSSPropertyTransform = /* @__PURE__ */ function() {
    function CSSPropertyTransform2() {
      _classCallCheck(this, CSSPropertyTransform2);
      this.parser = parseTransformUnmemoize;
      this.mixer = mergeTransforms;
    }
    return _createClass(CSSPropertyTransform2, [{
      key: "calculator",
      value: function calculator(name2, oldParsed, parsed, object) {
        if (parsed instanceof CSSKeywordValue) {
          return [];
        }
        return parsed;
      }
    }, {
      key: "postProcessor",
      value: function postProcessor(object) {
        parsedTransformToMat4(object.parsedStyle.transform, object);
      }
    }]);
  }();
  var CSSPropertyTransformOrigin = /* @__PURE__ */ function() {
    function CSSPropertyTransformOrigin2() {
      _classCallCheck(this, CSSPropertyTransformOrigin2);
    }
    return _createClass(CSSPropertyTransformOrigin2, [{
      key: "postProcessor",
      value: function postProcessor(object) {
        var transformOrigin = object.parsedStyle.transformOrigin;
        if (transformOrigin[0].unit === UnitType.kPixels && transformOrigin[1].unit === UnitType.kPixels) {
          object.setOrigin(transformOrigin[0].value, transformOrigin[1].value);
        } else {
          object.getGeometryBounds();
        }
      }
    }]);
  }();
  var CSSPropertyZIndex = /* @__PURE__ */ function() {
    function CSSPropertyZIndex2() {
      _classCallCheck(this, CSSPropertyZIndex2);
    }
    return _createClass(CSSPropertyZIndex2, [{
      key: "calculator",
      value: function calculator(name2, oldParsed, computed, object) {
        return computed.value;
      }
    }, {
      key: "postProcessor",
      value: function postProcessor(object) {
        if (object.parentNode) {
          var parentEntity = object.parentNode;
          var parentRenderable = parentEntity.renderable;
          var parentSortable = parentEntity.sortable;
          if (parentRenderable) {
            parentRenderable.dirty = true;
          }
          if (parentSortable) {
            parentSortable.dirty = true;
            parentSortable.dirtyReason = SortReason.Z_INDEX_CHANGED;
          }
        }
      }
    }]);
  }();
  var CircleUpdater = /* @__PURE__ */ function() {
    function CircleUpdater2() {
      _classCallCheck(this, CircleUpdater2);
    }
    return _createClass(CircleUpdater2, [{
      key: "update",
      value: function update(parsedStyle, object) {
        var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$r = parsedStyle.r, r = _parsedStyle$r === void 0 ? 0 : _parsedStyle$r;
        return {
          cx,
          cy,
          hwidth: r,
          hheight: r
        };
      }
    }]);
  }();
  var EllipseUpdater = /* @__PURE__ */ function() {
    function EllipseUpdater2() {
      _classCallCheck(this, EllipseUpdater2);
    }
    return _createClass(EllipseUpdater2, [{
      key: "update",
      value: function update(parsedStyle, object) {
        var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, _parsedStyle$rx = parsedStyle.rx, rx = _parsedStyle$rx === void 0 ? 0 : _parsedStyle$rx, _parsedStyle$ry = parsedStyle.ry, ry = _parsedStyle$ry === void 0 ? 0 : _parsedStyle$ry;
        return {
          cx,
          cy,
          hwidth: rx,
          hheight: ry
        };
      }
    }]);
  }();
  var LineUpdater = /* @__PURE__ */ function() {
    function LineUpdater2() {
      _classCallCheck(this, LineUpdater2);
    }
    return _createClass(LineUpdater2, [{
      key: "update",
      value: function update(parsedStyle) {
        var x12 = parsedStyle.x1, y12 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2;
        var minX = Math.min(x12, x22);
        var maxX = Math.max(x12, x22);
        var minY = Math.min(y12, y22);
        var maxY2 = Math.max(y12, y22);
        var width = maxX - minX;
        var height = maxY2 - minY;
        var hwidth = width / 2;
        var hheight = height / 2;
        return {
          cx: minX + hwidth,
          cy: minY + hheight,
          hwidth,
          hheight
        };
      }
    }]);
  }();
  var PathUpdater = /* @__PURE__ */ function() {
    function PathUpdater2() {
      _classCallCheck(this, PathUpdater2);
    }
    return _createClass(PathUpdater2, [{
      key: "update",
      value: function update(parsedStyle) {
        var d3 = parsedStyle.d;
        var _d$rect = d3.rect, x3 = _d$rect.x, y3 = _d$rect.y, width = _d$rect.width, height = _d$rect.height;
        var hwidth = width / 2;
        var hheight = height / 2;
        return {
          cx: x3 + hwidth,
          cy: y3 + hheight,
          hwidth,
          hheight
        };
      }
    }]);
  }();
  var PolylineUpdater = /* @__PURE__ */ function() {
    function PolylineUpdater2() {
      _classCallCheck(this, PolylineUpdater2);
    }
    return _createClass(PolylineUpdater2, [{
      key: "update",
      value: function update(parsedStyle) {
        if (parsedStyle.points && isArray(parsedStyle.points.points)) {
          var points = parsedStyle.points.points;
          var minX = Math.min.apply(Math, _toConsumableArray(points.map(function(point6) {
            return point6[0];
          })));
          var maxX = Math.max.apply(Math, _toConsumableArray(points.map(function(point6) {
            return point6[0];
          })));
          var minY = Math.min.apply(Math, _toConsumableArray(points.map(function(point6) {
            return point6[1];
          })));
          var maxY2 = Math.max.apply(Math, _toConsumableArray(points.map(function(point6) {
            return point6[1];
          })));
          var width = maxX - minX;
          var height = maxY2 - minY;
          var hwidth = width / 2;
          var hheight = height / 2;
          return {
            cx: minX + hwidth,
            cy: minY + hheight,
            hwidth,
            hheight
          };
        }
        return {
          cx: 0,
          cy: 0,
          hwidth: 0,
          hheight: 0
        };
      }
    }]);
  }();
  var RectUpdater = /* @__PURE__ */ function() {
    function RectUpdater2() {
      _classCallCheck(this, RectUpdater2);
    }
    return _createClass(RectUpdater2, [{
      key: "update",
      value: function update(parsedStyle, object) {
        var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, src = parsedStyle.src, _parsedStyle$width = parsedStyle.width, width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
        var contentWidth = width;
        var contentHeight = height;
        if (src && !isString2(src)) {
          if (!contentWidth) {
            contentWidth = src.width;
            parsedStyle.width = contentWidth;
          }
          if (!contentHeight) {
            contentHeight = src.height;
            parsedStyle.height = contentHeight;
          }
        }
        return {
          cx: x3 + contentWidth / 2,
          cy: y3 + contentHeight / 2,
          hwidth: contentWidth / 2,
          hheight: contentHeight / 2
        };
      }
    }]);
  }();
  var TextUpdater = /* @__PURE__ */ function() {
    function TextUpdater2(globalRuntime) {
      _classCallCheck(this, TextUpdater2);
      this.globalRuntime = globalRuntime;
    }
    return _createClass(TextUpdater2, [{
      key: "isReadyToMeasure",
      value: function isReadyToMeasure(parsedStyle, object) {
        var text = parsedStyle.text;
        return text;
      }
    }, {
      key: "update",
      value: function update(parsedStyle, object) {
        var _object$ownerDocument;
        var text = parsedStyle.text, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$dx = parsedStyle.dx, dx = _parsedStyle$dx === void 0 ? 0 : _parsedStyle$dx, _parsedStyle$dy = parsedStyle.dy, dy = _parsedStyle$dy === void 0 ? 0 : _parsedStyle$dy, _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y;
        if (!this.isReadyToMeasure(parsedStyle, object)) {
          parsedStyle.metrics = {
            font: "",
            width: 0,
            height: 0,
            lines: [],
            lineWidths: [],
            lineHeight: 0,
            maxLineWidth: 0,
            fontProperties: {
              ascent: 0,
              descent: 0,
              fontSize: 0
            },
            lineMetrics: []
          };
          return {
            hwidth: 0,
            hheight: 0,
            cx: 0,
            cy: 0
          };
        }
        var _ref = (object === null || object === void 0 || (_object$ownerDocument = object.ownerDocument) === null || _object$ownerDocument === void 0 || (_object$ownerDocument = _object$ownerDocument.defaultView) === null || _object$ownerDocument === void 0 ? void 0 : _object$ownerDocument.getConfig()) || {}, offscreenCanvas = _ref.offscreenCanvas;
        var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
        parsedStyle.metrics = metrics;
        var width = metrics.width, height = metrics.height;
        var hwidth = width / 2;
        var hheight = height / 2;
        var lineXOffset = x3 + hwidth;
        if (textAlign === "center" || textAlign === "middle") {
          lineXOffset += lineWidth / 2 - hwidth;
        } else if (textAlign === "right" || textAlign === "end") {
          lineXOffset += lineWidth - hwidth * 2;
        }
        var lineYOffset = y3 - hheight;
        if (textBaseline === "middle") {
          lineYOffset += hheight;
        } else if (textBaseline === "top" || textBaseline === "hanging") {
          lineYOffset += hheight * 2;
        } else if (textBaseline === "alphabetic") ;
        else if (textBaseline === "bottom" || textBaseline === "ideographic") {
          lineYOffset += 0;
        }
        if (dx) {
          lineXOffset += dx;
        }
        if (dy) {
          lineYOffset += dy;
        }
        return {
          cx: lineXOffset,
          cy: lineYOffset,
          hwidth,
          hheight
        };
      }
    }]);
  }();
  var GroupUpdater = /* @__PURE__ */ function() {
    function GroupUpdater2() {
      _classCallCheck(this, GroupUpdater2);
    }
    return _createClass(GroupUpdater2, [{
      key: "update",
      value: function update(parsedStyle, object) {
        return {
          cx: 0,
          cy: 0,
          hwidth: 0,
          hheight: 0
        };
      }
    }]);
  }();
  var HTMLUpdater = /* @__PURE__ */ function() {
    function HTMLUpdater2() {
      _classCallCheck(this, HTMLUpdater2);
    }
    return _createClass(HTMLUpdater2, [{
      key: "update",
      value: function update(parsedStyle, object) {
        var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, _parsedStyle$width = parsedStyle.width, width = _parsedStyle$width === void 0 ? 0 : _parsedStyle$width, _parsedStyle$height = parsedStyle.height, height = _parsedStyle$height === void 0 ? 0 : _parsedStyle$height;
        return {
          cx: x3 + width / 2,
          cy: y3 + height / 2,
          hwidth: width / 2,
          hheight: height / 2
        };
      }
    }]);
  }();
  var FederatedEvent = /* @__PURE__ */ function() {
    function FederatedEvent2(manager) {
      _classCallCheck(this, FederatedEvent2);
      this.eventPhase = FederatedEvent2.prototype.NONE;
      this.bubbles = true;
      this.cancelBubble = true;
      this.cancelable = false;
      this.defaultPrevented = false;
      this.propagationStopped = false;
      this.propagationImmediatelyStopped = false;
      this.layer = new Point2();
      this.page = new Point2();
      this.canvas = new Point2();
      this.viewport = new Point2();
      this.composed = false;
      this.NONE = 0;
      this.CAPTURING_PHASE = 1;
      this.AT_TARGET = 2;
      this.BUBBLING_PHASE = 3;
      this.manager = manager;
    }
    return _createClass(FederatedEvent2, [{
      key: "name",
      get: (
        /**
         * The type of event, supports the following:
         * * pointerdown
         * * touchstart
         * * mousedown
         * * rightdown
         * * ...
         */
        /**
         * @deprecated
         */
        function get2() {
          return this.type;
        }
      )
    }, {
      key: "layerX",
      get: function get2() {
        return this.layer.x;
      }
    }, {
      key: "layerY",
      get: function get2() {
        return this.layer.y;
      }
    }, {
      key: "pageX",
      get: function get2() {
        return this.page.x;
      }
    }, {
      key: "pageY",
      get: function get2() {
        return this.page.y;
      }
    }, {
      key: "x",
      get: function get2() {
        return this.canvas.x;
      }
    }, {
      key: "y",
      get: function get2() {
        return this.canvas.y;
      }
    }, {
      key: "canvasX",
      get: function get2() {
        return this.canvas.x;
      }
    }, {
      key: "canvasY",
      get: function get2() {
        return this.canvas.y;
      }
    }, {
      key: "viewportX",
      get: function get2() {
        return this.viewport.x;
      }
    }, {
      key: "viewportY",
      get: function get2() {
        return this.viewport.y;
      }
    }, {
      key: "composedPath",
      value: (
        /**
         * The propagation path for this event
         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/composedPath
         *
         * So composedPath()[0] represents the original target.
         * @see https://polymer-library.polymer-project.org/3.0/docs/devguide/events#retargeting
         */
        function composedPath() {
          if (this.manager && (!this.path || this.path[0] !== this.target)) {
            this.path = this.target ? this.manager.propagationPath(this.target) : [];
          }
          return this.path;
        }
      )
      /**
       * @deprecated
       */
    }, {
      key: "propagationPath",
      get: function get2() {
        return this.composedPath();
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/preventDefault
       */
    }, {
      key: "preventDefault",
      value: function preventDefault() {
        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
          this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = true;
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopImmediatePropagation
       */
    }, {
      key: "stopImmediatePropagation",
      value: function stopImmediatePropagation() {
        this.propagationImmediatelyStopped = true;
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Event/stopPropagation
       */
    }, {
      key: "stopPropagation",
      value: function stopPropagation() {
        this.propagationStopped = true;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/view
       */
    }, {
      key: "initEvent",
      value: (
        /**
         * added for compatibility with DOM Event,
         * deprecated props and methods
         */
        function initEvent() {
        }
      )
    }, {
      key: "initUIEvent",
      value: function initUIEvent() {
      }
    }, {
      key: "clone",
      value: function clone11() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }]);
  }();
  var FederatedMouseEvent = /* @__PURE__ */ function(_ref) {
    function FederatedMouseEvent2() {
      var _this;
      _classCallCheck(this, FederatedMouseEvent2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, FederatedMouseEvent2, [].concat(args));
      _this.client = new Point2();
      _this.movement = new Point2();
      _this.offset = new Point2();
      _this.global = new Point2();
      _this.screen = new Point2();
      return _this;
    }
    _inherits(FederatedMouseEvent2, _ref);
    return _createClass(FederatedMouseEvent2, [{
      key: "clientX",
      get: function get2() {
        return this.client.x;
      }
    }, {
      key: "clientY",
      get: function get2() {
        return this.client.y;
      }
    }, {
      key: "movementX",
      get: function get2() {
        return this.movement.x;
      }
    }, {
      key: "movementY",
      get: function get2() {
        return this.movement.y;
      }
    }, {
      key: "offsetX",
      get: function get2() {
        return this.offset.x;
      }
    }, {
      key: "offsetY",
      get: function get2() {
        return this.offset.y;
      }
    }, {
      key: "globalX",
      get: function get2() {
        return this.global.x;
      }
    }, {
      key: "globalY",
      get: function get2() {
        return this.global.y;
      }
    }, {
      key: "screenX",
      get: function get2() {
        return this.screen.x;
      }
    }, {
      key: "screenY",
      get: function get2() {
        return this.screen.y;
      }
    }, {
      key: "getModifierState",
      value: function getModifierState(key) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
      }
    }, {
      key: "initMouseEvent",
      value: function initMouseEvent() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }]);
  }(FederatedEvent);
  var FederatedPointerEvent = /* @__PURE__ */ function(_FederatedMouseEvent) {
    function FederatedPointerEvent2() {
      var _this;
      _classCallCheck(this, FederatedPointerEvent2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, FederatedPointerEvent2, [].concat(args));
      _this.width = 0;
      _this.height = 0;
      _this.isPrimary = false;
      return _this;
    }
    _inherits(FederatedPointerEvent2, _FederatedMouseEvent);
    return _createClass(FederatedPointerEvent2, [{
      key: "getCoalescedEvents",
      value: (
        /**
         * The type of pointer that triggered the event.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pointerType
         */
        /**
         * Pressure applied by the pointing device during the event.
         *s
         * A Touch's force property will be represented by this value.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/pressure
         */
        /**
         * Barrel pressure on a stylus pointer.
         *
         * @see https://w3c.github.io/pointerevents/#pointerevent-interface
         */
        /**
         * The angle, in degrees, between the pointer device and the screen.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltX
         */
        /**
         * The angle, in degrees, between the pointer device and the screen.
         *
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/tiltY
         */
        /**
         * Twist of a stylus pointer.
         *
         * @see https://w3c.github.io/pointerevents/#pointerevent-interface
         */
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/PointerEvent/getCoalescedEvents
         */
        function getCoalescedEvents() {
          if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
            return [this];
          }
          return [];
        }
      )
      /**
       * @see https://chromestatus.com/feature/5765569655603200
       */
    }, {
      key: "getPredictedEvents",
      value: function getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!");
      }
      /**
       * @see https://github.com/antvis/G/issues/1115
       * We currently reuses event objects in the event system,
       * avoiding the creation of a large number of event objects.
       * Reused objects are only used to carry different data,
       * such as coordinate information, native event objects,
       * and therefore the lifecycle is limited to the event handler,
       * which can lead to unintended consequences if an attempt is made to cache the entire event object.
       *
       * Therefore, while keeping the above performance considerations in mind, it is possible to provide a clone method that creates a new object when the user really wants to cache it, e.g.
       */
    }, {
      key: "clone",
      value: function clone11() {
        return this.manager.clonePointerEvent(this);
      }
    }]);
  }(FederatedMouseEvent);
  var FederatedWheelEvent = /* @__PURE__ */ function(_FederatedMouseEvent) {
    function FederatedWheelEvent2() {
      _classCallCheck(this, FederatedWheelEvent2);
      return _callSuper(this, FederatedWheelEvent2, arguments);
    }
    _inherits(FederatedWheelEvent2, _FederatedMouseEvent);
    return _createClass(FederatedWheelEvent2, [{
      key: "clone",
      value: (
        /**
         * The units of `deltaX`, `deltaY`, and `deltaZ`. This is one of `DOM_DELTA_LINE`,
         * `DOM_DELTA_PAGE`, `DOM_DELTA_PIXEL`.
         */
        /** Horizontal scroll amount */
        /** Vertical scroll amount */
        /** z-axis scroll amount. */
        function clone11() {
          return this.manager.cloneWheelEvent(this);
        }
      )
    }]);
  }(FederatedMouseEvent);
  var CustomEvent2 = /* @__PURE__ */ function(_FederatedEvent) {
    function CustomEvent3(eventName, object) {
      var _this;
      _classCallCheck(this, CustomEvent3);
      _this = _callSuper(this, CustomEvent3, [null]);
      _this.type = eventName;
      _this.detail = object;
      Object.assign(_this, object);
      return _this;
    }
    _inherits(CustomEvent3, _FederatedEvent);
    return _createClass(CustomEvent3);
  }(FederatedEvent);
  var CANVAS_CACHE = /* @__PURE__ */ new WeakMap();
  var EventTarget = /* @__PURE__ */ function() {
    function EventTarget2() {
      _classCallCheck(this, EventTarget2);
      this.emitter = new eventemitter3_default();
    }
    return _createClass(EventTarget2, [{
      key: "on",
      value: (
        /**
         * @deprecated
         * @alias addEventListener
         */
        function on2(type, listener, options) {
          this.addEventListener(type, listener, options);
          return this;
        }
      )
      /**
       * support `capture` & `once` in options
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener
       */
    }, {
      key: "addEventListener",
      value: function addEventListener2(type, listener, options) {
        var capture = false;
        var once = false;
        if (is_boolean_default(options)) capture = options;
        else if (options) {
          var _options$capture = options.capture;
          capture = _options$capture === void 0 ? false : _options$capture;
          var _options$once = options.once;
          once = _options$once === void 0 ? false : _options$once;
        }
        if (capture) type += "capture";
        listener = isFunction(listener) ? listener : listener.handleEvent;
        var context = isFunction(listener) ? void 0 : listener;
        if (once) this.emitter.once(type, listener, context);
        else this.emitter.on(type, listener, context);
        return this;
      }
      /**
       * @deprecated
       * @alias removeEventListener
       */
    }, {
      key: "off",
      value: function off2(type, listener, options) {
        if (type) {
          this.removeEventListener(type, listener, options);
        } else {
          this.removeAllEventListeners();
        }
        return this;
      }
    }, {
      key: "removeAllEventListeners",
      value: function removeAllEventListeners() {
        var _this$emitter;
        (_this$emitter = this.emitter) === null || _this$emitter === void 0 || _this$emitter.removeAllListeners();
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener2(type, listener, options) {
        var _listener;
        if (!this.emitter) return this;
        var capture = is_boolean_default(options) ? options : options === null || options === void 0 ? void 0 : options.capture;
        if (capture) type += "capture";
        listener = isFunction(listener) ? listener : (_listener = listener) === null || _listener === void 0 ? void 0 : _listener.handleEvent;
        var context = isFunction(listener) ? void 0 : listener;
        this.emitter.off(type, listener, context);
        return this;
      }
      /**
       * @deprecated
       * @alias dispatchEvent
       */
    }, {
      key: "emit",
      value: function emit(eventName, object) {
        this.dispatchEvent(new CustomEvent2(eventName, object));
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/dispatchEvent
       */
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent4(e3) {
        var skipPropagate = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var canvas = CANVAS_CACHE.get(this);
        if (!canvas) {
          var _ownerDocument;
          if (this.document) canvas = this;
          else if (this.defaultView) canvas = this.defaultView;
          else canvas = (_ownerDocument = this.ownerDocument) === null || _ownerDocument === void 0 ? void 0 : _ownerDocument.defaultView;
          if (canvas) CANVAS_CACHE.set(this, canvas);
        }
        if (canvas) {
          e3.manager = canvas.getEventService();
          if (!e3.manager) return false;
          e3.defaultPrevented = false;
          if (e3.path) e3.path.length = 0;
          else e3.page = [];
          if (!skipPropagate) e3.target = this;
          e3.manager.dispatchEvent(e3, e3.type, skipPropagate);
        } else {
          this.emitter.emit(e3.type, e3);
        }
        return !e3.defaultPrevented;
      }
    }]);
  }();
  var Node2 = /* @__PURE__ */ function(_EventTarget) {
    function Node6() {
      var _this;
      _classCallCheck(this, Node6);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, Node6, [].concat(args));
      _this.shadow = false;
      _this.ownerDocument = null;
      _this.isConnected = false;
      _this.baseURI = "";
      _this.childNodes = [];
      _this.nodeType = 0;
      _this.nodeName = "";
      _this.nodeValue = null;
      _this.parentNode = null;
      return _this;
    }
    _inherits(Node6, _EventTarget);
    return _createClass(Node6, [{
      key: "textContent",
      get: (
        /**
         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
         */
        function get2() {
          var out = "";
          if (this.nodeName === Shape.TEXT) {
            out += this.style.text;
          }
          var _iterator = _createForOfIteratorHelper(this.childNodes), _step;
          try {
            for (_iterator.s(); !(_step = _iterator.n()).done; ) {
              var _child = _step.value;
              if (_child.nodeName === Shape.TEXT) {
                out += _child.nodeValue;
              } else {
                out += _child.textContent;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
          return out;
        }
      ),
      set: function set8(content) {
        var _this2 = this;
        this.childNodes.slice().forEach(function(child) {
          _this2.removeChild(child);
        });
        if (this.nodeName === Shape.TEXT) {
          this.style.text = "".concat(content);
        }
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/getRootNode
       */
    }, {
      key: "getRootNode",
      value: function getRootNode() {
        var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (this.parentNode) {
          return this.parentNode.getRootNode(opts);
        }
        if (opts.composed && this.host) {
          return this.host.getRootNode(opts);
        }
        return this;
      }
    }, {
      key: "hasChildNodes",
      value: function hasChildNodes() {
        return this.childNodes.length > 0;
      }
    }, {
      key: "isDefaultNamespace",
      value: function isDefaultNamespace(namespace) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "lookupNamespaceURI",
      value: function lookupNamespaceURI(prefix) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "lookupPrefix",
      value: function lookupPrefix(namespace) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "normalize",
      value: function normalize9() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/isEqualNode
       */
    }, {
      key: "isEqualNode",
      value: function isEqualNode(otherNode) {
        return this === otherNode;
      }
    }, {
      key: "isSameNode",
      value: function isSameNode(otherNode) {
        return this.isEqualNode(otherNode);
      }
    }, {
      key: "parent",
      get: (
        /**
         * @deprecated
         * @alias parentNode
         */
        function get2() {
          return this.parentNode;
        }
      )
    }, {
      key: "parentElement",
      get: function get2() {
        return null;
      }
    }, {
      key: "nextSibling",
      get: function get2() {
        return null;
      }
    }, {
      key: "previousSibling",
      get: function get2() {
        return null;
      }
    }, {
      key: "firstChild",
      get: function get2() {
        return this.childNodes.length > 0 ? this.childNodes[0] : null;
      }
    }, {
      key: "lastChild",
      get: function get2() {
        return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
       * @see https://github.com/b-fuze/deno-dom/blob/master/src/dom/node.ts#L338
       */
    }, {
      key: "compareDocumentPosition",
      value: function compareDocumentPosition(other) {
        if (other === this) {
          return 0;
        }
        var node1Root = other;
        var node2Root = this;
        var node1Hierarchy = [node1Root];
        var node2Hierarchy = [node2Root];
        while ((_node1Root$parentNode = node1Root.parentNode) !== null && _node1Root$parentNode !== void 0 ? _node1Root$parentNode : node2Root.parentNode) {
          var _node1Root$parentNode;
          node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
          node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
        }
        if (node1Root !== node2Root) {
          return Node6.DOCUMENT_POSITION_DISCONNECTED | Node6.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node6.DOCUMENT_POSITION_PRECEDING;
        }
        var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
        var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
        if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
          return longerHierarchy === node1Hierarchy ? (
            // other is a child of this
            Node6.DOCUMENT_POSITION_CONTAINED_BY | Node6.DOCUMENT_POSITION_FOLLOWING
          ) : (
            // this is a child of other
            Node6.DOCUMENT_POSITION_CONTAINS | Node6.DOCUMENT_POSITION_PRECEDING
          );
        }
        var longerStart = longerHierarchy.length - shorterHierarchy.length;
        for (var i = shorterHierarchy.length - 1; i >= 0; i--) {
          var shorterHierarchyNode = shorterHierarchy[i];
          var longerHierarchyNode = longerHierarchy[longerStart + i];
          if (longerHierarchyNode !== shorterHierarchyNode) {
            var siblings = shorterHierarchyNode.parentNode.childNodes;
            if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
              if (shorterHierarchy === node1Hierarchy) {
                return Node6.DOCUMENT_POSITION_PRECEDING;
              }
              return Node6.DOCUMENT_POSITION_FOLLOWING;
            }
            if (longerHierarchy === node1Hierarchy) {
              return Node6.DOCUMENT_POSITION_PRECEDING;
            }
            return Node6.DOCUMENT_POSITION_FOLLOWING;
          }
        }
        return Node6.DOCUMENT_POSITION_FOLLOWING;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode
       */
    }, {
      key: "contain",
      value: (
        /**
         * @deprecated
         * @alias contains
         */
        function contain2(other) {
          return this.contains(other);
        }
      )
    }, {
      key: "contains",
      value: function contains(other) {
        var tmp2 = other;
        while (tmp2 && this !== tmp2) {
          tmp2 = tmp2.parentNode;
        }
        return !!tmp2;
      }
    }, {
      key: "getAncestor",
      value: function getAncestor(n2) {
        var temp = this;
        while (n2 > 0 && temp) {
          temp = temp.parentNode;
          n2--;
        }
        return temp;
      }
    }, {
      key: "forEach",
      value: function forEach4(callback) {
        var stack = [this];
        while (stack.length > 0) {
          var node = stack.pop();
          var result = callback(node);
          if (result === false) {
            break;
          }
          for (var i = node.childNodes.length - 1; i >= 0; i--) {
            stack.push(node.childNodes[i]);
          }
        }
      }
    }], [{
      key: "isNode",
      value: function isNode(target) {
        return !!target.childNodes;
      }
    }]);
  }(EventTarget);
  Node2.DOCUMENT_POSITION_DISCONNECTED = 1;
  Node2.DOCUMENT_POSITION_PRECEDING = 2;
  Node2.DOCUMENT_POSITION_FOLLOWING = 4;
  Node2.DOCUMENT_POSITION_CONTAINS = 8;
  Node2.DOCUMENT_POSITION_CONTAINED_BY = 16;
  Node2.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
  var PROPAGATION_LIMIT = 2048;
  var EventService = /* @__PURE__ */ function() {
    function EventService2(globalRuntime, context) {
      var _this = this;
      _classCallCheck(this, EventService2);
      this.nativeHTMLMap = /* @__PURE__ */ new WeakMap();
      this.cursor = "default";
      this.mappingTable = {};
      this.mappingState = {
        trackingData: {}
      };
      this.eventPool = /* @__PURE__ */ new Map();
      this.tmpMatrix = mat4_exports.create();
      this.tmpVec3 = vec3_exports.create();
      this.onPointerDown = function(from) {
        var e3 = _this.createPointerEvent(from);
        _this.dispatchEvent(e3, "pointerdown");
        if (e3.pointerType === "touch") {
          _this.dispatchEvent(e3, "touchstart");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          var isRightButton = e3.button === 2;
          _this.dispatchEvent(e3, isRightButton ? "rightdown" : "mousedown");
        }
        var trackingData = _this.trackingData(from.pointerId);
        trackingData.pressTargetsByButton[from.button] = e3.composedPath();
        _this.freeEvent(e3);
      };
      this.onPointerUp = function(from) {
        var now4 = clock.now();
        var e3 = _this.createPointerEvent(from, void 0, void 0, _this.context.config.alwaysTriggerPointerEventOnCanvas ? _this.rootTarget : void 0);
        _this.dispatchEvent(e3, "pointerup");
        if (e3.pointerType === "touch") {
          _this.dispatchEvent(e3, "touchend");
        } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
          var isRightButton = e3.button === 2;
          _this.dispatchEvent(e3, isRightButton ? "rightup" : "mouseup");
        }
        var trackingData = _this.trackingData(from.pointerId);
        var pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        var clickTarget = pressTarget;
        if (pressTarget && !e3.composedPath().includes(pressTarget)) {
          var currentTarget = pressTarget;
          while (currentTarget && !e3.composedPath().includes(currentTarget)) {
            e3.currentTarget = currentTarget;
            _this.notifyTarget(e3, "pointerupoutside");
            if (e3.pointerType === "touch") {
              _this.notifyTarget(e3, "touchendoutside");
            } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
              var _isRightButton = e3.button === 2;
              _this.notifyTarget(e3, _isRightButton ? "rightupoutside" : "mouseupoutside");
            }
            if (Node2.isNode(currentTarget)) {
              currentTarget = currentTarget.parentNode;
            }
          }
          delete trackingData.pressTargetsByButton[from.button];
          clickTarget = currentTarget;
        }
        if (clickTarget) {
          var _e$detail;
          var clickEvent = _this.clonePointerEvent(e3, "click");
          clickEvent.target = clickTarget;
          clickEvent.path = [];
          if (!trackingData.clicksByButton[from.button]) {
            trackingData.clicksByButton[from.button] = {
              clickCount: 0,
              target: clickEvent.target,
              timeStamp: now4
            };
          }
          var canvas = _this.context.renderingContext.root.ownerDocument.defaultView;
          var clickHistory = trackingData.clicksByButton[from.button];
          if (clickHistory.target === clickEvent.target && now4 - clickHistory.timeStamp < canvas.getConfig().dblClickSpeed) {
            ++clickHistory.clickCount;
          } else {
            clickHistory.clickCount = 1;
          }
          clickHistory.target = clickEvent.target;
          clickHistory.timeStamp = now4;
          clickEvent.detail = clickHistory.clickCount;
          if (!((_e$detail = e3.detail) !== null && _e$detail !== void 0 && _e$detail.preventClick)) {
            if (!_this.context.config.useNativeClickEvent && (clickEvent.pointerType === "mouse" || clickEvent.pointerType === "touch")) {
              _this.dispatchEvent(clickEvent, "click");
            }
            _this.dispatchEvent(clickEvent, "pointertap");
          }
          _this.freeEvent(clickEvent);
        }
        _this.freeEvent(e3);
      };
      this.onPointerMove = function(from) {
        var e3 = _this.createPointerEvent(from, void 0, void 0, _this.context.config.alwaysTriggerPointerEventOnCanvas ? _this.rootTarget : void 0);
        var isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
        var trackingData = _this.trackingData(from.pointerId);
        var outTarget = _this.findMountedTarget(trackingData.overTargets);
        if (trackingData.overTargets && outTarget !== e3.target) {
          var outType = from.type === "mousemove" ? "mouseout" : "pointerout";
          var outEvent = _this.createPointerEvent(from, outType, outTarget || void 0);
          _this.dispatchEvent(outEvent, "pointerout");
          if (isMouse) _this.dispatchEvent(outEvent, "mouseout");
          if (!e3.composedPath().includes(outTarget)) {
            var leaveEvent = _this.createPointerEvent(from, "pointerleave", outTarget || void 0);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && !e3.composedPath().includes(leaveEvent.target)) {
              leaveEvent.currentTarget = leaveEvent.target;
              _this.notifyTarget(leaveEvent);
              if (isMouse) {
                _this.notifyTarget(leaveEvent, "mouseleave");
              }
              if (Node2.isNode(leaveEvent.target)) {
                leaveEvent.target = leaveEvent.target.parentNode;
              }
            }
            _this.freeEvent(leaveEvent);
          }
          _this.freeEvent(outEvent);
        }
        if (outTarget !== e3.target) {
          var overType = from.type === "mousemove" ? "mouseover" : "pointerover";
          var overEvent = _this.clonePointerEvent(e3, overType);
          _this.dispatchEvent(overEvent, "pointerover");
          if (isMouse) _this.dispatchEvent(overEvent, "mouseover");
          var overTargetAncestor = outTarget && Node2.isNode(outTarget) && outTarget.parentNode;
          while (overTargetAncestor && overTargetAncestor !== (Node2.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
            if (overTargetAncestor === e3.target) break;
            overTargetAncestor = overTargetAncestor.parentNode;
          }
          var didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node2.isNode(_this.rootTarget) && _this.rootTarget.parentNode);
          if (didPointerEnter) {
            var enterEvent = _this.clonePointerEvent(e3, "pointerenter");
            enterEvent.eventPhase = enterEvent.AT_TARGET;
            while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node2.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
              enterEvent.currentTarget = enterEvent.target;
              _this.notifyTarget(enterEvent);
              if (isMouse) _this.notifyTarget(enterEvent, "mouseenter");
              if (Node2.isNode(enterEvent.target)) {
                enterEvent.target = enterEvent.target.parentNode;
              }
            }
            _this.freeEvent(enterEvent);
          }
          _this.freeEvent(overEvent);
        }
        _this.dispatchEvent(e3, "pointermove");
        if (e3.pointerType === "touch") _this.dispatchEvent(e3, "touchmove");
        if (isMouse) {
          _this.dispatchEvent(e3, "mousemove");
          _this.cursor = _this.getCursor(e3.target);
        }
        trackingData.overTargets = e3.composedPath();
        _this.freeEvent(e3);
      };
      this.onPointerOut = function(from) {
        var trackingData = _this.trackingData(from.pointerId);
        if (trackingData.overTargets) {
          var isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
          var outTarget = _this.findMountedTarget(trackingData.overTargets);
          var outEvent = _this.createPointerEvent(from, "pointerout", outTarget || void 0);
          _this.dispatchEvent(outEvent);
          if (isMouse) _this.dispatchEvent(outEvent, "mouseout");
          var leaveEvent = _this.createPointerEvent(from, "pointerleave", outTarget || void 0);
          leaveEvent.eventPhase = leaveEvent.AT_TARGET;
          while (leaveEvent.target && leaveEvent.target !== (Node2.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
            leaveEvent.currentTarget = leaveEvent.target;
            _this.notifyTarget(leaveEvent);
            if (isMouse) {
              _this.notifyTarget(leaveEvent, "mouseleave");
            }
            if (Node2.isNode(leaveEvent.target)) {
              leaveEvent.target = leaveEvent.target.parentNode;
            }
          }
          trackingData.overTargets = null;
          _this.freeEvent(outEvent);
          _this.freeEvent(leaveEvent);
        }
        _this.cursor = null;
      };
      this.onPointerOver = function(from) {
        var trackingData = _this.trackingData(from.pointerId);
        var e3 = _this.createPointerEvent(from);
        var isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
        _this.dispatchEvent(e3, "pointerover");
        if (isMouse) _this.dispatchEvent(e3, "mouseover");
        if (e3.pointerType === "mouse") _this.cursor = _this.getCursor(e3.target);
        var enterEvent = _this.clonePointerEvent(e3, "pointerenter");
        enterEvent.eventPhase = enterEvent.AT_TARGET;
        while (enterEvent.target && enterEvent.target !== (Node2.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
          enterEvent.currentTarget = enterEvent.target;
          _this.notifyTarget(enterEvent);
          if (isMouse) {
            _this.notifyTarget(enterEvent, "mouseenter");
          }
          if (Node2.isNode(enterEvent.target)) {
            enterEvent.target = enterEvent.target.parentNode;
          }
        }
        trackingData.overTargets = e3.composedPath();
        _this.freeEvent(e3);
        _this.freeEvent(enterEvent);
      };
      this.onPointerUpOutside = function(from) {
        var trackingData = _this.trackingData(from.pointerId);
        var pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
        var e3 = _this.createPointerEvent(from);
        if (pressTarget) {
          var currentTarget = pressTarget;
          while (currentTarget) {
            e3.currentTarget = currentTarget;
            _this.notifyTarget(e3, "pointerupoutside");
            if (e3.pointerType === "touch") ;
            else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
              _this.notifyTarget(e3, e3.button === 2 ? "rightupoutside" : "mouseupoutside");
            }
            if (Node2.isNode(currentTarget)) {
              currentTarget = currentTarget.parentNode;
            }
          }
          delete trackingData.pressTargetsByButton[from.button];
        }
        _this.freeEvent(e3);
      };
      this.onWheel = function(from) {
        var wheelEvent = _this.createWheelEvent(from);
        _this.dispatchEvent(wheelEvent);
        _this.freeEvent(wheelEvent);
      };
      this.onClick = function(from) {
        if (_this.context.config.useNativeClickEvent) {
          var e3 = _this.createPointerEvent(from);
          _this.dispatchEvent(e3);
          _this.freeEvent(e3);
        }
      };
      this.onPointerCancel = function(from) {
        var e3 = _this.createPointerEvent(from, void 0, void 0, _this.context.config.alwaysTriggerPointerEventOnCanvas ? _this.rootTarget : void 0);
        _this.dispatchEvent(e3);
        _this.freeEvent(e3);
      };
      this.globalRuntime = globalRuntime;
      this.context = context;
    }
    return _createClass(EventService2, [{
      key: "init",
      value: function init() {
        this.rootTarget = this.context.renderingContext.root.parentNode;
        this.addEventMapping("pointerdown", this.onPointerDown);
        this.addEventMapping("pointerup", this.onPointerUp);
        this.addEventMapping("pointermove", this.onPointerMove);
        this.addEventMapping("pointerout", this.onPointerOut);
        this.addEventMapping("pointerleave", this.onPointerOut);
        this.addEventMapping("pointercancel", this.onPointerCancel);
        this.addEventMapping("pointerover", this.onPointerOver);
        this.addEventMapping("pointerupoutside", this.onPointerUpOutside);
        this.addEventMapping("wheel", this.onWheel);
        this.addEventMapping("click", this.onClick);
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        this.mappingTable = {};
        this.mappingState = {};
        this.eventPool.clear();
      }
    }, {
      key: "getScale",
      value: function getScale() {
        var bbox = this.context.contextService.getBoundingClientRect();
        var scaleX2 = 1;
        var scaleY2 = 1;
        var $el = this.context.contextService.getDomElement();
        if ($el && bbox) {
          var offsetWidth = $el.offsetWidth, offsetHeight = $el.offsetHeight;
          if (offsetWidth && offsetHeight) {
            scaleX2 = bbox.width / offsetWidth;
            scaleY2 = bbox.height / offsetHeight;
          }
        }
        return {
          scaleX: scaleX2,
          scaleY: scaleY2,
          bbox
        };
      }
      /**
       * Should account for CSS Transform applied on container.
       * @see https://github.com/antvis/G/issues/1161
       * @see https://github.com/antvis/G/issues/1677
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/offsetX
       */
    }, {
      key: "client2Viewport",
      value: function client2Viewport(client) {
        var _this$getScale = this.getScale(), scaleX2 = _this$getScale.scaleX, scaleY2 = _this$getScale.scaleY, bbox = _this$getScale.bbox;
        return new Point2((client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) / scaleX2, (client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) / scaleY2);
      }
    }, {
      key: "viewport2Client",
      value: function viewport2Client(canvas) {
        var _this$getScale2 = this.getScale(), scaleX2 = _this$getScale2.scaleX, scaleY2 = _this$getScale2.scaleY, bbox = _this$getScale2.bbox;
        return new Point2((canvas.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) * scaleX2, (canvas.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) * scaleY2);
      }
    }, {
      key: "viewport2Canvas",
      value: function viewport2Canvas(_ref) {
        var x3 = _ref.x, y3 = _ref.y;
        var canvas = this.rootTarget.defaultView;
        var camera = canvas.getCamera();
        var _this$context$config = this.context.config, width = _this$context$config.width, height = _this$context$config.height;
        var projectionMatrixInverse = camera.getPerspectiveInverse();
        var worldMatrix = camera.getWorldTransform();
        var vpMatrix = mat4_exports.multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
        var viewport = vec3_exports.set(this.tmpVec3, x3 / width * 2 - 1, (1 - y3 / height) * 2 - 1, 0);
        vec3_exports.transformMat4(viewport, viewport, vpMatrix);
        return new Point2(viewport[0], viewport[1]);
      }
    }, {
      key: "canvas2Viewport",
      value: function canvas2Viewport(canvasP) {
        var canvas = this.rootTarget.defaultView;
        var camera = canvas.getCamera();
        var projectionMatrix = camera.getPerspective();
        var viewMatrix = camera.getViewTransform();
        var vpMatrix = mat4_exports.multiply(this.tmpMatrix, projectionMatrix, viewMatrix);
        var clip = vec3_exports.set(this.tmpVec3, canvasP.x, canvasP.y, 0);
        vec3_exports.transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);
        var _this$context$config2 = this.context.config, width = _this$context$config2.width, height = _this$context$config2.height;
        return new Point2((clip[0] + 1) / 2 * width, (1 - (clip[1] + 1) / 2) * height);
      }
    }, {
      key: "setPickHandler",
      value: function setPickHandler(pickHandler) {
        this.pickHandler = pickHandler;
      }
    }, {
      key: "addEventMapping",
      value: function addEventMapping(type, fn) {
        if (!this.mappingTable[type]) {
          this.mappingTable[type] = [];
        }
        this.mappingTable[type].push({
          fn,
          priority: 0
        });
        this.mappingTable[type].sort(function(a3, b) {
          return a3.priority - b.priority;
        });
      }
    }, {
      key: "mapEvent",
      value: function mapEvent(e3) {
        if (!this.rootTarget) {
          return;
        }
        var mappers = this.mappingTable[e3.type];
        if (mappers) {
          for (var i = 0, j = mappers.length; i < j; i++) {
            mappers[i].fn(e3);
          }
        } else {
          console.warn("[EventService]: Event mapping not defined for ".concat(e3.type));
        }
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent4(e3, type, skipPropagate) {
        if (!skipPropagate) {
          e3.propagationStopped = false;
          e3.propagationImmediatelyStopped = false;
          this.propagate(e3, type);
        } else {
          e3.eventPhase = e3.AT_TARGET;
          var canvas = this.rootTarget.defaultView || null;
          e3.currentTarget = canvas;
          this.notifyListeners(e3, type);
        }
      }
    }, {
      key: "propagate",
      value: function propagate(e3, type) {
        if (!e3.target) {
          return;
        }
        var composedPath = e3.composedPath();
        e3.eventPhase = e3.CAPTURING_PHASE;
        for (var i = composedPath.length - 1; i >= 1; i--) {
          e3.currentTarget = composedPath[i];
          this.notifyTarget(e3, type);
          if (e3.propagationStopped || e3.propagationImmediatelyStopped) return;
        }
        e3.eventPhase = e3.AT_TARGET;
        e3.currentTarget = e3.target;
        this.notifyTarget(e3, type);
        if (e3.propagationStopped || e3.propagationImmediatelyStopped) return;
        var index4 = composedPath.indexOf(e3.currentTarget);
        e3.eventPhase = e3.BUBBLING_PHASE;
        for (var _i = index4 + 1; _i < composedPath.length; _i++) {
          e3.currentTarget = composedPath[_i];
          this.notifyTarget(e3, type);
          if (e3.propagationStopped || e3.propagationImmediatelyStopped) return;
        }
      }
    }, {
      key: "propagationPath",
      value: function propagationPath(target) {
        var propagationPath2 = [target];
        var canvas = this.rootTarget.defaultView || null;
        if (canvas && canvas === target) {
          propagationPath2.unshift(canvas.document);
          return propagationPath2;
        }
        for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
          if (Node2.isNode(target) && target.parentNode) {
            propagationPath2.push(target.parentNode);
            target = target.parentNode;
          }
        }
        if (canvas) {
          propagationPath2.push(canvas);
        }
        return propagationPath2;
      }
    }, {
      key: "hitTest",
      value: function hitTest(position) {
        var viewportX = position.viewportX, viewportY = position.viewportY;
        var _this$context$config3 = this.context.config, width = _this$context$config3.width, height = _this$context$config3.height, disableHitTesting = _this$context$config3.disableHitTesting;
        if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
          return null;
        }
        return !disableHitTesting && this.pickHandler(position) || this.rootTarget || // return Document
        null;
      }
      /**
       * whether the native event trigger came from Canvas,
       * should account for HTML shape
       */
    }, {
      key: "isNativeEventFromCanvas",
      value: function isNativeEventFromCanvas($el, nativeEvent) {
        var _target;
        var target = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.target;
        if ((_target = target) !== null && _target !== void 0 && _target.shadowRoot) {
          target = nativeEvent.composedPath()[0];
        }
        if (target) {
          if (target === $el) {
            return true;
          }
          if ($el && $el.contains) {
            return $el.contains(target);
          }
        }
        if (nativeEvent !== null && nativeEvent !== void 0 && nativeEvent.composedPath) {
          return nativeEvent.composedPath().indexOf($el) > -1;
        }
        return false;
      }
      /**
       * Find HTML from composed path in native UI event.
       */
    }, {
      key: "getExistedHTML",
      value: function getExistedHTML(event) {
        if (event.nativeEvent.composedPath) {
          for (var _i2 = 0, _arr = event.nativeEvent.composedPath(); _i2 < _arr.length; _i2++) {
            var eventTarget = _arr[_i2];
            var existed = this.nativeHTMLMap.get(eventTarget);
            if (existed) {
              return existed;
            }
          }
        }
        return null;
      }
    }, {
      key: "pickTarget",
      value: function pickTarget(event) {
        return this.hitTest({
          clientX: event.clientX,
          clientY: event.clientY,
          viewportX: event.viewportX,
          viewportY: event.viewportY,
          x: event.canvasX,
          y: event.canvasY
        });
      }
    }, {
      key: "createPointerEvent",
      value: function createPointerEvent(from, type, target, fallbackTarget) {
        var event = this.allocateEvent(FederatedPointerEvent);
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        var existedHTML = this.getExistedHTML(event);
        var $el = this.context.contextService.getDomElement();
        event.target = target !== null && target !== void 0 ? target : existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event) || fallbackTarget;
        if (typeof type === "string") {
          event.type = type;
        }
        return event;
      }
    }, {
      key: "createWheelEvent",
      value: function createWheelEvent(from) {
        var event = this.allocateEvent(FederatedWheelEvent);
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        var existedHTML = this.getExistedHTML(event);
        var $el = this.context.contextService.getDomElement();
        event.target = existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event);
        return event;
      }
    }, {
      key: "trackingData",
      value: function trackingData(id5) {
        if (!this.mappingState.trackingData[id5]) {
          this.mappingState.trackingData[id5] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
          };
        }
        return this.mappingState.trackingData[id5];
      }
    }, {
      key: "cloneWheelEvent",
      value: function cloneWheelEvent(from) {
        var event = this.allocateEvent(FederatedWheelEvent);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = from.type;
        return event;
      }
    }, {
      key: "clonePointerEvent",
      value: function clonePointerEvent(from, type) {
        var event = this.allocateEvent(FederatedPointerEvent);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = type !== null && type !== void 0 ? type : event.type;
        return event;
      }
    }, {
      key: "copyPointerData",
      value: function copyPointerData(from, to) {
        to.pointerId = from.pointerId;
        to.width = from.width;
        to.height = from.height;
        to.isPrimary = from.isPrimary;
        to.pointerType = from.pointerType;
        to.pressure = from.pressure;
        to.tangentialPressure = from.tangentialPressure;
        to.tiltX = from.tiltX;
        to.tiltY = from.tiltY;
        to.twist = from.twist;
      }
    }, {
      key: "copyMouseData",
      value: function copyMouseData(from, to) {
        to.altKey = from.altKey;
        to.button = from.button;
        to.buttons = from.buttons;
        to.ctrlKey = from.ctrlKey;
        to.metaKey = from.metaKey;
        to.shiftKey = from.shiftKey;
        to.client.copyFrom(from.client);
        to.movement.copyFrom(from.movement);
        to.canvas.copyFrom(from.canvas);
        to.screen.copyFrom(from.screen);
        to.global.copyFrom(from.global);
        to.offset.copyFrom(from.offset);
      }
    }, {
      key: "copyWheelData",
      value: function copyWheelData(from, to) {
        to.deltaMode = from.deltaMode;
        to.deltaX = from.deltaX;
        to.deltaY = from.deltaY;
        to.deltaZ = from.deltaZ;
      }
    }, {
      key: "copyData",
      value: function copyData2(from, to) {
        to.isTrusted = from.isTrusted;
        to.timeStamp = clock.now();
        to.type = from.type;
        to.detail = from.detail;
        to.view = from.view;
        to.page.copyFrom(from.page);
        to.viewport.copyFrom(from.viewport);
      }
    }, {
      key: "allocateEvent",
      value: function allocateEvent(constructor) {
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        var event = this.eventPool.get(constructor).pop() || new constructor(this);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.path = [];
        event.target = null;
        return event;
      }
    }, {
      key: "freeEvent",
      value: function freeEvent(event) {
        if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        var constructor = event.constructor;
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        this.eventPool.get(constructor).push(event);
      }
    }, {
      key: "notifyTarget",
      value: function notifyTarget(e3, type) {
        var _type;
        type = (_type = type) !== null && _type !== void 0 ? _type : e3.type;
        var key = e3.eventPhase === e3.CAPTURING_PHASE || e3.eventPhase === e3.AT_TARGET ? "".concat(type, "capture") : type;
        this.notifyListeners(e3, key);
        if (e3.eventPhase === e3.AT_TARGET) {
          this.notifyListeners(e3, type);
        }
      }
    }, {
      key: "notifyListeners",
      value: function notifyListeners(e3, type) {
        var emitter = e3.currentTarget.emitter;
        var listeners = emitter._events[type];
        if (!listeners) return;
        if ("fn" in listeners) {
          if (listeners.once) {
            emitter.removeListener(type, listeners.fn, void 0, true);
          }
          listeners.fn.call(e3.currentTarget || listeners.context, e3);
        } else {
          for (var i = 0; i < listeners.length && !e3.propagationImmediatelyStopped; i++) {
            if (listeners[i].once) {
              emitter.removeListener(type, listeners[i].fn, void 0, true);
            }
            listeners[i].fn.call(e3.currentTarget || listeners[i].context, e3);
          }
        }
      }
      /**
       * some detached nodes may exist in propagation path, need to skip them
       */
    }, {
      key: "findMountedTarget",
      value: function findMountedTarget(propagationPath) {
        if (!propagationPath) {
          return null;
        }
        var currentTarget = propagationPath[propagationPath.length - 1];
        for (var i = propagationPath.length - 2; i >= 0; i--) {
          var target = propagationPath[i];
          if (target === this.rootTarget || Node2.isNode(target) && target.parentNode === currentTarget) {
            currentTarget = propagationPath[i];
          } else {
            break;
          }
        }
        return currentTarget;
      }
    }, {
      key: "getCursor",
      value: function getCursor(target) {
        var tmp2 = target;
        while (tmp2) {
          var cursor = isElement(tmp2) && tmp2.getAttribute("cursor");
          if (cursor) {
            return cursor;
          }
          tmp2 = Node2.isNode(tmp2) && tmp2.parentNode;
        }
      }
    }]);
  }();
  var OffscreenCanvasCreator = /* @__PURE__ */ function() {
    function OffscreenCanvasCreator2() {
      _classCallCheck(this, OffscreenCanvasCreator2);
    }
    return _createClass(OffscreenCanvasCreator2, [{
      key: "getOrCreateCanvas",
      value: function getOrCreateCanvas(offscreenCanvas, contextAttributes) {
        if (this.canvas) {
          return this.canvas;
        }
        if (offscreenCanvas || runtime.offscreenCanvas) {
          this.canvas = offscreenCanvas || runtime.offscreenCanvas;
          this.context = this.canvas.getContext("2d", _objectSpread22({
            willReadFrequently: true
          }, contextAttributes));
        } else {
          try {
            this.canvas = new window.OffscreenCanvas(0, 0);
            this.context = this.canvas.getContext("2d", _objectSpread22({
              willReadFrequently: true
            }, contextAttributes));
            if (!this.context || !this.context.measureText) {
              this.canvas = document.createElement("canvas");
              this.context = this.canvas.getContext("2d");
            }
          } catch (_unused) {
            this.canvas = document.createElement("canvas");
            this.context = this.canvas.getContext("2d", _objectSpread22({
              willReadFrequently: true
            }, contextAttributes));
          }
        }
        this.canvas.width = 10;
        this.canvas.height = 10;
        return this.canvas;
      }
    }, {
      key: "getOrCreateContext",
      value: function getOrCreateContext(offscreenCanvas, contextAttributes) {
        if (this.context) {
          return this.context;
        }
        this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
        return this.context;
      }
    }], [{
      key: "createCanvas",
      value: (
        /**
         * @returns new canvas instance
         */
        function createCanvas() {
          try {
            return new window.OffscreenCanvas(0, 0);
          } catch (_unused2) {
          }
          try {
            return document.createElement("canvas");
          } catch (_unused3) {
          }
          return null;
        }
      )
    }]);
  }();
  var RenderReason = /* @__PURE__ */ function(RenderReason2) {
    RenderReason2[RenderReason2["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
    RenderReason2[RenderReason2["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
    RenderReason2[RenderReason2["NONE"] = 2] = "NONE";
    return RenderReason2;
  }({});
  var RenderingService = /* @__PURE__ */ function() {
    function RenderingService2(globalRuntime, context) {
      _classCallCheck(this, RenderingService2);
      this.inited = false;
      this.stats = {
        /**
         * total display objects in scenegraph
         */
        total: 0,
        /**
         * number of display objects need to render in current frame
         */
        rendered: 0
      };
      this.zIndexCounter = 0;
      this.hooks = {
        /**
         * called before any frame rendered
         */
        init: new SyncHook(),
        initAsync: new AsyncParallelHook(),
        /**
         * only dirty object which has sth changed will be rendered
         */
        dirtycheck: new SyncWaterfallHook(),
        /**
         * do culling
         */
        cull: new SyncWaterfallHook(),
        /**
         * called at beginning of each frame, won't get called if nothing to re-render
         */
        beginFrame: new SyncHook(),
        /**
         * called before every dirty object get rendered
         */
        beforeRender: new SyncHook(),
        /**
         * called when every dirty object rendering even it's culled
         */
        render: new SyncHook(),
        /**
         * called after every dirty object get rendered
         */
        afterRender: new SyncHook(),
        endFrame: new SyncHook(),
        destroy: new SyncHook(),
        /**
         * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
         */
        pick: new AsyncSeriesWaterfallHook(),
        /**
         * Unsafe but sync version of pick.
         */
        pickSync: new SyncWaterfallHook(),
        /**
         * used in event system
         */
        pointerDown: new SyncHook(),
        pointerUp: new SyncHook(),
        pointerMove: new SyncHook(),
        pointerOut: new SyncHook(),
        pointerOver: new SyncHook(),
        pointerWheel: new SyncHook(),
        pointerCancel: new SyncHook(),
        click: new SyncHook()
      };
      this.globalRuntime = globalRuntime;
      this.context = context;
    }
    return _createClass(RenderingService2, [{
      key: "init",
      value: function init(callback) {
        var _this = this;
        var context = _objectSpread22(_objectSpread22({}, this.globalRuntime), this.context);
        this.context.renderingPlugins.forEach(function(plugin) {
          plugin.apply(context, _this.globalRuntime);
        });
        this.hooks.init.call();
        if (this.hooks.initAsync.getCallbacksNum() === 0) {
          this.inited = true;
          callback();
        } else {
          this.hooks.initAsync.promise().then(function() {
            _this.inited = true;
            callback();
          })["catch"](function(err) {
          });
        }
      }
    }, {
      key: "getStats",
      value: function getStats() {
        return this.stats;
      }
      /**
       * Meet the following conditions:
       * * disable DirtyRectangleRendering
       * * camera changed
       */
    }, {
      key: "disableDirtyRectangleRendering",
      value: function disableDirtyRectangleRendering() {
        var renderer = this.context.config.renderer;
        var _renderer$getConfig = renderer.getConfig(), enableDirtyRectangleRendering = _renderer$getConfig.enableDirtyRectangleRendering;
        return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
      }
    }, {
      key: "render",
      value: function render2(canvasConfig, frame2, rerenderCallback) {
        var _this2 = this;
        this.stats.total = 0;
        this.stats.rendered = 0;
        this.zIndexCounter = 0;
        var renderingContext = this.context.renderingContext;
        this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
        this.globalRuntime.sceneGraphService.triggerPendingEvents();
        if (renderingContext.renderReasons.size && this.inited) {
          renderingContext.dirtyRectangleRenderingDisabled = this.disableDirtyRectangleRendering();
          var onlyCameraChanged = renderingContext.renderReasons.size === 1 && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
          var shouldTriggerRenderHooks = !canvasConfig.disableRenderHooks || !(canvasConfig.disableRenderHooks && onlyCameraChanged);
          if (shouldTriggerRenderHooks) {
            this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
          }
          this.hooks.beginFrame.call(frame2);
          if (shouldTriggerRenderHooks) {
            renderingContext.renderListCurrentFrame.forEach(function(object) {
              _this2.hooks.beforeRender.call(object);
              _this2.hooks.render.call(object);
              _this2.hooks.afterRender.call(object);
            });
          }
          this.hooks.endFrame.call(frame2);
          renderingContext.renderListCurrentFrame = [];
          renderingContext.renderReasons.clear();
          rerenderCallback();
        }
      }
    }, {
      key: "renderDisplayObject",
      value: function renderDisplayObject(displayObject, canvasConfig, renderingContext) {
        var self2 = this;
        var _canvasConfig$rendere = canvasConfig.renderer.getConfig(), enableDirtyCheck = _canvasConfig$rendere.enableDirtyCheck, enableCulling = _canvasConfig$rendere.enableCulling;
        function internalRenderSingleDisplayObject(object) {
          var renderable = object.renderable, sortable = object.sortable;
          var objectChanged = enableDirtyCheck ? (
            // @ts-ignore
            renderable.dirty || renderingContext.dirtyRectangleRenderingDisabled ? object : null
          ) : object;
          if (objectChanged) {
            var objectToRender = enableCulling ? self2.hooks.cull.call(objectChanged, self2.context.camera) : objectChanged;
            if (objectToRender) {
              self2.stats.rendered += 1;
              renderingContext.renderListCurrentFrame.push(objectToRender);
            }
          }
          renderable.dirty = false;
          sortable.renderOrder = self2.zIndexCounter;
          self2.zIndexCounter += 1;
          self2.stats.total += 1;
          if (sortable.dirty) {
            self2.sort(object, sortable);
            sortable.dirty = false;
            sortable.dirtyChildren = [];
            sortable.dirtyReason = void 0;
          }
        }
        var stack = [displayObject];
        while (stack.length > 0) {
          var currentObject = stack.pop();
          internalRenderSingleDisplayObject(currentObject);
          var objects = currentObject.sortable.sorted || currentObject.childNodes;
          for (var i = objects.length - 1; i >= 0; i--) {
            stack.push(objects[i]);
          }
        }
      }
    }, {
      key: "sort",
      value: function sort3(displayObject, sortable) {
        if (sortable.sorted && sortable.dirtyReason !== SortReason.Z_INDEX_CHANGED) {
          sortable.dirtyChildren.forEach(function(child) {
            var index4 = displayObject.childNodes.indexOf(child);
            if (index4 === -1) {
              var _index = sortable.sorted.indexOf(child);
              if (_index >= 0) {
                sortable.sorted.splice(_index, 1);
              }
            } else if (sortable.sorted.length === 0) {
              sortable.sorted.push(child);
            } else {
              var _index2 = sortedIndex(sortable.sorted, child);
              sortable.sorted.splice(_index2, 0, child);
            }
          });
        } else {
          sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
        }
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        this.inited = false;
        this.hooks.destroy.call();
        this.globalRuntime.sceneGraphService.clearPendingEvents();
      }
    }, {
      key: "dirtify",
      value: function dirtify() {
        this.context.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);
      }
    }]);
  }();
  var ATTRIBUTE_REGEXP = /\[\s*(.*)=(.*)\s*\]/;
  var DefaultSceneGraphSelector = /* @__PURE__ */ function() {
    function DefaultSceneGraphSelector2() {
      _classCallCheck(this, DefaultSceneGraphSelector2);
    }
    return _createClass(DefaultSceneGraphSelector2, [{
      key: "selectOne",
      value: function selectOne(query, root2) {
        var _this = this;
        if (query.startsWith(".")) {
          return root2.find(function(node) {
            return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this.getIdOrClassname(query)) > -1;
          });
        }
        if (query.startsWith("#")) {
          return root2.find(function(node) {
            return node.id === _this.getIdOrClassname(query);
          });
        }
        if (query.startsWith("[")) {
          var _this$getAttribute = this.getAttribute(query), name2 = _this$getAttribute.name, value2 = _this$getAttribute.value;
          if (name2) {
            return root2.find(function(node) {
              return root2 !== node && (name2 === "name" ? node.name === value2 : _this.attributeToString(node, name2) === value2);
            });
          }
          return null;
        }
        return root2.find(function(node) {
          return root2 !== node && node.nodeName === query;
        });
      }
    }, {
      key: "selectAll",
      value: function selectAll(query, root2) {
        var _this2 = this;
        if (query.startsWith(".")) {
          return root2.findAll(function(node) {
            return root2 !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this2.getIdOrClassname(query)) > -1;
          });
        }
        if (query.startsWith("#")) {
          return root2.findAll(function(node) {
            return root2 !== node && node.id === _this2.getIdOrClassname(query);
          });
        }
        if (query.startsWith("[")) {
          var _this$getAttribute2 = this.getAttribute(query), name2 = _this$getAttribute2.name, value2 = _this$getAttribute2.value;
          if (name2) {
            return root2.findAll(function(node) {
              return root2 !== node && (name2 === "name" ? node.name === value2 : _this2.attributeToString(node, name2) === value2);
            });
          }
          return [];
        }
        return root2.findAll(function(node) {
          return root2 !== node && node.nodeName === query;
        });
      }
    }, {
      key: "is",
      value: function is2(query, node) {
        if (query.startsWith(".")) {
          return node.className === this.getIdOrClassname(query);
        }
        if (query.startsWith("#")) {
          return node.id === this.getIdOrClassname(query);
        }
        if (query.startsWith("[")) {
          var _this$getAttribute3 = this.getAttribute(query), name2 = _this$getAttribute3.name, value2 = _this$getAttribute3.value;
          return name2 === "name" ? node.name === value2 : this.attributeToString(node, name2) === value2;
        }
        return node.nodeName === query;
      }
    }, {
      key: "getIdOrClassname",
      value: function getIdOrClassname(query) {
        return query.substring(1);
      }
    }, {
      key: "getAttribute",
      value: function getAttribute2(query) {
        var matches2 = query.match(ATTRIBUTE_REGEXP);
        var name2 = "";
        var value2 = "";
        if (matches2 && matches2.length > 2) {
          name2 = matches2[1].replace(/"/g, "");
          value2 = matches2[2].replace(/"/g, "");
        }
        return {
          name: name2,
          value: value2
        };
      }
    }, {
      key: "attributeToString",
      value: function attributeToString(node, name2) {
        if (!node.getAttribute) {
          return "";
        }
        var value2 = node.getAttribute(name2);
        if (isNil(value2)) {
          return "";
        }
        if (value2.toString) {
          return value2.toString();
        }
        return "";
      }
    }]);
  }();
  var ElementEvent = /* @__PURE__ */ function(ElementEvent2) {
    ElementEvent2["ATTR_MODIFIED"] = "DOMAttrModified";
    ElementEvent2["INSERTED"] = "DOMNodeInserted";
    ElementEvent2["MOUNTED"] = "DOMNodeInsertedIntoDocument";
    ElementEvent2["REMOVED"] = "removed";
    ElementEvent2["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
    ElementEvent2["REPARENT"] = "reparent";
    ElementEvent2["DESTROY"] = "destroy";
    ElementEvent2["BOUNDS_CHANGED"] = "bounds-changed";
    ElementEvent2["CULLED"] = "culled";
    return ElementEvent2;
  }({});
  var MutationEvent = /* @__PURE__ */ function(_FederatedEvent) {
    function MutationEvent2(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
      var _this;
      _classCallCheck(this, MutationEvent2);
      _this = _callSuper(this, MutationEvent2, [null]);
      _this.relatedNode = relatedNode;
      _this.prevValue = prevValue;
      _this.newValue = newValue;
      _this.attrName = attrName;
      _this.attrChange = attrChange;
      _this.prevParsedValue = prevParsedValue;
      _this.newParsedValue = newParsedValue;
      _this.type = typeArg;
      return _this;
    }
    _inherits(MutationEvent2, _FederatedEvent);
    return _createClass(MutationEvent2);
  }(FederatedEvent);
  MutationEvent.ADDITION = 2;
  MutationEvent.MODIFICATION = 1;
  MutationEvent.REMOVAL = 3;
  function markRenderableDirty(e3) {
    var renderable = e3.renderable;
    if (renderable) {
      renderable.renderBoundsDirty = true;
      renderable.boundsDirty = true;
    }
  }
  var reparentEvent = new MutationEvent(ElementEvent.REPARENT, null, "", "", "", 0, "", "");
  var $vec2Zero = vec2_exports.create();
  var $vec3Zero = vec3_exports.create();
  var $vec3One = vec3_exports.fromValues(1, 1, 1);
  var $mat4Identity = mat4_exports.create();
  var $vec2 = vec2_exports.create();
  var $vec3$1 = vec3_exports.create();
  var $mat4 = mat4_exports.create();
  var $quat$1 = quat_exports.create();
  var $setLocalTransform_1 = vec3_exports.create();
  var $setLocalTransform_2 = quat_exports.create();
  var $setLocalTransform_3 = vec3_exports.create();
  var $setLocalPosition = vec3_exports.create();
  var $setPosition_1 = vec3_exports.create();
  var $setPosition_ParentInvertMatrix = mat4_exports.create();
  var $setEulerAngles_InvParentRot = quat_exports.create();
  var $rotateLocal = quat_exports.create();
  var $rotate_ParentInvertRotation = quat_exports.create();
  var $triggerPendingEvents_detail = {
    affectChildren: true
  };
  var DefaultSceneGraphService = /* @__PURE__ */ function() {
    function DefaultSceneGraphService2(runtime2) {
      _classCallCheck(this, DefaultSceneGraphService2);
      this.pendingEvents = /* @__PURE__ */ new Map();
      this.boundsChangedEvent = new CustomEvent2(ElementEvent.BOUNDS_CHANGED);
      this.displayObjectDependencyMap = /* @__PURE__ */ new WeakMap();
      this.runtime = runtime2;
    }
    return _createClass(DefaultSceneGraphService2, [{
      key: "matches",
      value: function matches2(query, root2) {
        return this.runtime.sceneGraphSelector.is(query, root2);
      }
    }, {
      key: "querySelector",
      value: function querySelector(query, root2) {
        return this.runtime.sceneGraphSelector.selectOne(query, root2);
      }
    }, {
      key: "querySelectorAll",
      value: function querySelectorAll(query, root2) {
        return this.runtime.sceneGraphSelector.selectAll(query, root2);
      }
    }, {
      key: "attach",
      value: function attach(child, parent, index4) {
        var _sortable$sorted;
        var detached = false;
        if (child.parentNode) {
          detached = child.parentNode !== parent;
          this.detach(child);
        }
        var isChildFragment = child.nodeName === Shape.FRAGMENT;
        var isAttachToFragment = isInFragment(parent);
        child.parentNode = parent;
        var nodes = isChildFragment ? child.childNodes : [child];
        if (isNumber2(index4)) {
          nodes.forEach(function(node) {
            parent.childNodes.splice(index4, 0, node);
            node.parentNode = parent;
          });
        } else {
          nodes.forEach(function(node) {
            parent.childNodes.push(node);
            node.parentNode = parent;
          });
        }
        var _ref = parent, sortable = _ref.sortable;
        if (sortable !== null && sortable !== void 0 && (_sortable$sorted = sortable.sorted) !== null && _sortable$sorted !== void 0 && _sortable$sorted.length || child.parsedStyle.zIndex) {
          if (sortable.dirtyChildren.indexOf(child) === -1) {
            sortable.dirtyChildren.push(child);
          }
          sortable.dirty = true;
          sortable.dirtyReason = SortReason.ADDED;
        }
        if (isAttachToFragment) return;
        if (isChildFragment) this.dirtifyFragment(child);
        else {
          var transform = child.transformable;
          if (transform) {
            this.dirtifyWorld(child, transform);
          }
        }
        if (detached) {
          child.dispatchEvent(reparentEvent);
        }
      }
    }, {
      key: "detach",
      value: function detach(child) {
        if (child.parentNode) {
          var _sortable$sorted2, _style;
          var transform = child.transformable;
          var _ref2 = child.parentNode, sortable = _ref2.sortable;
          if (sortable !== null && sortable !== void 0 && (_sortable$sorted2 = sortable.sorted) !== null && _sortable$sorted2 !== void 0 && _sortable$sorted2.length || (_style = child.style) !== null && _style !== void 0 && _style.zIndex) {
            if (sortable.dirtyChildren.indexOf(child) === -1) {
              sortable.dirtyChildren.push(child);
            }
            sortable.dirty = true;
            sortable.dirtyReason = SortReason.REMOVED;
          }
          var index4 = child.parentNode.childNodes.indexOf(child);
          if (index4 > -1) {
            child.parentNode.childNodes.splice(index4, 1);
          }
          if (transform) {
            this.dirtifyWorld(child, transform);
          }
          child.parentNode = null;
        }
      }
    }, {
      key: "getOrigin",
      value: function getOrigin2(element) {
        element.getGeometryBounds();
        return element.transformable.origin;
      }
      /**
       * same as pivot in Pixi.js
       *
       * @see https://stackoverflow.com/questions/40748452/how-to-change-css-transform-origin-but-preserve-transformation
       */
    }, {
      key: "setOrigin",
      value: function setOrigin(element, origin) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        if (typeof origin === "number") {
          origin = [origin, y3, z];
        }
        var transform = element.transformable;
        if (origin[0] === transform.origin[0] && origin[1] === transform.origin[1] && origin[2] === transform.origin[2]) {
          return;
        }
        var originVec = transform.origin;
        originVec[0] = origin[0];
        originVec[1] = origin[1];
        originVec[2] = origin[2] || 0;
        this.dirtifyLocal(element, transform);
      }
      /**
       * rotate in world space
       */
    }, {
      key: "rotate",
      value: function rotate5(element, degrees3) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        if (typeof degrees3 === "number") {
          degrees3 = vec3_exports.fromValues(degrees3, y3, z);
        }
        var transform = element.transformable;
        if (element.parentNode === null || !element.parentNode.transformable) {
          this.rotateLocal(element, degrees3);
        } else {
          var rotation = $quat$1;
          quat_exports.fromEuler(rotation, degrees3[0], degrees3[1], degrees3[2]);
          var rot = this.getRotation(element);
          var parentRot = this.getRotation(element.parentNode);
          quat_exports.copy($rotate_ParentInvertRotation, parentRot);
          quat_exports.invert($rotate_ParentInvertRotation, $rotate_ParentInvertRotation);
          quat_exports.multiply(rotation, $rotate_ParentInvertRotation, rotation);
          quat_exports.multiply(transform.localRotation, rotation, rot);
          quat_exports.normalize(transform.localRotation, transform.localRotation);
          this.dirtifyLocal(element, transform);
        }
      }
      /**
       * rotate in local space
       * @see @see https://docs.microsoft.com/en-us/windows/win32/api/directxmath/nf-directxmath-xmquaternionrotationrollpitchyaw
       */
    }, {
      key: "rotateLocal",
      value: function rotateLocal(element, degrees3) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        if (typeof degrees3 === "number") {
          degrees3 = vec3_exports.fromValues(degrees3, y3, z);
        }
        var transform = element.transformable;
        quat_exports.fromEuler($rotateLocal, degrees3[0], degrees3[1], degrees3[2]);
        quat_exports.mul(transform.localRotation, transform.localRotation, $rotateLocal);
        this.dirtifyLocal(element, transform);
      }
      /**
       * set euler angles(degrees) in world space
       */
    }, {
      key: "setEulerAngles",
      value: function setEulerAngles(element, degrees3) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        if (typeof degrees3 === "number") {
          degrees3 = vec3_exports.fromValues(degrees3, y3, z);
        }
        var transform = element.transformable;
        if (element.parentNode === null || !element.parentNode.transformable) {
          this.setLocalEulerAngles(element, degrees3);
        } else {
          quat_exports.fromEuler(transform.localRotation, degrees3[0], degrees3[1], degrees3[2]);
          var parentRotation = this.getRotation(element.parentNode);
          quat_exports.copy($setEulerAngles_InvParentRot, quat_exports.invert($quat$1, parentRotation));
          quat_exports.mul(transform.localRotation, transform.localRotation, $setEulerAngles_InvParentRot);
          this.dirtifyLocal(element, transform);
        }
      }
      /**
       * set euler angles(degrees) in local space
       */
    }, {
      key: "setLocalEulerAngles",
      value: function setLocalEulerAngles(element, degrees3) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        var dirtify = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
        if (typeof degrees3 === "number") {
          degrees3 = vec3_exports.fromValues(degrees3, y3, z);
        }
        var transform = element.transformable;
        quat_exports.fromEuler(transform.localRotation, degrees3[0], degrees3[1], degrees3[2]);
        if (dirtify) {
          this.dirtifyLocal(element, transform);
        }
      }
      /**
       * translate in local space
       *
       * @example
       * ```
       * translateLocal(x, y, z)
       * translateLocal(vec3(x, y, z))
       * ```
       */
    }, {
      key: "translateLocal",
      value: function translateLocal(element, translation) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        if (typeof translation === "number") {
          translation = vec3_exports.fromValues(translation, y3, z);
        }
        var transform = element.transformable;
        if (vec3_exports.equals(translation, $vec3Zero)) return;
        vec3_exports.transformQuat(translation, translation, transform.localRotation);
        vec3_exports.add(transform.localPosition, transform.localPosition, translation);
        this.dirtifyLocal(element, transform);
      }
      /**
       * move to position in world space
       *
       * 对应 g 原版的 move/moveTo
       * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L684-L689
       */
    }, {
      key: "setPosition",
      value: function setPosition(element, position) {
        var _position$;
        var transform = element.transformable;
        $setPosition_1[0] = position[0];
        $setPosition_1[1] = position[1];
        $setPosition_1[2] = (_position$ = position[2]) !== null && _position$ !== void 0 ? _position$ : 0;
        if (vec3_exports.equals(this.getPosition(element), $setPosition_1)) {
          return;
        }
        vec3_exports.copy(transform.position, $setPosition_1);
        if (element.parentNode === null || !element.parentNode.transformable) {
          vec3_exports.copy(transform.localPosition, $setPosition_1);
        } else {
          var parentTransform = element.parentNode.transformable;
          mat4_exports.copy($setPosition_ParentInvertMatrix, parentTransform.worldTransform);
          mat4_exports.invert($setPosition_ParentInvertMatrix, $setPosition_ParentInvertMatrix);
          vec3_exports.transformMat4(transform.localPosition, $setPosition_1, $setPosition_ParentInvertMatrix);
        }
        this.dirtifyLocal(element, transform);
      }
      /**
       * move to position in local space
       */
    }, {
      key: "setLocalPosition",
      value: function setLocalPosition(element, position) {
        var _position$2;
        var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
        var transform = element.transformable;
        $setLocalPosition[0] = position[0];
        $setLocalPosition[1] = position[1];
        $setLocalPosition[2] = (_position$2 = position[2]) !== null && _position$2 !== void 0 ? _position$2 : 0;
        if (vec3_exports.equals(transform.localPosition, $setLocalPosition)) {
          return;
        }
        vec3_exports.copy(transform.localPosition, $setLocalPosition);
        if (dirtify) {
          this.dirtifyLocal(element, transform);
        }
      }
      /**
       * scale in local space
       */
    }, {
      key: "scaleLocal",
      value: function scaleLocal(element, scaling) {
        var _scaling$;
        var transform = element.transformable;
        vec3_exports.multiply(transform.localScale, transform.localScale, vec3_exports.set($vec3$1, scaling[0], scaling[1], (_scaling$ = scaling[2]) !== null && _scaling$ !== void 0 ? _scaling$ : 1));
        this.dirtifyLocal(element, transform);
      }
    }, {
      key: "setLocalScale",
      value: function setLocalScale(element, scaling) {
        var _scaling$2;
        var dirtify = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
        var transform = element.transformable;
        vec3_exports.set($vec3$1, scaling[0], scaling[1], (_scaling$2 = scaling[2]) !== null && _scaling$2 !== void 0 ? _scaling$2 : transform.localScale[2]);
        if (vec3_exports.equals($vec3$1, transform.localScale)) {
          return;
        }
        vec3_exports.copy(transform.localScale, $vec3$1);
        if (dirtify) {
          this.dirtifyLocal(element, transform);
        }
      }
      /**
       * translate in world space
       *
       * @example
       * ```
       * translate(x, y, z)
       * translate(vec3(x, y, z))
       * ```
       *
       * 对应 g 原版的 translate 2D
       * @see https://github.com/antvis/g/blob/master/packages/g-base/src/abstract/element.ts#L665-L676
       */
    }, {
      key: "translate",
      value: function translate5(element, translation) {
        var y3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        var z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
        if (typeof translation === "number") {
          translation = vec3_exports.set($vec3$1, translation, y3, z);
        }
        if (vec3_exports.equals(translation, $vec3Zero)) return;
        vec3_exports.add($vec3$1, this.getPosition(element), translation);
        this.setPosition(element, $vec3$1);
      }
    }, {
      key: "setRotation",
      value: function setRotation(element, rotation, y3, z, w) {
        var transform = element.transformable;
        if (typeof rotation === "number") {
          rotation = quat_exports.fromValues(rotation, y3, z, w);
        }
        if (element.parentNode === null || !element.parentNode.transformable) {
          this.setLocalRotation(element, rotation);
        } else {
          var parentRot = this.getRotation(element.parentNode);
          quat_exports.copy($quat$1, parentRot);
          quat_exports.invert($quat$1, $quat$1);
          quat_exports.multiply(transform.localRotation, $quat$1, rotation);
          quat_exports.normalize(transform.localRotation, transform.localRotation);
          this.dirtifyLocal(element, transform);
        }
      }
    }, {
      key: "setLocalRotation",
      value: function setLocalRotation(element, rotation, y3, z, w) {
        var dirtify = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;
        if (typeof rotation === "number") {
          rotation = quat_exports.set($quat$1, rotation, y3, z, w);
        }
        var transform = element.transformable;
        quat_exports.copy(transform.localRotation, rotation);
        if (dirtify) {
          this.dirtifyLocal(element, transform);
        }
      }
    }, {
      key: "setLocalSkew",
      value: function setLocalSkew(element, skew2, y3) {
        var dirtify = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
        if (typeof skew2 === "number") {
          skew2 = vec2_exports.set($vec2, skew2, y3);
        }
        var transform = element.transformable;
        vec2_exports.copy(transform.localSkew, skew2);
        if (dirtify) {
          this.dirtifyLocal(element, transform);
        }
      }
    }, {
      key: "dirtifyLocal",
      value: function dirtifyLocal(element, transform) {
        if (isInFragment(element)) return;
        if (!transform.localDirtyFlag) {
          transform.localDirtyFlag = true;
          if (!transform.dirtyFlag) {
            this.dirtifyWorld(element, transform);
          }
        }
      }
    }, {
      key: "dirtifyWorld",
      value: function dirtifyWorld(element, transform) {
        if (!transform.dirtyFlag) {
          this.unfreezeParentToRoot(element);
        }
        this.dirtifyWorldInternal(element, transform);
        this.dirtifyToRoot(element, true);
      }
    }, {
      key: "dirtifyFragment",
      value: function dirtifyFragment(element) {
        var transform = element.transformable;
        if (transform) {
          transform.frozen = false;
          transform.dirtyFlag = true;
          transform.localDirtyFlag = true;
        }
        var renderable = element.renderable;
        if (renderable) {
          renderable.renderBoundsDirty = true;
          renderable.boundsDirty = true;
          renderable.dirty = true;
        }
        var length5 = element.childNodes.length;
        for (var i = 0; i < length5; i++) {
          this.dirtifyFragment(element.childNodes[i]);
        }
        if (element.nodeName === Shape.FRAGMENT) {
          this.pendingEvents.set(element, false);
        }
      }
    }, {
      key: "triggerPendingEvents",
      value: function triggerPendingEvents() {
        var _this = this;
        var triggered = /* @__PURE__ */ new Set();
        var trigger = function trigger2(element, detail) {
          if (!element.isConnected || triggered.has(element) || element.nodeName === Shape.FRAGMENT) {
            return;
          }
          _this.boundsChangedEvent.detail = detail;
          _this.boundsChangedEvent.target = element;
          if (element.isMutationObserved) {
            element.dispatchEvent(_this.boundsChangedEvent);
          } else {
            element.ownerDocument.defaultView.dispatchEvent(_this.boundsChangedEvent, true);
          }
          triggered.add(element);
        };
        this.pendingEvents.forEach(function(affectChildren, element) {
          if (element.nodeName === Shape.FRAGMENT) {
            return;
          }
          $triggerPendingEvents_detail.affectChildren = affectChildren;
          if (affectChildren) {
            element.forEach(function(e3) {
              trigger(e3, $triggerPendingEvents_detail);
            });
          } else trigger(element, $triggerPendingEvents_detail);
        });
        triggered.clear();
        this.clearPendingEvents();
      }
    }, {
      key: "clearPendingEvents",
      value: function clearPendingEvents() {
        this.pendingEvents.clear();
      }
    }, {
      key: "dirtifyToRoot",
      value: function dirtifyToRoot(element) {
        var affectChildren = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var p2 = element;
        if (p2.renderable) {
          p2.renderable.dirty = true;
        }
        while (p2) {
          markRenderableDirty(p2);
          p2 = p2.parentNode;
        }
        if (affectChildren) {
          element.forEach(function(e3) {
            markRenderableDirty(e3);
          });
        }
        this.informDependentDisplayObjects(element);
        this.pendingEvents.set(element, affectChildren);
      }
    }, {
      key: "updateDisplayObjectDependency",
      value: function updateDisplayObjectDependency(name2, oldPath, newPath, object) {
        if (oldPath && oldPath !== newPath) {
          var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
          if (oldDependencyMap && oldDependencyMap[name2]) {
            var index4 = oldDependencyMap[name2].indexOf(object);
            oldDependencyMap[name2].splice(index4, 1);
          }
        }
        if (newPath) {
          var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
          if (!newDependencyMap) {
            this.displayObjectDependencyMap.set(newPath, {});
            newDependencyMap = this.displayObjectDependencyMap.get(newPath);
          }
          if (!newDependencyMap[name2]) {
            newDependencyMap[name2] = [];
          }
          newDependencyMap[name2].push(object);
        }
      }
    }, {
      key: "informDependentDisplayObjects",
      value: function informDependentDisplayObjects(object) {
        var _this2 = this;
        var dependencyMap = this.displayObjectDependencyMap.get(object);
        if (!dependencyMap) {
          return;
        }
        Object.keys(dependencyMap).forEach(function(name2) {
          dependencyMap[name2].forEach(function(target) {
            _this2.dirtifyToRoot(target, true);
            target.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, target, _this2, _this2, name2, MutationEvent.MODIFICATION, _this2, _this2));
            if (target.isCustomElement && target.isConnected) {
              if (target.attributeChangedCallback) {
                target.attributeChangedCallback(name2, _this2, _this2);
              }
            }
          });
        });
      }
    }, {
      key: "getPosition",
      value: function getPosition(element) {
        var transform = element.transformable;
        return mat4_exports.getTranslation(transform.position, this.getWorldTransform(element, transform));
      }
    }, {
      key: "getRotation",
      value: function getRotation2(element) {
        var transform = element.transformable;
        return mat4_exports.getRotation(transform.rotation, this.getWorldTransform(element, transform));
      }
    }, {
      key: "getScale",
      value: function getScale(element) {
        var transform = element.transformable;
        return mat4_exports.getScaling(transform.scaling, this.getWorldTransform(element, transform));
      }
    }, {
      key: "getWorldTransform",
      value: function getWorldTransform(element) {
        var transform = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : element.transformable;
        if (!transform.localDirtyFlag && !transform.dirtyFlag) {
          return transform.worldTransform;
        }
        if (element.parentNode && element.parentNode.transformable) {
          this.getWorldTransform(element.parentNode);
        }
        this.sync(element, transform);
        return transform.worldTransform;
      }
    }, {
      key: "getLocalPosition",
      value: function getLocalPosition(element) {
        return element.transformable.localPosition;
      }
    }, {
      key: "getLocalRotation",
      value: function getLocalRotation(element) {
        return element.transformable.localRotation;
      }
    }, {
      key: "getLocalScale",
      value: function getLocalScale(element) {
        return element.transformable.localScale;
      }
    }, {
      key: "getLocalSkew",
      value: function getLocalSkew(element) {
        return element.transformable.localSkew;
      }
    }, {
      key: "calcLocalTransform",
      value: function calcLocalTransform(transform) {
        var hasSkew = transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0;
        if (hasSkew) {
          mat4_exports.fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, vec3_exports.fromValues(1, 1, 1), transform.origin);
          if (transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0) {
            mat4_exports.identity($mat4);
            $mat4[4] = Math.tan(transform.localSkew[0]);
            $mat4[1] = Math.tan(transform.localSkew[1]);
            mat4_exports.multiply(transform.localTransform, transform.localTransform, $mat4);
          }
          var scaling = mat4_exports.fromRotationTranslationScaleOrigin($mat4, quat_exports.set($quat$1, 0, 0, 0, 1), vec3_exports.set($vec3$1, 1, 1, 1), transform.localScale, transform.origin);
          mat4_exports.multiply(transform.localTransform, transform.localTransform, scaling);
        } else {
          var localTransform = transform.localTransform, localPosition = transform.localPosition, localRotation = transform.localRotation, localScale = transform.localScale, origin = transform.origin;
          var hasPosition = localPosition[0] !== 0 || localPosition[1] !== 0 || localPosition[2] !== 0;
          var hasRotation = localRotation[3] !== 1 || localRotation[0] !== 0 || localRotation[1] !== 0 || localRotation[2] !== 0;
          var hasScale = localScale[0] !== 1 || localScale[1] !== 1 || localScale[2] !== 1;
          var hasOrigin = origin[0] !== 0 || origin[1] !== 0 || origin[2] !== 0;
          if (!hasRotation && !hasScale && !hasOrigin) {
            if (hasPosition) {
              mat4_exports.fromTranslation(localTransform, localPosition);
            } else {
              mat4_exports.identity(localTransform);
            }
          } else {
            mat4_exports.fromRotationTranslationScaleOrigin(localTransform, localRotation, localPosition, localScale, origin);
          }
        }
      }
    }, {
      key: "getLocalTransform",
      value: function getLocalTransform(element) {
        var transform = element.transformable;
        if (transform.localDirtyFlag) {
          this.calcLocalTransform(transform);
          transform.localDirtyFlag = false;
        }
        return transform.localTransform;
      }
    }, {
      key: "setLocalTransform",
      value: function setLocalTransform(element, transform) {
        var t = mat4_exports.getTranslation($setLocalTransform_1, transform);
        var r = mat4_exports.getRotation($setLocalTransform_2, transform);
        var s3 = mat4_exports.getScaling($setLocalTransform_3, transform);
        this.setLocalScale(element, s3, false);
        this.setLocalPosition(element, t, false);
        this.setLocalRotation(element, r, void 0, void 0, void 0, false);
        this.dirtifyLocal(element, element.transformable);
      }
    }, {
      key: "resetLocalTransform",
      value: function resetLocalTransform(element) {
        this.setLocalScale(element, $vec3One, false);
        this.setLocalPosition(element, $vec3Zero, false);
        this.setLocalEulerAngles(element, $vec3Zero, void 0, void 0, false);
        this.setLocalSkew(element, $vec2Zero, void 0, false);
        this.dirtifyLocal(element, element.transformable);
      }
    }, {
      key: "getTransformedGeometryBounds",
      value: function getTransformedGeometryBounds(element) {
        var render2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var existedAABB = arguments.length > 2 ? arguments[2] : void 0;
        var bounds = this.getGeometryBounds(element, render2);
        if (!AABB.isEmpty(bounds)) {
          var aabb = existedAABB || new AABB();
          aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
          return aabb;
        }
        return null;
      }
      /**
       * won't account for children
       */
    }, {
      key: "getGeometryBounds",
      value: function getGeometryBounds(element) {
        var render2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var _ref3 = element, geometry = _ref3.geometry;
        if (geometry.dirty) {
          runtime.styleValueRegistry.updateGeometry(element);
        }
        var bounds = render2 ? geometry.renderBounds : geometry.contentBounds || null;
        return bounds || new AABB();
      }
      /**
       * account for children in world space
       */
    }, {
      key: "getBounds",
      value: function getBounds2(element) {
        var _this3 = this;
        var render2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var _ref4 = element, renderable = _ref4.renderable;
        if (!renderable.boundsDirty && !render2 && renderable.bounds) {
          return renderable.bounds;
        }
        if (!renderable.renderBoundsDirty && render2 && renderable.renderBounds) {
          return renderable.renderBounds;
        }
        var existedAABB = render2 ? renderable.renderBounds : renderable.bounds;
        var aabb = this.getTransformedGeometryBounds(element, render2, existedAABB);
        var children = element.childNodes;
        children.forEach(function(child) {
          var childBounds = _this3.getBounds(child, render2);
          if (childBounds) {
            if (!aabb) {
              aabb = existedAABB || new AABB();
              aabb.update(childBounds.center, childBounds.halfExtents);
            } else {
              aabb.add(childBounds);
            }
          }
        });
        if (!aabb) {
          aabb = new AABB();
        }
        if (render2) {
          var clipped = findClosestClipPathTarget(element);
          if (clipped) {
            var clipPathBounds = clipped.parsedStyle.clipPath.getBounds(render2);
            if (!aabb) {
              aabb.update(clipPathBounds.center, clipPathBounds.halfExtents);
            } else if (clipPathBounds) {
              aabb = clipPathBounds.intersection(aabb);
            }
          }
        }
        if (render2) {
          renderable.renderBounds = aabb;
          renderable.renderBoundsDirty = false;
        } else {
          renderable.bounds = aabb;
          renderable.boundsDirty = false;
        }
        return aabb;
      }
      /**
       * account for children in local space
       */
    }, {
      key: "getLocalBounds",
      value: function getLocalBounds2(element) {
        if (element.parentNode) {
          var parentInvert = $mat4Identity;
          if (element.parentNode.transformable) {
            parentInvert = mat4_exports.invert($mat4, this.getWorldTransform(element.parentNode));
          }
          var bounds = this.getBounds(element);
          if (!AABB.isEmpty(bounds)) {
            var localBounds = new AABB();
            localBounds.setFromTransformedAABB(bounds, parentInvert);
            return localBounds;
          }
        }
        return this.getBounds(element);
      }
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect(element) {
        var _element$ownerDocumen;
        var aabb;
        var bounds = this.getGeometryBounds(element);
        if (!AABB.isEmpty(bounds)) {
          aabb = new AABB();
          aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
        }
        var bbox = (_element$ownerDocumen = element.ownerDocument) === null || _element$ownerDocumen === void 0 || (_element$ownerDocumen = _element$ownerDocumen.defaultView) === null || _element$ownerDocumen === void 0 ? void 0 : _element$ownerDocumen.getContextService().getBoundingClientRect();
        if (aabb) {
          var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray(_aabb$getMin, 2), left2 = _aabb$getMin2[0], top = _aabb$getMin2[1];
          var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray(_aabb$getMax, 2), right2 = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
          return new Rectangle(left2 + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right2 - left2, bottom - top);
        }
        return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
      }
    }, {
      key: "dirtifyWorldInternal",
      value: function dirtifyWorldInternal(element, transform) {
        var _this4 = this;
        if (!transform.dirtyFlag) {
          transform.dirtyFlag = true;
          transform.frozen = false;
          element.childNodes.forEach(function(child) {
            var childTransform = child.transformable;
            if (!childTransform.dirtyFlag) {
              _this4.dirtifyWorldInternal(child, childTransform);
            }
          });
          var _ref5 = element, renderable = _ref5.renderable;
          if (renderable) {
            renderable.renderBoundsDirty = true;
            renderable.boundsDirty = true;
            renderable.dirty = true;
          }
        }
      }
    }, {
      key: "syncHierarchy",
      value: function syncHierarchy(element) {
        var transform = element.transformable;
        if (transform.frozen) {
          return;
        }
        transform.frozen = true;
        if (transform.localDirtyFlag || transform.dirtyFlag) {
          this.sync(element, transform);
        }
        var children = element.childNodes;
        for (var i = 0; i < children.length; i++) {
          this.syncHierarchy(children[i]);
        }
      }
    }, {
      key: "sync",
      value: function sync(element, transform) {
        if (transform.localDirtyFlag) {
          this.calcLocalTransform(transform);
          transform.localDirtyFlag = false;
        }
        if (transform.dirtyFlag) {
          var parent = element.parentNode;
          var parentTransform = parent && parent.transformable;
          if (parent === null || !parentTransform) {
            mat4_exports.copy(transform.worldTransform, transform.localTransform);
          } else {
            mat4_exports.multiply(transform.worldTransform, parentTransform.worldTransform, transform.localTransform);
          }
          transform.dirtyFlag = false;
        }
      }
    }, {
      key: "unfreezeParentToRoot",
      value: function unfreezeParentToRoot(child) {
        var p2 = child.parentNode;
        while (p2) {
          var transform = p2.transformable;
          if (transform) {
            transform.frozen = false;
          }
          p2 = p2.parentNode;
        }
      }
    }]);
  }();
  var TEXT_METRICS = {
    MetricsString: "|\xC9q\xC5",
    BaselineSymbol: "M",
    BaselineMultiplier: 1.4,
    HeightMultiplier: 2,
    Newlines: [
      10,
      // line feed
      13
      // carriage return
    ],
    BreakingSpaces: [
      9,
      // character tabulation
      32,
      // space
      8192,
      // en quad
      8193,
      // em quad
      8194,
      // en space
      8195,
      // em space
      8196,
      // three-per-em space
      8197,
      // four-per-em space
      8198,
      // six-per-em space
      8200,
      // punctuation space
      8201,
      // thin space
      8202,
      // hair space
      8287,
      // medium mathematical space
      12288
      // ideographic space
    ]
  };
  var LATIN_REGEX = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
  var regexCannotStartZhCn = /[!%),.:;?\]}¢°·'""†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？！］｝～]/;
  var regexCannotEndZhCn = /[$(£¥·'"〈《「『【〔〖〝﹙﹛＄（．［｛￡￥]/;
  var regexCannotStartZhTw = /[!),.:;?\]}¢·–—'"•"、。〆〞〕〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘﹚﹜！），．：；？︶︸︺︼︾﹀﹂﹗］｜｝､]/;
  var regexCannotEndZhTw = /[([{£¥'"‵〈《「『〔〝︴﹙﹛（｛︵︷︹︻︽︿﹁﹃﹏]/;
  var regexCannotStartJaJp = /[)\]｝〕〉》」』】〙〗〟'"｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠–〜?!‼⁇⁈⁉・、:;,。.]/;
  var regexCannotEndJaJp = /[([｛〔〈《「『【〘〖〝'"｟«—...‥〳〴〵]/;
  var regexCannotStartKoKr = /[!%),.:;?\]}¢°'"†‡℃〆〈《「『〕！％），．：；？］｝]/;
  var regexCannotEndKoKr = /[$([{£¥'"々〇〉》」〔＄（［｛｠￥￦#]/;
  var regexCannotStart = new RegExp("".concat(regexCannotStartZhCn.source, "|").concat(regexCannotStartZhTw.source, "|").concat(regexCannotStartJaJp.source, "|").concat(regexCannotStartKoKr.source));
  var regexCannotEnd = new RegExp("".concat(regexCannotEndZhCn.source, "|").concat(regexCannotEndZhTw.source, "|").concat(regexCannotEndJaJp.source, "|").concat(regexCannotEndKoKr.source));
  var TextService = /* @__PURE__ */ function() {
    function TextService2(runtime2) {
      var _this = this;
      _classCallCheck(this, TextService2);
      this.fontMetricsCache = {};
      this.shouldBreakByKinsokuShorui = function(_char, nextChar) {
        if (_this.isBreakingSpace(nextChar)) return false;
        if (_char) {
          if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(_char)) {
            return true;
          }
        }
        return false;
      };
      this.trimByKinsokuShorui = function(prev) {
        var next = _toConsumableArray(prev);
        var prevLine = next[next.length - 2];
        if (!prevLine) {
          return prev;
        }
        var lastChar = prevLine[prevLine.length - 1];
        next[next.length - 2] = prevLine.slice(0, -1);
        next[next.length - 1] = lastChar + next[next.length - 1];
        return next;
      };
      this.runtime = runtime2;
    }
    return _createClass(TextService2, [{
      key: "measureFont",
      value: (
        /**
         * Calculates the ascent, descent and fontSize of a given font-style.
         */
        function measureFont(font, offscreenCanvas) {
          if (this.fontMetricsCache[font]) {
            return this.fontMetricsCache[font];
          }
          var properties = {
            ascent: 0,
            descent: 0,
            fontSize: 0
          };
          var canvas = this.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
          var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
            willReadFrequently: true
          });
          context.font = font;
          var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;
          var width = Math.ceil(context.measureText(metricsString).width);
          var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);
          var height = TEXT_METRICS.HeightMultiplier * baseline;
          baseline = baseline * TEXT_METRICS.BaselineMultiplier | 0;
          canvas.width = width;
          canvas.height = height;
          context.fillStyle = "#f00";
          context.fillRect(0, 0, width, height);
          context.font = font;
          context.textBaseline = "alphabetic";
          context.fillStyle = "#000";
          context.fillText(metricsString, 0, baseline);
          var imagedata = context.getImageData(0, 0, width || 1, height || 1).data;
          var pixels = imagedata.length;
          var line4 = width * 4;
          var i = 0;
          var idx = 0;
          var stop = false;
          for (i = 0; i < baseline; ++i) {
            for (var j = 0; j < line4; j += 4) {
              if (imagedata[idx + j] !== 255) {
                stop = true;
                break;
              }
            }
            if (!stop) {
              idx += line4;
            } else {
              break;
            }
          }
          properties.ascent = baseline - i;
          idx = pixels - line4;
          stop = false;
          for (i = height; i > baseline; --i) {
            for (var _j = 0; _j < line4; _j += 4) {
              if (imagedata[idx + _j] !== 255) {
                stop = true;
                break;
              }
            }
            if (!stop) {
              idx -= line4;
            } else {
              break;
            }
          }
          properties.descent = i - baseline;
          properties.fontSize = properties.ascent + properties.descent;
          this.fontMetricsCache[font] = properties;
          return properties;
        }
      )
    }, {
      key: "measureText",
      value: function measureText(text, parsedStyle, offscreenCanvas) {
        var _parsedStyle$fontSize = parsedStyle.fontSize, fontSize = _parsedStyle$fontSize === void 0 ? 16 : _parsedStyle$fontSize, _parsedStyle$wordWrap = parsedStyle.wordWrap, wordWrap = _parsedStyle$wordWrap === void 0 ? false : _parsedStyle$wordWrap, strokeHeight = parsedStyle.lineHeight, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, textPath = parsedStyle.textPath;
        parsedStyle.textPathSide;
        parsedStyle.textPathStartOffset;
        var _parsedStyle$leading = parsedStyle.leading, leading = _parsedStyle$leading === void 0 ? 0 : _parsedStyle$leading;
        var font = toFontString(parsedStyle);
        var fontProperties = this.measureFont(font, offscreenCanvas);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = fontSize;
          fontProperties.ascent = fontSize;
        }
        var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
        context.font = font;
        parsedStyle.isOverflowing = false;
        var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        if (textPath) {
          textPath.getTotalLength();
          for (var i = 0; i < lines.length; i++) {
            context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;
          }
        } else {
          for (var _i = 0; _i < lines.length; _i++) {
            var _lineWidth = context.measureText(lines[_i]).width + (lines[_i].length - 1) * letterSpacing;
            lineWidths[_i] = _lineWidth;
            maxLineWidth = Math.max(maxLineWidth, _lineWidth);
          }
          var _width = maxLineWidth + lineWidth;
          var lineHeight = strokeHeight || fontProperties.fontSize + lineWidth;
          var height = Math.max(lineHeight, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight + leading);
          lineHeight += leading;
          var offsetY = 0;
          if (textBaseline === "middle") {
            offsetY = -height / 2;
          } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
            offsetY = -height;
          } else if (textBaseline === "top" || textBaseline === "hanging") {
            offsetY = 0;
          }
          return {
            font,
            width: _width,
            height,
            lines,
            lineWidths,
            lineHeight,
            maxLineWidth,
            fontProperties,
            lineMetrics: lineWidths.map(function(width, i2) {
              var offsetX = 0;
              if (textAlign === "center" || textAlign === "middle") {
                offsetX -= width / 2;
              } else if (textAlign === "right" || textAlign === "end") {
                offsetX -= width;
              }
              return new Rectangle(offsetX - lineWidth / 2, offsetY + i2 * lineHeight, width + lineWidth, lineHeight);
            })
          };
        }
      }
    }, {
      key: "wordWrap",
      value: function wordWrap(text, parsedStyle, offscreenCanvas) {
        var _this2 = this;
        var self2 = this;
        var _parsedStyle$wordWrap2 = parsedStyle.wordWrapWidth, wordWrapWidth = _parsedStyle$wordWrap2 === void 0 ? 0 : _parsedStyle$wordWrap2, _parsedStyle$letterSp2 = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp2 === void 0 ? 0 : _parsedStyle$letterSp2, _parsedStyle$maxLines = parsedStyle.maxLines, maxLines = _parsedStyle$maxLines === void 0 ? Infinity : _parsedStyle$maxLines, textOverflow = parsedStyle.textOverflow;
        var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
        var maxWidth = wordWrapWidth + letterSpacing;
        var ellipsis = "";
        if (textOverflow === "ellipsis") {
          ellipsis = "...";
        } else if (textOverflow && textOverflow !== "clip") {
          ellipsis = textOverflow;
        }
        var chars = Array.from(text);
        var lines = [];
        var currentLineIndex = 0;
        var currentLineWidth = 0;
        var cache3 = {};
        var calcWidth = function calcWidth2(txt) {
          return _this2.getFromCache(txt, letterSpacing, cache3, context);
        };
        var ellipsisWidth = calcWidth(ellipsis);
        function findCharIndexClosestWidthThreshold(txt, textCharIndex, widthThreshold) {
          while (calcWidth(txt) < widthThreshold && textCharIndex < chars.length - 1) {
            if (self2.isNewline(chars[textCharIndex + 1])) {
              break;
            }
            textCharIndex += 1;
            txt += chars[textCharIndex];
          }
          while (calcWidth(txt) > widthThreshold && textCharIndex > 0) {
            textCharIndex -= 1;
            txt = txt.slice(0, -1);
          }
          return {
            txt,
            textCharIndex
          };
        }
        function appendEllipsis(lineIndex, textCharIndex) {
          if (ellipsisWidth <= 0 || ellipsisWidth > maxWidth) {
            return;
          }
          if (!lines[lineIndex]) {
            lines[lineIndex] = ellipsis;
            return;
          }
          var result2 = findCharIndexClosestWidthThreshold(lines[lineIndex], textCharIndex, maxWidth - ellipsisWidth);
          lines[lineIndex] = result2.txt + ellipsis;
        }
        for (var i = 0; i < chars.length; i++) {
          var _char2 = chars[i];
          var prevChar = chars[i - 1];
          var nextChar = chars[i + 1];
          var charWidth = calcWidth(_char2);
          if (this.isNewline(_char2)) {
            if (currentLineIndex + 1 >= maxLines) {
              parsedStyle.isOverflowing = true;
              if (i < chars.length - 1) {
                appendEllipsis(currentLineIndex, i - 1);
              }
              break;
            }
            currentLineIndex += 1;
            currentLineWidth = 0;
            lines[currentLineIndex] = "";
            continue;
          }
          if (currentLineWidth > 0 && currentLineWidth + charWidth > maxWidth) {
            var result = findCharIndexClosestWidthThreshold(lines[currentLineIndex], i - 1, maxWidth);
            if (result.textCharIndex !== i - 1) {
              lines[currentLineIndex] = result.txt;
              if (result.textCharIndex === chars.length - 1) {
                break;
              }
              i = result.textCharIndex + 1;
              _char2 = chars[i];
              prevChar = chars[i - 1];
              nextChar = chars[i + 1];
              charWidth = calcWidth(_char2);
            }
            if (currentLineIndex + 1 >= maxLines) {
              parsedStyle.isOverflowing = true;
              appendEllipsis(currentLineIndex, i - 1);
              break;
            }
            currentLineIndex += 1;
            currentLineWidth = 0;
            lines[currentLineIndex] = "";
            if (this.isBreakingSpace(_char2)) {
              continue;
            }
            if (!this.canBreakInLastChar(_char2)) {
              lines = this.trimToBreakable(lines);
              currentLineWidth = this.sumTextWidthByCache(lines[currentLineIndex] || "", cache3);
            }
            if (this.shouldBreakByKinsokuShorui(_char2, nextChar)) {
              lines = this.trimByKinsokuShorui(lines);
              currentLineWidth += calcWidth(prevChar || "");
            }
          }
          currentLineWidth += charWidth;
          lines[currentLineIndex] = (lines[currentLineIndex] || "") + _char2;
        }
        return lines.join("\n");
      }
    }, {
      key: "isBreakingSpace",
      value: function isBreakingSpace(_char3) {
        if (typeof _char3 !== "string") {
          return false;
        }
        return TEXT_METRICS.BreakingSpaces.indexOf(_char3.charCodeAt(0)) >= 0;
      }
    }, {
      key: "isNewline",
      value: function isNewline(_char4) {
        if (typeof _char4 !== "string") {
          return false;
        }
        return TEXT_METRICS.Newlines.indexOf(_char4.charCodeAt(0)) >= 0;
      }
    }, {
      key: "trimToBreakable",
      value: function trimToBreakable(prev) {
        var next = _toConsumableArray(prev);
        var prevLine = next[next.length - 2];
        var index4 = this.findBreakableIndex(prevLine);
        if (index4 === -1 || !prevLine) return next;
        var trimmedChar = prevLine.slice(index4, index4 + 1);
        var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
        var trimFrom = index4 + 1;
        var trimTo = index4 + (isTrimmedWithSpace ? 0 : 1);
        next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
        next[next.length - 2] = prevLine.slice(0, trimTo);
        return next;
      }
    }, {
      key: "canBreakInLastChar",
      value: function canBreakInLastChar(_char5) {
        if (_char5 && LATIN_REGEX.test(_char5)) return false;
        return true;
      }
    }, {
      key: "sumTextWidthByCache",
      value: function sumTextWidthByCache(text, cache3) {
        return text.split("").reduce(function(sum3, c5) {
          if (!cache3[c5]) throw Error("cannot count the word without cache");
          return sum3 + cache3[c5];
        }, 0);
      }
    }, {
      key: "findBreakableIndex",
      value: function findBreakableIndex(line4) {
        for (var i = line4.length - 1; i >= 0; i--) {
          if (!LATIN_REGEX.test(line4[i])) return i;
        }
        return -1;
      }
    }, {
      key: "getFromCache",
      value: function getFromCache(key, letterSpacing, cache3, context) {
        var width = cache3[key];
        if (typeof width !== "number") {
          var spacing = key.length * letterSpacing;
          var metrics = context.measureText(key);
          width = metrics.width + spacing;
          cache3[key] = width;
        }
        return width;
      }
    }]);
  }();
  var runtime = {};
  var geometryUpdaterFactory = function(_ref) {
    var rectUpdater = new RectUpdater();
    var polylineUpdater = new PolylineUpdater();
    return _ref = {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_ref, Shape.FRAGMENT, null), Shape.CIRCLE, new CircleUpdater()), Shape.ELLIPSE, new EllipseUpdater()), Shape.RECT, rectUpdater), Shape.IMAGE, rectUpdater), Shape.GROUP, new GroupUpdater()), Shape.LINE, new LineUpdater()), Shape.TEXT, new TextUpdater(runtime)), Shape.POLYLINE, polylineUpdater), Shape.POLYGON, polylineUpdater), _defineProperty2(_defineProperty2(_defineProperty2(_ref, Shape.PATH, new PathUpdater()), Shape.HTML, new HTMLUpdater()), Shape.MESH, null);
  }();
  var CSSPropertySyntaxFactory = function(_ref2) {
    var color2 = new CSSPropertyColor();
    var length5 = new CSSPropertyLengthOrPercentage();
    return _ref2 = {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_ref2, PropertySyntax.PERCENTAGE, null), PropertySyntax.NUMBER, new CSSPropertyNumber()), PropertySyntax.ANGLE, new CSSPropertyAngle()), PropertySyntax.DEFINED_PATH, new CSSPropertyClipPath()), PropertySyntax.PAINT, color2), PropertySyntax.COLOR, color2), PropertySyntax.FILTER, new CSSPropertyFilter()), PropertySyntax.LENGTH, length5), PropertySyntax.LENGTH_PERCENTAGE, length5), PropertySyntax.LENGTH_PERCENTAGE_12, new CSSPropertyLengthOrPercentage12()), _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_ref2, PropertySyntax.LENGTH_PERCENTAGE_14, new CSSPropertyLengthOrPercentage14()), PropertySyntax.COORDINATE, new CSSPropertyLengthOrPercentage()), PropertySyntax.OFFSET_DISTANCE, new CSSPropertyOffsetDistance()), PropertySyntax.OPACITY_VALUE, new CSSPropertyOpacity()), PropertySyntax.PATH, new CSSPropertyPath()), PropertySyntax.LIST_OF_POINTS, new CSSPropertyPoints()), PropertySyntax.SHADOW_BLUR, new CSSPropertyShadowBlur()), PropertySyntax.TEXT, new CSSPropertyText()), PropertySyntax.TEXT_TRANSFORM, new CSSPropertyTextTransform()), PropertySyntax.TRANSFORM, new CSSPropertyTransform()), _defineProperty2(_defineProperty2(_defineProperty2(_ref2, PropertySyntax.TRANSFORM_ORIGIN, new CSSPropertyTransformOrigin()), PropertySyntax.Z_INDEX, new CSSPropertyZIndex()), PropertySyntax.MARKER, new CSSPropertyMarker());
  }();
  var getGlobalThis = function getGlobalThis2() {
    if (typeof globalThis !== "undefined") return globalThis;
    if (typeof self !== "undefined") return self;
    if (typeof window !== "undefined") return window;
    if (typeof global !== "undefined") return global;
    return {};
  };
  runtime.CameraContribution = Camera;
  runtime.AnimationTimeline = null;
  runtime.EasingFunction = null;
  runtime.offscreenCanvasCreator = new OffscreenCanvasCreator();
  runtime.sceneGraphSelector = new DefaultSceneGraphSelector();
  runtime.sceneGraphService = new DefaultSceneGraphService(runtime);
  runtime.textService = new TextService(runtime);
  runtime.geometryUpdaterFactory = geometryUpdaterFactory;
  runtime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;
  runtime.styleValueRegistry = new DefaultStyleValueRegistry(runtime);
  runtime.layoutRegistry = null;
  runtime.globalThis = getGlobalThis();
  runtime.enableStyleSyntax = true;
  runtime.enableSizeAttenuation = false;
  var entityCounter = 0;
  var insertedEvent = new MutationEvent(ElementEvent.INSERTED, null, "", "", "", 0, "", "");
  var removedEvent = new MutationEvent(ElementEvent.REMOVED, null, "", "", "", 0, "", "");
  var destroyEvent = new CustomEvent2(ElementEvent.DESTROY);
  var Element2 = /* @__PURE__ */ function(_Node) {
    function Element3() {
      var _this;
      _classCallCheck(this, Element3);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, Element3, [].concat(args));
      _this.entity = entityCounter++;
      _this.renderable = {
        bounds: void 0,
        boundsDirty: true,
        renderBounds: void 0,
        renderBoundsDirty: true,
        dirtyRenderBounds: void 0,
        dirty: false
      };
      _this.cullable = {
        strategy: Strategy.Standard,
        visibilityPlaneMask: -1,
        visible: true,
        enable: true
      };
      _this.transformable = {
        dirtyFlag: false,
        localDirtyFlag: false,
        frozen: false,
        localPosition: [0, 0, 0],
        localRotation: [0, 0, 0, 1],
        localScale: [1, 1, 1],
        localTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        localSkew: [0, 0],
        position: [0, 0, 0],
        rotation: [0, 0, 0, 1],
        scaling: [1, 1, 1],
        worldTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        origin: [0, 0, 0]
      };
      _this.sortable = {
        dirty: false,
        sorted: void 0,
        renderOrder: 0,
        dirtyChildren: [],
        dirtyReason: void 0
      };
      _this.geometry = {
        contentBounds: void 0,
        renderBounds: void 0,
        dirty: true
      };
      _this.rBushNode = {
        aabb: void 0
      };
      _this.namespaceURI = "g";
      _this.scrollLeft = 0;
      _this.scrollTop = 0;
      _this.clientTop = 0;
      _this.clientLeft = 0;
      _this.destroyed = false;
      _this.style = {};
      _this.computedStyle = {};
      _this.parsedStyle = {
        // opacity: '',
        // fillOpacity: '',
        // strokeOpacity: '',
        // transformOrigin: '',
        // visibility: '',
        // pointerEvents: '',
        // lineWidth: '',
        // lineCap: '',
        // lineJoin: '',
        // increasedLineWidthForHitTesting: '',
        // fontSize: '',
        // fontFamily: '',
        // fontStyle: '',
        // fontWeight: '',
        // fontVariant: '',
        // textAlign: '',
        // textBaseline: '',
        // textTransform: '',
      };
      _this.attributes = {};
      return _this;
    }
    _inherits(Element3, _Node);
    return _createClass(Element3, [{
      key: "className",
      get: (
        /**
         * used with `getElementById()`
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/id
         */
        /**
         * used in `getElementsByClassName`
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
         */
        function get2() {
          return this.getAttribute("class") || "";
        }
      ),
      set: function set8(className2) {
        this.setAttribute("class", className2);
      }
      /**
       * used in `getElementsByName`
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByName
       */
    }, {
      key: "classList",
      get: (
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
         */
        function get2() {
          return this.className.split(" ").filter(function(c5) {
            return c5 !== "";
          });
        }
      )
    }, {
      key: "tagName",
      get: function get2() {
        return this.nodeName;
      }
    }, {
      key: "children",
      get: function get2() {
        return this.childNodes;
      }
    }, {
      key: "childElementCount",
      get: function get2() {
        return this.childNodes.length;
      }
    }, {
      key: "firstElementChild",
      get: function get2() {
        return this.firstChild;
      }
    }, {
      key: "lastElementChild",
      get: function get2() {
        return this.lastChild;
      }
    }, {
      key: "parentElement",
      get: function get2() {
        return this.parentNode;
      }
    }, {
      key: "nextSibling",
      get: function get2() {
        if (this.parentNode) {
          var index4 = this.parentNode.childNodes.indexOf(this);
          return this.parentNode.childNodes[index4 + 1] || null;
        }
        return null;
      }
    }, {
      key: "previousSibling",
      get: function get2() {
        if (this.parentNode) {
          var index4 = this.parentNode.childNodes.indexOf(this);
          return this.parentNode.childNodes[index4 - 1] || null;
        }
        return null;
      }
    }, {
      key: "cloneNode",
      value: function cloneNode(deep2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "appendChild",
      value: function appendChild(child, index4) {
        var _this$ownerDocument;
        if (child.destroyed) {
          throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);
        }
        runtime.sceneGraphService.attach(child, this, index4);
        if ((_this$ownerDocument = this.ownerDocument) !== null && _this$ownerDocument !== void 0 && _this$ownerDocument.defaultView) {
          if (!isInFragment(this) && child.nodeName === Shape.FRAGMENT) {
            this.ownerDocument.defaultView.mountFragment(child);
          } else {
            this.ownerDocument.defaultView.mountChildren(child);
          }
        }
        if (this.isMutationObserved) {
          insertedEvent.relatedNode = this;
          child.dispatchEvent(insertedEvent);
        }
        return child;
      }
    }, {
      key: "insertBefore",
      value: function insertBefore(newChild, refChild) {
        if (!refChild) {
          this.appendChild(newChild);
        } else {
          if (newChild.parentElement) {
            newChild.parentElement.removeChild(newChild);
          }
          var index4 = this.childNodes.indexOf(refChild);
          if (index4 === -1) {
            this.appendChild(newChild);
          } else {
            this.appendChild(newChild, index4);
          }
        }
        return newChild;
      }
    }, {
      key: "replaceChild",
      value: function replaceChild2(newChild, oldChild) {
        var index4 = this.childNodes.indexOf(oldChild);
        this.removeChild(oldChild);
        this.appendChild(newChild, index4);
        return oldChild;
      }
    }, {
      key: "removeChild",
      value: function removeChild(child) {
        var _child$ownerDocument;
        removedEvent.relatedNode = this;
        child.dispatchEvent(removedEvent);
        if ((_child$ownerDocument = child.ownerDocument) !== null && _child$ownerDocument !== void 0 && _child$ownerDocument.defaultView) {
          child.ownerDocument.defaultView.unmountChildren(child);
        }
        runtime.sceneGraphService.detach(child);
        return child;
      }
      /**
       * Remove all children which can be appended to its original parent later again.
       */
    }, {
      key: "removeChildren",
      value: function removeChildren() {
        for (var i = this.childNodes.length - 1; i >= 0; i--) {
          var child = this.childNodes[i];
          this.removeChild(child);
        }
      }
      /**
       * Recursively destroy all children which can not be appended to its original parent later again.
       */
    }, {
      key: "destroyChildren",
      value: function destroyChildren() {
        for (var i = this.childNodes.length - 1; i >= 0; i--) {
          var child = this.childNodes[i];
          if (child.childNodes.length > 0) {
            child.destroyChildren();
          }
          child.destroy();
        }
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/matches
       */
    }, {
      key: "matches",
      value: function matches2(selector) {
        return runtime.sceneGraphService.matches(selector, this);
      }
    }, {
      key: "getElementById",
      value: function getElementById(id5) {
        return runtime.sceneGraphService.querySelector("#".concat(id5), this);
      }
    }, {
      key: "getElementsByName",
      value: function getElementsByName(name2) {
        return runtime.sceneGraphService.querySelectorAll('[name="'.concat(name2, '"]'), this);
      }
    }, {
      key: "getElementsByClassName",
      value: function getElementsByClassName(className2) {
        return runtime.sceneGraphService.querySelectorAll(".".concat(className2), this);
      }
    }, {
      key: "getElementsByTagName",
      value: function getElementsByTagName(tagName) {
        return runtime.sceneGraphService.querySelectorAll(tagName, this);
      }
    }, {
      key: "querySelector",
      value: function querySelector(selectors) {
        return runtime.sceneGraphService.querySelector(selectors, this);
      }
    }, {
      key: "querySelectorAll",
      value: function querySelectorAll(selectors) {
        return runtime.sceneGraphService.querySelectorAll(selectors, this);
      }
      /**
       * should traverses the element and its parents (heading toward the document root)
       * until it finds a node that matches the specified CSS selector.
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/closest
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/closest#polyfill
       */
    }, {
      key: "closest",
      value: function closest2(selectors) {
        var el = this;
        do {
          if (runtime.sceneGraphService.matches(selectors, el)) return el;
          el = el.parentElement;
        } while (el !== null);
        return null;
      }
      /**
       * search in scene group, but should not include itself
       */
    }, {
      key: "find",
      value: function find7(filter2) {
        var _this2 = this;
        var target = null;
        this.forEach(function(object) {
          if (object !== _this2 && filter2(object)) {
            target = object;
            return false;
          }
          return true;
        });
        return target;
      }
    }, {
      key: "findAll",
      value: function findAll(filter2) {
        var _this3 = this;
        var objects = [];
        this.forEach(function(object) {
          if (object !== _this3 && filter2(object)) {
            objects.push(object);
          }
        });
        return objects;
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/after
       */
    }, {
      key: "after",
      value: function after() {
        var _this4 = this;
        if (this.parentNode) {
          var index4 = this.parentNode.childNodes.indexOf(this);
          for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            nodes[_key2] = arguments[_key2];
          }
          nodes.forEach(function(node, i) {
            var _this4$parentNode;
            return (_this4$parentNode = _this4.parentNode) === null || _this4$parentNode === void 0 ? void 0 : _this4$parentNode.appendChild(node, index4 + i + 1);
          });
        }
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/before
       */
    }, {
      key: "before",
      value: function before() {
        if (this.parentNode) {
          var _ref;
          var index4 = this.parentNode.childNodes.indexOf(this);
          for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            nodes[_key3] = arguments[_key3];
          }
          var first3 = nodes[0], rest = nodes.slice(1);
          this.parentNode.appendChild(first3, index4);
          (_ref = first3).after.apply(_ref, _toConsumableArray(rest));
        }
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceWith
       */
    }, {
      key: "replaceWith",
      value: function replaceWith() {
        this.after.apply(this, arguments);
        this.remove();
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/append
       */
    }, {
      key: "append",
      value: function append3() {
        var _this5 = this;
        for (var _len4 = arguments.length, nodes = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          nodes[_key4] = arguments[_key4];
        }
        nodes.forEach(function(node) {
          return _this5.appendChild(node);
        });
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/prepend
       */
    }, {
      key: "prepend",
      value: function prepend() {
        var _this6 = this;
        for (var _len5 = arguments.length, nodes = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          nodes[_key5] = arguments[_key5];
        }
        nodes.forEach(function(node, i) {
          return _this6.appendChild(node, i);
        });
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/replaceChildren
       */
    }, {
      key: "replaceChildren",
      value: function replaceChildren2() {
        while (this.childNodes.length && this.firstChild) {
          this.removeChild(this.firstChild);
        }
        this.append.apply(this, arguments);
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/remove
       */
    }, {
      key: "remove",
      value: function remove() {
        if (this.parentNode) {
          return this.parentNode.removeChild(this);
        }
        return this;
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        this.destroyChildren();
        this.dispatchEvent(destroyEvent);
        this.remove();
        this.emitter.removeAllListeners();
        this.destroyed = true;
      }
    }, {
      key: "getGeometryBounds",
      value: function getGeometryBounds() {
        return runtime.sceneGraphService.getGeometryBounds(this);
      }
    }, {
      key: "getRenderBounds",
      value: function getRenderBounds() {
        return runtime.sceneGraphService.getBounds(this, true);
      }
      /**
       * get bounds in world space, account for children
       */
    }, {
      key: "getBounds",
      value: function getBounds2() {
        return runtime.sceneGraphService.getBounds(this);
      }
      /**
       * get bounds in local space, account for children
       */
    }, {
      key: "getLocalBounds",
      value: function getLocalBounds2() {
        return runtime.sceneGraphService.getLocalBounds(this);
      }
      /**
       * account for context's bounds in client space,
       * but not accounting for children
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect
       */
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        return runtime.sceneGraphService.getBoundingClientRect(this);
      }
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getClientRects
       */
    }, {
      key: "getClientRects",
      value: function getClientRects() {
        return [this.getBoundingClientRect()];
      }
    }, {
      key: "computedStyleMap",
      value: (
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/computedStyleMap
         * eg. circle.computedStyleMap().get('fill');
         */
        function computedStyleMap() {
          return new Map(Object.entries(this.computedStyle));
        }
      )
    }, {
      key: "getAttributeNames",
      value: (
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNames
         */
        function getAttributeNames() {
          return Object.keys(this.attributes);
        }
      )
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute
       */
    }, {
      key: "getAttribute",
      value: function getAttribute2(name2) {
        if (typeof name2 === "symbol") {
          return void 0;
        }
        var value2 = this.attributes[name2];
        if (value2 === void 0) {
          return value2;
        }
        return value2;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttribute
       */
    }, {
      key: "hasAttribute",
      value: function hasAttribute2(qualifiedName) {
        return this.getAttributeNames().includes(qualifiedName);
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/hasAttributes
       */
    }, {
      key: "hasAttributes",
      value: function hasAttributes() {
        return !!this.getAttributeNames().length;
      }
      /**
       * should use removeAttribute() instead of setting the attribute value to null either directly or using setAttribute(). Many attributes will not behave as expected if you set them to null.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/removeAttribute
       */
    }, {
      key: "removeAttribute",
      value: function removeAttribute(attributeName) {
        this.setAttribute(attributeName, null);
        delete this.attributes[attributeName];
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/setAttribute
       */
    }, {
      key: "setAttribute",
      value: function setAttribute(attributeName, value2, force, memoize3) {
        this.attributes[attributeName] = value2;
      }
    }, {
      key: "getAttributeNS",
      value: function getAttributeNS(namespace, localName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "getAttributeNode",
      value: function getAttributeNode(qualifiedName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "getAttributeNodeNS",
      value: function getAttributeNodeNS(namespace, localName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "hasAttributeNS",
      value: function hasAttributeNS(namespace, localName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "removeAttributeNS",
      value: function removeAttributeNS(namespace, localName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "removeAttributeNode",
      value: function removeAttributeNode(attr2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "setAttributeNS",
      value: function setAttributeNS(namespace, qualifiedName, value2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "setAttributeNode",
      value: function setAttributeNode(attr2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "setAttributeNodeNS",
      value: function setAttributeNodeNS(attr2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "toggleAttribute",
      value: function toggleAttribute(qualifiedName, force) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }]);
  }(Node2);
  function isDisplayObject(value2) {
    return !!(value2 !== null && value2 !== void 0 && value2.nodeName);
  }
  var Proxy2 = runtime.globalThis.Proxy ? runtime.globalThis.Proxy : function() {
  };
  var attrModifiedEvent = new MutationEvent(ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);
  var $vec3 = vec3_exports.create();
  var $quat = quat_exports.create();
  var DisplayObject = /* @__PURE__ */ function(_Element) {
    function DisplayObject2(config2) {
      var _this;
      _classCallCheck(this, DisplayObject2);
      _this = _callSuper(this, DisplayObject2);
      _this.isCustomElement = false;
      _this.isMutationObserved = false;
      _this.activeAnimations = [];
      _this.config = config2;
      _this.id = config2.id || "";
      _this.name = config2.name || "";
      if (config2.className || config2["class"]) {
        _this.className = config2.className || config2["class"];
      }
      _this.nodeName = config2.type || Shape.GROUP;
      if (config2.initialParsedStyle) {
        Object.assign(_this.parsedStyle, config2.initialParsedStyle);
      }
      _this.initAttributes(config2.style);
      if (runtime.enableStyleSyntax) {
        _this.style = new Proxy2(
          // @ts-ignore
          {
            // ...this.attributes,
            setProperty: function setProperty(propertyName, value2) {
              _this.setAttribute(propertyName, value2);
            },
            getPropertyValue: function getPropertyValue(propertyName) {
              return _this.getAttribute(propertyName);
            },
            removeProperty: function removeProperty(propertyName) {
              _this.removeAttribute(propertyName);
            },
            item: function item() {
              return "";
            }
          },
          {
            get: function get2(target, name2) {
              if (target[name2] !== void 0) {
                return target[name2];
              }
              return _this.getAttribute(name2);
            },
            set: function set8(_2, prop, value2) {
              _this.setAttribute(prop, value2);
              return true;
            }
          }
        );
      }
      return _this;
    }
    _inherits(DisplayObject2, _Element);
    return _createClass(DisplayObject2, [{
      key: "destroy",
      value: function destroy3() {
        _superPropGet(DisplayObject2, "destroy", this, 3)([]);
        this.getAnimations().forEach(function(animation) {
          animation.cancel();
        });
      }
    }, {
      key: "cloneNode",
      value: function cloneNode(deep2, customCloneFunc) {
        var clonedStyle = _objectSpread22({}, this.attributes);
        for (var attributeName in clonedStyle) {
          var attribute = clonedStyle[attributeName];
          if (isDisplayObject(attribute) && // share the same clipPath if possible
          attributeName !== "clipPath" && attributeName !== "offsetPath" && attributeName !== "textPath") {
            clonedStyle[attributeName] = attribute.cloneNode(deep2);
          }
          if (customCloneFunc) {
            clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
          }
        }
        var cloned = new this.constructor(_objectSpread22(_objectSpread22({}, this.config), {}, {
          style: clonedStyle
        }));
        cloned.setLocalTransform(this.getLocalTransform());
        if (deep2) {
          this.children.forEach(function(child) {
            if (!child.style.isMarker) {
              var clonedChild = child.cloneNode(deep2);
              cloned.appendChild(clonedChild);
            }
          });
        }
        return cloned;
      }
    }, {
      key: "initAttributes",
      value: function initAttributes() {
        var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var options = {
          forceUpdateGeometry: true
        };
        runtime.styleValueRegistry.processProperties(this, attributes, options);
        this.renderable.dirty = true;
      }
    }, {
      key: "setAttribute",
      value: function setAttribute(name2, value2) {
        var force = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        var memoize3 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
        if (is_undefined_default(value2)) {
          return;
        }
        if (force || value2 !== this.attributes[name2]) {
          this.internalSetAttribute(name2, value2, {
            memoize: memoize3
          });
          _superPropGet(DisplayObject2, "setAttribute", this, 3)([name2, value2]);
        }
      }
      /**
       * called when attributes get changed or initialized
       */
    }, {
      key: "internalSetAttribute",
      value: function internalSetAttribute(name2, value2) {
        var parseOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        var renderable = this.renderable;
        var oldValue = this.attributes[name2];
        var oldParsedValue = this.parsedStyle[name2];
        runtime.styleValueRegistry.processProperties(this, _defineProperty2({}, name2, value2), parseOptions);
        renderable.dirty = true;
        var newParsedValue = this.parsedStyle[name2];
        if (this.isConnected) {
          attrModifiedEvent.relatedNode = this;
          attrModifiedEvent.prevValue = oldValue;
          attrModifiedEvent.newValue = value2;
          attrModifiedEvent.attrName = name2;
          attrModifiedEvent.prevParsedValue = oldParsedValue;
          attrModifiedEvent.newParsedValue = newParsedValue;
          if (this.isMutationObserved) {
            this.dispatchEvent(attrModifiedEvent);
          } else {
            attrModifiedEvent.target = this;
            this.ownerDocument.defaultView.dispatchEvent(attrModifiedEvent, true);
          }
        }
        if (this.isCustomElement && this.isConnected || !this.isCustomElement) {
          var _attributeChangedCall, _ref;
          (_attributeChangedCall = (_ref = this).attributeChangedCallback) === null || _attributeChangedCall === void 0 || _attributeChangedCall.call(_ref, name2, oldValue, value2, oldParsedValue, newParsedValue);
        }
      }
      // #region transformable
      /**
       * returns different values than getBoundingClientRect(), as the latter returns value relative to the viewport
       * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement/getBBox
       *
       * FIXME: It is worth noting that getBBox responds to original untransformed values of a drawn object.
       * @see https://www.w3.org/Graphics/SVG/IG/resources/svgprimer.html#getBBox
       */
    }, {
      key: "getBBox",
      value: function getBBox2() {
        var aabb = this.getBounds();
        var _aabb$getMin = aabb.getMin(), _aabb$getMin2 = _slicedToArray(_aabb$getMin, 2), left2 = _aabb$getMin2[0], top = _aabb$getMin2[1];
        var _aabb$getMax = aabb.getMax(), _aabb$getMax2 = _slicedToArray(_aabb$getMax, 2), right2 = _aabb$getMax2[0], bottom = _aabb$getMax2[1];
        return new Rectangle(left2, top, right2 - left2, bottom - top);
      }
    }, {
      key: "setOrigin",
      value: function setOrigin(position) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        runtime.sceneGraphService.setOrigin(this, createVec3(position, y3, z, false));
        return this;
      }
    }, {
      key: "getOrigin",
      value: function getOrigin2() {
        return runtime.sceneGraphService.getOrigin(this);
      }
      /**
       * set position in world space
       */
    }, {
      key: "setPosition",
      value: function setPosition(position) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        runtime.sceneGraphService.setPosition(this, createVec3(position, y3, z, false));
        return this;
      }
      /**
       * set position in local space
       */
    }, {
      key: "setLocalPosition",
      value: function setLocalPosition(position) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        runtime.sceneGraphService.setLocalPosition(this, createVec3(position, y3, z, false));
        return this;
      }
      /**
       * translate in world space
       */
    }, {
      key: "translate",
      value: function translate5(position) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        runtime.sceneGraphService.translate(this, createVec3(position, y3, z, false));
        return this;
      }
      /**
       * translate in local space
       */
    }, {
      key: "translateLocal",
      value: function translateLocal(position) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        runtime.sceneGraphService.translateLocal(this, createVec3(position, y3, z, false));
        return this;
      }
    }, {
      key: "getPosition",
      value: function getPosition() {
        return runtime.sceneGraphService.getPosition(this);
      }
    }, {
      key: "getLocalPosition",
      value: function getLocalPosition() {
        return runtime.sceneGraphService.getLocalPosition(this);
      }
      /**
       * compatible with G 3.0
       *
       * scaling in local space
       * scale(10) = scale(10, 10, 10)
       *
       * we can't set scale in world space
       */
    }, {
      key: "scale",
      value: function scale10(scaling, y3, z) {
        return this.scaleLocal(scaling, y3, z);
      }
    }, {
      key: "scaleLocal",
      value: function scaleLocal(scaling, y3, z) {
        if (typeof scaling === "number") {
          y3 = y3 || scaling;
          z = z || scaling;
          scaling = createVec3(scaling, y3, z, false);
        }
        runtime.sceneGraphService.scaleLocal(this, scaling);
        return this;
      }
      /**
       * set scaling in local space
       */
    }, {
      key: "setLocalScale",
      value: function setLocalScale(scaling, y3, z) {
        if (typeof scaling === "number") {
          y3 = y3 || scaling;
          z = z || scaling;
          scaling = createVec3(scaling, y3, z, false);
        }
        runtime.sceneGraphService.setLocalScale(this, scaling);
        return this;
      }
      /**
       * get scaling in local space
       */
    }, {
      key: "getLocalScale",
      value: function getLocalScale() {
        return runtime.sceneGraphService.getLocalScale(this);
      }
      /**
       * get scaling in world space
       */
    }, {
      key: "getScale",
      value: function getScale() {
        return runtime.sceneGraphService.getScale(this);
      }
      /**
       * only return degrees of Z axis in world space
       */
    }, {
      key: "getEulerAngles",
      value: function getEulerAngles() {
        var _getEuler = getEuler($vec3, runtime.sceneGraphService.getWorldTransform(this)), _getEuler2 = _slicedToArray(_getEuler, 3), ez = _getEuler2[2];
        return rad2deg(ez);
      }
      /**
       * only return degrees of Z axis in local space
       */
    }, {
      key: "getLocalEulerAngles",
      value: function getLocalEulerAngles() {
        var _getEuler3 = getEuler($vec3, runtime.sceneGraphService.getLocalRotation(this)), _getEuler4 = _slicedToArray(_getEuler3, 3), ez = _getEuler4[2];
        return rad2deg(ez);
      }
      /**
       * set euler angles(degrees) in world space
       */
    }, {
      key: "setEulerAngles",
      value: function setEulerAngles(z) {
        runtime.sceneGraphService.setEulerAngles(this, 0, 0, z);
        return this;
      }
      /**
       * set euler angles(degrees) in local space
       */
    }, {
      key: "setLocalEulerAngles",
      value: function setLocalEulerAngles(z) {
        runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);
        return this;
      }
    }, {
      key: "rotateLocal",
      value: function rotateLocal(x3, y3, z) {
        if (isNil(y3) && isNil(z)) {
          runtime.sceneGraphService.rotateLocal(this, 0, 0, x3);
        } else {
          runtime.sceneGraphService.rotateLocal(this, x3, y3, z);
        }
        return this;
      }
    }, {
      key: "rotate",
      value: function rotate5(x3, y3, z) {
        if (isNil(y3) && isNil(z)) {
          runtime.sceneGraphService.rotate(this, 0, 0, x3);
        } else {
          runtime.sceneGraphService.rotate(this, x3, y3, z);
        }
        return this;
      }
    }, {
      key: "setRotation",
      value: function setRotation(rotation, y3, z, w) {
        runtime.sceneGraphService.setRotation(this, rotation, y3, z, w);
        return this;
      }
    }, {
      key: "setLocalRotation",
      value: function setLocalRotation(rotation, y3, z, w) {
        runtime.sceneGraphService.setLocalRotation(this, rotation, y3, z, w);
        return this;
      }
    }, {
      key: "setLocalSkew",
      value: function setLocalSkew(skew2, y3) {
        runtime.sceneGraphService.setLocalSkew(this, skew2, y3);
        return this;
      }
    }, {
      key: "getRotation",
      value: function getRotation2() {
        return runtime.sceneGraphService.getRotation(this);
      }
    }, {
      key: "getLocalRotation",
      value: function getLocalRotation() {
        return runtime.sceneGraphService.getLocalRotation(this);
      }
    }, {
      key: "getLocalSkew",
      value: function getLocalSkew() {
        return runtime.sceneGraphService.getLocalSkew(this);
      }
    }, {
      key: "getLocalTransform",
      value: function getLocalTransform() {
        return runtime.sceneGraphService.getLocalTransform(this);
      }
    }, {
      key: "getWorldTransform",
      value: function getWorldTransform() {
        return runtime.sceneGraphService.getWorldTransform(this);
      }
    }, {
      key: "setLocalTransform",
      value: function setLocalTransform(transform) {
        runtime.sceneGraphService.setLocalTransform(this, transform);
        return this;
      }
    }, {
      key: "resetLocalTransform",
      value: function resetLocalTransform() {
        runtime.sceneGraphService.resetLocalTransform(this);
      }
      // #endregion transformable
      // #region animatable
      /**
       * returns an array of all Animation objects affecting this element
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/getAnimations
       */
    }, {
      key: "getAnimations",
      value: function getAnimations() {
        return this.activeAnimations;
      }
      /**
       * create an animation with WAAPI
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/animate
       */
    }, {
      key: "animate",
      value: function animate2(keyframes, options) {
        var _this$ownerDocument;
        var timeline = (_this$ownerDocument = this.ownerDocument) === null || _this$ownerDocument === void 0 ? void 0 : _this$ownerDocument.timeline;
        if (timeline) {
          return timeline.play(this, keyframes, options);
        }
        return null;
      }
      // #endregion animatable
      // #region visible
      /**
       * shortcut for Used value of `visibility`
       */
    }, {
      key: "isVisible",
      value: function isVisible() {
        var _this$parsedStyle;
        return ((_this$parsedStyle = this.parsedStyle) === null || _this$parsedStyle === void 0 ? void 0 : _this$parsedStyle.visibility) !== "hidden";
      }
    }, {
      key: "interactive",
      get: function get2() {
        return this.isInteractive();
      },
      set: function set8(b) {
        this.style.pointerEvents = b ? "auto" : "none";
      }
    }, {
      key: "isInteractive",
      value: function isInteractive() {
        var _this$parsedStyle2;
        return ((_this$parsedStyle2 = this.parsedStyle) === null || _this$parsedStyle2 === void 0 ? void 0 : _this$parsedStyle2.pointerEvents) !== "none";
      }
    }, {
      key: "isCulled",
      value: function isCulled() {
        return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
      }
      /**
       * bring to front in current group
       */
    }, {
      key: "toFront",
      value: function toFront() {
        if (this.parentNode) {
          this.style.zIndex = Math.max.apply(Math, _toConsumableArray(this.parentNode.children.map(function(child) {
            return Number(child.style.zIndex);
          }))) + 1;
        }
        return this;
      }
      /**
       * send to back in current group
       */
    }, {
      key: "toBack",
      value: function toBack() {
        if (this.parentNode) {
          this.style.zIndex = Math.min.apply(Math, _toConsumableArray(this.parentNode.children.map(function(child) {
            return Number(child.style.zIndex);
          }))) - 1;
        }
        return this;
      }
      // #endregion visible
      // #region deprecated
      /**
       * compatible with G 3.0
       * @alias object.config
       * @deprecated
       */
    }, {
      key: "getConfig",
      value: function getConfig2() {
        return this.config;
      }
      /**
       * @alias style
       * @example
       * circle.style.r = 10;
       * const r = circle.style;
       * @deprecated
       */
    }, {
      key: "attr",
      value: function attr2() {
        var _this2 = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var name2 = args[0], value2 = args[1];
        if (!name2) {
          return this.attributes;
        }
        if (is_object_default(name2)) {
          Object.keys(name2).forEach(function(key) {
            _this2.setAttribute(key, name2[key]);
          });
          return this;
        }
        if (args.length === 2) {
          this.setAttribute(name2, value2);
          return this;
        }
        return this.attributes[name2];
      }
      /**
       * return 3x3 matrix in world space
       * @deprecated
       */
    }, {
      key: "getMatrix",
      value: function getMatrix(transformMat44) {
        var transform = transformMat44 || this.getWorldTransform();
        var _mat4$getTranslation = mat4_exports.getTranslation($vec3, transform), _mat4$getTranslation2 = _slicedToArray(_mat4$getTranslation, 2), tx = _mat4$getTranslation2[0], ty = _mat4$getTranslation2[1];
        var _mat4$getScaling = mat4_exports.getScaling($vec3, transform), _mat4$getScaling2 = _slicedToArray(_mat4$getScaling, 2), sx = _mat4$getScaling2[0], sy = _mat4$getScaling2[1];
        var rotation = mat4_exports.getRotation($quat, transform);
        var _getEuler5 = getEuler($vec3, rotation), _getEuler6 = _slicedToArray(_getEuler5, 3), eux = _getEuler6[0], euz = _getEuler6[2];
        return fromRotationTranslationScale2(eux || euz, tx, ty, sx, sy);
      }
      /**
       * return 3x3 matrix in local space
       * @deprecated
       */
    }, {
      key: "getLocalMatrix",
      value: function getLocalMatrix() {
        return this.getMatrix(this.getLocalTransform());
      }
      /**
       * set 3x3 matrix in world space
       * @deprecated
       */
    }, {
      key: "setMatrix",
      value: function setMatrix(mat) {
        var _decompose = decompose(mat), _decompose2 = _slicedToArray(_decompose, 5), tx = _decompose2[0], ty = _decompose2[1], scalingX = _decompose2[2], scalingY = _decompose2[3], angle4 = _decompose2[4];
        this.setEulerAngles(angle4).setPosition(tx, ty).setLocalScale(scalingX, scalingY);
      }
      /**
       * set 3x3 matrix in local space
       * @deprecated
       */
    }, {
      key: "setLocalMatrix",
      value: function setLocalMatrix(mat) {
        var _decompose3 = decompose(mat), _decompose4 = _slicedToArray(_decompose3, 5), tx = _decompose4[0], ty = _decompose4[1], scalingX = _decompose4[2], scalingY = _decompose4[3], angle4 = _decompose4[4];
        this.setLocalEulerAngles(angle4).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);
      }
      /**
       * Use `visibility: visible` instead.
       * @deprecated
       */
    }, {
      key: "show",
      value: function show3() {
        this.forEach(function(object) {
          object.style.visibility = "visible";
        });
      }
      /**
       * Use `visibility: hidden` instead.
       * @deprecated
       */
    }, {
      key: "hide",
      value: function hide3() {
        this.forEach(function(object) {
          object.style.visibility = "hidden";
        });
      }
      /**
       * Use `childElementCount` instead.
       * @deprecated
       */
    }, {
      key: "getCount",
      value: function getCount() {
        return this.childElementCount;
      }
      /**
       * Use `parentElement` instead.
       * @deprecated
       */
    }, {
      key: "getParent",
      value: function getParent() {
        return this.parentElement;
      }
      /**
       * Use `children` instead.
       * @deprecated
       */
    }, {
      key: "getChildren",
      value: function getChildren() {
        return this.children;
      }
      /**
       * Use `firstElementChild` instead.
       * @deprecated
       */
    }, {
      key: "getFirst",
      value: function getFirst() {
        return this.firstElementChild;
      }
      /**
       * Use `lastElementChild` instead.
       * @deprecated
       */
    }, {
      key: "getLast",
      value: function getLast() {
        return this.lastElementChild;
      }
      /**
       * Use `this.children[index]` instead.
       * @deprecated
       */
    }, {
      key: "getChildByIndex",
      value: function getChildByIndex(index4) {
        return this.children[index4] || null;
      }
      /**
       * Use `appendChild` instead.
       * @deprecated
       */
    }, {
      key: "add",
      value: function add11(child, index4) {
        return this.appendChild(child, index4);
      }
      /**
       * @deprecated
       */
    }, {
      key: "set",
      value: function set8(name2, value2) {
        this.config[name2] = value2;
      }
      /**
       * @deprecated
       */
    }, {
      key: "get",
      value: function get2(name2) {
        return this.config[name2];
      }
      /**
       * Use `setPosition` instead.
       * @deprecated
       */
    }, {
      key: "moveTo",
      value: function moveTo(position) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        this.setPosition(position, y3, z);
        return this;
      }
      /**
       * Use `setPosition` instead.
       * @deprecated
       */
    }, {
      key: "move",
      value: function move(position) {
        var y3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        var z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
        this.setPosition(position, y3, z);
        return this;
      }
      /**
       * Use `this.style.zIndex` instead.
       * @deprecated
       */
    }, {
      key: "setZIndex",
      value: function setZIndex(zIndex) {
        this.style.zIndex = zIndex;
        return this;
      }
      // #endregion deprecated
    }]);
  }(Element2);
  DisplayObject.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "display", "draggable", "droppable", "fill", "fillOpacity", "fillRule", "filter", "increasedLineWidthForHitTesting", "lineCap", "lineDash", "lineDashOffset", "lineJoin", "lineWidth", "miterLimit", "hitArea", "offsetDistance", "offsetPath", "offsetX", "offsetY", "opacity", "pointerEvents", "shadowColor", "shadowType", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "stroke", "strokeOpacity", "strokeWidth", "strokeLinecap", "strokeLineJoin", "strokeDasharray", "strokeDashoffset", "transform", "transformOrigin", "textTransform", "visibility", "zIndex"]);
  var Circle = /* @__PURE__ */ function(_DisplayObject) {
    function Circle3() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Circle3);
      return _callSuper(this, Circle3, [_objectSpread22({
        type: Shape.CIRCLE
      }, options)]);
    }
    _inherits(Circle3, _DisplayObject);
    return _createClass(Circle3);
  }(DisplayObject);
  Circle.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["cx", "cy", "cz", "r", "isBillboard", "isSizeAttenuation"]));
  var _excluded$6 = ["style"];
  var CustomElement = /* @__PURE__ */ function(_DisplayObject) {
    function CustomElement2() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded$6);
      _classCallCheck(this, CustomElement2);
      _this = _callSuper(this, CustomElement2, [_objectSpread22({
        style
      }, rest)]);
      _this.isCustomElement = true;
      return _this;
    }
    _inherits(CustomElement2, _DisplayObject);
    return _createClass(CustomElement2);
  }(DisplayObject);
  CustomElement.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
  var Ellipse = /* @__PURE__ */ function(_DisplayObject) {
    function Ellipse2() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Ellipse2);
      return _callSuper(this, Ellipse2, [_objectSpread22({
        type: Shape.ELLIPSE
      }, options)]);
    }
    _inherits(Ellipse2, _DisplayObject);
    return _createClass(Ellipse2);
  }(DisplayObject);
  Ellipse.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["cx", "cy", "cz", "rx", "ry", "isBillboard", "isSizeAttenuation"]));
  var Fragment = /* @__PURE__ */ function(_DisplayObject) {
    function Fragment2() {
      _classCallCheck(this, Fragment2);
      return _callSuper(this, Fragment2, [{
        type: Shape.FRAGMENT
      }]);
    }
    _inherits(Fragment2, _DisplayObject);
    return _createClass(Fragment2);
  }(DisplayObject);
  Fragment.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className"]);
  var Group2 = /* @__PURE__ */ function(_DisplayObject) {
    function Group3() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Group3);
      return _callSuper(this, Group3, [_objectSpread22({
        type: Shape.GROUP
      }, options)]);
    }
    _inherits(Group3, _DisplayObject);
    return _createClass(Group3);
  }(DisplayObject);
  Group2.PARSED_STYLE_LIST = /* @__PURE__ */ new Set(["class", "className", "clipPath", "cursor", "draggable", "droppable", "opacity", "pointerEvents", "transform", "transformOrigin", "zIndex", "visibility"]);
  var _excluded$5 = ["style"];
  var HTML = /* @__PURE__ */ function(_DisplayObject) {
    function HTML2() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded$5);
      _classCallCheck(this, HTML2);
      _this = _callSuper(this, HTML2, [_objectSpread22({
        type: Shape.HTML,
        style
      }, rest)]);
      _this.cullable.enable = false;
      return _this;
    }
    _inherits(HTML2, _DisplayObject);
    return _createClass(HTML2, [{
      key: "getDomElement",
      value: function getDomElement() {
        return this.parsedStyle.$el;
      }
      /**
       * override with $el.getBoundingClientRect
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect
       *
       * ! The calculation logic of the html element should be consistent with that of the canvas element
       */
      // getBoundingClientRect(): Rectangle {
      //   if (this.parsedStyle.$el) {
      //     return this.parsedStyle.$el.getBoundingClientRect();
      //   } else {
      //     const { x, y, width, height } = this.parsedStyle;
      //     return new Rectangle(x, y, width, height);
      //   }
      // }
    }, {
      key: "getClientRects",
      value: function getClientRects() {
        return [this.getBoundingClientRect()];
      }
      // getBounds() {
      //   const clientRect = this.getBoundingClientRect();
      //   // calc context's offset
      //   // @ts-ignore
      //   const canvasRect = this.ownerDocument?.defaultView
      //     ?.getContextService()
      //     .getBoundingClientRect();
      //   const aabb = new AABB();
      //   const minX = clientRect.left - (canvasRect?.left || 0);
      //   const minY = clientRect.top - (canvasRect?.top || 0);
      //   aabb.setMinMax(
      //     [minX, minY, 0],
      //     [minX + clientRect.width, minY + clientRect.height, 0],
      //   );
      //   return aabb;
      // }
    }, {
      key: "getLocalBounds",
      value: function getLocalBounds2() {
        if (this.parentNode) {
          var parentInvert = mat4_exports.invert(mat4_exports.create(), this.parentNode.getWorldTransform());
          var bounds = this.getBounds();
          if (!AABB.isEmpty(bounds)) {
            var localBounds = new AABB();
            localBounds.setFromTransformedAABB(bounds, parentInvert);
            return localBounds;
          }
        }
        return this.getBounds();
      }
    }]);
  }(DisplayObject);
  HTML.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "$el", "innerHTML", "width", "height"]));
  var Image2 = /* @__PURE__ */ function(_DisplayObject) {
    function Image5() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Image5);
      return _callSuper(this, Image5, [_objectSpread22({
        type: Shape.IMAGE
      }, options)]);
    }
    _inherits(Image5, _DisplayObject);
    return _createClass(Image5);
  }(DisplayObject);
  Image2.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "src", "width", "height", "isBillboard", "billboardRotation", "isSizeAttenuation", "keepAspectRatio"]));
  var _excluded$4 = ["style"];
  var Line = /* @__PURE__ */ function(_DisplayObject) {
    function Line6() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded$4);
      _classCallCheck(this, Line6);
      _this = _callSuper(this, Line6, [_objectSpread22({
        type: Shape.LINE,
        style: _objectSpread22({
          x1: 0,
          y1: 0,
          x2: 0,
          y2: 0,
          z1: 0,
          z2: 0
        }, style)
      }, rest)]);
      _this.markerStartAngle = 0;
      _this.markerEndAngle = 0;
      var _this$parsedStyle = _this.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd;
      if (markerStart && isDisplayObject(markerStart)) {
        _this.markerStartAngle = markerStart.getLocalEulerAngles();
        _this.appendChild(markerStart);
      }
      if (markerEnd && isDisplayObject(markerEnd)) {
        _this.markerEndAngle = markerEnd.getLocalEulerAngles();
        _this.appendChild(markerEnd);
      }
      _this.transformMarker(true);
      _this.transformMarker(false);
      return _this;
    }
    _inherits(Line6, _DisplayObject);
    return _createClass(Line6, [{
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
        if (attrName === "x1" || attrName === "y1" || attrName === "x2" || attrName === "y2" || attrName === "markerStartOffset" || attrName === "markerEndOffset") {
          this.transformMarker(true);
          this.transformMarker(false);
        } else if (attrName === "markerStart") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerStartAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerStartAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(true);
          }
        } else if (attrName === "markerEnd") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerEndAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerEndAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(false);
          }
        }
      }
    }, {
      key: "transformMarker",
      value: function transformMarker(isStart) {
        var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, x12 = _this$parsedStyle2.x1, x22 = _this$parsedStyle2.x2, y12 = _this$parsedStyle2.y1, y22 = _this$parsedStyle2.y2;
        var marker = isStart ? markerStart : markerEnd;
        if (!marker || !isDisplayObject(marker)) {
          return;
        }
        var rad2 = 0;
        var x3;
        var y3;
        var ox;
        var oy;
        var offset3;
        var originalAngle;
        if (isStart) {
          ox = x12;
          oy = y12;
          x3 = x22 - x12;
          y3 = y22 - y12;
          offset3 = markerStartOffset || 0;
          originalAngle = this.markerStartAngle;
        } else {
          ox = x22;
          oy = y22;
          x3 = x12 - x22;
          y3 = y12 - y22;
          offset3 = markerEndOffset || 0;
          originalAngle = this.markerEndAngle;
        }
        rad2 = Math.atan2(y3, x3);
        marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
        marker.setLocalPosition(ox + Math.cos(rad2) * offset3, oy + Math.sin(rad2) * offset3);
      }
    }, {
      key: "getPoint",
      value: function getPoint(ratio) {
        var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var _this$parsedStyle3 = this.parsedStyle, x12 = _this$parsedStyle3.x1, y12 = _this$parsedStyle3.y1, x22 = _this$parsedStyle3.x2, y22 = _this$parsedStyle3.y2;
        var _linePointAt = pointAt$3(x12, y12, x22, y22, ratio), x3 = _linePointAt.x, y3 = _linePointAt.y;
        var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
        return new Point2(transformed[0], transformed[1]);
      }
    }, {
      key: "getPointAtLength",
      value: function getPointAtLength2(distance7) {
        var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        return this.getPoint(distance7 / this.getTotalLength(), inWorldSpace);
      }
    }, {
      key: "getTotalLength",
      value: function getTotalLength2() {
        var _this$parsedStyle4 = this.parsedStyle, x12 = _this$parsedStyle4.x1, y12 = _this$parsedStyle4.y1, x22 = _this$parsedStyle4.x2, y22 = _this$parsedStyle4.y2;
        return length$4(x12, y12, x22, y22);
      }
    }]);
  }(DisplayObject);
  Line.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x1", "y1", "x2", "y2", "z1", "z2", "isBillboard", "isSizeAttenuation", "markerStart", "markerEnd", "markerStartOffset", "markerEndOffset"]));
  var _excluded$3 = ["style"];
  var Path2 = /* @__PURE__ */ function(_DisplayObject) {
    function Path5() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded$3);
      _classCallCheck(this, Path5);
      _this = _callSuper(this, Path5, [_objectSpread22({
        type: Shape.PATH,
        style,
        initialParsedStyle: {
          miterLimit: 4,
          d: _objectSpread22({}, EMPTY_PARSED_PATH)
        }
      }, rest)]);
      _this.markerStartAngle = 0;
      _this.markerEndAngle = 0;
      _this.markerMidList = [];
      var _this$parsedStyle = _this.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
      if (markerStart && isDisplayObject(markerStart)) {
        _this.markerStartAngle = markerStart.getLocalEulerAngles();
        _this.appendChild(markerStart);
      }
      if (markerMid && isDisplayObject(markerMid)) {
        _this.placeMarkerMid(markerMid);
      }
      if (markerEnd && isDisplayObject(markerEnd)) {
        _this.markerEndAngle = markerEnd.getLocalEulerAngles();
        _this.appendChild(markerEnd);
      }
      _this.transformMarker(true);
      _this.transformMarker(false);
      return _this;
    }
    _inherits(Path5, _DisplayObject);
    return _createClass(Path5, [{
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
        if (attrName === "d") {
          this.transformMarker(true);
          this.transformMarker(false);
          this.placeMarkerMid(this.parsedStyle.markerMid);
        } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
          this.transformMarker(true);
          this.transformMarker(false);
        } else if (attrName === "markerStart") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerStartAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerStartAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(true);
          }
        } else if (attrName === "markerEnd") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerEndAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerEndAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(false);
          }
        } else if (attrName === "markerMid") {
          this.placeMarkerMid(newParsedValue);
        }
      }
    }, {
      key: "transformMarker",
      value: function transformMarker(isStart) {
        var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset;
        var marker = isStart ? markerStart : markerEnd;
        if (!marker || !isDisplayObject(marker)) {
          return;
        }
        var rad2 = 0;
        var x3;
        var y3;
        var ox;
        var oy;
        var offset3;
        var originalAngle;
        if (isStart) {
          var _this$getStartTangent = this.getStartTangent(), _this$getStartTangent2 = _slicedToArray(_this$getStartTangent, 2), p1 = _this$getStartTangent2[0], p2 = _this$getStartTangent2[1];
          ox = p2[0];
          oy = p2[1];
          x3 = p1[0] - p2[0];
          y3 = p1[1] - p2[1];
          offset3 = markerStartOffset || 0;
          originalAngle = this.markerStartAngle;
        } else {
          var _this$getEndTangent = this.getEndTangent(), _this$getEndTangent2 = _slicedToArray(_this$getEndTangent, 2), _p = _this$getEndTangent2[0], _p2 = _this$getEndTangent2[1];
          ox = _p2[0];
          oy = _p2[1];
          x3 = _p[0] - _p2[0];
          y3 = _p[1] - _p2[1];
          offset3 = markerEndOffset || 0;
          originalAngle = this.markerEndAngle;
        }
        rad2 = Math.atan2(y3, x3);
        marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
        marker.setLocalPosition(ox + Math.cos(rad2) * offset3, oy + Math.sin(rad2) * offset3);
      }
    }, {
      key: "placeMarkerMid",
      value: function placeMarkerMid(marker) {
        var segments = this.parsedStyle.d.segments;
        this.markerMidList.forEach(function(marker2) {
          marker2.remove();
        });
        if (marker && isDisplayObject(marker)) {
          for (var i = 1; i < segments.length - 1; i++) {
            var _segments$i$currentPo = _slicedToArray(segments[i].currentPoint, 2), ox = _segments$i$currentPo[0], oy = _segments$i$currentPo[1];
            var cloned = i === 1 ? marker : marker.cloneNode(true);
            this.markerMidList.push(cloned);
            this.appendChild(cloned);
            cloned.setLocalPosition(ox, oy);
          }
        }
      }
      /**
       * Returns the total length of the path.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getTotalLength
       */
    }, {
      key: "getTotalLength",
      value: function getTotalLength2() {
        return getOrCalculatePathTotalLength(this);
      }
      /**
       * Returns the point at a given distance along the path.
       * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGeometryElement/getPointAtLength
       */
    }, {
      key: "getPointAtLength",
      value: function getPointAtLength$1(distance7) {
        var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var absolutePath = this.parsedStyle.d.absolutePath;
        var _getPointAtLength2 = getPointAtLength(absolutePath, distance7), x3 = _getPointAtLength2.x, y3 = _getPointAtLength2.y;
        var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
        return new Point2(transformed[0], transformed[1]);
      }
      /**
       * Returns the point at a given ratio of the total length in path.
       */
    }, {
      key: "getPoint",
      value: function getPoint(ratio) {
        var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);
      }
      /**
       * Get start tangent vector
       */
    }, {
      key: "getStartTangent",
      value: function getStartTangent() {
        var segments = this.parsedStyle.d.segments;
        var result = [];
        if (segments.length > 1) {
          var startPoint = segments[0].currentPoint;
          var endPoint = segments[1].currentPoint;
          var tangent = segments[1].startTangent;
          result = [];
          if (tangent) {
            result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
            result.push([startPoint[0], startPoint[1]]);
          } else {
            result.push([endPoint[0], endPoint[1]]);
            result.push([startPoint[0], startPoint[1]]);
          }
        }
        return result;
      }
      /**
       * Get end tangent vector
       */
    }, {
      key: "getEndTangent",
      value: function getEndTangent() {
        var segments = this.parsedStyle.d.segments;
        var length5 = segments.length;
        var result = [];
        if (length5 > 1) {
          var startPoint = segments[length5 - 2].currentPoint;
          var endPoint = segments[length5 - 1].currentPoint;
          var tangent = segments[length5 - 1].endTangent;
          result = [];
          if (tangent) {
            result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
            result.push([endPoint[0], endPoint[1]]);
          } else {
            result.push([startPoint[0], startPoint[1]]);
            result.push([endPoint[0], endPoint[1]]);
          }
        }
        return result;
      }
    }]);
  }(DisplayObject);
  Path2.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["d", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard", "isSizeAttenuation"]));
  var _excluded$2 = ["style"];
  var Polygon = /* @__PURE__ */ function(_DisplayObject) {
    function Polygon4() {
      var _this;
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded$2);
      _classCallCheck(this, Polygon4);
      _this = _callSuper(this, Polygon4, [_objectSpread22({
        type: Shape.POLYGON,
        style,
        initialParsedStyle: {
          points: {
            points: [],
            totalLength: 0,
            segments: []
          },
          miterLimit: 4,
          isClosed: true
        }
      }, rest)]);
      _this.markerStartAngle = 0;
      _this.markerEndAngle = 0;
      _this.markerMidList = [];
      var _this$parsedStyle = _this.parsedStyle, markerStart = _this$parsedStyle.markerStart, markerEnd = _this$parsedStyle.markerEnd, markerMid = _this$parsedStyle.markerMid;
      if (markerStart && isDisplayObject(markerStart)) {
        _this.markerStartAngle = markerStart.getLocalEulerAngles();
        _this.appendChild(markerStart);
      }
      if (markerMid && isDisplayObject(markerMid)) {
        _this.placeMarkerMid(markerMid);
      }
      if (markerEnd && isDisplayObject(markerEnd)) {
        _this.markerEndAngle = markerEnd.getLocalEulerAngles();
        _this.appendChild(markerEnd);
      }
      _this.transformMarker(true);
      _this.transformMarker(false);
      return _this;
    }
    _inherits(Polygon4, _DisplayObject);
    return _createClass(Polygon4, [{
      key: "attributeChangedCallback",
      value: function attributeChangedCallback(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
        if (attrName === "points") {
          this.transformMarker(true);
          this.transformMarker(false);
          this.placeMarkerMid(this.parsedStyle.markerMid);
        } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
          this.transformMarker(true);
          this.transformMarker(false);
        } else if (attrName === "markerStart") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerStartAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerStartAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(true);
          }
        } else if (attrName === "markerEnd") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerEndAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerEndAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(false);
          }
        } else if (attrName === "markerMid") {
          this.placeMarkerMid(newParsedValue);
        }
      }
    }, {
      key: "transformMarker",
      value: function transformMarker(isStart) {
        var _this$parsedStyle2 = this.parsedStyle, markerStart = _this$parsedStyle2.markerStart, markerEnd = _this$parsedStyle2.markerEnd, markerStartOffset = _this$parsedStyle2.markerStartOffset, markerEndOffset = _this$parsedStyle2.markerEndOffset, P = _this$parsedStyle2.points;
        var _ref2 = P || {}, points = _ref2.points;
        var marker = isStart ? markerStart : markerEnd;
        if (!marker || !isDisplayObject(marker) || !points) {
          return;
        }
        var rad2 = 0;
        var x3;
        var y3;
        var ox;
        var oy;
        var offset3;
        var originalAngle;
        ox = points[0][0];
        oy = points[0][1];
        if (isStart) {
          x3 = points[1][0] - points[0][0];
          y3 = points[1][1] - points[0][1];
          offset3 = markerStartOffset || 0;
          originalAngle = this.markerStartAngle;
        } else {
          var length5 = points.length;
          if (!this.parsedStyle.isClosed) {
            ox = points[length5 - 1][0];
            oy = points[length5 - 1][1];
            x3 = points[length5 - 2][0] - points[length5 - 1][0];
            y3 = points[length5 - 2][1] - points[length5 - 1][1];
          } else {
            x3 = points[length5 - 1][0] - points[0][0];
            y3 = points[length5 - 1][1] - points[0][1];
          }
          offset3 = markerEndOffset || 0;
          originalAngle = this.markerEndAngle;
        }
        rad2 = Math.atan2(y3, x3);
        marker.setLocalEulerAngles(rad2 * 180 / Math.PI + originalAngle);
        marker.setLocalPosition(ox + Math.cos(rad2) * offset3, oy + Math.sin(rad2) * offset3);
      }
    }, {
      key: "placeMarkerMid",
      value: function placeMarkerMid(marker) {
        var P = this.parsedStyle.points;
        var _ref3 = P || {}, points = _ref3.points;
        this.markerMidList.forEach(function(marker2) {
          marker2.remove();
        });
        this.markerMidList = [];
        if (marker && isDisplayObject(marker) && points) {
          for (var i = 1; i < (this.parsedStyle.isClosed ? points.length : points.length - 1); i++) {
            var ox = points[i][0];
            var oy = points[i][1];
            var cloned = i === 1 ? marker : marker.cloneNode(true);
            this.markerMidList.push(cloned);
            this.appendChild(cloned);
            cloned.setLocalPosition(ox, oy);
          }
        }
      }
    }]);
  }(DisplayObject);
  Polygon.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isClosed", "isBillboard", "isSizeAttenuation"]));
  var _excluded$1 = ["style"];
  var Polyline = /* @__PURE__ */ function(_Polygon) {
    function Polyline2() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded$1);
      _classCallCheck(this, Polyline2);
      return _callSuper(this, Polyline2, [_objectSpread22({
        type: Shape.POLYLINE,
        style,
        initialParsedStyle: {
          points: {
            points: [],
            totalLength: 0,
            segments: []
          },
          miterLimit: 4,
          isClosed: false
        }
      }, rest)]);
    }
    _inherits(Polyline2, _Polygon);
    return _createClass(Polyline2, [{
      key: "getTotalLength",
      value: function getTotalLength2() {
        return getOrCalculatePolylineTotalLength(this);
      }
    }, {
      key: "getPointAtLength",
      value: function getPointAtLength2(distance7) {
        var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        return this.getPoint(distance7 / this.getTotalLength(), inWorldSpace);
      }
    }, {
      key: "getPoint",
      value: function getPoint(ratio) {
        var inWorldSpace = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var points = this.parsedStyle.points.points;
        if (this.parsedStyle.points.segments.length === 0) {
          var segments = [];
          var tempLength = 0;
          var segmentT;
          var segmentL;
          var totalLength = this.getTotalLength();
          points.forEach(function(p2, i) {
            if (points[i + 1]) {
              segmentT = [0, 0];
              segmentT[0] = tempLength / totalLength;
              segmentL = length$4(p2[0], p2[1], points[i + 1][0], points[i + 1][1]);
              tempLength += segmentL;
              segmentT[1] = tempLength / totalLength;
              segments.push(segmentT);
            }
          });
          this.parsedStyle.points.segments = segments;
        }
        var subt = 0;
        var index4 = 0;
        this.parsedStyle.points.segments.forEach(function(v, i) {
          if (ratio >= v[0] && ratio <= v[1]) {
            subt = (ratio - v[0]) / (v[1] - v[0]);
            index4 = i;
          }
        });
        var _linePointAt = pointAt$3(points[index4][0], points[index4][1], points[index4 + 1][0], points[index4 + 1][1], subt), x3 = _linePointAt.x, y3 = _linePointAt.y;
        var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
        return new Point2(transformed[0], transformed[1]);
      }
    }, {
      key: "getStartTangent",
      value: function getStartTangent() {
        var points = this.parsedStyle.points.points;
        var result = [];
        result.push([points[1][0], points[1][1]]);
        result.push([points[0][0], points[0][1]]);
        return result;
      }
    }, {
      key: "getEndTangent",
      value: function getEndTangent() {
        var points = this.parsedStyle.points.points;
        var l2 = points.length - 1;
        var result = [];
        result.push([points[l2 - 1][0], points[l2 - 1][1]]);
        result.push([points[l2][0], points[l2][1]]);
        return result;
      }
    }]);
  }(Polygon);
  Polyline.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(Polygon.PARSED_STYLE_LIST), ["points", "markerStart", "markerMid", "markerEnd", "markerStartOffset", "markerEndOffset", "isBillboard"]));
  var Rect = /* @__PURE__ */ function(_DisplayObject) {
    function Rect4() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Rect4);
      return _callSuper(this, Rect4, [_objectSpread22({
        type: Shape.RECT
      }, options)]);
    }
    _inherits(Rect4, _DisplayObject);
    return _createClass(Rect4);
  }(DisplayObject);
  Rect.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "width", "height", "isBillboard", "isSizeAttenuation", "radius"]));
  var _excluded2 = ["style"];
  var Text = /* @__PURE__ */ function(_DisplayObject) {
    function Text5() {
      var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, style = _ref.style, rest = _objectWithoutProperties2(_ref, _excluded2);
      _classCallCheck(this, Text5);
      return _callSuper(this, Text5, [_objectSpread22({
        type: Shape.TEXT,
        style: _objectSpread22({
          fill: "black"
        }, style)
      }, rest)]);
    }
    _inherits(Text5, _DisplayObject);
    return _createClass(Text5, [{
      key: "getComputedTextLength",
      value: function getComputedTextLength() {
        var _this$parsedStyle$met;
        this.getGeometryBounds();
        return ((_this$parsedStyle$met = this.parsedStyle.metrics) === null || _this$parsedStyle$met === void 0 ? void 0 : _this$parsedStyle$met.maxLineWidth) || 0;
      }
    }, {
      key: "getLineBoundingRects",
      value: function getLineBoundingRects() {
        var _this$parsedStyle$met2;
        this.getGeometryBounds();
        return ((_this$parsedStyle$met2 = this.parsedStyle.metrics) === null || _this$parsedStyle$met2 === void 0 ? void 0 : _this$parsedStyle$met2.lineMetrics) || [];
      }
    }, {
      key: "isOverflowing",
      value: function isOverflowing() {
        this.getGeometryBounds();
        return !!this.parsedStyle.isOverflowing;
      }
    }]);
  }(DisplayObject);
  Text.PARSED_STYLE_LIST = new Set([].concat(_toConsumableArray(DisplayObject.PARSED_STYLE_LIST), ["x", "y", "z", "isBillboard", "billboardRotation", "isSizeAttenuation", "text", "textAlign", "textBaseline", "fontStyle", "fontSize", "fontFamily", "fontWeight", "fontVariant", "lineHeight", "letterSpacing", "leading", "wordWrap", "wordWrapWidth", "maxLines", "textOverflow", "isOverflowing", "textPath", "textDecorationLine", "textDecorationColor", "textDecorationStyle", "textPathSide", "textPathStartOffset", "metrics", "dx", "dy"]));
  var CustomElementRegistry = /* @__PURE__ */ function() {
    function CustomElementRegistry2() {
      _classCallCheck(this, CustomElementRegistry2);
      this.registry = {};
      this.define(Shape.CIRCLE, Circle);
      this.define(Shape.ELLIPSE, Ellipse);
      this.define(Shape.RECT, Rect);
      this.define(Shape.IMAGE, Image2);
      this.define(Shape.LINE, Line);
      this.define(Shape.GROUP, Group2);
      this.define(Shape.PATH, Path2);
      this.define(Shape.POLYGON, Polygon);
      this.define(Shape.POLYLINE, Polyline);
      this.define(Shape.TEXT, Text);
      this.define(Shape.HTML, HTML);
    }
    return _createClass(CustomElementRegistry2, [{
      key: "define",
      value: function define2(name2, constructor) {
        this.registry[name2] = constructor;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/CustomElementRegistry/get
       */
    }, {
      key: "get",
      value: function get2(name2) {
        return this.registry[name2];
      }
    }]);
  }();
  var CSS2 = {
    /**
     * <number>
     * @see https://drafts.csswg.org/css-values-4/#number-value
     */
    number: function number2(n2) {
      return new CSSUnitValue(n2);
    },
    /**
     * <percentage>
     * @see https://drafts.csswg.org/css-values-4/#percentage-value
     */
    percent: function percent(n2) {
      return new CSSUnitValue(n2, "%");
    },
    /**
     * <length>
     */
    px: function px(n2) {
      return new CSSUnitValue(n2, "px");
    },
    /**
     * <length>
     */
    em: function em(n2) {
      return new CSSUnitValue(n2, "em");
    },
    rem: function rem(n2) {
      return new CSSUnitValue(n2, "rem");
    },
    /**
     * <angle>
     */
    deg: function deg(n2) {
      return new CSSUnitValue(n2, "deg");
    },
    /**
     * <angle>
     */
    grad: function grad(n2) {
      return new CSSUnitValue(n2, "grad");
    },
    /**
     * <angle>
     */
    rad: function rad(n2) {
      return new CSSUnitValue(n2, "rad");
    },
    /**
     * <angle>
     */
    turn: function turn(n2) {
      return new CSSUnitValue(n2, "turn");
    },
    /**
     * <time>
     */
    s: function s2(n2) {
      return new CSSUnitValue(n2, "s");
    },
    /**
     * <time>
     */
    ms: function ms(n2) {
      return new CSSUnitValue(n2, "ms");
    },
    /**
     * CSS Properties & Values API
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API
     * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
     */
    registerProperty: function registerProperty(definition) {
      var name2 = definition.name, inherits = definition.inherits, interpolable = definition.interpolable, initialValue = definition.initialValue, syntax = definition.syntax;
      runtime.styleValueRegistry.registerMetadata({
        n: name2,
        inh: inherits,
        "int": interpolable,
        d: initialValue,
        syntax
      });
    },
    /**
     * CSS Layout API
     * register layout
     *
     * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md
     * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
     */
    registerLayout: function registerLayout(name2, clazz) {
      runtime.layoutRegistry.registerLayout(name2, clazz);
    }
  };
  var Document2 = /* @__PURE__ */ function(_Node) {
    function Document3() {
      var _this;
      _classCallCheck(this, Document3);
      _this = _callSuper(this, Document3);
      _this.defaultView = null;
      _this.ownerDocument = null;
      _this.nodeName = "document";
      try {
        _this.timeline = new runtime.AnimationTimeline(_this);
      } catch (_unused) {
      }
      var initialStyle = {};
      BUILT_IN_PROPERTIES.forEach(function(_ref) {
        var n2 = _ref.n, inh = _ref.inh, d3 = _ref.d;
        if (inh && d3) {
          initialStyle[n2] = isFunction(d3) ? d3(Shape.GROUP) : d3;
        }
      });
      _this.documentElement = new Group2({
        id: "g-root",
        style: initialStyle
      });
      _this.documentElement.ownerDocument = _this;
      _this.documentElement.parentNode = _this;
      _this.childNodes = [_this.documentElement];
      return _this;
    }
    _inherits(Document3, _Node);
    return _createClass(Document3, [{
      key: "children",
      get: function get2() {
        return this.childNodes;
      }
    }, {
      key: "childElementCount",
      get: function get2() {
        return this.childNodes.length;
      }
    }, {
      key: "firstElementChild",
      get: function get2() {
        return this.firstChild;
      }
    }, {
      key: "lastElementChild",
      get: function get2() {
        return this.lastChild;
      }
    }, {
      key: "createElement",
      value: (
        /**
         * @example const circle = document.createElement('circle', { style: { r: 10 } });
         */
        function createElement2(tagName, options) {
          if (tagName === "svg") {
            return this.documentElement;
          }
          var clazz = this.defaultView.customElements.get(tagName);
          if (!clazz) {
            console.warn("Unsupported tagName: ", tagName);
            clazz = tagName === "tspan" ? Text : Group2;
          }
          var shape23 = new clazz(options);
          shape23.ownerDocument = this;
          return shape23;
        }
      )
    }, {
      key: "createElementNS",
      value: function createElementNS(namespaceURI, tagName, options) {
        return this.createElement(tagName, options);
      }
    }, {
      key: "cloneNode",
      value: function cloneNode(deep2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        try {
          this.documentElement.destroyChildren();
          this.timeline.destroy();
        } catch (_unused2) {
        }
      }
      /**
       * Picking 2D graphics with RBush based on BBox, fast but inaccurate.
       */
    }, {
      key: "elementsFromBBox",
      value: function elementsFromBBox(minX, minY, maxX, maxY2) {
        var rBush = this.defaultView.context.rBushRoot;
        var rBushNodes = rBush.search({
          minX,
          minY,
          maxX,
          maxY: maxY2
        });
        var hitTestList = [];
        rBushNodes.forEach(function(_ref2) {
          var displayObject = _ref2.displayObject;
          var _displayObject$parsed = displayObject.parsedStyle.pointerEvents, pointerEvents = _displayObject$parsed === void 0 ? "auto" : _displayObject$parsed;
          var isVisibilityAffected = ["auto", "visiblepainted", "visiblefill", "visiblestroke", "visible"].includes(pointerEvents);
          if ((!isVisibilityAffected || isVisibilityAffected && displayObject.isVisible()) && !displayObject.isCulled() && displayObject.isInteractive()) {
            hitTestList.push(displayObject);
          }
        });
        hitTestList.sort(function(a3, b) {
          return b.sortable.renderOrder - a3.sortable.renderOrder;
        });
        return hitTestList;
      }
    }, {
      key: "elementFromPointSync",
      value: function elementFromPointSync(x3, y3) {
        var _this$defaultView$can = this.defaultView.canvas2Viewport({
          x: x3,
          y: y3
        }), viewportX = _this$defaultView$can.x, viewportY = _this$defaultView$can.y;
        var _this$defaultView$get = this.defaultView.getConfig(), width = _this$defaultView$get.width, height = _this$defaultView$get.height;
        if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
          return null;
        }
        var _this$defaultView$vie = this.defaultView.viewport2Client({
          x: viewportX,
          y: viewportY
        }), clientX = _this$defaultView$vie.x, clientY = _this$defaultView$vie.y;
        var _this$defaultView$get2 = this.defaultView.getRenderingService().hooks.pickSync.call({
          topmost: true,
          position: {
            x: x3,
            y: y3,
            viewportX,
            viewportY,
            clientX,
            clientY
          },
          picked: []
        }), picked = _this$defaultView$get2.picked;
        return picked && picked[0] || this.documentElement;
      }
      /**
       * Do picking with API instead of triggering interactive events.
       *
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementFromPoint
       */
    }, {
      key: "elementFromPoint",
      value: function() {
        var _elementFromPoint = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(x3, y3) {
          var _this$defaultView$can2, viewportX, viewportY, _this$defaultView$get3, width, height, _this$defaultView$vie2, clientX, clientY, _yield$this$defaultVi, picked;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _this$defaultView$can2 = this.defaultView.canvas2Viewport({
                  x: x3,
                  y: y3
                }), viewportX = _this$defaultView$can2.x, viewportY = _this$defaultView$can2.y;
                _this$defaultView$get3 = this.defaultView.getConfig(), width = _this$defaultView$get3.width, height = _this$defaultView$get3.height;
                if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                  _context.next = 4;
                  break;
                }
                return _context.abrupt("return", null);
              case 4:
                _this$defaultView$vie2 = this.defaultView.viewport2Client({
                  x: viewportX,
                  y: viewportY
                }), clientX = _this$defaultView$vie2.x, clientY = _this$defaultView$vie2.y;
                _context.next = 7;
                return this.defaultView.getRenderingService().hooks.pick.promise({
                  topmost: true,
                  position: {
                    x: x3,
                    y: y3,
                    viewportX,
                    viewportY,
                    clientX,
                    clientY
                  },
                  picked: []
                });
              case 7:
                _yield$this$defaultVi = _context.sent;
                picked = _yield$this$defaultVi.picked;
                return _context.abrupt("return", picked && picked[0] || this.documentElement);
              case 10:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function elementFromPoint(_x, _x2) {
          return _elementFromPoint.apply(this, arguments);
        }
        return elementFromPoint;
      }()
    }, {
      key: "elementsFromPointSync",
      value: function elementsFromPointSync(x3, y3) {
        var _this$defaultView$can3 = this.defaultView.canvas2Viewport({
          x: x3,
          y: y3
        }), viewportX = _this$defaultView$can3.x, viewportY = _this$defaultView$can3.y;
        var _this$defaultView$get4 = this.defaultView.getConfig(), width = _this$defaultView$get4.width, height = _this$defaultView$get4.height;
        if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
          return [];
        }
        var _this$defaultView$vie3 = this.defaultView.viewport2Client({
          x: viewportX,
          y: viewportY
        }), clientX = _this$defaultView$vie3.x, clientY = _this$defaultView$vie3.y;
        var _this$defaultView$get5 = this.defaultView.getRenderingService().hooks.pickSync.call({
          topmost: false,
          position: {
            x: x3,
            y: y3,
            viewportX,
            viewportY,
            clientX,
            clientY
          },
          picked: []
        }), picked = _this$defaultView$get5.picked;
        if (picked[picked.length - 1] !== this.documentElement) {
          picked.push(this.documentElement);
        }
        return picked;
      }
      /**
       * Do picking with API instead of triggering interactive events.
       *
       * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Document/elementsFromPoint
       */
    }, {
      key: "elementsFromPoint",
      value: function() {
        var _elementsFromPoint = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(x3, y3) {
          var _this$defaultView$can4, viewportX, viewportY, _this$defaultView$get6, width, height, _this$defaultView$vie4, clientX, clientY, _yield$this$defaultVi2, picked;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _this$defaultView$can4 = this.defaultView.canvas2Viewport({
                  x: x3,
                  y: y3
                }), viewportX = _this$defaultView$can4.x, viewportY = _this$defaultView$can4.y;
                _this$defaultView$get6 = this.defaultView.getConfig(), width = _this$defaultView$get6.width, height = _this$defaultView$get6.height;
                if (!(viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height)) {
                  _context2.next = 4;
                  break;
                }
                return _context2.abrupt("return", []);
              case 4:
                _this$defaultView$vie4 = this.defaultView.viewport2Client({
                  x: viewportX,
                  y: viewportY
                }), clientX = _this$defaultView$vie4.x, clientY = _this$defaultView$vie4.y;
                _context2.next = 7;
                return this.defaultView.getRenderingService().hooks.pick.promise({
                  topmost: false,
                  position: {
                    x: x3,
                    y: y3,
                    viewportX,
                    viewportY,
                    clientX,
                    clientY
                  },
                  picked: []
                });
              case 7:
                _yield$this$defaultVi2 = _context2.sent;
                picked = _yield$this$defaultVi2.picked;
                if (picked[picked.length - 1] !== this.documentElement) {
                  picked.push(this.documentElement);
                }
                return _context2.abrupt("return", picked);
              case 11:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function elementsFromPoint(_x3, _x4) {
          return _elementsFromPoint.apply(this, arguments);
        }
        return elementsFromPoint;
      }()
    }, {
      key: "appendChild",
      value: function appendChild(newChild, index4) {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      }
    }, {
      key: "insertBefore",
      value: function insertBefore(newChild, refChild) {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      }
    }, {
      key: "removeChild",
      value: function removeChild(oldChild, destroy3) {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      }
    }, {
      key: "replaceChild",
      value: function replaceChild2(newChild, oldChild, destroy3) {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      }
    }, {
      key: "append",
      value: function append3() {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      }
    }, {
      key: "prepend",
      value: function prepend() {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      }
      /**
       * Execute query on documentElement.
       */
    }, {
      key: "getElementById",
      value: function getElementById(id5) {
        return this.documentElement.getElementById(id5);
      }
    }, {
      key: "getElementsByName",
      value: function getElementsByName(name2) {
        return this.documentElement.getElementsByName(name2);
      }
    }, {
      key: "getElementsByTagName",
      value: function getElementsByTagName(tagName) {
        return this.documentElement.getElementsByTagName(tagName);
      }
    }, {
      key: "getElementsByClassName",
      value: function getElementsByClassName(className2) {
        return this.documentElement.getElementsByClassName(className2);
      }
    }, {
      key: "querySelector",
      value: function querySelector(selectors) {
        return this.documentElement.querySelector(selectors);
      }
    }, {
      key: "querySelectorAll",
      value: function querySelectorAll(selectors) {
        return this.documentElement.querySelectorAll(selectors);
      }
    }, {
      key: "find",
      value: function find7(filter2) {
        return this.documentElement.find(filter2);
      }
    }, {
      key: "findAll",
      value: function findAll(filter2) {
        return this.documentElement.findAll(filter2);
      }
    }]);
  }(Node2);
  var CullingPlugin = /* @__PURE__ */ function() {
    function CullingPlugin2(strategies) {
      _classCallCheck(this, CullingPlugin2);
      this.strategies = strategies;
    }
    return _createClass(CullingPlugin2, [{
      key: "apply",
      value: function apply(context) {
        var camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext;
        var strategies = this.strategies;
        renderingService.hooks.cull.tap(CullingPlugin2.tag, function(object) {
          if (object) {
            var cullable = object.cullable;
            if (strategies.length === 0) {
              cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
            } else {
              cullable.visible = strategies.every(function(strategy) {
                return strategy.isVisible(camera, object);
              });
            }
            if (!object.isCulled() && object.isVisible()) {
              return object;
            }
            object.dispatchEvent(new CustomEvent2(ElementEvent.CULLED));
            return null;
          }
          return object;
        });
        renderingService.hooks.afterRender.tap(CullingPlugin2.tag, function(object) {
          object.cullable.visibilityPlaneMask = -1;
        });
      }
    }]);
  }();
  CullingPlugin.tag = "Culling";
  var EventPlugin = /* @__PURE__ */ function() {
    function EventPlugin2() {
      var _this = this;
      _classCallCheck(this, EventPlugin2);
      this.autoPreventDefault = false;
      this.rootPointerEvent = new FederatedPointerEvent(null);
      this.rootWheelEvent = new FederatedWheelEvent(null);
      this.onPointerMove = function(nativeEvent) {
        var _this$context$renderi;
        var canvas = (_this$context$renderi = _this.context.renderingContext.root) === null || _this$context$renderi === void 0 || (_this$context$renderi = _this$context$renderi.ownerDocument) === null || _this$context$renderi === void 0 ? void 0 : _this$context$renderi.defaultView;
        if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
        var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);
        var _iterator = _createForOfIteratorHelper(normalizedEvents), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var normalizedEvent = _step.value;
            var event = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
            _this.context.eventService.mapEvent(event);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        _this.setCursor(_this.context.eventService.cursor);
      };
      this.onClick = function(nativeEvent) {
        var _this$context$renderi2;
        var canvas = (_this$context$renderi2 = _this.context.renderingContext.root) === null || _this$context$renderi2 === void 0 || (_this$context$renderi2 = _this$context$renderi2.ownerDocument) === null || _this$context$renderi2 === void 0 ? void 0 : _this$context$renderi2.defaultView;
        var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);
        var _iterator2 = _createForOfIteratorHelper(normalizedEvents), _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
            var normalizedEvent = _step2.value;
            var event = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
            _this.context.eventService.mapEvent(event);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        _this.setCursor(_this.context.eventService.cursor);
      };
    }
    return _createClass(EventPlugin2, [{
      key: "apply",
      value: function apply(context) {
        var _this2 = this;
        this.context = context;
        var renderingService = context.renderingService;
        var canvas = this.context.renderingContext.root.ownerDocument.defaultView;
        this.context.eventService.setPickHandler(function(position) {
          var _this2$context$render = _this2.context.renderingService.hooks.pickSync.call({
            position,
            picked: [],
            topmost: true
            // we only concern the topmost element
          }), picked = _this2$context$render.picked;
          return picked[0] || null;
        });
        renderingService.hooks.pointerWheel.tap(EventPlugin2.tag, function(nativeEvent) {
          var wheelEvent = _this2.normalizeWheelEvent(nativeEvent);
          _this2.context.eventService.mapEvent(wheelEvent);
        });
        renderingService.hooks.pointerDown.tap(EventPlugin2.tag, function(nativeEvent) {
          if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
          var events = _this2.normalizeToPointerEvent(nativeEvent, canvas);
          if (_this2.autoPreventDefault && events[0].isNormalized) {
            var cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
            if (cancelable) {
              nativeEvent.preventDefault();
            }
          }
          var _iterator3 = _createForOfIteratorHelper(events), _step3;
          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done; ) {
              var event = _step3.value;
              var federatedEvent = _this2.bootstrapEvent(_this2.rootPointerEvent, event, canvas, nativeEvent);
              _this2.context.eventService.mapEvent(federatedEvent);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
          _this2.setCursor(_this2.context.eventService.cursor);
        });
        renderingService.hooks.pointerUp.tap(EventPlugin2.tag, function(nativeEvent) {
          if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch") return;
          var $element = _this2.context.contextService.getDomElement();
          var isNativeEventFromCanvas = _this2.context.eventService.isNativeEventFromCanvas($element, nativeEvent);
          var outside2 = !isNativeEventFromCanvas ? "outside" : "";
          var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
          var _iterator4 = _createForOfIteratorHelper(normalizedEvents), _step4;
          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done; ) {
              var normalizedEvent = _step4.value;
              var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
              event.type += outside2;
              _this2.context.eventService.mapEvent(event);
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }
          _this2.setCursor(_this2.context.eventService.cursor);
        });
        renderingService.hooks.pointerMove.tap(EventPlugin2.tag, this.onPointerMove);
        renderingService.hooks.pointerOver.tap(EventPlugin2.tag, this.onPointerMove);
        renderingService.hooks.pointerOut.tap(EventPlugin2.tag, this.onPointerMove);
        renderingService.hooks.click.tap(EventPlugin2.tag, this.onClick);
        renderingService.hooks.pointerCancel.tap(EventPlugin2.tag, function(nativeEvent) {
          var normalizedEvents = _this2.normalizeToPointerEvent(nativeEvent, canvas);
          var _iterator5 = _createForOfIteratorHelper(normalizedEvents), _step5;
          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done; ) {
              var normalizedEvent = _step5.value;
              var event = _this2.bootstrapEvent(_this2.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
              _this2.context.eventService.mapEvent(event);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
          _this2.setCursor(_this2.context.eventService.cursor);
        });
      }
    }, {
      key: "bootstrapEvent",
      value: function bootstrapEvent(event, normalizedEvent, view, nativeEvent) {
        event.view = view;
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = normalizedEvent.pointerId;
        event.width = normalizedEvent.width;
        event.height = normalizedEvent.height;
        event.isPrimary = normalizedEvent.isPrimary;
        event.pointerType = normalizedEvent.pointerType;
        event.pressure = normalizedEvent.pressure;
        event.tangentialPressure = normalizedEvent.tangentialPressure;
        event.tiltX = normalizedEvent.tiltX;
        event.tiltY = normalizedEvent.tiltY;
        event.twist = normalizedEvent.twist;
        this.transferMouseData(event, normalizedEvent);
        var _this$context$eventSe = this.context.eventService.client2Viewport({
          x: normalizedEvent.clientX,
          y: normalizedEvent.clientY
        }), x3 = _this$context$eventSe.x, y3 = _this$context$eventSe.y;
        event.viewport.x = x3;
        event.viewport.y = y3;
        var _this$context$eventSe2 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe2.x, canvasY = _this$context$eventSe2.y;
        event.canvas.x = canvasX;
        event.canvas.y = canvasY;
        event.global.copyFrom(event.canvas);
        event.offset.copyFrom(event.canvas);
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === "pointerleave") {
          event.type = "pointerout";
        }
        if (event.type.startsWith("mouse")) {
          event.type = event.type.replace("mouse", "pointer");
        }
        if (event.type.startsWith("touch")) {
          event.type = TOUCH_TO_POINTER[event.type] || event.type;
        }
        return event;
      }
    }, {
      key: "normalizeWheelEvent",
      value: function normalizeWheelEvent(nativeEvent) {
        var event = this.rootWheelEvent;
        this.transferMouseData(event, nativeEvent);
        event.deltaMode = nativeEvent.deltaMode;
        event.deltaX = nativeEvent.deltaX;
        event.deltaY = nativeEvent.deltaY;
        event.deltaZ = nativeEvent.deltaZ;
        var _this$context$eventSe3 = this.context.eventService.client2Viewport({
          x: nativeEvent.clientX,
          y: nativeEvent.clientY
        }), x3 = _this$context$eventSe3.x, y3 = _this$context$eventSe3.y;
        event.viewport.x = x3;
        event.viewport.y = y3;
        var _this$context$eventSe4 = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _this$context$eventSe4.x, canvasY = _this$context$eventSe4.y;
        event.canvas.x = canvasX;
        event.canvas.y = canvasY;
        event.global.copyFrom(event.canvas);
        event.offset.copyFrom(event.canvas);
        event.nativeEvent = nativeEvent;
        event.type = nativeEvent.type;
        return event;
      }
      /**
       * Transfers base & mouse event data from the nativeEvent to the federated event.
       */
    }, {
      key: "transferMouseData",
      value: function transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = clock.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.metaKey = nativeEvent.metaKey;
        event.shiftKey = nativeEvent.shiftKey;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.screen.x = nativeEvent.screenX;
        event.screen.y = nativeEvent.screenY;
        event.relatedTarget = null;
      }
    }, {
      key: "setCursor",
      value: function setCursor2(cursor) {
        this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || "default");
      }
    }, {
      key: "normalizeToPointerEvent",
      value: function normalizeToPointerEvent(event, canvas) {
        var normalizedEvents = [];
        if (canvas.isTouchEvent(event)) {
          for (var i = 0; i < event.changedTouches.length; i++) {
            var touch = event.changedTouches[i];
            if (is_undefined_default(touch.button)) touch.button = 0;
            if (is_undefined_default(touch.buttons)) touch.buttons = 1;
            if (is_undefined_default(touch.isPrimary)) {
              touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
            }
            if (is_undefined_default(touch.width)) touch.width = touch.radiusX || 1;
            if (is_undefined_default(touch.height)) touch.height = touch.radiusY || 1;
            if (is_undefined_default(touch.tiltX)) touch.tiltX = 0;
            if (is_undefined_default(touch.tiltY)) touch.tiltY = 0;
            if (is_undefined_default(touch.pointerType)) touch.pointerType = "touch";
            if (is_undefined_default(touch.pointerId)) touch.pointerId = touch.identifier || 0;
            if (is_undefined_default(touch.pressure)) touch.pressure = touch.force || 0.5;
            if (is_undefined_default(touch.twist)) touch.twist = 0;
            if (is_undefined_default(touch.tangentialPressure)) touch.tangentialPressure = 0;
            touch.isNormalized = true;
            touch.type = event.type;
            normalizedEvents.push(touch);
          }
        } else if (canvas.isMouseEvent(event)) {
          var tempEvent = event;
          if (is_undefined_default(tempEvent.isPrimary)) tempEvent.isPrimary = true;
          if (is_undefined_default(tempEvent.width)) tempEvent.width = 1;
          if (is_undefined_default(tempEvent.height)) tempEvent.height = 1;
          if (is_undefined_default(tempEvent.tiltX)) tempEvent.tiltX = 0;
          if (is_undefined_default(tempEvent.tiltY)) tempEvent.tiltY = 0;
          if (is_undefined_default(tempEvent.pointerType)) tempEvent.pointerType = "mouse";
          if (is_undefined_default(tempEvent.pointerId)) tempEvent.pointerId = MOUSE_POINTER_ID;
          if (is_undefined_default(tempEvent.pressure)) tempEvent.pressure = 0.5;
          if (is_undefined_default(tempEvent.twist)) tempEvent.twist = 0;
          if (is_undefined_default(tempEvent.tangentialPressure)) tempEvent.tangentialPressure = 0;
          tempEvent.isNormalized = true;
          normalizedEvents.push(tempEvent);
        } else {
          normalizedEvents.push(event);
        }
        return normalizedEvents;
      }
    }]);
  }();
  EventPlugin.tag = "Event";
  var shape2D = [Shape.CIRCLE, Shape.ELLIPSE, Shape.IMAGE, Shape.RECT, Shape.LINE, Shape.POLYLINE, Shape.POLYGON, Shape.TEXT, Shape.PATH, Shape.HTML];
  var FrustumCullingStrategy = /* @__PURE__ */ function() {
    function FrustumCullingStrategy2() {
      _classCallCheck(this, FrustumCullingStrategy2);
    }
    return _createClass(FrustumCullingStrategy2, [{
      key: "isVisible",
      value: function isVisible(camera, object) {
        var _object$parentNode;
        var cullable = object.cullable;
        if (!cullable.enable) {
          return true;
        }
        var renderBounds = object.getRenderBounds();
        if (AABB.isEmpty(renderBounds)) {
          return false;
        }
        var frustum2 = camera.getFrustum();
        var parentVisibilityPlaneMask = (_object$parentNode = object.parentNode) === null || _object$parentNode === void 0 || (_object$parentNode = _object$parentNode.cullable) === null || _object$parentNode === void 0 ? void 0 : _object$parentNode.visibilityPlaneMask;
        cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum2.planes);
        cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;
        return cullable.visible;
      }
      /**
       *
       * @see「Optimized View Frustum Culling Algorithms for Bounding Boxes」
       * @see https://github.com/antvis/GWebGPUEngine/issues/3
       *
       * * 基础相交测试 the basic intersection test
       * * 标记 masking @see https://cesium.com/blog/2015/08/04/fast-hierarchical-culling/
       * * TODO: 平面一致性测试 the plane-coherency test
       * * TODO: 支持 mesh 指定自身的剔除策略，参考 Babylon.js @see https://doc.babylonjs.com/how_to/optimizing_your_scene#changing-mesh-culling-strategy
       *
       * @param aabb aabb
       * @param parentPlaneMask mask of parent
       * @param planes planes of frustum
       */
    }, {
      key: "computeVisibilityWithPlaneMask",
      value: function computeVisibilityWithPlaneMask(object, aabb, parentPlaneMask, planes) {
        if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
          return parentPlaneMask;
        }
        var mask = Mask.INSIDE;
        var isShape2D = shape2D.indexOf(object.nodeName) > -1;
        for (var k = 0, len5 = planes.length; k < len5; ++k) {
          var flag = 1 << k;
          if ((parentPlaneMask & flag) === 0) {
            continue;
          }
          if (isShape2D && (k === 4 || k === 5)) {
            continue;
          }
          var _planes$k = planes[k], normal = _planes$k.normal, distance7 = _planes$k.distance;
          if (vec3_exports.dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance7 < 0) {
            return Mask.OUTSIDE;
          }
          if (vec3_exports.dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance7 < 0) {
            mask |= flag;
          }
        }
        return mask;
      }
    }]);
  }();
  var PrepareRendererPlugin = /* @__PURE__ */ function() {
    function PrepareRendererPlugin2() {
      _classCallCheck(this, PrepareRendererPlugin2);
      this.syncTasks = /* @__PURE__ */ new Map();
      this.isFirstTimeRendering = true;
      this.syncing = false;
      this.isFirstTimeRenderingFinished = false;
    }
    return _createClass(PrepareRendererPlugin2, [{
      key: "apply",
      value: function apply(context) {
        var _this = this, _runtime$globalThis$r;
        var renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot;
        var canvas = renderingContext.root.ownerDocument.defaultView;
        this.rBush = rBushRoot;
        var handleAttributeChanged = function handleAttributeChanged2(e3) {
          var object = e3.target;
          object.renderable.dirty = true;
          renderingService.dirtify();
        };
        var handleBoundsChanged = function handleBoundsChanged2(e3) {
          _this.syncTasks.set(e3.target, e3.detail.affectChildren);
          renderingService.dirtify();
        };
        var handleMounted = function handleMounted2(e3) {
          var object = e3.target;
          if (runtime.enableSizeAttenuation) {
            runtime.styleValueRegistry.updateSizeAttenuation(object, canvas.getCamera().getZoom());
          }
        };
        var handleUnmounted = function handleUnmounted2(e3) {
          var object = e3.target;
          var rBushNode = object.rBushNode;
          if (rBushNode.aabb) {
            _this.rBush.remove(rBushNode.aabb);
          }
          _this.syncTasks["delete"](object);
          runtime.sceneGraphService.dirtifyToRoot(object);
          renderingService.dirtify();
        };
        renderingService.hooks.init.tap(PrepareRendererPlugin2.tag, function() {
          canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
          canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        });
        renderingService.hooks.destroy.tap(PrepareRendererPlugin2.tag, function() {
          canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
          canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
          _this.syncTasks.clear();
        });
        var ric = (_runtime$globalThis$r = runtime.globalThis.requestIdleCallback) !== null && _runtime$globalThis$r !== void 0 ? _runtime$globalThis$r : raf.bind(runtime.globalThis);
        renderingService.hooks.endFrame.tap(PrepareRendererPlugin2.tag, function() {
          if (_this.isFirstTimeRendering) {
            _this.isFirstTimeRendering = false;
            _this.syncing = true;
            ric(function() {
              _this.syncRTree(true);
              _this.isFirstTimeRenderingFinished = true;
            });
          } else {
            _this.syncRTree();
          }
        });
      }
    }, {
      key: "syncNode",
      value: function syncNode(node) {
        var force = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!node.isConnected) return;
        var rBushNode = node.rBushNode;
        if (rBushNode.aabb) this.rBush.remove(rBushNode.aabb);
        var renderBounds = node.getRenderBounds();
        if (renderBounds) {
          var renderable = node.renderable;
          if (force) {
            if (!renderable.dirtyRenderBounds) {
              renderable.dirtyRenderBounds = new AABB();
            }
            renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
          }
          var _renderBounds$getMin = renderBounds.getMin(), _renderBounds$getMin2 = _slicedToArray(_renderBounds$getMin, 2), minX = _renderBounds$getMin2[0], minY = _renderBounds$getMin2[1];
          var _renderBounds$getMax = renderBounds.getMax(), _renderBounds$getMax2 = _slicedToArray(_renderBounds$getMax, 2), maxX = _renderBounds$getMax2[0], maxY2 = _renderBounds$getMax2[1];
          if (!rBushNode.aabb) {
            rBushNode.aabb = {};
          }
          rBushNode.aabb.displayObject = node;
          rBushNode.aabb.minX = minX;
          rBushNode.aabb.minY = minY;
          rBushNode.aabb.maxX = maxX;
          rBushNode.aabb.maxY = maxY2;
        }
        if (rBushNode.aabb) {
          if (!isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.minX) && !isNaN(rBushNode.aabb.minY)) {
            return rBushNode.aabb;
          }
        }
      }
    }, {
      key: "syncRTree",
      value: function syncRTree() {
        var _this2 = this;
        var force = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
        if (!force && (this.syncing || this.syncTasks.size === 0)) {
          return;
        }
        this.syncing = true;
        var bulk = [];
        var synced = /* @__PURE__ */ new Set();
        var sync = function sync2(node) {
          if (!synced.has(node) && node.renderable) {
            var aabb = _this2.syncNode(node, force);
            if (aabb) {
              bulk.push(aabb);
              synced.add(node);
            }
          }
        };
        this.syncTasks.forEach(function(affectChildren, node) {
          if (affectChildren) {
            node.forEach(sync);
          }
          var parent = node;
          while (parent) {
            sync(parent);
            parent = parent.parentElement;
          }
        });
        this.rBush.load(bulk);
        bulk.length = 0;
        this.syncing = false;
      }
    }]);
  }();
  PrepareRendererPlugin.tag = "Prepare";
  var CanvasEvent = /* @__PURE__ */ function(CanvasEvent2) {
    CanvasEvent2["READY"] = "ready";
    CanvasEvent2["BEFORE_RENDER"] = "beforerender";
    CanvasEvent2["RERENDER"] = "rerender";
    CanvasEvent2["AFTER_RENDER"] = "afterrender";
    CanvasEvent2["BEFORE_DESTROY"] = "beforedestroy";
    CanvasEvent2["AFTER_DESTROY"] = "afterdestroy";
    CanvasEvent2["RESIZE"] = "resize";
    CanvasEvent2["DIRTY_RECTANGLE"] = "dirtyrectangle";
    CanvasEvent2["RENDERER_CHANGED"] = "rendererchanged";
    return CanvasEvent2;
  }({});
  var DEFAULT_CAMERA_Z = 500;
  var DEFAULT_CAMERA_NEAR = 0.1;
  var DEFAULT_CAMERA_FAR = 1e3;
  var mountedEvent = new CustomEvent2(ElementEvent.MOUNTED);
  var unmountedEvent = new CustomEvent2(ElementEvent.UNMOUNTED);
  var beforeRenderEvent = new CustomEvent2(CanvasEvent.BEFORE_RENDER);
  var rerenderEvent = new CustomEvent2(CanvasEvent.RERENDER);
  var afterRenderEvent = new CustomEvent2(CanvasEvent.AFTER_RENDER);
  var Canvas = /* @__PURE__ */ function(_EventTarget) {
    function Canvas3(config2) {
      var _this;
      _classCallCheck(this, Canvas3);
      _this = _callSuper(this, Canvas3);
      _this.Element = DisplayObject;
      _this.inited = false;
      _this.context = {};
      var container = config2.container, canvas = config2.canvas, renderer = config2.renderer, width = config2.width, height = config2.height, background = config2.background, cursor = config2.cursor, supportsMutipleCanvasesInOneContainer = config2.supportsMutipleCanvasesInOneContainer, _config$cleanUpOnDest = config2.cleanUpOnDestroy, cleanUpOnDestroy = _config$cleanUpOnDest === void 0 ? true : _config$cleanUpOnDest, offscreenCanvas = config2.offscreenCanvas, devicePixelRatio = config2.devicePixelRatio, requestAnimationFrame2 = config2.requestAnimationFrame, cancelAnimationFrame2 = config2.cancelAnimationFrame, createImage = config2.createImage, supportsTouchEvents = config2.supportsTouchEvents, supportsPointerEvents = config2.supportsPointerEvents, isTouchEvent = config2.isTouchEvent, isMouseEvent = config2.isMouseEvent, dblClickSpeed = config2.dblClickSpeed;
      var canvasWidth = width;
      var canvasHeight = height;
      var dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
      dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
      if (canvas) {
        canvasWidth = width || getWidth(canvas) || canvas.width / dpr;
        canvasHeight = height || getHeight(canvas) || canvas.height / dpr;
      }
      _this.customElements = new CustomElementRegistry();
      _this.devicePixelRatio = dpr;
      _this.requestAnimationFrame = requestAnimationFrame2 !== null && requestAnimationFrame2 !== void 0 ? requestAnimationFrame2 : raf.bind(runtime.globalThis);
      _this.cancelAnimationFrame = cancelAnimationFrame2 !== null && cancelAnimationFrame2 !== void 0 ? cancelAnimationFrame2 : caf.bind(runtime.globalThis);
      _this.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : "ontouchstart" in runtime.globalThis;
      _this.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;
      _this.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function(event) {
        return _this.supportsTouchEvents && event instanceof runtime.globalThis.TouchEvent;
      };
      _this.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function(event) {
        return !runtime.globalThis.MouseEvent || event instanceof runtime.globalThis.MouseEvent && (!_this.supportsPointerEvents || !(event instanceof runtime.globalThis.PointerEvent));
      };
      if (offscreenCanvas) {
        runtime.offscreenCanvas = offscreenCanvas;
      }
      _this.document = new Document2();
      _this.document.defaultView = _this;
      if (!supportsMutipleCanvasesInOneContainer) {
        cleanExistedCanvas(container, _this, cleanUpOnDestroy);
      }
      _this.initRenderingContext(_objectSpread22(_objectSpread22({}, config2), {}, {
        width: canvasWidth,
        height: canvasHeight,
        background: background !== null && background !== void 0 ? background : "transparent",
        cursor: cursor !== null && cursor !== void 0 ? cursor : "default",
        cleanUpOnDestroy,
        devicePixelRatio: dpr,
        requestAnimationFrame: _this.requestAnimationFrame,
        cancelAnimationFrame: _this.cancelAnimationFrame,
        supportsTouchEvents: _this.supportsTouchEvents,
        supportsPointerEvents: _this.supportsPointerEvents,
        isTouchEvent: _this.isTouchEvent,
        isMouseEvent: _this.isMouseEvent,
        dblClickSpeed: dblClickSpeed !== null && dblClickSpeed !== void 0 ? dblClickSpeed : 200,
        createImage: createImage !== null && createImage !== void 0 ? createImage : function() {
          return new window.Image();
        }
      }));
      _this.initDefaultCamera(canvasWidth, canvasHeight, renderer.clipSpaceNearZ);
      _this.initRenderer(renderer, true);
      return _this;
    }
    _inherits(Canvas3, _EventTarget);
    return _createClass(Canvas3, [{
      key: "initRenderingContext",
      value: function initRenderingContext(mergedConfig) {
        this.context.config = mergedConfig;
        this.context.renderingContext = {
          /**
           * the root node in scene graph
           */
          root: this.document.documentElement,
          renderListCurrentFrame: [],
          unculledEntities: [],
          renderReasons: /* @__PURE__ */ new Set(),
          force: false,
          dirty: false
        };
      }
    }, {
      key: "initDefaultCamera",
      value: function initDefaultCamera(width, height, clipSpaceNearZ) {
        var _this2 = this;
        var camera = new runtime.CameraContribution();
        camera.clipSpaceNearZ = clipSpaceNearZ;
        camera.setType(CameraType.EXPLORING, CameraTrackingMode.DEFAULT).setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0).setOrthographic(width / -2, width / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);
        camera.canvas = this;
        camera.eventEmitter.on(CameraEvent.UPDATED, function() {
          _this2.context.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
          if (runtime.enableSizeAttenuation && _this2.getConfig().renderer.getConfig().enableSizeAttenuation) {
            _this2.updateSizeAttenuation();
          }
        });
        this.context.camera = camera;
      }
    }, {
      key: "updateSizeAttenuation",
      value: function updateSizeAttenuation() {
        var zoom = this.getCamera().getZoom();
        this.document.documentElement.forEach(function(node) {
          runtime.styleValueRegistry.updateSizeAttenuation(node, zoom);
        });
      }
    }, {
      key: "getConfig",
      value: function getConfig2() {
        return this.context.config;
      }
      /**
       * get the root displayObject in scenegraph
       * @alias this.document.documentElement
       */
    }, {
      key: "getRoot",
      value: function getRoot() {
        return this.document.documentElement;
      }
      /**
       * get the camera of canvas
       */
    }, {
      key: "getCamera",
      value: function getCamera() {
        return this.context.camera;
      }
    }, {
      key: "getContextService",
      value: function getContextService() {
        return this.context.contextService;
      }
    }, {
      key: "getEventService",
      value: function getEventService() {
        return this.context.eventService;
      }
    }, {
      key: "getRenderingService",
      value: function getRenderingService() {
        return this.context.renderingService;
      }
    }, {
      key: "getRenderingContext",
      value: function getRenderingContext() {
        return this.context.renderingContext;
      }
    }, {
      key: "getStats",
      value: function getStats() {
        return this.getRenderingService().getStats();
      }
      // /**
      //  * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle
      //  */
      // getComputedStyle(node: DisplayObject) {
      //   return node.computedStyle;
      // }
    }, {
      key: "ready",
      get: function get2() {
        var _this3 = this;
        if (!this.readyPromise) {
          this.readyPromise = new Promise(function(resolve) {
            _this3.resolveReadyPromise = function() {
              resolve(_this3);
            };
          });
          if (this.inited) {
            this.resolveReadyPromise();
          }
        }
        return this.readyPromise;
      }
      /**
       * @param cleanUp - whether to clean up all the internal services of Canvas
       * @param skipTriggerEvent - whether to skip trigger destroy event
       */
    }, {
      key: "destroy",
      value: function destroy3() {
        var cleanUp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
        var skipTriggerEvent = arguments.length > 1 ? arguments[1] : void 0;
        if (!skipTriggerEvent) {
          this.dispatchEvent(new CustomEvent2(CanvasEvent.BEFORE_DESTROY));
        }
        if (this.frameId) {
          this.cancelAnimationFrame(this.frameId);
        }
        var root2 = this.getRoot();
        if (cleanUp) {
          this.unmountChildren(root2);
          this.document.destroy();
          this.getEventService().destroy();
        }
        this.getRenderingService().destroy();
        this.getContextService().destroy();
        if (this.context.rBushRoot) {
          this.context.rBushRoot.clear();
        }
        if (!skipTriggerEvent) {
          this.dispatchEvent(new CustomEvent2(CanvasEvent.AFTER_DESTROY));
        }
        var clearEventRetain = function clearEventRetain2(event) {
          event.currentTarget = null;
          event.manager = null;
          event.target = null;
          event.relatedNode = null;
        };
        clearEventRetain(mountedEvent);
        clearEventRetain(unmountedEvent);
        clearEventRetain(beforeRenderEvent);
        clearEventRetain(rerenderEvent);
        clearEventRetain(afterRenderEvent);
        clearEventRetain(attrModifiedEvent);
        clearEventRetain(insertedEvent);
        clearEventRetain(removedEvent);
        clearEventRetain(destroyEvent);
      }
      /**
       * compatible with G 3.0
       * @deprecated
       * @alias resize
       */
    }, {
      key: "changeSize",
      value: function changeSize(width, height) {
        this.resize(width, height);
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        var canvasConfig = this.context.config;
        canvasConfig.width = width;
        canvasConfig.height = height;
        this.getContextService().resize(width, height);
        var camera = this.context.camera;
        var projectionMode = camera.getProjectionMode();
        camera.setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0);
        if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
          camera.setOrthographic(width / -2, width / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
        } else {
          camera.setAspect(width / height);
        }
        this.dispatchEvent(new CustomEvent2(CanvasEvent.RESIZE, {
          width,
          height
        }));
      }
      // proxy to document.documentElement
    }, {
      key: "appendChild",
      value: function appendChild(child, index4) {
        return this.document.documentElement.appendChild(child, index4);
      }
    }, {
      key: "insertBefore",
      value: function insertBefore(newChild, refChild) {
        return this.document.documentElement.insertBefore(newChild, refChild);
      }
    }, {
      key: "removeChild",
      value: function removeChild(child) {
        return this.document.documentElement.removeChild(child);
      }
      /**
       * Remove all children which can be appended to its original parent later again.
       */
    }, {
      key: "removeChildren",
      value: function removeChildren() {
        this.document.documentElement.removeChildren();
      }
      /**
       * Recursively destroy all children which can not be appended to its original parent later again.
       * But the canvas remains running which means display objects can be appended later.
       */
    }, {
      key: "destroyChildren",
      value: function destroyChildren() {
        this.document.documentElement.destroyChildren();
      }
    }, {
      key: "render",
      value: function render2(frame2) {
        var _this4 = this;
        if (frame2) {
          beforeRenderEvent.detail = frame2;
          afterRenderEvent.detail = frame2;
        }
        this.dispatchEvent(beforeRenderEvent);
        var renderingService = this.getRenderingService();
        renderingService.render(this.getConfig(), frame2, function() {
          _this4.dispatchEvent(rerenderEvent);
        });
        this.dispatchEvent(afterRenderEvent);
      }
    }, {
      key: "run",
      value: function run() {
        var _this5 = this;
        var _tick = function tick3(time, frame2) {
          _this5.render(frame2);
          _this5.frameId = _this5.requestAnimationFrame(_tick);
        };
        _tick();
      }
    }, {
      key: "initRenderer",
      value: function initRenderer(renderer) {
        var _this6 = this;
        var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        if (!renderer) {
          throw new Error("Renderer is required.");
        }
        this.inited = false;
        this.readyPromise = void 0;
        this.context.rBushRoot = new RBush();
        this.context.renderingPlugins = [];
        this.context.renderingPlugins.push(
          new EventPlugin(),
          new PrepareRendererPlugin(),
          // new DirtyCheckPlugin(),
          new CullingPlugin([new FrustumCullingStrategy()])
        );
        this.loadRendererContainerModule(renderer);
        this.context.contextService = new this.context.ContextService(_objectSpread22(_objectSpread22({}, runtime), this.context));
        this.context.renderingService = new RenderingService(runtime, this.context);
        this.context.eventService = new EventService(runtime, this.context);
        this.context.eventService.init();
        if (this.context.contextService.init) {
          this.context.contextService.init();
          this.initRenderingService(renderer, firstContentfullPaint, true);
        } else {
          this.context.contextService.initAsync().then(function() {
            _this6.initRenderingService(renderer, firstContentfullPaint);
          })["catch"](function(err) {
            console.error(err);
          });
        }
      }
    }, {
      key: "initRenderingService",
      value: function initRenderingService(renderer) {
        var _this7 = this;
        var firstContentfullPaint = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var async = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
        this.context.renderingService.init(function() {
          _this7.inited = true;
          if (firstContentfullPaint) {
            if (async) {
              _this7.requestAnimationFrame(function() {
                _this7.dispatchEvent(new CustomEvent2(CanvasEvent.READY));
              });
            } else {
              _this7.dispatchEvent(new CustomEvent2(CanvasEvent.READY));
            }
          } else {
            _this7.dispatchEvent(new CustomEvent2(CanvasEvent.RENDERER_CHANGED));
          }
          if (_this7.readyPromise) {
            _this7.resolveReadyPromise();
          }
          if (!firstContentfullPaint) {
            _this7.getRoot().forEach(function(node) {
              var _ref = node, renderable = _ref.renderable;
              if (renderable) {
                renderable.renderBoundsDirty = true;
                renderable.boundsDirty = true;
                renderable.dirty = true;
              }
            });
          }
          _this7.mountChildren(_this7.getRoot());
          if (renderer.getConfig().enableAutoRendering) {
            _this7.run();
          }
        });
      }
    }, {
      key: "loadRendererContainerModule",
      value: function loadRendererContainerModule(renderer) {
        var _this8 = this;
        var plugins2 = renderer.getPlugins();
        plugins2.forEach(function(plugin) {
          plugin.context = _this8.context;
          plugin.init(runtime);
        });
      }
    }, {
      key: "setRenderer",
      value: function setRenderer(renderer) {
        var canvasConfig = this.getConfig();
        if (canvasConfig.renderer === renderer) {
          return;
        }
        var oldRenderer = canvasConfig.renderer;
        canvasConfig.renderer = renderer;
        this.destroy(false, true);
        _toConsumableArray((oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()) || []).reverse().forEach(function(plugin) {
          plugin.destroy(runtime);
        });
        this.initRenderer(renderer);
      }
    }, {
      key: "setCursor",
      value: function setCursor2(cursor) {
        var canvasConfig = this.getConfig();
        canvasConfig.cursor = cursor;
        this.getContextService().applyCursorStyle(cursor);
      }
    }, {
      key: "unmountChildren",
      value: function unmountChildren(parent) {
        var _this9 = this;
        parent.childNodes.forEach(function(child) {
          _this9.unmountChildren(child);
        });
        if (this.inited) {
          if (parent.isMutationObserved) {
            parent.dispatchEvent(unmountedEvent);
          } else {
            unmountedEvent.target = parent;
            this.dispatchEvent(unmountedEvent, true);
          }
          if (parent !== this.document.documentElement) {
            parent.ownerDocument = null;
          }
          parent.isConnected = false;
        }
        if (parent.isCustomElement) {
          if (parent.disconnectedCallback) {
            parent.disconnectedCallback();
          }
        }
      }
    }, {
      key: "mountChildren",
      value: function mountChildren(child) {
        var _this10 = this;
        var skipTriggerEvent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : isInFragment(child);
        if (this.inited) {
          if (!child.isConnected) {
            child.ownerDocument = this.document;
            child.isConnected = true;
            if (!skipTriggerEvent) {
              if (child.isMutationObserved) {
                child.dispatchEvent(mountedEvent);
              } else {
                mountedEvent.target = child;
                this.dispatchEvent(mountedEvent, true);
              }
            }
          }
        } else {
          console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", "appended child: ", child.nodeName);
        }
        child.childNodes.forEach(function(c5) {
          _this10.mountChildren(c5, skipTriggerEvent);
        });
        if (child.isCustomElement) {
          if (child.connectedCallback) {
            child.connectedCallback();
          }
        }
      }
    }, {
      key: "mountFragment",
      value: function mountFragment(child) {
        this.mountChildren(child, false);
      }
    }, {
      key: "client2Viewport",
      value: function client2Viewport(client) {
        return this.getEventService().client2Viewport(client);
      }
    }, {
      key: "viewport2Client",
      value: function viewport2Client(canvas) {
        return this.getEventService().viewport2Client(canvas);
      }
    }, {
      key: "viewport2Canvas",
      value: function viewport2Canvas(viewport) {
        return this.getEventService().viewport2Canvas(viewport);
      }
    }, {
      key: "canvas2Viewport",
      value: function canvas2Viewport(canvas) {
        return this.getEventService().canvas2Viewport(canvas);
      }
      /**
       * @deprecated
       * @alias client2Viewport
       */
    }, {
      key: "getPointByClient",
      value: function getPointByClient(clientX, clientY) {
        return this.client2Viewport({
          x: clientX,
          y: clientY
        });
      }
      /**
       * @deprecated
       * @alias viewport2Client
       */
    }, {
      key: "getClientByPoint",
      value: function getClientByPoint(x3, y3) {
        return this.viewport2Client({
          x: x3,
          y: y3
        });
      }
    }]);
  }(EventTarget);

  // node_modules/@antv/g-camera-api/dist/index.esm.js
  var AdvancedCamera = /* @__PURE__ */ function(_Camera) {
    function AdvancedCamera2() {
      var _this;
      _classCallCheck(this, AdvancedCamera2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, AdvancedCamera2, [].concat(args));
      _this.landmarks = [];
      return _this;
    }
    _inherits(AdvancedCamera2, _Camera);
    return _createClass(AdvancedCamera2, [{
      key: "rotate",
      value: (
        /**
         * Changes the azimuth and elevation with respect to the current camera axes
         * @param {Number} azimuth the relative azimuth
         * @param {Number} elevation the relative elevation
         * @param {Number} roll the relative roll
         */
        function rotate5(azimuth, elevation, roll) {
          this.relElevation = getAngle2(elevation);
          this.relAzimuth = getAngle2(azimuth);
          this.relRoll = getAngle2(roll);
          this.elevation += this.relElevation;
          this.azimuth += this.relAzimuth;
          this.roll += this.relRoll;
          if (this.type === CameraType.EXPLORING) {
            var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relElevation));
            var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relAzimuth));
            var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad(this.relRoll));
            var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
            rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
            var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
            mat4_exports.translate(this.matrix, this.matrix, [0, 0, -this.distance]);
            mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
            mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
          } else {
            if (Math.abs(this.elevation) > 90) {
              return this;
            }
            this.computeMatrix();
          }
          this._getAxes();
          if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
            this._getPosition();
          } else if (this.type === CameraType.TRACKING) {
            this._getFocalPoint();
          }
          this._update();
          return this;
        }
      )
      /**
       * 沿水平(right) & 垂直(up)平移相机
       */
    }, {
      key: "pan",
      value: function pan(tx, ty) {
        var coords = createVec3(tx, ty, 0);
        var pos = vec3_exports.clone(this.position);
        vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.right, coords[0]));
        vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.up, coords[1]));
        this._setPosition(pos);
        this.triggerUpdate();
        return this;
      }
      /**
       * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢
       */
    }, {
      key: "dolly",
      value: function dolly(value2) {
        var n2 = this.forward;
        var pos = vec3_exports.clone(this.position);
        var step2 = value2 * this.dollyingStep;
        var updatedDistance = this.distance + value2 * this.dollyingStep;
        step2 = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;
        pos[0] += step2 * n2[0];
        pos[1] += step2 * n2[1];
        pos[2] += step2 * n2[2];
        this._setPosition(pos);
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getDistance();
        } else if (this.type === CameraType.TRACKING) {
          vec3_exports.add(this.focalPoint, pos, this.distanceVector);
        }
        this.triggerUpdate();
        return this;
      }
    }, {
      key: "cancelLandmarkAnimation",
      value: function cancelLandmarkAnimation() {
        if (this.landmarkAnimationID !== void 0) {
          this.canvas.cancelAnimationFrame(this.landmarkAnimationID);
        }
      }
    }, {
      key: "createLandmark",
      value: function createLandmark(name2) {
        var _position$, _position$2, _focalPoint$, _focalPoint$2;
        var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var _params$position = params.position, position = _params$position === void 0 ? this.position : _params$position, _params$focalPoint = params.focalPoint, focalPoint = _params$focalPoint === void 0 ? this.focalPoint : _params$focalPoint, roll = params.roll, zoom = params.zoom;
        var camera = new runtime.CameraContribution();
        camera.setType(this.type, void 0);
        camera.setPosition(position[0], (_position$ = position[1]) !== null && _position$ !== void 0 ? _position$ : this.position[1], (_position$2 = position[2]) !== null && _position$2 !== void 0 ? _position$2 : this.position[2]);
        camera.setFocalPoint(focalPoint[0], (_focalPoint$ = focalPoint[1]) !== null && _focalPoint$ !== void 0 ? _focalPoint$ : this.focalPoint[1], (_focalPoint$2 = focalPoint[2]) !== null && _focalPoint$2 !== void 0 ? _focalPoint$2 : this.focalPoint[2]);
        camera.setRoll(roll !== null && roll !== void 0 ? roll : this.roll);
        camera.setZoom(zoom !== null && zoom !== void 0 ? zoom : this.zoom);
        var landmark = {
          name: name2,
          matrix: mat4_exports.clone(camera.getWorldTransform()),
          right: vec3_exports.clone(camera.right),
          up: vec3_exports.clone(camera.up),
          forward: vec3_exports.clone(camera.forward),
          position: vec3_exports.clone(camera.getPosition()),
          focalPoint: vec3_exports.clone(camera.getFocalPoint()),
          distanceVector: vec3_exports.clone(camera.getDistanceVector()),
          distance: camera.getDistance(),
          dollyingStep: camera.getDollyingStep(),
          azimuth: camera.getAzimuth(),
          elevation: camera.getElevation(),
          roll: camera.getRoll(),
          relAzimuth: camera.relAzimuth,
          relElevation: camera.relElevation,
          relRoll: camera.relRoll,
          zoom: camera.getZoom()
        };
        this.landmarks.push(landmark);
        return landmark;
      }
    }, {
      key: "gotoLandmark",
      value: function gotoLandmark(name2) {
        var _this2 = this;
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var landmark = isString2(name2) ? this.landmarks.find(function(l2) {
          return l2.name === name2;
        }) : name2;
        if (landmark) {
          var _ref = isNumber2(options) ? {
            duration: options
          } : options, _ref$easing = _ref.easing, easing = _ref$easing === void 0 ? "linear" : _ref$easing, _ref$duration = _ref.duration, duration = _ref$duration === void 0 ? 100 : _ref$duration, _ref$easingFunction = _ref.easingFunction, easingFunction = _ref$easingFunction === void 0 ? void 0 : _ref$easingFunction, _ref$onfinish = _ref.onfinish, onfinish = _ref$onfinish === void 0 ? void 0 : _ref$onfinish, _ref$onframe = _ref.onframe, onframe = _ref$onframe === void 0 ? void 0 : _ref$onframe;
          var epsilon4 = 0.01;
          this.cancelLandmarkAnimation();
          var destPosition = landmark.position;
          var destFocalPoint = landmark.focalPoint;
          var destZoom = landmark.zoom;
          var destRoll = landmark.roll;
          var easingFunc = easingFunction || runtime.EasingFunction(easing);
          var timeStart;
          var end = function end2() {
            _this2.setFocalPoint(destFocalPoint);
            _this2.setPosition(destPosition);
            _this2.setRoll(destRoll);
            _this2.setZoom(destZoom);
            _this2.computeMatrix();
            _this2.triggerUpdate();
            onfinish === null || onfinish === void 0 || onfinish();
          };
          if (duration === 0) return end();
          var _animate = function animate2(timestamp) {
            if (timeStart === void 0) {
              timeStart = timestamp;
            }
            var elapsed = timestamp - timeStart;
            if (elapsed >= duration) {
              end();
              return;
            }
            var t = easingFunc(elapsed / duration);
            var interFocalPoint = vec3_exports.create();
            var interPosition = vec3_exports.create();
            var interZoom = 1;
            var interRoll = 0;
            vec3_exports.lerp(interFocalPoint, _this2.focalPoint, destFocalPoint, t);
            vec3_exports.lerp(interPosition, _this2.position, destPosition, t);
            interRoll = _this2.roll * (1 - t) + destRoll * t;
            interZoom = _this2.zoom * (1 - t) + destZoom * t;
            _this2.setFocalPoint(interFocalPoint);
            _this2.setPosition(interPosition);
            _this2.setRoll(interRoll);
            _this2.setZoom(interZoom);
            var dist5 = vec3_exports.dist(interFocalPoint, destFocalPoint) + vec3_exports.dist(interPosition, destPosition);
            if (dist5 <= epsilon4 && destZoom === void 0 && destRoll === void 0) {
              return end();
            }
            _this2.computeMatrix();
            _this2.triggerUpdate();
            if (elapsed < duration) {
              onframe === null || onframe === void 0 || onframe(t);
              _this2.landmarkAnimationID = _this2.canvas.requestAnimationFrame(_animate);
            }
          };
          this.canvas.requestAnimationFrame(_animate);
        }
      }
      /**
       * Sets the camera to a distance such that the area covered by the bounding box is viewed.
       */
      // shot(displayObject: DisplayObject) {
      //   const aabb = displayObject.getBounds();
      //   if (!AABB.isEmpty(aabb)) {
      //     this.setElevation(0);
      //     this.setAzimuth(0);
      //     this.setRoll(0);
      //     const { halfExtents, center } = aabb;
      //     const maxDim = Math.max(halfExtents[0] * 2, halfExtents[1] * 2);
      //     const cc = center.map((c: number) => Math.round(c * 1000) / 1000) as [number, number, number];
      //     if (maxDim !== 0) {
      //       const d = (1.5 * maxDim) / Math.tan(this.fov * DEG_2_RAD);
      //       this.setPosition([cc[0], cc[1], cc[2] + d]);
      //     }
      //     this.setFocalPoint(cc);
      //   }
      // }
    }]);
  }(Camera);
  runtime.CameraContribution = AdvancedCamera;

  // node_modules/@antv/g-web-animations-api/dist/index.esm.js
  var AnimationEvent = /* @__PURE__ */ function(_FederatedEvent) {
    function AnimationEvent2(manager, target, currentTime, timelineTime) {
      var _this;
      _classCallCheck(this, AnimationEvent2);
      _this = _callSuper(this, AnimationEvent2, [manager]);
      _this.currentTime = currentTime;
      _this.timelineTime = timelineTime;
      _this.target = target;
      _this.type = "finish";
      _this.bubbles = false;
      _this.currentTarget = target;
      _this.defaultPrevented = false;
      _this.eventPhase = _this.AT_TARGET;
      _this.timeStamp = Date.now();
      _this.currentTime = currentTime;
      _this.timelineTime = timelineTime;
      return _this;
    }
    _inherits(AnimationEvent2, _FederatedEvent);
    return _createClass(AnimationEvent2);
  }(FederatedEvent);
  var sequenceNumber = 0;
  var Animation = /* @__PURE__ */ function() {
    function Animation2(effect, timeline) {
      var _this$effect;
      _classCallCheck(this, Animation2);
      this.currentTimePending = false;
      this._idle = true;
      this._paused = false;
      this._finishedFlag = true;
      this._currentTime = 0;
      this._playbackRate = 1;
      this._inTimeline = true;
      this.effect = effect;
      effect.animation = this;
      this.timeline = timeline;
      this.id = "".concat(sequenceNumber++);
      this._inEffect = !!this.effect.update(0);
      this._totalDuration = Number((_this$effect = this.effect) === null || _this$effect === void 0 ? void 0 : _this$effect.getComputedTiming().endTime);
      this._holdTime = 0;
      this._paused = false;
      this.oldPlayState = "idle";
      this.updatePromises();
    }
    return _createClass(Animation2, [{
      key: "pending",
      get: (
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/effect
         */
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/timeline
         */
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/id
         */
        // animation: InternalAnimation | null;
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
         */
        function get2() {
          return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;
        }
      )
    }, {
      key: "playState",
      get: function get2() {
        if (this._idle) return "idle";
        if (this._isFinished) return "finished";
        if (this._paused) return "paused";
        return "running";
      }
      /**
       * record previos state
       */
    }, {
      key: "ready",
      get: (
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
         * @example
          animation.pause();
          animation.ready.then(function() {
            // Displays 'running'
            alert(animation.playState);
          });
          animation.play();
         */
        function get2() {
          var _this = this;
          if (!this.readyPromise) {
            if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
              this.timeline.animationsWithPromises.push(this);
            }
            this.readyPromise = new Promise(function(resolve, reject) {
              _this.resolveReadyPromise = function() {
                resolve(_this);
              };
              _this.rejectReadyPromise = function() {
                reject(new Error());
              };
            });
            if (!this.pending) {
              this.resolveReadyPromise();
            }
          }
          return this.readyPromise;
        }
      )
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
       * @example
        Promise.all(
          elem.getAnimations().map(
            function(animation) {
              return animation.finished
            }
          )
        ).then(
          function() {
            return elem.remove();
          }
        );
       */
    }, {
      key: "finished",
      get: function get2() {
        var _this2 = this;
        if (!this.finishedPromise) {
          if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
            this.timeline.animationsWithPromises.push(this);
          }
          this.finishedPromise = new Promise(function(resolve, reject) {
            _this2.resolveFinishedPromise = function() {
              resolve(_this2);
            };
            _this2.rejectFinishedPromise = function() {
              reject(new Error());
            };
          });
          if (this.playState === "finished") {
            this.resolveFinishedPromise();
          }
        }
        return this.finishedPromise;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/onfinish
       */
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/oncancel
       */
      /**
       * get called after each frame when running
       */
    }, {
      key: "currentTime",
      get: function get2() {
        this.updatePromises();
        return this._idle || this.currentTimePending ? null : this._currentTime;
      },
      set: function set8(newTime) {
        newTime = Number(newTime);
        if (isNaN(newTime)) return;
        this.timeline.restart();
        if (!this._paused && this._startTime !== null) {
          var _this$timeline;
          this._startTime = Number((_this$timeline = this.timeline) === null || _this$timeline === void 0 ? void 0 : _this$timeline.currentTime) - newTime / this.playbackRate;
        }
        this.currentTimePending = false;
        if (this._currentTime === newTime) {
          return;
        }
        if (this._idle) {
          this._idle = false;
          this._paused = true;
        }
        this.tickCurrentTime(newTime, true);
        this.timeline.applyDirtiedAnimation(this);
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/startTime
       */
    }, {
      key: "startTime",
      get: function get2() {
        return this._startTime;
      },
      set: function set8(newTime) {
        if (newTime !== null) {
          this.updatePromises();
          newTime = Number(newTime);
          if (isNaN(newTime)) return;
          if (this._paused || this._idle) return;
          this._startTime = newTime;
          this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);
          this.timeline.applyDirtiedAnimation(this);
          this.updatePromises();
        }
      }
    }, {
      key: "playbackRate",
      get: function get2() {
        return this._playbackRate;
      },
      set: function set8(value2) {
        if (value2 === this._playbackRate) {
          return;
        }
        this.updatePromises();
        var oldCurrentTime = this.currentTime;
        this._playbackRate = value2;
        this.startTime = null;
        if (this.playState !== "paused" && this.playState !== "idle") {
          this._finishedFlag = false;
          this._idle = false;
          this.ensureAlive();
          this.timeline.applyDirtiedAnimation(this);
        }
        if (oldCurrentTime !== null) {
          this.currentTime = oldCurrentTime;
        }
        this.updatePromises();
      }
    }, {
      key: "_isFinished",
      get: function get2() {
        return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);
      }
    }, {
      key: "totalDuration",
      get: function get2() {
        return this._totalDuration;
      }
    }, {
      key: "_needsTick",
      get: function get2() {
        return this.pending || this.playState === "running" || !this._finishedFlag;
      }
    }, {
      key: "updatePromises",
      value: function updatePromises() {
        var oldPlayState = this.oldPlayState;
        var newPlayState = this.pending ? "pending" : this.playState;
        if (this.readyPromise && newPlayState !== oldPlayState) {
          if (newPlayState === "idle") {
            this.rejectReadyPromise();
            this.readyPromise = void 0;
          } else if (oldPlayState === "pending") {
            this.resolveReadyPromise();
          } else if (newPlayState === "pending") {
            this.readyPromise = void 0;
          }
        }
        if (this.finishedPromise && newPlayState !== oldPlayState) {
          if (newPlayState === "idle") {
            this.rejectFinishedPromise();
            this.finishedPromise = void 0;
          } else if (newPlayState === "finished") {
            this.resolveFinishedPromise();
          } else if (oldPlayState === "finished") {
            this.finishedPromise = void 0;
          }
        }
        this.oldPlayState = newPlayState;
        return this.readyPromise || this.finishedPromise;
      }
    }, {
      key: "play",
      value: function play() {
        this.updatePromises();
        this._paused = false;
        if (this._isFinished || this._idle) {
          this.rewind();
          this._startTime = null;
        }
        this._finishedFlag = false;
        this._idle = false;
        this.ensureAlive();
        this.timeline.applyDirtiedAnimation(this);
        if (this.timeline.animations.indexOf(this) === -1) {
          this.timeline.animations.push(this);
        }
        this.updatePromises();
      }
    }, {
      key: "pause",
      value: function pause() {
        this.updatePromises();
        if (this.currentTime) {
          this._holdTime = this.currentTime;
        }
        if (!this._isFinished && !this._paused && !this._idle) {
          this.currentTimePending = true;
        } else if (this._idle) {
          this.rewind();
          this._idle = false;
        }
        this._startTime = null;
        this._paused = true;
        this.updatePromises();
      }
    }, {
      key: "finish",
      value: function finish() {
        this.updatePromises();
        if (this._idle) return;
        this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
        this._startTime = this._totalDuration - this.currentTime;
        this.currentTimePending = false;
        this.timeline.applyDirtiedAnimation(this);
        this.updatePromises();
      }
    }, {
      key: "cancel",
      value: function cancel2() {
        var _this3 = this;
        this.updatePromises();
        if (!this._inEffect) return;
        this._inEffect = false;
        this._idle = true;
        this._paused = false;
        this._finishedFlag = true;
        this._currentTime = 0;
        this._startTime = null;
        this.effect.update(null);
        this.timeline.applyDirtiedAnimation(this);
        this.updatePromises();
        if (this.oncancel) {
          var event = new AnimationEvent(null, this, this.currentTime, null);
          setTimeout(function() {
            _this3.oncancel(event);
          });
        }
      }
    }, {
      key: "reverse",
      value: function reverse() {
        this.updatePromises();
        var oldCurrentTime = this.currentTime;
        this.playbackRate *= -1;
        this.play();
        if (oldCurrentTime !== null) {
          this.currentTime = oldCurrentTime;
        }
        this.updatePromises();
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/updatePlaybackRate
       */
    }, {
      key: "updatePlaybackRate",
      value: function updatePlaybackRate(playbackRate) {
        this.playbackRate = playbackRate;
      }
    }, {
      key: "targetAnimations",
      value: function targetAnimations() {
        var _this$effect2;
        var target = (_this$effect2 = this.effect) === null || _this$effect2 === void 0 ? void 0 : _this$effect2.target;
        return target.getAnimations();
      }
    }, {
      key: "markTarget",
      value: function markTarget() {
        var animations = this.targetAnimations();
        if (animations.indexOf(this) === -1) {
          animations.push(this);
        }
      }
    }, {
      key: "unmarkTarget",
      value: function unmarkTarget() {
        var animations = this.targetAnimations();
        var index4 = animations.indexOf(this);
        if (index4 !== -1) {
          animations.splice(index4, 1);
        }
      }
    }, {
      key: "tick",
      value: function tick3(timelineTime, isAnimationFrame) {
        if (!this._idle && !this._paused) {
          if (this._startTime === null) {
            if (isAnimationFrame) {
              this.startTime = timelineTime - this._currentTime / this.playbackRate;
            }
          } else if (!this._isFinished) {
            this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
          }
        }
        if (isAnimationFrame) {
          this.currentTimePending = false;
          this.fireEvents(timelineTime);
        }
      }
    }, {
      key: "rewind",
      value: function rewind() {
        if (this.playbackRate >= 0) {
          this.currentTime = 0;
        } else if (this._totalDuration < Infinity) {
          this.currentTime = this._totalDuration;
        } else {
          throw new Error("Unable to rewind negative playback rate animation with infinite duration");
        }
      }
    }, {
      key: "persist",
      value: function persist() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "addEventListener",
      value: function addEventListener2(type, listener, options) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener2(type, listener, options) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent4(event) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      }
    }, {
      key: "commitStyles",
      value: (
        // replaceState: AnimationReplaceState;
        function commitStyles() {
          throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
        }
      )
    }, {
      key: "ensureAlive",
      value: function ensureAlive() {
        if (this.playbackRate < 0 && this.currentTime === 0) {
          var _this$effect3;
          this._inEffect = !!((_this$effect3 = this.effect) !== null && _this$effect3 !== void 0 && _this$effect3.update(-1));
        } else {
          var _this$effect4;
          this._inEffect = !!((_this$effect4 = this.effect) !== null && _this$effect4 !== void 0 && _this$effect4.update(this.currentTime));
        }
        if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
          this._inTimeline = true;
          this.timeline.animations.push(this);
        }
      }
    }, {
      key: "tickCurrentTime",
      value: function tickCurrentTime(newTime, ignoreLimit) {
        if (newTime !== this._currentTime) {
          this._currentTime = newTime;
          if (this._isFinished && !ignoreLimit) {
            this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
          }
          this.ensureAlive();
        }
      }
    }, {
      key: "fireEvents",
      value: function fireEvents(baseTime) {
        var _this4 = this;
        if (this._isFinished) {
          if (!this._finishedFlag) {
            if (this.onfinish) {
              var event = new AnimationEvent(null, this, this.currentTime, baseTime);
              setTimeout(function() {
                if (_this4.onfinish) {
                  _this4.onfinish(event);
                }
              });
            }
            this._finishedFlag = true;
          }
        } else {
          if (this.onframe && this.playState === "running") {
            var _event = new AnimationEvent(null, this, this.currentTime, baseTime);
            this.onframe(_event);
          }
          this._finishedFlag = false;
        }
      }
    }]);
  }();
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 1e-3;
  var SUBDIVISION_PRECISION = 1e-7;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 1 / (kSplineTableSize - 1);
  var float32ArraySupported = typeof Float32Array === "function";
  var A2 = function A3(aA1, aA2) {
    return 1 - 3 * aA2 + 3 * aA1;
  };
  var B2 = function B3(aA1, aA2) {
    return 3 * aA2 - 6 * aA1;
  };
  var C2 = function C3(aA1) {
    return 3 * aA1;
  };
  var calcBezier = function calcBezier2(aT, aA1, aA2) {
    return ((A2(aA1, aA2) * aT + B2(aA1, aA2)) * aT + C2(aA1)) * aT;
  };
  var getSlope = function getSlope2(aT, aA1, aA2) {
    return 3 * A2(aA1, aA2) * aT * aT + 2 * B2(aA1, aA2) * aT + C2(aA1);
  };
  var binarySubdivide = function binarySubdivide2(aX, aA, aB, mX1, mX2) {
    var currentX;
    var currentT;
    var i = 0;
    do {
      currentT = aA + (aB - aA) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0) aB = currentT;
      else aA = currentT;
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
  };
  var newtonRaphsonIterate = function newtonRaphsonIterate2(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0) return aGuessT;
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  };
  var bezier2 = function bezier3(mX1, mY1, mX2, mY2) {
    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) throw new Error("bezier x values must be in [0, 1] range");
    if (mX1 === mY1 && mX2 === mY2) return function(t) {
      return t;
    };
    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    for (var i = 0; i < kSplineTableSize; ++i) {
      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
    var getTForX = function getTForX2(aX) {
      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;
      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) intervalStart += kSampleStepSize;
      --currentSample;
      var dist5 = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist5 * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);
      if (initialSlope >= NEWTON_MIN_SLOPE) return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      if (initialSlope === 0) return guessForT;
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    };
    return function(t) {
      if (t === 0 || t === 1) return t;
      return calcBezier(getTForX(t), mY1, mY2);
    };
  };
  var convertToDash = function convertToDash2(str7) {
    str7 = str7.replace(/([A-Z])/g, function(letter) {
      return "-".concat(letter.toLowerCase());
    });
    return str7.charAt(0) === "-" ? str7.substring(1) : str7;
  };
  var Quad = function Quad2(t) {
    return Math.pow(t, 2);
  };
  var Cubic = function Cubic2(t) {
    return Math.pow(t, 3);
  };
  var Quart = function Quart2(t) {
    return Math.pow(t, 4);
  };
  var Quint = function Quint2(t) {
    return Math.pow(t, 5);
  };
  var Expo = function Expo2(t) {
    return Math.pow(t, 6);
  };
  var Sine = function Sine2(t) {
    return 1 - Math.cos(t * Math.PI / 2);
  };
  var Circ = function Circ2(t) {
    return 1 - Math.sqrt(1 - t * t);
  };
  var Back = function Back2(t) {
    return t * t * (3 * t - 2);
  };
  var Bounce = function Bounce2(t) {
    var pow22;
    var b = 4;
    while (t < ((pow22 = Math.pow(2, --b)) - 1) / 11) {
    }
    return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow22 * 3 - 2) / 22 - t, 2);
  };
  var Elastic = function Elastic2(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var _params = _slicedToArray(params, 2), _params$ = _params[0], amplitude = _params$ === void 0 ? 1 : _params$, _params$2 = _params[1], period = _params$2 === void 0 ? 0.5 : _params$2;
    var a3 = clamp_default(Number(amplitude), 1, 10);
    var p2 = clamp_default(Number(period), 0.1, 2);
    if (t === 0 || t === 1) return t;
    return -a3 * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p2 / (Math.PI * 2) * Math.asin(1 / a3)) * (Math.PI * 2) / p2);
  };
  var Spring = function Spring2(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var duration = arguments.length > 2 ? arguments[2] : void 0;
    var _params2 = _slicedToArray(params, 4), _params2$ = _params2[0], mass = _params2$ === void 0 ? 1 : _params2$, _params2$2 = _params2[1], stiffness = _params2$2 === void 0 ? 100 : _params2$2, _params2$3 = _params2[2], damping = _params2$3 === void 0 ? 10 : _params2$3, _params2$4 = _params2[3], velocity = _params2$4 === void 0 ? 0 : _params2$4;
    mass = clamp_default(mass, 0.1, 1e3);
    stiffness = clamp_default(stiffness, 0.1, 1e3);
    damping = clamp_default(damping, 0.1, 1e3);
    velocity = clamp_default(velocity, 0.1, 1e3);
    var w0 = Math.sqrt(stiffness / mass);
    var zeta = damping / (2 * Math.sqrt(stiffness * mass));
    var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
    var a3 = 1;
    var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
    var progress = duration ? duration * t / 1e3 : t;
    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a3 * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a3 + b * progress) * Math.exp(-progress * w0);
    }
    if (t === 0 || t === 1) return t;
    return 1 - progress;
  };
  var Steps = function Steps2(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var _ref = params, _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], steps = _ref2$ === void 0 ? 10 : _ref2$, type = _ref2[1];
    var trunc = type === "start" ? Math.ceil : Math.floor;
    return trunc(clamp_default(t, 0, 1) * steps) / steps;
  };
  var Bezier = function Bezier2(t) {
    var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var _params3 = _slicedToArray(params, 4), mX1 = _params3[0], mY1 = _params3[1], mX2 = _params3[2], mY2 = _params3[3];
    return bezier2(mX1, mY1, mX2, mY2)(t);
  };
  var easein = bezier2(0.42, 0, 1, 1);
  var EaseOut = function EaseOut2(ease2) {
    return function(t) {
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var duration = arguments.length > 2 ? arguments[2] : void 0;
      return 1 - ease2(1 - t, params, duration);
    };
  };
  var EaseInOut = function EaseInOut2(ease2) {
    return function(t) {
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var duration = arguments.length > 2 ? arguments[2] : void 0;
      return t < 0.5 ? ease2(t * 2, params, duration) / 2 : 1 - ease2(t * -2 + 2, params, duration) / 2;
    };
  };
  var EaseOutIn = function EaseOutIn2(ease2) {
    return function(t) {
      var params = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var duration = arguments.length > 2 ? arguments[2] : void 0;
      return t < 0.5 ? (1 - ease2(1 - t * 2, params, duration)) / 2 : (ease2(t * 2 - 1, params, duration) + 1) / 2;
    };
  };
  var EasingFunctions = {
    steps: Steps,
    "step-start": function stepStart(t) {
      return Steps(t, [1, "start"]);
    },
    "step-end": function stepEnd(t) {
      return Steps(t, [1, "end"]);
    },
    linear: function linear(t) {
      return t;
    },
    "cubic-bezier": Bezier,
    ease: function ease(t) {
      return Bezier(t, [0.25, 0.1, 0.25, 1]);
    },
    "in": easein,
    out: EaseOut(easein),
    "in-out": EaseInOut(easein),
    "out-in": EaseOutIn(easein),
    "in-quad": Quad,
    "out-quad": EaseOut(Quad),
    "in-out-quad": EaseInOut(Quad),
    "out-in-quad": EaseOutIn(Quad),
    "in-cubic": Cubic,
    "out-cubic": EaseOut(Cubic),
    "in-out-cubic": EaseInOut(Cubic),
    "out-in-cubic": EaseOutIn(Cubic),
    "in-quart": Quart,
    "out-quart": EaseOut(Quart),
    "in-out-quart": EaseInOut(Quart),
    "out-in-quart": EaseOutIn(Quart),
    "in-quint": Quint,
    "out-quint": EaseOut(Quint),
    "in-out-quint": EaseInOut(Quint),
    "out-in-quint": EaseOutIn(Quint),
    "in-expo": Expo,
    "out-expo": EaseOut(Expo),
    "in-out-expo": EaseInOut(Expo),
    "out-in-expo": EaseOutIn(Expo),
    "in-sine": Sine,
    "out-sine": EaseOut(Sine),
    "in-out-sine": EaseInOut(Sine),
    "out-in-sine": EaseOutIn(Sine),
    "in-circ": Circ,
    "out-circ": EaseOut(Circ),
    "in-out-circ": EaseInOut(Circ),
    "out-in-circ": EaseOutIn(Circ),
    "in-back": Back,
    "out-back": EaseOut(Back),
    "in-out-back": EaseInOut(Back),
    "out-in-back": EaseOutIn(Back),
    "in-bounce": Bounce,
    "out-bounce": EaseOut(Bounce),
    "in-out-bounce": EaseInOut(Bounce),
    "out-in-bounce": EaseOutIn(Bounce),
    "in-elastic": Elastic,
    "out-elastic": EaseOut(Elastic),
    "in-out-elastic": EaseInOut(Elastic),
    "out-in-elastic": EaseOutIn(Elastic),
    spring: Spring,
    "spring-in": Spring,
    "spring-out": EaseOut(Spring),
    "spring-in-out": EaseInOut(Spring),
    "spring-out-in": EaseOutIn(Spring)
  };
  var complexEasingSyntax = function complexEasingSyntax2(ease2) {
    return convertToDash(ease2).replace(/^ease-/, "").replace(/(\(|\s).+/, "").toLowerCase().trim();
  };
  var getEasingFunction = function getEasingFunction2(ease2) {
    return EasingFunctions[complexEasingSyntax(ease2)] || EasingFunctions.linear;
  };
  var linear2 = function linear3(x3) {
    return x3;
  };
  var Start = 1;
  var Middle = 0.5;
  var End = 0;
  function step(count4, pos) {
    return function(x3) {
      if (x3 >= 1) {
        return 1;
      }
      var stepSize = 1 / count4;
      x3 += pos * stepSize;
      return x3 - x3 % stepSize;
    };
  }
  var numberString = "\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*";
  var cubicBezierRe = new RegExp("cubic-bezier\\(".concat(numberString, ",").concat(numberString, ",").concat(numberString, ",").concat(numberString, "\\)"));
  var step1Re = /steps\(\s*(\d+)\s*\)/;
  var step2Re = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
  function parseEasingFunction(normalizedEasing) {
    var cubicData = cubicBezierRe.exec(normalizedEasing);
    if (cubicData) {
      return bezier2.apply(void 0, _toConsumableArray(cubicData.slice(1).map(Number)));
    }
    var step1Data = step1Re.exec(normalizedEasing);
    if (step1Data) {
      return step(Number(step1Data[1]), End);
    }
    var step2Data = step2Re.exec(normalizedEasing);
    if (step2Data) {
      return step(Number(step2Data[1]), {
        start: Start,
        middle: Middle,
        end: End
      }[step2Data[2]]);
    }
    return getEasingFunction(normalizedEasing);
  }
  function calculateActiveDuration(timing) {
    return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));
  }
  function repeatedDuration(timing) {
    var _timing$iterations;
    if (timing.duration === 0 || timing.iterations === 0) {
      return 0;
    }
    return (timing.duration === "auto" ? 0 : Number(timing.duration)) * ((_timing$iterations = timing.iterations) !== null && _timing$iterations !== void 0 ? _timing$iterations : 1);
  }
  var PhaseNone = 0;
  var PhaseBefore = 1;
  var PhaseAfter = 2;
  var PhaseActive = 3;
  function calculatePhase(activeDuration, localTime, timing) {
    if (localTime === null) {
      return PhaseNone;
    }
    var endTime = timing.endTime;
    if (localTime < Math.min(timing.delay, endTime)) {
      return PhaseBefore;
    }
    if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
      return PhaseAfter;
    }
    return PhaseActive;
  }
  function calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {
    switch (phase) {
      case PhaseBefore:
        if (fillMode === "backwards" || fillMode === "both") return 0;
        return null;
      case PhaseActive:
        return localTime - delay;
      case PhaseAfter:
        if (fillMode === "forwards" || fillMode === "both") return activeDuration;
        return null;
      case PhaseNone:
        return null;
    }
  }
  function calculateOverallProgress(iterationDuration, phase, iterations2, activeTime, iterationStart) {
    var overallProgress = iterationStart;
    if (iterationDuration === 0) {
      if (phase !== PhaseBefore) {
        overallProgress += iterations2;
      }
    } else {
      overallProgress += activeTime / iterationDuration;
    }
    return overallProgress;
  }
  function calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations2, activeTime, iterationDuration) {
    var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;
    if (simpleIterationProgress === 0 && phase === PhaseAfter && iterations2 !== 0 && (activeTime !== 0 || iterationDuration === 0)) {
      simpleIterationProgress = 1;
    }
    return simpleIterationProgress;
  }
  function calculateCurrentIteration(phase, iterations2, simpleIterationProgress, overallProgress) {
    if (phase === PhaseAfter && iterations2 === Infinity) {
      return Infinity;
    }
    if (simpleIterationProgress === 1) {
      return Math.floor(overallProgress) - 1;
    }
    return Math.floor(overallProgress);
  }
  function calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {
    var currentDirection = playbackDirection;
    if (playbackDirection !== "normal" && playbackDirection !== "reverse") {
      var d3 = currentIteration;
      if (playbackDirection === "alternate-reverse") {
        d3 += 1;
      }
      currentDirection = "normal";
      if (d3 !== Infinity && d3 % 2 !== 0) {
        currentDirection = "reverse";
      }
    }
    if (currentDirection === "normal") {
      return simpleIterationProgress;
    }
    return 1 - simpleIterationProgress;
  }
  function calculateIterationProgress(activeDuration, localTime, timing) {
    var phase = calculatePhase(activeDuration, localTime, timing);
    var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);
    if (activeTime === null) return null;
    var duration = timing.duration === "auto" ? 0 : timing.duration;
    var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);
    var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);
    var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);
    var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);
    timing.currentIteration = currentIteration;
    timing.progress = directedProgress;
    return timing.easingFunction(directedProgress);
  }
  function convertEffectInput(keyframes, timing, target) {
    var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);
    var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);
    return function(target2, fraction) {
      if (fraction !== null) {
        interpolations.filter(function(interpolation) {
          return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;
        }).forEach(function(interpolation) {
          var offsetFraction = fraction - interpolation.startOffset;
          var localDuration = interpolation.endOffset - interpolation.startOffset;
          var scaledLocalTime = localDuration === 0 ? 0 : offsetFraction / localDuration;
          target2.setAttribute(
            interpolation.property,
            interpolation.interpolation(scaledLocalTime),
            false,
            false
            // disable memoize
          );
        });
      } else {
        for (var property in propertySpecificKeyframeGroups) if (isNotReservedWord(property)) {
          target2.setAttribute(property, null);
        }
      }
    };
  }
  function isNotReservedWord(member) {
    return member !== "offset" && member !== "easing" && member !== "composite" && member !== "computedOffset";
  }
  function makePropertySpecificKeyframeGroups(keyframes, timing) {
    var propertySpecificKeyframeGroups = {};
    for (var i = 0; i < keyframes.length; i++) {
      for (var member in keyframes[i]) {
        if (isNotReservedWord(member)) {
          var propertySpecificKeyframe = {
            offset: keyframes[i].offset,
            computedOffset: keyframes[i].computedOffset,
            easing: keyframes[i].easing,
            easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,
            value: keyframes[i][member]
          };
          propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || [];
          propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
        }
      }
    }
    return propertySpecificKeyframeGroups;
  }
  function makeInterpolations(propertySpecificKeyframeGroups, target) {
    var interpolations = [];
    for (var groupName in propertySpecificKeyframeGroups) {
      var keyframes = propertySpecificKeyframeGroups[groupName];
      for (var i = 0; i < keyframes.length - 1; i++) {
        var startIndex = i;
        var endIndex = i + 1;
        var startOffset = keyframes[startIndex].computedOffset;
        var endOffset = keyframes[endIndex].computedOffset;
        var applyFrom = startOffset;
        var applyTo = endOffset;
        if (i === 0) {
          applyFrom = -Infinity;
          if (endOffset === 0) {
            endIndex = startIndex;
          }
        }
        if (i === keyframes.length - 2) {
          applyTo = Infinity;
          if (startOffset === 1) {
            startIndex = endIndex;
          }
        }
        interpolations.push({
          applyFrom,
          applyTo,
          startOffset: keyframes[startIndex].computedOffset,
          endOffset: keyframes[endIndex].computedOffset,
          easingFunction: keyframes[startIndex].easingFunction,
          property: groupName,
          interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)
        });
      }
    }
    interpolations.sort(function(leftInterpolation, rightInterpolation) {
      return leftInterpolation.startOffset - rightInterpolation.startOffset;
    });
    return interpolations;
  }
  var InterpolationFactory = function InterpolationFactory2(from, to, convertToString) {
    return function(f) {
      var interpolated = interpolate3(from, to, f);
      return isNumber2(interpolated) ? interpolated : convertToString(interpolated);
    };
  };
  function propertyInterpolation(property, left2, right2, target) {
    var metadata = propertyMetadataCache[property];
    if (metadata && metadata.syntax && metadata["int"]) {
      var propertyHandler = runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);
      if (propertyHandler) {
        var parser2 = propertyHandler.parser;
        var usedLeft = parser2 ? parser2(left2, target) : left2;
        var usedRight = parser2 ? parser2(right2, target) : right2;
        var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);
        if (interpolationArgs) {
          var interp = InterpolationFactory.apply(void 0, _toConsumableArray(interpolationArgs));
          return function(t) {
            if (t === 0) return left2;
            if (t === 1) return right2;
            return interp(t);
          };
        }
      }
    }
    return InterpolationFactory(false, true, function(bool) {
      return bool ? right2 : left2;
    });
  }
  function interpolate3(from, to, f) {
    if (typeof from === "number" && typeof to === "number") {
      return from * (1 - f) + to * f;
    }
    if (typeof from === "boolean" && typeof to === "boolean" || typeof from === "string" && typeof to === "string") {
      return f < 0.5 ? from : to;
    }
    if (Array.isArray(from) && Array.isArray(to)) {
      var fromLength = from.length;
      var toLength = to.length;
      var length5 = Math.max(fromLength, toLength);
      var r = [];
      for (var i = 0; i < length5; i++) {
        r.push(interpolate3(from[i < fromLength ? i : fromLength - 1], to[i < toLength ? i : toLength - 1], f));
      }
      return r;
    }
    throw new Error("Mismatched interpolation arguments ".concat(from, ":").concat(to));
  }
  var AnimationEffectTiming = /* @__PURE__ */ function() {
    function AnimationEffectTiming2() {
      _classCallCheck(this, AnimationEffectTiming2);
      this.delay = 0;
      this.direction = "normal";
      this.duration = "auto";
      this._easing = "linear";
      this.easingFunction = linear2;
      this.endDelay = 0;
      this.fill = "auto";
      this.iterationStart = 0;
      this.iterations = 1;
      this.currentIteration = null;
      this.progress = null;
    }
    return _createClass(AnimationEffectTiming2, [{
      key: "easing",
      get: function get2() {
        return this._easing;
      },
      set: function set8(value2) {
        this.easingFunction = parseEasingFunction(value2);
        this._easing = value2;
      }
    }]);
  }();
  function convertToArrayForm(effectInput) {
    var normalizedEffectInput = [];
    for (var property in effectInput) {
      if (property in ["easing", "offset", "composite"]) {
        continue;
      }
      var values = effectInput[property];
      if (!Array.isArray(values)) {
        values = [values];
      }
      var numKeyframes = values.length;
      for (var i = 0; i < numKeyframes; i++) {
        if (!normalizedEffectInput[i]) {
          var keyframe = {};
          if ("offset" in effectInput) {
            keyframe.offset = Number(effectInput.offset);
          }
          if ("easing" in effectInput) {
            keyframe.easing = effectInput.easing;
          }
          if ("composite" in effectInput) {
            keyframe.composite = effectInput.composite;
          }
          normalizedEffectInput[i] = keyframe;
        }
        if (values[i] !== void 0 && values[i] !== null) {
          normalizedEffectInput[i][property] = values[i];
        }
      }
    }
    normalizedEffectInput.sort(function(a3, b) {
      return (a3.computedOffset || 0) - (b.computedOffset || 0);
    });
    return normalizedEffectInput;
  }
  function normalizeKeyframes(effectInput, timing) {
    if (effectInput === null) {
      return [];
    }
    if (!Array.isArray(effectInput)) {
      effectInput = convertToArrayForm(effectInput);
    }
    var keyframes = effectInput.map(function(originalKeyframe) {
      var keyframe = {};
      if (timing !== null && timing !== void 0 && timing.composite) {
        keyframe.composite = "auto";
      }
      for (var member in originalKeyframe) {
        var memberValue = originalKeyframe[member];
        if (member === "offset") {
          if (memberValue !== null) {
            memberValue = Number(memberValue);
            if (!isFinite(memberValue)) throw new Error("Keyframe offsets must be numbers.");
            if (memberValue < 0 || memberValue > 1) throw new Error("Keyframe offsets must be between 0 and 1.");
            keyframe.computedOffset = memberValue;
          }
        } else if (member === "composite") {
          if (["replace", "add", "accumulate", "auto"].indexOf(memberValue) === -1) {
            throw new Error("".concat(memberValue, " compositing is not supported"));
          }
        } else ;
        keyframe[member] = memberValue;
      }
      if (keyframe.offset === void 0) {
        keyframe.offset = null;
      }
      if (keyframe.easing === void 0) {
        keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || "linear";
      }
      if (keyframe.composite === void 0) {
        keyframe.composite = "auto";
      }
      return keyframe;
    });
    var everyFrameHasOffset = true;
    var previousOffset = -Infinity;
    for (var i = 0; i < keyframes.length; i++) {
      var offset3 = keyframes[i].offset;
      if (!isNil(offset3)) {
        if (offset3 < previousOffset) {
          throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");
        }
        previousOffset = offset3;
      } else {
        everyFrameHasOffset = false;
      }
    }
    keyframes = keyframes.filter(function(keyframe) {
      return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
    });
    function spaceKeyframes() {
      var _keyframes$offset;
      var _keyframes = keyframes, length5 = _keyframes.length;
      keyframes[length5 - 1].computedOffset = Number((_keyframes$offset = keyframes[length5 - 1].offset) !== null && _keyframes$offset !== void 0 ? _keyframes$offset : 1);
      if (length5 > 1) {
        var _keyframes$0$offset;
        keyframes[0].computedOffset = Number((_keyframes$0$offset = keyframes[0].offset) !== null && _keyframes$0$offset !== void 0 ? _keyframes$0$offset : 0);
      }
      var previousIndex = 0;
      var previousOffset2 = Number(keyframes[0].computedOffset);
      for (var _i = 1; _i < length5; _i++) {
        var _offset = keyframes[_i].computedOffset;
        if (!isNil(_offset) && !isNil(previousOffset2)) {
          for (var j = 1; j < _i - previousIndex; j++) keyframes[previousIndex + j].computedOffset = previousOffset2 + (Number(_offset) - previousOffset2) * j / (_i - previousIndex);
          previousIndex = _i;
          previousOffset2 = Number(_offset);
        }
      }
    }
    if (!everyFrameHasOffset) spaceKeyframes();
    return keyframes;
  }
  var fills = "backwards|forwards|both|none".split("|");
  var directions = "reverse|alternate|alternate-reverse".split("|");
  function makeTiming(timingInput, forGroup) {
    var timing = new AnimationEffectTiming();
    if (forGroup) {
      timing.fill = "both";
      timing.duration = "auto";
    }
    if (typeof timingInput === "number" && !isNaN(timingInput)) {
      timing.duration = timingInput;
    } else if (timingInput !== void 0) {
      Object.keys(timingInput).forEach(function(property) {
        if (timingInput[property] !== void 0 && timingInput[property] !== null && timingInput[property] !== "auto") {
          if (typeof timing[property] === "number" || property === "duration") {
            if (typeof timingInput[property] !== "number" || isNaN(timingInput[property])) {
              return;
            }
          }
          if (property === "fill" && fills.indexOf(timingInput[property]) === -1) {
            return;
          }
          if (property === "direction" && directions.indexOf(timingInput[property]) === -1) {
            return;
          }
          timing[property] = timingInput[property];
        }
      });
    }
    return timing;
  }
  function normalizeTimingInput(timingInput, forGroup) {
    var _timingInput;
    timingInput = numericTimingToObject((_timingInput = timingInput) !== null && _timingInput !== void 0 ? _timingInput : {
      duration: "auto"
    });
    return makeTiming(timingInput, forGroup);
  }
  function numericTimingToObject(timingInput) {
    if (typeof timingInput === "number") {
      if (isNaN(timingInput)) {
        timingInput = {
          duration: "auto"
        };
      } else {
        timingInput = {
          duration: timingInput
        };
      }
    }
    return timingInput;
  }
  var KeyframeEffect = /* @__PURE__ */ function() {
    function KeyframeEffect2(target, effectInput, timingInput) {
      var _this = this;
      _classCallCheck(this, KeyframeEffect2);
      this.composite = "replace";
      this.iterationComposite = "replace";
      this.target = target;
      this.timing = normalizeTimingInput(timingInput, false);
      this.timing.effect = this;
      this.timing.activeDuration = calculateActiveDuration(this.timing);
      this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);
      this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);
      this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);
      var Proxy3 = runtime.globalThis.Proxy;
      this.computedTiming = Proxy3 ? new Proxy3(this.timing, {
        get: function get2(target2, prop) {
          if (prop === "duration") {
            return target2.duration === "auto" ? 0 : target2.duration;
          }
          if (prop === "fill") {
            return target2.fill === "auto" ? "none" : target2.fill;
          }
          if (prop === "localTime") {
            return _this.animation && _this.animation.currentTime || null;
          }
          if (prop === "currentIteration") {
            if (!_this.animation || _this.animation.playState !== "running") {
              return null;
            }
            return target2.currentIteration || 0;
          }
          if (prop === "progress") {
            if (!_this.animation || _this.animation.playState !== "running") {
              return null;
            }
            return target2.progress || 0;
          }
          return target2[prop];
        },
        set: function set8() {
          return true;
        }
      }) : this.timing;
    }
    return _createClass(KeyframeEffect2, [{
      key: "applyInterpolations",
      value: function applyInterpolations() {
        this.interpolations(this.target, Number(this.timeFraction));
      }
    }, {
      key: "update",
      value: function update(localTime) {
        if (localTime === null) {
          return false;
        }
        this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);
        return this.timeFraction !== null;
      }
    }, {
      key: "getKeyframes",
      value: function getKeyframes() {
        return this.normalizedKeyframes;
      }
    }, {
      key: "setKeyframes",
      value: function setKeyframes(keyframes) {
        this.normalizedKeyframes = normalizeKeyframes(keyframes);
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getComputedTiming
       */
    }, {
      key: "getComputedTiming",
      value: function getComputedTiming() {
        return this.computedTiming;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/getTiming
       */
    }, {
      key: "getTiming",
      value: function getTiming() {
        return this.timing;
      }
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEffect/updateTiming
       */
    }, {
      key: "updateTiming",
      value: function updateTiming(timing) {
        var _this2 = this;
        Object.keys(timing || {}).forEach(function(name2) {
          _this2.timing[name2] = timing[name2];
        });
      }
    }]);
  }();
  function compareAnimations(leftAnimation, rightAnimation) {
    return Number(leftAnimation.id) - Number(rightAnimation.id);
  }
  var AnimationTimeline = /* @__PURE__ */ function() {
    function AnimationTimeline2(document2) {
      var _this = this;
      _classCallCheck(this, AnimationTimeline2);
      this.animations = [];
      this.ticking = false;
      this.timelineTicking = false;
      this.hasRestartedThisFrame = false;
      this.animationsWithPromises = [];
      this.inTick = false;
      this.pendingEffects = [];
      this.currentTime = null;
      this.rafId = 0;
      this.rafCallbacks = [];
      this.webAnimationsNextTick = function(t) {
        _this.currentTime = t;
        _this.discardAnimations();
        if (_this.animations.length === 0) {
          _this.timelineTicking = false;
        } else {
          _this.requestAnimationFrame(_this.webAnimationsNextTick);
        }
      };
      this.processRafCallbacks = function(t) {
        var processing = _this.rafCallbacks;
        _this.rafCallbacks = [];
        if (t < Number(_this.currentTime)) t = Number(_this.currentTime);
        _this.animations.sort(compareAnimations);
        _this.animations = _this.tick(t, true, _this.animations)[0];
        processing.forEach(function(entry) {
          entry[1](t);
        });
        _this.applyPendingEffects();
      };
      this.document = document2;
    }
    return _createClass(AnimationTimeline2, [{
      key: "getAnimations",
      value: function getAnimations() {
        this.discardAnimations();
        return this.animations.slice();
      }
    }, {
      key: "isTicking",
      value: function isTicking() {
        return this.inTick;
      }
    }, {
      key: "play",
      value: function play(target, keyframes, options) {
        var effect = new KeyframeEffect(target, keyframes, options);
        var animation = new Animation(effect, this);
        this.animations.push(animation);
        this.restartWebAnimationsNextTick();
        animation.updatePromises();
        animation.play();
        animation.updatePromises();
        return animation;
      }
      // RAF is supposed to be the last script to occur before frame rendering but not
      // all browsers behave like this. This function is for synchonously updating an
      // animation's effects whenever its state is mutated by script to work around
      // incorrect script execution ordering by the browser.
    }, {
      key: "applyDirtiedAnimation",
      value: function applyDirtiedAnimation(animation) {
        var _this2 = this;
        if (this.inTick) {
          return;
        }
        animation.markTarget();
        var animations = animation.targetAnimations();
        animations.sort(compareAnimations);
        var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
        inactiveAnimations.forEach(function(animation2) {
          var index4 = _this2.animations.indexOf(animation2);
          if (index4 !== -1) {
            _this2.animations.splice(index4, 1);
          }
        });
        this.applyPendingEffects();
      }
    }, {
      key: "restart",
      value: function restart() {
        if (!this.ticking) {
          this.ticking = true;
          this.requestAnimationFrame(function() {
          });
          this.hasRestartedThisFrame = true;
        }
        return this.hasRestartedThisFrame;
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        this.document.defaultView.cancelAnimationFrame(this.frameId);
      }
    }, {
      key: "applyPendingEffects",
      value: function applyPendingEffects() {
        this.pendingEffects.forEach(function(effect) {
          effect === null || effect === void 0 || effect.applyInterpolations();
        });
        this.pendingEffects = [];
      }
    }, {
      key: "updateAnimationsPromises",
      value: function updateAnimationsPromises() {
        this.animationsWithPromises = this.animationsWithPromises.filter(function(animation) {
          return animation.updatePromises();
        });
      }
    }, {
      key: "discardAnimations",
      value: function discardAnimations() {
        this.updateAnimationsPromises();
        this.animations = this.animations.filter(function(animation) {
          return animation.playState !== "finished" && animation.playState !== "idle";
        });
      }
    }, {
      key: "restartWebAnimationsNextTick",
      value: function restartWebAnimationsNextTick() {
        if (!this.timelineTicking) {
          this.timelineTicking = true;
          this.requestAnimationFrame(this.webAnimationsNextTick);
        }
      }
    }, {
      key: "rAF",
      value: function rAF(f) {
        var id5 = this.rafId++;
        if (this.rafCallbacks.length === 0) {
          this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
        }
        this.rafCallbacks.push([id5, f]);
        return id5;
      }
    }, {
      key: "requestAnimationFrame",
      value: function requestAnimationFrame2(f) {
        var _this3 = this;
        return this.rAF(function(x3) {
          _this3.updateAnimationsPromises();
          f(x3);
          _this3.updateAnimationsPromises();
        });
      }
    }, {
      key: "tick",
      value: function tick3(t, isAnimationFrame, updatingAnimations) {
        var _this4 = this, _this$pendingEffects, _this$pendingEffects2;
        this.inTick = true;
        this.hasRestartedThisFrame = false;
        this.currentTime = t;
        this.ticking = false;
        var newPendingClears = [];
        var newPendingEffects = [];
        var activeAnimations = [];
        var inactiveAnimations = [];
        updatingAnimations.forEach(function(animation) {
          animation.tick(t, isAnimationFrame);
          if (!animation._inEffect) {
            newPendingClears.push(animation.effect);
            animation.unmarkTarget();
          } else {
            newPendingEffects.push(animation.effect);
            animation.markTarget();
          }
          if (animation._needsTick) _this4.ticking = true;
          var alive = animation._inEffect || animation._needsTick;
          animation._inTimeline = alive;
          if (alive) {
            activeAnimations.push(animation);
          } else {
            inactiveAnimations.push(animation);
          }
        });
        (_this$pendingEffects = this.pendingEffects).push.apply(_this$pendingEffects, newPendingClears);
        (_this$pendingEffects2 = this.pendingEffects).push.apply(_this$pendingEffects2, newPendingEffects);
        if (this.ticking) this.requestAnimationFrame(function() {
        });
        this.inTick = false;
        return [activeAnimations, inactiveAnimations];
      }
    }]);
  }();
  runtime.EasingFunction = parseEasingFunction;
  runtime.AnimationTimeline = AnimationTimeline;

  // node_modules/@antv/g2/esm/utils/selection.js
  function select(node) {
    return new Selection([node], null, node, node.ownerDocument);
  }
  var Selection = class _Selection {
    constructor(elements = null, data2 = null, parent = null, document2 = null, selections = [
      null,
      null,
      null,
      null,
      null
    ], transitions = [], updateElements = []) {
      this._elements = Array.from(elements);
      this._data = data2;
      this._parent = parent;
      this._document = document2;
      this._enter = selections[0];
      this._update = selections[1];
      this._exit = selections[2];
      this._merge = selections[3];
      this._split = selections[4];
      this._transitions = transitions;
      this._facetElements = updateElements;
    }
    selectAll(selector) {
      const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _Selection(elements, null, this._elements[0], this._document);
    }
    selectFacetAll(selector) {
      const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _Selection(this._elements, null, this._parent, this._document, void 0, void 0, elements);
    }
    /**
     * @todo Replace with querySelector which has bug now.
     */
    select(selector) {
      const element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
      return new _Selection([element], null, element, this._document);
    }
    append(node) {
      const callback = typeof node === "function" ? node : () => this.createElement(node);
      const elements = [];
      if (this._data !== null) {
        for (let i = 0; i < this._data.length; i++) {
          const d3 = this._data[i];
          const [datum, from] = Array.isArray(d3) ? d3 : [d3, null];
          const newElement = callback(datum, i);
          newElement.__data__ = datum;
          if (from !== null)
            newElement.__fromElements__ = from;
          this._parent.appendChild(newElement);
          elements.push(newElement);
        }
        return new _Selection(elements, null, this._parent, this._document);
      } else {
        for (let i = 0; i < this._elements.length; i++) {
          const element = this._elements[i];
          const datum = element.__data__;
          const newElement = callback(datum, i);
          element.appendChild(newElement);
          elements.push(newElement);
        }
        return new _Selection(elements, null, elements[0], this._document);
      }
    }
    maybeAppend(id5, node, className2) {
      const element = this._elements[0];
      const child = element.getElementById(id5);
      if (child) {
        return new _Selection([child], null, this._parent, this._document);
      }
      const newChild = typeof node === "string" ? this.createElement(node) : node();
      newChild.id = id5;
      if (className2)
        newChild.className = className2;
      element.appendChild(newChild);
      return new _Selection([newChild], null, this._parent, this._document);
    }
    /**
     * Bind data to elements, and produce three selection:
     * Enter: Selection with empty elements and data to be bind to elements.
     * Update: Selection with elements to be updated.
     * Exit: Selection with elements to be removed.
     */
    data(data2, id5 = (d3) => d3, groupId = () => null) {
      const enter = [];
      const update = [];
      const exit = new Set(this._elements);
      const merge2 = [];
      const split = /* @__PURE__ */ new Set();
      const keyElement = new Map(this._elements.map((d3, i) => [id5(d3.__data__, i), d3]));
      const keyUpdateElement = new Map(this._facetElements.map((d3, i) => [id5(d3.__data__, i), d3]));
      const groupKeyElements = group(this._elements, (d3) => groupId(d3.__data__));
      for (let i = 0; i < data2.length; i++) {
        const datum = data2[i];
        const key = id5(datum, i);
        const groupKey = groupId(datum, i);
        if (keyElement.has(key)) {
          const element = keyElement.get(key);
          element.__data__ = datum;
          element.__facet__ = false;
          update.push(element);
          exit.delete(element);
          keyElement.delete(key);
        } else if (keyUpdateElement.has(key)) {
          const element = keyUpdateElement.get(key);
          element.__data__ = datum;
          element.__facet__ = true;
          update.push(element);
          keyUpdateElement.delete(key);
        } else if (groupKeyElements.has(key)) {
          const group3 = groupKeyElements.get(key);
          merge2.push([datum, group3]);
          for (const element of group3)
            exit.delete(element);
          groupKeyElements.delete(key);
        } else if (keyElement.has(groupKey)) {
          const element = keyElement.get(groupKey);
          if (element.__toData__)
            element.__toData__.push(datum);
          else
            element.__toData__ = [datum];
          split.add(element);
          exit.delete(element);
        } else {
          enter.push(datum);
        }
      }
      const S = [
        new _Selection([], enter, this._parent, this._document),
        new _Selection(update, null, this._parent, this._document),
        new _Selection(exit, null, this._parent, this._document),
        new _Selection([], merge2, this._parent, this._document),
        new _Selection(split, null, this._parent, this._document)
      ];
      return new _Selection(this._elements, null, this._parent, this._document, S);
    }
    merge(other) {
      const elements = [...this._elements, ...other._elements];
      const transitions = [...this._transitions, ...other._transitions];
      return new _Selection(elements, null, this._parent, this._document, void 0, transitions);
    }
    createElement(type) {
      if (this._document) {
        return this._document.createElement(type, {});
      }
      const Ctor = _Selection.registry[type];
      if (Ctor)
        return new Ctor();
      return error2(`Unknown node type: ${type}`);
    }
    /**
     * Apply callback for each selection(enter, update, exit)
     * and merge them into one selection.
     */
    join(enter = (d3) => d3, update = (d3) => d3, exit = (d3) => d3.remove(), merge2 = (d3) => d3, split = (d3) => d3.remove()) {
      const newEnter = enter(this._enter);
      const newUpdate = update(this._update);
      const newExit = exit(this._exit);
      const newMerge = merge2(this._merge);
      const newSplit = split(this._split);
      return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
    }
    remove() {
      for (let i = 0; i < this._elements.length; i++) {
        const transition2 = this._transitions[i];
        if (transition2) {
          const T = Array.isArray(transition2) ? transition2 : [transition2];
          Promise.all(T.map((d3) => d3.finished)).then(() => {
            const element = this._elements[i];
            element.remove();
          });
        } else {
          const element = this._elements[i];
          element.remove();
        }
      }
      return new _Selection([], null, this._parent, this._document, void 0, this._transitions);
    }
    each(callback) {
      for (let i = 0; i < this._elements.length; i++) {
        const element = this._elements[i];
        const datum = element.__data__;
        callback(datum, i, element);
      }
      return this;
    }
    attr(key, value2) {
      const callback = typeof value2 !== "function" ? () => value2 : value2;
      return this.each(function(d3, i, element) {
        if (value2 !== void 0)
          element[key] = callback(d3, i, element);
      });
    }
    style(key, value2) {
      const callback = typeof value2 !== "function" ? () => value2 : value2;
      return this.each(function(d3, i, element) {
        if (value2 !== void 0)
          element.style[key] = callback(d3, i, element);
      });
    }
    transition(value2) {
      const callback = typeof value2 !== "function" ? () => value2 : value2;
      const { _transitions: T } = this;
      return this.each(function(d3, i, element) {
        T[i] = callback(d3, i, element);
      });
    }
    on(event, handler) {
      this.each(function(d3, i, element) {
        element.addEventListener(event, handler);
      });
      return this;
    }
    call(callback, ...args) {
      callback(this, ...args);
      return this;
    }
    node() {
      return this._elements[0];
    }
    nodes() {
      return this._elements;
    }
    transitions() {
      return this._transitions;
    }
    parent() {
      return this._parent;
    }
  };
  Selection.registry = {
    g: Group2,
    rect: Rect,
    circle: Circle,
    path: Path2,
    text: Text,
    ellipse: Ellipse,
    image: Image2,
    line: Line,
    polygon: Polygon,
    polyline: Polyline,
    html: HTML
  };

  // node_modules/@antv/g2/esm/utils/number.js
  function clamp2(v, lower2, upper2) {
    return Math.max(lower2, Math.min(v, upper2));
  }
  function prettyNumber2(n2, precision = 10) {
    if (typeof n2 !== "number")
      return n2;
    return Math.abs(n2) < 1e-15 ? n2 : parseFloat(n2.toFixed(precision));
  }

  // node_modules/@antv/g2/esm/shape/utils.js
  function applyStyle(selection, style) {
    for (const [key, value2] of Object.entries(style)) {
      selection.style(key, value2);
    }
  }
  function appendPolygon(path2, points) {
    points.forEach((p2, idx) => idx === 0 ? path2.moveTo(p2[0], p2[1]) : path2.lineTo(p2[0], p2[1]));
    path2.closePath();
    return path2;
  }
  function arrowPoints(from, to, options) {
    const { arrowSize } = options;
    const size2 = typeof arrowSize === "string" ? +parseFloat(arrowSize) / 100 * dist4(from, to) : arrowSize;
    const arrowAngle = Math.PI / 6;
    const angle4 = Math.atan2(to[1] - from[1], to[0] - from[0]);
    const arrowAngle1 = Math.PI / 2 - angle4 - arrowAngle;
    const arrow1 = [
      to[0] - size2 * Math.sin(arrowAngle1),
      to[1] - size2 * Math.cos(arrowAngle1)
    ];
    const arrowAngle2 = angle4 - arrowAngle;
    const arrow2 = [
      to[0] - size2 * Math.cos(arrowAngle2),
      to[1] - size2 * Math.sin(arrowAngle2)
    ];
    return [arrow1, arrow2];
  }
  function appendArc(path2, from, to, center2, radius) {
    const startAngle = angle3(sub6(center2, from)) + Math.PI;
    const endAngle = angle3(sub6(center2, to)) + Math.PI;
    path2.arc(center2[0], center2[1], radius, startAngle, endAngle, endAngle - startAngle < 0);
    return path2;
  }
  function computeGradient(C4, X, Y, from = "y", mode = "between", tpShape = false) {
    const getTheta = (from2, tpShape2) => {
      if (from2 === "y" || from2 === true) {
        if (tpShape2) {
          return 180;
        } else {
          return 90;
        }
      } else {
        if (tpShape2) {
          return 90;
        } else {
          return 0;
        }
      }
    };
    const P = from === "y" || from === true ? Y : X;
    const theta = getTheta(from, tpShape);
    const I = indexOf3(P);
    const [min10, max11] = extent(I, (i) => P[i]);
    const p2 = new Linear({
      domain: [min10, max11],
      range: [0, 100]
    });
    const percentage = (i) => isNumber2(P[i]) && !Number.isNaN(P[i]) ? p2.map(P[i]) : 0;
    const gradientMode = {
      // Interpolate the colors for this segment.
      between: (i) => `${C4[i]} ${percentage(i)}%`,
      // Use the color of the start point as the color for this segment.
      start: (i) => i === 0 ? `${C4[i]} ${percentage(i)}%` : `${C4[i - 1]} ${percentage(i)}%, ${C4[i]} ${percentage(i)}%`,
      // Use the color of the end point as the color for this segment.
      end: (i) => i === C4.length - 1 ? `${C4[i]} ${percentage(i)}%` : `${C4[i]} ${percentage(i)}%, ${C4[i + 1]} ${percentage(i)}%`
    };
    const gradient = I.sort((a3, b) => percentage(a3) - percentage(b)).map(gradientMode[mode] || gradientMode["between"]).join(",");
    return `linear-gradient(${theta}deg, ${gradient})`;
  }
  function reorder(points) {
    const [p0, p1, p2, p3] = points;
    return [p3, p0, p1, p2];
  }
  function getArcObject(coordinate, points, Y) {
    const [p0, p1, , p3] = isTranspose(coordinate) ? reorder(points) : points;
    const [y3, y12] = Y;
    const center2 = coordinate.getCenter();
    const a1 = angleWithQuadrant(sub6(p0, center2));
    const a22 = angleWithQuadrant(sub6(p1, center2));
    const a3 = a22 === a1 && y3 !== y12 ? a22 + Math.PI * 2 : a22;
    return {
      startAngle: a1,
      endAngle: a3 - a1 >= 0 ? a3 : Math.PI * 2 + a3,
      innerRadius: dist4(p3, center2),
      outerRadius: dist4(p0, center2)
    };
  }
  function toOpacityKey(options) {
    const { colorAttribute, opacityAttribute = colorAttribute } = options;
    return `${opacityAttribute}Opacity`;
  }
  function getTransform(coordinate, value2) {
    if (!isPolar(coordinate))
      return "";
    const center2 = coordinate.getCenter();
    const { transform: suffix } = value2;
    return `translate(${center2[0]}, ${center2[1]}) ${suffix || ""}`;
  }
  function getOrigin(points) {
    if (points.length === 1)
      return points[0];
    const [[x05, y05, z0 = 0], [x22, y22, z2 = 0]] = points;
    return [(x05 + x22) / 2, (y05 + y22) / 2, (z0 + z2) / 2];
  }

  // node_modules/@antv/g2/esm/shape/interval/color.js
  var __rest13 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function rect(document2, points, value2, coordinate, style = {}) {
    const { inset = 0, radius = 0, insetLeft = inset, insetTop = inset, insetRight = inset, insetBottom = inset, radiusBottomLeft = radius, radiusBottomRight = radius, radiusTopLeft = radius, radiusTopRight = radius, minWidth = -Infinity, maxWidth = Infinity, minHeight = -Infinity } = style, rest = __rest13(style, ["inset", "radius", "insetLeft", "insetTop", "insetRight", "insetBottom", "radiusBottomLeft", "radiusBottomRight", "radiusTopLeft", "radiusTopRight", "minWidth", "maxWidth", "minHeight"]);
    if (!isPolar(coordinate) && !isHelix(coordinate)) {
      const tpShape = !!isTranspose(coordinate);
      const [p0, , p2] = tpShape ? reorder(points) : points;
      const [x3, y4] = p0;
      const [width, height] = sub6(p2, p0);
      const absX = width > 0 ? x3 : x3 + width;
      const absY = height > 0 ? y4 : y4 + height;
      const absWidth = Math.abs(width);
      const absHeight = Math.abs(height);
      const finalX = absX + insetLeft;
      const finalY = absY + insetTop;
      const finalWidth = absWidth - (insetLeft + insetRight);
      const finalHeight = absHeight - (insetTop + insetBottom);
      const clampWidth = tpShape ? clamp2(finalWidth, minHeight, Infinity) : clamp2(finalWidth, minWidth, maxWidth);
      const clampHeight = tpShape ? clamp2(finalHeight, minWidth, maxWidth) : clamp2(finalHeight, minHeight, Infinity);
      const clampX = tpShape ? finalX : finalX - (clampWidth - finalWidth) / 2;
      const clampY = tpShape ? finalY - (clampHeight - finalHeight) / 2 : finalY - (clampHeight - finalHeight);
      return select(document2.createElement("rect", {})).style("x", clampX).style("y", clampY).style("width", clampWidth).style("height", clampHeight).style("radius", [
        radiusTopLeft,
        radiusTopRight,
        radiusBottomRight,
        radiusBottomLeft
      ]).call(applyStyle, rest).node();
    }
    const { y: y3, y1: y12 } = value2;
    const center2 = coordinate.getCenter();
    const arcObject = getArcObject(coordinate, points, [y3, y12]);
    const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
    return select(document2.createElement("path", {})).style("d", path2(arcObject)).style("transform", `translate(${center2[0]}, ${center2[1]})`).style("radius", radius).style("inset", inset).call(applyStyle, rest).node();
  }
  var Color2 = (options, context) => {
    const { colorAttribute, opacityAttribute = "fill", first: first3 = true, last: last4 = true } = options, style = __rest13(options, ["colorAttribute", "opacityAttribute", "first", "last"]);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor, radius: defaultRadius2 = 0 } = defaults5, restDefaults = __rest13(defaults5, ["color", "radius"]);
      const defaultLineWidth = restDefaults.lineWidth || 1;
      const { stroke: stroke2, radius = defaultRadius2, radiusTopLeft = radius, radiusTopRight = radius, radiusBottomRight = radius, radiusBottomLeft = radius, innerRadius = 0, innerRadiusTopLeft = innerRadius, innerRadiusTopRight = innerRadius, innerRadiusBottomRight = innerRadius, innerRadiusBottomLeft = innerRadius, lineWidth = colorAttribute === "stroke" || stroke2 ? defaultLineWidth : 0, inset = 0, insetLeft = inset, insetRight = inset, insetBottom = inset, insetTop = inset, minWidth, maxWidth, minHeight } = style, rest = __rest13(style, ["stroke", "radius", "radiusTopLeft", "radiusTopRight", "radiusBottomRight", "radiusBottomLeft", "innerRadius", "innerRadiusTopLeft", "innerRadiusTopRight", "innerRadiusBottomRight", "innerRadiusBottomLeft", "lineWidth", "inset", "insetLeft", "insetRight", "insetBottom", "insetTop", "minWidth", "maxWidth", "minHeight"]);
      const { color: color2 = defaultColor, opacity } = value2;
      const standardDirRadius = [
        first3 ? radiusTopLeft : innerRadiusTopLeft,
        first3 ? radiusTopRight : innerRadiusTopRight,
        last4 ? radiusBottomRight : innerRadiusBottomRight,
        last4 ? radiusBottomLeft : innerRadiusBottomLeft
      ];
      const standardDir = [
        "radiusTopLeft",
        "radiusTopRight",
        "radiusBottomRight",
        "radiusBottomLeft"
      ];
      if (isTranspose(coordinate)) {
        standardDir.push(standardDir.shift());
      }
      const extendedStyle = Object.assign(Object.assign({ radius }, Object.fromEntries(standardDir.map((d3, i) => [d3, standardDirRadius[i]]))), {
        inset,
        insetLeft,
        insetRight,
        insetBottom,
        insetTop,
        minWidth,
        maxWidth,
        minHeight
      });
      return select(rect(document2, points, value2, coordinate, extendedStyle)).call(applyStyle, restDefaults).style("fill", "transparent").style(colorAttribute, color2).style(toOpacityKey(options), opacity).style("lineWidth", lineWidth).style("stroke", stroke2 === void 0 ? color2 : stroke2).call(applyStyle, rest).node();
    };
  };
  Color2.props = {
    defaultEnterAnimation: "scaleInY",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/interval/rect.js
  var Rect2 = (options, context) => {
    return Color2(Object.assign({ colorAttribute: "fill" }, options), context);
  };
  Rect2.props = Object.assign(Object.assign({}, Color2.props), { defaultMarker: "square" });

  // node_modules/@antv/g2/esm/shape/interval/hollow.js
  var Hollow = (options, context) => {
    return Color2(Object.assign({ colorAttribute: "stroke" }, options), context);
  };
  Hollow.props = Object.assign(Object.assign({}, Color2.props), { defaultMarker: "hollowSquare" });

  // node_modules/@antv/g2/esm/shape/interval/funnel.js
  var __rest14 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function getFunnelPoints(points, nextPoints, coordinate) {
    const [p0, p1, p2, p3] = points;
    if (isTranspose(coordinate)) {
      const newP12 = [nextPoints ? nextPoints[0][0] : p1[0], p1[1]];
      const newP22 = [nextPoints ? nextPoints[3][0] : p2[0], p2[1]];
      return [p0, newP12, newP22, p3];
    }
    const newP1 = [p1[0], nextPoints ? nextPoints[0][1] : p1[1]];
    const newP2 = [p2[0], nextPoints ? nextPoints[3][1] : p2[1]];
    return [p0, newP1, newP2, p3];
  }
  var Funnel = (options, context) => {
    const { adjustPoints = getFunnelPoints } = options, style = __rest14(options, ["adjustPoints"]);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5, point2d) => {
      const { index: index4 } = value2;
      const { color: defaultColor } = defaults5, rest = __rest14(defaults5, ["color"]);
      const nextPoints = point2d[index4 + 1];
      const funnelPoints = adjustPoints(points, nextPoints, coordinate);
      const tpShape = !!isTranspose(coordinate);
      const [p0, p1, p2, p3] = tpShape ? reorder(funnelPoints) : funnelPoints;
      const { color: color2 = defaultColor, opacity } = value2;
      const b = line_default().curve(linearClosed_default)([p0, p1, p2, p3]);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", b).style("fill", color2).style("fillOpacity", opacity).call(applyStyle, style).node();
    };
  };
  Funnel.props = {
    defaultMarker: "square"
  };

  // node_modules/@antv/g2/esm/shape/interval/pyramid.js
  function getPyramidPoints(points, nextPoints, coordinate) {
    const [p0, p1, p2, p3] = points;
    if (isTranspose(coordinate)) {
      const newP12 = [
        nextPoints ? nextPoints[0][0] : (p1[0] + p2[0]) / 2,
        p1[1]
      ];
      const newP22 = [
        nextPoints ? nextPoints[3][0] : (p1[0] + p2[0]) / 2,
        p2[1]
      ];
      return [p0, newP12, newP22, p3];
    }
    const newP1 = [
      p1[0],
      nextPoints ? nextPoints[0][1] : (p1[1] + p2[1]) / 2
    ];
    const newP2 = [
      p2[0],
      nextPoints ? nextPoints[3][1] : (p1[1] + p2[1]) / 2
    ];
    return [p0, newP1, newP2, p3];
  }
  var Pyramid = (options, context) => {
    return Funnel(Object.assign({ adjustPoints: getPyramidPoints }, options), context);
  };
  Pyramid.props = {
    defaultMarker: "square"
  };

  // node_modules/@antv/g2/esm/utils/createElement.js
  function createElement(descriptor) {
    const render2 = typeof descriptor === "function" ? descriptor : descriptor.render;
    return class extends CustomElement {
      connectedCallback() {
        this.draw();
      }
      attributeChangedCallback() {
        this.draw();
      }
      draw() {
        render2(this);
      }
    };
  }

  // node_modules/@antv/g2/esm/shape/line/curve.js
  var __rest15 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var DoublePath = createElement((g) => {
    const { d1, d2: d22, style1, style2 } = g.attributes;
    const document2 = g.ownerDocument;
    select(g).maybeAppend("line", () => document2.createElement("path", {})).style("d", d1).call(applyStyle, style1);
    select(g).maybeAppend("line1", () => document2.createElement("path", {})).style("d", d22).call(applyStyle, style2);
  });
  function segmentation(points, defined4) {
    const definedPoints = [];
    const segments = [];
    let m3 = false;
    let dp = null;
    for (const p2 of points) {
      if (!defined4(p2[0]) || !defined4(p2[1]))
        m3 = true;
      else {
        definedPoints.push(p2);
        if (m3) {
          m3 = false;
          segments.push([dp, p2]);
        }
        dp = p2;
      }
    }
    return [definedPoints, segments];
  }
  var Curve = (options, context) => {
    const {
      curve,
      gradient = false,
      // The color for each segment.
      gradientColor = "between",
      defined: defined4 = (d3) => !Number.isNaN(d3) && d3 !== void 0 && d3 !== null,
      connect: connectNulls = false
    } = options, style = __rest15(options, ["curve", "gradient", "gradientColor", "defined", "connect"]);
    const { coordinate, document: document2 } = context;
    return (P, value2, defaults5) => {
      const { color: defaultColor, lineWidth: defaultSize } = defaults5, rest = __rest15(defaults5, ["color", "lineWidth"]);
      const { color: color2 = defaultColor, size: size2 = defaultSize, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
      const transform = getTransform(coordinate, value2);
      const tpShape = isTranspose(coordinate);
      const stroke2 = gradient && sc ? computeGradient(sc, sx, sy, gradient, gradientColor, tpShape) : color2;
      const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, rest), stroke2 && { stroke: stroke2 }), size2 && { lineWidth: size2 }), transform && { transform }), style);
      let linePath;
      if (isPolar(coordinate)) {
        const center2 = coordinate.getCenter();
        linePath = (points) => lineRadial_default().angle((_2, idx) => angleWithQuadrant(sub6(points[idx], center2))).radius((_2, idx) => dist4(points[idx], center2)).defined(([x3, y3]) => defined4(x3) && defined4(y3)).curve(curve)(points);
      } else {
        linePath = line_default().x((d3) => d3[0]).y((d3) => d3[1]).defined(([x3, y3]) => defined4(x3) && defined4(y3)).curve(curve);
      }
      const [DP, MS] = segmentation(P, defined4);
      const connectStyle = subObject(finalStyle, "connect");
      const missing = !!MS.length;
      if (!missing || connectNulls && !Object.keys(connectStyle).length) {
        return select(document2.createElement("path", {})).style("d", linePath(DP) || []).call(applyStyle, finalStyle).node();
      }
      if (missing && !connectNulls) {
        return select(document2.createElement("path", {})).style("d", linePath(P)).call(applyStyle, finalStyle).node();
      }
      const connectPath = (segments) => segments.map(linePath).join(",");
      return select(new DoublePath()).style("style1", Object.assign(Object.assign({}, finalStyle), connectStyle)).style("style2", finalStyle).style("d1", connectPath(MS)).style("d2", linePath(P)).node();
    };
  };
  Curve.props = {
    defaultMarker: "smooth",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/line/line.js
  var Line2 = (options, context) => {
    const { coordinate } = context;
    return (...params) => {
      const curve = isPolar(coordinate) ? linearClosed_default : linear_default;
      return Curve(Object.assign({ curve }, options), context)(...params);
    };
  };
  Line2.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

  // node_modules/@antv/g2/esm/shape/line/smooth.js
  var __rest16 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var Smooth = (options, context) => {
    const rest = __rest16(options, []);
    const { coordinate } = context;
    return (...params) => {
      const curve = isPolar(coordinate) ? catmullRomClosed_default : isTranspose(coordinate) ? monotoneY : monotoneX;
      return Curve(Object.assign({ curve }, rest), context)(...params);
    };
  };
  Smooth.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "smooth" });

  // node_modules/@antv/g2/esm/shape/line/hv.js
  var HV = (options, context) => {
    return Curve(Object.assign({ curve: stepAfter }, options), context);
  };
  HV.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hv" });

  // node_modules/@antv/g2/esm/shape/line/vh.js
  var VH = (options, context) => {
    return Curve(Object.assign({ curve: stepBefore }, options), context);
  };
  VH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "vh" });

  // node_modules/@antv/g2/esm/shape/line/hvh.js
  var HVH = (options, context) => {
    return Curve(Object.assign({ curve: step_default }, options), context);
  };
  HVH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hvh" });

  // node_modules/@antv/g2/esm/shape/line/trail.js
  var __rest17 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function stroke(path2, p0, p1, s0, s1) {
    const v = sub6(p1, p0);
    const a3 = angle3(v);
    const a1 = a3 + Math.PI / 2;
    const r1 = [s0 / 2 * Math.cos(a1), s0 / 2 * Math.sin(a1)];
    const r2 = [s1 / 2 * Math.cos(a1), s1 / 2 * Math.sin(a1)];
    const r3 = [s1 / 2 * Math.cos(a3), s1 / 2 * Math.sin(a3)];
    const r4 = [s0 / 2 * Math.cos(a3), s0 / 2 * Math.sin(a3)];
    const x05 = add8(p0, r1);
    const x12 = add8(p1, r2);
    const x22 = add8(x12, r3);
    const x3 = add8(p1, r3);
    const x4 = sub6(x3, r2);
    const x5 = sub6(p1, r2);
    const x6 = sub6(p0, r1);
    const x7 = sub6(x6, r4);
    const x8 = sub6(p0, r4);
    const x9 = sub6(x05, r4);
    path2.moveTo(...x05);
    path2.lineTo(...x12);
    path2.arcTo(...x22, ...x3, s1 / 2);
    path2.arcTo(...x4, ...x5, s1 / 2);
    path2.lineTo(...x6);
    path2.arcTo(...x7, ...x8, s0 / 2);
    path2.arcTo(...x9, ...x05, s0 / 2);
    path2.closePath();
  }
  var Trail = (options, context) => {
    const { document: document2 } = context;
    return (P, value2, defaults5) => {
      const { seriesSize, color: color2 } = value2;
      const { color: defaultColor } = defaults5, rest = __rest17(defaults5, ["color"]);
      const path2 = path();
      for (let i = 0; i < P.length - 1; i++) {
        const p0 = P[i];
        const p1 = P[i + 1];
        const s0 = seriesSize[i];
        const s1 = seriesSize[i + 1];
        if ([...p0, ...p1].every(defined))
          stroke(path2, p0, p1, s0, s1);
      }
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("fill", color2 || defaultColor).style("d", path2.toString()).call(applyStyle, options).node();
    };
  };
  Trail.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

  // node_modules/@antv/g2/esm/utils/marker.js
  var __rest18 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var point4 = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3],
      ["A", r, r, 0, 1, 0, x3 + r, y3],
      ["A", r, r, 0, 1, 0, x3 - r, y3],
      ["Z"]
    ];
  };
  point4.style = ["fill"];
  var hollowPoint = point4.bind(void 0);
  hollowPoint.style = ["stroke", "lineWidth"];
  var square = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3 - r],
      ["L", x3 + r, y3 - r],
      ["L", x3 + r, y3 + r],
      ["L", x3 - r, y3 + r],
      ["Z"]
    ];
  };
  square.style = ["fill"];
  var rect2 = square.bind(void 0);
  rect2.style = ["fill"];
  var hollowSquare = square.bind(void 0);
  hollowSquare.style = ["stroke", "lineWidth"];
  var diamond = (x3, y3, r) => {
    const hr = r * 0.618;
    return [
      ["M", x3 - hr, y3],
      ["L", x3, y3 - r],
      ["L", x3 + hr, y3],
      ["L", x3, y3 + r],
      ["Z"]
    ];
  };
  diamond.style = ["fill"];
  var hollowDiamond = diamond.bind(void 0);
  hollowDiamond.style = ["stroke", "lineWidth"];
  var triangle = (x3, y3, r) => {
    const diffY = r * Math.sin(1 / 3 * Math.PI);
    return [
      ["M", x3 - r, y3 + diffY],
      ["L", x3, y3 - diffY],
      ["L", x3 + r, y3 + diffY],
      ["Z"]
    ];
  };
  triangle.style = ["fill"];
  var hollowTriangle = triangle.bind(void 0);
  hollowTriangle.style = ["stroke", "lineWidth"];
  var triangleDown = (x3, y3, r) => {
    const diffY = r * Math.sin(1 / 3 * Math.PI);
    return [
      ["M", x3 - r, y3 - diffY],
      ["L", x3 + r, y3 - diffY],
      ["L", x3, y3 + diffY],
      ["Z"]
    ];
  };
  triangleDown.style = ["fill"];
  var hollowTriangleDown = triangleDown.bind(void 0);
  hollowTriangleDown.style = ["stroke", "lineWidth"];
  var hexagon = (x3, y3, r) => {
    const diffX = r / 2 * Math.sqrt(3);
    return [
      ["M", x3, y3 - r],
      ["L", x3 + diffX, y3 - r / 2],
      ["L", x3 + diffX, y3 + r / 2],
      ["L", x3, y3 + r],
      ["L", x3 - diffX, y3 + r / 2],
      ["L", x3 - diffX, y3 - r / 2],
      ["Z"]
    ];
  };
  hexagon.style = ["fill"];
  var hollowHexagon = hexagon.bind(void 0);
  hollowHexagon.style = ["stroke", "lineWidth"];
  var bowtie = (x3, y3, r) => {
    const diffY = r - 1.5;
    return [
      ["M", x3 - r, y3 - diffY],
      ["L", x3 + r, y3 + diffY],
      ["L", x3 + r, y3 - diffY],
      ["L", x3 - r, y3 + diffY],
      ["Z"]
    ];
  };
  bowtie.style = ["fill"];
  var hollowBowtie = bowtie.bind(void 0);
  hollowBowtie.style = ["stroke", "lineWidth"];
  var line = (x3, y3, r) => {
    return [
      ["M", x3, y3 + r],
      ["L", x3, y3 - r]
    ];
  };
  line.style = ["stroke", "lineWidth"];
  var cross4 = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3 - r],
      ["L", x3 + r, y3 + r],
      ["M", x3 + r, y3 - r],
      ["L", x3 - r, y3 + r]
    ];
  };
  cross4.style = ["stroke", "lineWidth"];
  var tick = (x3, y3, r) => {
    return [
      ["M", x3 - r / 2, y3 - r],
      ["L", x3 + r / 2, y3 - r],
      ["M", x3, y3 - r],
      ["L", x3, y3 + r],
      ["M", x3 - r / 2, y3 + r],
      ["L", x3 + r / 2, y3 + r]
    ];
  };
  tick.style = ["stroke", "lineWidth"];
  var plus = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3],
      ["M", x3, y3 - r],
      ["L", x3, y3 + r]
    ];
  };
  plus.style = ["stroke", "lineWidth"];
  var hyphen = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3]
    ];
  };
  hyphen.style = ["stroke", "lineWidth"];
  var dot6 = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3]
    ];
  };
  dot6.style = ["stroke", "lineWidth"];
  var dash = dot6.bind(void 0);
  dash.style = ["stroke", "lineWidth"];
  var smooth = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3],
      ["A", r / 2, r / 2, 0, 1, 1, x3, y3],
      ["A", r / 2, r / 2, 0, 1, 0, x3 + r, y3]
    ];
  };
  smooth.style = ["stroke", "lineWidth"];
  var hv = (x3, y3, r) => {
    return [
      ["M", x3 - r - 1, y3 - 2.5],
      ["L", x3, y3 - 2.5],
      ["L", x3, y3 + 2.5],
      ["L", x3 + r + 1, y3 + 2.5]
    ];
  };
  hv.style = ["stroke", "lineWidth"];
  var vh = (x3, y3, r) => {
    return [
      ["M", x3 - r - 1, y3 + 2.5],
      ["L", x3, y3 + 2.5],
      ["L", x3, y3 - 2.5],
      ["L", x3 + r + 1, y3 - 2.5]
    ];
  };
  vh.style = ["stroke", "lineWidth"];
  var hvh = (x3, y3, r) => {
    return [
      ["M", x3 - (r + 1), y3 + 2.5],
      ["L", x3 - r / 2, y3 + 2.5],
      ["L", x3 - r / 2, y3 - 2.5],
      ["L", x3 + r / 2, y3 - 2.5],
      ["L", x3 + r / 2, y3 + 2.5],
      ["L", x3 + r + 1, y3 + 2.5]
    ];
  };
  hvh.style = ["stroke", "lineWidth"];
  var vhv = (x3, y3, r) => {
    return [
      ["M", x3 - 5, y3 + 2.5],
      ["L", x3 - 5, y3],
      ["L", x3, y3],
      ["L", x3, y3 - 3],
      ["L", x3, y3 + 3],
      ["L", x3 + 6.5, y3 + 3]
    ];
  };
  vhv.style = ["stroke", "lineWidth"];
  var Symbols = /* @__PURE__ */ new Map([
    ["bowtie", bowtie],
    ["cross", cross4],
    ["dash", dash],
    ["diamond", diamond],
    ["dot", dot6],
    ["hexagon", hexagon],
    ["hollowBowtie", hollowBowtie],
    ["hollowDiamond", hollowDiamond],
    ["hollowHexagon", hollowHexagon],
    ["hollowPoint", hollowPoint],
    ["hollowSquare", hollowSquare],
    ["hollowTriangle", hollowTriangle],
    ["hollowTriangleDown", hollowTriangleDown],
    ["hv", hv],
    ["hvh", hvh],
    ["hyphen", hyphen],
    ["line", line],
    ["plus", plus],
    ["point", point4],
    ["rect", rect2],
    ["smooth", smooth],
    ["square", square],
    ["tick", tick],
    ["triangleDown", triangleDown],
    ["triangle", triangle],
    ["vh", vh],
    ["vhv", vhv]
  ]);
  function useMarker(type, _a) {
    var { d: d3, fill, lineWidth, path: path2, stroke: stroke2, color: color2 } = _a, style = __rest18(_a, ["d", "fill", "lineWidth", "path", "stroke", "color"]);
    const symbol = Symbols.get(type) || Symbols.get("point");
    return (...args) => {
      const path3 = new Path2({
        style: Object.assign(Object.assign({}, style), { d: symbol(...args), stroke: symbol.style.includes("stroke") ? color2 || stroke2 : "", fill: symbol.style.includes("fill") ? color2 || fill : "", lineWidth: symbol.style.includes("lineWidth") ? lineWidth || lineWidth || 2 : 0 })
      });
      return path3;
    };
  }

  // node_modules/@antv/g2/esm/shape/point/color.js
  var __rest19 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function getRadius2(mode, points, value2, coordinate) {
    if (points.length === 1)
      return void 0;
    const { size: size2 } = value2;
    if (mode === "fixed")
      return size2;
    if (mode === "normal" || isFisheye(coordinate)) {
      const [[x05, y05], [x22, y22]] = points;
      const a3 = Math.abs((x22 - x05) / 2);
      const b = Math.abs((y22 - y05) / 2);
      return Math.max(0, (a3 + b) / 2);
    }
    return size2;
  }
  var Color3 = (options, context) => {
    const { colorAttribute, symbol, mode = "auto" } = options, style = __rest19(options, ["colorAttribute", "symbol", "mode"]);
    const path2 = Symbols.get(symbol) || Symbols.get("point");
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { lineWidth, color: defaultColor } = defaults5;
      const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;
      const { color: color2 = defaultColor, transform, opacity } = value2;
      const [cx, cy] = getOrigin(points);
      const r = getRadius2(mode, points, value2, coordinate);
      const finalRadius = r || style.r || defaults5.r;
      return select(document2.createElement("path", {})).call(applyStyle, defaults5).style("fill", "transparent").style("d", path2(cx, cy, finalRadius)).style("lineWidth", finalLineWidth).style("transform", transform).style("transformOrigin", `${cx - finalRadius} ${cy - finalRadius}`).style("stroke", color2).style(toOpacityKey(options), opacity).style(colorAttribute, color2).call(applyStyle, style).node();
    };
  };
  Color3.props = {
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/point/hollowBowtie.js
  var HollowBowtie = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "bowtie" }, options), context);
  };
  HollowBowtie.props = Object.assign({ defaultMarker: "hollowBowtie" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/hollowDiamond.js
  var HollowDiamond = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "diamond" }, options), context);
  };
  HollowDiamond.props = Object.assign({ defaultMarker: "hollowDiamond" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/hollowHexagon.js
  var HollowHexagon = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "hexagon" }, options), context);
  };
  HollowHexagon.props = Object.assign({ defaultMarker: "hollowHexagon" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/hollow.js
  var HollowPoint = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "point" }, options), context);
  };
  HollowPoint.props = Object.assign({ defaultMarker: "hollowPoint" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/hollowSquare.js
  var HollowSquare = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "square" }, options), context);
  };
  HollowSquare.props = Object.assign({ defaultMarker: "hollowSquare" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/hollowTriangle.js
  var HollowTriangle = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "triangle" }, options), context);
  };
  HollowTriangle.props = Object.assign({ defaultMarker: "hollowTriangle" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/hollowTriangleDown.js
  var HollowTriangleDown = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "triangle-down" }, options), context);
  };
  HollowTriangleDown.props = Object.assign({ defaultMarker: "hollowTriangleDown" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/circle.js
  var __rest20 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var BaseCircle = (options, context) => {
    const { colorAttribute, mode = "auto" } = options, style = __rest20(options, ["colorAttribute", "mode"]);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { lineWidth, color: defaultColor } = defaults5;
      const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;
      const { color: color2 = defaultColor, transform, opacity } = value2;
      const [cx, cy] = getOrigin(points);
      const r = getRadius2(mode, points, value2, coordinate);
      const finalRadius = r || style.r || defaults5.r;
      return select(document2.createElement("circle", {})).call(applyStyle, defaults5).style("fill", "transparent").style("cx", cx).style("cy", cy).style("r", finalRadius).style("lineWidth", finalLineWidth).style("transform", transform).style("transformOrigin", `${cx} ${cy}`).style("stroke", color2).style(toOpacityKey(options), opacity).style(colorAttribute, color2).call(applyStyle, style).node();
    };
  };
  var Circle2 = (options, context) => {
    return BaseCircle(Object.assign({ colorAttribute: "fill" }, options), context);
  };
  Circle2.props = {
    defaultMarker: "circle",
    defaultEnterAnimation: "fadeIn",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/point/hollowCircle.js
  var HollowCircle = (options, context) => {
    return BaseCircle(Object.assign({ colorAttribute: "stroke" }, options), context);
  };
  HollowCircle.props = Object.assign({ defaultMarker: "hollowPoint" }, Circle2.props);

  // node_modules/@antv/g2/esm/shape/point/bowtie.js
  var Bowtie = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "bowtie" }, options), context);
  };
  Bowtie.props = Object.assign({ defaultMarker: "bowtie" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/cross.js
  var Cross = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "cross" }, options), context);
  };
  Cross.props = Object.assign({ defaultMarker: "cross" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/diamond.js
  var Diamond = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "diamond" }, options), context);
  };
  Diamond.props = Object.assign({ defaultMarker: "diamond" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/hexagon.js
  var Hexagon = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "hexagon" }, options), context);
  };
  Hexagon.props = Object.assign({ defaultMarker: "hexagon" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/hyphen.js
  var Hyphen = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "hyphen" }, options), context);
  };
  Hyphen.props = Object.assign({ defaultMarker: "hyphen" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/line.js
  var Line3 = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "line" }, options), context);
  };
  Line3.props = Object.assign({ defaultMarker: "line" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/plus.js
  var Plus = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "plus" }, options), context);
  };
  Plus.props = Object.assign({ defaultMarker: "plus" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/point.js
  var Point3 = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "point" }, options), context);
  };
  Point3.props = Object.assign({ defaultMarker: "point" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/square.js
  var Square = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "square" }, options), context);
  };
  Square.props = Object.assign({ defaultMarker: "square" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/tick.js
  var Tick = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "tick" }, options), context);
  };
  Tick.props = Object.assign({ defaultMarker: "tick" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/triangle.js
  var Triangle = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "triangle" }, options), context);
  };
  Triangle.props = Object.assign({ defaultMarker: "triangle" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/point/triangleDown.js
  var TriangleDown = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "triangle-down" }, options), context);
  };
  TriangleDown.props = Object.assign({ defaultMarker: "triangleDown" }, Color3.props);

  // node_modules/@antv/g2/esm/shape/vector/vector.js
  var __rest21 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var Vector = (options, context) => {
    const { arrow = true, arrowSize = "40%" } = options, style = __rest21(options, ["arrow", "arrowSize"]);
    const { document: document2 } = context;
    return (points, value2, defaults5) => {
      const { defaultColor } = defaults5, rest = __rest21(defaults5, ["defaultColor"]);
      const { color: color2 = defaultColor, transform } = value2;
      const [from, to] = points;
      const path2 = path();
      path2.moveTo(...from);
      path2.lineTo(...to);
      if (arrow) {
        const [arrow1, arrow2] = arrowPoints(from, to, { arrowSize });
        path2.moveTo(...arrow1);
        path2.lineTo(...to);
        path2.lineTo(...arrow2);
      }
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("transform", transform).call(applyStyle, style).node();
    };
  };
  Vector.props = {
    defaultMarker: "line",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/component/esm/util/traverse.js
  function traverse(element, callback) {
    callback(element);
    if (element.children) {
      element.children.forEach(function(child) {
        if (child)
          traverse(child, callback);
      });
    }
  }

  // node_modules/@antv/component/esm/util/visibility.js
  function show(element) {
    visibility(element, true);
  }
  function hide(element) {
    visibility(element, false);
  }
  function visibility(element, visible) {
    var value2 = visible ? "visible" : "hidden";
    traverse(element, function(node) {
      node.attr("visibility", value2);
    });
  }

  // node_modules/@antv/component/esm/util/offscreen.js
  var OffscreenGroup = (
    /** @class */
    function(_super) {
      __extends(OffscreenGroup2, _super);
      function OffscreenGroup2() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
        _this.isMutationObserved = true;
        _this.addEventListener(ElementEvent.INSERTED, function() {
          hide(_this);
        });
        return _this;
      }
      return OffscreenGroup2;
    }(Group2)
  );
  function createOffscreenGroup(container) {
    var group3 = container.appendChild(new OffscreenGroup({
      class: "offscreen"
    }));
    hide(group3);
    return group3;
  }
  function isInOffscreenGroup(group3) {
    var ancestor = group3;
    while (ancestor) {
      if (ancestor.className === "offscreen") {
        return true;
      }
      ancestor = ancestor.parent;
    }
    return false;
  }

  // node_modules/@antv/component/esm/shapes/Text.js
  var Text2 = (
    /** @class */
    function(_super) {
      __extends(Text5, _super);
      function Text5(_a) {
        if (_a === void 0) {
          _a = {};
        }
        var style = _a.style, restOptions = __rest(_a, ["style"]);
        return _super.call(this, __assign({ style: __assign({ text: "", fill: "black", fontFamily: "sans-serif", fontSize: 16, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", lineWidth: 1, textAlign: "start", textBaseline: "middle" }, style) }, restOptions)) || this;
      }
      Object.defineProperty(Text5.prototype, "offscreenGroup", {
        get: function() {
          if (!this._offscreen)
            this._offscreen = createOffscreenGroup(this);
          return this._offscreen;
        },
        enumerable: false,
        configurable: true
      });
      Text5.prototype.disconnectedCallback = function() {
        var _a;
        (_a = this._offscreen) === null || _a === void 0 ? void 0 : _a.destroy();
      };
      return Text5;
    }(Text)
  );

  // node_modules/@antv/component/esm/util/angle-converter.js
  function degToRad(deg2) {
    return deg2 * Math.PI / 180;
  }
  function radToDeg(rad2) {
    return Number((rad2 * 180 / Math.PI).toPrecision(5));
  }

  // node_modules/@antv/component/esm/util/bbox.js
  var BBox = (
    /** @class */
    function() {
      function BBox2(x3, y3, width, height) {
        if (x3 === void 0) {
          x3 = 0;
        }
        if (y3 === void 0) {
          y3 = 0;
        }
        if (width === void 0) {
          width = 0;
        }
        if (height === void 0) {
          height = 0;
        }
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
        this.x = x3;
        this.y = y3;
        this.width = width;
        this.height = height;
      }
      Object.defineProperty(BBox2.prototype, "bottom", {
        get: function() {
          return this.y + this.height;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BBox2.prototype, "left", {
        get: function() {
          return this.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BBox2.prototype, "right", {
        get: function() {
          return this.x + this.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BBox2.prototype, "top", {
        get: function() {
          return this.y;
        },
        enumerable: false,
        configurable: true
      });
      BBox2.fromRect = function(other) {
        return new BBox2(other.x, other.y, other.width, other.height);
      };
      BBox2.prototype.toJSON = function() {
        return {
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height,
          top: this.top,
          right: this.right,
          bottom: this.bottom,
          left: this.left
        };
      };
      BBox2.prototype.isPointIn = function(x3, y3) {
        return x3 >= this.left && x3 <= this.right && y3 >= this.top && y3 <= this.bottom;
      };
      return BBox2;
    }()
  );

  // node_modules/@antv/component/esm/util/callback.js
  function getCallbackValue(value2, params) {
    return isFunction(value2) ? value2.apply(void 0, __spreadArray([], __read(params), false)) : value2;
  }

  // node_modules/@antv/component/esm/util/classnames.js
  var classNames = function(cls, prefix) {
    var PREFIX = function(str7) {
      return "".concat(prefix, "-").concat(str7);
    };
    var obj = Object.fromEntries(Object.entries(cls).map(function(_a) {
      var _b = __read(_a, 2), k = _b[0], v = _b[1];
      var name2 = PREFIX(v);
      return [
        k,
        {
          name: name2,
          class: ".".concat(name2),
          id: "#".concat(name2),
          toString: function() {
            return name2;
          }
        }
      ];
    }));
    Object.assign(obj, { prefix: PREFIX });
    return obj;
  };

  // node_modules/@antv/component/esm/util/deep-assign.js
  var MAX_MIX_LEVEL2 = 5;
  var deep = function(dist5, src, level, maxLevel) {
    if (level === void 0) {
      level = 0;
    }
    if (maxLevel === void 0) {
      maxLevel = MAX_MIX_LEVEL2;
    }
    Object.entries(src).forEach(function(_a) {
      var _b = __read(_a, 2), key = _b[0], value2 = _b[1];
      var res = dist5;
      if (Object.prototype.hasOwnProperty.call(src, key)) {
        if (!value2) {
          res[key] = value2;
        } else if (is_plain_object_default(value2)) {
          if (!is_plain_object_default(dist5[key])) {
            res[key] = {};
          }
          if (level < maxLevel) {
            deep(dist5[key], value2, level + 1, maxLevel);
          } else {
            res[key] = src[key];
          }
        } else if (isArray(value2)) {
          res[key] = [];
          res[key] = res[key].concat(value2);
        } else {
          res[key] = value2;
        }
      }
    });
  };
  var deepAssign2 = function(rst) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i += 1) {
      deep(rst, args[i]);
    }
    return rst;
  };

  // node_modules/@antv/component/esm/util/defined.js
  var defined2 = function(x3) {
    return x3 !== void 0 && x3 != null && !Number.isNaN(x3);
  };

  // node_modules/@antv/component/esm/util/text.js
  var ctx;
  var mockMeasureTextWidth;
  var measureTextWidth = memoize(function(text, font) {
    var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
    if (mockMeasureTextWidth) {
      return mockMeasureTextWidth(text, fontSize);
    }
    if (!ctx) {
      ctx = runtime.offscreenCanvasCreator.getOrCreateContext(void 0);
    }
    ctx.font = [fontStyle, fontVariant, fontWeight, "".concat(fontSize, "px"), fontFamily].join(" ");
    return ctx.measureText(text).width;
  }, function(text, font) {
    return [text, Object.values(font || getFont(text)).join()].join("");
  }, 4096);
  var getFont = function(textShape) {
    var fontFamily = textShape.style.fontFamily || "sans-serif";
    var fontWeight = textShape.style.fontWeight || "normal";
    var fontStyle = textShape.style.fontStyle || "normal";
    var fontVariant = textShape.style.fontVariant;
    var fontSize = textShape.style.fontSize;
    fontSize = typeof fontSize === "object" ? fontSize.value : fontSize;
    return { fontSize, fontFamily, fontWeight, fontStyle, fontVariant };
  };
  function textOf(node) {
    if (node.nodeName === "text") {
      return node;
    }
    if (node.nodeName === "g" && node.children.length === 1 && node.children[0].nodeName === "text") {
      return node.children[0];
    }
    return null;
  }
  function applyToText(node, style) {
    var text = textOf(node);
    if (text)
      text.attr(style);
  }

  // node_modules/@antv/component/esm/util/ellipsis.js
  function ellipsisIt(node, w, suffix) {
    if (suffix === void 0) {
      suffix = "...";
    }
    applyToText(node, { wordWrap: true, wordWrapWidth: w, maxLines: 1, textOverflow: suffix });
  }

  // node_modules/@antv/component/esm/util/wrap.js
  function wrapIt(node, wordWrapWidth, maxLines, textBaseline) {
    if (maxLines === void 0) {
      maxLines = 2;
    }
    if (textBaseline === void 0) {
      textBaseline = "top";
    }
    applyToText(node, { wordWrap: true, wordWrapWidth, maxLines, textBaseline });
  }

  // node_modules/@antv/component/esm/util/event.js
  function getEventPos(e3) {
    var canvas = e3.canvas, touches = e3.touches, offsetX = e3.offsetX, offsetY = e3.offsetY;
    if (canvas) {
      var x3 = canvas.x, y3 = canvas.y;
      return [x3, y3];
    }
    if (touches) {
      var _a = touches[0], clientX = _a.clientX, clientY = _a.clientY;
      return [clientX, clientY];
    }
    if (offsetX && offsetY)
      return [offsetX, offsetY];
    return [0, 0];
  }

  // node_modules/@antv/component/esm/util/extend-display-object.js
  function renderExtDo(el) {
    if (typeof el === "function")
      return el();
    return isString2(el) || isNumber2(el) ? new Text2({ style: { text: String(el) } }) : el;
  }

  // node_modules/@antv/component/esm/util/group-by.js
  function groupBy(source, by) {
    return source.reduce(function(acc, curr) {
      (acc[curr[by]] = acc[curr[by]] || []).push(curr);
      return acc;
    }, {});
  }

  // node_modules/@antv/component/esm/util/if-show.js
  function ifShow(show3, container, creator, removeChildren, removeHandler) {
    if (removeChildren === void 0) {
      removeChildren = true;
    }
    if (removeHandler === void 0) {
      removeHandler = function(g) {
        g.node().removeChildren();
      };
    }
    if (show3) {
      return creator(container);
    }
    if (removeChildren)
      removeHandler(container);
    return null;
  }

  // node_modules/@antv/component/esm/util/in-range.js
  function inRange(n2, start2, end, includeLeft, includeRight) {
    if (includeLeft === void 0) {
      includeLeft = true;
    }
    if (includeRight === void 0) {
      includeRight = false;
    }
    if (includeLeft && n2 === start2 || includeRight && n2 === end)
      return true;
    return n2 > start2 && n2 < end;
  }

  // node_modules/@antv/component/esm/util/interpolate.js
  var numberInterpolate = function(from, to) {
    return function(t) {
      return from * (1 - t) + to * t;
    };
  };
  function arrayInterpolate(from, to) {
    var nb = to ? to.length : 0;
    var na = from ? Math.min(nb, from.length) : 0;
    return function(t) {
      var x3 = new Array(na);
      var c5 = new Array(nb);
      var i = 0;
      for (i = 0; i < na; ++i)
        x3[i] = interpolate4(from[i], to[i]);
      for (; i < nb; ++i)
        c5[i] = to[i];
      for (i = 0; i < na; ++i)
        c5[i] = x3[i](t);
      return c5;
    };
  }
  function objectInterpolate(from, to) {
    if (from === void 0) {
      from = {};
    }
    if (to === void 0) {
      to = {};
    }
    var i = {};
    var c5 = {};
    Object.entries(to).forEach(function(_a) {
      var _b = __read(_a, 2), k = _b[0], v = _b[1];
      if (k in from)
        i[k] = interpolate4(from[k], v);
      else
        c5[k] = v;
    });
    return function(t) {
      Object.entries(i).forEach(function(_a) {
        var _b = __read(_a, 2), k = _b[0], v = _b[1];
        return c5[k] = v(t);
      });
      return c5;
    };
  }
  function interpolate4(from, to) {
    if (typeof from === "number" && typeof to === "number") {
      return numberInterpolate(from, to);
    }
    if (Array.isArray(from) && Array.isArray(to)) {
      return arrayInterpolate(from, to);
    }
    if (typeof from === "object" && typeof to === "object") {
      return objectInterpolate(from, to);
    }
    return function(t) {
      return from;
    };
  }

  // node_modules/@antv/component/esm/util/keyframe-interpolate.js
  function keyframeInterpolate(element, from, to, options) {
    if (!options) {
      element.attr("__keyframe_data__", to);
      return null;
    }
    var _a = options.duration, duration = _a === void 0 ? 0 : _a;
    var int2 = interpolate4(from, to);
    var count4 = Math.ceil(+duration / 16);
    var keyframes = new Array(count4).fill(0).map(function(datum, index4, array2) {
      return { __keyframe_data__: int2(index4 / (array2.length - 1)) };
    });
    return element.animate(keyframes, __assign({ fill: "both" }, options));
  }

  // node_modules/@antv/component/esm/util/layout/utils/helper.js
  function getItemsBBox(items) {
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY2 = -Infinity;
    for (var i = 0; i < items.length; i++) {
      var _a = items[i], x3 = _a.x, y3 = _a.y, width = _a.width, height = _a.height;
      var _b = __read([x3 + width, y3 + height], 2), X = _b[0], Y = _b[1];
      if (x3 < minX)
        minX = x3;
      if (y3 < minY)
        minY = y3;
      if (X > maxX)
        maxX = X;
      if (Y > maxY2)
        maxY2 = Y;
    }
    return new BBox(minX, minY, maxX - minX, maxY2 - minY);
  }

  // node_modules/@antv/component/esm/util/layout/flex/index.js
  var flex = function(container, children, config2) {
    var width = container.width, height = container.height;
    var _a = config2.flexDirection, flexDirection = _a === void 0 ? "row" : _a, _b = config2.flexWrap, flexWrap = _b === void 0 ? "nowrap" : _b, _c = config2.justifyContent, justifyContent = _c === void 0 ? "flex-start" : _c, _d = config2.alignContent, alignContent = _d === void 0 ? "flex-start" : _d, _e = config2.alignItems, alignItems = _e === void 0 ? "flex-start" : _e;
    var isHorizontalFlow = flexDirection === "row";
    var isLeftToRightFlow = flexDirection === "row" || flexDirection === "column";
    var direction2 = isHorizontalFlow ? isLeftToRightFlow ? [1, 0] : [-1, 0] : isLeftToRightFlow ? [0, 1] : [0, -1];
    var _f = __read([0, 0], 2), offsetX = _f[0], offsetY = _f[1];
    var itemsFromDirection = children.map(function(child) {
      var _a2;
      var width2 = child.width, height2 = child.height;
      var _b2 = __read([offsetX, offsetY], 2), x3 = _b2[0], y3 = _b2[1];
      _a2 = __read([offsetX + width2 * direction2[0], offsetY + height2 * direction2[1]], 2), offsetX = _a2[0], offsetY = _a2[1];
      return new BBox(x3, y3, width2, height2);
    });
    var itemsForJustifyContentBBox = getItemsBBox(itemsFromDirection);
    var justifyContentOffset = {
      "flex-start": 0,
      "flex-end": isHorizontalFlow ? width - itemsForJustifyContentBBox.width : height - itemsForJustifyContentBBox.height,
      center: isHorizontalFlow ? (width - itemsForJustifyContentBBox.width) / 2 : (height - itemsForJustifyContentBBox.height) / 2
    };
    var itemsFromJustifyContent = itemsFromDirection.map(function(item) {
      var x3 = item.x, y3 = item.y;
      var itemBox = BBox.fromRect(item);
      itemBox.x = isHorizontalFlow ? x3 + justifyContentOffset[justifyContent] : x3;
      itemBox.y = isHorizontalFlow ? y3 : y3 + justifyContentOffset[justifyContent];
      return itemBox;
    });
    var itemsForAlignItemsBBox = getItemsBBox(itemsFromJustifyContent);
    var calcAlignItemsOffset = function(box2) {
      var _a2 = __read(isHorizontalFlow ? ["height", height] : ["width", width], 2), key = _a2[0], size2 = _a2[1];
      switch (alignItems) {
        case "flex-start":
          return 0;
        case "flex-end":
          return size2 - box2[key];
        case "center":
          return size2 / 2 - box2[key] / 2;
        default:
          return 0;
      }
    };
    var itemsFromAlignItems = itemsFromJustifyContent.map(function(item) {
      var x3 = item.x, y3 = item.y;
      var itemBox = BBox.fromRect(item);
      itemBox.x = isHorizontalFlow ? x3 : x3 + calcAlignItemsOffset(itemBox);
      itemBox.y = isHorizontalFlow ? y3 + calcAlignItemsOffset(itemBox) : y3;
      return itemBox;
    });
    var finalItems = itemsFromAlignItems.map(function(item) {
      var _a2, _b2;
      var itemBox = BBox.fromRect(item);
      itemBox.x += (_a2 = container.x) !== null && _a2 !== void 0 ? _a2 : 0;
      itemBox.y += (_b2 = container.y) !== null && _b2 !== void 0 ? _b2 : 0;
      return itemBox;
    });
    return finalItems;
  };

  // node_modules/@antv/component/esm/util/layout/grid/index.js
  var grid = function(container, children, config2) {
    return [];
  };

  // node_modules/@antv/component/esm/util/layout/executer.js
  var executer_default = function(container, children, config2) {
    if (children.length === 0)
      return [];
    var callers = { flex, grid };
    var caller = config2.display in callers ? callers[config2.display] : null;
    return (caller === null || caller === void 0 ? void 0 : caller.call(null, container, children, config2)) || [];
  };

  // node_modules/@antv/component/esm/util/matrix.js
  function scale8(vec, s3) {
    return [vec[0] * s3, vec[1] * s3];
  }
  function add9(vec1, vec2) {
    return [vec1[0] + vec2[0], vec1[1] + vec2[1]];
  }
  function sub7(vec1, vec2) {
    return [vec1[0] - vec2[0], vec1[1] - vec2[1]];
  }
  function min8(vec1, vec2) {
    return [Math.min(vec1[0], vec2[0]), Math.min(vec1[1], vec2[1])];
  }
  function max9(vec1, vec2) {
    return [Math.max(vec1[0], vec2[0]), Math.max(vec1[1], vec2[1])];
  }
  function distance5(vec1, vec2) {
    return Math.sqrt(Math.pow(vec1[0] - vec2[0], 2) + Math.pow(vec1[1] - vec2[1], 2));
  }
  function normalize7(vec) {
    if (vec[0] === 0 && vec[1] === 0)
      return [0, 0];
    var len5 = Math.sqrt(Math.pow(vec[0], 2) + Math.pow(vec[1], 2));
    return [vec[0] / len5, vec[1] / len5];
  }
  function vertical(vec, flag) {
    return flag ? [vec[1], -vec[0]] : [-vec[1], vec[0]];
  }

  // node_modules/@antv/component/esm/util/number.js
  function toPrecision(num, precision) {
    return +num.toPrecision(precision);
  }

  // node_modules/@antv/component/esm/util/omit.js
  function omit(obj, keys2) {
    var res = {};
    var innerKeys = Array.isArray(keys2) ? keys2 : [keys2];
    for (var key in obj) {
      if (!innerKeys.includes(key)) {
        res[key] = obj[key];
      }
    }
    return res;
  }

  // node_modules/@antv/component/esm/util/path.js
  function smoothBezier(points, smooth3, isLoop, constraint) {
    var _a;
    var cps = [];
    var hasConstraint = !!constraint;
    var prevPoint;
    var nextPoint;
    var min10 = [Infinity, Infinity];
    var max11 = [-Infinity, -Infinity];
    var nextCp0;
    var cp1;
    var cp0;
    if (hasConstraint) {
      _a = __read(constraint, 2), min10 = _a[0], max11 = _a[1];
      for (var i = 0, l2 = points.length; i < l2; i += 1) {
        var point6 = points[i];
        min10 = min8(min10, point6);
        max11 = max9(max11, point6);
      }
    }
    for (var i = 0, len5 = points.length; i < len5; i += 1) {
      var point6 = points[i];
      if (i === 0 && !isLoop) {
        cp0 = point6;
      } else if (i === len5 - 1 && !isLoop) {
        cp1 = point6;
        cps.push(cp0);
        cps.push(cp1);
      } else {
        var prevIdx = [i ? i - 1 : len5 - 1, i - 1][isLoop ? 0 : 1];
        prevPoint = points[prevIdx];
        nextPoint = points[isLoop ? (i + 1) % len5 : i + 1];
        var v = [0, 0];
        v = sub7(nextPoint, prevPoint);
        v = scale8(v, smooth3);
        var d0 = distance5(point6, prevPoint);
        var d1 = distance5(point6, nextPoint);
        var sum3 = d0 + d1;
        if (sum3 !== 0) {
          d0 /= sum3;
          d1 /= sum3;
        }
        var v1 = scale8(v, -d0);
        var v2 = scale8(v, d1);
        cp1 = add9(point6, v1);
        nextCp0 = add9(point6, v2);
        nextCp0 = min8(nextCp0, max9(nextPoint, point6));
        nextCp0 = max9(nextCp0, min8(nextPoint, point6));
        v1 = sub7(nextCp0, point6);
        v1 = scale8(v1, -d0 / d1);
        cp1 = add9(point6, v1);
        cp1 = min8(cp1, max9(prevPoint, point6));
        cp1 = max9(cp1, min8(prevPoint, point6));
        v2 = sub7(point6, cp1);
        v2 = scale8(v2, d1 / d0);
        nextCp0 = add9(point6, v2);
        if (hasConstraint) {
          cp1 = max9(cp1, min10);
          cp1 = min8(cp1, max11);
          nextCp0 = max9(nextCp0, min10);
          nextCp0 = min8(nextCp0, max11);
        }
        cps.push(cp0);
        cps.push(cp1);
        cp0 = nextCp0;
      }
    }
    if (isLoop) {
      cps.push(cps.shift());
    }
    return cps;
  }
  function catmullRom2Bezier(crp, z, constraint) {
    var _a;
    if (z === void 0) {
      z = false;
    }
    if (constraint === void 0) {
      constraint = [
        [0, 0],
        [1, 1]
      ];
    }
    var isLoop = !!z;
    var pointList = [];
    for (var i = 0, l2 = crp.length; i < l2; i += 2) {
      pointList.push([crp[i], crp[i + 1]]);
    }
    var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
    var len5 = pointList.length;
    var d1 = [];
    var cp1;
    var cp2;
    var p2;
    for (var i = 0; i < len5 - 1; i += 1) {
      cp1 = controlPointList[i * 2];
      cp2 = controlPointList[i * 2 + 1];
      p2 = pointList[i + 1];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
    }
    if (isLoop) {
      cp1 = controlPointList[len5];
      cp2 = controlPointList[len5 + 1];
      _a = __read(pointList, 1), p2 = _a[0];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
    }
    return d1;
  }

  // node_modules/@antv/component/esm/util/primitive.js
  var PRIMILTIVE_ATTRIBUTES = [
    "$el",
    "cx",
    "cy",
    "d",
    "dx",
    "dy",
    "fill",
    "fillOpacity",
    "filter",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontVariant",
    "fontWeight",
    "height",
    "img",
    "increasedLineWidthForHitTesting",
    "innerHTML",
    "isBillboard",
    "billboardRotation",
    "isSizeAttenuation",
    "isClosed",
    "isOverflowing",
    "leading",
    "letterSpacing",
    "lineDash",
    "lineHeight",
    "lineWidth",
    "markerEnd",
    "markerEndOffset",
    "markerMid",
    "markerStart",
    "markerStartOffset",
    "maxLines",
    "metrics",
    "miterLimit",
    "offsetX",
    "offsetY",
    "opacity",
    "path",
    "points",
    "r",
    "radius",
    "rx",
    "ry",
    "shadowColor",
    "src",
    "stroke",
    "strokeOpacity",
    "text",
    "textAlign",
    "textBaseline",
    "textDecorationColor",
    "textDecorationLine",
    "textDecorationStyle",
    "textOverflow",
    "textPath",
    "textPathSide",
    "textPathStartOffset",
    "transform",
    "transformOrigin",
    "visibility",
    "width",
    "wordWrap",
    "wordWrapWidth",
    "x",
    "x1",
    "x2",
    "y",
    "y1",
    "y2",
    "z1",
    "z2",
    "zIndex"
  ];
  function isPrimitiveAttribute(key) {
    return PRIMILTIVE_ATTRIBUTES.includes(key);
  }
  function getPrimitiveAttributes(attributes) {
    var object = {};
    for (var key in attributes) {
      if (isPrimitiveAttribute(key))
        object[key] = attributes[key];
    }
    return object;
  }

  // node_modules/@antv/component/esm/util/sampling.js
  function sampling(data2, size2) {
    if (data2.length <= size2)
      return data2;
    var step2 = Math.floor(data2.length / size2);
    var result = [];
    for (var i = 0; i < data2.length; i += step2) {
      result.push(data2[i]);
    }
    return result;
  }

  // node_modules/@antv/component/esm/util/scale-to-pixel.js
  function scaleToPixel(el, size2, applyScale2) {
    if (applyScale2 === void 0) {
      applyScale2 = false;
    }
    var _a = el.getBBox(), width = _a.width, height = _a.height;
    var scale10 = size2 / Math.max(width, height);
    if (applyScale2) {
      el.style.transform = "scale(".concat(scale10, ")");
    }
    return scale10;
  }

  // node_modules/@antv/component/esm/util/group.js
  function group2(array2, keyFunc) {
    var grouped = /* @__PURE__ */ new Map();
    array2.forEach(function(item) {
      var key = keyFunc(item);
      if (!grouped.has(key)) {
        grouped.set(key, []);
      }
      grouped.get(key).push(item);
    });
    return grouped;
  }

  // node_modules/@antv/component/esm/util/selection.js
  function error3(msg) {
    throw new Error(msg);
  }
  var Selection2 = (
    /** @class */
    function() {
      function Selection3(elements, data2, parent, document2, selections, transitions, updateElements) {
        if (elements === void 0) {
          elements = null;
        }
        if (data2 === void 0) {
          data2 = null;
        }
        if (parent === void 0) {
          parent = null;
        }
        if (document2 === void 0) {
          document2 = null;
        }
        if (selections === void 0) {
          selections = [null, null, null, null, null];
        }
        if (transitions === void 0) {
          transitions = [];
        }
        if (updateElements === void 0) {
          updateElements = [];
        }
        _Selection_instances.add(this);
        this._elements = Array.from(elements);
        this._data = data2;
        this._parent = parent;
        this._document = document2;
        this._enter = selections[0];
        this._update = selections[1];
        this._exit = selections[2];
        this._merge = selections[3];
        this._split = selections[4];
        this._transitions = transitions;
        this._facetElements = updateElements;
      }
      Selection3.prototype.selectAll = function(selector) {
        var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
        return new _a(elements, null, this._elements[0], this._document);
      };
      Selection3.prototype.selectFacetAll = function(selector) {
        var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
        return new _a(this._elements, null, this._parent, this._document, void 0, void 0, elements);
      };
      Selection3.prototype.select = function(selector) {
        var element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
        return new _a([element], null, element, this._document);
      };
      Selection3.prototype.append = function(node) {
        var _this = this;
        var callback = typeof node === "function" ? node : function() {
          return _this.createElement(node);
        };
        var elements = [];
        if (this._data !== null) {
          for (var i = 0; i < this._data.length; i++) {
            var d3 = this._data[i];
            var _b = __read(Array.isArray(d3) ? d3 : [d3, null], 2), datum = _b[0], from = _b[1];
            var newElement = callback(datum, i);
            newElement.__data__ = datum;
            if (from !== null)
              newElement.__fromElements__ = from;
            this._parent.appendChild(newElement);
            elements.push(newElement);
          }
          return new _a(elements, null, this._parent, this._document);
        }
        for (var i = 0; i < this._elements.length; i++) {
          var element = this._elements[i];
          var datum = element.__data__;
          var newElement = callback(datum, i);
          element.appendChild(newElement);
          elements.push(newElement);
        }
        return new _a(elements, null, elements[0], this._document);
      };
      Selection3.prototype.maybeAppend = function(id5, node) {
        var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, id5[0] === "#" ? id5 : "#".concat(id5), node);
        element.attr("id", id5);
        return element;
      };
      Selection3.prototype.maybeAppendByClassName = function(className2, node) {
        var cls = className2.toString();
        var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, cls[0] === "." ? cls : ".".concat(cls), node);
        element.attr("className", cls);
        return element;
      };
      Selection3.prototype.maybeAppendByName = function(name2, node) {
        var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, '[name="'.concat(name2, '"]'), node);
        element.attr("name", name2);
        return element;
      };
      Selection3.prototype.data = function(data2, id5, groupId) {
        var e_1, _b;
        if (id5 === void 0) {
          id5 = function(d3) {
            return d3;
          };
        }
        if (groupId === void 0) {
          groupId = function() {
            return null;
          };
        }
        var enter = [];
        var update = [];
        var exit = new Set(this._elements);
        var merge2 = [];
        var split = /* @__PURE__ */ new Set();
        var keyElement = new Map(this._elements.map(function(d3, i2) {
          return [id5(d3.__data__, i2), d3];
        }));
        var keyUpdateElement = new Map(this._facetElements.map(function(d3, i2) {
          return [id5(d3.__data__, i2), d3];
        }));
        var groupKeyElements = group2(this._elements, function(d3) {
          return groupId(d3.__data__);
        });
        for (var i = 0; i < data2.length; i++) {
          var datum = data2[i];
          var key = id5(datum, i);
          var groupKey = groupId(datum, i);
          if (keyElement.has(key)) {
            var element = keyElement.get(key);
            element.__data__ = datum;
            element.__facet__ = false;
            update.push(element);
            exit.delete(element);
            keyElement.delete(key);
          } else if (keyUpdateElement.has(key)) {
            var element = keyUpdateElement.get(key);
            element.__data__ = datum;
            element.__facet__ = true;
            update.push(element);
            keyUpdateElement.delete(key);
          } else if (groupKeyElements.has(key)) {
            var group_2 = groupKeyElements.get(key);
            merge2.push([datum, group_2]);
            try {
              for (var group_1 = (e_1 = void 0, __values(group_2)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {
                var element = group_1_1.value;
                exit.delete(element);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (group_1_1 && !group_1_1.done && (_b = group_1.return)) _b.call(group_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            groupKeyElements.delete(key);
          } else if (keyElement.has(groupKey)) {
            var element = keyElement.get(groupKey);
            if (element.__toData__)
              element.__toData__.push(datum);
            else
              element.__toData__ = [datum];
            split.add(element);
            exit.delete(element);
          } else {
            enter.push(datum);
          }
        }
        var S = [
          new _a([], enter, this._parent, this._document),
          new _a(update, null, this._parent, this._document),
          new _a(exit, null, this._parent, this._document),
          new _a([], merge2, this._parent, this._document),
          new _a(split, null, this._parent, this._document)
        ];
        return new _a(this._elements, null, this._parent, this._document, S);
      };
      Selection3.prototype.merge = function(other) {
        var elements = __spreadArray(__spreadArray([], __read(this._elements), false), __read(other._elements), false);
        var transitions = __spreadArray(__spreadArray([], __read(this._transitions), false), __read(other._transitions), false);
        return new _a(elements, null, this._parent, this._document, void 0, transitions);
      };
      Selection3.prototype.createElement = function(type) {
        if (this._document) {
          return this._document.createElement(type, {});
        }
        var Ctor = _a.registry[type];
        if (Ctor)
          return new Ctor();
        return error3("Unknown node type: ".concat(type));
      };
      Selection3.prototype.join = function(enter, update, exit, merge2, split) {
        if (enter === void 0) {
          enter = function(d3) {
            return d3;
          };
        }
        if (update === void 0) {
          update = function(d3) {
            return d3;
          };
        }
        if (exit === void 0) {
          exit = function(d3) {
            return d3.remove();
          };
        }
        if (merge2 === void 0) {
          merge2 = function(d3) {
            return d3;
          };
        }
        if (split === void 0) {
          split = function(d3) {
            return d3.remove();
          };
        }
        var newEnter = enter(this._enter);
        var newUpdate = update(this._update);
        var newExit = exit(this._exit);
        var newMerge = merge2(this._merge);
        var newSplit = split(this._split);
        return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
      };
      Selection3.prototype.remove = function() {
        var _loop_1 = function(i2) {
          var element = this_1._elements[i2];
          var transition2 = this_1._transitions[i2];
          if (transition2) {
            transition2.then(function() {
              return element.remove();
            });
          } else {
            element.remove();
          }
        };
        var this_1 = this;
        for (var i = 0; i < this._elements.length; i++) {
          _loop_1(i);
        }
        return new _a([], null, this._parent, this._document, void 0, this._transitions);
      };
      Selection3.prototype.each = function(callback) {
        for (var i = 0; i < this._elements.length; i++) {
          var element = this._elements[i];
          var datum = element.__data__;
          callback.call(element, datum, i);
        }
        return this;
      };
      Selection3.prototype.attr = function(key, value2) {
        var callback = typeof value2 !== "function" ? function() {
          return value2;
        } : value2;
        return this.each(function(d3, i) {
          if (value2 !== void 0)
            this[key] = callback.call(this, d3, i);
        });
      };
      Selection3.prototype.style = function(key, value2, callable) {
        if (callable === void 0) {
          callable = true;
        }
        var callback = typeof value2 !== "function" || !callable ? function() {
          return value2;
        } : value2;
        return this.each(function(d3, i) {
          if (value2 !== void 0)
            this.style[key] = callback.call(this, d3, i);
        });
      };
      Selection3.prototype.styles = function(style, callable) {
        if (style === void 0) {
          style = {};
        }
        if (callable === void 0) {
          callable = true;
        }
        return this.each(function(d3, i) {
          var _this = this;
          Object.entries(style).forEach(function(_b) {
            var _c = __read(_b, 2), key = _c[0], value2 = _c[1];
            var callback = typeof value2 !== "function" || !callable ? function() {
              return value2;
            } : value2;
            if (value2 !== void 0)
              _this.attr(key, callback.call(_this, d3, i));
          });
        });
      };
      Selection3.prototype.update = function(option2, callable) {
        if (callable === void 0) {
          callable = true;
        }
        var callback = typeof option2 !== "function" || !callable ? function() {
          return option2;
        } : option2;
        return this.each(function(d3, i) {
          if (option2 && this.update)
            this.update(callback.call(this, d3, i));
        });
      };
      Selection3.prototype.maybeUpdate = function(option2, callable) {
        if (callable === void 0) {
          callable = true;
        }
        var callback = typeof option2 !== "function" || !callable ? function() {
          return option2;
        } : option2;
        return this.each(function(d3, i) {
          if (option2 && this.update)
            this.update(callback.call(this, d3, i));
        });
      };
      Selection3.prototype.transition = function(callback) {
        var T = this._transitions;
        return this.each(function(d3, i) {
          T[i] = callback.call(this, d3, i);
        });
      };
      Selection3.prototype.on = function(event, handler) {
        this.each(function() {
          this.addEventListener(event, handler);
        });
        return this;
      };
      Selection3.prototype.call = function(callback) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        callback.call.apply(callback, __spreadArray([this._parent, this], __read(args), false));
        return this;
      };
      Selection3.prototype.node = function() {
        return this._elements[0];
      };
      Selection3.prototype.nodes = function() {
        return this._elements;
      };
      Selection3.prototype.transitions = function() {
        return this._transitions.filter(function(t) {
          return !!t;
        });
      };
      Selection3.prototype.parent = function() {
        return this._parent;
      };
      var _Selection_instances, _a, _Selection_maybeAppend;
      _a = Selection3, _Selection_instances = /* @__PURE__ */ new WeakSet(), _Selection_maybeAppend = function _Selection_maybeAppend2(selector, node) {
        var element = this._elements[0];
        var child = element.querySelector(selector);
        if (child)
          return new _a([child], null, this._parent, this._document);
        var newChild = typeof node === "string" ? this.createElement(node) : node();
        element.appendChild(newChild);
        return new _a([newChild], null, this._parent, this._document);
      };
      Selection3.registry = {
        g: Group2,
        rect: Rect,
        circle: Circle,
        path: Path2,
        text: Text2,
        ellipse: Ellipse,
        image: Image2,
        line: Line,
        polygon: Polygon,
        polyline: Polyline,
        html: HTML
      };
      return Selection3;
    }()
  );
  function select2(node) {
    return new Selection2([node], null, node, node.ownerDocument);
  }
  function maybeAppend(parent, selector, node) {
    if (!parent.querySelector(selector)) {
      return select2(parent).append(node);
    }
    return select2(parent).select(selector);
  }

  // node_modules/@antv/component/esm/util/series.js
  function parseSeriesAttr(series) {
    if (isNumber2(series)) {
      return [series, series, series, series];
    }
    if (isArray(series)) {
      var len5 = series.length;
      if (len5 === 1) {
        return [series[0], series[0], series[0], series[0]];
      }
      if (len5 === 2) {
        return [series[0], series[1], series[0], series[1]];
      }
      if (len5 === 3) {
        return [series[0], series[1], series[2], series[1]];
      }
      if (len5 === 4) {
        return series;
      }
    }
    return [0, 0, 0, 0];
  }

  // node_modules/@antv/component/esm/util/shape.js
  function getLocalBBox(shape23) {
    var _a = shape23.getLocalBounds(), min10 = _a.min, max11 = _a.max;
    var _b = __read([min10, max11], 2), _c = __read(_b[0], 2), x12 = _c[0], y12 = _c[1], _d = __read(_b[1], 2), x22 = _d[0], y22 = _d[1];
    return { x: x12, y: y12, width: x22 - x12, height: y22 - y12, left: x12, bottom: y22, top: y12, right: x22 };
  }
  function isHorizontal(p1, p2) {
    var _a = __read(p1, 2), x12 = _a[0], y12 = _a[1];
    var _b = __read(p2, 2), x22 = _b[0], y22 = _b[1];
    return x12 !== x22 && y12 === y22;
  }
  function copyAttributes2(target, source) {
    var e_1, _a;
    var attributes = source.attributes;
    try {
      for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2), key = _d[0], value2 = _d[1];
        if (key !== "id" && key !== "className")
          target.attr(key, value2);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  }

  // node_modules/@antv/component/esm/util/string.js
  function toUppercaseFirstLetter(string) {
    return string.toString().charAt(0).toUpperCase() + string.toString().slice(1);
  }
  function toLowercaseFirstLetter(string) {
    return string.toString().charAt(0).toLowerCase() + string.toString().slice(1);
  }
  function addPrefix(string, prefix) {
    return "".concat(prefix).concat(toUppercaseFirstLetter(string));
  }
  function removePrefix(string, prefix, lowercaseFirstLetter) {
    var _a;
    if (lowercaseFirstLetter === void 0) {
      lowercaseFirstLetter = true;
    }
    var inferPrefix = prefix || ((_a = string.match(/^([a-z][a-z0-9]+)/)) === null || _a === void 0 ? void 0 : _a[0]) || "";
    var withoutPrefix = string.replace(new RegExp("^(".concat(inferPrefix, ")")), "");
    return lowercaseFirstLetter ? toLowercaseFirstLetter(withoutPrefix) : withoutPrefix;
  }

  // node_modules/@antv/component/esm/util/style.js
  function applyStyleSheet(element, style) {
    Object.entries(style).forEach(function(_a) {
      var _b = __read(_a, 2), selector = _b[0], styleString = _b[1];
      __spreadArray([element], __read(element.querySelectorAll(selector)), false).filter(function(el) {
        return el.matches(selector);
      }).forEach(function(target) {
        if (!target)
          return;
        var temp = target;
        temp.style.cssText += Object.entries(styleString).reduce(function(total, currVal) {
          return "".concat(total).concat(currVal.join(":"), ";");
        }, "");
      });
    });
  }
  var startsWith = function(text, prefix) {
    if (!(text === null || text === void 0 ? void 0 : text.startsWith(prefix)))
      return false;
    var nextChart = text[prefix.length];
    return nextChart >= "A" && nextChart <= "Z";
  };
  function subStyleProps(style, prefix, invert5) {
    if (invert5 === void 0) {
      invert5 = false;
    }
    var result = {};
    Object.entries(style).forEach(function(_a) {
      var _b = __read(_a, 2), key = _b[0], value2 = _b[1];
      if (key === "className" || key === "class") {
      } else if (startsWith(key, "show") && startsWith(removePrefix(key, "show"), prefix) !== invert5) {
        if (key === addPrefix(prefix, "show"))
          result[key] = value2;
        else
          result[key.replace(new RegExp(toUppercaseFirstLetter(prefix)), "")] = value2;
      } else if (!startsWith(key, "show") && startsWith(key, prefix) !== invert5) {
        var name_1 = removePrefix(key, prefix);
        if (name_1 === "filter" && typeof value2 === "function") {
        } else
          result[name_1] = value2;
      }
    });
    return result;
  }
  function superStyleProps(style, prefix) {
    return Object.entries(style).reduce(function(acc, _a) {
      var _b = __read(_a, 2), key = _b[0], value2 = _b[1];
      if (key.startsWith("show"))
        acc["show".concat(prefix).concat(key.slice(4))] = value2;
      else
        acc["".concat(prefix).concat(toUppercaseFirstLetter(key))] = value2;
      return acc;
    }, {});
  }
  function splitStyle(style, ignoreStyleDict) {
    if (ignoreStyleDict === void 0) {
      ignoreStyleDict = ["x", "y", "class", "className"];
    }
    var groupStyleDict = [
      "transform",
      "transformOrigin",
      "anchor",
      "visibility",
      "pointerEvents",
      "zIndex",
      "cursor",
      "clipPath",
      "clipPathTargets",
      "offsetPath",
      "offsetPathTargets",
      "offsetDistance",
      "draggable",
      "droppable"
    ];
    var output = {};
    var groupStyle = {};
    Object.entries(style).forEach(function(_a) {
      var _b = __read(_a, 2), key = _b[0], val = _b[1];
      if (ignoreStyleDict.includes(key)) {
      } else if (groupStyleDict.indexOf(key) !== -1)
        groupStyle[key] = val;
      else
        output[key] = val;
    });
    return [output, groupStyle];
  }

  // node_modules/@antv/component/esm/util/transform.js
  function getTranslate(node, x3, y3) {
    var _a = node.getBBox(), width = _a.width, height = _a.height;
    var _b = __read([x3, y3].map(function(v, i) {
      var _a2;
      return v.includes("%") ? parseFloat(((_a2 = v.match(/[+-]?([0-9]*[.])?[0-9]+/)) === null || _a2 === void 0 ? void 0 : _a2[0]) || "0") / 100 * (i === 0 ? width : height) : v;
    }), 2), tx = _b[0], ty = _b[1];
    return [tx, ty];
  }
  function percentTransform(node, val) {
    if (!val)
      return;
    try {
      var reg = /translate\(([+-]*[\d]+[%]*),[ ]*([+-]*[\d]+[%]*)\)/g;
      var computedVal = val.replace(reg, function(match2, x3, y3) {
        return "translate(".concat(getTranslate(node, x3, y3), ")");
      });
      node.attr("transform", computedVal);
    } catch (e3) {
    }
  }

  // node_modules/@antv/component/esm/util/transpose.js
  function transpose3(m3) {
    var _a;
    return ((_a = m3[0]) === null || _a === void 0 ? void 0 : _a.map(function(x3, i) {
      return m3.map(function(x4) {
        return x4[i];
      });
    })) || [];
  }

  // node_modules/@antv/component/esm/util/replace-children.js
  var replaceChildren = function(el, content) {
    if (content == null) {
      el.innerHTML = "";
      return;
    }
    if (el.replaceChildren) {
      if (Array.isArray(content)) {
        el.replaceChildren.apply(el, __spreadArray([], __read(content), false));
      } else {
        el.replaceChildren(content);
      }
    } else {
      el.innerHTML = "";
      if (Array.isArray(content)) {
        content.forEach(function(child) {
          return el.appendChild(child);
        });
      } else {
        el.appendChild(content);
      }
    }
  };

  // node_modules/@antv/component/esm/core/component.js
  function applyVisibility() {
    visibility(this, this.attributes.visibility !== "hidden");
  }
  var Component = (
    /** @class */
    function(_super) {
      __extends(Component2, _super);
      function Component2(options, defaultStyleProps) {
        if (defaultStyleProps === void 0) {
          defaultStyleProps = {};
        }
        var _this = _super.call(this, deepAssign2({}, { style: defaultStyleProps }, options)) || this;
        _this.initialized = false;
        _this._defaultOptions = defaultStyleProps;
        return _this;
      }
      Object.defineProperty(Component2.prototype, "offscreenGroup", {
        get: function() {
          if (!this._offscreen)
            this._offscreen = createOffscreenGroup(this);
          return this._offscreen;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Component2.prototype, "defaultOptions", {
        get: function() {
          return this._defaultOptions;
        },
        enumerable: false,
        configurable: true
      });
      Component2.prototype.connectedCallback = function() {
        this.render(this.attributes, this);
        this.bindEvents(this.attributes, this);
        this.initialized = true;
      };
      Component2.prototype.disconnectedCallback = function() {
        var _a;
        (_a = this._offscreen) === null || _a === void 0 ? void 0 : _a.destroy();
      };
      Component2.prototype.attributeChangedCallback = function(name2) {
        if (name2 === "visibility") {
          applyVisibility.call(this);
        }
      };
      Component2.prototype.update = function(attr2, animate2) {
        var _a;
        this.attr(deepAssign2({}, this.attributes, attr2 || {}));
        return (_a = this.render) === null || _a === void 0 ? void 0 : _a.call(this, this.attributes, this, animate2);
      };
      Component2.prototype.clear = function() {
        this.removeChildren();
      };
      Component2.prototype.bindEvents = function(attributes, container) {
      };
      Component2.prototype.getSubShapeStyle = function(attributes) {
        var x3 = attributes.x, y3 = attributes.y, transform = attributes.transform, transformOrigin = attributes.transformOrigin, _class = attributes.class, className2 = attributes.className, zIndex = attributes.zIndex, style = __rest(attributes, ["x", "y", "transform", "transformOrigin", "class", "className", "zIndex"]);
        return style;
      };
      return Component2;
    }(CustomElement)
  );

  // node_modules/@antv/component/esm/ui/marker/symbol.js
  var circle = function(x3, y3, r) {
    return [["M", x3 - r, y3], ["A", r, r, 0, 1, 0, x3 + r, y3], ["A", r, r, 0, 1, 0, x3 - r, y3], ["Z"]];
  };
  var point5 = circle;
  var square2 = function(x3, y3, r) {
    return [["M", x3 - r, y3 - r], ["L", x3 + r, y3 - r], ["L", x3 + r, y3 + r], ["L", x3 - r, y3 + r], ["Z"]];
  };
  var diamond2 = function(x3, y3, r) {
    return [["M", x3 - r, y3], ["L", x3, y3 - r], ["L", x3 + r, y3], ["L", x3, y3 + r], ["Z"]];
  };
  var triangle2 = function(x3, y3, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x3 - r, y3 + diffY], ["L", x3, y3 - diffY], ["L", x3 + r, y3 + diffY], ["Z"]];
  };
  var triangleDown2 = function(x3, y3, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 - diffY], ["L", x3, y3 + diffY], ["Z"]];
  };
  var hexagon2 = function(x3, y3, r) {
    var diffX = r / 2 * Math.sqrt(3);
    return [
      ["M", x3, y3 - r],
      ["L", x3 + diffX, y3 - r / 2],
      ["L", x3 + diffX, y3 + r / 2],
      ["L", x3, y3 + r],
      ["L", x3 - diffX, y3 + r / 2],
      ["L", x3 - diffX, y3 - r / 2],
      ["Z"]
    ];
  };
  var bowtie2 = function(x3, y3, r) {
    var diffY = r - 1.5;
    return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 + diffY], ["L", x3 + r, y3 - diffY], ["L", x3 - r, y3 + diffY], ["Z"]];
  };
  var line2 = function(x3, y3, r) {
    return [
      ["M", x3, y3 + r],
      ["L", x3, y3 - r]
    ];
  };
  var cross5 = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3 - r],
      ["L", x3 + r, y3 + r],
      ["M", x3 + r, y3 - r],
      ["L", x3 - r, y3 + r]
    ];
  };
  var tick2 = function(x3, y3, r) {
    return [
      ["M", x3 - r / 2, y3 - r],
      ["L", x3 + r / 2, y3 - r],
      ["M", x3, y3 - r],
      ["L", x3, y3 + r],
      ["M", x3 - r / 2, y3 + r],
      ["L", x3 + r / 2, y3 + r]
    ];
  };
  var plus2 = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3],
      ["M", x3, y3 - r],
      ["L", x3, y3 + r]
    ];
  };
  var hyphen2 = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3]
    ];
  };
  var dot7 = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3]
    ];
  };
  var dash2 = dot7;
  var smooth2 = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3],
      ["A", r / 2, r / 2, 0, 1, 1, x3, y3],
      ["A", r / 2, r / 2, 0, 1, 0, x3 + r, y3]
    ];
  };
  var hv2 = function(x3, y3, r) {
    return [
      ["M", x3 - r - 1, y3 - 2.5],
      ["L", x3, y3 - 2.5],
      ["L", x3, y3 + 2.5],
      ["L", x3 + r + 1, y3 + 2.5]
    ];
  };
  var vh2 = function(x3, y3, r) {
    return [
      ["M", x3 - r - 1, y3 + 2.5],
      ["L", x3, y3 + 2.5],
      ["L", x3, y3 - 2.5],
      ["L", x3 + r + 1, y3 - 2.5]
    ];
  };
  var hvh2 = function(x3, y3, r) {
    return [
      ["M", x3 - (r + 1), y3 + 2.5],
      ["L", x3 - r / 2, y3 + 2.5],
      ["L", x3 - r / 2, y3 - 2.5],
      ["L", x3 + r / 2, y3 - 2.5],
      ["L", x3 + r / 2, y3 + 2.5],
      ["L", x3 + r + 1, y3 + 2.5]
    ];
  };
  function vhv2(x3, y3) {
    return [
      ["M", x3 - 5, y3 + 2.5],
      ["L", x3 - 5, y3],
      ["L", x3, y3],
      ["L", x3, y3 - 3],
      ["L", x3, y3 + 3],
      ["L", x3 + 6.5, y3 + 3]
    ];
  }
  var button = function(x3, y3, r) {
    return [["M", x3 - r, y3 - r], ["L", x3 + r, y3], ["L", x3 - r, y3 + r], ["Z"]];
  };

  // node_modules/@antv/component/esm/ui/marker/utils.js
  function parseMarker(icon) {
    var type = "default";
    if (is_object_default(icon) && icon instanceof Image)
      type = "image";
    else if (isFunction(icon))
      type = "symbol";
    else if (isString2(icon)) {
      var dataURLsPattern = new RegExp("data:(image|text)");
      if (icon.match(dataURLsPattern)) {
        type = "base64";
      } else if (/^(https?:\/\/(([a-zA-Z0-9]+-?)+[a-zA-Z0-9]+\.)+[a-zA-Z]+)(:\d+)?(\/.*)?(\?.*)?(#.*)?$/.test(icon)) {
        type = "url";
      } else {
        type = "symbol";
      }
    }
    return type;
  }

  // node_modules/@antv/component/esm/ui/marker/index.js
  function getType(symbol) {
    var markerType = parseMarker(symbol);
    if (["base64", "url", "image"].includes(markerType)) {
      return "image";
    }
    if (symbol && markerType === "symbol") {
      return "path";
    }
    return null;
  }
  var Marker = (
    /** @class */
    function(_super) {
      __extends(Marker2, _super);
      function Marker2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Marker2.prototype.render = function(attributes, container) {
        var _a = attributes.x, x3 = _a === void 0 ? 0 : _a, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
        var _c = this.getSubShapeStyle(attributes), symbol = _c.symbol, _d = _c.size, size2 = _d === void 0 ? 16 : _d, style = __rest(_c, ["symbol", "size"]);
        var type = getType(symbol);
        ifShow(!!type, select2(container), function(group3) {
          group3.maybeAppendByClassName("marker", type).attr("className", "marker ".concat(type, "-marker")).call(function(selection) {
            if (type === "image") {
              var r = size2 * 2;
              selection.styles({
                img: symbol,
                width: r,
                height: r,
                x: x3 - size2,
                y: y3 - size2
              });
            } else {
              var r = size2 / 2;
              var symbolFn = isFunction(symbol) ? symbol : Marker2.getSymbol(symbol);
              selection.styles(__assign({ d: symbolFn === null || symbolFn === void 0 ? void 0 : symbolFn(x3, y3, r) }, style));
            }
          });
        });
      };
      Marker2.MARKER_SYMBOL_MAP = /* @__PURE__ */ new Map();
      Marker2.registerSymbol = function(type, symbol) {
        Marker2.MARKER_SYMBOL_MAP.set(type, symbol);
      };
      Marker2.getSymbol = function(type) {
        return Marker2.MARKER_SYMBOL_MAP.get(type);
      };
      Marker2.getSymbols = function() {
        return Array.from(Marker2.MARKER_SYMBOL_MAP.keys());
      };
      return Marker2;
    }(Component)
  );
  Marker.registerSymbol("cross", cross5);
  Marker.registerSymbol("hyphen", hyphen2);
  Marker.registerSymbol("line", line2);
  Marker.registerSymbol("plus", plus2);
  Marker.registerSymbol("tick", tick2);
  Marker.registerSymbol("circle", circle);
  Marker.registerSymbol("point", point5);
  Marker.registerSymbol("bowtie", bowtie2);
  Marker.registerSymbol("hexagon", hexagon2);
  Marker.registerSymbol("square", square2);
  Marker.registerSymbol("diamond", diamond2);
  Marker.registerSymbol("triangle", triangle2);
  Marker.registerSymbol("triangle-down", triangleDown2);
  Marker.registerSymbol("line", line2);
  Marker.registerSymbol("dot", dot7);
  Marker.registerSymbol("dash", dash2);
  Marker.registerSymbol("smooth", smooth2);
  Marker.registerSymbol("hv", hv2);
  Marker.registerSymbol("vh", vh2);
  Marker.registerSymbol("hvh", hvh2);
  Marker.registerSymbol("vhv", vhv2);

  // node_modules/@antv/component/esm/ui/sparkline/columns.js
  var Columns = (
    /** @class */
    function(_super) {
      __extends(Columns2, _super);
      function Columns2(_a) {
        var _this = this;
        var style = _a.style, rest = __rest(_a, ["style"]);
        _this = _super.call(this, deep_mix_default({}, { type: "column" }, __assign({ style }, rest))) || this;
        _this.columnsGroup = new Group2({ name: "columns" });
        _this.appendChild(_this.columnsGroup);
        _this.render();
        return _this;
      }
      Columns2.prototype.render = function() {
        var _a = this.attributes, columns = _a.columns, x3 = _a.x, y3 = _a.y;
        this.columnsGroup.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        select2(this.columnsGroup).selectAll(".column").data(columns.flat()).join(function(enter) {
          return enter.append("rect").attr("className", "column").each(function(style) {
            this.attr(style);
          });
        }, function(update) {
          return update.each(function(style) {
            this.attr(style);
          });
        }, function(exit) {
          return exit.remove();
        });
      };
      Columns2.prototype.update = function(attr2) {
        this.attr(deepAssign2({}, this.attributes, attr2));
        this.render();
      };
      Columns2.prototype.clear = function() {
        this.removeChildren();
      };
      return Columns2;
    }(DisplayObject)
  );

  // node_modules/@antv/component/esm/ui/sparkline/lines.js
  var Lines = (
    /** @class */
    function(_super) {
      __extends(Lines2, _super);
      function Lines2(_a) {
        var _this = this;
        var style = _a.style, rest = __rest(_a, ["style"]);
        _this = _super.call(this, deep_mix_default({}, { type: "lines" }, __assign({ style }, rest))) || this;
        _this.linesGroup = _this.appendChild(new Group2());
        _this.areasGroup = _this.appendChild(new Group2());
        _this.render();
        return _this;
      }
      Lines2.prototype.render = function() {
        var _a = this.attributes, lines = _a.lines, areas = _a.areas, x3 = _a.x, y3 = _a.y;
        this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        if (lines)
          this.renderLines(lines);
        if (areas)
          this.renderAreas(areas);
      };
      Lines2.prototype.clear = function() {
        this.linesGroup.removeChildren();
        this.areasGroup.removeChildren();
      };
      Lines2.prototype.update = function(attr2) {
        this.attr(deepAssign2({}, this.attributes, attr2));
        this.render();
      };
      Lines2.prototype.renderLines = function(lines) {
        select2(this.linesGroup).selectAll(".line").data(lines).join(function(enter) {
          return enter.append("path").attr("className", "line").each(function(style) {
            this.attr(style);
          });
        }, function(update) {
          return update.each(function(style) {
            this.attr(style);
          });
        }, function(exit) {
          return exit.remove();
        });
      };
      Lines2.prototype.renderAreas = function(areas) {
        select2(this.linesGroup).selectAll(".area").data(areas).join(function(enter) {
          return enter.append("path").attr("className", "area").each(function(style) {
            this.attr(style);
          });
        }, function(update) {
          return update.each(function(style) {
            this.style(style);
          });
        }, function(exit) {
          return exit.remove();
        });
      };
      return Lines2;
    }(DisplayObject)
  );

  // node_modules/@antv/component/esm/ui/sparkline/path.js
  function dataToLines(data2, scales) {
    var _a;
    var x3 = scales.x, y3 = scales.y;
    var _b = __read(y3.getOptions().range || [0, 0], 2), max11 = _b[0], min10 = _b[1];
    if (min10 > max11)
      _a = __read([max11, min10], 2), min10 = _a[0], max11 = _a[1];
    return data2.map(function(points) {
      var lines = points.map(function(val, idx) {
        return [x3.map(idx), clamp_default(y3.map(val), min10, max11)];
      });
      return lines;
    });
  }
  function lineToLinePath(line4, reverse) {
    if (reverse === void 0) {
      reverse = false;
    }
    var M2 = reverse ? line4.length - 1 : 0;
    var linePath = line4.map(function(point6, idx) {
      return __spreadArray([idx === M2 ? "M" : "L"], __read(point6), false);
    });
    return reverse ? linePath.reverse() : linePath;
  }
  function lineToCurvePath(line4, reverse) {
    if (reverse === void 0) {
      reverse = false;
    }
    if (line4.length <= 2) {
      return lineToLinePath(line4);
    }
    var data2 = [];
    var len5 = line4.length;
    for (var idx = 0; idx < len5; idx += 1) {
      var point6 = reverse ? line4[len5 - idx - 1] : line4[idx];
      if (!is_equal_default(point6, data2.slice(-2))) {
        data2.push.apply(data2, __spreadArray([], __read(point6), false));
      }
    }
    var path2 = catmullRom2Bezier(data2, false);
    if (reverse) {
      path2.unshift(__spreadArray(["M"], __read(line4[len5 - 1]), false));
    } else {
      path2.unshift(__spreadArray(["M"], __read(line4[0]), false));
    }
    return path2;
  }
  function closePathByBaseLine(path2, width, baseline) {
    var closedPath = clone_default(path2);
    closedPath.push(["L", width, baseline], ["L", 0, baseline], ["Z"]);
    return closedPath;
  }
  function linesToAreaPaths(lines, smooth3, width, baseline) {
    return lines.map(function(line4) {
      return closePathByBaseLine(smooth3 ? lineToCurvePath(line4) : lineToLinePath(line4), width, baseline);
    });
  }
  function linesToStackAreaPaths(lines, width, baseline) {
    var paths = [];
    for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
      var currLine = lines[idx];
      var currCurvePath = lineToLinePath(currLine);
      var path2 = void 0;
      if (idx === 0) {
        path2 = closePathByBaseLine(currCurvePath, width, baseline);
      } else {
        var belowLine = lines[idx - 1];
        var belowCurvePath = lineToLinePath(belowLine, true);
        belowCurvePath[0][0] = "L";
        path2 = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [["Z"]], false);
      }
      paths.push(path2);
    }
    return paths;
  }
  function linesToStackCurveAreaPaths(lines, width, baseline) {
    var paths = [];
    for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
      var currLine = lines[idx];
      var currCurvePath = lineToCurvePath(currLine);
      var path2 = void 0;
      if (idx === 0) {
        path2 = closePathByBaseLine(currCurvePath, width, baseline);
      } else {
        var belowLine = lines[idx - 1];
        var belowCurvePath = lineToCurvePath(belowLine, true);
        var A5 = currLine[0];
        belowCurvePath[0][0] = "L";
        path2 = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [__spreadArray(["M"], __read(A5), false), ["Z"]], false);
      }
      paths.push(path2);
    }
    return paths;
  }

  // node_modules/@antv/component/esm/ui/sparkline/utils.js
  function getRange(data2) {
    if (data2.length === 0)
      return [0, 0];
    return [
      min_default(min_by_default(data2, function(arr) {
        return min_default(arr) || 0;
      })),
      max(max_by_default(data2, function(arr) {
        return max(arr) || 0;
      }))
    ];
  }
  function getStackedData(_2) {
    var data2 = clone_default(_2);
    var datumLen = data2[0].length;
    var _a = __read([Array(datumLen).fill(0), Array(datumLen).fill(0)], 2), positivePrev = _a[0], negativePrev = _a[1];
    for (var i = 0; i < data2.length; i += 1) {
      var datum = data2[i];
      for (var j = 0; j < datumLen; j += 1) {
        if (datum[j] >= 0) {
          datum[j] += positivePrev[j];
          positivePrev[j] = datum[j];
        } else {
          datum[j] += negativePrev[j];
          negativePrev[j] = datum[j];
        }
      }
    }
    return data2;
  }

  // node_modules/@antv/component/esm/ui/sparkline/index.js
  var Sparkline = (
    /** @class */
    function(_super) {
      __extends(Sparkline2, _super);
      function Sparkline2(options) {
        return _super.call(this, options, {
          type: "line",
          x: 0,
          y: 0,
          width: 200,
          height: 20,
          isStack: false,
          color: ["#83daad", "#edbf45", "#d2cef9", "#e290b3", "#6f63f4"],
          smooth: true,
          lineLineWidth: 1,
          areaOpacity: 0,
          isGroup: false,
          columnLineWidth: 1,
          columnStroke: "#fff",
          scale: 1,
          spacing: 0
        }) || this;
      }
      Object.defineProperty(Sparkline2.prototype, "rawData", {
        /**
         * 将data统一格式化为数组形式
         * 如果堆叠，则生成堆叠数据
         */
        get: function() {
          var rawData = this.attributes.data;
          if (!rawData || (rawData === null || rawData === void 0 ? void 0 : rawData.length) === 0)
            return [[]];
          var data2 = clone_default(rawData);
          return isNumber2(data2[0]) ? [data2] : data2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "data", {
        get: function() {
          if (this.attributes.isStack)
            return getStackedData(this.rawData);
          return this.rawData;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "scales", {
        get: function() {
          return this.createScales(this.data);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "baseline", {
        /**
         * 基准线，默认为 0
         */
        get: function() {
          var y3 = this.scales.y;
          var _a = __read(y3.getOptions().domain || [0, 0], 2), y12 = _a[0], y22 = _a[1];
          if (y22 < 0) {
            return y3.map(y22);
          }
          return y3.map(y12 < 0 ? 0 : y12);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "containerShape", {
        get: function() {
          var _a = this.attributes, width = _a.width, height = _a.height;
          return { width, height };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "linesStyle", {
        get: function() {
          var _this = this;
          var _a = this.attributes, type = _a.type, isStack = _a.isStack, smooth3 = _a.smooth;
          if (type !== "line")
            throw new Error("linesStyle can only be used in line type");
          var areaStyle = subStyleProps(this.attributes, "area");
          var lineStyle = subStyleProps(this.attributes, "line");
          var width = this.containerShape.width;
          var data2 = this.data;
          if (data2[0].length === 0)
            return { lines: [], areas: [] };
          var _b = this.scales, x3 = _b.x, y3 = _b.y;
          var lines = dataToLines(data2, { type: "line", x: x3, y: y3 });
          var areas = [];
          if (areaStyle) {
            var baseline = this.baseline;
            if (isStack) {
              areas = smooth3 ? linesToStackCurveAreaPaths(lines, width, baseline) : linesToStackAreaPaths(lines, width, baseline);
            } else {
              areas = linesToAreaPaths(lines, smooth3, width, baseline);
            }
          }
          return {
            lines: lines.map(function(line4, idx) {
              return __assign({ stroke: _this.getColor(idx), d: smooth3 ? lineToCurvePath(line4) : lineToLinePath(line4) }, lineStyle);
            }),
            areas: areas.map(function(path2, idx) {
              return __assign({ d: path2, fill: _this.getColor(idx) }, areaStyle);
            })
          };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "columnsStyle", {
        get: function() {
          var _this = this;
          var columnStyle = subStyleProps(this.attributes, "column");
          var _a = this.attributes, isStack = _a.isStack, type = _a.type, scale10 = _a.scale;
          if (type !== "column")
            throw new Error("columnsStyle can only be used in column type");
          var height = this.containerShape.height;
          var data2 = this.rawData;
          if (!data2)
            return { columns: [] };
          if (isStack)
            data2 = getStackedData(data2);
          var _b = this.createScales(data2), x3 = _b.x, y3 = _b.y;
          var _c = __read(getRange(data2), 2), minVal = _c[0], maxVal = _c[1];
          var heightScale = new Linear({
            domain: [0, maxVal - (minVal > 0 ? 0 : minVal)],
            range: [0, height * scale10]
          });
          var bandWidth3 = x3.getBandWidth();
          var rawData = this.rawData;
          return {
            columns: data2.map(function(column2, i) {
              return column2.map(function(val, j) {
                var barWidth = bandWidth3 / data2.length;
                var getShape2 = function() {
                  return {
                    x: x3.map(j) + barWidth * i,
                    y: val >= 0 ? y3.map(val) : y3.map(0),
                    width: barWidth,
                    height: heightScale.map(Math.abs(val))
                  };
                };
                var getStackShape = function() {
                  return {
                    x: x3.map(j),
                    y: y3.map(val),
                    width: bandWidth3,
                    height: heightScale.map(rawData[i][j])
                  };
                };
                return __assign(__assign({ fill: _this.getColor(i) }, columnStyle), isStack ? getStackShape() : getShape2());
              });
            })
          };
        },
        enumerable: false,
        configurable: true
      });
      Sparkline2.prototype.render = function(attributes, container) {
        maybeAppend(container, ".container", "rect").attr("className", "container").node();
        var type = attributes.type, x3 = attributes.x, y3 = attributes.y;
        var className2 = "spark".concat(type);
        var style = __assign({ x: x3, y: y3 }, type === "line" ? this.linesStyle : this.columnsStyle);
        select2(container).selectAll(".spark").data([type]).join(function(enter) {
          return enter.append(function(type2) {
            if (type2 === "line")
              return new Lines({ className: className2, style });
            return new Columns({ className: className2, style });
          }).attr("className", "spark ".concat(className2));
        }, function(update) {
          return update.update(style);
        }, function(exit) {
          return exit.remove();
        });
      };
      Sparkline2.prototype.getColor = function(index4) {
        var color2 = this.attributes.color;
        if (isArray(color2)) {
          return color2[index4 % color2.length];
        }
        if (isFunction(color2)) {
          return color2.call(null, index4);
        }
        return color2;
      };
      Sparkline2.prototype.createScales = function(data2) {
        var _a, _b;
        var _c = this.attributes, type = _c.type, scale10 = _c.scale, _d = _c.range, range3 = _d === void 0 ? [] : _d, spacing = _c.spacing;
        var _e = this.containerShape, width = _e.width, height = _e.height;
        var _f = __read(getRange(data2), 2), minVal = _f[0], maxVal = _f[1];
        var yScale = new Linear({
          domain: [(_a = range3[0]) !== null && _a !== void 0 ? _a : minVal, (_b = range3[1]) !== null && _b !== void 0 ? _b : maxVal],
          range: [height, height * (1 - scale10)]
        });
        if (type === "line") {
          return {
            type,
            x: new Linear({
              domain: [0, data2[0].length - 1],
              range: [0, width]
            }),
            y: yScale
          };
        }
        return {
          type,
          x: new Band({
            domain: data2[0].map(function(val, idx) {
              return idx;
            }),
            range: [0, width],
            paddingInner: spacing,
            paddingOuter: spacing / 2,
            align: 0.5
          }),
          y: yScale
        };
      };
      Sparkline2.tag = "sparkline";
      return Sparkline2;
    }(Component)
  );

  // node_modules/@antv/component/esm/animation/utils.js
  function isStandardAnimationOption(option2) {
    if (typeof option2 === "boolean")
      return false;
    return "enter" in option2 && "update" in option2 && "exit" in option2;
  }
  function parseAnimationOption(option2) {
    if (!option2)
      return { enter: false, update: false, exit: false };
    var keys2 = ["enter", "update", "exit"];
    var baseOption = Object.fromEntries(Object.entries(option2).filter(function(_a) {
      var _b = __read(_a, 1), k = _b[0];
      return !keys2.includes(k);
    }));
    return Object.fromEntries(keys2.map(function(k) {
      if (isStandardAnimationOption(option2)) {
        if (option2[k] === false)
          return [k, false];
        return [k, __assign(__assign({}, option2[k]), baseOption)];
      }
      return [k, baseOption];
    }));
  }
  function onAnimateFinished(animation, callback) {
    if (!animation)
      callback();
    else
      animation.finished.then(callback);
  }
  function onAnimatesFinished(animations, callback) {
    if (animations.length === 0)
      callback();
    else
      Promise.all(animations.map(function(a3) {
        return a3 === null || a3 === void 0 ? void 0 : a3.finished;
      })).then(callback);
  }
  function attr(target, value2) {
    if ("update" in target)
      target.update(value2);
    else
      target.attr(value2);
  }
  function animate(target, keyframes, options) {
    if (keyframes.length === 0)
      return null;
    if (!options) {
      var state = keyframes.slice(-1)[0];
      attr(target, { style: state });
      return null;
    }
    return target.animate(keyframes, options);
  }
  function identicalTextNode(source, target) {
    if (source.nodeName !== "text" || target.nodeName !== "text")
      return false;
    if (source.attributes.text !== target.attributes.text)
      return false;
    return true;
  }
  function transitionShape(source, target, options, after) {
    if (after === void 0) {
      after = "destroy";
    }
    if (identicalTextNode(source, target)) {
      source.remove();
      return [null];
    }
    var afterTransition = function() {
      if (after === "destroy")
        source.destroy();
      else if (after === "hide")
        hide(source);
      if (target.isVisible())
        show(target);
    };
    if (!options) {
      afterTransition();
      return [null];
    }
    var _a = options.duration, duration = _a === void 0 ? 0 : _a, _b = options.delay, delay = _b === void 0 ? 0 : _b;
    var middle = Math.ceil(+duration / 2);
    var offset3 = +duration / 4;
    var _c = __read(source.getGeometryBounds().center, 2), sx = _c[0], sy = _c[1];
    var _d = __read(target.getGeometryBounds().center, 2), ex = _d[0], ey = _d[1];
    var _e = __read([(sx + ex) / 2 - sx, (sy + ey) / 2 - sy], 2), mx = _e[0], my = _e[1];
    var _f = source.style.opacity, so = _f === void 0 ? 1 : _f;
    var _g = target.style.opacity, to = _g === void 0 ? 1 : _g;
    var st = source.style.transform || "";
    var tt = target.style.transform || "";
    var sourceAnimation = source.animate([
      { opacity: so, transform: "translate(0, 0) ".concat(st) },
      { opacity: 0, transform: "translate(".concat(mx, ", ").concat(my, ") ").concat(st) }
    ], __assign(__assign({ fill: "both" }, options), { duration: delay + middle + offset3 }));
    var targetAnimation = target.animate([
      { opacity: 0, transform: "translate(".concat(-mx, ", ").concat(-my, ") ").concat(tt), offset: 0.01 },
      { opacity: to, transform: "translate(0, 0) ".concat(tt) }
    ], __assign(__assign({ fill: "both" }, options), { duration: middle + offset3, delay: delay + middle - offset3 }));
    onAnimateFinished(targetAnimation, afterTransition);
    return [sourceAnimation, targetAnimation];
  }
  function transition(target, state, options) {
    var from = {};
    var to = {};
    Object.entries(state).forEach(function(_a) {
      var _b = __read(_a, 2), key = _b[0], tarStyle = _b[1];
      if (!isNil(tarStyle)) {
        var currStyle = target.style[key] || target.parsedStyle[key] || 0;
        if (currStyle !== tarStyle) {
          from[key] = currStyle;
          to[key] = tarStyle;
        }
      }
    });
    if (!options) {
      attr(target, to);
      return null;
    }
    return animate(target, [from, to], __assign({ fill: "both" }, options));
  }

  // node_modules/@antv/component/esm/animation/fadeOut.js
  function fadeOut_default(element, options) {
    if (!element.style.opacity)
      element.style.opacity = 1;
    return transition(element, { opacity: 0 }, options);
  }

  // node_modules/@antv/component/esm/ui/slider/constant.js
  var HANDLE_ICON_DEFAULT_CFG = {
    fill: "#fff",
    lineWidth: 1,
    radius: 2,
    size: 10,
    stroke: "#bfbfbf",
    strokeOpacity: 1,
    zIndex: 0
  };
  var HANDLE_LABEL_DEFAULT_CFG = {
    fill: "#000",
    fillOpacity: 0.45,
    fontSize: 12,
    textAlign: "center",
    textBaseline: "middle",
    zIndex: 1
  };
  var HANDLE_DEFAULT_CFG = {
    x: 0,
    y: 0,
    orientation: "horizontal",
    showLabel: true,
    type: "start"
  };
  var CLASS_NAMES = classNames({
    foreground: "foreground",
    handle: "handle",
    selection: "selection",
    sparkline: "sparkline",
    sparklineGroup: "sparkline-group",
    track: "track",
    brushArea: "brush-area"
  }, "slider");

  // node_modules/@antv/component/esm/ui/slider/handle.js
  var CLASS_NAMES2 = classNames({
    labelGroup: "label-group",
    label: "label",
    iconGroup: "icon-group",
    icon: "icon",
    iconRect: "icon-rect",
    iconLine: "icon-line"
  }, "handle");
  var HandleIcon = (
    /** @class */
    function(_super) {
      __extends(HandleIcon2, _super);
      function HandleIcon2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      HandleIcon2.prototype.render = function(attributes, container) {
        var x3 = attributes.x, y3 = attributes.y, _a = attributes.size, size2 = _a === void 0 ? 10 : _a, _b = attributes.radius, radius = _b === void 0 ? size2 / 4 : _b, orientation = attributes.orientation, iconStyle = __rest(attributes, ["x", "y", "size", "radius", "orientation"]);
        var width = size2;
        var height = width * 2.4;
        var rect4 = select2(container).maybeAppendByClassName(CLASS_NAMES2.iconRect, "rect").styles(__assign(__assign({}, iconStyle), { width, height, radius, x: x3 - width / 2, y: y3 - height / 2, transformOrigin: "center" }));
        var x12 = x3 + 1 / 3 * width - width / 2;
        var x22 = x3 + 2 / 3 * width - width / 2;
        var y12 = y3 + 1 / 4 * height - height / 2;
        var y22 = y3 + 3 / 4 * height - height / 2;
        rect4.maybeAppendByClassName("".concat(CLASS_NAMES2.iconLine, "-1"), "line").styles(__assign({ x1: x12, x2: x12, y1: y12, y2: y22 }, iconStyle));
        rect4.maybeAppendByClassName("".concat(CLASS_NAMES2.iconLine, "-2"), "line").styles(__assign({ x1: x22, x2: x22, y1: y12, y2: y22 }, iconStyle));
        if (orientation === "vertical")
          rect4.node().style.transform = "rotate(90)";
      };
      return HandleIcon2;
    }(Component)
  );
  var Handle = (
    /** @class */
    function(_super) {
      __extends(Handle3, _super);
      function Handle3(options) {
        return _super.call(this, options, HANDLE_DEFAULT_CFG) || this;
      }
      Handle3.prototype.renderLabel = function(container) {
        var _this = this;
        var _a = this.attributes, x3 = _a.x, y3 = _a.y, showLabel = _a.showLabel;
        var _b = subStyleProps(this.attributes, "label"), _c = _b.x, labelX = _c === void 0 ? 0 : _c, _d = _b.y, labelY = _d === void 0 ? 0 : _d, transform = _b.transform, transformOrigin = _b.transformOrigin, style = __rest(_b, ["x", "y", "transform", "transformOrigin"]);
        var _e = __read(splitStyle(style, []), 2), labelStyle = _e[0], groupStyle = _e[1];
        var labelGroup = select2(container).maybeAppendByClassName(CLASS_NAMES2.labelGroup, "g").styles(groupStyle);
        var _f = __assign(__assign({}, HANDLE_LABEL_DEFAULT_CFG), labelStyle), text = _f.text, rest = __rest(_f, ["text"]);
        ifShow(!!showLabel, labelGroup, function(group3) {
          _this.label = group3.maybeAppendByClassName(CLASS_NAMES2.label, "text").styles(__assign(__assign({}, rest), { x: x3 + labelX, y: y3 + labelY, transform, transformOrigin, text: "".concat(text) }));
          _this.label.on("mousedown", function(e3) {
            e3.stopPropagation();
          });
          _this.label.on("touchstart", function(e3) {
            e3.stopPropagation();
          });
        });
      };
      Handle3.prototype.renderIcon = function(container) {
        var _a = this.attributes, x3 = _a.x, y3 = _a.y, orientation = _a.orientation, type = _a.type;
        var iconStyle = __assign(__assign({ x: x3, y: y3, orientation }, HANDLE_ICON_DEFAULT_CFG), subStyleProps(this.attributes, "icon"));
        var _b = this.attributes.iconShape, iconShape = _b === void 0 ? function() {
          return new HandleIcon({ style: iconStyle });
        } : _b;
        var iconGroup = select2(container).maybeAppendByClassName(CLASS_NAMES2.iconGroup, "g");
        iconGroup.selectAll(CLASS_NAMES2.icon.class).data([iconShape]).join(function(enter) {
          return enter.append(typeof iconShape === "string" ? iconShape : function() {
            return iconShape(type);
          }).attr("className", CLASS_NAMES2.icon.name);
        }, function(update) {
          return update.update(iconStyle);
        }, function(exit) {
          return exit.remove();
        });
      };
      Handle3.prototype.render = function(attributes, container) {
        this.renderIcon(container);
        this.renderLabel(container);
      };
      return Handle3;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/slider/index.js
  var Slider = (
    /** @class */
    function(_super) {
      __extends(Slider3, _super);
      function Slider3(options) {
        var _this = _super.call(this, options, __assign(__assign(__assign({ x: 0, y: 0, animate: { duration: 100, fill: "both" }, brushable: true, formatter: function(val) {
          return val.toString();
        }, handleSpacing: 2, orientation: "horizontal", padding: 0, autoFitLabel: true, scrollable: true, selectionFill: "#5B8FF9", selectionFillOpacity: 0.45, selectionZIndex: 2, showHandle: true, showLabel: true, slidable: true, trackFill: "#416180", trackLength: 200, trackOpacity: 0.05, trackSize: 20, trackZIndex: -1, values: [0, 1], type: "range", selectionType: "select", handleIconOffset: 0 }, superStyleProps(HANDLE_DEFAULT_CFG, "handle")), superStyleProps(HANDLE_ICON_DEFAULT_CFG, "handleIcon")), superStyleProps(HANDLE_LABEL_DEFAULT_CFG, "handleLabel"))) || this;
        _this.range = [0, 1];
        _this.onDragStart = function(target) {
          return function(e3) {
            e3.stopPropagation();
            _this.target = target;
            _this.prevPos = _this.getOrientVal(getEventPos(e3));
            var _a = _this.availableSpace, x3 = _a.x, y3 = _a.y;
            var _b = _this.getBBox(), X = _b.x, Y = _b.y;
            _this.selectionStartPos = _this.getRatio(_this.prevPos - _this.getOrientVal([x3, y3]) - _this.getOrientVal([+X, +Y]));
            _this.selectionWidth = 0;
            document.addEventListener("pointermove", _this.onDragging);
            document.addEventListener("pointerup", _this.onDragEnd);
          };
        };
        _this.onDragging = function(e3) {
          var _a = _this.attributes, slidable = _a.slidable, brushable = _a.brushable, type = _a.type;
          e3.stopPropagation();
          var currPos = _this.getOrientVal(getEventPos(e3));
          var diffPos = currPos - _this.prevPos;
          if (!diffPos)
            return;
          var deltaVal = _this.getRatio(diffPos);
          switch (_this.target) {
            case "start":
              if (slidable)
                _this.setValuesOffset(deltaVal);
              break;
            case "end":
              if (slidable)
                _this.setValuesOffset(0, deltaVal);
              break;
            case "selection":
              if (slidable)
                _this.setValuesOffset(deltaVal, deltaVal);
              break;
            case "track":
              if (!brushable)
                return;
              _this.selectionWidth += deltaVal;
              if (type === "range") {
                _this.innerSetValues([_this.selectionStartPos, _this.selectionStartPos + _this.selectionWidth].sort(), true);
              } else
                _this.innerSetValues([0, _this.selectionStartPos + _this.selectionWidth], true);
              break;
            default:
              break;
          }
          _this.prevPos = currPos;
        };
        _this.onDragEnd = function() {
          document.removeEventListener("pointermove", _this.onDragging);
          document.removeEventListener("pointermove", _this.onDragging);
          document.removeEventListener("pointerup", _this.onDragEnd);
          _this.target = "";
          _this.updateHandlesPosition(false);
        };
        _this.onValueChange = function(oldValue) {
          var _a = _this.attributes, onChange = _a.onChange, type = _a.type;
          var internalOldValue = type === "range" ? oldValue : oldValue[1];
          var value2 = type === "range" ? _this.getValues() : _this.getValues()[1];
          var evt = new CustomEvent2("valuechange", {
            detail: { oldValue: internalOldValue, value: value2 }
          });
          _this.dispatchEvent(evt);
          onChange === null || onChange === void 0 ? void 0 : onChange(value2);
        };
        _this.selectionStartPos = 0;
        _this.selectionWidth = 0;
        _this.prevPos = 0;
        _this.target = "";
        return _this;
      }
      Object.defineProperty(Slider3.prototype, "values", {
        get: function() {
          return this.attributes.values;
        },
        set: function(values) {
          this.attributes.values = this.clampValues(values);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Slider3.prototype, "sparklineStyle", {
        get: function() {
          var orientation = this.attributes.orientation;
          if (orientation !== "horizontal")
            return null;
          var attr2 = subStyleProps(this.attributes, "sparkline");
          return __assign(__assign({ zIndex: 0 }, this.availableSpace), attr2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Slider3.prototype, "shape", {
        get: function() {
          var _a = this.attributes, trackLength = _a.trackLength, trackSize = _a.trackSize;
          var _b = __read(this.getOrientVal([
            [trackLength, trackSize],
            [trackSize, trackLength]
          ]), 2), width = _b[0], height = _b[1];
          return { width, height };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Slider3.prototype, "availableSpace", {
        get: function() {
          var _a = this.attributes, x3 = _a.x, y3 = _a.y, padding = _a.padding;
          var _b = __read(parseSeriesAttr(padding), 4), top = _b[0], right2 = _b[1], bottom = _b[2], left2 = _b[3];
          var _c = this.shape, width = _c.width, height = _c.height;
          return {
            x: left2,
            y: top,
            width: width - (left2 + right2),
            height: height - (top + bottom)
          };
        },
        enumerable: false,
        configurable: true
      });
      Slider3.prototype.getValues = function() {
        return this.values;
      };
      Slider3.prototype.setValues = function(values, animate2) {
        if (values === void 0) {
          values = [0, 0];
        }
        if (animate2 === void 0) {
          animate2 = false;
        }
        this.attributes.values = values;
        var animation = animate2 === false ? false : this.attributes.animate;
        this.updateSelectionArea(animation);
        this.updateHandlesPosition(animation);
      };
      Slider3.prototype.updateSelectionArea = function(animation) {
        var newSelectionArea = this.calcSelectionArea();
        this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).each(function(datum, index4) {
          transition(this, newSelectionArea[index4], animation);
        });
      };
      Slider3.prototype.updateHandlesPosition = function(animation) {
        if (!this.attributes.showHandle)
          return;
        this.startHandle && transition(this.startHandle, this.getHandleStyle("start"), animation);
        this.endHandle && transition(this.endHandle, this.getHandleStyle("end"), animation);
      };
      Slider3.prototype.innerSetValues = function(values, trigger) {
        if (values === void 0) {
          values = [0, 0];
        }
        if (trigger === void 0) {
          trigger = false;
        }
        var oldValues = this.values;
        var newValues = this.clampValues(values);
        this.attributes.values = newValues;
        this.setValues(newValues);
        if (trigger) {
          this.onValueChange(oldValues);
        }
      };
      Slider3.prototype.renderTrack = function(container) {
        var _a = this.attributes, x3 = _a.x, y3 = _a.y;
        var style = subStyleProps(this.attributes, "track");
        this.trackShape = select2(container).maybeAppendByClassName(CLASS_NAMES.track, "rect").styles(__assign(__assign({ x: x3, y: y3 }, this.shape), style));
      };
      Slider3.prototype.renderBrushArea = function(container) {
        var _a = this.attributes, x3 = _a.x, y3 = _a.y, brushable = _a.brushable;
        this.brushArea = select2(container).maybeAppendByClassName(CLASS_NAMES.brushArea, "rect").styles(__assign({ x: x3, y: y3, fill: "transparent", cursor: brushable ? "crosshair" : "default" }, this.shape));
      };
      Slider3.prototype.renderSparkline = function(container) {
        var _this = this;
        var _a = this.attributes, x3 = _a.x, y3 = _a.y, orientation = _a.orientation;
        var sparklineGroup = select2(container).maybeAppendByClassName(CLASS_NAMES.sparklineGroup, "g");
        ifShow(orientation === "horizontal", sparklineGroup, function(group3) {
          var style = __assign(__assign({}, _this.sparklineStyle), { x: x3, y: y3 });
          group3.maybeAppendByClassName(CLASS_NAMES.sparkline, function() {
            return new Sparkline({ style });
          }).update(style);
        });
      };
      Slider3.prototype.renderHandles = function() {
        var _this = this;
        var _a;
        var _b = this.attributes, showHandle = _b.showHandle, type = _b.type;
        var availableHandle = type === "range" ? ["start", "end"] : ["end"];
        var data2 = showHandle ? availableHandle : [];
        var that = this;
        (_a = this.foregroundGroup) === null || _a === void 0 ? void 0 : _a.selectAll(CLASS_NAMES.handle.class).data(data2.map(function(type2) {
          return { type: type2 };
        }), function(d3) {
          return d3.type;
        }).join(function(enter) {
          return enter.append(function(_a2) {
            var type2 = _a2.type;
            return new Handle({ style: _this.getHandleStyle(type2) });
          }).each(function(_a2) {
            var type2 = _a2.type;
            this.attr("class", "".concat(CLASS_NAMES.handle.name, " ").concat(type2, "-handle"));
            var name2 = "".concat(type2, "Handle");
            that[name2] = this;
            this.addEventListener("pointerdown", that.onDragStart(type2));
          });
        }, function(update) {
          return update.each(function(_a2) {
            var type2 = _a2.type;
            this.update(that.getHandleStyle(type2));
          });
        }, function(exit) {
          return exit.each(function(_a2) {
            var type2 = _a2.type;
            var name2 = "".concat(type2, "Handle");
            that[name2] = void 0;
          }).remove();
        });
      };
      Slider3.prototype.renderSelection = function(container) {
        var _a = this.attributes, x3 = _a.x, y3 = _a.y, type = _a.type, selectionType = _a.selectionType;
        this.foregroundGroup = select2(container).maybeAppendByClassName(CLASS_NAMES.foreground, "g");
        var selectionStyle = subStyleProps(this.attributes, "selection");
        var applyStyle4 = function(selection) {
          return selection.style("visibility", function(d3) {
            return d3.show ? "visible" : "hidden";
          }).style("cursor", function(d3) {
            if (selectionType === "select")
              return "grab";
            if (selectionType === "invert")
              return "crosshair";
            return "default";
          }).styles(__assign(__assign({}, selectionStyle), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }));
        };
        var that = this;
        this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).data(type === "value" ? [] : this.calcSelectionArea().map(function(area2, index4) {
          return {
            style: __assign({}, area2),
            index: index4,
            // 是否可见
            show: selectionType === "select" ? index4 === 1 : index4 !== 1
          };
        }), function(d3) {
          return d3.index;
        }).join(function(enter) {
          return enter.append("rect").attr("className", CLASS_NAMES.selection.name).call(applyStyle4).each(function(datum, index4) {
            var _this = this;
            if (index4 === 1) {
              that.selectionShape = select2(this);
              this.on("pointerdown", function(e3) {
                _this.attr("cursor", "grabbing");
                that.onDragStart("selection")(e3);
              });
              that.dispatchCustomEvent(this, "pointerenter", "selectionMouseenter");
              that.dispatchCustomEvent(this, "pointerleave", "selectionMouseleave");
              that.dispatchCustomEvent(this, "click", "selectionClick");
              this.addEventListener("pointerdown", function() {
                _this.attr("cursor", "grabbing");
              });
              this.addEventListener("pointerup", function() {
                _this.attr("cursor", "pointer");
              });
              this.addEventListener("pointerover", function() {
                _this.attr("cursor", "pointer");
              });
            } else {
              this.on("pointerdown", that.onDragStart("track"));
            }
          });
        }, function(update) {
          return update.call(applyStyle4);
        }, function(exit) {
          return exit.remove();
        });
        this.updateSelectionArea(false);
        this.renderHandles();
      };
      Slider3.prototype.render = function(attributes, container) {
        this.renderTrack(container);
        this.renderSparkline(container);
        this.renderBrushArea(container);
        this.renderSelection(container);
      };
      Slider3.prototype.clampValues = function(values, precision) {
        var _a;
        if (precision === void 0) {
          precision = 4;
        }
        var _b = __read(this.range, 2), min10 = _b[0], max11 = _b[1];
        var _c = __read(this.getValues().map(function(num) {
          return toPrecision(num, precision);
        }), 2), prevStart = _c[0], prevEnd = _c[1];
        var internalValues = Array.isArray(values) ? values : [prevStart, values !== null && values !== void 0 ? values : prevEnd];
        var _d = __read((internalValues || [prevStart, prevEnd]).map(function(num) {
          return toPrecision(num, precision);
        }), 2), startVal = _d[0], endVal = _d[1];
        if (this.attributes.type === "value")
          return [0, clamp_default(endVal, min10, max11)];
        if (startVal > endVal) {
          _a = __read([endVal, startVal], 2), startVal = _a[0], endVal = _a[1];
        }
        var range3 = endVal - startVal;
        if (range3 > max11 - min10)
          return [min10, max11];
        if (startVal < min10) {
          if (prevStart === min10 && prevEnd === endVal)
            return [min10, endVal];
          return [min10, range3 + min10];
        }
        if (endVal > max11) {
          if (prevEnd === max11 && prevStart === startVal)
            return [startVal, max11];
          return [max11 - range3, max11];
        }
        return [startVal, endVal];
      };
      Slider3.prototype.calcSelectionArea = function(values) {
        var _a = __read(this.clampValues(values), 2), start2 = _a[0], end = _a[1];
        var _b = this.availableSpace, x3 = _b.x, y3 = _b.y, width = _b.width, height = _b.height;
        return this.getOrientVal([
          [
            { y: y3, height, x: x3, width: start2 * width },
            { y: y3, height, x: start2 * width + x3, width: (end - start2) * width },
            { y: y3, height, x: end * width, width: (1 - end) * width }
          ],
          [
            { x: x3, width, y: y3, height: start2 * height },
            { x: x3, width, y: start2 * height + y3, height: (end - start2) * height },
            { x: x3, width, y: end * height, height: (1 - end) * height }
          ]
        ]);
      };
      Slider3.prototype.calcHandlePosition = function(handleType) {
        var handleIconOffset = this.attributes.handleIconOffset;
        var _a = this.availableSpace, x3 = _a.x, y3 = _a.y, width = _a.width, height = _a.height;
        var _b = __read(this.clampValues(), 2), stVal = _b[0], endVal = _b[1];
        var offset3 = handleType === "start" ? -handleIconOffset : handleIconOffset;
        var L = (handleType === "start" ? stVal : endVal) * this.getOrientVal([width, height]) + offset3;
        return {
          x: x3 + this.getOrientVal([L, width / 2]),
          y: y3 + this.getOrientVal([height / 2, L])
        };
      };
      Slider3.prototype.inferTextStyle = function(handleType) {
        var orientation = this.attributes.orientation;
        if (orientation === "horizontal")
          return {};
        if (handleType === "start")
          return { transformOrigin: "left center", transform: "rotate(90)", textAlign: "start" };
        if (handleType === "end")
          return { transformOrigin: "right center", transform: "rotate(90)", textAlign: "end" };
        return {};
      };
      Slider3.prototype.calcHandleText = function(handleType) {
        var _a;
        var _b = this.attributes, type = _b.type, orientation = _b.orientation, formatter2 = _b.formatter, autoFitLabel = _b.autoFitLabel;
        var handleStyle = subStyleProps(this.attributes, "handle");
        var labelStyle = subStyleProps(handleStyle, "label");
        var spacing = handleStyle.spacing;
        var size2 = this.getHandleSize();
        var values = this.clampValues();
        var value2 = handleType === "start" ? values[0] : values[1];
        var text = formatter2(value2);
        var temp = new Text2({
          style: __assign(__assign(__assign({}, labelStyle), this.inferTextStyle(handleType)), { text })
        });
        var _c = temp.getBBox(), textWidth = _c.width, textHeight = _c.height;
        temp.destroy();
        if (!autoFitLabel) {
          if (type === "value")
            return { text, x: 0, y: -textHeight - spacing };
          var finaleWidth = spacing + size2 + (orientation === "horizontal" ? textWidth / 2 : 0);
          return _a = { text }, _a[orientation === "horizontal" ? "x" : "y"] = handleType === "start" ? -finaleWidth : finaleWidth, _a;
        }
        var x3 = 0;
        var y3 = 0;
        var _d = this.availableSpace, iW = _d.width, iH = _d.height;
        var _e = this.calcSelectionArea()[1], fX = _e.x, fY = _e.y, fW = _e.width, fH = _e.height;
        var totalSpacing = spacing + size2;
        if (orientation === "horizontal") {
          var finalWidth = totalSpacing + textWidth / 2;
          if (handleType === "start") {
            var left2 = fX - totalSpacing - textWidth;
            x3 = left2 > 0 ? -finalWidth : finalWidth;
          } else {
            var sign3 = iW - fX - fW - totalSpacing > textWidth;
            x3 = sign3 ? finalWidth : -finalWidth;
          }
        } else {
          var positiveSize = totalSpacing;
          var negativeSize = textHeight + totalSpacing;
          if (handleType === "start") {
            y3 = fY - size2 > textHeight ? -negativeSize : positiveSize;
          } else {
            y3 = iH - (fY + fH) - size2 > textHeight ? negativeSize : -positiveSize;
          }
        }
        return { x: x3, y: y3, text };
      };
      Slider3.prototype.getHandleLabelStyle = function(handleType) {
        var style = subStyleProps(this.attributes, "handleLabel");
        return __assign(__assign(__assign({}, style), this.calcHandleText(handleType)), this.inferTextStyle(handleType));
      };
      Slider3.prototype.getHandleIconStyle = function() {
        var shape23 = this.attributes.handleIconShape;
        var style = subStyleProps(this.attributes, "handleIcon");
        var cursor = this.getOrientVal(["ew-resize", "ns-resize"]);
        var size2 = this.getHandleSize();
        return __assign({ cursor, shape: shape23, size: size2 }, style);
      };
      Slider3.prototype.getHandleStyle = function(handleType) {
        var _a = this.attributes, ox = _a.x, oy = _a.y, showLabel = _a.showLabel, showLabelOnInteraction = _a.showLabelOnInteraction, orientation = _a.orientation;
        var _b = this.calcHandlePosition(handleType), x3 = _b.x, y3 = _b.y;
        var textStyle = this.calcHandleText(handleType);
        var internalShowLabel = showLabel;
        if (!showLabel && showLabelOnInteraction) {
          if (this.target)
            internalShowLabel = true;
          else
            internalShowLabel = false;
        }
        return __assign(__assign(__assign({}, superStyleProps(this.getHandleIconStyle(), "icon")), superStyleProps(__assign(__assign({}, this.getHandleLabelStyle(handleType)), textStyle), "label")), { transform: "translate(".concat(x3 + ox, ", ").concat(y3 + oy, ")"), orientation, showLabel: internalShowLabel, type: handleType, zIndex: 3 });
      };
      Slider3.prototype.getHandleSize = function() {
        var _a = this.attributes, size2 = _a.handleIconSize, width = _a.width, height = _a.height;
        if (size2)
          return size2;
        return Math.floor((this.getOrientVal([+height, +width]) + 4) / 2.4);
      };
      Slider3.prototype.getOrientVal = function(_a) {
        var _b = __read(_a, 2), x3 = _b[0], y3 = _b[1];
        var orientation = this.attributes.orientation;
        return orientation === "horizontal" ? x3 : y3;
      };
      Slider3.prototype.setValuesOffset = function(stOffset, endOffset, animate2) {
        if (endOffset === void 0) {
          endOffset = 0;
        }
        if (animate2 === void 0) {
          animate2 = false;
        }
        var type = this.attributes.type;
        var _a = __read(this.getValues(), 2), oldStartVal = _a[0], oldEndVal = _a[1];
        var internalStartOffset = type === "range" ? stOffset : 0;
        var values = [oldStartVal + internalStartOffset, oldEndVal + endOffset].sort();
        if (animate2)
          this.setValues(values);
        else
          this.innerSetValues(values, true);
      };
      Slider3.prototype.getRatio = function(val) {
        var _a = this.availableSpace, width = _a.width, height = _a.height;
        return val / this.getOrientVal([width, height]);
      };
      Slider3.prototype.dispatchCustomEvent = function(target, event, name2) {
        var _this = this;
        target.on(event, function(e3) {
          e3.stopPropagation();
          _this.dispatchEvent(new CustomEvent2(name2, { detail: e3 }));
        });
      };
      Slider3.prototype.bindEvents = function() {
        this.addEventListener("wheel", this.onScroll);
        var brushArea = this.brushArea;
        this.dispatchCustomEvent(brushArea, "click", "trackClick");
        this.dispatchCustomEvent(brushArea, "pointerenter", "trackMouseenter");
        this.dispatchCustomEvent(brushArea, "pointerleave", "trackMouseleave");
        brushArea.on("pointerdown", this.onDragStart("track"));
      };
      Slider3.prototype.onScroll = function(event) {
        var scrollable = this.attributes.scrollable;
        if (scrollable) {
          var deltaX = event.deltaX, deltaY = event.deltaY;
          var offset3 = deltaY || deltaX;
          var deltaVal = this.getRatio(offset3);
          this.setValuesOffset(deltaVal, deltaVal, true);
        }
      };
      Slider3.tag = "slider";
      return Slider3;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/scrollbar/index.js
  var Scrollbar = (
    /** @class */
    function(_super) {
      __extends(Scrollbar3, _super);
      function Scrollbar3(options) {
        var _this = _super.call(this, options, {
          x: 0,
          y: 0,
          isRound: true,
          orientation: "vertical",
          padding: [2, 2, 2, 2],
          scrollable: true,
          slidable: true,
          thumbCursor: "default",
          trackSize: 10,
          value: 0
        }) || this;
        _this.range = [0, 1];
        _this.onValueChange = function(oldValue) {
          var newValue = _this.attributes.value;
          if (oldValue === newValue)
            return;
          var evtVal = {
            detail: {
              oldValue,
              value: newValue
            }
          };
          _this.dispatchEvent(new CustomEvent2("scroll", evtVal));
          _this.dispatchEvent(new CustomEvent2("valuechange", evtVal));
        };
        _this.onTrackClick = function(e3) {
          var slidable = _this.attributes.slidable;
          if (!slidable)
            return;
          var _a = __read(_this.getLocalPosition(), 2), x3 = _a[0], y3 = _a[1];
          var _b = __read(_this.padding, 4), top = _b[0], left2 = _b[3];
          var basePos = _this.getOrientVal([x3 + left2, y3 + top]);
          var clickPos = _this.getOrientVal(getEventPos(e3));
          var value2 = (clickPos - basePos) / _this.trackLength;
          _this.setValue(value2, true);
        };
        _this.onThumbMouseenter = function(e3) {
          _this.dispatchEvent(new CustomEvent2("thumbMouseenter", { detail: e3.detail }));
        };
        _this.onTrackMouseenter = function(e3) {
          _this.dispatchEvent(new CustomEvent2("trackMouseenter", { detail: e3.detail }));
        };
        _this.onThumbMouseleave = function(e3) {
          _this.dispatchEvent(new CustomEvent2("thumbMouseleave", { detail: e3.detail }));
        };
        _this.onTrackMouseleave = function(e3) {
          _this.dispatchEvent(new CustomEvent2("trackMouseleave", { detail: e3.detail }));
        };
        return _this;
      }
      Object.defineProperty(Scrollbar3.prototype, "padding", {
        get: function() {
          var padding = this.attributes.padding;
          return parseSeriesAttr(padding);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scrollbar3.prototype, "value", {
        get: function() {
          var value2 = this.attributes.value;
          var _a = __read(this.range, 2), min10 = _a[0], max11 = _a[1];
          return clamp_default(value2, min10, max11);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scrollbar3.prototype, "trackLength", {
        get: function() {
          var _a = this.attributes, viewportLength = _a.viewportLength, _b = _a.trackLength, trackLength = _b === void 0 ? viewportLength : _b;
          return trackLength;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scrollbar3.prototype, "availableSpace", {
        get: function() {
          var trackSize = this.attributes.trackSize;
          var trackLength = this.trackLength;
          var _a = __read(this.padding, 4), top = _a[0], right2 = _a[1], bottom = _a[2], left2 = _a[3];
          var _b = __read(this.getOrientVal([
            [trackLength, trackSize],
            [trackSize, trackLength]
          ]), 2), width = _b[0], height = _b[1];
          return {
            x: left2,
            y: top,
            width: +width - (left2 + right2),
            height: +height - (top + bottom)
          };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scrollbar3.prototype, "trackRadius", {
        get: function() {
          var _a = this.attributes, isRound = _a.isRound, trackSize = _a.trackSize;
          if (!isRound)
            return 0;
          return trackSize / 2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scrollbar3.prototype, "thumbRadius", {
        get: function() {
          var _a = this.attributes, isRound = _a.isRound, thumbRadius = _a.thumbRadius;
          if (!isRound)
            return 0;
          var _b = this.availableSpace, width = _b.width, height = _b.height;
          return thumbRadius || this.getOrientVal([height, width]) / 2;
        },
        enumerable: false,
        configurable: true
      });
      Scrollbar3.prototype.getValues = function(value2) {
        if (value2 === void 0) {
          value2 = this.value;
        }
        var _a = this.attributes, viewportLength = _a.viewportLength, contentLength = _a.contentLength;
        var unit = viewportLength / contentLength;
        var _b = __read(this.range, 2), min10 = _b[0], max11 = _b[1];
        var start2 = value2 * (max11 - min10 - unit);
        return [start2, start2 + unit];
      };
      Scrollbar3.prototype.getValue = function() {
        return this.value;
      };
      Scrollbar3.prototype.renderSlider = function(container) {
        var _a = this.attributes, x3 = _a.x, y3 = _a.y, orientation = _a.orientation, trackSize = _a.trackSize, padding = _a.padding, slidable = _a.slidable;
        var trackStyle = subStyleProps(this.attributes, "track");
        var selectionStyle = subStyleProps(this.attributes, "thumb");
        var style = __assign(__assign({ x: x3, y: y3, brushable: false, orientation, padding, selectionRadius: this.thumbRadius, showHandle: false, slidable, trackLength: this.trackLength, trackRadius: this.trackRadius, trackSize, values: this.getValues() }, superStyleProps(trackStyle, "track")), superStyleProps(selectionStyle, "selection"));
        this.slider = select2(container).maybeAppendByClassName("scrollbar", function() {
          return new Slider({ style });
        }).update(style).node();
      };
      Scrollbar3.prototype.render = function(attributes, container) {
        this.renderSlider(container);
      };
      Scrollbar3.prototype.setValue = function(value2, animate2) {
        if (animate2 === void 0) {
          animate2 = false;
        }
        var oldValue = this.attributes.value;
        var _a = __read(this.range, 2), min10 = _a[0], max11 = _a[1];
        this.slider.setValues(this.getValues(clamp_default(value2, min10, max11)), animate2);
        this.onValueChange(oldValue);
      };
      Scrollbar3.prototype.bindEvents = function() {
        var _this = this;
        this.slider.addEventListener("trackClick", function(e3) {
          e3.stopPropagation();
          _this.onTrackClick(e3.detail);
        });
        this.onHover();
      };
      Scrollbar3.prototype.getOrientVal = function(values) {
        var orientation = this.attributes.orientation;
        return orientation === "horizontal" ? values[0] : values[1];
      };
      Scrollbar3.prototype.onHover = function() {
        this.slider.addEventListener("selectionMouseenter", this.onThumbMouseenter);
        this.slider.addEventListener("trackMouseenter", this.onTrackMouseenter);
        this.slider.addEventListener("selectionMouseleave", this.onThumbMouseleave);
        this.slider.addEventListener("trackMouseleave", this.onTrackMouseleave);
      };
      Scrollbar3.tag = "scrollbar";
      return Scrollbar3;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/axis/constant.js
  var AXIS_BASE_DEFAULT_ATTR = {
    data: [],
    animate: {
      enter: false,
      update: {
        duration: 100,
        easing: "ease-in-out-sine",
        fill: "both"
      },
      exit: {
        duration: 100,
        fill: "both"
      }
    },
    showArrow: true,
    showGrid: true,
    showLabel: true,
    showLine: true,
    showTick: true,
    showTitle: true,
    showTrunc: false,
    dataThreshold: 100,
    lineLineWidth: 1,
    lineStroke: "black",
    crossPadding: 10,
    titleFill: "black",
    titleFontSize: 12,
    titlePosition: "lb",
    titleSpacing: 0,
    titleTextAlign: "center",
    titleTextBaseline: "middle",
    lineArrow: function() {
      return new Path2({
        style: {
          d: [["M", 10, 10], ["L", -10, 0], ["L", 10, -10], ["L", 0, 0], ["L", 10, 10], ["Z"]],
          fill: "black",
          transformOrigin: "center"
        }
      });
    },
    labelAlign: "parallel",
    labelDirection: "positive",
    labelFontSize: 12,
    labelSpacing: 0,
    gridConnect: "line",
    gridControlAngles: [],
    gridDirection: "positive",
    gridLength: 0,
    gridType: "segment",
    lineArrowOffset: 15,
    lineArrowSize: 10,
    tickDirection: "positive",
    tickLength: 5,
    tickLineWidth: 1,
    tickStroke: "black",
    labelOverlap: [
      // { type: 'rotate', optionalAngles: [0, 45, 90] },
      // { type: 'ellipsis', suffix: '...', minLength: 14, maxLength: 160 },
      // { type: 'hide' },
    ]
  };
  var ARC_DEFAULT_OPTIONS = deep_mix_default({}, AXIS_BASE_DEFAULT_ATTR, {
    style: {
      type: "arc"
    }
  });
  var HELIX_DEFAULT_OPTIONS = deep_mix_default({}, AXIS_BASE_DEFAULT_ATTR, {
    style: {}
  });
  var CLASS_NAMES3 = classNames({
    mainGroup: "main-group",
    gridGroup: "grid-group",
    grid: "grid",
    lineGroup: "line-group",
    line: "line",
    tickGroup: "tick-group",
    tick: "tick",
    tickItem: "tick-item",
    labelGroup: "label-group",
    label: "label",
    labelItem: "label-item",
    titleGroup: "title-group",
    title: "title",
    lineFirst: "line-first",
    lineSecond: "line-second"
  }, "axis");

  // node_modules/@antv/component/esm/ui/grid/index.js
  var CLASS_NAMES4 = classNames({
    lineGroup: "line-group",
    line: "line",
    regionGroup: "region-group",
    region: "region"
  }, "grid");
  function getStraightPath(points) {
    return points.reduce(function(acc, curr, idx) {
      acc.push(__spreadArray([idx === 0 ? "M" : "L"], __read(curr), false));
      return acc;
    }, []);
  }
  function getSurroundPath(points, attr2, reversed) {
    var _a = attr2.connect, connect = _a === void 0 ? "line" : _a, center2 = attr2.center;
    if (connect === "line")
      return getStraightPath(points);
    if (!center2)
      return [];
    var radius = distance5(points[0], center2);
    var sweepFlag = reversed ? 0 : 1;
    return points.reduce(function(r, p2, idx) {
      if (idx === 0)
        r.push(__spreadArray(["M"], __read(p2), false));
      else
        r.push(__spreadArray(["A", radius, radius, 0, 0, sweepFlag], __read(p2), false));
      return r;
    }, []);
  }
  function getLinePath(points, cfg, reversed) {
    if (cfg.type === "surround")
      return getSurroundPath(points, cfg, reversed);
    return getStraightPath(points);
  }
  function connectPaths(from, to, cfg) {
    var type = cfg.type, connect = cfg.connect, center2 = cfg.center, closed = cfg.closed;
    var closeFlag = closed ? [["Z"]] : [];
    var _a = __read([getLinePath(from, cfg), getLinePath(to.slice().reverse(), cfg, true)], 2), path1 = _a[0], path2 = _a[1];
    var _b = __read([from[0], to.slice(-1)[0]], 2), startOfFrom = _b[0], endOfTo = _b[1];
    var createPath = function(insertA, insertB) {
      return [path1, insertA, path2, insertB, closeFlag].flat();
    };
    if (connect === "line" || type === "surround") {
      return createPath([__spreadArray(["L"], __read(endOfTo), false)], [__spreadArray(["L"], __read(startOfFrom), false)]);
    }
    if (!center2)
      throw new Error("Arc grid need to specified center");
    var _c = __read([distance5(endOfTo, center2), distance5(startOfFrom, center2)], 2), raduis1 = _c[0], radius2 = _c[1];
    return createPath([
      __spreadArray(["A", raduis1, raduis1, 0, 0, 1], __read(endOfTo), false),
      __spreadArray(["L"], __read(endOfTo), false)
    ], [
      __spreadArray(["A", radius2, radius2, 0, 0, 0], __read(startOfFrom), false),
      __spreadArray(["L"], __read(startOfFrom), false)
    ]);
  }
  function renderGridLine(container, data2, attr2, style) {
    var animate2 = attr2.animate, isBillboard = attr2.isBillboard;
    var lines = data2.map(function(item, idx) {
      return {
        id: item.id || "grid-line-".concat(idx),
        d: getLinePath(item.points, attr2)
      };
    });
    return container.selectAll(CLASS_NAMES4.line.class).data(lines, function(d3) {
      return d3.id;
    }).join(function(enter) {
      return enter.append("path").each(function(datum, index4) {
        var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index4, lines]);
        this.attr(__assign({ class: CLASS_NAMES4.line.name, stroke: "#D9D9D9", lineWidth: 1, lineDash: [4, 4], isBillboard }, lineStyle));
      });
    }, function(update) {
      return update.transition(function(datum, index4) {
        var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index4, lines]);
        return transition(this, lineStyle, animate2.update);
      });
    }, function(exit) {
      return exit.transition(function() {
        var _this = this;
        var animation = fadeOut_default(this, animate2.exit);
        onAnimateFinished(animation, function() {
          return _this.remove();
        });
        return animation;
      });
    }).transitions();
  }
  function renderAlternateRegion(container, data2, style) {
    var animate2 = style.animate, connect = style.connect, areaFill = style.areaFill;
    if (data2.length < 2 || !areaFill || !connect)
      return [];
    var colors = Array.isArray(areaFill) ? areaFill : [areaFill, "transparent"];
    var getColor3 = function(idx2) {
      return colors[idx2 % colors.length];
    };
    var regions = [];
    for (var idx = 0; idx < data2.length - 1; idx++) {
      var _a = __read([data2[idx].points, data2[idx + 1].points], 2), prev = _a[0], curr = _a[1];
      var path2 = connectPaths(prev, curr, style);
      regions.push({ d: path2, fill: getColor3(idx) });
    }
    return container.selectAll(CLASS_NAMES4.region.class).data(regions, function(_2, i) {
      return i;
    }).join(function(enter) {
      return enter.append("path").each(function(datum, index4) {
        var regionStyle = getCallbackValue(datum, [datum, index4, regions]);
        this.attr(regionStyle);
      }).attr("className", CLASS_NAMES4.region.name);
    }, function(update) {
      return update.transition(function(datum, index4) {
        var regionStyle = getCallbackValue(datum, [datum, index4, regions]);
        return transition(this, regionStyle, animate2.update);
      });
    }, function(exit) {
      return exit.transition(function() {
        var _this = this;
        var animation = fadeOut_default(this, animate2.exit);
        onAnimateFinished(animation, function() {
          return _this.remove();
        });
        return animation;
      });
    }).transitions();
  }
  function getData(attr2) {
    var _a = attr2.data, data2 = _a === void 0 ? [] : _a, closed = attr2.closed;
    if (!closed)
      return data2;
    return data2.map(function(datum) {
      var points = datum.points;
      var _a2 = __read(points, 1), start2 = _a2[0];
      return __assign(__assign({}, datum), { points: __spreadArray(__spreadArray([], __read(points), false), [start2], false) });
    });
  }
  var Grid = (
    /** @class */
    function(_super) {
      __extends(Grid2, _super);
      function Grid2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Grid2.prototype.render = function(attributes, container) {
        var type = attributes.type, center2 = attributes.center, areaFill = attributes.areaFill, closed = attributes.closed, style = __rest(attributes, ["type", "center", "areaFill", "closed"]);
        var data2 = getData(attributes);
        var lineGroup = select2(container).maybeAppendByClassName(CLASS_NAMES4.lineGroup, "g");
        var regionGroup = select2(container).maybeAppendByClassName(CLASS_NAMES4.regionGroup, "g");
        var lineTransitions = renderGridLine(lineGroup, data2, attributes, style);
        var reigionTransitions = renderAlternateRegion(regionGroup, data2, attributes);
        return __spreadArray(__spreadArray([], __read(lineTransitions), false), __read(reigionTransitions), false);
      };
      return Grid2;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/axis/guides/utils.js
  function getCallbackStyle(style, params) {
    return Object.fromEntries(Object.entries(style).map(function(_a) {
      var _b = __read(_a, 2), key = _b[0], val = _b[1];
      return [key, getCallbackValue(val, params)];
    }));
  }
  function filterExec(data2, filter2) {
    return !!filter2 && isFunction(filter2) ? data2.filter(filter2) : data2;
  }
  function getLineAngle(value2, attr2) {
    var startAngle = attr2.startAngle, endAngle = attr2.endAngle;
    return (endAngle - startAngle) * value2 + startAngle;
  }
  function getLineTangentVector(value2, attr2) {
    if (attr2.type === "linear") {
      var _a = __read(attr2.startPos, 2), startX = _a[0], startY = _a[1], _b = __read(attr2.endPos, 2), endX = _b[0], endY = _b[1];
      var _c = __read([endX - startX, endY - startY], 2), dx = _c[0], dy = _c[1];
      return normalize7([dx, dy]);
    }
    var angle4 = degToRad(getLineAngle(value2, attr2));
    return [-Math.sin(angle4), Math.cos(angle4)];
  }
  function getDirectionVector(value2, direction2, attr2) {
    var tangentVector = getLineTangentVector(value2, attr2);
    return vertical(tangentVector, direction2 !== "positive");
  }
  function getLabelVector(value2, attr2) {
    return getDirectionVector(value2, attr2.labelDirection, attr2);
  }

  // node_modules/@antv/component/esm/ui/axis/guides/line.js
  function getLinearValuePos(value2, attr2) {
    var _a = __read(attr2.startPos, 2), sx = _a[0], sy = _a[1], _b = __read(attr2.endPos, 2), ex = _b[0], ey = _b[1];
    var _c = __read([ex - sx, ey - sy], 2), dx = _c[0], dy = _c[1];
    return [sx + dx * value2, sy + dy * value2];
  }
  function getArcValuePos(value2, attr2) {
    var radius = attr2.radius, _a = __read(attr2.center, 2), cx = _a[0], cy = _a[1];
    var angle4 = degToRad(getLineAngle(value2, attr2));
    return [cx + radius * Math.cos(angle4), cy + radius * Math.sin(angle4)];
  }
  function getValuePos(value2, attr2) {
    if (attr2.type === "linear")
      return getLinearValuePos(value2, attr2);
    return getArcValuePos(value2, attr2);
  }
  function isAxisHorizontal(attr2) {
    return getLineTangentVector(0, attr2)[1] === 0;
  }
  function isAxisVertical(attr2) {
    return getLineTangentVector(0, attr2)[0] === 0;
  }
  function isCircle(startAngle, endAngle) {
    return endAngle - startAngle === 360;
  }
  function getArcPath(startAngle, endAngle, cx, cy, radius) {
    var diffAngle = endAngle - startAngle;
    var _a = __read([radius, radius], 2), rx = _a[0], ry = _a[1];
    var _b = __read([degToRad(startAngle), degToRad(endAngle)], 2), startAngleRadians = _b[0], endAngleRadians = _b[1];
    var getPosByAngle = function(angle4) {
      return [cx + radius * Math.cos(angle4), cy + radius * Math.sin(angle4)];
    };
    var _c = __read(getPosByAngle(startAngleRadians), 2), x12 = _c[0], y12 = _c[1];
    var _d = __read(getPosByAngle(endAngleRadians), 2), x22 = _d[0], y22 = _d[1];
    if (isCircle(startAngle, endAngle)) {
      var middleAngleRadians = (endAngleRadians + startAngleRadians) / 2;
      var _e = __read(getPosByAngle(middleAngleRadians), 2), xm = _e[0], ym = _e[1];
      return [
        ["M", x12, y12],
        ["A", rx, ry, 0, 1, 0, xm, ym],
        ["A", rx, ry, 0, 1, 0, x22, y22]
      ];
    }
    var large = diffAngle > 180 ? 1 : 0;
    var sweep = startAngle > endAngle ? 0 : 1;
    var isClosePath = false;
    return isClosePath ? "M".concat(cx, ",").concat(cy, ",L").concat(x12, ",").concat(y12, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x22, ",").concat(y22, ",L").concat(cx, ",").concat(cy) : "M".concat(x12, ",").concat(y12, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x22, ",").concat(y22);
  }
  function getArcAttr(arc) {
    var _a = arc.attributes, startAngle = _a.startAngle, endAngle = _a.endAngle, center2 = _a.center, radius = _a.radius;
    return __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false);
  }
  function renderArc(container, attr2, style, animate2) {
    var startAngle = attr2.startAngle, endAngle = attr2.endAngle, center2 = attr2.center, radius = attr2.radius;
    return container.selectAll(CLASS_NAMES3.line.class).data([{ d: getArcPath.apply(void 0, __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false)) }], function(d3, i) {
      return i;
    }).join(function(enter) {
      return enter.append("path").attr("className", CLASS_NAMES3.line.name).styles(attr2).styles({ d: function(d3) {
        return d3.d;
      } });
    }, function(update) {
      return update.transition(function() {
        var _this = this;
        var animation = keyframeInterpolate(this, getArcAttr(this), __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false), animate2.update);
        if (animation) {
          var layout = function() {
            var data2 = get_default(_this.attributes, "__keyframe_data__");
            _this.style.d = getArcPath.apply(void 0, __spreadArray([], __read(data2), false));
          };
          animation.onframe = layout;
          animation.onfinish = layout;
        }
        return animation;
      }).styles(attr2);
    }, function(exit) {
      return exit.remove();
    }).styles(style).transitions();
  }
  function renderTruncation(container, _a) {
    var truncRange = _a.truncRange, truncShape = _a.truncShape, lineExtension = _a.lineExtension;
  }
  function extendLine(startPos, endPos, range3) {
    if (range3 === void 0) {
      range3 = [0, 0];
    }
    var _a = __read([startPos, endPos, range3], 3), _b = __read(_a[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a[1], 2), x22 = _c[0], y22 = _c[1], _d = __read(_a[2], 2), l1 = _d[0], l2 = _d[1];
    var _e = __read([x22 - x12, y22 - y12], 2), x3 = _e[0], y3 = _e[1];
    var L = Math.sqrt(Math.pow(x3, 2) + Math.pow(y3, 2));
    var _f = __read([-l1 / L, l2 / L], 2), s1 = _f[0], s22 = _f[1];
    return [s1 * x3, s1 * y3, s22 * x3, s22 * y3];
  }
  function getLinePath2(points) {
    var _a = __read(points, 2), _b = __read(_a[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a[1], 2), x22 = _c[0], y22 = _c[1];
    return { x1: x12, y1: y12, x2: x22, y2: y22 };
  }
  function renderLinear(container, attr2, style, animate2) {
    var showTrunc = attr2.showTrunc, startPos = attr2.startPos, endPos = attr2.endPos, truncRange = attr2.truncRange, lineExtension = attr2.lineExtension;
    var _a = __read([startPos, endPos], 2), _b = __read(_a[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a[1], 2), x22 = _c[0], y22 = _c[1];
    var _d = __read(lineExtension ? extendLine(startPos, endPos, lineExtension) : new Array(4).fill(0), 4), ox1 = _d[0], oy1 = _d[1], ox2 = _d[2], oy2 = _d[3];
    var renderLine = function(data2) {
      return container.selectAll(CLASS_NAMES3.line.class).data(data2, function(d3, i) {
        return i;
      }).join(function(enter) {
        return enter.append("line").attr("className", function(d3) {
          return "".concat(CLASS_NAMES3.line.name, " ").concat(d3.className);
        }).styles(style).transition(function(d3) {
          return transition(this, getLinePath2(d3.line), false);
        });
      }, function(update) {
        return update.styles(style).transition(function(_a2) {
          var line4 = _a2.line;
          return transition(this, getLinePath2(line4), animate2.update);
        });
      }, function(exit) {
        return exit.remove();
      }).transitions();
    };
    if (!showTrunc || !truncRange) {
      return renderLine([
        {
          line: [
            [x12 + ox1, y12 + oy1],
            [x22 + ox2, y22 + oy2]
          ],
          className: CLASS_NAMES3.line.name
        }
      ]);
    }
    var _e = __read(truncRange, 2), r1 = _e[0], r2 = _e[1];
    var dx = x22 - x12;
    var dy = y22 - y12;
    var _f = __read([x12 + dx * r1, y12 + dy * r1], 2), x3 = _f[0], y3 = _f[1];
    var _g = __read([x12 + dx * r2, y12 + dy * r2], 2), x4 = _g[0], y4 = _g[1];
    var animation = renderLine([
      {
        line: [
          [x12 + ox1, y12 + oy1],
          [x3, y3]
        ],
        className: CLASS_NAMES3.lineFirst.name
      },
      {
        line: [
          [x4, y4],
          [x22 + ox2, y22 + oy2]
        ],
        className: CLASS_NAMES3.lineSecond.name
      }
    ]);
    renderTruncation(container, attr2);
    return animation;
  }
  function renderAxisArrow(container, type, attr2, style) {
    var showArrow = attr2.showArrow, showTrunc = attr2.showTrunc, lineArrow = attr2.lineArrow, lineArrowOffset = attr2.lineArrowOffset, lineArrowSize = attr2.lineArrowSize;
    var shapeToAddArrow;
    if (type === "arc")
      shapeToAddArrow = container.select(CLASS_NAMES3.line.class);
    else if (showTrunc)
      shapeToAddArrow = container.select(CLASS_NAMES3.lineSecond.class);
    else
      shapeToAddArrow = container.select(CLASS_NAMES3.line.class);
    if (!showArrow || !lineArrow || attr2.type === "arc" && isCircle(attr2.startAngle, attr2.endAngle)) {
      var node = shapeToAddArrow.node();
      if (node)
        node.style.markerEnd = void 0;
      return;
    }
    var arrow = renderExtDo(lineArrow);
    arrow.attr(style);
    scaleToPixel(arrow, lineArrowSize, true);
    shapeToAddArrow.style("markerEnd", arrow).style("markerEndOffset", -lineArrowOffset);
  }
  function renderAxisLine(container, attr2, animate2) {
    var type = attr2.type;
    var animation;
    var style = subStyleProps(attr2, "line");
    if (type === "linear")
      animation = renderLinear(container, attr2, omit(style, "arrow"), animate2);
    else
      animation = renderArc(container, attr2, omit(style, "arrow"), animate2);
    renderAxisArrow(container, type, attr2, style);
    return animation;
  }

  // node_modules/@antv/component/esm/ui/axis/guides/grid.js
  function getGridVector(value2, attr2) {
    return getDirectionVector(value2, attr2.gridDirection, attr2);
  }
  function getGridCenter(attr2) {
    var type = attr2.type, gridCenter = attr2.gridCenter;
    if (type === "linear")
      return gridCenter;
    return gridCenter || attr2.center;
  }
  function renderStraight(data2, attr2) {
    var gridLength = attr2.gridLength;
    return data2.map(function(_a, index4) {
      var value2 = _a.value;
      var _b = __read(getValuePos(value2, attr2), 2), x3 = _b[0], y3 = _b[1];
      var _c = __read(scale8(getGridVector(value2, attr2), gridLength), 2), dx = _c[0], dy = _c[1];
      return {
        id: index4,
        points: [
          [x3, y3],
          [x3 + dx, y3 + dy]
        ]
      };
    });
  }
  function renderSurround(data2, attr2) {
    var controlAngles = attr2.gridControlAngles;
    var center2 = getGridCenter(attr2);
    if (!center2)
      throw new Error("grid center is not provide");
    if (data2.length < 2)
      throw new Error("Invalid grid data");
    if (!controlAngles || controlAngles.length === 0)
      throw new Error("Invalid gridControlAngles");
    var _a = __read(center2, 2), cx = _a[0], cy = _a[1];
    return data2.map(function(_a2, index4) {
      var value2 = _a2.value;
      var _b = __read(getValuePos(value2, attr2), 2), sx = _b[0], sy = _b[1];
      var _c = __read([sx - cx, sy - cy], 2), dx = _c[0], dy = _c[1];
      var points = [];
      controlAngles.forEach(function(angle4) {
        var angleInRad = degToRad(angle4);
        var _a3 = __read([Math.cos(angleInRad), Math.sin(angleInRad)], 2), cosa = _a3[0], sina = _a3[1];
        var x3 = dx * cosa - dy * sina + cx;
        var y3 = dx * sina + dy * cosa + cy;
        points.push([x3, y3]);
      });
      return { points, id: index4 };
    });
  }
  function renderGrid(container, data2, attr2, animate2) {
    var gridAttr = subStyleProps(attr2, "grid");
    var type = gridAttr.type, areaFill = gridAttr.areaFill;
    var center2 = getGridCenter(attr2);
    var finalData = filterExec(data2, attr2.gridFilter);
    var gridItems = type === "segment" ? renderStraight(finalData, attr2) : renderSurround(finalData, attr2);
    var style = __assign(__assign({}, gridAttr), { center: center2, areaFill: isFunction(areaFill) ? finalData.map(function(datum, index4) {
      return getCallbackValue(areaFill, [datum, index4, finalData]);
    }) : areaFill, animate: animate2, data: gridItems });
    return container.selectAll(CLASS_NAMES3.grid.class).data([1]).join(function(enter) {
      return enter.append(function() {
        return new Grid({ style });
      }).attr("className", CLASS_NAMES3.grid.name);
    }, function(update) {
      return update.transition(function() {
        return this.update(style);
      });
    }, function(exit) {
      return exit.remove();
    }).transitions();
  }

  // node_modules/@antv/component/esm/ui/axis/utils/bounds.js
  var Bounds = (
    /** @class */
    function() {
      function Bounds2(x12, y12, x22, y22) {
        this.set(x12, y12, x22, y22);
      }
      Object.defineProperty(Bounds2.prototype, "left", {
        get: function() {
          return this.x1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "top", {
        get: function() {
          return this.y1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "right", {
        get: function() {
          return this.x2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "bottom", {
        get: function() {
          return this.y2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "width", {
        get: function() {
          return this.defined("x2") && this.defined("x1") ? this.x2 - this.x1 : void 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "height", {
        get: function() {
          return this.defined("y2") && this.defined("y1") ? this.y2 - this.y1 : void 0;
        },
        enumerable: false,
        configurable: true
      });
      Bounds2.prototype.rotatedPoints = function(radian, x3, y3) {
        var _a = this, x12 = _a.x1, y12 = _a.y1, x22 = _a.x2, y22 = _a.y2;
        var cos3 = Math.cos(radian);
        var sin3 = Math.sin(radian);
        var cx = x3 - x3 * cos3 + y3 * sin3;
        var cy = y3 - x3 * sin3 - y3 * cos3;
        var points = [
          [cos3 * x12 - sin3 * y22 + cx, sin3 * x12 + cos3 * y22 + cy],
          [cos3 * x22 - sin3 * y22 + cx, sin3 * x22 + cos3 * y22 + cy],
          [cos3 * x12 - sin3 * y12 + cx, sin3 * x12 + cos3 * y12 + cy],
          [cos3 * x22 - sin3 * y12 + cx, sin3 * x22 + cos3 * y12 + cy]
        ];
        return points;
      };
      Bounds2.prototype.set = function(x12, y12, x22, y22) {
        if (x22 < x12) {
          this.x2 = x12;
          this.x1 = x22;
        } else {
          this.x1 = x12;
          this.x2 = x22;
        }
        if (y22 < y12) {
          this.y2 = y12;
          this.y1 = y22;
        } else {
          this.y1 = y12;
          this.y2 = y22;
        }
        return this;
      };
      Bounds2.prototype.defined = function(key) {
        return this[key] !== Number.MAX_VALUE && this[key] !== -Number.MAX_VALUE;
      };
      return Bounds2;
    }()
  );
  function getBounds(item, margin) {
    var angle4 = item.getEulerAngles() || 0;
    item.setEulerAngles(0);
    var _a = item.getBounds(), _b = __read(_a.min, 2), x3 = _b[0], y3 = _b[1], _c = __read(_a.max, 2), right2 = _c[0], bottom = _c[1];
    var _d = item.getBBox(), w = _d.width, h = _d.height;
    var height = h;
    var dx = 0;
    var dy = 0;
    var anchorX = x3;
    var anchorY = y3;
    var text = textOf(item);
    if (text) {
      height -= 1.5;
      var a3 = text.style.textAlign;
      var b_1 = text.style.textBaseline;
      if (a3 === "center") {
        anchorX = (x3 + right2) / 2;
      } else if (a3 === "right" || a3 === "end") {
        anchorX = right2;
      } else {
      }
      if (b_1 === "middle") {
        anchorY = (y3 + bottom) / 2;
      } else if (b_1 === "bottom") {
        anchorY = bottom;
      }
    }
    var _e = __read(parseSeriesAttr(margin), 4), _f = _e[0], t = _f === void 0 ? 0 : _f, _g = _e[1], r = _g === void 0 ? 0 : _g, _h = _e[2], b = _h === void 0 ? t : _h, _j = _e[3], l2 = _j === void 0 ? r : _j;
    var bounds = new Bounds((dx += x3) - l2, (dy += y3) - t, dx + w + r, dy + height + b);
    item.setEulerAngles(angle4);
    return bounds.rotatedPoints(degToRad(angle4), anchorX, anchorY);
  }

  // node_modules/@antv/component/esm/ui/axis/utils/contain.js
  function onLine(line4, point6) {
    return point6[0] <= Math.max(line4[0][0], line4[1][0]) && point6[0] <= Math.min(line4[0][0], line4[1][0]) && point6[1] <= Math.max(line4[0][1], line4[1][1]) && point6[1] <= Math.min(line4[0][1], line4[1][1]);
  }
  function direction(a3, b, c5) {
    var val = (b[1] - a3[1]) * (c5[0] - b[0]) - (b[0] - a3[0]) * (c5[1] - b[1]);
    if (val === 0)
      return 0;
    return val < 0 ? 2 : 1;
  }
  function isIntersect(line1, line22) {
    var dir1 = direction(line1[0], line1[1], line22[0]);
    var dir2 = direction(line1[0], line1[1], line22[1]);
    var dir3 = direction(line22[0], line22[1], line1[0]);
    var dir4 = direction(line22[0], line22[1], line1[1]);
    if (dir1 !== dir2 && dir3 !== dir4)
      return true;
    if (dir1 === 0 && onLine(line1, line22[0]))
      return true;
    if (dir2 === 0 && onLine(line1, line22[1]))
      return true;
    if (dir3 === 0 && onLine(line22, line1[0]))
      return true;
    if (dir4 === 0 && onLine(line22, line1[1]))
      return true;
    return false;
  }
  function isPointInsideRectangle(polygon, point6) {
    var n2 = polygon.length;
    if (n2 < 3)
      return false;
    var lineToInfinity = [point6, [9999, point6[1]]];
    var count4 = 0;
    var i = 0;
    do {
      var side = [polygon[i], polygon[(i + 1) % n2]];
      if (isIntersect(side, lineToInfinity)) {
        if (direction(side[0], point6, side[1]) === 0)
          return onLine(side, point6);
        count4++;
      }
      i = (i + 1) % n2;
    } while (i !== 0);
    return !!(count4 & 1);
  }
  function isRectangleBInsideA(rectA, rectB) {
    return rectB.every(function(point6) {
      return isPointInsideRectangle(rectA, point6);
    });
  }
  function contain(container, child, margin) {
    var x12 = container.x1, x22 = container.x2, y12 = container.y1, y22 = container.y2;
    var parent = [
      [x12, y12],
      [x22, y12],
      [x22, y22],
      [x12, y22]
    ];
    var element = getBounds(child, margin);
    return isRectangleBInsideA(parent, element);
  }

  // node_modules/@antv/component/esm/ui/axis/utils/intersect.js
  function lineToLine(line1, line22) {
    var _a = __read(line1, 4), x05 = _a[0], y05 = _a[1], x12 = _a[2], y12 = _a[3];
    var _b = __read(line22, 4), x22 = _b[0], y22 = _b[1], x3 = _b[2], y3 = _b[3];
    var s10x = x12 - x05;
    var s10y = y12 - y05;
    var s32x = x3 - x22;
    var s32y = y3 - y22;
    var denom = s10x * s32y - s32x * s10y;
    if (denom === 0)
      return false;
    var denomPositive = denom > 0;
    var s02x = x05 - x22;
    var s02y = y05 - y22;
    var sNum = s10x * s02y - s10y * s02x;
    if (sNum < 0 === denomPositive)
      return false;
    var tNum = s32x * s02y - s32y * s02x;
    if (tNum < 0 === denomPositive)
      return false;
    if (sNum > denom === denomPositive || tNum > denom === denomPositive)
      return false;
    return true;
  }
  function intersectBoxLine(box2, line4) {
    var lines = [
      [box2[0], box2[1], box2[2], box2[3]],
      [box2[2], box2[3], box2[4], box2[5]],
      [box2[4], box2[5], box2[6], box2[7]],
      [box2[6], box2[7], box2[0], box2[1]]
    ];
    return lines.some(function(boxLine) {
      return lineToLine(line4, boxLine);
    });
  }
  function intersect2(a3, b, margin) {
    var e_1, _a;
    var p2 = getBounds(a3, margin).flat(1);
    var q = getBounds(b, margin).flat(1);
    var linesP = [
      [p2[0], p2[1], p2[2], p2[3]],
      [p2[0], p2[1], p2[4], p2[5]],
      [p2[4], p2[5], p2[6], p2[7]],
      [p2[2], p2[3], p2[6], p2[7]]
    ];
    try {
      for (var linesP_1 = __values(linesP), linesP_1_1 = linesP_1.next(); !linesP_1_1.done; linesP_1_1 = linesP_1.next()) {
        var line4 = linesP_1_1.value;
        if (intersectBoxLine(q, line4))
          return true;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (linesP_1_1 && !linesP_1_1.done && (_a = linesP_1.return)) _a.call(linesP_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    return false;
  }

  // node_modules/@antv/component/esm/ui/axis/utils/test.js
  function createCrossBBox(attr2, padding) {
    var type = attr2.type, labelDirection = attr2.labelDirection, crossSize = attr2.crossSize;
    if (!crossSize)
      return false;
    if (type === "arc") {
      var center2 = attr2.center, radius = attr2.radius;
      var _a = __read(center2, 2), cx = _a[0], cy = _a[1];
      var size2 = labelDirection === "negative" ? 0 : crossSize;
      var dMin = -radius - size2;
      var dMax = radius + size2;
      var _b = __read(parseSeriesAttr(padding), 4), top_1 = _b[0], right_1 = _b[1], bottom_1 = _b[2], left_1 = _b[3];
      return new Bounds(cx + dMin - left_1, cy + dMin - top_1, cx + dMax + right_1, cy + dMax + bottom_1);
    }
    var _c = __read(attr2.startPos, 2), sx = _c[0], sy = _c[1], _d = __read(attr2.endPos, 2), ex = _d[0], ey = _d[1];
    var _e = __read(isAxisVertical(attr2) ? [-padding, 0, padding, 0] : [0, padding, 0, -padding], 4), top = _e[0], right2 = _e[1], bottom = _e[2], left2 = _e[3];
    var labelVector = getLabelVector(0, attr2);
    var diff = scale8(labelVector, crossSize);
    var bbox = new Bounds(sx, sy, ex, ey);
    bbox.x1 += left2;
    bbox.y1 += top;
    bbox.x2 += right2 + diff[0];
    bbox.y2 += bottom + diff[1];
    return bbox;
  }
  function boundTest(items, attr2, margin) {
    var e_1, _a;
    var crossPadding = attr2.crossPadding;
    var resultSet = /* @__PURE__ */ new Set();
    var prev = null;
    var crossBBox = createCrossBBox(attr2, crossPadding);
    var testContain = function(item) {
      if (crossBBox)
        return contain(crossBBox, item);
      return true;
    };
    var testIntersect = function(prevItem, currItem) {
      if (!prevItem || !prevItem.firstChild)
        return true;
      return !intersect2(prevItem.firstChild, currItem.firstChild, parseSeriesAttr(margin));
    };
    try {
      for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
        var curr = items_1_1.value;
        if (!testContain(curr)) {
          resultSet.add(curr);
        } else if (!prev || testIntersect(prev, curr)) {
          prev = curr;
        } else {
          resultSet.add(prev);
          resultSet.add(curr);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    return Array.from(resultSet);
  }

  // node_modules/@antv/component/esm/ui/axis/overlap/autoEllipsis.js
  function parseLengthString(str7, font) {
    if (font === void 0) {
      font = {};
    }
    if (isNil(str7))
      return 0;
    if (typeof str7 === "number")
      return str7;
    return Math.floor(measureTextWidth(str7, font));
  }
  function ellipseLabels(labels, overlapCfg, attr2, utils) {
    if (labels.length <= 1)
      return;
    var _a = overlapCfg.suffix, suffix = _a === void 0 ? "..." : _a, minLength = overlapCfg.minLength, _b = overlapCfg.maxLength, maxLength = _b === void 0 ? Infinity : _b, _c = overlapCfg.step, ellipsisStep = _c === void 0 ? " " : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
    var font = getFont(utils.getTextShape(labels[0]));
    var step2 = parseLengthString(ellipsisStep, font);
    var min10 = minLength ? parseLengthString(minLength, font) : step2;
    var max11 = parseLengthString(maxLength, font);
    if (isNil(max11) || max11 === Infinity) {
      max11 = Math.max.apply(null, labels.map(function(d3) {
        return d3.getBBox().width;
      }));
    }
    var source = labels.slice();
    var _e = __read(margin, 4), _f = _e[0], top = _f === void 0 ? 0 : _f, _g = _e[1], right2 = _g === void 0 ? 0 : _g, _h = _e[2], bottom = _h === void 0 ? top : _h, _j = _e[3], left2 = _j === void 0 ? right2 : _j;
    var _loop_1 = function(allowedLength2) {
      source.forEach(function(label) {
        utils.ellipsis(utils.getTextShape(label), allowedLength2, suffix);
      });
      source = boundTest(labels, attr2, margin);
      if (source.length < 1)
        return { value: void 0 };
    };
    for (var allowedLength = max11; allowedLength > min10 + step2; allowedLength -= step2) {
      var state_1 = _loop_1(allowedLength);
      if (typeof state_1 === "object")
        return state_1.value;
    }
  }

  // node_modules/@antv/component/esm/ui/axis/overlap/autoHide.js
  var methods = {
    parity: function(items, _a) {
      var _b = _a.seq, seq = _b === void 0 ? 2 : _b;
      return items.filter(function(item, i) {
        return i % seq ? (hide(item), false) : true;
      });
    }
  };
  var filterDefined = function(arr) {
    return arr.filter(defined2);
  };
  function hideLabels(labels, overlapCfg, attr2, utils) {
    var count4 = labels.length;
    var keepHeader = overlapCfg.keepHeader, keepTail = overlapCfg.keepTail;
    if (count4 <= 1 || count4 === 2 && keepHeader && keepTail)
      return;
    var parityHide = methods.parity;
    var reset = function(els) {
      return els.forEach(utils.show), els;
    };
    var seq = 2;
    var source = labels.slice();
    var target = labels.slice();
    var minLabelWidth = Math.min.apply(Math, __spreadArray([1], __read(labels.map(function(d3) {
      return d3.getBBox().width;
    })), false));
    if (attr2.type === "linear" && (isAxisHorizontal(attr2) || isAxisVertical(attr2))) {
      var minX = getLocalBBox(labels[0]).left;
      var maxX = getLocalBBox(labels[count4 - 1]).right;
      var distance7 = Math.abs(maxX - minX) || 1;
      seq = Math.max(Math.floor(count4 * minLabelWidth / distance7), seq);
    }
    var first3;
    var last4;
    if (keepHeader)
      first3 = source.splice(0, 1)[0];
    if (keepTail) {
      last4 = source.splice(-1, 1)[0];
      source.reverse();
    }
    reset(source);
    while (seq < labels.length && boundTest(filterDefined(last4 ? __spreadArray(__spreadArray([last4], __read(target), false), [first3], false) : __spreadArray([first3], __read(target), false)), attr2, overlapCfg === null || overlapCfg === void 0 ? void 0 : overlapCfg.margin).length) {
      if (last4 && !first3 && seq % 2 === 0) {
        var rest = source.splice(0, 1);
        rest.forEach(utils.hide);
      } else if (last4 && first3) {
        var rest = source.splice(0, 1);
        rest.forEach(utils.hide);
      }
      target = parityHide(reset(source), { seq });
      seq++;
    }
  }

  // node_modules/@antv/component/esm/ui/axis/overlap/autoRotate.js
  function rotateLabels(labels, overlapCfg, attr2, utils) {
    var e_1, _a;
    var _b = overlapCfg.optionalAngles, optionalAngles = _b === void 0 ? [0, 45, 90] : _b, margin = overlapCfg.margin, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c;
    var defaultAngles = labels.map(function(label) {
      return label.getLocalEulerAngles();
    });
    var runAndPassed = function() {
      return boundTest(labels, attr2, margin).length < 1;
    };
    var setLabelsRotate = function(angle5) {
      return labels.forEach(function(label, index4) {
        var rotate5 = Array.isArray(angle5) ? angle5[index4] : angle5;
        utils.rotate(label, +rotate5);
      });
    };
    try {
      for (var optionalAngles_1 = __values(optionalAngles), optionalAngles_1_1 = optionalAngles_1.next(); !optionalAngles_1_1.done; optionalAngles_1_1 = optionalAngles_1.next()) {
        var angle4 = optionalAngles_1_1.value;
        setLabelsRotate(angle4);
        if (runAndPassed())
          return;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (optionalAngles_1_1 && !optionalAngles_1_1.done && (_a = optionalAngles_1.return)) _a.call(optionalAngles_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    if (recoverWhenFailed) {
      setLabelsRotate(defaultAngles);
    }
  }

  // node_modules/@antv/component/esm/ui/axis/overlap/autoWrap.js
  function inferTextBaseline(attr2) {
    var type = attr2.type, labelDirection = attr2.labelDirection;
    if (type === "linear" && isAxisHorizontal(attr2)) {
      return labelDirection === "negative" ? "bottom" : "top";
    }
    return "middle";
  }
  function wrapLabels(labels, overlapCfg, attr2, utils) {
    var _a = overlapCfg.wordWrapWidth, wordWrapWidth = _a === void 0 ? 50 : _a, _b = overlapCfg.maxLines, maxLines = _b === void 0 ? 3 : _b, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
    var defaultLines = labels.map(function(label) {
      return label.attr("maxLines") || 1;
    });
    var minLines = Math.min.apply(Math, __spreadArray([], __read(defaultLines), false));
    var runAndPassed = function() {
      return boundTest(labels, attr2, margin).length < 1;
    };
    var textBaseline = inferTextBaseline(attr2);
    var setLabelsWrap = function(lines2) {
      return labels.forEach(function(label, index4) {
        var maxLines2 = Array.isArray(lines2) ? lines2[index4] : lines2;
        utils.wrap(label, wordWrapWidth, maxLines2, textBaseline);
      });
    };
    if (minLines > maxLines)
      return;
    for (var lines = minLines; lines <= maxLines; lines++) {
      setLabelsWrap(lines);
      if (runAndPassed())
        return;
    }
    if (recoverWhenFailed) {
      setLabelsWrap(defaultLines);
    }
  }

  // node_modules/@antv/component/esm/ui/axis/overlap/index.js
  var OverlapUtils = /* @__PURE__ */ new Map([
    ["hide", hideLabels],
    ["rotate", rotateLabels],
    ["ellipsis", ellipseLabels],
    ["wrap", wrapLabels]
  ]);
  function canProcessOverlap(labels, attr2, type) {
    if (attr2.labelOverlap.length < 1)
      return false;
    if (type === "hide")
      return !isInOffscreenGroup(labels[0]);
    if (type === "rotate")
      return !labels.some(function(label) {
        var _a;
        return !!((_a = label.attr("transform")) === null || _a === void 0 ? void 0 : _a.includes("rotate"));
      });
    if (type === "ellipsis" || type === "wrap")
      return labels.filter(function(item) {
        return item.querySelector("text");
      }).length > 1;
    return true;
  }
  function processOverlap(labels, attr2, utils) {
    var _a = attr2.labelOverlap, labelOverlap = _a === void 0 ? [] : _a;
    if (!labelOverlap.length)
      return;
    labelOverlap.forEach(function(overlapCfg) {
      var type = overlapCfg.type;
      var util = OverlapUtils.get(type);
      if (canProcessOverlap(labels, attr2, type))
        util === null || util === void 0 ? void 0 : util(labels, overlapCfg, attr2, utils);
    });
  }

  // node_modules/@antv/component/esm/ui/axis/utils/index.js
  function getFactor() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var fn = function(str7) {
      return str7 === "positive" ? -1 : 1;
    };
    return args.reduce(function(acc, cur) {
      return acc * fn(cur);
    }, 1);
  }

  // node_modules/@antv/component/esm/ui/axis/guides/labels.js
  function angleNormalizer(angle4) {
    var normalizedAngle = angle4;
    while (normalizedAngle < 0)
      normalizedAngle += 360;
    return Math.round(normalizedAngle % 360);
  }
  function getAngle3(v1, v2) {
    var _a = __read(v1, 2), x12 = _a[0], y12 = _a[1];
    var _b = __read(v2, 2), x22 = _b[0], y22 = _b[1];
    var _c = __read([x12 * x22 + y12 * y22, x12 * y22 - y12 * x22], 2), dot8 = _c[0], det = _c[1];
    return Math.atan2(det, dot8);
  }
  function correctLabelRotation(_rotate) {
    var rotate5 = (_rotate + 360) % 180;
    if (!inRange(rotate5, -90, 90))
      rotate5 += 180;
    return rotate5;
  }
  function getLabelRotation(datum, label, attr2) {
    var _a;
    var labelAlign = attr2.labelAlign;
    var customRotate = (_a = label.style.transform) === null || _a === void 0 ? void 0 : _a.includes("rotate");
    if (customRotate)
      return label.getLocalEulerAngles();
    var rotate5 = 0;
    var labelVector = getLabelVector(datum.value, attr2);
    var tangentVector = getLineTangentVector(datum.value, attr2);
    if (labelAlign === "horizontal")
      return 0;
    if (labelAlign === "perpendicular")
      rotate5 = getAngle3([1, 0], labelVector);
    else
      rotate5 = getAngle3([tangentVector[0] < 0 ? -1 : 1, 0], tangentVector);
    return correctLabelRotation(radToDeg(rotate5));
  }
  function getLabelStyle(value2, rotate5, attr2) {
    var type = attr2.type, labelAlign = attr2.labelAlign;
    var labelVector = getLabelVector(value2, attr2);
    var labelAngle = angleNormalizer(rotate5);
    var tickAngle = angleNormalizer(radToDeg(getAngle3([1, 0], labelVector)));
    var textAlign = "center";
    var textBaseline = "middle";
    if (type === "linear") {
      if ([90, 270].includes(tickAngle) && labelAngle === 0) {
        textAlign = "center";
        textBaseline = labelVector[1] === 1 ? "top" : "bottom";
      } else if (!(tickAngle % 180) && [90, 270].includes(labelAngle)) {
        textAlign = "center";
      } else if (tickAngle === 0) {
        if (inRange(labelAngle, 0, 90, false, true)) {
          textAlign = "start";
        } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
          textAlign = "start";
        }
      } else if (tickAngle === 90) {
        if (inRange(labelAngle, 0, 90, false, true)) {
          textAlign = "start";
        } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
          textAlign = "end";
        }
      } else if (tickAngle === 270) {
        if (inRange(labelAngle, 0, 90, false, true)) {
          textAlign = "end";
        } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
          textAlign = "start";
        }
      } else if (tickAngle === 180) {
        if (labelAngle === 90) {
          textAlign = "start";
        } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
          textAlign = "end";
        }
      }
    } else {
      if (labelAlign === "parallel") {
        if (inRange(tickAngle, 0, 180, true)) {
          textBaseline = "top";
        } else {
          textBaseline = "bottom";
        }
      } else if (labelAlign === "horizontal") {
        if (inRange(tickAngle, 90, 270, false)) {
          textAlign = "end";
        } else if (inRange(tickAngle, 270, 360, false) || inRange(tickAngle, 0, 90)) {
          textAlign = "start";
        }
      } else if (labelAlign === "perpendicular") {
        if (inRange(tickAngle, 90, 270)) {
          textAlign = "end";
        } else {
          textAlign = "start";
        }
      }
    }
    return { textAlign, textBaseline };
  }
  function setRotateAndAdjustLabelAlign(rotate5, group3, attr2) {
    group3.setLocalEulerAngles(rotate5);
    var value2 = group3.__data__.value;
    var textStyle = getLabelStyle(value2, rotate5, attr2);
    var label = group3.querySelector(CLASS_NAMES3.labelItem.class);
    if (label)
      applyTextStyle(label, textStyle);
  }
  function getLabelPos(datum, data2, attr2) {
    var showTick = attr2.showTick, tickLength = attr2.tickLength, tickDirection = attr2.tickDirection, labelDirection = attr2.labelDirection, labelSpacing = attr2.labelSpacing;
    var index4 = data2.indexOf(datum);
    var finalLabelSpacing = getCallbackValue(labelSpacing, [datum, index4, data2]);
    var _a = __read([getLabelVector(datum.value, attr2), getFactor(labelDirection, tickDirection)], 2), labelVector = _a[0], unionFactor = _a[1];
    var extraLength = unionFactor === 1 ? getCallbackValue(showTick ? tickLength : 0, [datum, index4, data2]) : 0;
    var _b = __read(add9(scale8(labelVector, finalLabelSpacing + extraLength), getValuePos(datum.value, attr2)), 2), x3 = _b[0], y3 = _b[1];
    return { x: x3, y: y3 };
  }
  function formatter(datum, index4, data2, attr2) {
    var labelFormatter = attr2.labelFormatter;
    var element = isFunction(labelFormatter) ? function() {
      return renderExtDo(getCallbackValue(labelFormatter, [datum, index4, data2, getLabelVector(datum.value, attr2)]));
    } : function() {
      return renderExtDo(datum.label || "");
    };
    return element;
  }
  function applyTextStyle(node, style) {
    if (node.nodeName === "text")
      node.attr(style);
  }
  function overlapHandler(attr2) {
    processOverlap(this.node().childNodes, attr2, {
      hide,
      show,
      rotate: function(label, angle4) {
        setRotateAndAdjustLabelAlign(+angle4, label, attr2);
      },
      ellipsis: function(label, len5, suffix) {
        label && ellipsisIt(label, len5 || Infinity, suffix);
      },
      wrap: function(label, width, lines) {
        label && wrapIt(label, width, lines);
      },
      getTextShape: function(label) {
        return label.querySelector("text");
      }
    });
  }
  function renderLabel(container, datum, data2, style, attr2) {
    var index4 = data2.indexOf(datum);
    var label = select2(container).append(formatter(datum, index4, data2, attr2)).attr("className", CLASS_NAMES3.labelItem.name).node();
    var _a = __read(splitStyle(getCallbackStyle(style, [datum, index4, data2])), 2), labelStyle = _a[0], _b = _a[1], transform = _b.transform, groupStyle = __rest(_b, ["transform"]);
    percentTransform(label, transform);
    var rotate5 = getLabelRotation(datum, label, attr2);
    if (!label.getLocalEulerAngles()) {
      label.setLocalEulerAngles(rotate5);
    }
    applyTextStyle(label, __assign(__assign({}, getLabelStyle(datum.value, rotate5, attr2)), labelStyle));
    container.attr(groupStyle);
    return label;
  }
  function renderLabels(container, data2, attr2, animate2) {
    var finalData = filterExec(data2, attr2.labelFilter);
    var style = subStyleProps(attr2, "label");
    return container.selectAll(CLASS_NAMES3.label.class).data(finalData, function(d3, i) {
      return i;
    }).join(function(enter) {
      return enter.append("g").attr("className", CLASS_NAMES3.label.name).transition(function(datum) {
        renderLabel(this, datum, data2, style, attr2);
        var _a = getLabelPos(datum, data2, attr2), x3 = _a.x, y3 = _a.y;
        this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        return null;
      }).call(function() {
        overlapHandler.call(container, attr2);
      });
    }, function(update) {
      return update.transition(function(datum) {
        var prevLabel = this.querySelector(CLASS_NAMES3.labelItem.class);
        var label = renderLabel(this, datum, data2, style, attr2);
        var shapeAnimation = transitionShape(prevLabel, label, animate2.update);
        var _a = getLabelPos(datum, data2, attr2), x3 = _a.x, y3 = _a.y;
        var animation = transition(this, { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2.update);
        return __spreadArray(__spreadArray([], __read(shapeAnimation), false), [animation], false);
      }).call(function(selection) {
        var transitions = get_default(selection, "_transitions").flat().filter(defined2);
        onAnimatesFinished(transitions, function() {
          overlapHandler.call(container, attr2);
        });
      });
    }, function(exit) {
      return exit.transition(function() {
        var _this = this;
        var animation = fadeOut_default(this.childNodes[0], animate2.exit);
        onAnimateFinished(animation, function() {
          return select2(_this).remove();
        });
        return animation;
      });
    }).transitions();
  }

  // node_modules/@antv/component/esm/ui/axis/guides/ticks.js
  function getTickVector(value2, attr2) {
    return getDirectionVector(value2, attr2.tickDirection, attr2);
  }
  function getTickPoints(unitVector, tickLength) {
    var _a = __read(unitVector, 2), dx = _a[0], dy = _a[1];
    return [
      [0, 0],
      [dx * tickLength, dy * tickLength]
    ];
  }
  function getTickLineLayout(datum, index4, data2, tickVector, attr2) {
    var tickLength = attr2.tickLength;
    var _a = __read(getTickPoints(tickVector, getCallbackValue(tickLength, [datum, index4, data2])), 2), _b = __read(_a[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a[1], 2), x22 = _c[0], y22 = _c[1];
    return { x1: x12, x2: x22, y1: y12, y2: y22 };
  }
  function createTickEl(container, datum, index4, data2, attr2) {
    var formatter2 = attr2.tickFormatter;
    var tickVector = getTickVector(datum.value, attr2);
    var el = "line";
    if (isFunction(formatter2))
      el = function() {
        return getCallbackValue(formatter2, [datum, index4, data2, tickVector]);
      };
    return container.append(el).attr("className", CLASS_NAMES3.tickItem.name);
  }
  function applyTickStyle(datum, index4, data2, tick3, group3, attr2, style) {
    var tickVector = getTickVector(datum.value, attr2);
    var _a = getTickLineLayout(datum, index4, data2, tickVector, attr2), x12 = _a.x1, x22 = _a.x2, y12 = _a.y1, y22 = _a.y2;
    var _b = __read(splitStyle(getCallbackStyle(style, [datum, index4, data2, tickVector])), 2), tickStyle = _b[0], groupStyle = _b[1];
    tick3.node().nodeName === "line" && tick3.styles(__assign({ x1: x12, x2: x22, y1: y12, y2: y22 }, tickStyle));
    group3.attr(groupStyle);
    tick3.styles(tickStyle);
  }
  function createTick(datum, index4, data2, attr2, tickAttr, animate2) {
    var tick3 = createTickEl(select2(this), datum, index4, data2, attr2);
    applyTickStyle(datum, index4, data2, tick3, this, attr2, tickAttr);
    var _a = __read(getValuePos(datum.value, attr2), 2), x3 = _a[0], y3 = _a[1];
    return transition(this, { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2);
  }
  function renderTicks(container, axisData, attr2, animate2) {
    var finalData = filterExec(axisData, attr2.tickFilter);
    var tickAttr = subStyleProps(attr2, "tick");
    return container.selectAll(CLASS_NAMES3.tick.class).data(finalData, function(d3) {
      return d3.id || d3.label;
    }).join(function(enter) {
      return enter.append("g").attr("className", CLASS_NAMES3.tick.name).transition(function(datum, index4) {
        return createTick.call(this, datum, index4, finalData, attr2, tickAttr, false);
      });
    }, function(update) {
      return update.transition(function(datum, index4) {
        this.removeChildren();
        return createTick.call(this, datum, index4, finalData, attr2, tickAttr, animate2.update);
      });
    }, function(exit) {
      return exit.transition(function() {
        var _this = this;
        var animation = fadeOut_default(this.childNodes[0], animate2.exit);
        onAnimateFinished(animation, function() {
          return _this.remove();
        });
        return animation;
      });
    }).transitions();
  }

  // node_modules/@antv/component/esm/ui/title/index.js
  var CLASS_NAMES5 = classNames({
    text: "text"
  }, "title");
  function parsePosition(position) {
    if (!/\S+-\S+/g.test(position))
      return position.length > 2 ? [position[0]] : position.split("");
    return position.split("-").map(function(str7) {
      return str7[0];
    });
  }
  function getBBox(title, content) {
    var _a = title.attributes, position = _a.position, spacing = _a.spacing, inset = _a.inset, text = _a.text;
    var titleBBox = title.getBBox();
    var contentBBox = content.getBBox();
    var pos = parsePosition(position);
    var _b = __read(parseSeriesAttr(text ? spacing : 0), 4), spacingTop = _b[0], spacingRight = _b[1], spacingBottom = _b[2], spacingLeft = _b[3];
    var _c = __read(parseSeriesAttr(inset), 4), insetTop = _c[0], insetRight = _c[1], insetBottom = _c[2], insetLeft = _c[3];
    var _d = __read([spacingLeft + spacingRight, spacingTop + spacingBottom], 2), spacingWidth = _d[0], spacingHeight = _d[1];
    var _e = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _e[0], insetHeight = _e[1];
    if (pos[0] === "l") {
      return new BBox(titleBBox.x, titleBBox.y, contentBBox.width + titleBBox.width + spacingWidth + insetWidth, Math.max(contentBBox.height + insetHeight, titleBBox.height));
    }
    if (pos[0] === "t") {
      return new BBox(titleBBox.x, titleBBox.y, Math.max(contentBBox.width + insetWidth, titleBBox.width), contentBBox.height + titleBBox.height + spacingHeight + insetHeight);
    }
    var _f = __read([
      content.attributes.width || contentBBox.width,
      content.attributes.height || contentBBox.height
    ], 2), contentWidth = _f[0], contentHeight = _f[1];
    return new BBox(contentBBox.x, contentBBox.y, contentWidth + titleBBox.width + spacingWidth + insetWidth, contentHeight + titleBBox.height + spacingHeight + insetHeight);
  }
  function mayApplyStyle(el, style) {
    var finalStyle = Object.entries(style).reduce(function(acc, _a) {
      var _b = __read(_a, 2), key = _b[0], value2 = _b[1];
      var currAttr = el.node().attr(key);
      if (!currAttr)
        acc[key] = value2;
      return acc;
    }, {});
    el.styles(finalStyle);
  }
  function getTitleLayout(cfg) {
    var _a, _b, _c, _d;
    var _e = cfg, width = _e.width, height = _e.height, position = _e.position;
    var _f = __read([+width / 2, +height / 2], 2), hW = _f[0], hH = _f[1];
    var _g = __read([+hW, +hH, "center", "middle"], 4), x3 = _g[0], y3 = _g[1], textAlign = _g[2], textBaseline = _g[3];
    var pos = parsePosition(position);
    if (pos.includes("l"))
      _a = __read([0, "start"], 2), x3 = _a[0], textAlign = _a[1];
    if (pos.includes("r"))
      _b = __read([+width, "end"], 2), x3 = _b[0], textAlign = _b[1];
    if (pos.includes("t"))
      _c = __read([0, "top"], 2), y3 = _c[0], textBaseline = _c[1];
    if (pos.includes("b"))
      _d = __read([+height, "bottom"], 2), y3 = _d[0], textBaseline = _d[1];
    return { x: x3, y: y3, textAlign, textBaseline };
  }
  var Title = (
    /** @class */
    function(_super) {
      __extends(Title3, _super);
      function Title3(options) {
        return _super.call(this, options, {
          text: "",
          width: 0,
          height: 0,
          fill: "#4a505a",
          fontWeight: "bold",
          fontSize: 12,
          fontFamily: "sans-serif",
          inset: 0,
          spacing: 0,
          position: "top-left"
        }) || this;
      }
      Title3.prototype.getAvailableSpace = function() {
        var container = this;
        var _a = this.attributes, containerWidth = _a.width, containerHeight = _a.height, position = _a.position, spacing = _a.spacing, inset = _a.inset;
        var title = container.querySelector(CLASS_NAMES5.text.class);
        if (!title)
          return new BBox(0, 0, +containerWidth, +containerHeight);
        var _b = title.getBBox(), titleWidth = _b.width, titleHeight = _b.height;
        var _c = __read(parseSeriesAttr(spacing), 4), spacingTop = _c[0], spacingRight = _c[1], spacingBottom = _c[2], spacingLeft = _c[3];
        var _d = __read([0, 0, +containerWidth, +containerHeight], 4), x3 = _d[0], y3 = _d[1], width = _d[2], height = _d[3];
        var pos = parsePosition(position);
        if (pos.includes("i"))
          return new BBox(x3, y3, width, height);
        pos.forEach(function(p2, i) {
          var _a2, _b2, _c2, _d2;
          if (p2 === "t")
            _a2 = __read(i === 0 ? [titleHeight + spacingBottom, +containerHeight - titleHeight - spacingBottom] : [0, +containerHeight], 2), y3 = _a2[0], height = _a2[1];
          if (p2 === "r")
            _b2 = __read([+containerWidth - titleWidth - spacingLeft], 1), width = _b2[0];
          if (p2 === "b")
            _c2 = __read([+containerHeight - titleHeight - spacingTop], 1), height = _c2[0];
          if (p2 === "l")
            _d2 = __read(i === 0 ? [titleWidth + spacingRight, +containerWidth - titleWidth - spacingRight] : [0, +containerWidth], 2), x3 = _d2[0], width = _d2[1];
        });
        var _e = __read(parseSeriesAttr(inset), 4), insetTop = _e[0], insetRight = _e[1], insetBottom = _e[2], insetLeft = _e[3];
        var _f = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _f[0], insetHeight = _f[1];
        return new BBox(x3 + insetLeft, y3 + insetTop, width - insetWidth, height - insetHeight);
      };
      Title3.prototype.getBBox = function() {
        if (this.title)
          return this.title.getBBox();
        return new BBox(0, 0, 0, 0);
      };
      Title3.prototype.render = function(attributes, container) {
        var _this = this;
        var width = attributes.width, height = attributes.height, position = attributes.position, spacing = attributes.spacing, restStyle = __rest(attributes, ["width", "height", "position", "spacing"]);
        var _a = __read(splitStyle(restStyle), 1), titleStyle = _a[0];
        var _b = getTitleLayout(attributes), x3 = _b.x, y3 = _b.y, textAlign = _b.textAlign, textBaseline = _b.textBaseline;
        ifShow(!!restStyle.text, select2(container), function(group3) {
          _this.title = group3.maybeAppendByClassName(CLASS_NAMES5.text, "text").styles(titleStyle).call(mayApplyStyle, { x: x3, y: y3, textAlign, textBaseline }).node();
        });
      };
      return Title3;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/axis/guides/title.js
  function getTitlePosition(mainGroup, titleGroup, attr2) {
    var _a = attr2.titlePosition, position = _a === void 0 ? "lb" : _a, spacing = attr2.titleSpacing;
    var pos = parsePosition(position);
    var _b = mainGroup.node().getLocalBounds(), _c = __read(_b.min, 2), mainX = _c[0], mainY = _c[1], _d = __read(_b.halfExtents, 2), mainHalfWidth = _d[0], mainHalfHeight = _d[1];
    var _e = __read(titleGroup.node().getLocalBounds().halfExtents, 2), titleHalfWidth = _e[0], titleHalfHeight = _e[1];
    var _f = __read([mainX + mainHalfWidth, mainY + mainHalfHeight], 2), x3 = _f[0], y3 = _f[1];
    var _g = __read(parseSeriesAttr(spacing), 4), spacingTop = _g[0], spacingRight = _g[1], spacingBottom = _g[2], spacingLeft = _g[3];
    if (["start", "end"].includes(position) && attr2.type === "linear") {
      var startPos = attr2.startPos, endPos = attr2.endPos;
      var _h = __read(position === "start" ? [startPos, endPos] : [endPos, startPos], 2), from = _h[0], to = _h[1];
      var direction2 = normalize7([-to[0] + from[0], -to[1] + from[1]]);
      var _j = __read(scale8(direction2, spacingTop), 2), dx = _j[0], dy = _j[1];
      return { x: from[0] + dx, y: from[1] + dy };
    }
    if (pos.includes("t"))
      y3 -= mainHalfHeight + titleHalfHeight + spacingTop;
    if (pos.includes("r"))
      x3 += mainHalfWidth + titleHalfWidth + spacingRight;
    if (pos.includes("l"))
      x3 -= mainHalfWidth + titleHalfWidth + spacingLeft;
    if (pos.includes("b"))
      y3 += mainHalfHeight + titleHalfHeight + spacingBottom;
    return { x: x3, y: y3 };
  }
  function inferTransform(n2, direction2, position) {
    var halfExtents = n2.getGeometryBounds().halfExtents;
    var height = halfExtents[1] * 2;
    if (direction2 === "vertical") {
      if (position === "left")
        return "rotate(-90) translate(0, ".concat(height / 2, ")");
      if (position === "right")
        return "rotate(-90) translate(0, -".concat(height / 2, ")");
    }
    return "";
  }
  function applyTitleStyle(title, group3, axis, attr2, animate2) {
    var style = subStyleProps(attr2, "title");
    var _a = __read(splitStyle(style), 2), titleStyle = _a[0], _b = _a[1], specified = _b.transform, transformOrigin = _b.transformOrigin, groupStyle = __rest(_b, ["transform", "transformOrigin"]);
    group3.styles(groupStyle);
    var transform = specified || inferTransform(title.node(), titleStyle.direction, titleStyle.position);
    title.styles(__assign(__assign({}, titleStyle), { transformOrigin }));
    percentTransform(title.node(), transform);
    var _c = getTitlePosition(
      // @ts-ignore
      select2(axis._offscreen || axis.querySelector(CLASS_NAMES3.mainGroup.class)),
      group3,
      attr2
    ), x3 = _c.x, y3 = _c.y;
    var animation = transition(group3.node(), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2);
    return animation;
  }
  function renderTitle(container, axis, attr2, animate2) {
    var titleText = attr2.titleText;
    return container.selectAll(CLASS_NAMES3.title.class).data([{ title: titleText }].filter(function(d3) {
      return !!d3.title;
    }), function(d3, i) {
      return d3.title;
    }).join(function(enter) {
      return enter.append(function() {
        return renderExtDo(titleText);
      }).attr("className", CLASS_NAMES3.title.name).transition(function() {
        return applyTitleStyle(select2(this), container, axis, attr2, animate2.enter);
      });
    }, function(update) {
      return update.transition(function() {
        return applyTitleStyle(select2(this), container, axis, attr2, animate2.update);
      });
    }, function(exit) {
      return exit.remove();
    }).transitions();
  }

  // node_modules/@antv/component/esm/ui/axis/axis.js
  function renderAxisMain(attributes, container, data2, animation) {
    var showLine = attributes.showLine, showTick = attributes.showTick, showLabel = attributes.showLabel;
    var lineGroup = container.maybeAppendByClassName(CLASS_NAMES3.lineGroup, "g");
    var lineTransitions = ifShow(showLine, lineGroup, function(group3) {
      return renderAxisLine(group3, attributes, animation);
    }) || [];
    var tickGroup = container.maybeAppendByClassName(CLASS_NAMES3.tickGroup, "g");
    var tickTransitions = ifShow(showTick, tickGroup, function(group3) {
      return renderTicks(group3, data2, attributes, animation);
    }) || [];
    var labelGroup = container.maybeAppendByClassName(CLASS_NAMES3.labelGroup, "g");
    var labelTransitions = ifShow(showLabel, labelGroup, function(group3) {
      return renderLabels(group3, data2, attributes, animation);
    }) || [];
    return __spreadArray(__spreadArray(__spreadArray([], __read(lineTransitions), false), __read(tickTransitions), false), __read(labelTransitions), false).filter(function(t) {
      return !!t;
    });
  }
  var Axis = (
    /** @class */
    function(_super) {
      __extends(Axis2, _super);
      function Axis2(options) {
        return _super.call(this, options, AXIS_BASE_DEFAULT_ATTR) || this;
      }
      Axis2.prototype.render = function(attributes, container, specificAnimation) {
        var _this = this;
        var titleText = attributes.titleText, data2 = attributes.data, animate2 = attributes.animate, showTitle = attributes.showTitle, showGrid = attributes.showGrid, dataThreshold = attributes.dataThreshold, truncRange = attributes.truncRange;
        var sampledData = sampling(data2, dataThreshold).filter(function(_a) {
          var value2 = _a.value;
          if (truncRange && value2 > truncRange[0] && value2 < truncRange[1])
            return false;
          return true;
        });
        var finalAnimation = parseAnimationOption(specificAnimation === void 0 ? animate2 : specificAnimation);
        var gridGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.gridGroup, "g");
        var gridTransitions = ifShow(showGrid, gridGroup, function(group3) {
          return renderGrid(group3, sampledData, attributes, finalAnimation);
        }) || [];
        var mainGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.mainGroup, "g");
        if (titleText && (!this.initialized && finalAnimation.enter || this.initialized && finalAnimation.update)) {
          renderAxisMain(attributes, select2(this.offscreenGroup), sampledData, parseAnimationOption(false));
        }
        var mainTransitions = renderAxisMain(attributes, select2(mainGroup.node()), sampledData, finalAnimation);
        var titleGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.titleGroup, "g");
        var titleTransitions = ifShow(showTitle, titleGroup, function(group3) {
          return renderTitle(group3, _this, attributes, finalAnimation);
        }) || [];
        return __spreadArray(__spreadArray(__spreadArray([], __read(gridTransitions), false), __read(mainTransitions), false), __read(titleTransitions), false).flat().filter(function(t) {
          return !!t;
        });
      };
      return Axis2;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/navigator/index.js
  var CLASS_NAMES6 = classNames({
    prevBtnGroup: "prev-btn-group",
    prevBtn: "prev-btn",
    nextBtnGroup: "next-btn-group",
    nextBtn: "next-btn",
    pageInfoGroup: "page-info-group",
    pageInfo: "page-info",
    playWindow: "play-window",
    contentGroup: "content-group",
    controller: "controller",
    clipPath: "clip-path"
  }, "navigator");
  var Navigator2 = (
    /** @class */
    function(_super) {
      __extends(Navigator3, _super);
      function Navigator3(options) {
        var _this = _super.call(this, options, {
          x: 0,
          y: 0,
          animate: {
            easing: "linear",
            duration: 200,
            fill: "both"
          },
          buttonCursor: "pointer",
          buttonFill: "black",
          buttonD: button(0, 0, 6),
          buttonSize: 12,
          controllerPadding: 5,
          controllerSpacing: 5,
          formatter: function(curr, total) {
            return "".concat(curr, "/").concat(total);
          },
          defaultPage: 0,
          loop: false,
          orientation: "horizontal",
          pageNumFill: "black",
          pageNumFontSize: 12,
          pageNumTextAlign: "start",
          pageNumTextBaseline: "middle"
        }) || this;
        _this.playState = "idle";
        _this.contentGroup = _this.appendChild(new Group2({ class: CLASS_NAMES6.contentGroup.name }));
        _this.playWindow = _this.contentGroup.appendChild(new Group2({ class: CLASS_NAMES6.playWindow.name }));
        _this.innerCurrPage = _this.defaultPage;
        return _this;
      }
      Object.defineProperty(Navigator3.prototype, "defaultPage", {
        get: function() {
          var defaultPage = this.attributes.defaultPage;
          return clamp_default(defaultPage, 0, Math.max(this.pageViews.length - 1, 0));
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Navigator3.prototype, "pageViews", {
        get: function() {
          return this.playWindow.children;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Navigator3.prototype, "controllerShape", {
        // todo fixme
        get: function() {
          return this.totalPages > 1 ? { width: 55, height: 0 } : { width: 0, height: 0 };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Navigator3.prototype, "pageShape", {
        get: function() {
          var pageViews = this.pageViews;
          var _a = __read(transpose3(pageViews.map(function(pageView) {
            var _a2 = pageView.getBBox(), width = _a2.width, height = _a2.height;
            return [width, height];
          })).map(function(arr) {
            return Math.max.apply(Math, __spreadArray([], __read(arr), false));
          }), 2), maxWidth = _a[0], maxHeight = _a[1];
          var _b = this.attributes, _c = _b.pageWidth, pageWidth = _c === void 0 ? maxWidth : _c, _d = _b.pageHeight, pageHeight = _d === void 0 ? maxHeight : _d;
          return { pageWidth, pageHeight };
        },
        enumerable: false,
        configurable: true
      });
      Navigator3.prototype.getContainer = function() {
        return this.playWindow;
      };
      Object.defineProperty(Navigator3.prototype, "totalPages", {
        get: function() {
          return this.pageViews.length;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Navigator3.prototype, "currPage", {
        get: function() {
          return this.innerCurrPage;
        },
        enumerable: false,
        configurable: true
      });
      Navigator3.prototype.getBBox = function() {
        var _a = _super.prototype.getBBox.call(this), x3 = _a.x, y3 = _a.y;
        var controllerShape = this.controllerShape;
        var _b = this.pageShape, pageWidth = _b.pageWidth, pageHeight = _b.pageHeight;
        return new BBox(x3, y3, pageWidth + controllerShape.width, pageHeight);
      };
      Navigator3.prototype.goTo = function(pageNum) {
        var _this = this;
        var animateOptions = this.attributes.animate;
        var _a = this, currPage = _a.currPage, playState = _a.playState, playWindow = _a.playWindow, pageViews = _a.pageViews;
        if (playState !== "idle" || pageNum < 0 || pageViews.length <= 0 || pageNum >= pageViews.length)
          return null;
        pageViews[currPage].setLocalPosition(0, 0);
        this.prepareFollowingPage(pageNum);
        var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
        this.playState = "running";
        var animation = animate(playWindow, [{ transform: "translate(0, 0)" }, { transform: "translate(".concat(-dx, ", ").concat(-dy, ")") }], animateOptions);
        onAnimateFinished(animation, function() {
          _this.innerCurrPage = pageNum;
          _this.playState = "idle";
          _this.setVisiblePages([pageNum]);
          _this.updatePageInfo();
        });
        return animation;
      };
      Navigator3.prototype.prev = function() {
        var loop = this.attributes.loop;
        var pages = this.pageViews.length;
        var page = this.currPage;
        if (!loop && page <= 0)
          return null;
        var following = loop ? (page - 1 + pages) % pages : clamp_default(page - 1, 0, pages);
        return this.goTo(following);
      };
      Navigator3.prototype.next = function() {
        var loop = this.attributes.loop;
        var pages = this.pageViews.length;
        var page = this.currPage;
        if (!loop && page >= pages - 1)
          return null;
        var following = loop ? (page + 1) % pages : clamp_default(page + 1, 0, pages);
        return this.goTo(following);
      };
      Navigator3.prototype.renderClipPath = function(container) {
        var _a = this.pageShape, pageWidth = _a.pageWidth, pageHeight = _a.pageHeight;
        if (!pageWidth || !pageHeight) {
          this.contentGroup.style.clipPath = void 0;
          return;
        }
        this.clipPath = container.maybeAppendByClassName(CLASS_NAMES6.clipPath, "rect").styles({
          width: pageWidth,
          height: pageHeight
        });
        this.contentGroup.attr("clipPath", this.clipPath.node());
      };
      Navigator3.prototype.setVisiblePages = function(pages) {
        this.playWindow.children.forEach(function(page, index4) {
          if (pages.includes(index4))
            show(page);
          else
            hide(page);
        });
      };
      Navigator3.prototype.adjustControllerLayout = function() {
        var _a = this, prevBtn = _a.prevBtnGroup, nextBtn = _a.nextBtnGroup, pageNum = _a.pageInfoGroup;
        var _b = this.attributes, orientation = _b.orientation, padding = _b.controllerPadding;
        var _c = pageNum.getBBox(), pW = _c.width, pH = _c.height;
        var _d = __read(orientation === "horizontal" ? [-180, 0] : [-90, 90], 2), r1 = _d[0], r2 = _d[1];
        prevBtn.setLocalEulerAngles(r1);
        nextBtn.setLocalEulerAngles(r2);
        var _e = prevBtn.getBBox(), bpW = _e.width, bpH = _e.height;
        var _f = nextBtn.getBBox(), bnW = _f.width, bnH = _f.height;
        var maxWidth = Math.max(bpW, pW, bnW);
        var _g = orientation === "horizontal" ? {
          offset: [
            [0, 0],
            [bpW / 2 + padding, 0],
            [bpW + pW + padding * 2, 0]
          ],
          textAlign: "start"
        } : {
          offset: [
            [maxWidth / 2, -bpH - padding],
            [maxWidth / 2, 0],
            [maxWidth / 2, bnH + padding]
          ],
          textAlign: "center"
        }, _h = __read(_g.offset, 3), _j = __read(_h[0], 2), o1x = _j[0], o1y = _j[1], _k = __read(_h[1], 2), o2x = _k[0], o2y = _k[1], _l = __read(_h[2], 2), o3x = _l[0], o3y = _l[1], textAlign = _g.textAlign;
        var pageNumText = pageNum.querySelector("text");
        pageNumText && (pageNumText.style.textAlign = textAlign);
        prevBtn.setLocalPosition(o1x, o1y);
        pageNum.setLocalPosition(o2x, o2y);
        nextBtn.setLocalPosition(o3x, o3y);
      };
      Navigator3.prototype.updatePageInfo = function() {
        var _a;
        var _b = this, currPage = _b.currPage, pageViews = _b.pageViews, formatter2 = _b.attributes.formatter;
        if (pageViews.length < 2)
          return;
        (_a = this.pageInfoGroup.querySelector(CLASS_NAMES6.pageInfo.class)) === null || _a === void 0 ? void 0 : _a.attr("text", formatter2(currPage + 1, pageViews.length));
        this.adjustControllerLayout();
      };
      Navigator3.prototype.getFollowingPageDiff = function(pageNum) {
        var currPage = this.currPage;
        if (currPage === pageNum)
          return [0, 0];
        var orientation = this.attributes.orientation;
        var _a = this.pageShape, pageWidth = _a.pageWidth, pageHeight = _a.pageHeight;
        var sign3 = pageNum < currPage ? -1 : 1;
        return orientation === "horizontal" ? [sign3 * pageWidth, 0] : [0, sign3 * pageHeight];
      };
      Navigator3.prototype.prepareFollowingPage = function(pageNum) {
        var _a = this, currPage = _a.currPage, pageViews = _a.pageViews;
        this.setVisiblePages([pageNum, currPage]);
        if (pageNum !== currPage) {
          var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
          pageViews[pageNum].setLocalPosition(dx, dy);
        }
      };
      Navigator3.prototype.renderController = function(container) {
        var _this = this;
        var spacing = this.attributes.controllerSpacing;
        var _a = this.pageShape, pageWidth = _a.pageWidth, pageHeight = _a.pageHeight;
        var visible = this.pageViews.length >= 2;
        var group3 = container.maybeAppendByClassName(CLASS_NAMES6.controller, "g");
        visibility(group3.node(), visible);
        if (!visible)
          return;
        var style = subStyleProps(this.attributes, "button");
        var textStyle = subStyleProps(this.attributes, "pageNum");
        var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1], size2 = _c.size, pathStyle = __rest(_c, ["size"]);
        var whetherToAddEventListener = !group3.select(CLASS_NAMES6.prevBtnGroup.class).node();
        var prevBtnGroup = group3.maybeAppendByClassName(CLASS_NAMES6.prevBtnGroup, "g").styles(groupStyle);
        this.prevBtnGroup = prevBtnGroup.node();
        var prevBtn = prevBtnGroup.maybeAppendByClassName(CLASS_NAMES6.prevBtn, "path");
        var nextBtnGroup = group3.maybeAppendByClassName(CLASS_NAMES6.nextBtnGroup, "g").styles(groupStyle);
        this.nextBtnGroup = nextBtnGroup.node();
        var nextBtn = nextBtnGroup.maybeAppendByClassName(CLASS_NAMES6.nextBtn, "path");
        [prevBtn, nextBtn].forEach(function(btn) {
          btn.styles(__assign(__assign({}, pathStyle), { transformOrigin: "center" }));
          scaleToPixel(btn.node(), size2, true);
        });
        var pageInfoGroup = group3.maybeAppendByClassName(CLASS_NAMES6.pageInfoGroup, "g");
        this.pageInfoGroup = pageInfoGroup.node();
        pageInfoGroup.maybeAppendByClassName(CLASS_NAMES6.pageInfo, "text").styles(textStyle);
        this.updatePageInfo();
        group3.node().setLocalPosition(pageWidth + spacing, pageHeight / 2);
        if (whetherToAddEventListener) {
          this.prevBtnGroup.addEventListener("click", function() {
            _this.prev();
          });
          this.nextBtnGroup.addEventListener("click", function() {
            _this.next();
          });
        }
      };
      Navigator3.prototype.render = function(attributes, container) {
        var _a = attributes.x, x3 = _a === void 0 ? 0 : _a, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
        this.attr("transform", "translate(".concat(x3, ", ").concat(y3, ")"));
        var containerSelection = select2(container);
        this.renderClipPath(containerSelection);
        this.renderController(containerSelection);
        this.setVisiblePages([this.defaultPage]);
        this.goTo(this.defaultPage);
      };
      Navigator3.prototype.bindEvents = function() {
        var _this = this;
        var render2 = debounce_default(function() {
          return _this.render(_this.attributes, _this);
        }, 50);
        this.playWindow.addEventListener(ElementEvent.INSERTED, render2);
        this.playWindow.addEventListener(ElementEvent.REMOVED, render2);
      };
      return Navigator3;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/legend/utils.js
  function getStepValueByValue(value2, step2, min10) {
    var count4 = Math.round((value2 - min10) / step2);
    return min10 + count4 * step2;
  }
  function hiddenHandle(x3, y3, r) {
    var ratio = 1.4;
    var diffY = ratio * r;
    return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 - diffY], ["L", x3 + r, y3 + diffY], ["L", x3 - r, y3 + diffY], ["Z"]];
  }
  var HANDLE_HEIGHT_RATIO = 1.4;
  var HANDLE_TRIANGLE_RATIO = 0.4;
  function verticalHandle(x3, y3, r) {
    var width = r;
    var height = width * HANDLE_HEIGHT_RATIO;
    var halfWidth = width / 2;
    var oneSixthWidth = width / 6;
    var triangleX = x3 + height * HANDLE_TRIANGLE_RATIO;
    return [
      ["M", x3, y3],
      ["L", triangleX, y3 + halfWidth],
      ["L", x3 + height, y3 + halfWidth],
      ["L", x3 + height, y3 - halfWidth],
      ["L", triangleX, y3 - halfWidth],
      ["Z"],
      // 绘制两条横线
      ["M", triangleX, y3 + oneSixthWidth],
      ["L", x3 + height - 2, y3 + oneSixthWidth],
      ["M", triangleX, y3 - oneSixthWidth],
      ["L", x3 + height - 2, y3 - oneSixthWidth]
    ];
  }
  function horizontalHandle(x3, y3, r) {
    var width = r;
    var height = width * HANDLE_HEIGHT_RATIO;
    var halfWidth = width / 2;
    var oneSixthWidth = width / 6;
    var triangleY = y3 + height * HANDLE_TRIANGLE_RATIO;
    return [
      ["M", x3, y3],
      ["L", x3 - halfWidth, triangleY],
      ["L", x3 - halfWidth, y3 + height],
      ["L", x3 + halfWidth, y3 + height],
      ["L", x3 + halfWidth, triangleY],
      ["Z"],
      // 绘制两条竖线
      ["M", x3 - oneSixthWidth, triangleY],
      ["L", x3 - oneSixthWidth, y3 + height - 2],
      ["M", x3 + oneSixthWidth, triangleY],
      ["L", x3 + oneSixthWidth, y3 + height - 2]
    ];
  }
  Marker.registerSymbol("hiddenHandle", hiddenHandle);
  Marker.registerSymbol("verticalHandle", verticalHandle);
  Marker.registerSymbol("horizontalHandle", horizontalHandle);
  function getSafetySelections(domain, newSelection, oldSelection, precision) {
    var _a;
    if (precision === void 0) {
      precision = 4;
    }
    var _b = __read(domain, 2), min10 = _b[0], max11 = _b[1];
    var _c = __read(newSelection, 2), start2 = _c[0], end = _c[1];
    var _d = __read(oldSelection, 2), prevStart = _d[0], prevEnd = _d[1];
    var _e = __read([start2, end], 2), startVal = _e[0], endVal = _e[1];
    var range3 = endVal - startVal;
    if (startVal > endVal) {
      _a = __read([endVal, startVal], 2), startVal = _a[0], endVal = _a[1];
    }
    if (range3 > max11 - min10) {
      return [min10, max11];
    }
    if (startVal < min10) {
      if (prevStart === min10 && prevEnd === endVal) {
        return [min10, endVal];
      }
      return [min10, range3 + min10];
    }
    if (endVal > max11) {
      if (prevEnd === max11 && prevStart === startVal) {
        return [startVal, max11];
      }
      return [max11 - range3, max11];
    }
    return [startVal, endVal];
  }
  function ifHorizontal(orientation, a3, b) {
    if (orientation === void 0) {
      orientation = "horizontal";
    }
    return orientation === "horizontal" ? a3 : b;
  }

  // node_modules/@antv/component/esm/ui/legend/category/item.js
  var CLASS_NAMES7 = classNames({
    layout: "flex",
    markerGroup: "marker-group",
    marker: "marker",
    labelGroup: "label-group",
    label: "label",
    valueGroup: "value-group",
    value: "value",
    backgroundGroup: "background-group",
    background: "background"
  }, "legend-category-item");
  function styleOfMarker(group3) {
    var marker = group3.querySelector(CLASS_NAMES7.marker.class);
    if (marker)
      return marker.style;
    return {};
  }
  var CategoryItem = (
    /** @class */
    function(_super) {
      __extends(CategoryItem2, _super);
      function CategoryItem2(options) {
        return _super.call(this, options, {
          span: [1, 1],
          marker: function() {
            return new Circle({ style: { r: 6 } });
          },
          markerSize: 10,
          labelFill: "#646464",
          valueFill: "#646464",
          labelFontSize: 12,
          valueFontSize: 12,
          labelTextBaseline: "middle",
          valueTextBaseline: "middle"
        }) || this;
      }
      Object.defineProperty(CategoryItem2.prototype, "showValue", {
        get: function() {
          var valueText = this.attributes.valueText;
          if (!valueText)
            return false;
          if (typeof valueText === "string" || typeof valueText === "number")
            return valueText !== "";
          if (typeof valueText === "function")
            return true;
          return valueText.attr("text") !== "";
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "actualSpace", {
        get: function() {
          var label = this.labelGroup;
          var value2 = this.valueGroup;
          var markerSize = this.attributes.markerSize;
          var _a = label.node().getBBox(), labelWidth = _a.width, labelHeight = _a.height;
          var _b = value2.node().getBBox(), valueWidth = _b.width, valueHeight = _b.height;
          return {
            markerWidth: markerSize,
            labelWidth,
            valueWidth,
            height: Math.max(markerSize, labelHeight, valueHeight)
          };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "span", {
        get: function() {
          var span = this.attributes.span;
          if (!span)
            return [1, 1];
          var _a = __read(parseSeriesAttr(span), 2), span1 = _a[0], innerSpan = _a[1];
          var span2 = this.showValue ? innerSpan : 0;
          var basis2 = span1 + span2;
          return [span1 / basis2, span2 / basis2];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "shape", {
        get: function() {
          var _a;
          var _b = this.attributes, markerSize = _b.markerSize, fullWidth = _b.width;
          var actualSpace = this.actualSpace;
          var markerWidth = actualSpace.markerWidth, height = actualSpace.height;
          var _c = this.actualSpace, labelWidth = _c.labelWidth, valueWidth = _c.valueWidth;
          var _d = __read(this.spacing, 2), spacing1 = _d[0], spacing2 = _d[1];
          if (fullWidth) {
            var width_1 = fullWidth - markerSize - spacing1 - spacing2;
            var _e = __read(this.span, 2), span1 = _e[0], span2 = _e[1];
            _a = __read([span1 * width_1, span2 * width_1], 2), labelWidth = _a[0], valueWidth = _a[1];
          }
          var width = markerWidth + labelWidth + valueWidth + spacing1 + spacing2;
          return { width, height, markerWidth, labelWidth, valueWidth };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "spacing", {
        get: function() {
          var spacing = this.attributes.spacing;
          if (!spacing)
            return [0, 0];
          var _a = __read(parseSeriesAttr(spacing), 2), spacing1 = _a[0], spacing2 = _a[1];
          if (this.showValue)
            return [spacing1, spacing2];
          return [spacing1, 0];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "layout", {
        get: function() {
          var _a = this.shape, markerWidth = _a.markerWidth, labelWidth = _a.labelWidth, valueWidth = _a.valueWidth, width = _a.width, height = _a.height;
          var _b = __read(this.spacing, 2), spacing1 = _b[0], spacing2 = _b[1];
          return {
            height,
            width,
            markerWidth,
            labelWidth,
            valueWidth,
            position: [markerWidth / 2, markerWidth + spacing1, markerWidth + labelWidth + spacing1 + spacing2]
          };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "scaleSize", {
        get: function() {
          var markerShapeStyle = styleOfMarker(this.markerGroup.node());
          var _a = this.attributes, markerSize = _a.markerSize, _b = _a.markerStrokeWidth, markerStrokeWidth = _b === void 0 ? markerShapeStyle.strokeWidth : _b, _c = _a.markerLineWidth, markerLineWidth = _c === void 0 ? markerShapeStyle.lineWidth : _c, _d = _a.markerStroke, markerStroke = _d === void 0 ? markerShapeStyle.stroke : _d;
          var strokeWidth = +(markerStrokeWidth || markerLineWidth || (markerStroke ? 1 : 0)) * Math.sqrt(2);
          var _e = this.markerGroup.node().getBBox(), width = _e.width, height = _e.height;
          return (1 - strokeWidth / Math.max(width, height)) * markerSize;
        },
        enumerable: false,
        configurable: true
      });
      CategoryItem2.prototype.renderMarker = function(container) {
        var _this = this;
        var marker = this.attributes.marker;
        var style = subStyleProps(this.attributes, "marker");
        this.markerGroup = container.maybeAppendByClassName(CLASS_NAMES7.markerGroup, "g").style("zIndex", 0);
        ifShow(!!marker, this.markerGroup, function() {
          var _a;
          var parent = _this.markerGroup.node();
          var oldMarker = (_a = parent.childNodes) === null || _a === void 0 ? void 0 : _a[0];
          var newMarker = typeof marker === "string" ? new Marker({ style: { symbol: marker }, className: CLASS_NAMES7.marker.name }) : marker();
          if (!oldMarker) {
            if (!(newMarker instanceof Marker))
              select2(newMarker).attr("className", CLASS_NAMES7.marker.name).styles(style);
            parent.appendChild(newMarker);
          } else if (newMarker.nodeName === oldMarker.nodeName) {
            if (oldMarker instanceof Marker)
              oldMarker.update(__assign(__assign({}, style), { symbol: marker }));
            else {
              copyAttributes2(oldMarker, newMarker);
              select2(oldMarker).styles(style);
            }
          } else {
            oldMarker.remove();
            select2(newMarker).attr("className", CLASS_NAMES7.marker.name).styles(style);
            parent.appendChild(newMarker);
          }
          _this.markerGroup.node().scale(1 / _this.markerGroup.node().getScale()[0]);
          var scale10 = scaleToPixel(_this.markerGroup.node(), _this.scaleSize, true);
          _this.markerGroup.node().style._transform = "scale(".concat(scale10, ")");
        });
      };
      CategoryItem2.prototype.renderLabel = function(container) {
        var _a = subStyleProps(this.attributes, "label"), label = _a.text, style = __rest(_a, ["text"]);
        this.labelGroup = container.maybeAppendByClassName(CLASS_NAMES7.labelGroup, "g").style("zIndex", 0);
        this.labelGroup.maybeAppendByClassName(CLASS_NAMES7.label, function() {
          return renderExtDo(label);
        }).styles(style);
      };
      CategoryItem2.prototype.renderValue = function(container) {
        var _this = this;
        var _a = subStyleProps(this.attributes, "value"), value2 = _a.text, style = __rest(_a, ["text"]);
        this.valueGroup = container.maybeAppendByClassName(CLASS_NAMES7.valueGroup, "g").style("zIndex", 0);
        ifShow(this.showValue, this.valueGroup, function() {
          _this.valueGroup.maybeAppendByClassName(CLASS_NAMES7.value, function() {
            return renderExtDo(value2);
          }).styles(style);
        });
      };
      CategoryItem2.prototype.renderBackground = function(container) {
        var _a = this.shape, width = _a.width, height = _a.height;
        var style = subStyleProps(this.attributes, "background");
        this.background = container.maybeAppendByClassName(CLASS_NAMES7.backgroundGroup, "g").style("zIndex", -1);
        this.background.maybeAppendByClassName(CLASS_NAMES7.background, "rect").styles(__assign({ width, height }, style));
      };
      CategoryItem2.prototype.adjustLayout = function() {
        var _a = this.layout, labelWidth = _a.labelWidth, valueWidth = _a.valueWidth, height = _a.height, _b = __read(_a.position, 3), markerX = _b[0], labelX = _b[1], valueX = _b[2];
        var halfHeight = height / 2;
        this.markerGroup.styles({
          transform: "translate(".concat(markerX, ", ").concat(halfHeight, ")").concat(this.markerGroup.node().style._transform)
        });
        this.labelGroup.styles({ transform: "translate(".concat(labelX, ", ").concat(halfHeight, ")") });
        ellipsisIt(this.labelGroup.select(CLASS_NAMES7.label.class).node(), Math.ceil(labelWidth));
        if (this.showValue) {
          this.valueGroup.styles({ transform: "translate(".concat(valueX, ", ").concat(halfHeight, ")") });
          ellipsisIt(this.valueGroup.select(CLASS_NAMES7.value.class).node(), Math.ceil(valueWidth));
        }
      };
      CategoryItem2.prototype.render = function(attributes, container) {
        var ctn = select2(container);
        var _a = attributes.x, x3 = _a === void 0 ? 0 : _a, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
        ctn.styles({ transform: "translate(".concat(x3, ", ").concat(y3, ")") });
        this.renderMarker(ctn);
        this.renderLabel(ctn);
        this.renderValue(ctn);
        this.renderBackground(ctn);
        this.adjustLayout();
      };
      return CategoryItem2;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/legend/category/items.js
  var CLASS_NAMES8 = classNames({
    page: "item-page",
    navigator: "navigator",
    item: "item"
  }, "items");
  var ifSatisfied = function(value2, rule, defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = true;
    }
    if (value2) {
      return rule(value2);
    }
    return defaultValue;
  };
  var CategoryItems = (
    /** @class */
    function(_super) {
      __extends(CategoryItems2, _super);
      function CategoryItems2(options) {
        var _this = _super.call(this, options, {
          data: [],
          gridRow: Infinity,
          gridCol: void 0,
          padding: 0,
          width: 1e3,
          height: 100,
          rowPadding: 0,
          colPadding: 0,
          layout: "flex",
          orientation: "horizontal",
          click: noop_default,
          mouseenter: noop_default,
          mouseleave: noop_default
        }) || this;
        _this.navigatorShape = [0, 0];
        return _this;
      }
      Object.defineProperty(CategoryItems2.prototype, "pageViews", {
        get: function() {
          return this.navigator.getContainer();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItems2.prototype, "grid", {
        get: function() {
          var _a = this.attributes, gridRow = _a.gridRow, gridCol = _a.gridCol, data2 = _a.data;
          if (!gridRow && !gridCol)
            throw new Error("gridRow and gridCol can not be set null at the same time");
          if (!!gridRow && !!gridCol)
            return [gridRow, gridCol];
          if (gridRow)
            return [gridRow, data2.length];
          return [data2.length, gridCol];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItems2.prototype, "renderData", {
        get: function() {
          var _a = this.attributes, data2 = _a.data, layout = _a.layout;
          var style = subStyleProps(this.attributes, "item");
          var d3 = data2.map(function(datum, index4) {
            var _a2 = datum.id, id5 = _a2 === void 0 ? index4 : _a2, labelText = datum.label, valueText = datum.value;
            return {
              id: "".concat(id5),
              index: index4,
              style: __assign({ layout, labelText, valueText }, Object.fromEntries(Object.entries(style).map(function(_a3) {
                var _b = __read(_a3, 2), key = _b[0], val = _b[1];
                return [key, getCallbackValue(val, [datum, index4, data2])];
              })))
            };
          });
          return d3;
        },
        enumerable: false,
        configurable: true
      });
      CategoryItems2.prototype.getGridLayout = function() {
        var _this = this;
        var _a = this.attributes, orientation = _a.orientation, width = _a.width, rowPadding = _a.rowPadding, colPadding = _a.colPadding;
        var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
        var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
        var pageSize = gridCol * gridRow;
        var prevOffset = 0;
        return this.pageViews.children.map(function(item, index4) {
          var _a2, _b2;
          var page = Math.floor(index4 / pageSize);
          var pageIndex = index4 % pageSize;
          var dir = _this.ifHorizontal(gridCol, gridRow);
          var pos = [Math.floor(pageIndex / dir), pageIndex % dir];
          if (orientation === "vertical")
            pos.reverse();
          var _c2 = __read(pos, 2), row2 = _c2[0], col = _c2[1];
          var colWidth = (width - navWidth - (gridCol - 1) * colPadding) / gridCol;
          var rowHeight = item.getBBox().height;
          var _d = __read([0, 0], 2), x3 = _d[0], y3 = _d[1];
          if (orientation === "horizontal") {
            _a2 = __read([prevOffset, row2 * (rowHeight + rowPadding)], 2), x3 = _a2[0], y3 = _a2[1];
            prevOffset = col === gridCol - 1 ? 0 : prevOffset + colWidth + colPadding;
          } else {
            _b2 = __read([col * (colWidth + colPadding), prevOffset], 2), x3 = _b2[0], y3 = _b2[1];
            prevOffset = row2 === gridRow - 1 ? 0 : prevOffset + rowHeight + rowPadding;
          }
          return { page, index: index4, row: row2, col, pageIndex, width: colWidth, height: rowHeight, x: x3, y: y3 };
        });
      };
      CategoryItems2.prototype.getFlexLayout = function() {
        var _a = this.attributes, maxWidth = _a.width, maxHeight = _a.height, rowPadding = _a.rowPadding, cP = _a.colPadding;
        var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
        var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
        var _d = __read([maxWidth - navWidth, maxHeight], 2), limitWidth = _d[0], limitHeight = _d[1];
        var _e = __read([0, 0, 0, 0, 0, 0, 0, 0], 8), x3 = _e[0], y3 = _e[1], page = _e[2], pageIndex = _e[3], col = _e[4], row2 = _e[5], prevWidth = _e[6], prevHeight = _e[7];
        return this.pageViews.children.map(function(item, index4) {
          var _a2, _b2, _c2, _d2;
          var _e2 = item.getBBox(), width = _e2.width, height = _e2.height;
          var colPadding = prevWidth === 0 ? 0 : cP;
          var nextWidth = prevWidth + colPadding + width;
          if (nextWidth <= limitWidth && ifSatisfied(col, function(c5) {
            return c5 < gridCol;
          })) {
            _a2 = __read([prevWidth + colPadding, prevHeight, nextWidth], 3), x3 = _a2[0], y3 = _a2[1], prevWidth = _a2[2];
            return { width, height, x: x3, y: y3, page, index: index4, pageIndex: pageIndex++, row: row2, col: col++ };
          }
          _b2 = __read([row2 + 1, 0, 0, prevHeight + height + rowPadding], 4), row2 = _b2[0], col = _b2[1], prevWidth = _b2[2], prevHeight = _b2[3];
          var nextHeight = prevHeight + height;
          if (nextHeight <= limitHeight && ifSatisfied(row2, function(r) {
            return r < gridRow;
          })) {
            _c2 = __read([prevWidth, prevHeight, width], 3), x3 = _c2[0], y3 = _c2[1], prevWidth = _c2[2];
            return { width, height, x: x3, y: y3, page, index: index4, pageIndex: pageIndex++, row: row2, col: col++ };
          }
          _d2 = __read([0, 0, width, 0, page + 1, 0, 0, 0], 8), x3 = _d2[0], y3 = _d2[1], prevWidth = _d2[2], prevHeight = _d2[3], page = _d2[4], pageIndex = _d2[5], row2 = _d2[6], col = _d2[7];
          return { width, height, x: x3, y: y3, page, index: index4, pageIndex: pageIndex++, row: row2, col: col++ };
        });
      };
      Object.defineProperty(CategoryItems2.prototype, "itemsLayout", {
        get: function() {
          this.navigatorShape = [0, 0];
          var cb = this.attributes.layout === "grid" ? this.getGridLayout : this.getFlexLayout;
          var layout = cb.call(this);
          if (layout.slice(-1)[0].page > 0) {
            this.navigatorShape = [55, 0];
            return cb.call(this);
          }
          return layout;
        },
        enumerable: false,
        configurable: true
      });
      CategoryItems2.prototype.ifHorizontal = function(a3, b) {
        var orientation = this.attributes.orientation;
        return ifHorizontal(orientation, a3, b);
      };
      CategoryItems2.prototype.flattenPage = function(container) {
        container.querySelectorAll(CLASS_NAMES8.item.class).forEach(function(item) {
          container.appendChild(item);
        });
        container.querySelectorAll(CLASS_NAMES8.page.class).forEach(function(page) {
          var removedPage = container.removeChild(page);
          removedPage.destroy();
        });
      };
      CategoryItems2.prototype.renderItems = function(container) {
        var _a = this.attributes, click = _a.click, mouseenter = _a.mouseenter, mouseleave = _a.mouseleave;
        this.flattenPage(container);
        var dispatchCustomEvent = this.dispatchCustomEvent.bind(this);
        select2(container).selectAll(CLASS_NAMES8.item.class).data(this.renderData, function(d3) {
          return d3.id;
        }).join(function(enter) {
          return enter.append(function(_a2) {
            var style = _a2.style;
            return new CategoryItem({ style });
          }).attr("className", CLASS_NAMES8.item.name).on("click", function() {
            click === null || click === void 0 ? void 0 : click(this);
            dispatchCustomEvent("itemClick", { item: this });
          }).on("pointerenter", function() {
            mouseenter === null || mouseenter === void 0 ? void 0 : mouseenter(this);
            dispatchCustomEvent("itemMouseenter", { item: this });
          }).on("pointerleave", function() {
            mouseleave === null || mouseleave === void 0 ? void 0 : mouseleave(this);
            dispatchCustomEvent("itemMouseleave", { item: this });
          });
        }, function(update) {
          return update.each(function(_a2) {
            var style = _a2.style;
            this.update(style);
          });
        }, function(exit) {
          return exit.remove();
        });
      };
      CategoryItems2.prototype.relayoutNavigator = function() {
        var _a;
        var _b = this.attributes, layout = _b.layout, width = _b.width;
        var height = ((_a = this.pageViews.children[0]) === null || _a === void 0 ? void 0 : _a.getBBox().height) || 0;
        var _c = __read(this.navigatorShape, 2), navWidth = _c[0], navHeight = _c[1];
        this.navigator.update(layout === "grid" ? { pageWidth: width - navWidth, pageHeight: height - navHeight } : {});
      };
      CategoryItems2.prototype.adjustLayout = function() {
        var _this = this;
        var itemsLayouts = Object.entries(groupBy(this.itemsLayout, "page")).map(function(_a) {
          var _b = __read(_a, 2), page = _b[0], layouts = _b[1];
          return {
            page,
            layouts
          };
        });
        var categoryItems = __spreadArray([], __read(this.navigator.getContainer().children), false);
        itemsLayouts.forEach(function(_a) {
          var layouts = _a.layouts;
          var page = _this.pageViews.appendChild(new Group2({ className: CLASS_NAMES8.page.name }));
          layouts.forEach(function(layout) {
            var x3 = layout.x, y3 = layout.y, index4 = layout.index, width = layout.width, height = layout.height;
            var item = categoryItems[index4];
            page.appendChild(item);
            set_default(item, "__layout__", layout);
            item.update({ x: x3, y: y3, width, height });
          });
        });
        this.relayoutNavigator();
      };
      CategoryItems2.prototype.renderNavigator = function(container) {
        var orientation = this.attributes.orientation;
        var navStyle = subStyleProps(this.attributes, "nav");
        var style = deepAssign2({ orientation }, navStyle);
        var that = this;
        container.selectAll(CLASS_NAMES8.navigator.class).data(["nav"]).join(function(enter) {
          return enter.append(function() {
            return new Navigator2({ style });
          }).attr("className", CLASS_NAMES8.navigator.name).each(function() {
            that.navigator = this;
          });
        }, function(update) {
          return update.each(function() {
            this.update(style);
          });
        }, function(exit) {
          return exit.remove();
        });
        return this.navigator;
      };
      CategoryItems2.prototype.getBBox = function() {
        return this.navigator.getBBox();
      };
      CategoryItems2.prototype.render = function(attributes, container) {
        var data2 = this.attributes.data;
        if (!data2 || data2.length === 0)
          return;
        var navigator2 = this.renderNavigator(select2(container));
        this.renderItems(navigator2.getContainer());
        this.adjustLayout();
      };
      CategoryItems2.prototype.dispatchCustomEvent = function(type, payload) {
        var evt = new CustomEvent2(type, {
          detail: payload
        });
        this.dispatchEvent(evt);
      };
      return CategoryItems2;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/legend/continuous/handle.js
  var CLASS_NAMES9 = classNames({
    markerGroup: "marker-group",
    marker: "marker",
    labelGroup: "label-group",
    label: "label"
  }, "handle");
  var DEFAULT_HANDLE_CFG = {
    showLabel: true,
    formatter: function(val) {
      return val.toString();
    },
    markerSize: 25,
    markerStroke: "#c5c5c5",
    markerFill: "#fff",
    markerLineWidth: 1,
    labelFontSize: 12,
    labelFill: "#c5c5c5",
    labelText: "",
    orientation: "vertical",
    spacing: 0
  };
  var Handle2 = (
    /** @class */
    function(_super) {
      __extends(Handle3, _super);
      function Handle3(options) {
        return _super.call(this, options, DEFAULT_HANDLE_CFG) || this;
      }
      Handle3.prototype.render = function(attributes, container) {
        var markerGroup = select2(container).maybeAppendByClassName(CLASS_NAMES9.markerGroup, "g");
        this.renderMarker(markerGroup);
        var labelGroup = select2(container).maybeAppendByClassName(CLASS_NAMES9.labelGroup, "g");
        this.renderLabel(labelGroup);
      };
      Handle3.prototype.renderMarker = function(container) {
        var _this = this;
        var _a = this.attributes, orientation = _a.orientation, _b = _a.markerSymbol, markerSymbol = _b === void 0 ? ifHorizontal(orientation, "horizontalHandle", "verticalHandle") : _b;
        ifShow(!!markerSymbol, container, function(group3) {
          var handleStyle = subStyleProps(_this.attributes, "marker");
          var markerStyle = __assign({ symbol: markerSymbol }, handleStyle);
          _this.marker = group3.maybeAppendByClassName(CLASS_NAMES9.marker, function() {
            return new Marker({ style: markerStyle });
          }).update(markerStyle);
        });
      };
      Handle3.prototype.renderLabel = function(container) {
        var _this = this;
        var _a = this.attributes, showLabel = _a.showLabel, orientation = _a.orientation, _b = _a.spacing, spacing = _b === void 0 ? 0 : _b, formatter2 = _a.formatter;
        ifShow(showLabel, container, function(group3) {
          var _a2;
          var _b2 = subStyleProps(_this.attributes, "label"), text = _b2.text, labelStyle = __rest(_b2, ["text"]);
          var _c = ((_a2 = group3.select(CLASS_NAMES9.marker.class)) === null || _a2 === void 0 ? void 0 : _a2.node().getBBox()) || {}, _d = _c.width, width = _d === void 0 ? 0 : _d, _e = _c.height, height = _e === void 0 ? 0 : _e;
          var _f = __read(ifHorizontal(orientation, [0, height + spacing, "center", "top"], [width + spacing, 0, "start", "middle"]), 4), x3 = _f[0], y3 = _f[1], textAlign = _f[2], textBaseline = _f[3];
          group3.maybeAppendByClassName(CLASS_NAMES9.label, "text").styles(__assign(__assign({}, labelStyle), { x: x3, y: y3, text: formatter2(text).toString(), textAlign, textBaseline }));
        });
      };
      return Handle3;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/legend/constant.js
  var LEGEND_BASE_DEFAULT_OPTIONS = {
    showTitle: true,
    padding: 0,
    orientation: "horizontal",
    backgroundFill: "transparent",
    titleText: "",
    titleSpacing: 4,
    titlePosition: "top-left",
    titleFill: "#2C3542",
    titleFontWeight: "bold",
    titleFontFamily: "sans-serif",
    titleFontSize: 12
  };
  var CATEGORY_DEFAULT_OPTIONS = deepAssign2({}, LEGEND_BASE_DEFAULT_OPTIONS, {});
  var CONTINUOUS_DEFAULT_OPTIONS = deepAssign2({}, LEGEND_BASE_DEFAULT_OPTIONS, superStyleProps(DEFAULT_HANDLE_CFG, "handle"), {
    color: [
      "#d0e3fa",
      "#acc7f6",
      "#8daaf2",
      "#6d8eea",
      "#4d73cd",
      "#325bb1",
      "#5a3e75",
      "#8c3c79",
      "#e23455",
      "#e7655b"
    ],
    indicatorBackgroundFill: "#262626",
    indicatorLabelFill: "white",
    indicatorLabelFontSize: 12,
    indicatorVisibility: "hidden",
    labelAlign: "value",
    labelDirection: "positive",
    labelSpacing: 5,
    showHandle: true,
    showIndicator: true,
    showLabel: true,
    slidable: true,
    titleText: "",
    type: "continuous"
  });
  var STEP_RATIO = 0.01;
  var CLASS_NAMES10 = classNames({
    title: "title",
    titleGroup: "title-group",
    items: "items",
    itemsGroup: "items-group",
    contentGroup: "content-group",
    ribbonGroup: "ribbon-group",
    ribbon: "ribbon",
    handlesGroup: "handles-group",
    handle: "handle",
    startHandle: "start-handle",
    endHandle: "end-handle",
    labelGroup: "label-group",
    label: "label",
    indicator: "indicator"
  }, "legend");

  // node_modules/@antv/component/esm/ui/legend/category.js
  var Category = (
    /** @class */
    function(_super) {
      __extends(Category2, _super);
      function Category2(options) {
        return _super.call(this, options, CATEGORY_DEFAULT_OPTIONS) || this;
      }
      Category2.prototype.renderTitle = function(container, width, height) {
        var _a = this.attributes, showTitle = _a.showTitle, titleText = _a.titleText;
        var style = subStyleProps(this.attributes, "title");
        var _b = __read(splitStyle(style), 2), titleStyle = _b[0], groupStyle = _b[1];
        this.titleGroup = container.maybeAppendByClassName(CLASS_NAMES10.titleGroup, "g").styles(groupStyle);
        var finalTitleStyle = __assign(__assign({ width, height }, titleStyle), { text: showTitle ? titleText : "" });
        this.title = this.titleGroup.maybeAppendByClassName(CLASS_NAMES10.title, function() {
          return new Title({ style: finalTitleStyle });
        }).update(finalTitleStyle);
      };
      Category2.prototype.renderItems = function(container, bbox) {
        var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
        var style = subStyleProps(this.attributes, "title", true);
        var _a = __read(splitStyle(style), 2), partialItemStyle = _a[0], groupStyle = _a[1];
        var itemStyle = __assign(__assign({}, partialItemStyle), { width, height, x: 0, y: 0 });
        this.itemsGroup = container.maybeAppendByClassName(CLASS_NAMES10.itemsGroup, "g").styles(__assign(__assign({}, groupStyle), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }));
        var that = this;
        this.itemsGroup.selectAll(CLASS_NAMES10.items.class).data(["items"]).join(function(enter) {
          return enter.append(function() {
            return new CategoryItems({ style: itemStyle });
          }).attr("className", CLASS_NAMES10.items.name).each(function() {
            that.items = select2(this);
          });
        }, function(update) {
          return update.update(itemStyle);
        }, function(exit) {
          return exit.remove();
        });
      };
      Category2.prototype.adjustLayout = function() {
        var showTitle = this.attributes.showTitle;
        if (showTitle) {
          var _a = this.title.node().getAvailableSpace(), x3 = _a.x, y3 = _a.y;
          this.itemsGroup.node().style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        }
      };
      Object.defineProperty(Category2.prototype, "availableSpace", {
        get: function() {
          var _a = this.attributes, showTitle = _a.showTitle, width = _a.width, height = _a.height;
          if (!showTitle)
            return new BBox(0, 0, width, height);
          return this.title.node().getAvailableSpace();
        },
        enumerable: false,
        configurable: true
      });
      Category2.prototype.getBBox = function() {
        var _a, _b;
        var title = (_a = this.title) === null || _a === void 0 ? void 0 : _a.node();
        var items = (_b = this.items) === null || _b === void 0 ? void 0 : _b.node();
        if (!title || !items)
          return _super.prototype.getBBox.call(this);
        return getBBox(title, items);
      };
      Category2.prototype.render = function(attributes, container) {
        var _a = this.attributes, width = _a.width, height = _a.height, _b = _a.x, x3 = _b === void 0 ? 0 : _b, _c = _a.y, y3 = _c === void 0 ? 0 : _c;
        var ctn = select2(container);
        container.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        this.renderTitle(ctn, width, height);
        this.renderItems(ctn, this.availableSpace);
        this.adjustLayout();
      };
      return Category2;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/indicator/constant.js
  var DEFAULT_INDICATOR_STYLE_PROPS = {
    backgroundFill: "#262626",
    backgroundLineCap: "round",
    backgroundLineWidth: 1,
    backgroundStroke: "#333",
    backgroundZIndex: -1,
    formatter: function(val) {
      return val.toString();
    },
    labelFill: "#fff",
    labelFontSize: 12,
    labelTextBaseline: "middle",
    padding: [2, 4],
    position: "right",
    radius: 0,
    zIndex: 999
  };

  // node_modules/@antv/component/esm/ui/indicator/indicator.js
  var CLASS_NAMES11 = classNames({
    background: "background",
    labelGroup: "label-group",
    label: "label"
  }, "indicator");
  var Indicator = (
    /** @class */
    function(_super) {
      __extends(Indicator2, _super);
      function Indicator2(options) {
        var _this = _super.call(this, options, DEFAULT_INDICATOR_STYLE_PROPS) || this;
        _this.point = [0, 0];
        _this.group = _this.appendChild(new Group2({}));
        _this.isMutationObserved = true;
        return _this;
      }
      Indicator2.prototype.renderBackground = function() {
        if (!this.label)
          return;
        var _a = this.attributes, position = _a.position, padding = _a.padding;
        var _b = __read(parseSeriesAttr(padding), 4), t = _b[0], r = _b[1], b = _b[2], l2 = _b[3];
        var _c = this.label.node().getLocalBounds(), min10 = _c.min, max11 = _c.max;
        var bbox = new BBox(min10[0] - l2, min10[1] - t, max11[0] + r - min10[0] + l2, max11[1] + b - min10[1] + t);
        var path2 = this.getPath(position, bbox);
        var style = subStyleProps(this.attributes, "background");
        this.background = select2(this.group).maybeAppendByClassName(CLASS_NAMES11.background, "path").styles(__assign(__assign({}, style), { d: path2 }));
        this.group.appendChild(this.label.node());
      };
      Indicator2.prototype.renderLabel = function() {
        var _a = this.attributes, formatter2 = _a.formatter, labelText = _a.labelText;
        var style = subStyleProps(this.attributes, "label");
        var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1], rawText = _c.text, textStyle = __rest(_c, ["text"]);
        this.label = select2(this.group).maybeAppendByClassName(CLASS_NAMES11.labelGroup, "g").styles(groupStyle);
        if (!labelText)
          return;
        var text = this.label.maybeAppendByClassName(CLASS_NAMES11.label, function() {
          return renderExtDo(formatter2(labelText));
        }).style("text", formatter2(labelText).toString());
        text.selectAll("text").styles(textStyle);
      };
      Indicator2.prototype.adjustLayout = function() {
        var _a = __read(this.point, 2), dx = _a[0], dy = _a[1];
        var _b = this.attributes, x3 = _b.x, y3 = _b.y;
        this.group.attr("transform", "translate(".concat(x3 - dx, ", ").concat(y3 - dy, ")"));
      };
      Indicator2.prototype.getPath = function(position, bbox) {
        var r = this.attributes.radius;
        var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
        var pathArray = [
          // 0 开始路径
          ["M", x3 + r, y3],
          // 1 上边线
          ["L", x3 + width - r, y3],
          // 2 右上角圆弧
          ["A", r, r, 0, 0, 1, x3 + width, y3 + r],
          // 3 右边线
          ["L", x3 + width, y3 + height - r],
          // 4 右下角圆弧
          ["A", r, r, 0, 0, 1, x3 + width - r, y3 + height],
          // 5 下边线
          ["L", x3 + r, y3 + height],
          // 6 左下角圆弧
          ["A", r, r, 0, 0, 1, x3, y3 + height - r],
          // 7 左边线
          ["L", x3, y3 + r],
          // 8 左上角圆弧
          ["A", r, r, 0, 0, 1, x3 + r, y3],
          // 9 关闭路径
          ["Z"]
        ];
        var revertPositionMap = { top: 4, right: 6, bottom: 0, left: 2 };
        var index4 = revertPositionMap[position];
        var newPath = this.createCorner([pathArray[index4].slice(-2), pathArray[index4 + 1].slice(-2)]);
        pathArray.splice.apply(pathArray, __spreadArray([index4 + 1, 1], __read(newPath), false));
        pathArray[0][0] = "M";
        return pathArray;
      };
      Indicator2.prototype.createCorner = function(edge, size2) {
        if (size2 === void 0) {
          size2 = 10;
        }
        var cornerScale = 0.8;
        var isH = isHorizontal.apply(void 0, __spreadArray([], __read(edge), false));
        var _a = __read(edge, 2), _b = __read(_a[0], 2), x05 = _b[0], y05 = _b[1], _c = __read(_a[1], 2), x12 = _c[0], y12 = _c[1];
        var _d = __read(isH ? [x12 - x05, [x05, x12]] : [y12 - y05, [y05, y12]], 2), len5 = _d[0], _e = __read(_d[1], 2), b0 = _e[0], b1 = _e[1];
        var hL = len5 / 2;
        var sign3 = len5 / Math.abs(len5);
        var cL = size2 * sign3;
        var hCL = cL / 2;
        var cS = cL * Math.sqrt(3) / 2 * cornerScale;
        var _f = __read([b0, b0 + hL - hCL, b0 + hL, b0 + hL + hCL, b1], 5), a0 = _f[0], a1 = _f[1], a22 = _f[2], a3 = _f[3], a4 = _f[4];
        if (isH) {
          this.point = [a22, y05 - cS];
          return [
            ["L", a0, y05],
            ["L", a1, y05],
            ["L", a22, y05 - cS],
            ["L", a3, y05],
            ["L", a4, y05]
          ];
        }
        this.point = [x05 + cS, a22];
        return [
          ["L", x05, a0],
          ["L", x05, a1],
          ["L", x05 + cS, a22],
          ["L", x05, a3],
          ["L", x05, a4]
        ];
      };
      Indicator2.prototype.applyVisibility = function() {
        var visibility2 = this.attributes.visibility;
        if (visibility2 === "hidden")
          hide(this);
        else
          show(this);
      };
      Indicator2.prototype.bindEvents = function() {
        this.label.on(ElementEvent.BOUNDS_CHANGED, this.renderBackground);
      };
      Indicator2.prototype.render = function() {
        this.renderLabel();
        this.renderBackground();
        this.adjustLayout();
        this.applyVisibility();
      };
      return Indicator2;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/legend/continuous/utils.js
  function search(array2, value2) {
    for (var i = 1; i < array2.length; i += 1) {
      var st = array2[i - 1];
      var end = array2[i];
      if (value2 >= st && value2 <= end) {
        return [st, end];
      }
    }
    return [value2, value2];
  }
  function getBlockColor(partition, color2, orientation) {
    var colors = Array.from(color2);
    var count4 = partition.length;
    return new Array(count4).fill(0).reduce(function(r, v, idx) {
      var c5 = colors[idx % colors.length];
      return r += " ".concat(partition[idx], ":").concat(c5).concat(idx < count4 - 1 ? " ".concat(partition[idx + 1], ":").concat(c5) : "");
    }, "l(".concat(orientation === "horizontal" ? "0" : "270", ")"));
  }
  function getNextTickValue(ticks2, value2) {
    var _a = __read(search(ticks2, value2), 2), v1 = _a[0], v2 = _a[1];
    return { tick: value2 > (v1 + v2) / 2 ? v2 : v1, range: [v1, v2] };
  }

  // node_modules/@antv/component/esm/ui/legend/continuous/ribbon.js
  var CLASS_NAMES12 = classNames({
    trackGroup: "background-group",
    track: "background",
    selectionGroup: "ribbon-group",
    selection: "ribbon",
    clipPath: "clip-path"
  }, "ribbon");
  function getShape(attr2) {
    var orientation = attr2.orientation, size2 = attr2.size, length5 = attr2.length;
    return ifHorizontal(orientation, [length5, size2], [size2, length5]);
  }
  function getTrackPath(attr2) {
    var type = attr2.type;
    var _a = __read(getShape(attr2), 2), cw2 = _a[0], ch2 = _a[1];
    if (type === "size") {
      return [["M", 0, ch2], ["L", 0 + cw2, 0], ["L", 0 + cw2, ch2], ["Z"]];
    }
    return [["M", 0, ch2], ["L", 0, 0], ["L", 0 + cw2, 0], ["L", 0 + cw2, ch2], ["Z"]];
  }
  function getSelectionPath(attr2) {
    return getTrackPath(attr2);
  }
  function getColor(attr2) {
    var orientation = attr2.orientation, color2 = attr2.color, block = attr2.block, partition = attr2.partition;
    var colors;
    if (isFunction(color2)) {
      var len5 = 20;
      colors = new Array(len5).fill(0).map(function(_2, index4, arr) {
        return color2(index4 / (arr.length - 1));
      });
    } else
      colors = color2;
    var count4 = colors.length;
    var genericColor = colors.map(function(c5) {
      return parseColor(c5).toString();
    });
    if (!count4)
      return "";
    if (count4 === 1)
      return genericColor[0];
    if (block)
      return getBlockColor(partition, genericColor, orientation);
    return genericColor.reduce(function(r, c5, idx) {
      return r += " ".concat(idx / (count4 - 1), ":").concat(c5);
    }, "l(".concat(ifHorizontal(orientation, "0", "270"), ")"));
  }
  function getClipPath(attr2) {
    var orientation = attr2.orientation, range3 = attr2.range;
    if (!range3)
      return [];
    var _a = __read(getShape(attr2), 2), width = _a[0], height = _a[1];
    var _b = __read(range3, 2), st = _b[0], et = _b[1];
    var x3 = ifHorizontal(orientation, st * width, 0);
    var y3 = ifHorizontal(orientation, 0, st * height);
    var w = ifHorizontal(orientation, et * width, width);
    var h = ifHorizontal(orientation, height, et * height);
    return [["M", x3, y3], ["L", x3, h], ["L", w, h], ["L", w, y3], ["Z"]];
  }
  function renderTrack(container, attr2) {
    var style = subStyleProps(attr2, "track");
    container.maybeAppendByClassName(CLASS_NAMES12.track, "path").styles(__assign({ d: getTrackPath(attr2) }, style));
  }
  function renderSelection(container, attr2) {
    var style = subStyleProps(attr2, "selection");
    var fill = getColor(attr2);
    var ribbon = container.maybeAppendByClassName(CLASS_NAMES12.selection, "path").styles(__assign({ d: getSelectionPath(attr2), fill }, style));
    var clipPath = ribbon.maybeAppendByClassName(CLASS_NAMES12.clipPath, "path").styles({ d: getClipPath(attr2) }).node();
    ribbon.style("clipPath", clipPath);
  }
  var Ribbon = (
    /** @class */
    function(_super) {
      __extends(Ribbon3, _super);
      function Ribbon3(options) {
        return _super.call(this, options, {
          type: "color",
          orientation: "horizontal",
          size: 30,
          range: [0, 1],
          length: 200,
          block: false,
          partition: [],
          color: ["#fff", "#000"],
          trackFill: "#e5e5e5"
        }) || this;
      }
      Ribbon3.prototype.render = function(attribute, container) {
        var trackGroup = select2(container).maybeAppendByClassName(CLASS_NAMES12.trackGroup, "g");
        renderTrack(trackGroup, attribute);
        var ribbonGroup = select2(container).maybeAppendByClassName(CLASS_NAMES12.selectionGroup, "g");
        renderSelection(ribbonGroup, attribute);
      };
      return Ribbon3;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/legend/continuous.js
  function getMinMax(data2) {
    return {
      min: Math.min.apply(Math, __spreadArray([], __read(data2.map(function(d3) {
        return d3.value;
      })), false)),
      max: Math.max.apply(Math, __spreadArray([], __read(data2.map(function(d3) {
        return d3.value;
      })), false))
    };
  }
  var Continuous2 = (
    /** @class */
    function(_super) {
      __extends(Continuous3, _super);
      function Continuous3(options) {
        var _this = _super.call(this, options, CONTINUOUS_DEFAULT_OPTIONS) || this;
        _this.eventToOffsetScale = new Linear({});
        _this.innerRibbonScale = new Linear({});
        _this.cacheLabelBBox = null;
        _this.cacheHandleBBox = null;
        _this.onHovering = function(e3) {
          var _a = _this.attributes, data2 = _a.data, block = _a.block;
          e3.stopPropagation();
          var value2 = _this.getValueByCanvasPoint(e3);
          if (block) {
            var range3 = getNextTickValue(data2.map(function(_a2) {
              var value3 = _a2.value;
              return value3;
            }), value2).range;
            var selection = _this.getRealSelection(range3);
            _this.showIndicator((range3[0] + range3[1]) / 2, "".concat(selection[0], "-").concat(selection[1]));
            _this.dispatchIndicated(value2, range3);
          } else {
            var safetyValue = _this.getTickValue(value2);
            _this.showIndicator(safetyValue, "".concat(_this.getRealValue(safetyValue)));
            _this.dispatchIndicated(safetyValue);
          }
        };
        _this.onDragStart = function(target) {
          return function(e3) {
            e3.stopPropagation();
            if (!_this.attributes.slidable)
              return;
            _this.target = target;
            _this.prevValue = _this.getTickValue(_this.getValueByCanvasPoint(e3));
            document.addEventListener("mousemove", _this.onDragging);
            document.addEventListener("touchmove", _this.onDragging);
            document.addEventListener("mouseleave", _this.onDragEnd);
            document.addEventListener("mouseup", _this.onDragEnd);
            document.addEventListener("mouseup", _this.onDragEnd);
            document.addEventListener("touchend", _this.onDragEnd);
          };
        };
        _this.onDragging = function(e3) {
          var target = _this.target;
          _this.updateMouse();
          var _a = __read(_this.selection, 2), start2 = _a[0], end = _a[1];
          var currValue = _this.getTickValue(_this.getValueByCanvasPoint(e3));
          var diffValue = currValue - _this.prevValue;
          if (target === "start")
            start2 !== currValue && _this.updateSelection(currValue, end);
          else if (target === "end")
            end !== currValue && _this.updateSelection(start2, currValue);
          else if (target === "ribbon" && diffValue !== 0) {
            _this.prevValue = currValue;
            _this.updateSelection(diffValue, diffValue, true);
          }
        };
        _this.onDragEnd = function() {
          _this.style.cursor = "pointer";
          document.removeEventListener("mousemove", _this.onDragging);
          document.removeEventListener("touchmove", _this.onDragging);
          document.removeEventListener("mouseup", _this.onDragEnd);
          document.removeEventListener("touchend", _this.onDragEnd);
        };
        return _this;
      }
      Object.defineProperty(Continuous3.prototype, "handleOffsetRatio", {
        get: function() {
          return this.ifHorizontal(0.5, 0.5);
        },
        enumerable: false,
        configurable: true
      });
      Continuous3.prototype.getBBox = function() {
        var _a = this.attributes, width = _a.width, height = _a.height;
        return new BBox(0, 0, width, height);
      };
      Continuous3.prototype.render = function(attributes, container) {
        var _this = this;
        var showLabel = attributes.showLabel;
        this.renderTitle(select2(container));
        var _a = this.availableSpace, x3 = _a.x, y3 = _a.y;
        var contentGroup = select2(container).maybeAppendByClassName(CLASS_NAMES10.contentGroup, "g").styles({ transform: "translate(".concat(x3, ", ").concat(y3, ")") });
        var labelGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.labelGroup, "g").styles({ zIndex: 1 });
        ifShow(!!showLabel, labelGroup, function(group3) {
          _this.renderLabel(group3);
        });
        var ribbonGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.ribbonGroup, "g").styles({ zIndex: 0 });
        this.handlesGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.handlesGroup, "g").styles({ zIndex: 2 });
        this.renderHandles();
        this.renderRibbon(ribbonGroup);
        this.renderIndicator(contentGroup);
        this.adjustLabel();
        this.adjustHandles();
      };
      Object.defineProperty(Continuous3.prototype, "range", {
        get: function() {
          var _a = this.attributes, data2 = _a.data, domain = _a.domain;
          return domain ? { min: domain[0], max: domain[1] } : getMinMax(data2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous3.prototype, "ribbonScale", {
        get: function() {
          var _a = this.range, min10 = _a.min, max11 = _a.max;
          this.innerRibbonScale.update({
            domain: [min10, max11],
            range: [0, 1]
          });
          return this.innerRibbonScale;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous3.prototype, "ribbonRange", {
        get: function() {
          var _a = __read(this.selection, 2), min10 = _a[0], max11 = _a[1];
          var scale10 = this.ribbonScale;
          return [scale10.map(min10), scale10.map(max11)];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous3.prototype, "selection", {
        get: function() {
          var _a = this.range, min10 = _a.min, max11 = _a.max;
          var _b = this.attributes.defaultValue, _c = _b === void 0 ? [min10, max11] : _b, _d = __read(_c, 2), start2 = _d[0], end = _d[1];
          return [start2, end];
        },
        enumerable: false,
        configurable: true
      });
      Continuous3.prototype.ifHorizontal = function(a3, b) {
        return ifHorizontal(this.attributes.orientation, typeof a3 === "function" ? a3() : a3, typeof b === "function" ? b() : b);
      };
      Continuous3.prototype.renderTitle = function(container) {
        var _a = this.attributes, showTitle = _a.showTitle, titleText = _a.titleText, width = _a.width, height = _a.height;
        var style = subStyleProps(this.attributes, "title");
        var finalTitleStyle = __assign(__assign({}, style), { width, height, text: titleText });
        var that = this;
        container.selectAll(CLASS_NAMES10.title.class).data(showTitle ? [titleText] : []).join(function(enter) {
          return enter.append(function() {
            return new Title({ style: finalTitleStyle });
          }).attr("className", CLASS_NAMES10.title.name).each(function() {
            that.title = this;
          });
        }, function(update) {
          return update.update(finalTitleStyle);
        }, function(exit) {
          return exit.each(function() {
            that.title = void 0;
          }).remove();
        });
      };
      Object.defineProperty(Continuous3.prototype, "availableSpace", {
        get: function() {
          if (this.title)
            return this.title.getAvailableSpace();
          var _a = this.attributes, width = _a.width, height = _a.height;
          return new BBox(0, 0, width, height);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous3.prototype, "labelFixedSpacing", {
        get: function() {
          var showTick = this.attributes.showTick;
          return showTick ? 5 : 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous3.prototype, "labelPosition", {
        get: function() {
          var _a = this.attributes, orientation = _a.orientation, labelDirection = _a.labelDirection;
          var positions = {
            vertical: { positive: "right", negative: "left" },
            horizontal: { positive: "bottom", negative: "top" }
          };
          return positions[orientation][labelDirection];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous3.prototype, "labelBBox", {
        get: function() {
          var _a;
          var showLabel = this.attributes.showLabel;
          if (!showLabel)
            return new BBox(0, 0, 0, 0);
          if (this.cacheLabelBBox)
            return this.cacheLabelBBox;
          var _b = ((_a = this.label.querySelector(CLASS_NAMES3.labelGroup.class)) === null || _a === void 0 ? void 0 : _a.children.slice(-1)[0]).getBBox(), width = _b.width, height = _b.height;
          this.cacheLabelBBox = new BBox(0, 0, width, height);
          return this.cacheLabelBBox;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous3.prototype, "labelShape", {
        get: function() {
          var _a = this.attributes, showLabel = _a.showLabel, _b = _a.labelSpacing, labelSpacing = _b === void 0 ? 0 : _b;
          if (!showLabel)
            return { width: 0, height: 0, size: 0, length: 0 };
          var _c = this.labelBBox, width = _c.width, height = _c.height;
          var size2 = this.ifHorizontal(height, width) + labelSpacing + this.labelFixedSpacing;
          var length5 = this.ifHorizontal(width, height);
          return { width, height, size: size2, length: length5 };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous3.prototype, "ribbonBBox", {
        get: function() {
          var _a = this.attributes, showHandle = _a.showHandle, userDefinedRibbonSize = _a.ribbonSize;
          var _b = this.availableSpace, availableWidth = _b.width, availableHeight = _b.height;
          var _c = this.labelShape, labelSize = _c.size, labelLength = _c.length;
          var _d = __read(this.ifHorizontal([availableHeight, availableWidth], [availableWidth, availableHeight]), 2), availableSize = _d[0], availableLength = _d[1];
          var _e = showHandle ? this.handleShape : { size: 0, length: 0 }, handleSize = _e.size, handleLength = _e.length;
          var handleRatio = this.handleOffsetRatio;
          var ribbonSize = 0;
          var labelPosition = this.labelPosition;
          if (userDefinedRibbonSize) {
            ribbonSize = userDefinedRibbonSize;
          } else if (["bottom", "right"].includes(labelPosition)) {
            ribbonSize = Math.min(availableSize - labelSize, (availableSize - handleSize) / handleRatio);
          } else if (availableSize * (1 - handleRatio) > handleSize) {
            ribbonSize = Math.max(availableSize - labelSize, 0);
          } else
            ribbonSize = Math.max((availableSize - labelSize - handleSize) / handleRatio, 0);
          var edgeLength = Math.max(handleLength, labelLength);
          var ribbonLength = availableLength - edgeLength;
          var _f = __read(this.ifHorizontal([ribbonLength, ribbonSize], [ribbonSize, ribbonLength]), 2), width = _f[0], height = _f[1];
          var finalLabelOccupy = ["top", "left"].includes(labelPosition) ? labelSize : 0;
          var _g = __read(this.ifHorizontal([edgeLength / 2, finalLabelOccupy], [finalLabelOccupy, edgeLength / 2]), 2), x3 = _g[0], y3 = _g[1];
          return new BBox(x3, y3, width, height);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous3.prototype, "ribbonShape", {
        get: function() {
          var _a = this.ribbonBBox, width = _a.width, height = _a.height;
          return this.ifHorizontal({ size: height, length: width }, { size: width, length: height });
        },
        enumerable: false,
        configurable: true
      });
      Continuous3.prototype.renderRibbon = function(container) {
        var _a = this.attributes, data2 = _a.data, type = _a.type, orientation = _a.orientation, color2 = _a.color, block = _a.block;
        var ribbonStyle = subStyleProps(this.attributes, "ribbon");
        var _b = this.range, min10 = _b.min, max11 = _b.max;
        var _c = this.ribbonBBox, x3 = _c.x, y3 = _c.y;
        var _d = this.ribbonShape, length5 = _d.length, size2 = _d.size;
        var style = deepAssign2({
          transform: "translate(".concat(x3, ", ").concat(y3, ")"),
          length: length5,
          size: size2,
          type,
          orientation,
          color: color2,
          block,
          partition: data2.map(function(d3) {
            return (d3.value - min10) / (max11 - min10);
          }),
          range: this.ribbonRange
        }, ribbonStyle);
        this.ribbon = container.maybeAppendByClassName(CLASS_NAMES10.ribbon, function() {
          return new Ribbon({ style });
        }).update(style);
      };
      Continuous3.prototype.getHandleClassName = function(type) {
        return "".concat(CLASS_NAMES10.prefix("".concat(type, "-handle")));
      };
      Continuous3.prototype.renderHandles = function() {
        var _a = this.attributes, showHandle = _a.showHandle, orientation = _a.orientation;
        var handleStyle = subStyleProps(this.attributes, "handle");
        var _b = __read(this.selection, 2), min10 = _b[0], max11 = _b[1];
        var style = __assign(__assign({}, handleStyle), { orientation });
        var _c = handleStyle.shape, shape23 = _c === void 0 ? "slider" : _c;
        var HandleCtor = shape23 === "basic" ? Handle2 : Handle;
        var that = this;
        this.handlesGroup.selectAll(CLASS_NAMES10.handle.class).data(showHandle ? [
          { value: min10, type: "start" },
          { value: max11, type: "end" }
        ] : [], function(d3) {
          return d3.type;
        }).join(function(enter) {
          return enter.append(function() {
            return new HandleCtor({ style });
          }).attr("className", function(_a2) {
            var type = _a2.type;
            return "".concat(CLASS_NAMES10.handle, " ").concat(that.getHandleClassName(type));
          }).each(function(_a2) {
            var type = _a2.type, labelText = _a2.value;
            this.update({ labelText });
            var name2 = "".concat(type, "Handle");
            that[name2] = this;
            this.addEventListener("pointerdown", that.onDragStart(type));
          });
        }, function(update) {
          return update.update(style).each(function(_a2) {
            var labelText = _a2.value;
            this.update({ labelText });
          });
        }, function(exit) {
          return exit.each(function(_a2) {
            var type = _a2.type;
            var name2 = "".concat(type, "Handle");
            that[name2] = void 0;
          }).remove();
        });
      };
      Continuous3.prototype.adjustHandles = function() {
        var _a = __read(this.selection, 2), min10 = _a[0], max11 = _a[1];
        this.setHandlePosition("start", min10);
        this.setHandlePosition("end", max11);
      };
      Object.defineProperty(Continuous3.prototype, "handleBBox", {
        get: function() {
          if (this.cacheHandleBBox)
            return this.cacheHandleBBox;
          if (!this.attributes.showHandle)
            return new BBox(0, 0, 0, 0);
          var _a = this.startHandle.getBBox(), startHandleWidth = _a.width, startHandleHeight = _a.height;
          var _b = this.endHandle.getBBox(), endHandleWidth = _b.width, endHandleHeight = _b.height;
          var _c = __read([Math.max(startHandleWidth, endHandleWidth), Math.max(startHandleHeight, endHandleHeight)], 2), width = _c[0], height = _c[1];
          this.cacheHandleBBox = new BBox(0, 0, width, height);
          return this.cacheHandleBBox;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous3.prototype, "handleShape", {
        /**
         *  因为 handle label 的宽高是动态的，所以 handle bbox 是第一次渲染时的 bbox
         */
        get: function() {
          var _a = this.handleBBox, width = _a.width, height = _a.height;
          var _b = __read(this.ifHorizontal([height, width], [width, height]), 2), size2 = _b[0], length5 = _b[1];
          return { width, height, size: size2, length: length5 };
        },
        enumerable: false,
        configurable: true
      });
      Continuous3.prototype.setHandlePosition = function(type, value2) {
        var handleFormatter = this.attributes.handleFormatter;
        var _a = this.ribbonBBox, ribbonX = _a.x, ribbonY = _a.y;
        var ribbonSize = this.ribbonShape.size;
        var offset3 = this.getOffset(value2);
        var _b = __read(this.ifHorizontal([ribbonX + offset3, ribbonY + ribbonSize * this.handleOffsetRatio], [ribbonX + ribbonSize * this.handleOffsetRatio, ribbonY + offset3]), 2), x3 = _b[0], y3 = _b[1];
        var handle = this.handlesGroup.select(".".concat(this.getHandleClassName(type))).node();
        handle === null || handle === void 0 ? void 0 : handle.update({ transform: "translate(".concat(x3, ", ").concat(y3, ")"), formatter: handleFormatter });
      };
      Continuous3.prototype.renderIndicator = function(container) {
        var style = subStyleProps(this.attributes, "indicator");
        this.indicator = container.maybeAppendByClassName(CLASS_NAMES10.indicator, function() {
          return new Indicator({});
        }).update(style);
      };
      Object.defineProperty(Continuous3.prototype, "labelData", {
        get: function() {
          var _this = this;
          var data2 = this.attributes.data;
          return data2.reduce(function(acc, curr, index4, arr) {
            var _a, _b;
            var id5 = (_a = curr === null || curr === void 0 ? void 0 : curr.id) !== null && _a !== void 0 ? _a : index4.toString();
            acc.push(__assign(__assign({}, curr), { id: id5, index: index4, type: "value", label: (_b = curr === null || curr === void 0 ? void 0 : curr.label) !== null && _b !== void 0 ? _b : curr.value.toString(), value: _this.ribbonScale.map(curr.value) }));
            if (index4 < arr.length - 1) {
              var next = arr[index4 + 1];
              var _c = __read([curr.value, next.value], 2), cr = _c[0], nx = _c[1];
              var midVal = (cr + nx) / 2;
              acc.push(__assign(__assign({}, curr), { id: id5, index: index4, type: "range", range: [cr, nx], label: [cr, nx].join("~"), value: _this.ribbonScale.map(midVal) }));
            }
            return acc;
          }, []);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous3.prototype, "labelStyle", {
        get: function() {
          var _a = __read(["center", "middle"], 2), labelTextAlign = _a[0], labelTextBaseline = _a[1];
          var labelPosition = this.labelPosition;
          if (labelPosition === "top")
            labelTextBaseline = "bottom";
          else if (labelPosition === "bottom")
            labelTextBaseline = "top";
          else if (labelPosition === "left")
            labelTextAlign = "end";
          else if (labelPosition === "right")
            labelTextAlign = "start";
          return {
            labelTextAlign,
            labelTextBaseline
          };
        },
        enumerable: false,
        configurable: true
      });
      Continuous3.prototype.renderLabel = function(container) {
        var _a = this.attributes, _b = _a.showTick, showTick = _b === void 0 ? false : _b, labelFilter = _a.labelFilter, labelFormatter = _a.labelFormatter;
        var tickStyle = subStyleProps(this.attributes, "tick");
        var labelStyle = subStyleProps(this.attributes, "label");
        var align = labelStyle.align;
        var style = deepAssign2(__assign({ showLine: false, showGrid: false, showTick, type: "linear", startPos: [0, 0], endPos: [0, 0], tickDirection: "negative", labelTransform: "rotate(0)" }, this.labelStyle), superStyleProps(tickStyle, "tick"), superStyleProps(labelStyle, "label"), { data: this.labelData });
        var functionStyle = {
          tickFilter: function(datum, index4, data2) {
            if ((datum === null || datum === void 0 ? void 0 : datum.type) !== "value")
              return false;
            if (labelFilter)
              return labelFilter(datum, datum.index, data2.filter(function(d3) {
                return d3.type !== "value";
              }));
            return true;
          },
          labelFilter: function(datum, index4, data2) {
            if ((datum === null || datum === void 0 ? void 0 : datum.type) !== align)
              return false;
            if (labelFilter)
              return labelFilter(datum, datum.index, data2.filter(function(d3) {
                return d3.type === align;
              }));
            return true;
          },
          labelFormatter
        };
        var finalLabelStyle = __assign(__assign(__assign({}, style), functionStyle), { labelOverlap: [{ type: "hide" }] });
        this.label = container.maybeAppendByClassName(CLASS_NAMES10.label, function() {
          return new Axis({ style: finalLabelStyle });
        }).node();
        this.label.update(finalLabelStyle, false);
      };
      Object.defineProperty(Continuous3.prototype, "labelAxisStyle", {
        get: function() {
          var _a = this.attributes, showTick = _a.showTick, labelDirection = _a.labelDirection, labelSpacing = _a.labelSpacing, definedTickLength = _a.tickLength;
          var ribbonSize = this.ribbonShape.size;
          var labelPosition = this.labelPosition;
          var labelFixedSpacing = this.labelFixedSpacing;
          var _b = __read([0, 0, 0], 3), offset3 = _b[0], spacing = _b[1], tickLength = _b[2];
          var internalVal = definedTickLength !== null && definedTickLength !== void 0 ? definedTickLength : ribbonSize;
          if (showTick) {
            tickLength = internalVal;
            spacing = labelFixedSpacing;
            if (labelDirection === "positive") {
              if (labelPosition === "right") {
                offset3 = internalVal;
                tickLength = internalVal;
              } else if (labelPosition === "bottom")
                offset3 = tickLength;
            } else if (labelDirection === "negative") {
              if (labelPosition === "top")
                offset3 = ribbonSize;
              else if (labelPosition === "left")
                offset3 = ribbonSize;
            }
          } else if (labelDirection === "positive") {
            if (labelPosition === "right")
              spacing = internalVal;
            else if (labelPosition === "bottom") {
              offset3 = ribbonSize + labelFixedSpacing;
              spacing = labelSpacing;
            }
          } else if (labelDirection === "negative") {
            if (labelPosition === "left")
              spacing = labelSpacing;
            else if (labelPosition === "top")
              spacing = labelSpacing;
          }
          return { offset: offset3, spacing, tickLength };
        },
        enumerable: false,
        configurable: true
      });
      Continuous3.prototype.adjustLabel = function() {
        var showLabel = this.attributes.showLabel;
        if (!showLabel)
          return;
        var _a = this.ribbonBBox, x3 = _a.x, y3 = _a.y, width = _a.width, height = _a.height;
        var _b = this.labelAxisStyle, axisOffset = _b.offset, axisSpacing = _b.spacing, axisTickLength = _b.tickLength;
        var _c = __read(this.ifHorizontal([
          [x3, y3 + axisOffset],
          [x3 + width, y3 + axisOffset]
        ], [
          [x3 + axisOffset, y3 + height],
          [x3 + axisOffset, y3]
        ]), 2), startPos = _c[0], endPos = _c[1];
        this.label.update({
          startPos,
          endPos,
          tickLength: axisTickLength,
          labelSpacing: axisSpacing
        }, false);
      };
      Continuous3.prototype.bindEvents = function() {
        this.style.cursor = "pointer";
        this.ribbon.on("pointerdown", this.onDragStart("ribbon"));
        this.ribbon.on("pointermove", this.onHovering);
        this.addEventListener("pointerout", this.hideIndicator);
      };
      Continuous3.prototype.showIndicator = function(value2, text) {
        if (text === void 0) {
          text = "".concat(value2);
        }
        var showIndicator = this.attributes.showIndicator;
        if (!showIndicator || typeof value2 !== "number") {
          this.hideIndicator();
          return;
        }
        var _a = this.range, min10 = _a.min, max11 = _a.max;
        var _b = this.ribbonBBox, x3 = _b.x, y3 = _b.y;
        var safeValue = clamp_default(value2, min10, max11);
        var offset3 = this.getOffset(safeValue);
        var pos = this.ifHorizontal([offset3 + x3, y3], [x3, offset3 + y3]);
        this.indicator.update({
          x: pos[0],
          y: pos[1],
          position: this.ifHorizontal("top", "left"),
          labelText: text
        });
        show(this.indicator.node());
      };
      Continuous3.prototype.hideIndicator = function() {
        hide(this.indicator.node());
      };
      Continuous3.prototype.updateMouse = function() {
        if (this.attributes.slidable)
          this.style.cursor = "grabbing";
      };
      Continuous3.prototype.setSelection = function(start2, end) {
        this.updateSelection(start2, end);
      };
      Continuous3.prototype.updateSelection = function(stVal, endVal, isOffset) {
        var _a;
        if (isOffset === void 0) {
          isOffset = false;
        }
        var _b = __read(this.selection, 2), currSt = _b[0], currEnd = _b[1];
        var _c = __read([stVal, endVal], 2), start2 = _c[0], end = _c[1];
        if (isOffset) {
          start2 += currSt;
          end += currEnd;
        }
        var _d = this.range, min10 = _d.min, max11 = _d.max;
        _a = __read(getSafetySelections([min10, max11], [start2, end], this.selection), 2), start2 = _a[0], end = _a[1];
        this.update({ defaultValue: [start2, end] });
        this.dispatchSelection();
      };
      Object.defineProperty(Continuous3.prototype, "step", {
        get: function() {
          var _a = this.attributes.step, step2 = _a === void 0 ? 1 : _a;
          var _b = this.range, min10 = _b.min, max11 = _b.max;
          if (is_undefined_default(step2))
            return toPrecision((max11 - min10) * STEP_RATIO, 0);
          return step2;
        },
        enumerable: false,
        configurable: true
      });
      Continuous3.prototype.getTickValue = function(value2) {
        var _a = this.attributes, data2 = _a.data, block = _a.block;
        var min10 = this.range.min;
        if (block)
          return getNextTickValue(data2.map(function(_a2) {
            var value3 = _a2.value;
            return value3;
          }), value2).tick;
        return getStepValueByValue(value2, this.step, min10);
      };
      Continuous3.prototype.getValueByCanvasPoint = function(e3) {
        var _a = this.range, min10 = _a.min, max11 = _a.max;
        var _b = __read(this.ribbon.node().getPosition(), 2), x3 = _b[0], y3 = _b[1];
        var startPos = this.ifHorizontal(x3, y3);
        var currValue = this.ifHorizontal.apply(this, __spreadArray([], __read(getEventPos(e3)), false));
        var offset3 = currValue - startPos;
        var value2 = clamp_default(this.getOffset(offset3, true), min10, max11);
        return value2;
      };
      Continuous3.prototype.getOffset = function(value2, reverse) {
        if (reverse === void 0) {
          reverse = false;
        }
        var _a = this.range, min10 = _a.min, max11 = _a.max;
        var ribbonLen = this.ribbonShape.length;
        var scale10 = this.eventToOffsetScale;
        scale10.update({ domain: [min10, max11], range: [0, ribbonLen] });
        if (reverse)
          return scale10.invert(value2);
        return scale10.map(value2);
      };
      Continuous3.prototype.getRealSelection = function(range3) {
        var max11 = this.range.max;
        var _a = __read(range3, 2), start2 = _a[0], end = _a[1];
        return this.ifHorizontal([start2, end], [max11 - end, max11 - start2]);
      };
      Continuous3.prototype.getRealValue = function(value2) {
        var max11 = this.range.max;
        return this.ifHorizontal(value2, max11 - value2);
      };
      Continuous3.prototype.dispatchSelection = function() {
        var selection = this.getRealSelection(this.selection);
        var evt = new CustomEvent2("valuechange", {
          detail: {
            value: selection
          }
        });
        this.dispatchEvent(evt);
      };
      Continuous3.prototype.dispatchIndicated = function(value2, range3) {
        var _this = this;
        var max11 = this.range.max;
        var detail = this.ifHorizontal(function() {
          return {
            value: value2,
            range: range3
          };
        }, function() {
          return {
            value: max11 - value2,
            range: range3 ? _this.getRealSelection(range3) : void 0
          };
        });
        var evt = new CustomEvent2("indicate", {
          detail
        });
        this.dispatchEvent(evt);
      };
      return Continuous3;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/tooltip/constant.js
  function getClassNames(prefixCls) {
    if (prefixCls === void 0) {
      prefixCls = "";
    }
    return {
      CONTAINER: "".concat(prefixCls, "tooltip"),
      TITLE: "".concat(prefixCls, "tooltip-title"),
      LIST: "".concat(prefixCls, "tooltip-list"),
      LIST_ITEM: "".concat(prefixCls, "tooltip-list-item"),
      NAME: "".concat(prefixCls, "tooltip-list-item-name"),
      MARKER: "".concat(prefixCls, "tooltip-list-item-marker"),
      NAME_LABEL: "".concat(prefixCls, "tooltip-list-item-name-label"),
      VALUE: "".concat(prefixCls, "tooltip-list-item-value"),
      CROSSHAIR_X: "".concat(prefixCls, "tooltip-crosshair-x"),
      CROSSHAIR_Y: "".concat(prefixCls, "tooltip-crosshair-y")
    };
  }
  var TEXT_OVERFLOW_STYLE = {
    overflow: "hidden",
    "white-space": "nowrap",
    "text-overflow": "ellipsis"
  };
  function getDefaultTooltipStyle(prefixCls) {
    var _a;
    if (prefixCls === void 0) {
      prefixCls = "";
    }
    var CLASS_NAME = getClassNames(prefixCls);
    return _a = {}, _a[".".concat(CLASS_NAME.CONTAINER)] = {
      position: "absolute",
      visibility: "visible",
      // 'white-space': 'nowrap',
      "z-index": 8,
      transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
      "background-color": "rgba(255, 255, 255, 0.96)",
      "box-shadow": "0 6px 12px 0 rgba(0, 0, 0, 0.12)",
      "border-radius": "4px",
      color: "rgba(0, 0, 0, 0.65)",
      "font-size": "12px",
      // 'font-family': ,
      "line-height": "20px",
      padding: "12px",
      "min-width": "120px",
      "max-width": "360px",
      "font-family": "Roboto-Regular"
    }, _a[".".concat(CLASS_NAME.TITLE)] = {
      color: "rgba(0, 0, 0, 0.45)"
    }, _a[".".concat(CLASS_NAME.LIST)] = {
      margin: "0px",
      "list-style-type": "none",
      padding: "0px"
    }, _a[".".concat(CLASS_NAME.LIST_ITEM)] = {
      "list-style-type": "none",
      display: "flex",
      "line-height": "2em",
      "align-items": "center",
      "justify-content": "space-between",
      "white-space": "nowrap"
    }, _a[".".concat(CLASS_NAME.MARKER)] = {
      width: "8px",
      height: "8px",
      "border-radius": "50%",
      display: "inline-block",
      "margin-right": "4px"
    }, _a[".".concat(CLASS_NAME.NAME)] = {
      display: "flex",
      "align-items": "center",
      "max-width": "216px"
    }, _a[".".concat(CLASS_NAME.NAME_LABEL)] = __assign({ flex: 1 }, TEXT_OVERFLOW_STYLE), _a[".".concat(CLASS_NAME.VALUE)] = __assign({ display: "inline-block", float: "right", flex: 1, "text-align": "right", "min-width": "28px", "margin-left": "30px", color: "rgba(0, 0, 0, 0.85)" }, TEXT_OVERFLOW_STYLE), _a[".".concat(CLASS_NAME.CROSSHAIR_X)] = {
      position: "absolute",
      width: "1px",
      "background-color": "rgba(0, 0, 0, 0.25)"
    }, _a[".".concat(CLASS_NAME.CROSSHAIR_Y)] = {
      position: "absolute",
      height: "1px",
      "background-color": "rgba(0, 0, 0, 0.25)"
    }, _a;
  }

  // node_modules/@antv/component/esm/ui/tooltip/index.js
  var Tooltip = (
    /** @class */
    function(_super) {
      __extends(Tooltip3, _super);
      function Tooltip3(options) {
        var _this = this;
        var _a, _b;
        var prefixCls = (_b = (_a = options.style) === null || _a === void 0 ? void 0 : _a.template) === null || _b === void 0 ? void 0 : _b.prefixCls;
        var CLASS_NAME = getClassNames(prefixCls);
        _this = _super.call(this, options, {
          data: [],
          x: 0,
          y: 0,
          visibility: "visible",
          title: "",
          position: "bottom-right",
          offset: [5, 5],
          enterable: false,
          container: {
            x: 0,
            y: 0
          },
          bounding: null,
          template: {
            prefixCls: "",
            container: '<div class="'.concat(CLASS_NAME.CONTAINER, '"></div>'),
            title: '<div class="'.concat(CLASS_NAME.TITLE, '"></div>'),
            item: '<li class="'.concat(CLASS_NAME.LIST_ITEM, '" data-index={index}>\n        <span class="').concat(CLASS_NAME.NAME, '">\n          <span class="').concat(CLASS_NAME.MARKER, '" style="background:{color}"></span>\n          <span class="').concat(CLASS_NAME.NAME_LABEL, '" title="{name}">{name}</span>\n        </span>\n        <span class="').concat(CLASS_NAME.VALUE, '" title="{value}">{value}</span>\n      </li>')
          },
          style: getDefaultTooltipStyle(prefixCls)
        }) || this;
        _this.timestamp = -1;
        _this.prevCustomContentKey = _this.attributes.contentKey;
        _this.initShape();
        _this.render(_this.attributes, _this);
        return _this;
      }
      Object.defineProperty(Tooltip3.prototype, "HTMLTooltipElement", {
        get: function() {
          return this.element;
        },
        enumerable: false,
        configurable: true
      });
      Tooltip3.prototype.getContainer = function() {
        return this.element;
      };
      Object.defineProperty(Tooltip3.prototype, "elementSize", {
        get: function() {
          var width = this.element.offsetWidth;
          var height = this.element.offsetHeight;
          return { width, height };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Tooltip3.prototype, "HTMLTooltipItemsElements", {
        get: function() {
          var _a = this.attributes, data2 = _a.data, template = _a.template;
          return data2.map(function(_a2, idx) {
            var _b = _a2.name, name2 = _b === void 0 ? "" : _b, _c = _a2.color, color2 = _c === void 0 ? "black" : _c, index4 = _a2.index, rest = __rest(_a2, ["name", "color", "index"]);
            var datum = __assign({ name: name2, color: color2, index: index4 !== null && index4 !== void 0 ? index4 : idx }, rest);
            return createDOM(substitute_default(template.item, datum));
          });
        },
        enumerable: false,
        configurable: true
      });
      Tooltip3.prototype.render = function(attributes, container) {
        this.renderHTMLTooltipElement();
        this.updatePosition();
      };
      Tooltip3.prototype.destroy = function() {
        var _a;
        (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();
        _super.prototype.destroy.call(this);
      };
      Tooltip3.prototype.show = function(x3, y3) {
        var _this = this;
        if (x3 !== void 0 && y3 !== void 0) {
          var isToggle = this.element.style.visibility === "hidden";
          var setPosition = function() {
            _this.attributes.x = x3 !== null && x3 !== void 0 ? x3 : _this.attributes.x;
            _this.attributes.y = y3 !== null && y3 !== void 0 ? y3 : _this.attributes.y;
            _this.updatePosition();
          };
          isToggle ? this.closeTransition(setPosition) : setPosition();
        }
        this.element.style.visibility = "visible";
      };
      Tooltip3.prototype.hide = function(x3, y3) {
        if (x3 === void 0) {
          x3 = 0;
        }
        if (y3 === void 0) {
          y3 = 0;
        }
        var enterable = this.attributes.enterable;
        if (enterable && this.isCursorEntered(x3, y3))
          return;
        this.element.style.visibility = "hidden";
      };
      Tooltip3.prototype.initShape = function() {
        var template = this.attributes.template;
        this.element = createDOM(template.container);
        if (this.id)
          this.element.setAttribute("id", this.id);
      };
      Tooltip3.prototype.renderCustomContent = function() {
        if (this.prevCustomContentKey !== void 0 && this.prevCustomContentKey === this.attributes.contentKey)
          return;
        this.prevCustomContentKey = this.attributes.contentKey;
        var content = this.attributes.content;
        if (!content)
          return;
        if (typeof content === "string")
          this.element.innerHTML = content;
        else
          replaceChildren(this.element, content);
      };
      Tooltip3.prototype.renderHTMLTooltipElement = function() {
        var _a, _b;
        var _c = this.attributes, template = _c.template, title = _c.title, enterable = _c.enterable, style = _c.style, content = _c.content;
        var CLASS_NAME = getClassNames(template.prefixCls);
        var container = this.element;
        this.element.style.pointerEvents = enterable ? "auto" : "none";
        if (content)
          this.renderCustomContent();
        else {
          if (title) {
            container.innerHTML = template.title;
            container.getElementsByClassName(CLASS_NAME.TITLE)[0].innerHTML = title;
          } else
            (_b = (_a = container.getElementsByClassName(CLASS_NAME.TITLE)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.remove();
          var itemsElements = this.HTMLTooltipItemsElements;
          var ul = document.createElement("ul");
          ul.className = CLASS_NAME.LIST;
          replaceChildren(ul, itemsElements);
          var list = this.element.querySelector(".".concat(CLASS_NAME.LIST));
          if (list)
            list.replaceWith(ul);
          else
            container.appendChild(ul);
        }
        applyStyleSheet(container, style);
      };
      Tooltip3.prototype.getRelativeOffsetFromCursor = function(assignPosition) {
        var _a = this.attributes, position = _a.position, offset3 = _a.offset;
        var interPosition = assignPosition || position;
        var finalPosition = interPosition.split("-");
        var positionScore = { left: [-1, 0], right: [1, 0], top: [0, -1], bottom: [0, 1] };
        var _b = this.elementSize, width = _b.width, height = _b.height;
        var absolutelyOffset = [-width / 2, -height / 2];
        finalPosition.forEach(function(pos) {
          var _a2 = __read(absolutelyOffset, 2), abs1 = _a2[0], abs22 = _a2[1];
          var _b2 = __read(positionScore[pos], 2), pos1 = _b2[0], pos2 = _b2[1];
          absolutelyOffset = [abs1 + (width / 2 + offset3[0]) * pos1, abs22 + (height / 2 + offset3[1]) * pos2];
        });
        return absolutelyOffset;
      };
      Tooltip3.prototype.setOffsetPosition = function(_a) {
        var _b = __read(_a, 2), offsetX = _b[0], offsetY = _b[1];
        var _c = this.attributes, _d = _c.x, x3 = _d === void 0 ? 0 : _d, _e = _c.y, y3 = _e === void 0 ? 0 : _e, _f = _c.container, cx = _f.x, cy = _f.y;
        this.element.style.left = "".concat(+x3 + cx + offsetX, "px");
        this.element.style.top = "".concat(+y3 + cy + offsetY, "px");
      };
      Tooltip3.prototype.updatePosition = function() {
        var _a = this.attributes.showDelay, showDelay = _a === void 0 ? 60 : _a;
        var currentTimestamp = Date.now();
        if (this.timestamp > 0 && currentTimestamp - this.timestamp < showDelay)
          return;
        this.timestamp = currentTimestamp;
        this.setOffsetPosition(this.autoPosition(this.getRelativeOffsetFromCursor()));
      };
      Tooltip3.prototype.autoPosition = function(_a) {
        var _b = __read(_a, 2), offsetX = _b[0], offsetY = _b[1];
        var _c = this.attributes, cursorX = _c.x, cursorY = _c.y, bounding = _c.bounding, position = _c.position;
        if (!bounding)
          return [offsetX, offsetY];
        var _d = this.element, offsetWidth = _d.offsetWidth, offsetHeight = _d.offsetHeight;
        var _e = __read([+cursorX + offsetX, +cursorY + offsetY], 2), expectLeft = _e[0], expectTop = _e[1];
        var inversion = {
          left: "right",
          right: "left",
          top: "bottom",
          bottom: "top"
        };
        var boundingX = bounding.x, boundingY = bounding.y, boundingWidth = bounding.width, boundingHeight = bounding.height;
        var edgeCompare = {
          left: expectLeft < boundingX,
          right: expectLeft + offsetWidth > boundingX + boundingWidth,
          top: expectTop < boundingY,
          bottom: expectTop + offsetHeight > boundingY + boundingHeight
        };
        var correctivePosition = [];
        position.split("-").forEach(function(pos) {
          if (edgeCompare[pos])
            correctivePosition.push(inversion[pos]);
          else
            correctivePosition.push(pos);
        });
        var correctedPositionString = correctivePosition.join("-");
        return this.getRelativeOffsetFromCursor(correctedPositionString);
      };
      Tooltip3.prototype.isCursorEntered = function(clientX, clientY) {
        if (this.element) {
          var _a = this.element.getBoundingClientRect(), x3 = _a.x, y3 = _a.y, width = _a.width, height = _a.height;
          return new BBox(x3, y3, width, height).isPointIn(clientX, clientY);
        }
        return false;
      };
      Tooltip3.prototype.closeTransition = function(callback) {
        var _this = this;
        var transition2 = this.element.style.transition;
        this.element.style.transition = "none";
        callback();
        setTimeout(function() {
          _this.element.style.transition = transition2;
        }, 10);
      };
      Tooltip3.tag = "tooltip";
      return Tooltip3;
    }(Component)
  );

  // node_modules/@antv/component/esm/ui/layout/layout.js
  var Layout = (
    /** @class */
    function(_super) {
      __extends(Layout2, _super);
      function Layout2(options) {
        var _this = _super.call(this, options) || this;
        _this.layoutEvents = [ElementEvent.BOUNDS_CHANGED, ElementEvent.INSERTED, ElementEvent.REMOVED];
        _this.$margin = parseSeriesAttr(0);
        _this.$padding = parseSeriesAttr(0);
        var _a = options.style || {}, _b = _a.margin, margin = _b === void 0 ? 0 : _b, _c = _a.padding, padding = _c === void 0 ? 0 : _c;
        _this.margin = margin;
        _this.padding = padding;
        _this.isMutationObserved = true;
        _this.bindEvents();
        return _this;
      }
      Object.defineProperty(Layout2.prototype, "margin", {
        get: function() {
          return this.$margin;
        },
        set: function(value2) {
          this.$margin = parseSeriesAttr(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Layout2.prototype, "padding", {
        get: function() {
          return this.$padding;
        },
        set: function(value2) {
          this.$padding = parseSeriesAttr(value2);
        },
        enumerable: false,
        configurable: true
      });
      Layout2.prototype.getBBox = function() {
        var _a = this.attributes, _b = _a.x, x3 = _b === void 0 ? 0 : _b, _c = _a.y, y3 = _c === void 0 ? 0 : _c, width = _a.width, height = _a.height;
        var _d = __read(this.$margin, 4), marginTop = _d[0], marginRight = _d[1], marginBottom = _d[2], marginLeft = _d[3];
        return new BBox(x3 - marginLeft, y3 - marginTop, width + marginLeft + marginRight, height + marginTop + marginBottom);
      };
      Layout2.prototype.appendChild = function(child, index4) {
        child.isMutationObserved = true;
        _super.prototype.appendChild.call(this, child, index4);
        return child;
      };
      Layout2.prototype.getAvailableSpace = function() {
        var _a = this.attributes, width = _a.width, height = _a.height;
        var _b = __read(this.$padding, 4), paddingTop = _b[0], paddingRight = _b[1], paddingBottom = _b[2], paddingLeft = _b[3];
        var _c = __read(this.$margin, 4), marginTop = _c[0], marginLeft = _c[3];
        return new BBox(paddingLeft + marginLeft, paddingTop + marginTop, width - paddingLeft - paddingRight, height - paddingTop - paddingBottom);
      };
      Layout2.prototype.layout = function() {
        if (!this.attributes.display || !this.isConnected)
          return;
        if (this.children.some(function(child) {
          return !child.isConnected;
        }))
          return;
        try {
          var _a = this.attributes, x3 = _a.x, y3 = _a.y;
          this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
          var bboxes_1 = executer_default(this.getAvailableSpace(), this.children.map(function(child) {
            return child.getBBox();
          }), this.attributes);
          this.children.forEach(function(child, index4) {
            var _a2 = bboxes_1[index4], x4 = _a2.x, y4 = _a2.y;
            child.style.transform = "translate(".concat(x4, ", ").concat(y4, ")");
          });
        } catch (e3) {
        }
      };
      Layout2.prototype.bindEvents = function() {
        var _this = this;
        this.layoutEvents.forEach(function(event) {
          _this.addEventListener(event, function(e3) {
            if (!e3.target)
              return;
            e3.target.isMutationObserved = true;
            _this.layout();
          });
        });
      };
      Layout2.prototype.attributeChangedCallback = function(name2, oldValue, newValue) {
        if (name2 === "margin")
          this.margin = newValue;
        else if (name2 === "padding")
          this.padding = newValue;
        this.layout();
      };
      return Layout2;
    }(Group2)
  );

  // node_modules/@antv/g2/esm/shape/text/advance.js
  var __rest22 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function getConnectorPoint(shape23) {
    const { min: [x05, y05], max: [x12, y12] } = shape23.getLocalBounds();
    let x3 = 0;
    let y3 = 0;
    if (x05 > 0)
      x3 = x05;
    if (x12 < 0)
      x3 = x12;
    if (y05 > 0)
      y3 = y05;
    if (y12 < 0)
      y3 = y12;
    return [x3, y3];
  }
  function inferBackgroundBounds(textShape, padding = []) {
    const [top = 0, right2 = 0, bottom = top, left2 = right2] = padding;
    const container = textShape.parentNode;
    const angle4 = container.getEulerAngles();
    container.setEulerAngles(0);
    const { min: min10, halfExtents } = textShape.getLocalBounds();
    const [x3, y3] = min10;
    const [hw, hh] = halfExtents;
    container.setEulerAngles(angle4);
    return {
      x: x3 - left2,
      y: y3 - top,
      width: hw * 2 + left2 + right2,
      height: hh * 2 + top + bottom
    };
  }
  function inferConnectorPath(shape23, end, control, coordCenter, left2 = true, top = true) {
    const path2 = (points) => line_default()(points);
    if (!end[0] && !end[1])
      return path2([getConnectorPoint(shape23), end]);
    if (!control.length)
      return path2([[0, 0], end]);
    const [inflection, start2] = control;
    const p1 = [...start2];
    const p2 = [...inflection];
    if (start2[0] !== inflection[0]) {
      const offset3 = left2 ? -4 : 4;
      p1[1] = start2[1];
      if (top && !left2) {
        p1[0] = Math.max(inflection[0], start2[0] - offset3);
        if (start2[1] < inflection[1]) {
          p2[1] = p1[1];
        } else {
          p2[1] = inflection[1];
          p2[0] = Math.max(p2[0], p1[0] - offset3);
        }
      }
      if (!top && !left2) {
        p1[0] = Math.max(inflection[0], start2[0] - offset3);
        if (start2[1] > inflection[1]) {
          p2[1] = p1[1];
        } else {
          p2[1] = inflection[1];
          p2[0] = Math.max(p2[0], p1[0] - offset3);
        }
      }
      if (!top && left2) {
        p1[0] = Math.min(inflection[0], start2[0] - offset3);
        if (start2[1] > inflection[1]) {
          p2[1] = p1[1];
        } else {
          p2[1] = inflection[1];
          p2[0] = Math.min(p2[0], p1[0] - offset3);
        }
      }
      if (top && left2) {
        p1[0] = Math.min(inflection[0], start2[0] - offset3);
        if (start2[1] < inflection[1]) {
          p2[1] = p1[1];
        } else {
          p2[1] = inflection[1];
          p2[0] = Math.min(p2[0], p1[0] - offset3);
        }
      }
    }
    return path2([start2, p1, p2, inflection, end]);
  }
  var Advance = createElement((g) => {
    const _a = g.attributes, {
      className: className2,
      // Do not pass className
      class: _c,
      transform,
      rotate: rotate5,
      labelTransform,
      labelTransformOrigin,
      x: x3,
      y: y3,
      x0: x05 = x3,
      y0: y05 = y3,
      text,
      background,
      connector,
      startMarker,
      endMarker,
      coordCenter,
      innerHTML
    } = _a, rest = __rest22(_a, ["className", "class", "transform", "rotate", "labelTransform", "labelTransformOrigin", "x", "y", "x0", "y0", "text", "background", "connector", "startMarker", "endMarker", "coordCenter", "innerHTML"]);
    g.style.transform = `translate(${x3}, ${y3})`;
    if ([x3, y3, x05, y05].some((v) => !isNumber2(v))) {
      g.children.forEach((d3) => d3.remove());
      return;
    }
    const _b = subObject(rest, "background"), { padding } = _b, backgroundStyle = __rest22(_b, ["padding"]);
    const _d = subObject(rest, "connector"), { points: controlPoints = [] } = _d, connectorStyle = __rest22(_d, ["points"]);
    let textShape;
    if (innerHTML) {
      textShape = select(g).maybeAppend("html", "html", className2).style("zIndex", 0).style("innerHTML", innerHTML).call(applyStyle, Object.assign({ transform: labelTransform, transformOrigin: labelTransformOrigin }, rest)).node();
    } else {
      textShape = select(g).maybeAppend("text", "text").style("zIndex", 0).style("text", text).call(applyStyle, Object.assign({ textBaseline: "middle", transform: labelTransform, transformOrigin: labelTransformOrigin }, rest)).node();
    }
    const rect4 = select(g).maybeAppend("background", "rect").style("zIndex", -1).call(applyStyle, inferBackgroundBounds(textShape, padding)).call(applyStyle, background ? backgroundStyle : {}).node();
    const left2 = +x05 < coordCenter[0];
    const top = +y05 < coordCenter[1];
    const end = [+x05 - +x3, +y05 - +y3];
    const connectorPath = inferConnectorPath(rect4, end, controlPoints, coordCenter, left2, top);
    const markerStart = startMarker && new Marker({
      id: "startMarker",
      style: Object.assign({ x: 0, y: 0 }, subObject(rest, "startMarker"))
    });
    const markerEnd = endMarker && new Marker({
      id: "endMarker",
      style: Object.assign({ x: 0, y: 0 }, subObject(rest, "endMarker"))
    });
    select(g).maybeAppend("connector", "path").style("zIndex", 0).style("d", connectorPath).style("markerStart", markerStart).style("markerEnd", markerEnd).call(applyStyle, connector ? connectorStyle : {});
  });

  // node_modules/@antv/g2/esm/shape/text/text.js
  var Text3 = (options, context) => {
    const { coordinate } = context;
    return (points, value2, defaults5) => {
      const { color: color2, text = "", fontSize, rotate: rotate5 = 0, transform = "" } = value2;
      const textStyle = {
        text: String(text),
        stroke: color2,
        fill: color2,
        fontSize
      };
      const [[x05, y05]] = points;
      return select(new Advance()).style("x", x05).style("y", y05).call(applyStyle, defaults5).style("transform", `${transform}rotate(${+rotate5})`).style("coordCenter", coordinate.getCenter()).call(applyStyle, textStyle).call(applyStyle, options).node();
    };
  };
  Text3.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/text/badge.js
  var __rest23 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function getPath(r) {
    const offset3 = r / Math.sqrt(2);
    const dy = r * Math.sqrt(2);
    const [p0x, p0y] = [-offset3, offset3 - dy];
    const [p1x, p1y] = [0, 0];
    const [p2x, p2y] = [offset3, offset3 - dy];
    return [
      ["M", p0x, p0y],
      ["A", r, r, 0, 1, 1, p2x, p2y],
      ["L", p1x, p1y],
      ["Z"]
    ];
  }
  function inferTextPosition(shape23) {
    const { min: min10, max: max11 } = shape23.getLocalBounds();
    return [(min10[0] + max11[0]) * 0.5, (min10[1] + max11[1]) * 0.5];
  }
  var BadgeShape = createElement((g) => {
    const _a = g.attributes, { class: className2, x: x05, y: y05, transform } = _a, rest = __rest23(_a, ["class", "x", "y", "transform"]);
    const markerStyle = subObject(rest, "marker");
    const { size: size2 = 24 } = markerStyle;
    const symbol = () => getPath(size2 / 2);
    const bgShape = select(g).maybeAppend("marker", () => new Marker({})).call((selection) => selection.node().update(Object.assign({ symbol }, markerStyle))).node();
    const [x3, y3] = inferTextPosition(bgShape);
    select(g).maybeAppend("text", "text").style("x", x3).style("y", y3).call(applyStyle, rest);
  });
  var Badge = (options, context) => {
    const style = __rest23(options, []);
    return (points, value2, defaults5) => {
      const { color: defaultColor } = defaults5, rest = __rest23(defaults5, ["color"]);
      const { color: color2 = defaultColor, text = "" } = value2;
      const textStyle = {
        text: String(text),
        stroke: color2,
        fill: color2
      };
      const [[x05, y05]] = points;
      return select(new BadgeShape()).call(applyStyle, rest).style("transform", `translate(${x05},${y05})`).call(applyStyle, textStyle).call(applyStyle, style).node();
    };
  };
  Badge.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/text/tag.js
  var Tag = (options, context) => {
    const { coordinate } = context;
    return (points, value2, defaults5) => {
      const { color: color2, text = "", fontSize, rotate: rotate5 = 0, transform = "" } = value2;
      const textStyle = {
        text: String(text),
        stroke: color2,
        fill: color2,
        fontSize,
        textAlign: "center",
        textBaseline: "middle"
      };
      const [[x05, y05]] = points;
      const n2 = select(new Text()).style("x", x05).style("y", y05).call(applyStyle, defaults5).style("transformOrigin", "center center").style("transform", `${transform}rotate(${rotate5}deg)`).style("coordCenter", coordinate.getCenter()).call(applyStyle, textStyle).call(applyStyle, options).node();
      return n2;
    };
  };
  Tag.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/area/curve.js
  var __rest24 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function segmentation2(points, defined4) {
    const definedPointsY1 = [];
    const definedPointsY0 = [];
    const segments = [];
    let m3 = false;
    let dp = null;
    const mid2 = points.length / 2;
    for (let i = 0; i < mid2; i++) {
      const y12 = points[i];
      const y05 = points[i + mid2];
      if ([...y12, ...y05].some((v) => !defined4(v)))
        m3 = true;
      else {
        definedPointsY1.push(y12);
        definedPointsY0.push(y05);
        if (m3 && dp) {
          m3 = false;
          const [dpy1, dpy0] = dp;
          segments.push([dpy1, y12, dpy0, y05]);
        }
        dp = [y12, y05];
      }
    }
    return [definedPointsY1.concat(definedPointsY0), segments];
  }
  var DoubleArea = createElement((g) => {
    const { areaPath, connectPath, areaStyle, connectStyle } = g.attributes;
    const document2 = g.ownerDocument;
    select(g).maybeAppend("connect-path", () => document2.createElement("path", {})).style("d", connectPath).call(applyStyle, connectStyle);
    select(g).maybeAppend("area-path", () => document2.createElement("path", {})).style("d", areaPath).call(applyStyle, areaStyle);
  });
  var Curve2 = (options, context) => {
    const { curve, gradient = false, defined: defined4 = (d3) => !Number.isNaN(d3) && d3 !== void 0 && d3 !== null, connect: connectNulls = false } = options, style = __rest24(options, ["curve", "gradient", "defined", "connect"]);
    const { coordinate, document: document2 } = context;
    return (P, value2, defaults5) => {
      const { color: defaultColor } = defaults5;
      const { color: color2 = defaultColor, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
      const tpShape = isTranspose(coordinate);
      const transform = getTransform(coordinate, value2);
      const fill = gradient && sc ? computeGradient(sc, sx, sy, gradient, void 0, tpShape) : color2;
      const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign({}, defaults5), { stroke: fill, fill }), transform && { transform }), style);
      const [DP, MS] = segmentation2(P, defined4);
      const connectStyle = subObject(finalStyle, "connect");
      const missing = !!MS.length;
      const getPathNode = (path2) => {
        return select(document2.createElement("path", {})).style("d", path2 || "").call(applyStyle, finalStyle).node();
      };
      if (!isPolar(coordinate)) {
        const areaPath = (points) => {
          const Y12 = points.slice(0, points.length / 2);
          const Y02 = points.slice(points.length / 2);
          return tpShape ? area_default().y((_2, idx) => Y12[idx][1]).x1((_2, idx) => Y12[idx][0]).x0((_2, idx) => Y02[idx][0]).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y12) : area_default().x((_2, idx) => Y12[idx][0]).y1((_2, idx) => Y12[idx][1]).y0((_2, idx) => Y02[idx][1]).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y12);
        };
        if (!missing || connectNulls && !Object.keys(connectStyle).length) {
          return getPathNode(areaPath(DP));
        }
        if (missing && !connectNulls) {
          return getPathNode(areaPath(P));
        }
        return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaPath(P)).style("connectPath", MS.map(areaPath).join("")).node();
      } else {
        const areaRadialPath = (points) => {
          const center2 = coordinate.getCenter();
          const Y12 = points.slice(0, points.length / 2);
          const Y02 = points.slice(points.length / 2);
          return areaRadial_default().angle((_2, idx) => angleWithQuadrant(sub6(Y12[idx], center2))).outerRadius((_2, idx) => dist4(Y12[idx], center2)).innerRadius((_2, idx) => dist4(Y02[idx], center2)).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y02);
        };
        if (!missing || connectNulls && !Object.keys(connectStyle).length) {
          return getPathNode(areaRadialPath(DP));
        }
        if (missing && !connectNulls) {
          return getPathNode(areaRadialPath(P));
        }
        return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaRadialPath(P)).style("connectPath", MS.map(areaRadialPath).join("")).node();
      }
    };
  };
  Curve2.props = {
    defaultMarker: "smooth",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/area/area.js
  var Area = (options, context) => {
    const { coordinate } = context;
    return (...params) => {
      const curve = isPolar(coordinate) ? linearClosed_default : linear_default;
      return Curve2(Object.assign({ curve }, options), context)(...params);
    };
  };
  Area.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "square" });

  // node_modules/@antv/g2/esm/shape/area/smooth.js
  var __rest25 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var Smooth2 = (options, context) => {
    const rest = __rest25(options, []);
    const { coordinate } = context;
    return (...params) => {
      const curve = isPolar(coordinate) ? catmullRomClosed_default : isTranspose(coordinate) ? monotoneY : monotoneX;
      return Curve2(Object.assign({ curve }, rest), context)(...params);
    };
  };
  Smooth2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "smooth" });

  // node_modules/@antv/g2/esm/shape/area/hvh.js
  var HVH2 = (options, context) => {
    return (...params) => {
      return Curve2(Object.assign({ curve: step_default }, options), context)(...params);
    };
  };
  HVH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hvh" });

  // node_modules/@antv/g2/esm/shape/area/vh.js
  var VH2 = (options, context) => {
    return (...params) => {
      return Curve2(Object.assign({ curve: stepBefore }, options), context)(...params);
    };
  };
  VH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "vh" });

  // node_modules/@antv/g2/esm/shape/area/hv.js
  var HV2 = (options, context) => {
    return (...params) => {
      return Curve2(Object.assign({ curve: stepAfter }, options), context)(...params);
    };
  };
  HV2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hv" });

  // node_modules/@antv/g2/esm/shape/link/link.js
  var Link = (options, context) => {
    const { arrow = false } = options;
    return (...params) => {
      return Vector(Object.assign(Object.assign({}, options), { arrow }), context)(...params);
    };
  };
  Link.props = {
    defaultMarker: "line",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/link/smooth.js
  var __rest26 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var Smooth3 = (options, context) => {
    const style = __rest26(options, []);
    const { document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor } = defaults5, rest = __rest26(defaults5, ["color"]);
      const { color: color2 = defaultColor, transform } = value2;
      const [from, to] = points;
      const path2 = path();
      path2.moveTo(from[0], from[1]);
      path2.bezierCurveTo(from[0] / 2 + to[0] / 2, from[1], from[0] / 2 + to[0] / 2, to[1], to[0], to[1]);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("transform", transform).call(applyStyle, style).node();
    };
  };
  Smooth3.props = {
    defaultMarker: "smooth",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/link/vhv.js
  var __rest27 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function getVHVPath(from, to, coordinate, ratio) {
    const path2 = path();
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      const a3 = dist4(from, center2);
      const b = dist4(to, center2);
      const radius = (b - a3) * ratio + a3;
      path2.moveTo(from[0], from[1]);
      appendArc(path2, from, to, center2, radius);
      path2.lineTo(to[0], to[1]);
      return path2;
    }
    if (isTranspose(coordinate)) {
      path2.moveTo(from[0], from[1]);
      path2.lineTo(from[0] + (to[0] - from[0]) * ratio, from[1]);
      path2.lineTo(from[0] + (to[0] - from[0]) * ratio, to[1]);
      path2.lineTo(to[0], to[1]);
      return path2;
    }
    path2.moveTo(from[0], from[1]);
    path2.lineTo(from[0], from[1] + (to[1] - from[1]) * ratio);
    path2.lineTo(to[0], from[1] + (to[1] - from[1]) * ratio);
    path2.lineTo(to[0], to[1]);
    return path2;
  }
  var VHV = (options, context) => {
    const { cornerRatio = 1 / 3 } = options, style = __rest27(options, ["cornerRatio"]);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { defaultColor } = defaults5, rest = __rest27(defaults5, ["defaultColor"]);
      const { color: color2 = defaultColor, transform } = value2;
      const [from, to] = points;
      const path2 = getVHVPath(from, to, coordinate, cornerRatio);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("transform", transform).call(applyStyle, style).node();
    };
  };
  VHV.props = {
    defaultMarker: "vhv",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/link/arc.js
  var __rest28 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var Arc = (options, context) => {
    const style = __rest28(options, []);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor } = defaults5, rest = __rest28(defaults5, ["color"]);
      const { color: color2 = defaultColor, transform } = value2;
      const [from, to] = points;
      const path2 = path();
      path2.moveTo(from[0], from[1]);
      if (isPolar(coordinate)) {
        const center2 = coordinate.getCenter();
        path2.quadraticCurveTo(center2[0], center2[1], to[0], to[1]);
      } else {
        const center2 = mid(from, to);
        const raduis = dist4(from, to) / 2;
        appendArc(path2, from, to, center2, raduis);
      }
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("transform", transform).call(applyStyle, style).node();
    };
  };
  Arc.props = {
    defaultMarker: "smooth",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/mark/utils.js
  function baseChannels(options = {}) {
    const { shapes } = options;
    return [
      { name: "color" },
      { name: "opacity" },
      { name: "shape", range: shapes },
      { name: "enterType" },
      { name: "enterDelay", scaleKey: "enter" },
      { name: "enterDuration", scaleKey: "enter" },
      { name: "enterEasing" },
      { name: "key", scale: "identity" },
      { name: "groupKey", scale: "identity" },
      { name: "label", scale: "identity" }
    ];
  }
  function baseGeometryChannels(options = {}) {
    return [...baseChannels(options), { name: "title", scale: "identity" }];
  }
  function tooltip2d() {
    return [
      { type: MaybeTitle, channel: "color" },
      { type: MaybeTooltip, channel: ["x", "y"] }
    ];
  }
  function tooltip1d() {
    return [
      { type: MaybeTitle, channel: "x" },
      { type: MaybeTooltip, channel: ["y"] }
    ];
  }
  function tooltipXd() {
    return [
      { type: MaybeTitle, channel: "color" },
      { type: MaybeTooltip, channel: ["position"] }
    ];
  }
  function baseAnnotationChannels(options = {}) {
    return baseChannels(options);
  }
  function basePreInference() {
    return [{ type: MaybeKey }];
  }
  function basePostInference() {
    return [];
  }
  function bandWidth(scale10, x3) {
    return scale10.getBandWidth(scale10.invert(x3));
  }
  function createBandOffset(scale10, value2, options = {}) {
    const { x: X, y: Y, series: S } = value2;
    const { x: x3, y: y3, series } = scale10;
    const { style: { bandOffset = series ? 0 : 0.5, bandOffsetX = bandOffset, bandOffsetY = bandOffset } = {} } = options;
    const isBandX = !!(x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth);
    const isBandY = !!(y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth);
    const isSeries = !!(series === null || series === void 0 ? void 0 : series.getBandWidth);
    if (!isBandX && !isBandY)
      return (d3) => d3;
    return (d3, i) => {
      const widthX = isBandX ? bandWidth(x3, X[i]) : 0;
      const widthY = isBandY ? bandWidth(y3, Y[i]) : 0;
      const f = () => (bandWidth(series, S[i]) / 2 + +S[i]) * widthX;
      const offset3 = isSeries && S ? f() : 0;
      const [x05, y05] = d3;
      return [x05 + bandOffsetX * widthX + offset3, y05 + bandOffsetY * widthY];
    };
  }
  function p(d3) {
    return parseFloat(d3) / 100;
  }
  function visualMark(index4, scale10, value2, coordinate) {
    const { x: X, y: Y } = value2;
    const { innerWidth, innerHeight } = coordinate.getOptions();
    const P = Array.from(index4, (i) => {
      const x05 = X[i];
      const y05 = Y[i];
      const x3 = typeof x05 === "string" ? p(x05) * innerWidth : +x05;
      const y3 = typeof y05 === "string" ? p(y05) * innerHeight : +y05;
      return [[x3, y3]];
    });
    return [index4, P];
  }
  function field(encode) {
    return typeof encode === "function" ? encode : (d3) => d3[encode];
  }
  function valueof(data2, encode) {
    return Array.from(data2, field(encode));
  }
  function initializeData(data2, encode) {
    const { source = (d3) => d3.source, target = (d3) => d3.target, value: value2 = (d3) => d3.value } = encode;
    const { links, nodes } = data2;
    const LS = valueof(links, source);
    const LT = valueof(links, target);
    const LV = valueof(links, value2);
    return {
      links: links.map((_2, i) => ({
        target: LT[i],
        source: LS[i],
        value: LV[i]
      })),
      nodes: nodes || Array.from(/* @__PURE__ */ new Set([...LS, ...LT]), (key) => ({ key }))
    };
  }

  // node_modules/@antv/g2/esm/shape/image/image.js
  var __rest29 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var Image3 = (options, context) => {
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor } = defaults5, rest = __rest29(defaults5, ["color"]);
      const { color: color2 = defaultColor, src = "", size: size2 = 32, transform = "" } = value2;
      let { width = size2, height = size2 } = options;
      const [[x05, y05]] = points;
      const [w, h] = coordinate.getSize();
      width = typeof width === "string" ? p(width) * w : width;
      height = typeof height === "string" ? p(height) * h : height;
      const x3 = x05 - Number(width) / 2;
      const y3 = y05 - Number(height) / 2;
      return select(document2.createElement("image", {})).call(applyStyle, rest).style("x", x3).style("y", y3).style("src", src).style("stroke", color2).style("transform", transform).call(applyStyle, options).style("width", width).style("height", height).node();
    };
  };
  Image3.props = {
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/polygon/polygon.js
  var __rest30 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function getPolygonPath(points, coordinate) {
    const path2 = path();
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      const closedPoints = [...points, points[0]];
      const dists = closedPoints.map((p2) => dist4(p2, center2));
      closedPoints.forEach((curr, idx) => {
        if (idx === 0) {
          path2.moveTo(curr[0], curr[1]);
          return;
        }
        const currDist = dists[idx];
        const prev = points[idx - 1];
        const prevDist = dists[idx - 1];
        if (prevDist !== void 0 && Math.abs(currDist - prevDist) < 1e-10) {
          appendArc(path2, prev, curr, center2, currDist);
        } else {
          path2.lineTo(curr[0], curr[1]);
        }
      });
      path2.closePath();
      return path2;
    }
    return appendPolygon(path2, points);
  }
  var Polygon2 = (options, context) => {
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor } = defaults5, rest = __rest30(defaults5, ["color"]);
      const { color: color2 = defaultColor, transform } = value2;
      const path2 = getPolygonPath(points, coordinate);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("fill", color2).style("transform", transform).call(applyStyle, options).node();
    };
  };
  Polygon2.props = {
    defaultMarker: "square",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/polygon/ribbon.js
  var __rest31 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function getRibbonPath(points, coordinate) {
    const [p0, p1, p2, p3] = points;
    const path2 = path();
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      const radius = dist4(center2, p0);
      path2.moveTo(p0[0], p0[1]);
      path2.quadraticCurveTo(center2[0], center2[1], p2[0], p2[1]);
      appendArc(path2, p2, p3, center2, radius);
      path2.quadraticCurveTo(center2[0], center2[1], p1[0], p1[1]);
      appendArc(path2, p1, p0, center2, radius);
      path2.closePath();
      return path2;
    }
    path2.moveTo(p0[0], p0[1]);
    path2.bezierCurveTo(p0[0] / 2 + p2[0] / 2, p0[1], p0[0] / 2 + p2[0] / 2, p2[1], p2[0], p2[1]);
    path2.lineTo(p3[0], p3[1]);
    path2.bezierCurveTo(p3[0] / 2 + p1[0] / 2, p3[1], p3[0] / 2 + p1[0] / 2, p1[1], p1[0], p1[1]);
    path2.lineTo(p0[0], p0[1]);
    path2.closePath();
    return path2;
  }
  var Ribbon2 = (options, context) => {
    const style = __rest31(options, []);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor } = defaults5, rest = __rest31(defaults5, ["color"]);
      const { color: color2 = defaultColor, transform } = value2;
      const path2 = getRibbonPath(points, coordinate);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("fill", color2 || defaultColor).style("stroke", color2 || defaultColor).style("transform", transform).call(applyStyle, style).node();
    };
  };
  Ribbon2.props = {
    defaultMarker: "square",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/box/box.js
  var __rest32 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function getPath2(points, coordinate) {
    const path2 = path();
    if (!isPolar(coordinate)) {
      path2.moveTo(...points[0]);
      path2.lineTo(...points[1]);
      path2.moveTo(...points[2]);
      path2.lineTo(...points[3]);
      path2.moveTo(...points[4]);
      path2.lineTo(...points[5]);
      path2.lineTo(...points[6]);
      path2.lineTo(...points[7]);
      path2.closePath();
      path2.moveTo(...points[8]);
      path2.lineTo(...points[9]);
      path2.moveTo(...points[10]);
      path2.lineTo(...points[11]);
      path2.moveTo(...points[12]);
      path2.lineTo(...points[13]);
    } else {
      const center2 = coordinate.getCenter();
      const [x3, y3] = center2;
      const startAngle = angle3(sub6(points[0], center2));
      const endAngle = angle3(sub6(points[1], center2));
      const radiusHigh = dist4(center2, points[2]);
      const radiusQ3 = dist4(center2, points[3]);
      const radiusMedian = dist4(center2, points[8]);
      const radiusQ1 = dist4(center2, points[10]);
      const radiusLow = dist4(center2, points[11]);
      path2.moveTo(...points[0]);
      path2.arc(x3, y3, radiusHigh, startAngle, endAngle);
      path2.arc(x3, y3, radiusHigh, endAngle, startAngle, true);
      path2.moveTo(...points[2]);
      path2.lineTo(...points[3]);
      path2.moveTo(...points[4]);
      path2.arc(x3, y3, radiusQ3, startAngle, endAngle);
      path2.lineTo(...points[6]);
      path2.arc(x3, y3, radiusQ1, endAngle, startAngle, true);
      path2.closePath();
      path2.moveTo(...points[8]);
      path2.arc(x3, y3, radiusMedian, startAngle, endAngle);
      path2.arc(x3, y3, radiusMedian, endAngle, startAngle, true);
      path2.moveTo(...points[10]);
      path2.lineTo(...points[11]);
      path2.moveTo(...points[12]);
      path2.arc(x3, y3, radiusLow, startAngle, endAngle);
      path2.arc(x3, y3, radiusLow, endAngle, startAngle, true);
    }
    return path2;
  }
  var Box = (options, context) => {
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: color2, transform } = value2;
      const { color: defaultColor, fill = defaultColor, stroke: stroke2 = defaultColor } = defaults5, rest = __rest32(defaults5, ["color", "fill", "stroke"]);
      const path2 = getPath2(points, coordinate);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", stroke2).style("fill", color2 || fill).style("transform", transform).call(applyStyle, options).node();
    };
  };
  Box.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/box/violin.js
  var __rest33 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function getPath3(p2, coordinate, size2 = 4) {
    const path2 = path();
    if (!isPolar(coordinate)) {
      path2.moveTo(...p2[2]);
      path2.lineTo(...p2[3]);
      path2.lineTo(p2[3][0] - size2, p2[3][1]);
      path2.lineTo(p2[10][0] - size2, p2[10][1]);
      path2.lineTo(p2[10][0] + size2, p2[10][1]);
      path2.lineTo(p2[3][0] + size2, p2[3][1]);
      path2.lineTo(...p2[3]);
      path2.closePath();
      path2.moveTo(...p2[10]);
      path2.lineTo(...p2[11]);
      path2.moveTo(p2[3][0] + size2 / 2, p2[8][1]);
      path2.arc(p2[3][0], p2[8][1], size2 / 2, 0, Math.PI * 2);
      path2.closePath();
      return path2;
    }
    const center2 = coordinate.getCenter();
    const [x3, y3] = center2;
    const radiusQ3 = dist4(center2, p2[3]);
    const radiusMedian = dist4(center2, p2[8]);
    const radiusQ1 = dist4(center2, p2[10]);
    const middleAngle = angle3(sub6(p2[2], center2));
    const rectAngle = Math.asin(size2 / radiusMedian);
    const startAngle = middleAngle - rectAngle;
    const endAngle = middleAngle + rectAngle;
    path2.moveTo(...p2[2]);
    path2.lineTo(...p2[3]);
    path2.moveTo(Math.cos(startAngle) * radiusQ3 + x3, Math.sin(startAngle) * radiusQ3 + y3);
    path2.arc(x3, y3, radiusQ3, startAngle, endAngle);
    path2.lineTo(Math.cos(endAngle) * radiusQ1 + x3, Math.sin(endAngle) * radiusQ1 + y3);
    path2.arc(x3, y3, radiusQ1, endAngle, startAngle, true);
    path2.lineTo(Math.cos(startAngle) * radiusQ3 + x3, Math.sin(startAngle) * radiusQ3 + y3);
    path2.closePath();
    path2.moveTo(...p2[10]);
    path2.lineTo(...p2[11]);
    const a3 = (startAngle + endAngle) / 2;
    path2.moveTo(Math.cos(a3) * (radiusMedian + size2 / 2) + x3, Math.sin(a3) * (radiusMedian + size2 / 2) + y3);
    path2.arc(Math.cos(a3) * radiusMedian + x3, Math.sin(a3) * radiusMedian + y3, size2 / 2, a3, Math.PI * 2 + a3);
    path2.closePath();
    return path2;
  }
  var Violin = (options, context) => {
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: color2, transform } = value2;
      const size2 = 4;
      const { color: defaultColor, fill = defaultColor, stroke: stroke2 = defaultColor } = defaults5, rest = __rest33(defaults5, ["color", "fill", "stroke"]);
      const path2 = getPath3(points, coordinate, size2);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", stroke2).style("fill", color2 || fill).style("transform", transform).call(applyStyle, options).node();
    };
  };
  Violin.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/lineXY/line.js
  var __rest34 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function getArrowMarker(document2, arrowSize, arrowStyle) {
    const arrowMarker = document2.createElement("path", {
      style: Object.assign({ d: `M ${arrowSize},${arrowSize} L -${arrowSize},0 L ${arrowSize},-${arrowSize} L 0,0 Z`, transformOrigin: "center" }, arrowStyle)
    });
    return arrowMarker;
  }
  function getPath4(points, coordinate) {
    if (!isPolar(coordinate))
      return line_default().x((d3) => d3[0]).y((d3) => d3[1])(points);
    const center2 = coordinate.getCenter();
    return arc_default()({
      startAngle: 0,
      endAngle: Math.PI * 2,
      outerRadius: dist4(points[0], center2),
      innerRadius: dist4(points[1], center2)
    });
  }
  function getTransform2(coordinate, transform) {
    if (!isPolar(coordinate))
      return transform;
    const [cx, cy] = coordinate.getCenter();
    return `translate(${cx}, ${cy}) ${transform || ""}`;
  }
  var Line4 = (options, context) => {
    const { arrow, arrowSize = 4 } = options, style = __rest34(options, ["arrow", "arrowSize"]);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor, lineWidth } = defaults5, shapeTheme = __rest34(defaults5, ["color", "lineWidth"]);
      const { color: color2 = defaultColor, size: size2 = lineWidth } = value2;
      const arrowMarker = arrow ? getArrowMarker(document2, arrowSize, Object.assign({ fill: style.stroke || color2, stroke: style.stroke || color2 }, subObject(style, "arrow"))) : null;
      const path2 = getPath4(points, coordinate);
      const transform = getTransform2(coordinate, value2.transform);
      return select(document2.createElement("path", {})).call(applyStyle, shapeTheme).style("d", path2).style("stroke", color2).style("lineWidth", size2).style("transform", transform).style("markerEnd", arrowMarker).call(applyStyle, style).node();
    };
  };
  Line4.props = {
    defaultMarker: "line",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/connector/connector.js
  var __rest35 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function inferSymbol(x3, y3, r) {
    return [["M", x3, y3], ["L", x3 + 2 * r, y3 - r], ["L", x3 + 2 * r, y3 + r], ["Z"]];
  }
  function inferConnectorPath2(points) {
    return line_default().x((d3) => d3[0]).y((d3) => d3[1])(points);
  }
  function getPoints(coordinate, points, offset1, offset22, length1 = 0) {
    const [[x05, y05], [x12, y12]] = points;
    if (isTranspose(coordinate)) {
      const X02 = x05 + offset1;
      const X12 = x12 + offset22;
      const X = X02 + length1;
      return [
        [X02, y05],
        [X, y05],
        [X, y12],
        [X12, y12]
      ];
    }
    const Y02 = y05 - offset1;
    const Y12 = y12 - offset22;
    const Y = Y02 - length1;
    return [
      [x05, Y02],
      [x05, Y],
      [x12, Y],
      [x12, Y12]
    ];
  }
  var Connector = (options, context) => {
    const { offset: offset3 = 0, offset1 = offset3, offset2: offset22 = offset3, connectLength1: length1, endMarker = true } = options, style = __rest35(options, ["offset", "offset1", "offset2", "connectLength1", "endMarker"]);
    const { coordinate } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor, connectLength1 } = defaults5, rest = __rest35(defaults5, ["color", "connectLength1"]);
      const { color: color2, transform } = value2;
      const P = getPoints(coordinate, points, offset1, offset22, length1 !== null && length1 !== void 0 ? length1 : connectLength1);
      const makerStyle = subObject(Object.assign(Object.assign({}, style), defaults5), "endMarker");
      return select(new Path2()).call(applyStyle, rest).style("d", inferConnectorPath2(P)).style("stroke", color2 || defaultColor).style("transform", transform).style("markerEnd", endMarker ? new Marker({
        className: "marker",
        style: Object.assign(Object.assign({}, makerStyle), { symbol: inferSymbol })
      }) : null).call(applyStyle, style).node();
    };
  };
  Connector.props = {
    defaultMarker: "line",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/utils/string.js
  function camelCase(s3) {
    return s3.replace(/-(\w)/g, function(_2, letter) {
      return letter.toUpperCase();
    });
  }
  function kebabCase(s3) {
    return s3.replace(/([A-Z])/g, "-$1").toLowerCase();
  }

  // node_modules/@antv/g2/esm/shape/label/position/index.js
  var position_exports = {};
  __export(position_exports, {
    area: () => area,
    bottom: () => getDefaultStyle,
    bottomLeft: () => getDefaultStyle,
    bottomRight: () => getDefaultStyle,
    inside: () => getDefaultStyle,
    left: () => getDefaultStyle,
    outside: () => outside,
    right: () => getDefaultStyle,
    spider: () => spider,
    surround: () => surround,
    top: () => getDefaultStyle,
    topLeft: () => getDefaultStyle,
    topRight: () => getDefaultStyle
  });

  // node_modules/@antv/g2/esm/shape/label/position/area.js
  function area(position, points, value2, coordinate) {
    const l2 = points.length / 2;
    const Y12 = points.slice(0, l2);
    const Y02 = points.slice(l2);
    let idx = maxIndex(Y12, (p2, i) => Math.abs(p2[1] - Y02[i][1]));
    idx = Math.max(Math.min(idx, l2 - 2), 1);
    const mid2 = (i) => [Y12[i][0], (Y12[i][1] + Y02[i][1]) / 2];
    const point6 = mid2(idx);
    const prev = mid2(idx - 1);
    const next = mid2(idx + 1);
    const rotate5 = angle3(sub6(next, prev)) / Math.PI * 180;
    return {
      x: point6[0],
      y: point6[1],
      transform: `rotate(${rotate5})`,
      textAlign: "center",
      textBaseline: "middle"
    };
  }

  // node_modules/@antv/g2/esm/shape/label/position/default.js
  function inferNonCircularStyle(position, points, value2, coordinate) {
    const { bounds } = value2;
    const [[x05, y05], [x12, y12]] = bounds;
    const w = x12 - x05;
    const h = y12 - y05;
    const xy = (options) => {
      const { x: ox, y: oy } = options;
      const px2 = maybePercentage(value2.x, w);
      const py = maybePercentage(value2.y, h);
      return Object.assign(Object.assign({}, options), { x: (px2 || ox) + x05, y: (py || oy) + y05 });
    };
    if (position === "left")
      return xy({ x: 0, y: h / 2, textAlign: "start", textBaseline: "middle" });
    if (position === "right")
      return xy({ x: w, y: h / 2, textAlign: "end", textBaseline: "middle" });
    if (position === "top")
      return xy({ x: w / 2, y: 0, textAlign: "center", textBaseline: "top" });
    if (position === "bottom")
      return xy({ x: w / 2, y: h, textAlign: "center", textBaseline: "bottom" });
    if (position === "top-left")
      return xy({ x: 0, y: 0, textAlign: "start", textBaseline: "top" });
    if (position === "top-right")
      return xy({ x: w, y: 0, textAlign: "end", textBaseline: "top" });
    if (position === "bottom-left")
      return xy({ x: 0, y: h, textAlign: "start", textBaseline: "bottom" });
    if (position === "bottom-right")
      return xy({ x: w, y: h, textAlign: "end", textBaseline: "bottom" });
    return xy({
      x: w / 2,
      y: h / 2,
      textAlign: "center",
      textBaseline: "middle"
    });
  }
  function inferRadialStyle(position, points, value2, coordinate) {
    const { y: y3, y1: y12, autoRotate, rotateToAlignArc } = value2;
    const center2 = coordinate.getCenter();
    const arcObject = getArcObject(coordinate, points, [y3, y12]);
    const { innerRadius, outerRadius, startAngle, endAngle } = arcObject;
    const angle4 = position === "inside" ? (startAngle + endAngle) / 2 : endAngle;
    const rotate5 = inferRotation(angle4, autoRotate, rotateToAlignArc);
    const point6 = (() => {
      const [p0, p1] = points;
      const radius = innerRadius + (outerRadius - innerRadius) * 0.5;
      const [x3, y4] = position === "inside" ? pointOfArc(center2, angle4, radius) : mid(p0, p1);
      return { x: x3, y: y4 };
    })();
    return Object.assign(Object.assign({}, point6), { textAlign: position === "inside" ? "center" : "start", textBaseline: "middle", rotate: rotate5 });
  }
  function pointOfArc(center2, angle4, radius) {
    return [
      center2[0] + Math.sin(angle4) * radius,
      center2[1] - Math.cos(angle4) * radius
    ];
  }
  function inferRotation(angle4, autoRotate, rotateToAlignArc) {
    if (!autoRotate)
      return 0;
    const append3 = rotateToAlignArc ? 0 : Math.sin(angle4) < 0 ? 90 : -90;
    return angle4 / Math.PI * 180 + append3;
  }
  function inferInnerCircularStyle(position, points, value2, coordinate) {
    const { y: y3, y1: y12, autoRotate, rotateToAlignArc, radius: radiusRatio = 0.5, offset: offset3 = 0 } = value2;
    const arcObject = getArcObject(coordinate, points, [y3, y12]);
    const { startAngle, endAngle } = arcObject;
    const center2 = coordinate.getCenter();
    const angle4 = (startAngle + endAngle) / 2;
    const rotate5 = inferRotation(angle4, autoRotate, rotateToAlignArc);
    const textStyle = { textAlign: "center", textBaseline: "middle", rotate: rotate5 };
    const { innerRadius, outerRadius } = arcObject;
    const r0 = innerRadius + (outerRadius - innerRadius) * radiusRatio;
    const r1 = r0 + offset3;
    const [x05, y05] = pointOfArc(center2, angle4, r1);
    return Object.assign({ x: x05, y: y05 }, textStyle);
  }
  function maybeUndefined(d3) {
    return d3 === void 0 ? null : d3;
  }
  function inferIdentityStyle(position, points, value2, coordinate) {
    const { bounds } = value2;
    const [p2] = bounds;
    return {
      x: maybeUndefined(p2[0]),
      y: maybeUndefined(p2[1])
    };
  }
  function getDefaultStyle(position, points, value2, coordinate) {
    const { bounds } = value2;
    if (bounds.length === 1) {
      return inferIdentityStyle(position, points, value2, coordinate);
    }
    const inferDefaultStyle2 = isRadial(coordinate) ? inferRadialStyle : isCircular(coordinate) ? inferInnerCircularStyle : inferNonCircularStyle;
    return inferDefaultStyle2(position, points, value2, coordinate);
  }

  // node_modules/@antv/g2/esm/shape/label/position/outside.js
  function linePoints(center2, angle4, radius, radius1, offsetX) {
    const [x05, y05] = pointOfArc(center2, angle4, radius);
    const [x12, y12] = pointOfArc(center2, angle4, radius1);
    const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
    return [
      [x05, y05],
      [x12, y12],
      [x12 + sign3 * offsetX, y12]
    ];
  }
  function radiusOf2(points, value2, coordinate) {
    const arcObject = getArcObject(coordinate, points, [value2.y, value2.y1]);
    const { innerRadius, outerRadius } = arcObject;
    return innerRadius + (outerRadius - innerRadius);
  }
  function angleOf2(points, value2, coordinate) {
    const arcObject = getArcObject(coordinate, points, [value2.y, value2.y1]);
    const { startAngle, endAngle } = arcObject;
    return (startAngle + endAngle) / 2;
  }
  function inferOutsideCircularStyle(position, points, value2, coordinate) {
    const { autoRotate, rotateToAlignArc, offset: offset3 = 0, connector = true, connectorLength = offset3, connectorLength2 = 0, connectorDistance = 0 } = value2;
    const center2 = coordinate.getCenter();
    const angle4 = angleOf2(points, value2, coordinate);
    const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
    const rotate5 = inferRotation(angle4, autoRotate, rotateToAlignArc);
    const textStyle = {
      textAlign: sign3 > 0 || isRadial(coordinate) ? "start" : "end",
      textBaseline: "middle",
      rotate: rotate5
    };
    const radius = radiusOf2(points, value2, coordinate);
    const radius1 = radius + (connector ? connectorLength : offset3);
    const [[x05, y05], [x12, y12], [x22, y22]] = linePoints(center2, angle4, radius, radius1, connector ? connectorLength2 : 0);
    const dx = connector ? +connectorDistance * sign3 : 0;
    const x3 = x22 + dx;
    const y3 = y22;
    const connectorStyle = {
      connector,
      connectorPoints: [
        [x12 - x3, y12 - y3],
        [x22 - x3, y22 - y3]
      ]
    };
    return Object.assign(Object.assign({
      x0: x05,
      y0: y05,
      x: x22 + dx,
      y: y22
    }, textStyle), connectorStyle);
  }
  function outside(position, points, value2, coordinate) {
    const { bounds } = value2;
    if (bounds.length === 1) {
      return inferIdentityStyle(position, points, value2, coordinate);
    }
    const inferDefaultStyle2 = isRadial(coordinate) ? inferRadialStyle : isCircular(coordinate) ? inferOutsideCircularStyle : inferNonCircularStyle;
    return inferDefaultStyle2(position, points, value2, coordinate);
  }

  // node_modules/@antv/g2/esm/shape/label/position/utils.js
  function dodgeY(labels, options = {}) {
    const { labelHeight = 14, height } = options;
    const sortedLabels = sort2(labels, (d3) => d3.y);
    const n2 = sortedLabels.length;
    const boxes = new Array(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      const label = sortedLabels[i2];
      const { y: y3 } = label;
      boxes[i2] = { y: y3, y1: y3 + labelHeight, labels: [y3] };
    }
    let overlap = true;
    while (overlap) {
      overlap = false;
      for (let i2 = boxes.length - 1; i2 > 0; i2--) {
        const box2 = boxes[i2];
        const preBox = boxes[i2 - 1];
        if (preBox.y1 > box2.y) {
          overlap = true;
          preBox.labels.push(...box2.labels);
          boxes.splice(i2, 1);
          preBox.y1 += box2.y1 - box2.y;
          const newHeight = preBox.y1 - preBox.y;
          preBox.y1 = Math.max(Math.min(preBox.y1, height), newHeight);
          preBox.y = preBox.y1 - newHeight;
        }
      }
    }
    let i = 0;
    for (const box2 of boxes) {
      const { y: y3, labels: labels2 } = box2;
      let prevY = y3 - labelHeight;
      for (const curY of labels2) {
        const label = sortedLabels[i++];
        const expectedY = prevY + labelHeight;
        const dy = expectedY - curY;
        label.connectorPoints[0][1] -= dy;
        label.y = prevY + labelHeight;
        prevY += labelHeight;
      }
    }
  }
  function hideAndDodgeY(unsorted, options) {
    const labels = sort2(unsorted, (d3) => d3.y);
    const { height, labelHeight = 14 } = options;
    const maxCount = Math.ceil(height / labelHeight);
    if (labels.length <= maxCount)
      return dodgeY(labels, options);
    const filtered = [];
    for (let i = 0; i < labels.length; i++) {
      if (i < labels.length - maxCount) {
        labels[i].opacity = 0;
        labels[i].connector = false;
      } else
        filtered.push(labels[i]);
    }
    dodgeY(filtered, options);
  }

  // node_modules/@antv/g2/esm/shape/label/position/spider.js
  var __rest36 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var styleByPoints = /* @__PURE__ */ new WeakMap();
  function compute(points, value2, coordinate) {
    const { connectorLength, connectorLength2, connectorDistance } = value2;
    const style = __rest36(inferOutsideCircularStyle("outside", points, value2, coordinate), []);
    const center2 = coordinate.getCenter();
    const radius = radiusOf2(points, value2, coordinate);
    const angle4 = angleOf2(points, value2, coordinate);
    const radius1 = radius + connectorLength + connectorLength2;
    const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
    const newX = center2[0] + (radius1 + +connectorDistance) * sign3;
    const { x: originX } = style;
    const dx = newX - originX;
    style.x += dx;
    style.connectorPoints[0][0] -= dx;
    return style;
  }
  function spider(position, points, value2, coordinate, options, labels) {
    if (!isCircular(coordinate))
      return {};
    if (styleByPoints.has(points))
      return styleByPoints.get(points);
    const computed = labels.map((points2) => compute(points2, value2, coordinate));
    const { width, height } = coordinate.getOptions();
    const left2 = computed.filter((d3) => d3.x < width / 2);
    const right2 = computed.filter((d3) => d3.x >= width / 2);
    const extendedOptions = Object.assign(Object.assign({}, options), { height });
    hideAndDodgeY(left2, extendedOptions);
    hideAndDodgeY(right2, extendedOptions);
    computed.forEach((style, i) => styleByPoints.set(labels[i], style));
    return styleByPoints.get(points);
  }

  // node_modules/@antv/g2/esm/shape/label/position/surround.js
  var __rest37 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function surround(position, points, value2, coordinate) {
    if (!isCircular(coordinate))
      return {};
    const { connectorLength, connectorLength2, connectorDistance } = value2;
    const style = __rest37(inferOutsideCircularStyle("outside", points, value2, coordinate), []);
    const { x0: x05, y0: y05 } = style;
    const center2 = coordinate.getCenter();
    const radius = getRadius(coordinate);
    const radius1 = radius + connectorLength;
    const angle4 = angleWithQuadrant([x05 - center2[0], y05 - center2[1]]);
    const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
    const [newX, newY] = pointOfArc(center2, angle4, radius1);
    style.x = newX + (connectorLength2 + connectorDistance) * sign3;
    style.y = newY;
    return style;
  }

  // node_modules/@antv/g2/esm/shape/label/label.js
  var __rest38 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function inferPosition(position, coordinate) {
    if (position !== void 0)
      return position;
    if (isCircular(coordinate))
      return "inside";
    if (isTranspose(coordinate))
      return "right";
    return "top";
  }
  function getDefaultStyle2(points, value2, coordinate, theme, options, labels) {
    const { position } = value2;
    const { render: render2 } = options;
    const p2 = inferPosition(position, coordinate);
    const labelType = render2 ? "htmlLabel" : p2 === "inside" ? "innerLabel" : "label";
    const t = theme[labelType];
    const v = Object.assign({}, t, value2);
    const processor = position_exports[camelCase(p2)];
    if (!processor) {
      throw new Error(`Unknown position: ${p2}`);
    }
    return Object.assign(Object.assign({}, t), processor(p2, points, v, coordinate, options, labels));
  }
  var Label = (options, context) => {
    const { coordinate, theme } = context;
    const { render: render2 } = options;
    return (points, value2, style, labels) => {
      const { text, x: x3, y: y3, transform: specifiedTS = "", transformOrigin, className: className2 = "" } = value2, overrideStyle = __rest38(value2, ["text", "x", "y", "transform", "transformOrigin", "className"]);
      const _a = getDefaultStyle2(points, value2, coordinate, theme, options, labels), { rotate: rotate5 = 0, transform = "" } = _a, defaultStyle2 = __rest38(_a, ["rotate", "transform"]);
      return select(new Advance()).call(applyStyle, defaultStyle2).style("text", `${text}`).style("className", `${className2} g2-label`).style("innerHTML", render2 ? render2(text, value2.datum, value2.index) : void 0).style("labelTransform", `${transform} rotate(${+rotate5}) ${specifiedTS}`.trim()).style("labelTransformOrigin", transformOrigin).style("coordCenter", coordinate.getCenter()).call(applyStyle, overrideStyle).node();
    };
  };
  Label.props = {
    defaultMarker: "point"
  };

  // node_modules/@antv/g2/esm/shape/path/color.js
  var __rest39 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var Color4 = (options, context) => {
    const { arrow, colorAttribute } = options, style = __rest39(options, ["arrow", "colorAttribute"]);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor, stroke: stroke2 } = defaults5, rest = __rest39(defaults5, ["color", "stroke"]);
      const { d: d3, color: color2 = defaultColor } = value2;
      const [width, height] = coordinate.getSize();
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", typeof d3 === "function" ? d3({ width, height }) : d3).style(colorAttribute, color2).call(applyStyle, style).node();
    };
  };
  Color4.props = {
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/path/path.js
  var Path3 = (options, context) => {
    return Color4(Object.assign({ colorAttribute: "fill" }, options), context);
  };
  Path3.props = {
    defaultMarker: "hvh",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/path/hollow.js
  var Hollow2 = (options, context) => {
    return Color4(Object.assign({ fill: "none", colorAttribute: "stroke" }, options), context);
  };
  Hollow2.props = {
    defaultMarker: "hvh",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/density/density.js
  var __rest40 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var Density = (options, context) => {
    const { document: document2 } = context;
    return (points, value2, defaults5) => {
      const { transform } = value2;
      const { color: defaultColor } = defaults5, rest = __rest40(defaults5, ["color"]);
      const { color: color2 = defaultColor } = value2;
      const [first3, ...p2] = points;
      const path2 = path();
      path2.moveTo(...first3);
      p2.forEach(([x3, y3]) => {
        path2.lineTo(x3, y3);
      });
      path2.closePath();
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2 || defaultColor).style("fill", color2 || defaultColor).style("fillOpacity", 0.4).style("transform", transform).call(applyStyle, options).node();
    };
  };
  Density.props = {
    defaultMarker: "square",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/flru/dist/flru.mjs
  function flru_default(max11) {
    var num, curr, prev;
    var limit = max11 || 1;
    function keep(key, value2) {
      if (++num > limit) {
        prev = curr;
        reset(1);
        ++num;
      }
      curr[key] = value2;
    }
    function reset(isPartial) {
      num = 0;
      curr = /* @__PURE__ */ Object.create(null);
      isPartial || (prev = /* @__PURE__ */ Object.create(null));
    }
    reset();
    return {
      clear: reset,
      has: function(key) {
        return curr[key] !== void 0 || prev[key] !== void 0;
      },
      get: function(key) {
        var val = curr[key];
        if (val !== void 0) return val;
        if ((val = prev[key]) !== void 0) {
          keep(key, val);
          return val;
        }
      },
      set: function(key, value2) {
        if (curr[key] !== void 0) {
          curr[key] = value2;
        } else {
          keep(key, value2);
        }
      }
    };
  }

  // node_modules/@antv/g2/esm/utils/lru.js
  var cache2 = flru_default(3);
  function lru(fn, keyFn = (...args) => `${args[0]}`, maxSize = 16) {
    const cache3 = flru_default(maxSize);
    return (...args) => {
      const key = keyFn(...args);
      let v = cache3.get(key);
      if (cache3.has(key))
        return cache3.get(key);
      v = fn(...args);
      cache3.set(key, v);
      return v;
    };
  }

  // node_modules/@antv/g2/esm/shape/heatmap/renderer/gradient.js
  function parseGradient2(gradient) {
    if (typeof gradient === "string") {
      return gradient.split(" ").map((stop) => {
        const [r, c5] = stop.split(":");
        return [+r, c5];
      });
    }
    return gradient;
  }

  // node_modules/@antv/g2/esm/shape/heatmap/renderer/index.js
  function newCanvas(createCanvas, width, height) {
    const c5 = createCanvas ? createCanvas() : document.createElement("canvas");
    c5.width = width;
    c5.height = height;
    return c5;
  }
  var getPointTemplate = lru((radius, blurFactor, createCanvas) => {
    const tplCanvas = newCanvas(createCanvas, radius * 2, radius * 2);
    const tplCtx = tplCanvas.getContext("2d");
    const x3 = radius;
    const y3 = radius;
    if (blurFactor === 1) {
      tplCtx.beginPath();
      tplCtx.arc(x3, y3, radius, 0, 2 * Math.PI, false);
      tplCtx.fillStyle = "rgba(0,0,0,1)";
      tplCtx.fill();
    } else {
      const gradient = tplCtx.createRadialGradient(x3, y3, radius * blurFactor, x3, y3, radius);
      gradient.addColorStop(0, "rgba(0,0,0,1)");
      gradient.addColorStop(1, "rgba(0,0,0,0)");
      tplCtx.fillStyle = gradient;
      tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);
    }
    return tplCanvas;
  }, (radius) => `${radius}`);
  function getColorPalette(gradientConfig, createCanvas) {
    const paletteCanvas = newCanvas(createCanvas, 256, 1);
    const paletteCtx = paletteCanvas.getContext("2d");
    const gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);
    parseGradient2(gradientConfig).forEach(([r, c5]) => {
      gradient.addColorStop(r, c5);
    });
    paletteCtx.fillStyle = gradient;
    paletteCtx.fillRect(0, 0, 256, 1);
    return paletteCtx.getImageData(0, 0, 256, 1).data;
  }
  function drawAlpha(shadowCtx, min10, max11, data2, options, createCanvas) {
    const { blur } = options;
    let len5 = data2.length;
    while (len5--) {
      const { x: x3, y: y3, value: v, radius } = data2[len5];
      const value2 = Math.min(v, max11);
      const rectX = x3 - radius;
      const rectY = y3 - radius;
      const tpl = getPointTemplate(radius, 1 - blur, createCanvas);
      const templateAlpha = (value2 - min10) / (max11 - min10);
      shadowCtx.globalAlpha = Math.max(templateAlpha, 1e-3);
      shadowCtx.drawImage(tpl, rectX, rectY);
    }
    return shadowCtx;
  }
  function colorize(shadowCtx, maxWidth, maxHeight, palette, options) {
    const { minOpacity, opacity, maxOpacity, useGradientOpacity } = options;
    const x3 = 0;
    const y3 = 0;
    const width = maxWidth;
    const height = maxHeight;
    const img = shadowCtx.getImageData(x3, y3, width, height);
    const imgData = img.data;
    const len5 = imgData.length;
    for (let i = 3; i < len5; i += 4) {
      const alpha = imgData[i];
      const offset3 = alpha * 4;
      if (!offset3) {
        continue;
      }
      const finalAlpha = opacity || Math.max(0, Math.min(maxOpacity, Math.max(minOpacity, alpha)));
      imgData[i - 3] = palette[offset3];
      imgData[i - 2] = palette[offset3 + 1];
      imgData[i - 1] = palette[offset3 + 2];
      imgData[i] = useGradientOpacity ? palette[offset3 + 3] : finalAlpha;
    }
    return img;
  }
  function HeatmapRenderer(width, height, min10, max11, data2, options, createCanvas) {
    const opts = Object.assign({ blur: 0.85, minOpacity: 0, opacity: 0.6, maxOpacity: 1, gradient: [
      [0.25, "rgb(0,0,255)"],
      [0.55, "rgb(0,255,0)"],
      [0.85, "yellow"],
      [1, "rgb(255,0,0)"]
    ] }, options);
    opts.minOpacity *= 255;
    opts.opacity *= 255;
    opts.maxOpacity *= 255;
    const shadowCanvas = newCanvas(createCanvas, width, height);
    const shadowCtx = shadowCanvas.getContext("2d");
    const palette = getColorPalette(opts.gradient, createCanvas);
    shadowCtx.clearRect(0, 0, width, height);
    drawAlpha(shadowCtx, min10, max11, data2, opts, createCanvas);
    const img = colorize(shadowCtx, width, height, palette, opts);
    const canvas = newCanvas(createCanvas, width, height);
    const ctx2 = canvas.getContext("2d");
    ctx2.putImageData(img, 0, 0);
    return ctx2;
  }

  // node_modules/@antv/g2/esm/shape/heatmap/heatmap.js
  var __rest41 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function deleteKey(obj, fn) {
    return Object.keys(obj).reduce((r, k) => {
      const v = obj[k];
      if (!fn(v, k))
        r[k] = v;
      return r;
    }, {});
  }
  var Heatmap = (options, context) => {
    const { gradient, opacity, maxOpacity, minOpacity, blur, useGradientOpacity } = options, style = __rest41(options, ["gradient", "opacity", "maxOpacity", "minOpacity", "blur", "useGradientOpacity"]);
    const { coordinate, createCanvas, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { transform } = value2;
      const [width, height] = coordinate.getSize();
      const data2 = points.map((p2) => ({
        x: p2[0],
        y: p2[1],
        value: p2[2],
        radius: p2[3]
      }));
      const min10 = min4(points, (p2) => p2[2]);
      const max11 = max5(points, (p2) => p2[2]);
      const options2 = {
        gradient,
        opacity,
        minOpacity,
        maxOpacity,
        blur,
        useGradientOpacity
      };
      const ctx2 = width && height ? HeatmapRenderer(width, height, min10, max11, data2, deleteKey(options2, (v) => v === void 0), createCanvas) : { canvas: null };
      return select(document2.createElement("image", {})).call(applyStyle, defaults5).style("x", 0).style("y", 0).style("width", width).style("height", height).style("src", ctx2.canvas).style("transform", transform).call(applyStyle, style).node();
    };
  };
  Heatmap.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/shape/shape.js
  var __rest42 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var Shape2 = (options, context) => {
    const { render: render2 } = options, rest = __rest42(options, ["render"]);
    return (points) => {
      const [[x05, y05]] = points;
      return render2(Object.assign(Object.assign({}, rest), { x: x05, y: y05 }), context);
    };
  };
  Shape2.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // node_modules/@antv/g2/esm/shape/liquid/wave.js
  var DURATION = 5e3;
  function lerp5(min10, max11, factor) {
    return min10 + (max11 - min10) * factor;
  }
  function getWaterWavePositions(x3, stage, waveLength, amplitude) {
    if (stage === 0) {
      return [
        [x3 + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],
        [x3 + 1 / 2 * waveLength / Math.PI, amplitude],
        [x3 + waveLength / 4, amplitude]
      ];
    }
    if (stage === 1) {
      return [
        [x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude],
        [
          x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
          amplitude / 2
        ],
        [x3 + waveLength / 4, 0]
      ];
    }
    if (stage === 2) {
      return [
        [x3 + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],
        [x3 + 1 / 2 * waveLength / Math.PI, -amplitude],
        [x3 + waveLength / 4, -amplitude]
      ];
    }
    return [
      [x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude],
      [
        x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
        -amplitude / 2
      ],
      [x3 + waveLength / 4, 0]
    ];
  }
  function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {
    const curves = Math.ceil(2 * radius / waveLength * 4) * 4;
    const path2 = [];
    let _phase = phase;
    while (_phase < -Math.PI * 2) {
      _phase += Math.PI * 2;
    }
    while (_phase > 0) {
      _phase -= Math.PI * 2;
    }
    _phase = _phase / Math.PI / 2 * waveLength;
    const left2 = cx - radius + _phase - radius * 2;
    path2.push(["M", left2, waterLevel]);
    let waveRight = 0;
    for (let c5 = 0; c5 < curves; ++c5) {
      const stage = c5 % 4;
      const pos = getWaterWavePositions(c5 * waveLength / 4, stage, waveLength, amplitude);
      path2.push([
        "C",
        pos[0][0] + left2,
        -pos[0][1] + waterLevel,
        pos[1][0] + left2,
        -pos[1][1] + waterLevel,
        pos[2][0] + left2,
        -pos[2][1] + waterLevel
      ]);
      if (c5 === curves - 1) {
        waveRight = pos[2][0];
      }
    }
    path2.push(["L", waveRight + left2, cy + radius]);
    path2.push(["L", left2, cy + radius]);
    path2.push(["Z"]);
    return path2;
  }
  function addWave(x3, y3, level, waveCount, waveAttrs, group3, minY, radius, waveLength, animation, document2) {
    const { fill, fillOpacity, opacity } = waveAttrs;
    for (let idx = 0; idx < waveCount; idx++) {
      const factor = waveCount <= 1 ? 1 : idx / (waveCount - 1);
      const path2 = getWaterWavePath(
        radius,
        minY + radius * level,
        waveLength,
        0,
        // Amplitude height.
        radius / 40,
        x3,
        y3
      );
      const wave = document2.createElement("path", {
        style: {
          d: path2,
          fill,
          opacity: lerp5(0.2, 0.9, factor) * Number(opacity || fillOpacity)
        }
      });
      group3.appendChild(wave);
      try {
        if (animation === false)
          return;
        const keyframes = [
          {
            transform: "translate(0, 0)"
          },
          {
            transform: `translate(${waveLength * 2}, 0)`
          }
        ];
        wave.animate(keyframes, {
          duration: lerp5(0.5 * DURATION, DURATION, factor) * 2,
          iterations: Infinity
        });
      } catch (e3) {
        console.warn("off-screen group animate error!");
      }
    }
  }

  // node_modules/@antv/g2/esm/shape/liquid/shapes.js
  function circle2(x3, y3, r) {
    return `
      M ${x3} ${y3 - r} 
      a ${r} ${r} 0 1 0 0 ${r * 2}
      a ${r} ${r} 0 1 0 0 ${-r * 2}
      Z
    `;
  }
  function rect3(x3, y3, r) {
    const GOLDEN_SECTION_RATIO = 0.618;
    const w = r * GOLDEN_SECTION_RATIO;
    return `
      M ${x3 - w} ${y3 - r}
      L ${x3 + w} ${y3 - r}
      L ${x3 + w} ${y3 + r}
      L ${x3 - w} ${y3 + r}
      Z
    `;
  }
  function diamond3(x3, y3, r) {
    return `
      M ${x3} ${y3 - r}
      L ${x3 + r} ${y3}
      L ${x3} ${y3 + r}
      L ${x3 - r} ${y3}
      Z
    `;
  }
  function triangle3(x3, y3, r) {
    return `
      M ${x3} ${y3 - r}
      L ${x3 + r} ${y3 + r}
      L ${x3 - r} ${y3 + r}
      Z
    `;
  }
  function pin(x3, y3, radius) {
    const w = radius * 4 / 3;
    const h = Math.max(w, radius * 2);
    const r = w / 2;
    const cx = x3;
    const cy = r + y3 - h / 2;
    const theta = Math.asin(r / ((h - r) * 0.85));
    const dy = Math.sin(theta) * r;
    const dx = Math.cos(theta) * r;
    const x05 = cx - dx;
    const y05 = cy + dy;
    const cpX = x3;
    const cpY = cy + r / Math.sin(theta);
    return `
      M ${x05} ${y05}
      A ${r} ${r} 0 1 1 ${x05 + dx * 2} ${y05}
      Q ${cpX} ${cpY} ${x3} ${y3 + h / 2}
      Q ${cpX} ${cpY} ${x05} ${y05}
      Z 
    `;
  }
  var LiquidShapesPath = {
    pin,
    rect: rect3,
    circle: circle2,
    diamond: diamond3,
    triangle: triangle3
  };

  // node_modules/@antv/g2/esm/shape/liquid/liquid.js
  var __rest43 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var getLiquidShape = (shape23 = "circle") => LiquidShapesPath[shape23] || LiquidShapesPath.circle;
  var Liquid = (options, context) => {
    if (!context)
      return;
    const { coordinate } = context;
    const { liquidOptions, styleOptions } = options;
    const { liquidShape, percent: percent2 } = liquidOptions;
    const { background: backgroundStyle, outline = {}, wave = {} } = styleOptions, attr2 = __rest43(styleOptions, ["background", "outline", "wave"]);
    const { border = 2, distance: distance7 = 0 } = outline, outlineStyle = __rest43(outline, ["border", "distance"]);
    const { length: length5 = 192, count: count4 = 3 } = wave;
    return (points, cfg, defaultAttr) => {
      const { document: document2 } = context.canvas;
      const { color: color2, fillOpacity } = defaultAttr;
      const attrs = Object.assign(Object.assign({ fill: color2 }, defaultAttr), attr2);
      const g = document2.createElement("g", {});
      const [centerX, centerY] = coordinate.getCenter();
      const size2 = coordinate.getSize();
      const radius = Math.min(...size2) / 2;
      const buildPath = isFunction(liquidShape) ? liquidShape : getLiquidShape(liquidShape);
      const shapePath = buildPath(centerX, centerY, radius, ...size2);
      if (Object.keys(backgroundStyle).length) {
        const backgroundShape = document2.createElement("path", {
          style: Object.assign({ d: shapePath, fill: "#fff" }, backgroundStyle)
        });
        g.appendChild(backgroundShape);
      }
      if (percent2 > 0) {
        const clipShape = document2.createElement("path", {
          style: {
            d: shapePath
          }
        });
        g.appendChild(clipShape);
        g.style.clipPath = clipShape;
        addWave(centerX, centerY, 1 - percent2, count4, attrs, g, clipShape.getBBox().y, radius * 2, length5, true, document2);
      }
      const distanceShape = document2.createElement("path", {
        style: {
          d: shapePath,
          fill: "transparent",
          lineWidth: border + 2 * distance7,
          stroke: "#fff"
        }
      });
      const borderShape = document2.createElement("path", {
        style: Object.assign(Object.assign(Object.assign({ d: shapePath, stroke: color2, strokeOpacity: fillOpacity, lineWidth: border }, attrs), outlineStyle), { fill: "transparent" })
      });
      g.appendChild(distanceShape);
      g.appendChild(borderShape);
      return g;
    };
  };
  Liquid.props = {};

  // node_modules/@antv/g2/esm/shape/gauge/round.js
  var getR = (point1, point22) => {
    return Math.sqrt(Math.pow(point1[0] - point22[0], 2) + Math.pow(point1[1] - point22[1], 2)) / 2;
  };
  var Round = (options, context) => {
    if (!context)
      return;
    const { coordinate } = context;
    if (!(coordinate === null || coordinate === void 0 ? void 0 : coordinate.getCenter))
      return;
    const center2 = coordinate.getCenter();
    return (points, cfg, defaultCfg) => {
      const { document: document2 } = context.canvas;
      const { color: color2, index: index4 } = cfg;
      const g = document2.createElement("g", {});
      const minR = getR(points[0], points[1]);
      const maxR = getR(points[0], center2) * 2;
      const roundPath = document2.createElement("path", {
        style: Object.assign(Object.assign(Object.assign({ d: [
          ["M", ...points[0]],
          ["A", minR, minR, 0, 1, 0, ...points[1]],
          ["A", maxR + minR * 2, maxR + minR * 2, 0, 0, 0, ...points[2]],
          ["A", minR, minR, 0, 1, index4 === 0 ? 0 : 1, ...points[3]],
          ["A", maxR, maxR, 0, 0, 1, ...points[0]],
          ["Z"]
        ] }, defaultCfg), omit_default(options, ["shape", "last", "first"])), { fill: color2 || defaultCfg.color })
      });
      g.appendChild(roundPath);
      return g;
    };
  };

  // node_modules/@antv/g2/esm/mark/interval.js
  function bandWidth2(scale10, x3) {
    return scale10.getBandWidth(scale10.invert(x3));
  }
  var shape = {
    rect: Rect2,
    hollow: Hollow,
    funnel: Funnel,
    pyramid: Pyramid
  };
  var Interval2 = () => {
    return (index4, scale10, value2, coordinate) => {
      const { x: X, y: Y, y1: Y12, series: S, size: SZ } = value2;
      const x3 = scale10.x;
      const series = scale10.series;
      const [width] = coordinate.getSize();
      const NSZ = SZ ? SZ.map((d3) => +d3 / width) : null;
      const x1x2 = !SZ ? (x4, w, i) => [x4, x4 + w] : (x4, w, i) => {
        const mx = x4 + w / 2;
        const s3 = NSZ[i];
        return [mx - s3 / 2, mx + s3 / 2];
      };
      const P = Array.from(index4, (i) => {
        const groupWidth = bandWidth2(x3, X[i]);
        const ratio = series ? bandWidth2(series, S === null || S === void 0 ? void 0 : S[i]) : 1;
        const width2 = groupWidth * ratio;
        const offset3 = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
        const x05 = +X[i] + offset3;
        const [x12, x22] = x1x2(x05, width2, i);
        const y12 = +Y[i];
        const y22 = +Y12[i];
        const p1 = [x12, y12];
        const p2 = [x22, y12];
        const p3 = [x22, y22];
        const p4 = [x12, y22];
        return [p1, p2, p3, p4].map((d3) => coordinate.map(d3));
      });
      return [index4, P];
    };
  };
  Interval2.props = {
    defaultShape: "rect",
    defaultLabelShape: "label",
    composite: false,
    shape,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape) }),
      { name: "x", scale: "band", required: true },
      { name: "y", required: true },
      { name: "series", scale: "band" },
      { name: "size" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeZeroY1 },
      { type: MaybeZeroX }
    ],
    postInference: [...basePostInference(), ...tooltip1d()],
    interaction: { shareTooltip: true }
  };

  // node_modules/@antv/g2/esm/mark/rect.js
  var shape2 = {
    rect: Rect2,
    hollow: Hollow
  };
  var Rect3 = () => {
    return (index4, scale10, value2, coordinate) => {
      const { x: X, x1: X12, y: Y, y1: Y12 } = value2;
      const P = Array.from(index4, (i) => {
        const p1 = [+X[i], +Y[i]];
        const p2 = [+X12[i], +Y[i]];
        const p3 = [+X12[i], +Y12[i]];
        const p4 = [+X[i], +Y12[i]];
        return [p1, p2, p3, p4].map((d3) => coordinate.map(d3));
      });
      return [index4, P];
    };
  };
  Rect3.props = {
    defaultShape: "rect",
    defaultLabelShape: "label",
    composite: false,
    shape: shape2,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape2) }),
      { name: "x", required: true },
      { name: "y", required: true }
    ],
    preInference: [...basePreInference(), { type: MaybeZeroY1 }],
    postInference: [...basePostInference(), ...tooltip1d()],
    interaction: {
      shareTooltip: true
    }
  };

  // node_modules/@antv/g2/esm/mark/line.js
  var shape3 = {
    line: Line2,
    smooth: Smooth,
    hv: HV,
    vh: VH,
    hvh: HVH,
    trail: Trail
  };
  var line3 = (index4, scale10, value2, coordinate) => {
    var _a, _b;
    const { series: S, x: X, y: Y } = value2;
    const { x: x3, y: y3 } = scale10;
    if (X === void 0 || Y === void 0) {
      throw new Error("Missing encode for x or y channel.");
    }
    const series = S ? Array.from(group(index4, (i) => S[i]).values()) : [index4];
    const I = series.map((group3) => group3[0]).filter((i) => i !== void 0);
    const xoffset = (((_a = x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(x3)) || 0) / 2;
    const yoffset = (((_b = y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y3)) || 0) / 2;
    const P = Array.from(series, (I2) => {
      return I2.map((i) => coordinate.map([+X[i] + xoffset, +Y[i] + yoffset]));
    });
    return [I, P, series];
  };
  var parallel = (index4, scale10, value2, coordinate) => {
    const PV = Object.entries(value2).filter(([key]) => key.startsWith("position")).map(([, value3]) => value3);
    if (PV.length === 0) {
      throw new Error("Missing encode for position channel.");
    }
    const P = Array.from(index4, (i) => {
      const vector = PV.map((pv) => +pv[i]);
      const vectors = coordinate.map(vector);
      const points = [];
      for (let i2 = 0; i2 < vectors.length; i2 += 2) {
        points.push([vectors[i2], vectors[i2 + 1]]);
      }
      return points;
    });
    return [index4, P];
  };
  var Line5 = () => {
    return (index4, scale10, value2, coordinate) => {
      const mark = isParallel(coordinate) ? parallel : line3;
      return mark(index4, scale10, value2, coordinate);
    };
  };
  Line5.props = {
    defaultShape: "line",
    defaultLabelShape: "label",
    composite: false,
    shape: shape3,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape3) }),
      { name: "x" },
      { name: "y" },
      { name: "position", independent: true },
      { name: "size" },
      { name: "series", scale: "band" }
    ],
    preInference: [
      ...basePreInference(),
      // !!!Note This order is very important.
      { type: MaybeGradient },
      { type: MaybeSeries }
    ],
    postInference: [...basePostInference(), ...tooltip1d(), ...tooltipXd()],
    interaction: {
      shareTooltip: true,
      seriesTooltip: true,
      crosshairs: true
    }
  };

  // node_modules/@antv/g2/esm/mark/point.js
  var shape4 = {
    hollow: HollowPoint,
    hollowDiamond: HollowDiamond,
    hollowHexagon: HollowHexagon,
    hollowSquare: HollowSquare,
    hollowTriangleDown: HollowTriangleDown,
    hollowTriangle: HollowTriangle,
    hollowBowtie: HollowBowtie,
    hollowCircle: HollowCircle,
    point: Point3,
    plus: Plus,
    diamond: Diamond,
    square: Square,
    triangle: Triangle,
    hexagon: Hexagon,
    cross: Cross,
    bowtie: Bowtie,
    hyphen: Hyphen,
    line: Line3,
    tick: Tick,
    triangleDown: TriangleDown,
    circle: Circle2
  };
  var Point4 = (options) => {
    return (index4, scale10, value2, coordinate) => {
      const { x: X, y: Y, x1: X12, y1: Y12, size: S, dx: DX, dy: DY } = value2;
      const [width, height] = coordinate.getSize();
      const offset3 = createBandOffset(scale10, value2, options);
      const xy = (i) => {
        const dx = +((DX === null || DX === void 0 ? void 0 : DX[i]) || 0);
        const dy = +((DY === null || DY === void 0 ? void 0 : DY[i]) || 0);
        const x3 = X12 ? (+X[i] + +X12[i]) / 2 : +X[i];
        const y3 = Y12 ? (+Y[i] + +Y12[i]) / 2 : +Y[i];
        const cx = x3 + dx;
        const cy = y3 + dy;
        return [cx, cy];
      };
      const P = S ? Array.from(index4, (i) => {
        const [cx, cy] = xy(i);
        const r = +S[i];
        const a3 = r / width;
        const b = r / height;
        const p1 = [cx - a3, cy - b];
        const p2 = [cx + a3, cy + b];
        return [
          coordinate.map(offset3(p1, i)),
          coordinate.map(offset3(p2, i))
        ];
      }) : Array.from(index4, (i) => [coordinate.map(offset3(xy(i), i))]);
      return [index4, P];
    };
  };
  Point4.props = {
    defaultShape: "hollow",
    defaultLabelShape: "label",
    composite: false,
    shape: shape4,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape4) }),
      { name: "x", required: true },
      { name: "y", required: true },
      { name: "series", scale: "band" },
      { name: "size", quantitative: "sqrt" },
      { name: "dx", scale: "identity" },
      { name: "dy", scale: "identity" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeZeroX },
      { type: MaybeZeroY }
    ],
    postInference: [...basePostInference(), { type: MaybeSize }, ...tooltip2d()]
  };

  // node_modules/@antv/g2/esm/mark/text.js
  var shape5 = {
    text: Text3,
    badge: Badge,
    tag: Tag
  };
  var Text4 = (options) => {
    const { cartesian: cartesian2 = false } = options;
    if (cartesian2)
      return visualMark;
    return (index4, scale10, value2, coordinate) => {
      const { x: X, y: Y } = value2;
      const offset3 = createBandOffset(scale10, value2, options);
      const P = Array.from(index4, (i) => {
        const p2 = [+X[i], +Y[i]];
        return [coordinate.map(offset3(p2, i))];
      });
      return [index4, P];
    };
  };
  Text4.props = {
    defaultShape: "text",
    defaultLabelShape: "label",
    composite: false,
    shape: shape5,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape5) }),
      { name: "x", required: true },
      { name: "y", required: true },
      { name: "text", scale: "identity" },
      { name: "fontSize", scale: "identity" },
      { name: "rotate", scale: "identity" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeTuple },
      { type: MaybeVisualPosition }
    ],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // node_modules/@antv/g2/esm/mark/cell.js
  var shape6 = {
    cell: Rect2,
    hollow: Hollow
  };
  var Cell = () => {
    return (index4, scale10, value2, coordinate) => {
      const { x: X, y: Y } = value2;
      const x3 = scale10.x;
      const y3 = scale10.y;
      const P = Array.from(index4, (i) => {
        const width = x3.getBandWidth(x3.invert(+X[i]));
        const height = y3.getBandWidth(y3.invert(+Y[i]));
        const x12 = +X[i];
        const y12 = +Y[i];
        const p1 = [x12, y12];
        const p2 = [x12 + width, y12];
        const p3 = [x12 + width, y12 + height];
        const p4 = [x12, y12 + height];
        return [p1, p2, p3, p4].map((d3) => coordinate.map(d3));
      });
      return [index4, P];
    };
  };
  Cell.props = {
    defaultShape: "cell",
    defaultLabelShape: "label",
    shape: shape6,
    composite: false,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape6) }),
      { name: "x", required: true, scale: "band" },
      { name: "y", required: true, scale: "band" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeZeroX },
      { type: MaybeZeroY },
      { type: MaybeZeroPadding }
    ],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // node_modules/@antv/g2/esm/mark/area.js
  var shape7 = {
    area: Area,
    smooth: Smooth2,
    hvh: HVH2,
    vh: VH2,
    hv: HV2
  };
  var Area2 = () => {
    return (index4, scale10, value2, coordinate) => {
      var _a, _b;
      const { x: X, y: Y, y1: Y12, series: S } = value2;
      const { x: x3, y: y3 } = scale10;
      const series = S ? Array.from(group(index4, (i) => S[i]).values()) : [index4];
      const I = series.map((group3) => group3[0]).filter((i) => i !== void 0);
      const xoffset = (((_a = x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(x3)) || 0) / 2;
      const yoffset = (((_b = y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y3)) || 0) / 2;
      const P = Array.from(series, (SI) => {
        const l2 = SI.length;
        const points = new Array(l2 * 2);
        for (let idx = 0; idx < SI.length; idx++) {
          const i = SI[idx];
          points[idx] = coordinate.map([+X[i] + xoffset, +Y[i] + yoffset]);
          points[l2 + idx] = coordinate.map([+X[i] + xoffset, +Y12[i] + yoffset]);
        }
        return points;
      });
      return [I, P, series];
    };
  };
  Area2.props = {
    defaultShape: "area",
    defaultLabelShape: "label",
    composite: false,
    shape: shape7,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape7) }),
      { name: "x", required: true },
      { name: "y", required: true },
      { name: "size" },
      { name: "series", scale: "band" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeSeries },
      { type: MaybeZeroY1 },
      { type: MaybeZeroPadding }
    ],
    postInference: [...basePostInference(), ...tooltip1d()],
    interaction: {
      shareTooltip: true,
      seriesTooltip: true,
      crosshairs: true
    }
  };

  // node_modules/@antv/g2/esm/mark/link.js
  var shape8 = {
    link: Link,
    arc: Arc,
    smooth: Smooth3,
    vhv: VHV
  };
  var Link2 = (options) => {
    return (index4, scale10, value2, coordinate) => {
      const { x: X, y: Y, x1: X12 = X, y1: Y12 = Y } = value2;
      const offset3 = createBandOffset(scale10, value2, options);
      const P = index4.map((i) => [
        coordinate.map(offset3([+X[i], +Y[i]], i)),
        coordinate.map(offset3([+X12[i], +Y12[i]], i))
      ]);
      return [index4, P];
    };
  };
  Link2.props = {
    defaultShape: "link",
    defaultLabelShape: "label",
    composite: false,
    shape: shape8,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape8) }),
      { name: "x", required: true },
      { name: "y", required: true }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeIdentityY },
      { type: MaybeIdentityX }
    ],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // node_modules/@antv/g2/esm/mark/image.js
  var shape9 = {
    image: Image3
  };
  var Image4 = (options) => {
    const { cartesian: cartesian2 } = options;
    if (cartesian2)
      return visualMark;
    return (index4, scale10, value2, coordinate) => {
      const { x: X, y: Y } = value2;
      const offset3 = createBandOffset(scale10, value2, options);
      const P = Array.from(index4, (i) => {
        const p2 = [+X[i], +Y[i]];
        return [coordinate.map(offset3(p2, i))];
      });
      return [index4, P];
    };
  };
  Image4.props = {
    defaultShape: "image",
    defaultLabelShape: "label",
    composite: false,
    shape: shape9,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape9) }),
      { name: "x", required: true },
      { name: "y", required: true },
      { name: "src", scale: "identity" },
      { name: "size" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeTuple },
      { type: MaybeVisualPosition }
    ],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // node_modules/@antv/g2/esm/mark/polygon.js
  var shape10 = {
    polygon: Polygon2,
    ribbon: Ribbon2
  };
  var Polygon3 = () => {
    return (index4, scale10, value2, coordinate) => {
      const Xn = Object.entries(value2).filter(([key]) => key.startsWith("x")).map(([, value3]) => value3);
      const Yn = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
      const P = index4.map((i) => {
        const Pn = [];
        for (let j = 0; j < Xn.length; j++) {
          const x3 = Xn[j][i];
          if (x3 === void 0)
            break;
          const y3 = Yn[j][i];
          Pn.push(coordinate.map([+x3, +y3]));
        }
        return Pn;
      });
      return [index4, P];
    };
  };
  Polygon3.props = {
    defaultShape: "polygon",
    defaultLabelShape: "label",
    composite: false,
    shape: shape10,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape10) }),
      { name: "x", required: true },
      { name: "y", required: true }
    ],
    preInference: [...basePreInference()],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // node_modules/@antv/g2/esm/mark/box.js
  var shape11 = {
    box: Box,
    violin: Violin
  };
  var Box2 = () => {
    return (index4, scale10, value2, coordinate) => {
      const { x: X, y: Y, y1: Y12, y2: Y22, y3: Y3, y4: Y4, series: S } = value2;
      const xScale = scale10.x;
      const series = scale10.series;
      const P = Array.from(index4, (i) => {
        const groupWidth = xScale.getBandWidth(xScale.invert(+X[i]));
        const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i]))) : 1;
        const width = groupWidth * ratio;
        const offset3 = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
        const x3 = +X[i] + offset3 + width / 2;
        const [low, q12, median3, q32, high] = [
          +Y[i],
          +Y12[i],
          +Y22[i],
          +Y3[i],
          +Y4[i]
        ];
        const P13 = [
          [x3 - width / 2, high],
          [x3 + width / 2, high],
          [x3, high],
          [x3, q32],
          [x3 - width / 2, q32],
          [x3 + width / 2, q32],
          [x3 + width / 2, q12],
          [x3 - width / 2, q12],
          [x3 - width / 2, median3],
          [x3 + width / 2, median3],
          [x3, q12],
          [x3, low],
          [x3 - width / 2, low],
          [x3 + width / 2, low]
        ];
        return P13.map((d3) => coordinate.map(d3));
      });
      return [index4, P];
    };
  };
  Box2.props = {
    defaultShape: "box",
    defaultLabelShape: "label",
    composite: false,
    shape: shape11,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape11) }),
      { name: "x", scale: "band", required: true },
      { name: "y", required: true },
      { name: "series", scale: "band" }
    ],
    preInference: [...basePreInference(), { type: MaybeZeroX }],
    postInference: [...basePostInference(), ...tooltip1d()],
    interaction: {
      shareTooltip: true
    }
  };

  // node_modules/@antv/g2/esm/mark/vector.js
  var shape12 = {
    vector: Vector
  };
  var Vector2 = () => {
    return (index4, scale10, value2, coordinate) => {
      const { x: X, y: Y, size: S, rotate: R } = value2;
      const [width, height] = coordinate.getSize();
      const P = index4.map((i) => {
        const angle4 = +R[i] / 180 * Math.PI;
        const s3 = +S[i];
        const a3 = s3 / width;
        const b = s3 / height;
        const vx = a3 * Math.cos(angle4);
        const vy = -b * Math.sin(angle4);
        return [
          coordinate.map([+X[i] - vx / 2, +Y[i] - vy / 2]),
          coordinate.map([+X[i] + vx / 2, +Y[i] + vy / 2])
        ];
      });
      return [index4, P];
    };
  };
  Vector2.props = {
    defaultShape: "vector",
    defaultLabelShape: "label",
    composite: false,
    shape: shape12,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape12) }),
      { name: "x", required: true },
      { name: "y", required: true },
      { name: "rotate", required: true, scale: "identity" },
      { name: "size", required: true }
    ],
    preInference: [...basePreInference()],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // node_modules/@antv/g2/esm/mark/lineY.js
  var shape13 = {
    line: Line4
  };
  var LineY = (options) => {
    return (index4, scale10, value2, coordinate) => {
      const { y: Y } = value2;
      const offset3 = createBandOffset(scale10, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
      const P = Array.from(index4, (i) => {
        const p1 = [0, Y[i]];
        const p2 = [1, Y[i]];
        return [p1, p2].map((d3) => coordinate.map(offset3(d3, i)));
      });
      return [index4, P];
    };
  };
  LineY.props = {
    defaultShape: "line",
    defaultLabelShape: "label",
    composite: false,
    shape: shape13,
    channels: [
      ...baseAnnotationChannels({ shapes: Object.keys(shape13) }),
      { name: "y", required: true }
    ],
    preInference: [...basePreInference(), { type: MaybeTupleY }],
    postInference: [...basePostInference()]
  };

  // node_modules/@antv/g2/esm/mark/lineX.js
  var shape14 = {
    line: Line4
  };
  var LineX = (options) => {
    return (index4, scale10, value2, coordinate) => {
      const { x: X } = value2;
      const offset3 = createBandOffset(scale10, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
      const P = Array.from(index4, (i) => {
        const p1 = [X[i], 1];
        const p2 = [X[i], 0];
        return [p1, p2].map((d3) => coordinate.map(offset3(d3, i)));
      });
      return [index4, P];
    };
  };
  LineX.props = {
    defaultShape: "line",
    defaultLabelShape: "label",
    composite: false,
    shape: shape14,
    channels: [
      ...baseAnnotationChannels({ shapes: Object.keys(shape14) }),
      { name: "x", required: true }
    ],
    preInference: [...basePreInference(), { type: MaybeTupleX }],
    postInference: [...basePostInference()]
  };

  // node_modules/@antv/g2/esm/mark/connector.js
  var shape15 = {
    connector: Connector
  };
  var Connector2 = (...args) => {
    return Link2(...args);
  };
  Connector2.props = {
    defaultShape: "connector",
    defaultLabelShape: "label",
    composite: false,
    shape: shape15,
    channels: [
      ...baseAnnotationChannels({ shapes: Object.keys(shape15) }),
      { name: "x", required: true },
      { name: "y", required: true }
    ],
    preInference: [...basePreInference()],
    postInference: [...basePostInference()]
  };

  // node_modules/@antv/g2/esm/mark/range.js
  function extend5(channel, extended, value2, scale10) {
    if (extended)
      return () => [0, 1];
    const { [channel]: C4, [`${channel}1`]: C1 } = value2;
    return (i) => {
      var _a;
      const offset3 = ((_a = scale10.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scale10, scale10.invert(+C1[i]))) || 0;
      return [C4[i], C1[i] + offset3];
    };
  }
  function AbstractRange(options = {}) {
    const { extendX = false, extendY = false } = options;
    return (index4, scale10, value2, coordinate) => {
      const x3 = extend5("x", extendX, value2, scale10.x);
      const y3 = extend5("y", extendY, value2, scale10.y);
      const P = Array.from(index4, (i) => {
        const [x12, x22] = x3(i);
        const [y12, y22] = y3(i);
        const p1 = [x12, y12];
        const p2 = [x22, y12];
        const p3 = [x22, y22];
        const p4 = [x12, y22];
        return [p1, p2, p3, p4].map((d3) => coordinate.map(d3));
      });
      return [index4, P];
    };
  }
  var shape16 = { range: Rect2 };
  var Range = () => {
    return AbstractRange();
  };
  Range.props = {
    defaultShape: "range",
    defaultLabelShape: "label",
    composite: false,
    shape: shape16,
    channels: [
      ...baseAnnotationChannels({ shapes: Object.keys(shape16) }),
      { name: "x", required: true },
      { name: "y", required: true }
    ],
    preInference: [...basePreInference()],
    postInference: [...basePostInference()]
  };

  // node_modules/@antv/g2/esm/mark/rangeX.js
  var shape17 = {
    range: Rect2
  };
  var RangeX = () => {
    return AbstractRange({ extendY: true });
  };
  RangeX.props = {
    defaultShape: "range",
    defaultLabelShape: "label",
    composite: false,
    shape: shape17,
    channels: [
      ...baseAnnotationChannels({ shapes: Object.keys(shape17) }),
      { name: "x", required: true }
    ],
    preInference: [...basePreInference(), { type: MaybeDefaultX }],
    postInference: [...basePostInference()]
  };

  // node_modules/@antv/g2/esm/mark/rangeY.js
  var shape18 = {
    range: Rect2
  };
  var RangeY = () => {
    return AbstractRange({ extendX: true });
  };
  RangeY.props = {
    defaultShape: "range",
    defaultLabelShape: "label",
    composite: false,
    shape: shape18,
    channels: [
      ...baseAnnotationChannels({ shapes: Object.keys(shape18) }),
      { name: "y", required: true }
    ],
    preInference: [...basePreInference(), { type: MaybeDefaultY }],
    postInference: [...basePostInference()]
  };

  // node_modules/@antv/g2/esm/data/utils/d3-sankey/align.js
  function targetDepth(d3) {
    return d3.target.depth;
  }
  function left(node) {
    return node.depth;
  }
  function right(node, n2) {
    return n2 - 1 - node.height;
  }
  function justify(node, n2) {
    return node.sourceLinks.length ? node.depth : n2 - 1;
  }
  function center(node) {
    return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min4(node.sourceLinks, targetDepth) - 1 : 0;
  }

  // node_modules/@antv/g2/esm/data/utils/d3-sankey/constant.js
  function constant3(x3) {
    return function() {
      return x3;
    };
  }

  // node_modules/@antv/g2/esm/data/utils/d3-sankey/sankey.js
  function ascendingSourceBreadth(a3, b) {
    return ascendingBreadth(a3.source, b.source) || a3.index - b.index;
  }
  function ascendingTargetBreadth(a3, b) {
    return ascendingBreadth(a3.target, b.target) || a3.index - b.index;
  }
  function ascendingBreadth(a3, b) {
    return a3.y0 - b.y0;
  }
  function value(d3) {
    return d3.value;
  }
  function defaultId(d3) {
    return d3.index;
  }
  function defaultNodes(graph) {
    return graph.nodes;
  }
  function defaultLinks(graph) {
    return graph.links;
  }
  function find5(nodeById, id5) {
    const node = nodeById.get(id5);
    if (!node)
      throw new Error("missing: " + id5);
    return node;
  }
  function computeLinkBreadths({ nodes }) {
    for (const node of nodes) {
      let y05 = node.y0;
      let y12 = y05;
      for (const link2 of node.sourceLinks) {
        link2.y0 = y05 + link2.width / 2;
        y05 += link2.width;
      }
      for (const link2 of node.targetLinks) {
        link2.y1 = y12 + link2.width / 2;
        y12 += link2.width;
      }
    }
  }
  function Sankey() {
    let x05 = 0, y05 = 0, x12 = 1, y12 = 1;
    let dx = 24;
    let dy = 8, py;
    let id5 = defaultId;
    let align = justify;
    let depth;
    let sort3;
    let linkSort;
    let nodes = defaultNodes;
    let links = defaultLinks;
    let iterations2 = 6;
    function sankey(arg) {
      const graph = {
        nodes: nodes(arg),
        links: links(arg)
      };
      computeNodeLinks(graph);
      computeNodeValues(graph);
      computeNodeDepths(graph);
      computeNodeHeights(graph);
      computeNodeBreadths(graph);
      computeLinkBreadths(graph);
      return graph;
    }
    sankey.update = function(graph) {
      computeLinkBreadths(graph);
      return graph;
    };
    sankey.nodeId = function(_2) {
      return arguments.length ? (id5 = typeof _2 === "function" ? _2 : constant3(_2), sankey) : id5;
    };
    sankey.nodeAlign = function(_2) {
      return arguments.length ? (align = typeof _2 === "function" ? _2 : constant3(_2), sankey) : align;
    };
    sankey.nodeDepth = function(_2) {
      return arguments.length ? (depth = typeof _2 === "function" ? _2 : _2, sankey) : depth;
    };
    sankey.nodeSort = function(_2) {
      return arguments.length ? (sort3 = _2, sankey) : sort3;
    };
    sankey.nodeWidth = function(_2) {
      return arguments.length ? (dx = +_2, sankey) : dx;
    };
    sankey.nodePadding = function(_2) {
      return arguments.length ? (dy = py = +_2, sankey) : dy;
    };
    sankey.nodes = function(_2) {
      return arguments.length ? (nodes = typeof _2 === "function" ? _2 : constant3(_2), sankey) : nodes;
    };
    sankey.links = function(_2) {
      return arguments.length ? (links = typeof _2 === "function" ? _2 : constant3(_2), sankey) : links;
    };
    sankey.linkSort = function(_2) {
      return arguments.length ? (linkSort = _2, sankey) : linkSort;
    };
    sankey.size = function(_2) {
      return arguments.length ? (x05 = y05 = 0, x12 = +_2[0], y12 = +_2[1], sankey) : [x12 - x05, y12 - y05];
    };
    sankey.extent = function(_2) {
      return arguments.length ? (x05 = +_2[0][0], x12 = +_2[1][0], y05 = +_2[0][1], y12 = +_2[1][1], sankey) : [
        [x05, y05],
        [x12, y12]
      ];
    };
    sankey.iterations = function(_2) {
      return arguments.length ? (iterations2 = +_2, sankey) : iterations2;
    };
    function computeNodeLinks({ nodes: nodes2, links: links2 }) {
      nodes2.forEach((node, idx) => {
        node.index = idx;
        node.sourceLinks = [];
        node.targetLinks = [];
      });
      const nodeById = new Map(nodes2.map((d3) => [id5(d3), d3]));
      links2.forEach((link2, idx) => {
        link2.index = idx;
        let { source, target } = link2;
        if (typeof source !== "object")
          source = link2.source = find5(nodeById, source);
        if (typeof target !== "object")
          target = link2.target = find5(nodeById, target);
        source.sourceLinks.push(link2);
        target.targetLinks.push(link2);
      });
      if (linkSort != null) {
        for (const { sourceLinks, targetLinks } of nodes2) {
          sourceLinks.sort(linkSort);
          targetLinks.sort(linkSort);
        }
      }
    }
    function computeNodeValues({ nodes: nodes2 }) {
      for (const node of nodes2) {
        node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
      }
    }
    function computeNodeDepths({ nodes: nodes2 }) {
      const n2 = nodes2.length;
      let current = new Set(nodes2);
      let next = /* @__PURE__ */ new Set();
      let x3 = 0;
      while (current.size) {
        current.forEach((node) => {
          node.depth = x3;
          for (const { target } of node.sourceLinks) {
            next.add(target);
          }
        });
        if (++x3 > n2)
          throw new Error("circular link");
        current = next;
        next = /* @__PURE__ */ new Set();
      }
      if (depth) {
        const maxDepth2 = Math.max(max5(nodes2, (d3) => d3.depth) + 1, 0);
        let node;
        for (let i = 0; i < nodes2.length; i++) {
          node = nodes2[i];
          node.depth = depth.call(null, node, maxDepth2);
        }
      }
    }
    function computeNodeHeights({ nodes: nodes2 }) {
      const n2 = nodes2.length;
      let current = new Set(nodes2);
      let next = /* @__PURE__ */ new Set();
      let x3 = 0;
      while (current.size) {
        current.forEach((node) => {
          node.height = x3;
          for (const { source } of node.targetLinks) {
            next.add(source);
          }
        });
        if (++x3 > n2)
          throw new Error("circular link");
        current = next;
        next = /* @__PURE__ */ new Set();
      }
    }
    function computeNodeLayers({ nodes: nodes2 }) {
      const x3 = Math.max(max5(nodes2, (d3) => d3.depth) + 1, 0);
      const kx = (x12 - x05 - dx) / (x3 - 1);
      const columns = new Array(x3).fill(0).map(() => []);
      for (const node of nodes2) {
        const i = Math.max(0, Math.min(x3 - 1, Math.floor(align.call(null, node, x3))));
        node.layer = i;
        node.x0 = x05 + i * kx;
        node.x1 = node.x0 + dx;
        if (columns[i])
          columns[i].push(node);
        else
          columns[i] = [node];
      }
      if (sort3)
        for (const column2 of columns) {
          column2.sort(sort3);
        }
      return columns;
    }
    function initializeNodeBreadths(columns) {
      const ky = min4(columns, (c5) => (y12 - y05 - (c5.length - 1) * py) / sum(c5, value));
      for (const nodes2 of columns) {
        let y3 = y05;
        for (const node of nodes2) {
          node.y0 = y3;
          node.y1 = y3 + node.value * ky;
          y3 = node.y1 + py;
          for (const link2 of node.sourceLinks) {
            link2.width = link2.value * ky;
          }
        }
        y3 = (y12 - y3 + py) / (nodes2.length + 1);
        for (let i = 0; i < nodes2.length; ++i) {
          const node = nodes2[i];
          node.y0 += y3 * (i + 1);
          node.y1 += y3 * (i + 1);
        }
        reorderLinks(nodes2);
      }
    }
    function computeNodeBreadths(graph) {
      const columns = computeNodeLayers(graph);
      py = Math.min(dy, (y12 - y05) / (max5(columns, (c5) => c5.length) - 1));
      initializeNodeBreadths(columns);
      for (let i = 0; i < iterations2; ++i) {
        const alpha = Math.pow(0.99, i);
        const beta = Math.max(1 - alpha, (i + 1) / iterations2);
        relaxRightToLeft(columns, alpha, beta);
        relaxLeftToRight(columns, alpha, beta);
      }
    }
    function relaxLeftToRight(columns, alpha, beta) {
      for (let i = 1, n2 = columns.length; i < n2; ++i) {
        const column2 = columns[i];
        for (const target of column2) {
          let y3 = 0;
          let w = 0;
          for (const { source, value: value2 } of target.targetLinks) {
            const v = value2 * (target.layer - source.layer);
            y3 += targetTop(source, target) * v;
            w += v;
          }
          if (!(w > 0))
            continue;
          const dy2 = (y3 / w - target.y0) * alpha;
          target.y0 += dy2;
          target.y1 += dy2;
          reorderNodeLinks(target);
        }
        if (sort3 === void 0)
          column2.sort(ascendingBreadth);
        if (column2.length)
          resolveCollisions(column2, beta);
      }
    }
    function relaxRightToLeft(columns, alpha, beta) {
      for (let n2 = columns.length, i = n2 - 2; i >= 0; --i) {
        const column2 = columns[i];
        for (const source of column2) {
          let y3 = 0;
          let w = 0;
          for (const { target, value: value2 } of source.sourceLinks) {
            const v = value2 * (target.layer - source.layer);
            y3 += sourceTop(source, target) * v;
            w += v;
          }
          if (!(w > 0))
            continue;
          const dy2 = (y3 / w - source.y0) * alpha;
          source.y0 += dy2;
          source.y1 += dy2;
          reorderNodeLinks(source);
        }
        if (sort3 === void 0)
          column2.sort(ascendingBreadth);
        if (column2.length)
          resolveCollisions(column2, beta);
      }
    }
    function resolveCollisions(nodes2, alpha) {
      const i = nodes2.length >> 1;
      const subject = nodes2[i];
      resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
      resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
      resolveCollisionsBottomToTop(nodes2, y12, nodes2.length - 1, alpha);
      resolveCollisionsTopToBottom(nodes2, y05, 0, alpha);
    }
    function resolveCollisionsTopToBottom(nodes2, y3, i, alpha) {
      for (; i < nodes2.length; ++i) {
        const node = nodes2[i];
        const dy2 = (y3 - node.y0) * alpha;
        if (dy2 > 1e-6)
          node.y0 += dy2, node.y1 += dy2;
        y3 = node.y1 + py;
      }
    }
    function resolveCollisionsBottomToTop(nodes2, y3, i, alpha) {
      for (; i >= 0; --i) {
        const node = nodes2[i];
        const dy2 = (node.y1 - y3) * alpha;
        if (dy2 > 1e-6)
          node.y0 -= dy2, node.y1 -= dy2;
        y3 = node.y0 - py;
      }
    }
    function reorderNodeLinks({ sourceLinks, targetLinks }) {
      if (linkSort === void 0) {
        for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
          sourceLinks2.sort(ascendingTargetBreadth);
        }
        for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
          targetLinks2.sort(ascendingSourceBreadth);
        }
      }
    }
    function reorderLinks(nodes2) {
      if (linkSort === void 0) {
        for (const { sourceLinks, targetLinks } of nodes2) {
          sourceLinks.sort(ascendingTargetBreadth);
          targetLinks.sort(ascendingSourceBreadth);
        }
      }
    }
    function targetTop(source, target) {
      let y3 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
      for (const { target: node, width } of source.sourceLinks) {
        if (node === target)
          break;
        y3 += width + py;
      }
      for (const { source: node, width } of target.targetLinks) {
        if (node === source)
          break;
        y3 -= width;
      }
      return y3;
    }
    function sourceTop(source, target) {
      let y3 = target.y0 - (target.targetLinks.length - 1) * py / 2;
      for (const { source: node, width } of target.targetLinks) {
        if (node === source)
          break;
        y3 += width + py;
      }
      for (const { target: node, width } of source.sourceLinks) {
        if (node === target)
          break;
        y3 -= width;
      }
      return y3;
    }
    return sankey;
  }

  // node_modules/@antv/g2/esm/data/sankey.js
  var DEFAULT_OPTIONS = {
    nodeAlign: "justify",
    nodeWidth: 8e-3,
    nodePadding: 0.03,
    nodes: (graph) => graph.nodes,
    links: (graph) => graph.links,
    nodeSort: void 0,
    linkSort: void 0,
    iterations: 6
  };
  var ALIGN_METHOD = {
    left,
    right,
    center,
    justify
  };
  function getNodeAlignFunction(nodeAlign) {
    const type = typeof nodeAlign;
    if (type === "string")
      return ALIGN_METHOD[nodeAlign] || justify;
    if (type === "function")
      return nodeAlign;
    return justify;
  }
  var Sankey2 = (options) => {
    return (data2) => {
      const { nodeId, nodeSort, nodeAlign, nodeWidth, nodePadding, nodeDepth, nodes: nodeNodes, links: nodeLinks, linkSort, iterations: iterations2 } = Object.assign({}, DEFAULT_OPTIONS, options);
      const sankeyProcessor = Sankey().nodeSort(nodeSort).linkSort(linkSort).links(nodeLinks).nodes(nodeNodes).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).iterations(iterations2).extent([
        [0, 0],
        [1, 1]
      ]);
      if (typeof nodeId === "function") {
        sankeyProcessor.nodeId(nodeId);
      }
      const layoutData = sankeyProcessor(data2);
      const { nodes: N, links: L } = layoutData;
      const nodes = N.map((node) => {
        const { x0: x05, x1: x12, y0: y05, y1: y12 } = node;
        return Object.assign(Object.assign({}, node), { x: [x05, x12, x12, x05], y: [y05, y05, y12, y12] });
      });
      const links = L.map((edge) => {
        const { source, target } = edge;
        const sx = source.x1;
        const tx = target.x0;
        const offset3 = edge.width / 2;
        return Object.assign(Object.assign({}, edge), { x: [sx, sx, tx, tx], y: [
          edge.y0 + offset3,
          edge.y0 - offset3,
          edge.y1 + offset3,
          edge.y1 - offset3
        ] });
      });
      return { nodes, links };
    };
  };
  Sankey2.props = {};

  // node_modules/@antv/g2/esm/utils/mark.js
  function subTooltip(tooltip2, name2, defaults5 = {}, main = false) {
    if (isUnset(tooltip2))
      return tooltip2;
    if (Array.isArray(tooltip2) && main)
      return tooltip2;
    const sub8 = subObject(tooltip2, name2);
    return deep_mix_default(defaults5, sub8);
  }
  function maybeTooltip(tooltip2, defaults5 = {}) {
    if (isUnset(tooltip2))
      return tooltip2;
    if (Array.isArray(tooltip2))
      return tooltip2;
    if (!isFullTooltip(tooltip2))
      return tooltip2;
    return deep_mix_default(defaults5, tooltip2);
  }
  function isFullTooltip(tooltip2) {
    if (Object.keys(tooltip2).length === 0)
      return true;
    const { title, items } = tooltip2;
    return title !== void 0 || items !== void 0;
  }
  function maybeAnimation(animate2, sub8) {
    return typeof animate2 === "object" ? subObject(animate2, sub8) : animate2;
  }

  // node_modules/@antv/g2/esm/mark/sankey.js
  var __rest44 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var DEFAULT_LAYOUT_OPTIONS = {
    nodeId: (d3) => d3.key,
    nodeWidth: 0.02,
    nodePadding: 0.02
  };
  var DEFAULT_NODE_OPTIONS = {
    type: "polygon",
    axis: false,
    legend: false,
    encode: {
      shape: "polygon",
      x: "x",
      y: "y"
    },
    scale: {
      x: { type: "identity" },
      y: { type: "identity" }
    },
    style: {
      stroke: "#000"
    }
  };
  var DEFAULT_LINK_OPTIONS = {
    type: "polygon",
    axis: false,
    legend: false,
    encode: {
      shape: "ribbon",
      x: "x",
      y: "y"
    },
    style: {
      fillOpacity: 0.5,
      stroke: void 0
    }
  };
  var DEFAULT_LABEL_OPTIONS = {
    textAlign: (d3) => d3.x[0] < 0.5 ? "start" : "end",
    position: (d3) => d3.x[0] < 0.5 ? "right" : "left",
    fontSize: 10
  };
  var Sankey3 = (options) => {
    const { data: data2, encode = {}, scale: scale10, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {}, interaction } = options;
    const { links, nodes } = initializeData(data2, encode);
    const nodeEncode = subObject(encode, "node");
    const linkEncode = subObject(encode, "link");
    const { key: nodeKey = (d3) => d3.key, color: color2 = nodeKey } = nodeEncode;
    const { links: linkData, nodes: nodeData } = Sankey2(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS), { nodeId: field(nodeKey) }), layout))({ links, nodes });
    const _a = subObject(style, "label"), { text = nodeKey, spacing = 5 } = _a, labelStyle = __rest44(_a, ["text", "spacing"]);
    const key1 = field(nodeKey);
    const nodeTooltip = subTooltip(tooltip2, "node", {
      title: key1,
      items: [{ field: "value" }]
    }, true);
    const linkTooltip = subTooltip(tooltip2, "link", {
      title: "",
      items: [
        (d3) => ({ name: "source", value: key1(d3.source) }),
        (d3) => ({ name: "target", value: key1(d3.target) })
      ]
    });
    return [
      deep_mix_default({}, DEFAULT_NODE_OPTIONS, {
        data: nodeData,
        encode: Object.assign(Object.assign({}, nodeEncode), { color: color2 }),
        scale: scale10,
        style: subObject(style, "node"),
        labels: [
          Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS), { text, dx: (d3) => d3.x[0] < 0.5 ? spacing : -spacing }), labelStyle),
          ...nodeLabels
        ],
        tooltip: nodeTooltip,
        animate: maybeAnimation(animate2, "node"),
        axis: false,
        interaction
      }),
      deep_mix_default({}, DEFAULT_LINK_OPTIONS, {
        data: linkData,
        encode: linkEncode,
        labels: linkLabels,
        style: Object.assign({ fill: linkEncode.color ? void 0 : "#aaa", lineWidth: 0 }, subObject(style, "link")),
        tooltip: linkTooltip,
        animate: maybeAnimation(animate2, "link"),
        interaction
      })
    ];
  };
  Sankey3.props = {};

  // node_modules/@antv/g2/esm/data/utils/arc/sort.js
  var sort_exports = {};
  __export(sort_exports, {
    frequency: () => frequency,
    id: () => id2,
    name: () => name,
    weight: () => weight
  });
  function weight(a3, b) {
    return b.value - a3.value;
  }
  function frequency(a3, b) {
    return b.frequency - a3.frequency;
  }
  function id2(a3, b) {
    return `${a3.id}`.localeCompare(`${b.id}`);
  }
  function name(a3, b) {
    return `${a3.name}`.localeCompare(`${b.name}`);
  }

  // node_modules/@antv/g2/esm/data/utils/arc/arc.js
  var DEFAULT_OPTIONS2 = {
    y: 0,
    thickness: 0.05,
    weight: false,
    marginRatio: 0.1,
    id: (node) => node.id,
    source: (edge) => edge.source,
    target: (edge) => edge.target,
    sourceWeight: (edge) => edge.value || 1,
    targetWeight: (edge) => edge.value || 1,
    sortBy: null
  };
  function Arc2(options) {
    const { y: y3, thickness, weight: weight2, marginRatio, id: id5, source, target, sourceWeight, targetWeight, sortBy } = Object.assign(Object.assign({}, DEFAULT_OPTIONS2), options);
    function arc(data2) {
      const nodes = data2.nodes.map((n2) => Object.assign({}, n2));
      const edges = data2.edges.map((n2) => Object.assign({}, n2));
      preprocess(nodes, edges);
      sortNodes(nodes, edges);
      layoutNodes(nodes, edges);
      layoutEdges(nodes, edges);
      return { nodes, edges };
    }
    function preprocess(nodes, edges) {
      edges.forEach((edge) => {
        edge.source = source(edge);
        edge.target = target(edge);
        edge.sourceWeight = sourceWeight(edge);
        edge.targetWeight = targetWeight(edge);
      });
      const edgesBySource = group(edges, (e3) => e3.source);
      const edgesByTarget = group(edges, (e3) => e3.target);
      nodes.forEach((node) => {
        node.id = id5(node);
        const sources = edgesBySource.has(node.id) ? edgesBySource.get(node.id) : [];
        const targets = edgesByTarget.has(node.id) ? edgesByTarget.get(node.id) : [];
        node.frequency = sources.length + targets.length;
        node.value = sum(sources, (d3) => d3.sourceWeight) + sum(targets, (d3) => d3.targetWeight);
      });
      return { nodes, edges };
    }
    function sortNodes(nodes, edges) {
      const method = typeof sortBy === "function" ? sortBy : sort_exports[sortBy];
      if (method) {
        nodes.sort(method);
      }
    }
    function layoutNodes(nodes, edges) {
      const size2 = nodes.length;
      if (!size2) {
        throw error2("Invalid nodes: it's empty!");
      }
      if (!weight2) {
        const deltaX = 1 / size2;
        nodes.forEach((node, i) => {
          node.x = (i + 0.5) * deltaX;
          node.y = y3;
        });
        return { nodes, edges };
      }
      const margin = marginRatio / (2 * size2);
      const total = nodes.reduce((prev, node) => prev += node.value, 0);
      nodes.reduce((deltaX, node) => {
        node.weight = node.value / total;
        node.width = node.weight * (1 - marginRatio);
        node.height = thickness;
        const minX = margin + deltaX;
        const maxX = minX + node.width;
        const minY = y3 - thickness / 2;
        const maxY2 = minY + thickness;
        node.x = [minX, maxX, maxX, minX];
        node.y = [minY, minY, maxY2, maxY2];
        return deltaX + node.width + 2 * margin;
      }, 0);
      return {
        nodes,
        edges
      };
    }
    function layoutEdges(nodes, edges) {
      const nodesMap = new Map(nodes.map((d3) => [d3.id, d3]));
      if (!weight2) {
        edges.forEach((edge) => {
          const sourceId = source(edge);
          const targetId = target(edge);
          const sourceNode = nodesMap.get(sourceId);
          const targetNode = nodesMap.get(targetId);
          if (sourceNode && targetNode) {
            edge.x = [sourceNode.x, targetNode.x];
            edge.y = [sourceNode.y, targetNode.y];
          }
        });
        return { nodes, edges };
      }
      edges.forEach((edge) => {
        edge.x = [0, 0, 0, 0];
        edge.y = [y3, y3, y3, y3];
      });
      const edgesBySource = group(edges, (e3) => e3.source);
      const edgesByTarget = group(edges, (e3) => e3.target);
      nodes.forEach((node) => {
        const { edges: edges2, width, x: x3, y: y4, value: value2, id: id6 } = node;
        const sourceEdges = edgesBySource.get(id6) || [];
        const targetEdges = edgesByTarget.get(id6) || [];
        let offset3 = 0;
        sourceEdges.map((edge) => {
          const w = edge.sourceWeight / value2 * width;
          edge.x[0] = x3[0] + offset3;
          edge.x[1] = x3[0] + offset3 + w;
          offset3 += w;
        });
        targetEdges.forEach((edge) => {
          const w = edge.targetWeight / value2 * width;
          edge.x[3] = x3[0] + offset3;
          edge.x[2] = x3[0] + offset3 + w;
          offset3 += w;
        });
      });
    }
    return arc;
  }

  // node_modules/@antv/g2/esm/data/arc.js
  var Arc3 = (options) => {
    return (data2) => {
      return Arc2(options)(data2);
    };
  };
  Arc3.props = {};

  // node_modules/@antv/g2/esm/mark/chord.js
  var __rest45 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var DEFAULT_LAYOUT_OPTIONS2 = {
    y: 0,
    thickness: 0.05,
    marginRatio: 0.1,
    id: (node) => node.key,
    source: (edge) => edge.source,
    target: (edge) => edge.target,
    sourceWeight: (edge) => edge.value || 1,
    targetWeight: (edge) => edge.value || 1,
    sortBy: null
    // optional, id | weight | frequency | {function}
  };
  var DEFAULT_NODE_OPTIONS2 = {
    type: "polygon",
    axis: false,
    legend: false,
    encode: {
      shape: "polygon",
      x: "x",
      y: "y"
    },
    scale: {
      x: { type: "identity" },
      y: { type: "identity" }
    },
    style: {
      opacity: 1,
      fillOpacity: 1,
      lineWidth: 1
    }
  };
  var DEFAULT_LINK_OPTIONS2 = {
    type: "polygon",
    axis: false,
    legend: false,
    encode: {
      shape: "ribbon",
      x: "x",
      y: "y"
    },
    style: {
      opacity: 0.5,
      lineWidth: 1
    }
  };
  var DEFAULT_LABEL_OPTIONS2 = {
    position: "outside",
    fontSize: 10
  };
  var Chord = (options, context) => {
    const { data: data2, encode = {}, scale: scale10, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
    const { nodes, links } = initializeData(data2, encode);
    const nodeEncode = subObject(encode, "node");
    const linkEncode = subObject(encode, "link");
    const { key: nodeKey = (d3) => d3.key, color: color2 = nodeKey } = nodeEncode;
    const { linkEncodeColor = (d3) => d3.source } = linkEncode;
    const { nodeWidthRatio = DEFAULT_LAYOUT_OPTIONS2.thickness, nodePaddingRatio = DEFAULT_LAYOUT_OPTIONS2.marginRatio } = layout, restLayout = __rest45(layout, ["nodeWidthRatio", "nodePaddingRatio"]);
    const { nodes: nodeData, edges: linkData } = Arc3(Object.assign(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS2), { id: field(nodeKey), thickness: nodeWidthRatio, marginRatio: nodePaddingRatio }), restLayout), { weight: true }))({ nodes, edges: links });
    const _a = subObject(style, "label"), { text = nodeKey } = _a, labelStyle = __rest45(_a, ["text"]);
    const nodeTooltip = subTooltip(tooltip2, "node", {
      title: "",
      items: [(d3) => ({ name: d3.key, value: d3.value })]
    }, true);
    const linkTooltip = subTooltip(tooltip2, "link", {
      title: "",
      items: [(d3) => ({ name: `${d3.source} -> ${d3.target}`, value: d3.value })]
    });
    const { height, width } = context;
    const minimumLen = Math.min(height, width);
    return [
      deep_mix_default({}, DEFAULT_LINK_OPTIONS2, {
        data: linkData,
        encode: Object.assign(Object.assign({}, linkEncode), { color: linkEncodeColor }),
        labels: linkLabels,
        style: Object.assign({ fill: linkEncodeColor ? void 0 : "#aaa" }, subObject(style, "link")),
        tooltip: linkTooltip,
        animate: maybeAnimation(animate2, "link")
      }),
      deep_mix_default({}, DEFAULT_NODE_OPTIONS2, {
        data: nodeData,
        encode: Object.assign(Object.assign({}, nodeEncode), { color: color2 }),
        scale: scale10,
        style: subObject(style, "node"),
        coordinate: {
          type: "polar",
          // Leave enough rendering space for the label.
          outerRadius: (minimumLen - 20) / minimumLen,
          startAngle: -Math.PI * 2,
          endAngle: 0
        },
        labels: [
          Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS2), { text }), labelStyle),
          ...nodeLabels
        ],
        tooltip: nodeTooltip,
        animate: maybeAnimation(animate2, "node"),
        axis: false
      })
    ];
  };
  Chord.props = {};

  // node_modules/@antv/g2/esm/mark/path.js
  var shape19 = {
    path: Path3,
    hollow: Hollow2
  };
  var Path4 = (options) => {
    return (index4, scale10, value2, coordinate) => {
      return [index4, index4.map(() => [[0, 0]])];
    };
  };
  Path4.props = {
    defaultShape: "path",
    defaultLabelShape: "label",
    shape: shape19,
    composite: false,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape19) }),
      { name: "d", scale: "identity" }
    ],
    preInference: [...basePreInference()],
    postInference: [...basePostInference()]
  };

  // node_modules/d3-hierarchy/src/cluster.js
  function defaultSeparation(a3, b) {
    return a3.parent === b.parent ? 1 : 2;
  }
  function meanX(children) {
    return children.reduce(meanXReduce, 0) / children.length;
  }
  function meanXReduce(x3, c5) {
    return x3 + c5.x;
  }
  function maxY(children) {
    return 1 + children.reduce(maxYReduce, 0);
  }
  function maxYReduce(y3, c5) {
    return Math.max(y3, c5.y);
  }
  function leafLeft(node) {
    var children;
    while (children = node.children) node = children[0];
    return node;
  }
  function leafRight(node) {
    var children;
    while (children = node.children) node = children[children.length - 1];
    return node;
  }
  function cluster_default() {
    var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
    function cluster(root2) {
      var previousNode, x3 = 0;
      root2.eachAfter(function(node) {
        var children = node.children;
        if (children) {
          node.x = meanX(children);
          node.y = maxY(children);
        } else {
          node.x = previousNode ? x3 += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left2 = leafLeft(root2), right2 = leafRight(root2), x05 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
      return root2.eachAfter(nodeSize ? function(node) {
        node.x = (node.x - root2.x) * dx;
        node.y = (root2.y - node.y) * dy;
      } : function(node) {
        node.x = (node.x - x05) / (x12 - x05) * dx;
        node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
      });
    }
    cluster.separation = function(x3) {
      return arguments.length ? (separation = x3, cluster) : separation;
    };
    cluster.size = function(x3) {
      return arguments.length ? (nodeSize = false, dx = +x3[0], dy = +x3[1], cluster) : nodeSize ? null : [dx, dy];
    };
    cluster.nodeSize = function(x3) {
      return arguments.length ? (nodeSize = true, dx = +x3[0], dy = +x3[1], cluster) : nodeSize ? [dx, dy] : null;
    };
    return cluster;
  }

  // node_modules/d3-hierarchy/src/hierarchy/count.js
  function count3(node) {
    var sum3 = 0, children = node.children, i = children && children.length;
    if (!i) sum3 = 1;
    else while (--i >= 0) sum3 += children[i].value;
    node.value = sum3;
  }
  function count_default() {
    return this.eachAfter(count3);
  }

  // node_modules/d3-hierarchy/src/hierarchy/each.js
  function each_default2(callback, that) {
    let index4 = -1;
    for (const node of this) {
      callback.call(that, node, ++index4, this);
    }
    return this;
  }

  // node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
  function eachBefore_default(callback, that) {
    var node = this, nodes = [node], children, i, index4 = -1;
    while (node = nodes.pop()) {
      callback.call(that, node, ++index4, this);
      if (children = node.children) {
        for (i = children.length - 1; i >= 0; --i) {
          nodes.push(children[i]);
        }
      }
    }
    return this;
  }

  // node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
  function eachAfter_default(callback, that) {
    var node = this, nodes = [node], next = [], children, i, n2, index4 = -1;
    while (node = nodes.pop()) {
      next.push(node);
      if (children = node.children) {
        for (i = 0, n2 = children.length; i < n2; ++i) {
          nodes.push(children[i]);
        }
      }
    }
    while (node = next.pop()) {
      callback.call(that, node, ++index4, this);
    }
    return this;
  }

  // node_modules/d3-hierarchy/src/hierarchy/find.js
  function find_default2(callback, that) {
    let index4 = -1;
    for (const node of this) {
      if (callback.call(that, node, ++index4, this)) {
        return node;
      }
    }
  }

  // node_modules/d3-hierarchy/src/hierarchy/sum.js
  function sum_default(value2) {
    return this.eachAfter(function(node) {
      var sum3 = +value2(node.data) || 0, children = node.children, i = children && children.length;
      while (--i >= 0) sum3 += children[i].value;
      node.value = sum3;
    });
  }

  // node_modules/d3-hierarchy/src/hierarchy/sort.js
  function sort_default(compare) {
    return this.eachBefore(function(node) {
      if (node.children) {
        node.children.sort(compare);
      }
    });
  }

  // node_modules/d3-hierarchy/src/hierarchy/path.js
  function path_default(end) {
    var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
    while (start2 !== ancestor) {
      start2 = start2.parent;
      nodes.push(start2);
    }
    var k = nodes.length;
    while (end !== ancestor) {
      nodes.splice(k, 0, end);
      end = end.parent;
    }
    return nodes;
  }
  function leastCommonAncestor(a3, b) {
    if (a3 === b) return a3;
    var aNodes = a3.ancestors(), bNodes = b.ancestors(), c5 = null;
    a3 = aNodes.pop();
    b = bNodes.pop();
    while (a3 === b) {
      c5 = a3;
      a3 = aNodes.pop();
      b = bNodes.pop();
    }
    return c5;
  }

  // node_modules/d3-hierarchy/src/hierarchy/ancestors.js
  function ancestors_default() {
    var node = this, nodes = [node];
    while (node = node.parent) {
      nodes.push(node);
    }
    return nodes;
  }

  // node_modules/d3-hierarchy/src/hierarchy/descendants.js
  function descendants_default() {
    return Array.from(this);
  }

  // node_modules/d3-hierarchy/src/hierarchy/leaves.js
  function leaves_default() {
    var leaves = [];
    this.eachBefore(function(node) {
      if (!node.children) {
        leaves.push(node);
      }
    });
    return leaves;
  }

  // node_modules/d3-hierarchy/src/hierarchy/links.js
  function links_default() {
    var root2 = this, links = [];
    root2.each(function(node) {
      if (node !== root2) {
        links.push({ source: node.parent, target: node });
      }
    });
    return links;
  }

  // node_modules/d3-hierarchy/src/hierarchy/iterator.js
  function* iterator_default() {
    var node = this, current, next = [node], children, i, n2;
    do {
      current = next.reverse(), next = [];
      while (node = current.pop()) {
        yield node;
        if (children = node.children) {
          for (i = 0, n2 = children.length; i < n2; ++i) {
            next.push(children[i]);
          }
        }
      }
    } while (next.length);
  }

  // node_modules/d3-hierarchy/src/hierarchy/index.js
  function hierarchy(data2, children) {
    if (data2 instanceof Map) {
      data2 = [void 0, data2];
      if (children === void 0) children = mapChildren;
    } else if (children === void 0) {
      children = objectChildren;
    }
    var root2 = new Node3(data2), node, nodes = [root2], child, childs, i, n2;
    while (node = nodes.pop()) {
      if ((childs = children(node.data)) && (n2 = (childs = Array.from(childs)).length)) {
        node.children = childs;
        for (i = n2 - 1; i >= 0; --i) {
          nodes.push(child = childs[i] = new Node3(childs[i]));
          child.parent = node;
          child.depth = node.depth + 1;
        }
      }
    }
    return root2.eachBefore(computeHeight);
  }
  function node_copy() {
    return hierarchy(this).eachBefore(copyData);
  }
  function objectChildren(d3) {
    return d3.children;
  }
  function mapChildren(d3) {
    return Array.isArray(d3) ? d3[1] : null;
  }
  function copyData(node) {
    if (node.data.value !== void 0) node.value = node.data.value;
    node.data = node.data.data;
  }
  function computeHeight(node) {
    var height = 0;
    do
      node.height = height;
    while ((node = node.parent) && node.height < ++height);
  }
  function Node3(data2) {
    this.data = data2;
    this.depth = this.height = 0;
    this.parent = null;
  }
  Node3.prototype = hierarchy.prototype = {
    constructor: Node3,
    count: count_default,
    each: each_default2,
    eachAfter: eachAfter_default,
    eachBefore: eachBefore_default,
    find: find_default2,
    sum: sum_default,
    sort: sort_default,
    path: path_default,
    ancestors: ancestors_default,
    descendants: descendants_default,
    leaves: leaves_default,
    links: links_default,
    copy: node_copy,
    [Symbol.iterator]: iterator_default
  };

  // node_modules/d3-hierarchy/src/accessors.js
  function optional(f) {
    return f == null ? null : required(f);
  }
  function required(f) {
    if (typeof f !== "function") throw new Error();
    return f;
  }

  // node_modules/d3-hierarchy/src/constant.js
  function constantZero() {
    return 0;
  }
  function constant_default2(x3) {
    return function() {
      return x3;
    };
  }

  // node_modules/d3-hierarchy/src/lcg.js
  var a = 1664525;
  var c = 1013904223;
  var m = 4294967296;
  function lcg_default() {
    let s3 = 1;
    return () => (s3 = (a * s3 + c) % m) / m;
  }

  // node_modules/d3-hierarchy/src/array.js
  function array_default2(x3) {
    return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
  }
  function shuffle(array2, random5) {
    let m3 = array2.length, t, i;
    while (m3) {
      i = random5() * m3-- | 0;
      t = array2[m3];
      array2[m3] = array2[i];
      array2[i] = t;
    }
    return array2;
  }

  // node_modules/d3-hierarchy/src/pack/enclose.js
  function packEncloseRandom(circles, random5) {
    var i = 0, n2 = (circles = shuffle(Array.from(circles), random5)).length, B4 = [], p2, e3;
    while (i < n2) {
      p2 = circles[i];
      if (e3 && enclosesWeak(e3, p2)) ++i;
      else e3 = encloseBasis(B4 = extendBasis(B4, p2)), i = 0;
    }
    return e3;
  }
  function extendBasis(B4, p2) {
    var i, j;
    if (enclosesWeakAll(p2, B4)) return [p2];
    for (i = 0; i < B4.length; ++i) {
      if (enclosesNot(p2, B4[i]) && enclosesWeakAll(encloseBasis2(B4[i], p2), B4)) {
        return [B4[i], p2];
      }
    }
    for (i = 0; i < B4.length - 1; ++i) {
      for (j = i + 1; j < B4.length; ++j) {
        if (enclosesNot(encloseBasis2(B4[i], B4[j]), p2) && enclosesNot(encloseBasis2(B4[i], p2), B4[j]) && enclosesNot(encloseBasis2(B4[j], p2), B4[i]) && enclosesWeakAll(encloseBasis3(B4[i], B4[j], p2), B4)) {
          return [B4[i], B4[j], p2];
        }
      }
    }
    throw new Error();
  }
  function enclosesNot(a3, b) {
    var dr = a3.r - b.r, dx = b.x - a3.x, dy = b.y - a3.y;
    return dr < 0 || dr * dr < dx * dx + dy * dy;
  }
  function enclosesWeak(a3, b) {
    var dr = a3.r - b.r + Math.max(a3.r, b.r, 1) * 1e-9, dx = b.x - a3.x, dy = b.y - a3.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }
  function enclosesWeakAll(a3, B4) {
    for (var i = 0; i < B4.length; ++i) {
      if (!enclosesWeak(a3, B4[i])) {
        return false;
      }
    }
    return true;
  }
  function encloseBasis(B4) {
    switch (B4.length) {
      case 1:
        return encloseBasis1(B4[0]);
      case 2:
        return encloseBasis2(B4[0], B4[1]);
      case 3:
        return encloseBasis3(B4[0], B4[1], B4[2]);
    }
  }
  function encloseBasis1(a3) {
    return {
      x: a3.x,
      y: a3.y,
      r: a3.r
    };
  }
  function encloseBasis2(a3, b) {
    var x12 = a3.x, y12 = a3.y, r1 = a3.r, x22 = b.x, y22 = b.y, r2 = b.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l2 = Math.sqrt(x21 * x21 + y21 * y21);
    return {
      x: (x12 + x22 + x21 / l2 * r21) / 2,
      y: (y12 + y22 + y21 / l2 * r21) / 2,
      r: (l2 + r1 + r2) / 2
    };
  }
  function encloseBasis3(a3, b, c5) {
    var x12 = a3.x, y12 = a3.y, r1 = a3.r, x22 = b.x, y22 = b.y, r2 = b.r, x3 = c5.x, y3 = c5.y, r3 = c5.r, a22 = x12 - x22, a32 = x12 - x3, b2 = y12 - y22, b3 = y12 - y3, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d22 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a32 * b2 - a22 * b3, xa = (b2 * d3 - b3 * d22) / (ab * 2) - x12, xb = (b3 * c22 - b2 * c32) / ab, ya = (a32 * d22 - a22 * d3) / (ab * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab, A5 = xb * xb + yb * yb - 1, B4 = 2 * (r1 + xa * xb + ya * yb), C4 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A5) > 1e-6 ? (B4 + Math.sqrt(B4 * B4 - 4 * A5 * C4)) / (2 * A5) : C4 / B4);
    return {
      x: x12 + xa + xb * r,
      y: y12 + ya + yb * r,
      r
    };
  }

  // node_modules/d3-hierarchy/src/pack/siblings.js
  function place(b, a3, c5) {
    var dx = b.x - a3.x, x3, a22, dy = b.y - a3.y, y3, b2, d22 = dx * dx + dy * dy;
    if (d22) {
      a22 = a3.r + c5.r, a22 *= a22;
      b2 = b.r + c5.r, b2 *= b2;
      if (a22 > b2) {
        x3 = (d22 + b2 - a22) / (2 * d22);
        y3 = Math.sqrt(Math.max(0, b2 / d22 - x3 * x3));
        c5.x = b.x - x3 * dx - y3 * dy;
        c5.y = b.y - x3 * dy + y3 * dx;
      } else {
        x3 = (d22 + a22 - b2) / (2 * d22);
        y3 = Math.sqrt(Math.max(0, a22 / d22 - x3 * x3));
        c5.x = a3.x + x3 * dx - y3 * dy;
        c5.y = a3.y + x3 * dy + y3 * dx;
      }
    } else {
      c5.x = a3.x + c5.r;
      c5.y = a3.y;
    }
  }
  function intersects(a3, b) {
    var dr = a3.r + b.r - 1e-6, dx = b.x - a3.x, dy = b.y - a3.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }
  function score(node) {
    var a3 = node._, b = node.next._, ab = a3.r + b.r, dx = (a3.x * b.r + b.x * a3.r) / ab, dy = (a3.y * b.r + b.y * a3.r) / ab;
    return dx * dx + dy * dy;
  }
  function Node4(circle3) {
    this._ = circle3;
    this.next = null;
    this.previous = null;
  }
  function packSiblingsRandom(circles, random5) {
    if (!(n2 = (circles = array_default2(circles)).length)) return 0;
    var a3, b, c5, n2, aa, ca, i, j, k, sj, sk;
    a3 = circles[0], a3.x = 0, a3.y = 0;
    if (!(n2 > 1)) return a3.r;
    b = circles[1], a3.x = -b.r, b.x = a3.r, b.y = 0;
    if (!(n2 > 2)) return a3.r + b.r;
    place(b, a3, c5 = circles[2]);
    a3 = new Node4(a3), b = new Node4(b), c5 = new Node4(c5);
    a3.next = c5.previous = b;
    b.next = a3.previous = c5;
    c5.next = b.previous = a3;
    pack: for (i = 3; i < n2; ++i) {
      place(a3._, b._, c5 = circles[i]), c5 = new Node4(c5);
      j = b.next, k = a3.previous, sj = b._.r, sk = a3._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c5._)) {
            b = j, a3.next = b, b.previous = a3, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k._, c5._)) {
            a3 = k, a3.next = b, b.previous = a3, --i;
            continue pack;
          }
          sk += k._.r, k = k.previous;
        }
      } while (j !== k.next);
      c5.previous = a3, c5.next = b, a3.next = b.previous = b = c5;
      aa = score(a3);
      while ((c5 = c5.next) !== b) {
        if ((ca = score(c5)) < aa) {
          a3 = c5, aa = ca;
        }
      }
      b = a3.next;
    }
    a3 = [b._], c5 = b;
    while ((c5 = c5.next) !== b) a3.push(c5._);
    c5 = packEncloseRandom(a3, random5);
    for (i = 0; i < n2; ++i) a3 = circles[i], a3.x -= c5.x, a3.y -= c5.y;
    return c5.r;
  }

  // node_modules/d3-hierarchy/src/pack/index.js
  function defaultRadius(d3) {
    return Math.sqrt(d3.value);
  }
  function pack_default() {
    var radius = null, dx = 1, dy = 1, padding = constantZero;
    function pack3(root2) {
      const random5 = lcg_default();
      root2.x = dx / 2, root2.y = dy / 2;
      if (radius) {
        root2.eachBefore(radiusLeaf(radius)).eachAfter(packChildrenRandom(padding, 0.5, random5)).eachBefore(translateChild(1));
      } else {
        root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, random5)).eachAfter(packChildrenRandom(padding, root2.r / Math.min(dx, dy), random5)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
      }
      return root2;
    }
    pack3.radius = function(x3) {
      return arguments.length ? (radius = optional(x3), pack3) : radius;
    };
    pack3.size = function(x3) {
      return arguments.length ? (dx = +x3[0], dy = +x3[1], pack3) : [dx, dy];
    };
    pack3.padding = function(x3) {
      return arguments.length ? (padding = typeof x3 === "function" ? x3 : constant_default2(+x3), pack3) : padding;
    };
    return pack3;
  }
  function radiusLeaf(radius) {
    return function(node) {
      if (!node.children) {
        node.r = Math.max(0, +radius(node) || 0);
      }
    };
  }
  function packChildrenRandom(padding, k, random5) {
    return function(node) {
      if (children = node.children) {
        var children, i, n2 = children.length, r = padding(node) * k || 0, e3;
        if (r) for (i = 0; i < n2; ++i) children[i].r += r;
        e3 = packSiblingsRandom(children, random5);
        if (r) for (i = 0; i < n2; ++i) children[i].r -= r;
        node.r = e3 + r;
      }
    };
  }
  function translateChild(k) {
    return function(node) {
      var parent = node.parent;
      node.r *= k;
      if (parent) {
        node.x = parent.x + k * node.x;
        node.y = parent.y + k * node.y;
      }
    };
  }

  // node_modules/d3-hierarchy/src/treemap/round.js
  function round_default(node) {
    node.x0 = Math.round(node.x0);
    node.y0 = Math.round(node.y0);
    node.x1 = Math.round(node.x1);
    node.y1 = Math.round(node.y1);
  }

  // node_modules/d3-hierarchy/src/treemap/dice.js
  function dice_default(parent, x05, y05, x12, y12) {
    var nodes = parent.children, node, i = -1, n2 = nodes.length, k = parent.value && (x12 - x05) / parent.value;
    while (++i < n2) {
      node = nodes[i], node.y0 = y05, node.y1 = y12;
      node.x0 = x05, node.x1 = x05 += node.value * k;
    }
  }

  // node_modules/d3-hierarchy/src/stratify.js
  var preroot = { depth: -1 };
  var ambiguous = {};
  var imputed = {};
  function defaultId2(d3) {
    return d3.id;
  }
  function defaultParentId(d3) {
    return d3.parentId;
  }
  function stratify_default() {
    var id5 = defaultId2, parentId = defaultParentId, path2;
    function stratify(data2) {
      var nodes = Array.from(data2), currentId = id5, currentParentId = parentId, n2, d3, i, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
      if (path2 != null) {
        const I = nodes.map((d4, i2) => normalize8(path2(d4, i2, data2)));
        const P = I.map(parentof);
        const S = new Set(I).add("");
        for (const i2 of P) {
          if (!S.has(i2)) {
            S.add(i2);
            I.push(i2);
            P.push(parentof(i2));
            nodes.push(imputed);
          }
        }
        currentId = (_2, i2) => I[i2];
        currentParentId = (_2, i2) => P[i2];
      }
      for (i = 0, n2 = nodes.length; i < n2; ++i) {
        d3 = nodes[i], node = nodes[i] = new Node3(d3);
        if ((nodeId = currentId(d3, i, data2)) != null && (nodeId += "")) {
          nodeKey = node.id = nodeId;
          nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
        }
        if ((nodeId = currentParentId(d3, i, data2)) != null && (nodeId += "")) {
          node.parent = nodeId;
        }
      }
      for (i = 0; i < n2; ++i) {
        node = nodes[i];
        if (nodeId = node.parent) {
          parent = nodeByKey.get(nodeId);
          if (!parent) throw new Error("missing: " + nodeId);
          if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
          if (parent.children) parent.children.push(node);
          else parent.children = [node];
          node.parent = parent;
        } else {
          if (root2) throw new Error("multiple roots");
          root2 = node;
        }
      }
      if (!root2) throw new Error("no root");
      if (path2 != null) {
        while (root2.data === imputed && root2.children.length === 1) {
          root2 = root2.children[0], --n2;
        }
        for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
          node = nodes[i2];
          if (node.data !== imputed) break;
          node.data = null;
        }
      }
      root2.parent = preroot;
      root2.eachBefore(function(node2) {
        node2.depth = node2.parent.depth + 1;
        --n2;
      }).eachBefore(computeHeight);
      root2.parent = null;
      if (n2 > 0) throw new Error("cycle");
      return root2;
    }
    stratify.id = function(x3) {
      return arguments.length ? (id5 = optional(x3), stratify) : id5;
    };
    stratify.parentId = function(x3) {
      return arguments.length ? (parentId = optional(x3), stratify) : parentId;
    };
    stratify.path = function(x3) {
      return arguments.length ? (path2 = optional(x3), stratify) : path2;
    };
    return stratify;
  }
  function normalize8(path2) {
    path2 = `${path2}`;
    let i = path2.length;
    if (slash(path2, i - 1) && !slash(path2, i - 2)) path2 = path2.slice(0, -1);
    return path2[0] === "/" ? path2 : `/${path2}`;
  }
  function parentof(path2) {
    let i = path2.length;
    if (i < 2) return "";
    while (--i > 1) if (slash(path2, i)) break;
    return path2.slice(0, i);
  }
  function slash(path2, i) {
    if (path2[i] === "/") {
      let k = 0;
      while (i > 0 && path2[--i] === "\\") ++k;
      if ((k & 1) === 0) return true;
    }
    return false;
  }

  // node_modules/d3-hierarchy/src/tree.js
  function defaultSeparation2(a3, b) {
    return a3.parent === b.parent ? 1 : 2;
  }
  function nextLeft(v) {
    var children = v.children;
    return children ? children[0] : v.t;
  }
  function nextRight(v) {
    var children = v.children;
    return children ? children[children.length - 1] : v.t;
  }
  function moveSubtree(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function executeShifts(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function nextAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  function TreeNode(node, i) {
    this._ = node;
    this.parent = null;
    this.children = null;
    this.A = null;
    this.a = this;
    this.z = 0;
    this.m = 0;
    this.c = 0;
    this.s = 0;
    this.t = null;
    this.i = i;
  }
  TreeNode.prototype = Object.create(Node3.prototype);
  function treeRoot(root2) {
    var tree = new TreeNode(root2, 0), node, nodes = [tree], child, children, i, n2;
    while (node = nodes.pop()) {
      if (children = node._.children) {
        node.children = new Array(n2 = children.length);
        for (i = n2 - 1; i >= 0; --i) {
          nodes.push(child = node.children[i] = new TreeNode(children[i], i));
          child.parent = node;
        }
      }
    }
    (tree.parent = new TreeNode(null, 0)).children = [tree];
    return tree;
  }
  function tree_default2() {
    var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
    function tree(root2) {
      var t = treeRoot(root2);
      t.eachAfter(firstWalk), t.parent.m = -t.z;
      t.eachBefore(secondWalk);
      if (nodeSize) root2.eachBefore(sizeNode);
      else {
        var left2 = root2, right2 = root2, bottom = root2;
        root2.eachBefore(function(node) {
          if (node.x < left2.x) left2 = node;
          if (node.x > right2.x) right2 = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var s3 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s3 - left2.x, kx = dx / (right2.x + s3 + tx), ky = dy / (bottom.depth || 1);
        root2.eachBefore(function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return root2;
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children) {
        executeShifts(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
          vom = nextLeft(vom);
          vop = nextRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !nextRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !nextLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= dx;
      node.y = node.depth * dy;
    }
    tree.separation = function(x3) {
      return arguments.length ? (separation = x3, tree) : separation;
    };
    tree.size = function(x3) {
      return arguments.length ? (nodeSize = false, dx = +x3[0], dy = +x3[1], tree) : nodeSize ? null : [dx, dy];
    };
    tree.nodeSize = function(x3) {
      return arguments.length ? (nodeSize = true, dx = +x3[0], dy = +x3[1], tree) : nodeSize ? [dx, dy] : null;
    };
    return tree;
  }

  // node_modules/d3-hierarchy/src/treemap/slice.js
  function slice_default(parent, x05, y05, x12, y12) {
    var nodes = parent.children, node, i = -1, n2 = nodes.length, k = parent.value && (y12 - y05) / parent.value;
    while (++i < n2) {
      node = nodes[i], node.x0 = x05, node.x1 = x12;
      node.y0 = y05, node.y1 = y05 += node.value * k;
    }
  }

  // node_modules/d3-hierarchy/src/treemap/squarify.js
  var phi = (1 + Math.sqrt(5)) / 2;
  function squarifyRatio(ratio, parent, x05, y05, x12, y12) {
    var rows = [], nodes = parent.children, row2, nodeValue, i0 = 0, i1 = 0, n2 = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
    while (i0 < n2) {
      dx = x12 - x05, dy = y12 - y05;
      do
        sumValue = nodes[i1++].value;
      while (!sumValue && i1 < n2);
      minValue = maxValue = sumValue;
      alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
      beta = sumValue * sumValue * alpha;
      minRatio = Math.max(maxValue / beta, beta / minValue);
      for (; i1 < n2; ++i1) {
        sumValue += nodeValue = nodes[i1].value;
        if (nodeValue < minValue) minValue = nodeValue;
        if (nodeValue > maxValue) maxValue = nodeValue;
        beta = sumValue * sumValue * alpha;
        newRatio = Math.max(maxValue / beta, beta / minValue);
        if (newRatio > minRatio) {
          sumValue -= nodeValue;
          break;
        }
        minRatio = newRatio;
      }
      rows.push(row2 = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
      if (row2.dice) dice_default(row2, x05, y05, x12, value2 ? y05 += dy * sumValue / value2 : y12);
      else slice_default(row2, x05, y05, value2 ? x05 += dx * sumValue / value2 : x12, y12);
      value2 -= sumValue, i0 = i1;
    }
    return rows;
  }
  var squarify_default = function custom5(ratio) {
    function squarify(parent, x05, y05, x12, y12) {
      squarifyRatio(ratio, parent, x05, y05, x12, y12);
    }
    squarify.ratio = function(x3) {
      return custom5((x3 = +x3) > 1 ? x3 : 1);
    };
    return squarify;
  }(phi);

  // node_modules/d3-hierarchy/src/treemap/index.js
  function treemap_default() {
    var tile = squarify_default, round5 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
    function treemap(root2) {
      root2.x0 = root2.y0 = 0;
      root2.x1 = dx;
      root2.y1 = dy;
      root2.eachBefore(positionNode);
      paddingStack = [0];
      if (round5) root2.eachBefore(round_default);
      return root2;
    }
    function positionNode(node) {
      var p2 = paddingStack[node.depth], x05 = node.x0 + p2, y05 = node.y0 + p2, x12 = node.x1 - p2, y12 = node.y1 - p2;
      if (x12 < x05) x05 = x12 = (x05 + x12) / 2;
      if (y12 < y05) y05 = y12 = (y05 + y12) / 2;
      node.x0 = x05;
      node.y0 = y05;
      node.x1 = x12;
      node.y1 = y12;
      if (node.children) {
        p2 = paddingStack[node.depth + 1] = paddingInner(node) / 2;
        x05 += paddingLeft(node) - p2;
        y05 += paddingTop(node) - p2;
        x12 -= paddingRight(node) - p2;
        y12 -= paddingBottom(node) - p2;
        if (x12 < x05) x05 = x12 = (x05 + x12) / 2;
        if (y12 < y05) y05 = y12 = (y05 + y12) / 2;
        tile(node, x05, y05, x12, y12);
      }
    }
    treemap.round = function(x3) {
      return arguments.length ? (round5 = !!x3, treemap) : round5;
    };
    treemap.size = function(x3) {
      return arguments.length ? (dx = +x3[0], dy = +x3[1], treemap) : [dx, dy];
    };
    treemap.tile = function(x3) {
      return arguments.length ? (tile = required(x3), treemap) : tile;
    };
    treemap.padding = function(x3) {
      return arguments.length ? treemap.paddingInner(x3).paddingOuter(x3) : treemap.paddingInner();
    };
    treemap.paddingInner = function(x3) {
      return arguments.length ? (paddingInner = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingInner;
    };
    treemap.paddingOuter = function(x3) {
      return arguments.length ? treemap.paddingTop(x3).paddingRight(x3).paddingBottom(x3).paddingLeft(x3) : treemap.paddingTop();
    };
    treemap.paddingTop = function(x3) {
      return arguments.length ? (paddingTop = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingTop;
    };
    treemap.paddingRight = function(x3) {
      return arguments.length ? (paddingRight = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingRight;
    };
    treemap.paddingBottom = function(x3) {
      return arguments.length ? (paddingBottom = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingBottom;
    };
    treemap.paddingLeft = function(x3) {
      return arguments.length ? (paddingLeft = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingLeft;
    };
    return treemap;
  }

  // node_modules/d3-hierarchy/src/treemap/binary.js
  function binary_default(parent, x05, y05, x12, y12) {
    var nodes = parent.children, i, n2 = nodes.length, sum3, sums = new Array(n2 + 1);
    for (sums[0] = sum3 = i = 0; i < n2; ++i) {
      sums[i + 1] = sum3 += nodes[i].value;
    }
    partition(0, n2, parent.value, x05, y05, x12, y12);
    function partition(i2, j, value2, x06, y06, x13, y13) {
      if (i2 >= j - 1) {
        var node = nodes[i2];
        node.x0 = x06, node.y0 = y06;
        node.x1 = x13, node.y1 = y13;
        return;
      }
      var valueOffset = sums[i2], valueTarget = value2 / 2 + valueOffset, k = i2 + 1, hi = j - 1;
      while (k < hi) {
        var mid2 = k + hi >>> 1;
        if (sums[mid2] < valueTarget) k = mid2 + 1;
        else hi = mid2;
      }
      if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i2 + 1 < k) --k;
      var valueLeft = sums[k] - valueOffset, valueRight = value2 - valueLeft;
      if (x13 - x06 > y13 - y06) {
        var xk = value2 ? (x06 * valueRight + x13 * valueLeft) / value2 : x13;
        partition(i2, k, valueLeft, x06, y06, xk, y13);
        partition(k, j, valueRight, xk, y06, x13, y13);
      } else {
        var yk = value2 ? (y06 * valueRight + y13 * valueLeft) / value2 : y13;
        partition(i2, k, valueLeft, x06, y06, x13, yk);
        partition(k, j, valueRight, x06, yk, x13, y13);
      }
    }
  }

  // node_modules/d3-hierarchy/src/treemap/sliceDice.js
  function sliceDice_default(parent, x05, y05, x12, y12) {
    (parent.depth & 1 ? slice_default : dice_default)(parent, x05, y05, x12, y12);
  }

  // node_modules/d3-hierarchy/src/treemap/resquarify.js
  var resquarify_default = function custom6(ratio) {
    function resquarify(parent, x05, y05, x12, y12) {
      if ((rows = parent._squarify) && rows.ratio === ratio) {
        var rows, row2, nodes, i, j = -1, n2, m3 = rows.length, value2 = parent.value;
        while (++j < m3) {
          row2 = rows[j], nodes = row2.children;
          for (i = row2.value = 0, n2 = nodes.length; i < n2; ++i) row2.value += nodes[i].value;
          if (row2.dice) dice_default(row2, x05, y05, x12, value2 ? y05 += (y12 - y05) * row2.value / value2 : y12);
          else slice_default(row2, x05, y05, value2 ? x05 += (x12 - x05) * row2.value / value2 : x12, y12);
          value2 -= row2.value;
        }
      } else {
        parent._squarify = rows = squarifyRatio(ratio, parent, x05, y05, x12, y12);
        rows.ratio = ratio;
      }
    }
    resquarify.ratio = function(x3) {
      return custom6((x3 = +x3) > 1 ? x3 : 1);
    };
    return resquarify;
  }(phi);

  // node_modules/@antv/g2/esm/utils/treeDataTransform.js
  function generateHierarchyRoot(data2, path2) {
    if (Array.isArray(data2)) {
      return typeof path2 === "function" ? stratify_default().path(path2)(data2) : stratify_default()(data2);
    }
    return hierarchy(data2);
  }
  function addObjectDataPath(root2, path2 = [root2.data.name]) {
    root2.id = root2.id || root2.data.name;
    root2.path = path2;
    if (root2.children) {
      root2.children.forEach((item) => {
        item.id = `${root2.id}/${item.data.name}`;
        item.path = [...path2, item.data.name];
        addObjectDataPath(item, item.path);
      });
    }
  }
  function addArrayDataPath(root2) {
    const name2 = get_default(root2, ["data", "name"]);
    if (name2.replaceAll) {
      root2.path = name2.replaceAll(".", "/").split("/");
    }
    if (root2.children) {
      root2.children.forEach((item) => {
        addArrayDataPath(item);
      });
    }
  }
  function getTileMethod(tile, ratio) {
    const tiles = {
      treemapBinary: binary_default,
      treemapDice: dice_default,
      treemapSlice: slice_default,
      treemapSliceDice: sliceDice_default,
      treemapSquarify: squarify_default,
      treemapResquarify: resquarify_default
    };
    const tileMethod = tile === "treemapSquarify" ? tiles[tile].ratio(ratio) : tiles[tile];
    if (!tileMethod) {
      throw new TypeError("Invalid tile method!");
    }
    return tileMethod;
  }
  function treeDataTransform(data2, layout, encode) {
    const { value: value2 } = encode;
    const tileMethod = getTileMethod(layout.tile, layout.ratio);
    const root2 = generateHierarchyRoot(data2, layout.path);
    if (isArray(data2)) {
      addArrayDataPath(root2);
    } else {
      addObjectDataPath(root2);
    }
    value2 ? root2.sum((d3) => layout.ignoreParentValue && d3.children ? 0 : field(value2)(d3)).sort(layout.sort) : root2.count();
    treemap_default().tile(tileMethod).size(layout.size).round(layout.round).paddingInner(layout.paddingInner).paddingOuter(layout.paddingOuter).paddingTop(layout.paddingTop).paddingRight(layout.paddingRight).paddingBottom(layout.paddingBottom).paddingLeft(layout.paddingLeft)(root2);
    const nodes = root2.descendants().map((d3) => Object.assign(d3, {
      id: d3.id.replace(/^\//, ""),
      x: [d3.x0, d3.x1],
      y: [d3.y0, d3.y1]
    }));
    const filterData = nodes.filter(typeof layout.layer === "function" ? layout.layer : (d3) => d3.height === layout.layer);
    return [filterData, nodes];
  }

  // node_modules/@antv/g2/esm/mark/treemap.js
  var __rest46 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var GET_DEFAULT_LAYOUT_OPTIONS = (width, height) => ({
    tile: "treemapSquarify",
    ratio: 0.5 * (1 + Math.sqrt(5)),
    size: [width, height],
    round: false,
    ignoreParentValue: true,
    padding: 0,
    paddingInner: 0,
    paddingOuter: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    sort: (a3, b) => b.value - a3.value,
    layer: 0
  });
  var GET_DEFAULT_OPTIONS = (width, height) => ({
    type: "rect",
    axis: false,
    encode: {
      x: "x",
      y: "y",
      key: "id",
      color: (d3) => d3.path[1]
    },
    scale: {
      x: { domain: [0, width], range: [0, 1] },
      y: { domain: [0, height], range: [0, 1] }
    },
    style: {
      stroke: "#fff"
    },
    state: {
      active: { opacity: 0.6 },
      inactive: { opacity: 1 }
    }
  });
  var DEFAULT_LABEL_OPTIONS3 = {
    fontSize: 10,
    text: (d3) => last(d3.path),
    position: "inside",
    fill: "#000",
    textOverflow: "clip",
    wordWrap: true,
    maxLines: 1,
    wordWrapWidth: (d3) => d3.x1 - d3.x0
  };
  var DEFAULT_TOOLTIP_OPTIONS = {
    title: (d3) => {
      var _a, _b;
      return (_b = (_a = d3.path) === null || _a === void 0 ? void 0 : _a.join) === null || _b === void 0 ? void 0 : _b.call(_a, ".");
    },
    items: [{ field: "value" }]
  };
  var DEFAULT_TOOLTIP_OPTIONS_DRILL = {
    title: (d3) => last(d3.path),
    items: [{ field: "value" }]
  };
  var Treemap = (options, context) => {
    const { width, height, options: markOptions } = context;
    const { data: data2, encode = {}, scale: scale10, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = options, resOptions = __rest46(options, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
    const treemapDrillDown = get_default(markOptions, [
      "interaction",
      "treemapDrillDown"
    ]);
    const layoutOptions = deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS(width, height), layout, {
      layer: treemapDrillDown ? (d3) => {
        return d3.depth === 1;
      } : layout.layer
    });
    const [transformedData, transformedDataAll] = treeDataTransform(data2, layoutOptions, encode);
    const labelStyle = subObject(style, "label");
    return deep_mix_default({}, GET_DEFAULT_OPTIONS(width, height), Object.assign(Object.assign({
      data: transformedData,
      scale: scale10,
      style,
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS3), labelStyle),
        ...labels
      ]
    }, resOptions), { encode, tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS), axis: false }), treemapDrillDown ? {
      interaction: Object.assign(Object.assign({}, resOptions.interaction), { treemapDrillDown: treemapDrillDown ? Object.assign(Object.assign({}, treemapDrillDown), { originData: transformedDataAll, layout: layoutOptions }) : void 0 }),
      encode: Object.assign({ color: (d3) => last(d3.path) }, encode),
      tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS_DRILL)
    } : {});
  };
  Treemap.props = {};

  // node_modules/@antv/g2/esm/mark/pack.js
  var __rest47 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var GET_DEFAULT_LAYOUT_OPTIONS2 = (width, height) => ({
    size: [width, height],
    padding: 0,
    sort: (a3, b) => b.value - a3.value
  });
  var GET_DEFAULT_OPTIONS2 = (width, height, encode) => ({
    type: "point",
    axis: false,
    legend: false,
    scale: {
      x: { domain: [0, width] },
      y: { domain: [0, height] },
      size: { type: "identity" }
    },
    encode: {
      x: "x",
      y: "y",
      size: "r",
      shape: "point"
    },
    style: {
      fill: !encode.color ? (d3) => d3.height === 0 ? "#ddd" : "#fff" : void 0,
      stroke: !encode.color ? (d3) => d3.height === 0 ? "" : "#000" : void 0
    }
  });
  var DEFAULT_LABEL_OPTIONS4 = {
    text: "",
    position: "inside",
    textOverflow: "clip",
    wordWrap: true,
    maxLines: 1,
    wordWrapWidth: (d3) => d3.r * 2
  };
  var DEFAULT_TOOLTIP_OPTIONS2 = {
    title: (d3) => d3.data.name,
    items: [{ field: "value" }]
  };
  var dataTransform = (data2, layout, encode) => {
    const { value: value2 } = encode;
    const root2 = isArray(data2) ? stratify_default().path(layout.path)(data2) : hierarchy(data2);
    value2 ? root2.sum((d3) => field(value2)(d3)).sort(layout.sort) : root2.count();
    pack_default().size(layout.size).padding(layout.padding)(root2);
    return root2.descendants();
  };
  var Pack2 = (markOptions, context) => {
    const { width, height } = context;
    const { data: data2, encode = {}, scale: scale10 = {}, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = markOptions, resOptions = __rest47(markOptions, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
    const DEFAULT_OPTIONS6 = GET_DEFAULT_OPTIONS2(width, height, encode);
    const transformedData = dataTransform(data2, deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS2(width, height), layout), deep_mix_default({}, DEFAULT_OPTIONS6["encode"], encode));
    const labelStyle = subObject(style, "label");
    return deep_mix_default({}, DEFAULT_OPTIONS6, Object.assign(Object.assign({
      data: transformedData,
      encode,
      scale: scale10,
      style,
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS4), labelStyle),
        ...labels
      ]
    }, resOptions), { tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS2), axis: false }));
  };
  Pack2.props = {};

  // node_modules/@antv/g2/esm/mark/boxplot.js
  var __rest48 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function min9(I, V) {
    return min4(I, (i) => V[i]);
  }
  function max10(I, V) {
    return max5(I, (i) => V[i]);
  }
  function lower(I, V) {
    const lo = q1(I, V) * 2.5 - q3(I, V) * 1.5;
    return min4(I, (i) => V[i] >= lo ? V[i] : NaN);
  }
  function q1(I, V) {
    return quantile(I, 0.25, (i) => V[i]);
  }
  function q2(I, V) {
    return quantile(I, 0.5, (i) => V[i]);
  }
  function q3(I, V) {
    return quantile(I, 0.75, (i) => V[i]);
  }
  function upper(I, V) {
    const hi = q3(I, V) * 2.5 - q1(I, V) * 1.5;
    return max5(I, (i) => V[i] <= hi ? V[i] : NaN);
  }
  function OutlierY() {
    return (I, mark) => {
      const { encode } = mark;
      const { y: y3, x: x3 } = encode;
      const { value: V } = y3;
      const { value: X } = x3;
      const GI = Array.from(group(I, (i) => X[+i]).values());
      const FI = GI.flatMap((I2) => {
        const lo = lower(I2, V);
        const hi = upper(I2, V);
        return I2.filter((i) => V[i] < lo || V[i] > hi);
      });
      return [FI, mark];
    };
  }
  var Boxplot = (options) => {
    const { data: data2, encode, style = {}, tooltip: tooltip2 = {}, transform, animate: animate2 } = options, rest = __rest48(options, ["data", "encode", "style", "tooltip", "transform", "animate"]);
    const { point: point6 = true } = style, restStyle = __rest48(style, ["point"]);
    const { y: y3 } = encode;
    const encodeY = { y: y3, y1: y3, y2: y3, y3, y4: y3 };
    const qy = { y1: q1, y2: q2, y3: q3 };
    const boxTooltip = subTooltip(tooltip2, "box", {
      items: [
        { channel: "y", name: "min" },
        { channel: "y1", name: "q1" },
        { channel: "y2", name: "q2" },
        { channel: "y3", name: "q3" },
        { channel: "y4", name: "max" }
      ]
    }, true);
    const pointTooltip = subTooltip(tooltip2, "point", {
      title: { channel: "x" },
      items: [{ name: "outlier", channel: "y" }]
    });
    if (!point6) {
      return Object.assign({ type: "box", data: data2, transform: [
        Object.assign(Object.assign({ type: "groupX", y: min9 }, qy), { y4: max10 })
      ], encode: Object.assign(Object.assign({}, encode), encodeY), style: restStyle, tooltip: boxTooltip }, rest);
    }
    const boxStyle = subObject(restStyle, "box");
    const pointStyle = subObject(restStyle, "point");
    return [
      Object.assign({ type: "box", data: data2, transform: [
        Object.assign(Object.assign({ type: "groupX", y: lower }, qy), { y4: upper })
      ], encode: Object.assign(Object.assign({}, encode), encodeY), style: boxStyle, tooltip: boxTooltip, animate: maybeAnimation(animate2, "box") }, rest),
      // Draw outliers.
      {
        type: "point",
        data: data2,
        transform: [{ type: OutlierY }],
        encode,
        style: Object.assign({}, pointStyle),
        tooltip: pointTooltip,
        animate: maybeAnimation(animate2, "point")
      }
    ];
  };
  Boxplot.props = {};

  // node_modules/@antv/g2/esm/mark/shape.js
  var shape20 = {
    shape: Shape2
  };
  var Shape3 = (options) => {
    const { cartesian: cartesian2 } = options;
    if (cartesian2)
      return visualMark;
    return (index4, scale10, value2, coordinate) => {
      const { x: X, y: Y } = value2;
      const offset3 = createBandOffset(scale10, value2, options);
      const P = Array.from(index4, (i) => {
        const p2 = [+X[i], +Y[i]];
        return [coordinate.map(offset3(p2, i))];
      });
      return [index4, P];
    };
  };
  Shape3.props = {
    defaultShape: "shape",
    defaultLabelShape: "label",
    composite: false,
    shape: shape20,
    channels: [
      { name: "x", required: true },
      { name: "y", required: true }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeTuple },
      { type: MaybeVisualPosition },
      { type: MaybeFunctionAttribute }
    ]
  };

  // node_modules/d3-force/src/center.js
  function center_default(x3, y3) {
    var nodes, strength = 1;
    if (x3 == null) x3 = 0;
    if (y3 == null) y3 = 0;
    function force() {
      var i, n2 = nodes.length, node, sx = 0, sy = 0;
      for (i = 0; i < n2; ++i) {
        node = nodes[i], sx += node.x, sy += node.y;
      }
      for (sx = (sx / n2 - x3) * strength, sy = (sy / n2 - y3) * strength, i = 0; i < n2; ++i) {
        node = nodes[i], node.x -= sx, node.y -= sy;
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
    };
    force.x = function(_2) {
      return arguments.length ? (x3 = +_2, force) : x3;
    };
    force.y = function(_2) {
      return arguments.length ? (y3 = +_2, force) : y3;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = +_2, force) : strength;
    };
    return force;
  }

  // node_modules/d3-quadtree/src/add.js
  function add_default(d3) {
    const x3 = +this._x.call(null, d3), y3 = +this._y.call(null, d3);
    return add10(this.cover(x3, y3), x3, y3, d3);
  }
  function add10(tree, x3, y3, d3) {
    if (isNaN(x3) || isNaN(y3)) return tree;
    var parent, node = tree._root, leaf = { data: d3 }, x05 = tree._x0, y05 = tree._y0, x12 = tree._x1, y12 = tree._y1, xm, ym, xp, yp, right2, bottom, i, j;
    if (!node) return tree._root = leaf, tree;
    while (node.length) {
      if (right2 = x3 >= (xm = (x05 + x12) / 2)) x05 = xm;
      else x12 = xm;
      if (bottom = y3 >= (ym = (y05 + y12) / 2)) y05 = ym;
      else y12 = ym;
      if (parent = node, !(node = node[i = bottom << 1 | right2])) return parent[i] = leaf, tree;
    }
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    if (x3 === xp && y3 === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
    do {
      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
      if (right2 = x3 >= (xm = (x05 + x12) / 2)) x05 = xm;
      else x12 = xm;
      if (bottom = y3 >= (ym = (y05 + y12) / 2)) y05 = ym;
      else y12 = ym;
    } while ((i = bottom << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));
    return parent[j] = node, parent[i] = leaf, tree;
  }
  function addAll(data2) {
    var d3, i, n2 = data2.length, x3, y3, xz = new Array(n2), yz = new Array(n2), x05 = Infinity, y05 = Infinity, x12 = -Infinity, y12 = -Infinity;
    for (i = 0; i < n2; ++i) {
      if (isNaN(x3 = +this._x.call(null, d3 = data2[i])) || isNaN(y3 = +this._y.call(null, d3))) continue;
      xz[i] = x3;
      yz[i] = y3;
      if (x3 < x05) x05 = x3;
      if (x3 > x12) x12 = x3;
      if (y3 < y05) y05 = y3;
      if (y3 > y12) y12 = y3;
    }
    if (x05 > x12 || y05 > y12) return this;
    this.cover(x05, y05).cover(x12, y12);
    for (i = 0; i < n2; ++i) {
      add10(this, xz[i], yz[i], data2[i]);
    }
    return this;
  }

  // node_modules/d3-quadtree/src/cover.js
  function cover_default(x3, y3) {
    if (isNaN(x3 = +x3) || isNaN(y3 = +y3)) return this;
    var x05 = this._x0, y05 = this._y0, x12 = this._x1, y12 = this._y1;
    if (isNaN(x05)) {
      x12 = (x05 = Math.floor(x3)) + 1;
      y12 = (y05 = Math.floor(y3)) + 1;
    } else {
      var z = x12 - x05 || 1, node = this._root, parent, i;
      while (x05 > x3 || x3 >= x12 || y05 > y3 || y3 >= y12) {
        i = (y3 < y05) << 1 | x3 < x05;
        parent = new Array(4), parent[i] = node, node = parent, z *= 2;
        switch (i) {
          case 0:
            x12 = x05 + z, y12 = y05 + z;
            break;
          case 1:
            x05 = x12 - z, y12 = y05 + z;
            break;
          case 2:
            x12 = x05 + z, y05 = y12 - z;
            break;
          case 3:
            x05 = x12 - z, y05 = y12 - z;
            break;
        }
      }
      if (this._root && this._root.length) this._root = node;
    }
    this._x0 = x05;
    this._y0 = y05;
    this._x1 = x12;
    this._y1 = y12;
    return this;
  }

  // node_modules/d3-quadtree/src/data.js
  function data_default() {
    var data2 = [];
    this.visit(function(node) {
      if (!node.length) do
        data2.push(node.data);
      while (node = node.next);
    });
    return data2;
  }

  // node_modules/d3-quadtree/src/extent.js
  function extent_default(_2) {
    return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
  }

  // node_modules/d3-quadtree/src/quad.js
  function quad_default(node, x05, y05, x12, y12) {
    this.node = node;
    this.x0 = x05;
    this.y0 = y05;
    this.x1 = x12;
    this.y1 = y12;
  }

  // node_modules/d3-quadtree/src/find.js
  function find_default3(x3, y3, radius) {
    var data2, x05 = this._x0, y05 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
    if (node) quads.push(new quad_default(node, x05, y05, x32, y32));
    if (radius == null) radius = Infinity;
    else {
      x05 = x3 - radius, y05 = y3 - radius;
      x32 = x3 + radius, y32 = y3 + radius;
      radius *= radius;
    }
    while (q = quads.pop()) {
      if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x05 || (y22 = q.y1) < y05) continue;
      if (node.length) {
        var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
        quads.push(
          new quad_default(node[3], xm, ym, x22, y22),
          new quad_default(node[2], x12, ym, xm, y22),
          new quad_default(node[1], xm, y12, x22, ym),
          new quad_default(node[0], x12, y12, xm, ym)
        );
        if (i = (y3 >= ym) << 1 | x3 >= xm) {
          q = quads[quads.length - 1];
          quads[quads.length - 1] = quads[quads.length - 1 - i];
          quads[quads.length - 1 - i] = q;
        }
      } else {
        var dx = x3 - +this._x.call(null, node.data), dy = y3 - +this._y.call(null, node.data), d22 = dx * dx + dy * dy;
        if (d22 < radius) {
          var d3 = Math.sqrt(radius = d22);
          x05 = x3 - d3, y05 = y3 - d3;
          x32 = x3 + d3, y32 = y3 + d3;
          data2 = node.data;
        }
      }
    }
    return data2;
  }

  // node_modules/d3-quadtree/src/remove.js
  function remove_default(d3) {
    if (isNaN(x3 = +this._x.call(null, d3)) || isNaN(y3 = +this._y.call(null, d3))) return this;
    var parent, node = this._root, retainer, previous, next, x05 = this._x0, y05 = this._y0, x12 = this._x1, y12 = this._y1, x3, y3, xm, ym, right2, bottom, i, j;
    if (!node) return this;
    if (node.length) while (true) {
      if (right2 = x3 >= (xm = (x05 + x12) / 2)) x05 = xm;
      else x12 = xm;
      if (bottom = y3 >= (ym = (y05 + y12) / 2)) y05 = ym;
      else y12 = ym;
      if (!(parent = node, node = node[i = bottom << 1 | right2])) return this;
      if (!node.length) break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
    }
    while (node.data !== d3) if (!(previous = node, node = node.next)) return this;
    if (next = node.next) delete node.next;
    if (previous) return next ? previous.next = next : delete previous.next, this;
    if (!parent) return this._root = next, this;
    next ? parent[i] = next : delete parent[i];
    if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
      if (retainer) retainer[j] = node;
      else this._root = node;
    }
    return this;
  }
  function removeAll(data2) {
    for (var i = 0, n2 = data2.length; i < n2; ++i) this.remove(data2[i]);
    return this;
  }

  // node_modules/d3-quadtree/src/root.js
  function root_default() {
    return this._root;
  }

  // node_modules/d3-quadtree/src/size.js
  function size_default() {
    var size2 = 0;
    this.visit(function(node) {
      if (!node.length) do
        ++size2;
      while (node = node.next);
    });
    return size2;
  }

  // node_modules/d3-quadtree/src/visit.js
  function visit_default2(callback) {
    var quads = [], q, node = this._root, child, x05, y05, x12, y12;
    if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      if (!callback(node = q.node, x05 = q.x0, y05 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
        var xm = (x05 + x12) / 2, ym = (y05 + y12) / 2;
        if (child = node[3]) quads.push(new quad_default(child, xm, ym, x12, y12));
        if (child = node[2]) quads.push(new quad_default(child, x05, ym, xm, y12));
        if (child = node[1]) quads.push(new quad_default(child, xm, y05, x12, ym));
        if (child = node[0]) quads.push(new quad_default(child, x05, y05, xm, ym));
      }
    }
    return this;
  }

  // node_modules/d3-quadtree/src/visitAfter.js
  function visitAfter_default(callback) {
    var quads = [], next = [], q;
    if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      var node = q.node;
      if (node.length) {
        var child, x05 = q.x0, y05 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x05 + x12) / 2, ym = (y05 + y12) / 2;
        if (child = node[0]) quads.push(new quad_default(child, x05, y05, xm, ym));
        if (child = node[1]) quads.push(new quad_default(child, xm, y05, x12, ym));
        if (child = node[2]) quads.push(new quad_default(child, x05, ym, xm, y12));
        if (child = node[3]) quads.push(new quad_default(child, xm, ym, x12, y12));
      }
      next.push(q);
    }
    while (q = next.pop()) {
      callback(q.node, q.x0, q.y0, q.x1, q.y1);
    }
    return this;
  }

  // node_modules/d3-quadtree/src/x.js
  function defaultX(d3) {
    return d3[0];
  }
  function x_default(_2) {
    return arguments.length ? (this._x = _2, this) : this._x;
  }

  // node_modules/d3-quadtree/src/y.js
  function defaultY(d3) {
    return d3[1];
  }
  function y_default(_2) {
    return arguments.length ? (this._y = _2, this) : this._y;
  }

  // node_modules/d3-quadtree/src/quadtree.js
  function quadtree(nodes, x3, y3) {
    var tree = new Quadtree(x3 == null ? defaultX : x3, y3 == null ? defaultY : y3, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }
  function Quadtree(x3, y3, x05, y05, x12, y12) {
    this._x = x3;
    this._y = y3;
    this._x0 = x05;
    this._y0 = y05;
    this._x1 = x12;
    this._y1 = y12;
    this._root = void 0;
  }
  function leaf_copy(leaf) {
    var copy7 = { data: leaf.data }, next = copy7;
    while (leaf = leaf.next) next = next.next = { data: leaf.data };
    return copy7;
  }
  var treeProto = quadtree.prototype = Quadtree.prototype;
  treeProto.copy = function() {
    var copy7 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
    if (!node) return copy7;
    if (!node.length) return copy7._root = leaf_copy(node), copy7;
    nodes = [{ source: node, target: copy7._root = new Array(4) }];
    while (node = nodes.pop()) {
      for (var i = 0; i < 4; ++i) {
        if (child = node.source[i]) {
          if (child.length) nodes.push({ source: child, target: node.target[i] = new Array(4) });
          else node.target[i] = leaf_copy(child);
        }
      }
    }
    return copy7;
  };
  treeProto.add = add_default;
  treeProto.addAll = addAll;
  treeProto.cover = cover_default;
  treeProto.data = data_default;
  treeProto.extent = extent_default;
  treeProto.find = find_default3;
  treeProto.remove = remove_default;
  treeProto.removeAll = removeAll;
  treeProto.root = root_default;
  treeProto.size = size_default;
  treeProto.visit = visit_default2;
  treeProto.visitAfter = visitAfter_default;
  treeProto.x = x_default;
  treeProto.y = y_default;

  // node_modules/d3-force/src/constant.js
  function constant_default3(x3) {
    return function() {
      return x3;
    };
  }

  // node_modules/d3-force/src/jiggle.js
  function jiggle_default(random5) {
    return (random5() - 0.5) * 1e-6;
  }

  // node_modules/d3-force/src/link.js
  function index3(d3) {
    return d3.index;
  }
  function find6(nodeById, nodeId) {
    var node = nodeById.get(nodeId);
    if (!node) throw new Error("node not found: " + nodeId);
    return node;
  }
  function link_default(links) {
    var id5 = index3, strength = defaultStrength, strengths, distance7 = constant_default3(30), distances, nodes, count4, bias, random5, iterations2 = 1;
    if (links == null) links = [];
    function defaultStrength(link2) {
      return 1 / Math.min(count4[link2.source.index], count4[link2.target.index]);
    }
    function force(alpha) {
      for (var k = 0, n2 = links.length; k < iterations2; ++k) {
        for (var i = 0, link2, source, target, x3, y3, l2, b; i < n2; ++i) {
          link2 = links[i], source = link2.source, target = link2.target;
          x3 = target.x + target.vx - source.x - source.vx || jiggle_default(random5);
          y3 = target.y + target.vy - source.y - source.vy || jiggle_default(random5);
          l2 = Math.sqrt(x3 * x3 + y3 * y3);
          l2 = (l2 - distances[i]) / l2 * alpha * strengths[i];
          x3 *= l2, y3 *= l2;
          target.vx -= x3 * (b = bias[i]);
          target.vy -= y3 * b;
          source.vx += x3 * (b = 1 - b);
          source.vy += y3 * b;
        }
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n2 = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d3, i2) => [id5(d3, i2, nodes), d3])), link2;
      for (i = 0, count4 = new Array(n2); i < m3; ++i) {
        link2 = links[i], link2.index = i;
        if (typeof link2.source !== "object") link2.source = find6(nodeById, link2.source);
        if (typeof link2.target !== "object") link2.target = find6(nodeById, link2.target);
        count4[link2.source.index] = (count4[link2.source.index] || 0) + 1;
        count4[link2.target.index] = (count4[link2.target.index] || 0) + 1;
      }
      for (i = 0, bias = new Array(m3); i < m3; ++i) {
        link2 = links[i], bias[i] = count4[link2.source.index] / (count4[link2.source.index] + count4[link2.target.index]);
      }
      strengths = new Array(m3), initializeStrength();
      distances = new Array(m3), initializeDistance();
    }
    function initializeStrength() {
      if (!nodes) return;
      for (var i = 0, n2 = links.length; i < n2; ++i) {
        strengths[i] = +strength(links[i], i, links);
      }
    }
    function initializeDistance() {
      if (!nodes) return;
      for (var i = 0, n2 = links.length; i < n2; ++i) {
        distances[i] = +distance7(links[i], i, links);
      }
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random5 = _random;
      initialize();
    };
    force.links = function(_2) {
      return arguments.length ? (links = _2, initialize(), force) : links;
    };
    force.id = function(_2) {
      return arguments.length ? (id5 = _2, force) : id5;
    };
    force.iterations = function(_2) {
      return arguments.length ? (iterations2 = +_2, force) : iterations2;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initializeStrength(), force) : strength;
    };
    force.distance = function(_2) {
      return arguments.length ? (distance7 = typeof _2 === "function" ? _2 : constant_default3(+_2), initializeDistance(), force) : distance7;
    };
    return force;
  }

  // node_modules/d3-dispatch/src/dispatch.js
  var noop = { value: () => {
  } };
  function dispatch2() {
    for (var i = 0, n2 = arguments.length, _2 = {}, t; i < n2; ++i) {
      if (!(t = arguments[i] + "") || t in _2 || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
      _2[t] = [];
    }
    return new Dispatch(_2);
  }
  function Dispatch(_2) {
    this._ = _2;
  }
  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name2 = "", i = t.indexOf(".");
      if (i >= 0) name2 = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      return { type: t, name: name2 };
    });
  }
  Dispatch.prototype = dispatch2.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _2 = this._, T = parseTypenames(typename + "", _2), t, i = -1, n2 = T.length;
      if (arguments.length < 2) {
        while (++i < n2) if ((t = (typename = T[i]).type) && (t = get(_2[t], typename.name))) return t;
        return;
      }
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i < n2) {
        if (t = (typename = T[i]).type) _2[t] = set7(_2[t], typename.name, callback);
        else if (callback == null) for (t in _2) _2[t] = set7(_2[t], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy7 = {}, _2 = this._;
      for (var t in _2) copy7[t] = _2[t].slice();
      return new Dispatch(copy7);
    },
    call: function(type, that) {
      if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i = 0, n2, t; i < n2; ++i) args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (t = this._[type], i = 0, n2 = t.length; i < n2; ++i) t[i].value.apply(that, args);
    },
    apply: function(type, that, args) {
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (var t = this._[type], i = 0, n2 = t.length; i < n2; ++i) t[i].value.apply(that, args);
    }
  };
  function get(type, name2) {
    for (var i = 0, n2 = type.length, c5; i < n2; ++i) {
      if ((c5 = type[i]).name === name2) {
        return c5.value;
      }
    }
  }
  function set7(type, name2, callback) {
    for (var i = 0, n2 = type.length; i < n2; ++i) {
      if (type[i].name === name2) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null) type.push({ name: name2, value: callback });
    return type;
  }
  var dispatch_default2 = dispatch2;

  // node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock2 = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now3() {
    return clockNow || (setFrame(clearNow), clockNow = clock2.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function") throw new TypeError("callback is not a function");
      time = (time == null ? now3() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail) taskTail._next = this;
        else taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    var t = new Timer();
    t.restart(callback, delay, time);
    return t;
  }
  function timerFlush() {
    now3();
    ++frame;
    var t = taskHead, e3;
    while (t) {
      if ((e3 = clockNow - t._time) >= 0) t._call.call(void 0, e3);
      t = t._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock2.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now4 = clock2.now(), delay = now4 - clockLast;
    if (delay > pokeDelay) clockSkew -= delay, clockLast = now4;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame) return;
    if (timeout) timeout = clearTimeout(timeout);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity) timeout = setTimeout(wake, time - clock2.now() - clockSkew);
      if (interval) interval = clearInterval(interval);
    } else {
      if (!interval) clockLast = clock2.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // node_modules/d3-force/src/lcg.js
  var a2 = 1664525;
  var c2 = 1013904223;
  var m2 = 4294967296;
  function lcg_default2() {
    let s3 = 1;
    return () => (s3 = (a2 * s3 + c2) % m2) / m2;
  }

  // node_modules/d3-force/src/simulation.js
  function x2(d3) {
    return d3.x;
  }
  function y2(d3) {
    return d3.y;
  }
  var initialRadius = 10;
  var initialAngle = Math.PI * (3 - Math.sqrt(5));
  function simulation_default(nodes) {
    var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step2), event = dispatch_default2("tick", "end"), random5 = lcg_default2();
    if (nodes == null) nodes = [];
    function step2() {
      tick3();
      event.call("tick", simulation);
      if (alpha < alphaMin) {
        stepper.stop();
        event.call("end", simulation);
      }
    }
    function tick3(iterations2) {
      var i, n2 = nodes.length, node;
      if (iterations2 === void 0) iterations2 = 1;
      for (var k = 0; k < iterations2; ++k) {
        alpha += (alphaTarget - alpha) * alphaDecay;
        forces.forEach(function(force) {
          force(alpha);
        });
        for (i = 0; i < n2; ++i) {
          node = nodes[i];
          if (node.fx == null) node.x += node.vx *= velocityDecay;
          else node.x = node.fx, node.vx = 0;
          if (node.fy == null) node.y += node.vy *= velocityDecay;
          else node.y = node.fy, node.vy = 0;
        }
      }
      return simulation;
    }
    function initializeNodes() {
      for (var i = 0, n2 = nodes.length, node; i < n2; ++i) {
        node = nodes[i], node.index = i;
        if (node.fx != null) node.x = node.fx;
        if (node.fy != null) node.y = node.fy;
        if (isNaN(node.x) || isNaN(node.y)) {
          var radius = initialRadius * Math.sqrt(0.5 + i), angle4 = i * initialAngle;
          node.x = radius * Math.cos(angle4);
          node.y = radius * Math.sin(angle4);
        }
        if (isNaN(node.vx) || isNaN(node.vy)) {
          node.vx = node.vy = 0;
        }
      }
    }
    function initializeForce(force) {
      if (force.initialize) force.initialize(nodes, random5);
      return force;
    }
    initializeNodes();
    return simulation = {
      tick: tick3,
      restart: function() {
        return stepper.restart(step2), simulation;
      },
      stop: function() {
        return stepper.stop(), simulation;
      },
      nodes: function(_2) {
        return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
      },
      alpha: function(_2) {
        return arguments.length ? (alpha = +_2, simulation) : alpha;
      },
      alphaMin: function(_2) {
        return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
      },
      alphaDecay: function(_2) {
        return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
      },
      alphaTarget: function(_2) {
        return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
      },
      velocityDecay: function(_2) {
        return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
      },
      randomSource: function(_2) {
        return arguments.length ? (random5 = _2, forces.forEach(initializeForce), simulation) : random5;
      },
      force: function(name2, _2) {
        return arguments.length > 1 ? (_2 == null ? forces.delete(name2) : forces.set(name2, initializeForce(_2)), simulation) : forces.get(name2);
      },
      find: function(x3, y3, radius) {
        var i = 0, n2 = nodes.length, dx, dy, d22, node, closest2;
        if (radius == null) radius = Infinity;
        else radius *= radius;
        for (i = 0; i < n2; ++i) {
          node = nodes[i];
          dx = x3 - node.x;
          dy = y3 - node.y;
          d22 = dx * dx + dy * dy;
          if (d22 < radius) closest2 = node, radius = d22;
        }
        return closest2;
      },
      on: function(name2, _2) {
        return arguments.length > 1 ? (event.on(name2, _2), simulation) : event.on(name2);
      }
    };
  }

  // node_modules/d3-force/src/manyBody.js
  function manyBody_default() {
    var nodes, node, random5, alpha, strength = constant_default3(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
    function force(_2) {
      var i, n2 = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
      for (alpha = _2, i = 0; i < n2; ++i) node = nodes[i], tree.visit(apply);
    }
    function initialize() {
      if (!nodes) return;
      var i, n2 = nodes.length, node2;
      strengths = new Array(n2);
      for (i = 0; i < n2; ++i) node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
    }
    function accumulate(quad) {
      var strength2 = 0, q, c5, weight2 = 0, x3, y3, i;
      if (quad.length) {
        for (x3 = y3 = i = 0; i < 4; ++i) {
          if ((q = quad[i]) && (c5 = Math.abs(q.value))) {
            strength2 += q.value, weight2 += c5, x3 += c5 * q.x, y3 += c5 * q.y;
          }
        }
        quad.x = x3 / weight2;
        quad.y = y3 / weight2;
      } else {
        q = quad;
        q.x = q.data.x;
        q.y = q.data.y;
        do
          strength2 += strengths[q.data.index];
        while (q = q.next);
      }
      quad.value = strength2;
    }
    function apply(quad, x12, _2, x22) {
      if (!quad.value) return true;
      var x3 = quad.x - node.x, y3 = quad.y - node.y, w = x22 - x12, l2 = x3 * x3 + y3 * y3;
      if (w * w / theta2 < l2) {
        if (l2 < distanceMax2) {
          if (x3 === 0) x3 = jiggle_default(random5), l2 += x3 * x3;
          if (y3 === 0) y3 = jiggle_default(random5), l2 += y3 * y3;
          if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
          node.vx += x3 * quad.value * alpha / l2;
          node.vy += y3 * quad.value * alpha / l2;
        }
        return true;
      } else if (quad.length || l2 >= distanceMax2) return;
      if (quad.data !== node || quad.next) {
        if (x3 === 0) x3 = jiggle_default(random5), l2 += x3 * x3;
        if (y3 === 0) y3 = jiggle_default(random5), l2 += y3 * y3;
        if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
      }
      do
        if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l2;
          node.vx += x3 * w;
          node.vy += y3 * w;
        }
      while (quad = quad.next);
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random5 = _random;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
    };
    force.distanceMin = function(_2) {
      return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
    };
    force.distanceMax = function(_2) {
      return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
    };
    force.theta = function(_2) {
      return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
    };
    return force;
  }

  // node_modules/d3-force/src/x.js
  function x_default2(x3) {
    var strength = constant_default3(0.1), nodes, strengths, xz;
    if (typeof x3 !== "function") x3 = constant_default3(x3 == null ? 0 : +x3);
    function force(alpha) {
      for (var i = 0, n2 = nodes.length, node; i < n2; ++i) {
        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n2 = nodes.length;
      strengths = new Array(n2);
      xz = new Array(n2);
      for (i = 0; i < n2; ++i) {
        strengths[i] = isNaN(xz[i] = +x3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
    };
    force.x = function(_2) {
      return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : x3;
    };
    return force;
  }

  // node_modules/d3-force/src/y.js
  function y_default2(y3) {
    var strength = constant_default3(0.1), nodes, strengths, yz;
    if (typeof y3 !== "function") y3 = constant_default3(y3 == null ? 0 : +y3);
    function force(alpha) {
      for (var i = 0, n2 = nodes.length, node; i < n2; ++i) {
        node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n2 = nodes.length;
      strengths = new Array(n2);
      yz = new Array(n2);
      for (i = 0; i < n2; ++i) {
        strengths[i] = isNaN(yz[i] = +y3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
    };
    force.y = function(_2) {
      return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : y3;
    };
    return force;
  }

  // node_modules/@antv/g2/esm/mark/forceGraph.js
  var __rest49 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var DEFAULT_LAYOUT_OPTIONS3 = {
    joint: true
  };
  var DEFAULT_LINK_OPTIONS3 = {
    type: "link",
    axis: false,
    legend: false,
    encode: {
      x: [(d3) => d3.source.x, (d3) => d3.target.x],
      y: [(d3) => d3.source.y, (d3) => d3.target.y]
    },
    style: {
      stroke: "#999",
      strokeOpacity: 0.6
    }
  };
  var DEFAULT_NODE_OPTIONS3 = {
    type: "point",
    axis: false,
    legend: false,
    encode: {
      x: "x",
      y: "y",
      size: 5,
      color: "group",
      shape: "point"
    },
    style: {
      stroke: "#fff"
    }
  };
  var DEFAULT_LABEL_OPTIONS5 = {
    text: ""
  };
  function dataTransform2(data2, layout, encode) {
    const { nodes, links } = data2;
    const { joint, nodeStrength, linkStrength } = layout;
    const { nodeKey = (d3) => d3.id, linkKey = (d3) => d3.id } = encode;
    const nodeForce = manyBody_default();
    const linkForce = link_default(links).id(field(linkKey));
    typeof nodeStrength === "function" && nodeForce.strength(nodeStrength);
    typeof linkStrength === "function" && linkForce.strength(linkStrength);
    const simulation = simulation_default(nodes).force("link", linkForce).force("charge", nodeForce);
    joint ? simulation.force("center", center_default()) : simulation.force("x", x_default2()).force("y", y_default2());
    simulation.stop();
    const n2 = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay()));
    for (let i = 0; i < n2; i++)
      simulation.tick();
    return {
      nodesData: nodes,
      linksData: links
    };
  }
  var ForceGraph = (options) => {
    const { data: data2, encode: e3 = {}, scale: scale10, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
    const { nodeKey = (d3) => d3.id, linkKey = (d3) => d3.id } = e3, restEncode = __rest49(e3, ["nodeKey", "linkKey"]);
    const encode = Object.assign({ nodeKey, linkKey }, restEncode);
    const nodeEncode = subObject(encode, "node");
    const linkEncode = subObject(encode, "link");
    const { links, nodes } = initializeData(data2, encode);
    const { nodesData, linksData } = dataTransform2({ links, nodes }, deep_mix_default({}, DEFAULT_LAYOUT_OPTIONS3, layout), encode);
    const linkTooltip = subTooltip(tooltip2, "link", {
      items: [
        (d3) => ({ name: "source", value: field(linkKey)(d3.source) }),
        (d3) => ({ name: "target", value: field(linkKey)(d3.target) })
      ]
    });
    const nodeTooltip = subTooltip(tooltip2, "node", {
      items: [(d3) => ({ name: "key", value: field(nodeKey)(d3) })]
    }, true);
    return [
      deep_mix_default({}, DEFAULT_LINK_OPTIONS3, {
        data: linksData,
        encode: linkEncode,
        labels: linkLabels,
        style: subObject(style, "link"),
        tooltip: linkTooltip,
        animate: maybeAnimation(animate2, "link")
      }),
      deep_mix_default({}, DEFAULT_NODE_OPTIONS3, {
        data: nodesData,
        encode: Object.assign({}, nodeEncode),
        scale: scale10,
        style: subObject(style, "node"),
        tooltip: nodeTooltip,
        labels: [
          Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS5), subObject(style, "label")),
          ...nodeLabels
        ],
        animate: maybeAnimation(animate2, "link")
      })
    ];
  };
  ForceGraph.props = {};

  // node_modules/@antv/g2/esm/data/cluster.js
  var hierarchyFunction = (layoutFunction) => (options) => {
    return (data2) => {
      const { field: field3 = "value", nodeSize, separation, sortBy, as = ["x", "y"] } = options;
      const [x3, y3] = as;
      const root2 = hierarchy(data2, (d3) => d3.children).sum((d3) => d3[field3]).sort(sortBy);
      const c5 = layoutFunction();
      c5.size([1, 1]);
      if (nodeSize)
        c5.nodeSize(nodeSize);
      if (separation)
        c5.separation(separation);
      c5(root2);
      const nodes = [];
      root2.each((node) => {
        node[x3] = node.x;
        node[y3] = node.y;
        node.name = node.data.name;
        nodes.push(node);
      });
      const edges = root2.links();
      edges.forEach((edge) => {
        edge[x3] = [edge.source[x3], edge.target[x3]];
        edge[y3] = [edge.source[y3], edge.target[y3]];
      });
      return { nodes, edges };
    };
  };
  var Cluster = (options) => {
    return hierarchyFunction(cluster_default)(options);
  };
  Cluster.props = {};

  // node_modules/@antv/g2/esm/data/tree.js
  var Tree = (options) => {
    return hierarchyFunction(tree_default2)(options);
  };
  Tree.props = {};

  // node_modules/@antv/g2/esm/mark/tree.js
  var DEFAULT_LAYOUT_OPTIONS4 = {
    sortBy: (a3, b) => b.value - a3.value
  };
  var DEFAULT_NODE_OPTIONS4 = {
    axis: false,
    legend: false,
    type: "point",
    encode: {
      x: "x",
      y: "y",
      size: 2,
      shape: "point"
    }
  };
  var DEFAULT_LINK_OPTIONS4 = {
    type: "link",
    encode: {
      x: "x",
      y: "y",
      shape: "smooth"
    }
  };
  var DEFAULT_LABEL_OPTIONS6 = {
    text: "",
    fontSize: 10
  };
  var Tree2 = (options) => {
    const { data: data2, encode = {}, scale: scale10 = {}, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
    const valueEncode = encode === null || encode === void 0 ? void 0 : encode.value;
    const { nodes, edges } = Tree(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS4), layout), { field: valueEncode }))(data2);
    const nodeTooltip = subTooltip(tooltip2, "node", {
      title: "name",
      items: ["value"]
    }, true);
    const linkTooltip = subTooltip(tooltip2, "link", {
      title: "",
      items: [
        (d3) => ({ name: "source", value: d3.source.name }),
        (d3) => ({ name: "target", value: d3.target.name })
      ]
    });
    return [
      deep_mix_default({}, DEFAULT_LINK_OPTIONS4, {
        data: edges,
        encode: subObject(encode, "link"),
        scale: subObject(scale10, "link"),
        labels: linkLabels,
        style: Object.assign({ stroke: "#999" }, subObject(style, "link")),
        tooltip: linkTooltip,
        animate: maybeAnimation(animate2, "link")
      }),
      deep_mix_default({}, DEFAULT_NODE_OPTIONS4, {
        data: nodes,
        scale: subObject(scale10, "node"),
        encode: subObject(encode, "node"),
        labels: [
          Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS6), subObject(style, "label")),
          ...nodeLabels
        ],
        style: Object.assign({}, subObject(style, "node")),
        tooltip: nodeTooltip,
        animate: maybeAnimation(animate2, "node")
      })
    ];
  };
  Tree2.props = {};

  // node_modules/@antv/g2/esm/mark/wordCloud.js
  var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest50 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function initializeData2(data2, encode) {
    const { text = "text", value: value2 = "value" } = encode;
    return data2.map((d3) => Object.assign(Object.assign({}, d3), { text: d3[text], value: d3[value2] }));
  }
  var GET_DEFAULT_OPTIONS3 = () => ({
    axis: false,
    type: "text",
    encode: {
      x: "x",
      y: "y",
      text: "text",
      rotate: "rotate",
      fontSize: "size",
      shape: "tag"
    },
    scale: {
      x: { range: [0, 1] },
      y: { range: [0, 1] }
    },
    style: {
      fontFamily: (d3) => d3.fontFamily
    }
  });
  var WordCloud = (options, context) => __awaiter2(void 0, void 0, void 0, function* () {
    const { width, height } = context;
    const { data: data2, encode = {}, scale: scale10, style = {}, layout = {} } = options, resOptions = __rest50(options, ["data", "encode", "scale", "style", "layout"]);
    const initializedData = initializeData2(data2, encode);
    return deep_mix_default({}, GET_DEFAULT_OPTIONS3(), Object.assign(Object.assign({
      data: {
        value: initializedData,
        transform: [
          Object.assign({ type: "wordCloud", size: [width, height] }, layout)
        ]
      },
      encode,
      scale: scale10,
      style
    }, resOptions), { axis: false }));
  });
  WordCloud.props = {};

  // node_modules/@antv/g2/esm/mark/gauge.js
  var __rest51 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var indicatorShape = (options, context) => {
    const { shape: shape23, radius } = options, style = __rest51(options, ["shape", "radius"]);
    const pointerStyle = subObject(style, "pointer");
    const pinStyle = subObject(style, "pin");
    const { shape: pointerShape } = pointerStyle, resPointerStyle = __rest51(pointerStyle, ["shape"]);
    const { shape: pinShape } = pinStyle, resPinStyle = __rest51(pinStyle, ["shape"]);
    const { coordinate, theme } = context;
    return (points, value2) => {
      const invertedPoints = points.map((p2) => coordinate.invert(p2));
      const [startAngle, endAngle, innerRadius] = getTransformOptions(coordinate, "polar");
      const newCoordinate = coordinate.clone();
      const { color: stroke2 } = value2;
      const newTransformations = Radial({
        startAngle,
        endAngle,
        innerRadius,
        outerRadius: radius
      });
      newTransformations.push(["cartesian"]);
      newCoordinate.update({
        transformations: newTransformations
      });
      const newPoints = invertedPoints.map((p2) => newCoordinate.map(p2));
      const [x3, y3] = getOrigin(newPoints);
      const [cx, cy] = coordinate.getCenter();
      const pointerAttrs = Object.assign(Object.assign({ x1: x3, y1: y3, x2: cx, y2: cy, stroke: stroke2 }, resPointerStyle), style);
      const pinAttrs = Object.assign(Object.assign({
        cx,
        cy,
        stroke: stroke2
      }, resPinStyle), style);
      const indicatorGroup = select(new Group2());
      if (!isUnset(pointerShape)) {
        typeof pointerShape === "function" ? indicatorGroup.append(() => pointerShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("line").call(applyStyle, pointerAttrs).node();
      }
      if (!isUnset(pinShape)) {
        typeof pinShape === "function" ? indicatorGroup.append(() => pinShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("circle").call(applyStyle, pinAttrs).node();
      }
      return indicatorGroup.node();
    };
  };
  var DEFAULT_OPTIONS3 = {
    coordinate: {
      type: "radial",
      innerRadius: 0.9,
      outerRadius: 1,
      startAngle: -11 / 10 * Math.PI,
      endAngle: 1 / 10 * Math.PI
    },
    axis: {
      x: false
    },
    legend: false,
    tooltip: false,
    encode: {
      x: "x",
      y: "y",
      color: "color"
    },
    scale: {
      color: {
        range: ["#30BF78", "#D0D0D0"]
      }
    }
  };
  var DEFAULT_INDICATOR_OPTIONS = {
    style: {
      shape: indicatorShape,
      lineWidth: 4,
      pointerLineCap: "round",
      pinR: 10,
      pinFill: "#fff",
      radius: 0.6
    }
  };
  var DEFAULT_TEXT_OPTIONS = {
    type: "text",
    style: {
      x: "50%",
      y: "60%",
      textAlign: "center",
      textBaseline: "middle",
      fontSize: 20,
      fontWeight: 800,
      fill: "#888"
    },
    tooltip: false
  };
  function getGaugeData(data2) {
    if (isNumber2(data2)) {
      const percent2 = Math.max(0, Math.min(data2, 1));
      return {
        percent: percent2,
        target: percent2,
        total: 1
      };
    }
    return data2;
  }
  function dataTransform3(data2, scale10) {
    const { name: name2 = "score", target, total, percent: percent2, thresholds = [] } = getGaugeData(data2);
    const _target = percent2 || target;
    const _total = percent2 ? 1 : total;
    const newScale = Object.assign({ y: {
      domain: [0, _total]
    } }, scale10);
    if (!thresholds.length) {
      return {
        targetData: [{ x: name2, y: _target, color: "target" }],
        totalData: [
          { x: name2, y: _target, color: "target" },
          { x: name2, y: _total - _target, color: "total" }
        ],
        target: _target,
        total: _total,
        scale: newScale
      };
    }
    return {
      targetData: [{ x: name2, y: _target, color: "target" }],
      totalData: thresholds.map((d3, i) => ({
        x: name2,
        y: i >= 1 ? d3 - thresholds[i - 1] : d3,
        color: i
      })),
      target: _target,
      total: _total,
      scale: newScale
    };
  }
  function getTextContent(textStyle, { target, total }) {
    const { content } = textStyle;
    return content ? content(target, total) : target.toString();
  }
  var Gauge = (options) => {
    const { data: data2 = {}, scale: scale10 = {}, style = {}, animate: animate2 = {}, transform = [] } = options, resOptions = __rest51(options, ["data", "scale", "style", "animate", "transform"]);
    const { targetData, totalData, target, total, scale: newScale } = dataTransform3(data2, scale10);
    const _a = subObject(style, "text"), { tooltip: tooltip2 } = _a, textStyle = __rest51(_a, ["tooltip"]);
    const indicatorStyle = filterPrefixObject(style, ["pointer", "pin"]);
    const arcStyle = subObject(style, "arc");
    const shape23 = arcStyle.shape;
    return [
      deep_mix_default({}, DEFAULT_OPTIONS3, Object.assign({ type: "interval", transform: [{ type: "stackY" }], data: totalData, scale: newScale, style: shape23 === "round" ? Object.assign(Object.assign({}, arcStyle), { shape: Round }) : arcStyle, animate: typeof animate2 === "object" ? subObject(animate2, "arc") : animate2 }, resOptions)),
      deep_mix_default({}, DEFAULT_OPTIONS3, DEFAULT_INDICATOR_OPTIONS, Object.assign({ type: "point", data: targetData, scale: newScale, style: indicatorStyle, animate: typeof animate2 === "object" ? subObject(animate2, "indicator") : animate2 }, resOptions)),
      deep_mix_default({}, DEFAULT_TEXT_OPTIONS, {
        style: Object.assign({ text: getTextContent(textStyle, { target, total }) }, textStyle),
        tooltip: tooltip2,
        animate: typeof animate2 === "object" ? subObject(animate2, "text") : animate2
      })
    ];
  };
  Gauge.props = {};

  // node_modules/@antv/g2/esm/mark/density.js
  var shape21 = {
    density: Density
  };
  var Density2 = () => {
    return (index4, scale10, value2, coordinate) => {
      const { x: X, series: S } = value2;
      const Yn = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
      const SZn = Object.entries(value2).filter(([key]) => key.startsWith("size")).map(([, value3]) => value3);
      if (X === void 0 || Yn === void 0 || SZn === void 0) {
        throw new Error("Missing encode for x or y or size channel.");
      }
      const xScale = scale10.x;
      const series = scale10.series;
      const P = Array.from(index4, (i) => {
        const groupWidth = xScale.getBandWidth(xScale.invert(+X[i]));
        const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i]))) : 1;
        const width = groupWidth * ratio;
        const offset3 = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
        const x3 = +X[i] + offset3 + width / 2;
        const PN = [
          ...Yn.map((_2, idx) => [x3 + +SZn[idx][i] / index4.length, +Yn[idx][i]]),
          ...Yn.map((_2, idx) => [
            x3 - +SZn[idx][i] / index4.length,
            +Yn[idx][i]
          ]).reverse()
          // left
        ];
        return PN.map((p2) => coordinate.map(p2));
      });
      return [index4, P];
    };
  };
  Density2.props = {
    defaultShape: "density",
    defaultLabelShape: "label",
    composite: false,
    shape: shape21,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape21) }),
      { name: "x", scale: "band", required: true },
      { name: "y", required: true },
      { name: "size", required: true },
      { name: "series", scale: "band" },
      { name: "size", required: true, scale: "identity" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeZeroY1 },
      { type: MaybeZeroX }
    ],
    postInference: [...basePostInference(), ...tooltip1d()],
    interaction: { shareTooltip: true }
  };

  // node_modules/@antv/g2/esm/mark/heatmap.js
  var shape22 = {
    heatmap: Heatmap
  };
  var Heatmap2 = (options) => {
    return (index4, scale10, value2, coordinate) => {
      const { x: X, y: Y, size: S, color: C4 } = value2;
      const P = Array.from(index4, (i) => {
        const r = S ? +S[i] : 40;
        return [...coordinate.map([+X[i], +Y[i]]), C4[i], r];
      });
      return [[0], [P]];
    };
  };
  Heatmap2.props = {
    defaultShape: "heatmap",
    defaultLabelShape: "label",
    composite: false,
    shape: shape22,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape22) }),
      { name: "x", required: true },
      { name: "y", required: true },
      { name: "color", scale: "identity", required: true },
      { name: "size" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeZeroX },
      { type: MaybeZeroY }
    ],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // node_modules/@antv/g2/esm/mark/liquid.js
  var __rest52 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var DEFAULT_OPTIONS4 = {
    axis: {
      x: false,
      y: false
    },
    legend: false,
    tooltip: false,
    encode: {
      x: "type",
      y: "percent"
    },
    scale: {
      y: {
        domain: [0, 1]
      }
    },
    style: {
      shape: Liquid
    },
    animate: {
      enter: {
        type: "fadeIn"
      }
    }
  };
  var DEFAULT_TEXT_OPTIONS2 = {
    type: "text",
    style: {
      x: "50%",
      y: "50%",
      textAlign: "center",
      textBaseline: "middle",
      fontSize: 20,
      fontWeight: 800,
      fill: "#888"
    },
    animate: {
      enter: {
        type: "fadeIn"
      }
    }
  };
  var Liquid2 = (options) => {
    const { data: data2 = {}, style = {}, animate: animate2 } = options, resOptions = __rest52(options, ["data", "style", "animate"]);
    const percent2 = Math.max(0, isNumber2(data2) ? data2 : data2 === null || data2 === void 0 ? void 0 : data2.percent);
    const newData = [{ percent: percent2, type: "liquid" }];
    const contentStyle = Object.assign(Object.assign({}, subObject(style, "text")), subObject(style, "content"));
    const outline = subObject(style, "outline");
    const wave = subObject(style, "wave");
    const background = subObject(style, "background");
    return [
      deep_mix_default({}, DEFAULT_OPTIONS4, Object.assign({ type: "interval", data: newData, style: {
        liquidOptions: {
          percent: percent2,
          liquidShape: style === null || style === void 0 ? void 0 : style.shape
        },
        styleOptions: Object.assign(Object.assign({}, style), {
          outline,
          wave,
          background
        })
      }, animate: animate2 }, resOptions)),
      deep_mix_default({}, DEFAULT_TEXT_OPTIONS2, {
        style: Object.assign({ text: `${prettyNumber2(percent2 * 100)} %` }, contentStyle),
        animate: animate2
      })
    ];
  };
  Liquid2.props = {};

  // node_modules/@antv/g2/esm/palette/category10.js
  var Category10 = () => {
    return [
      "#5B8FF9",
      "#5AD8A6",
      "#5D7092",
      "#F6BD16",
      "#6F5EF9",
      "#6DC8EC",
      "#945FB9",
      "#FF9845",
      "#1E9493",
      "#FF99C3"
    ];
  };
  Category10.props = {};

  // node_modules/@antv/g2/esm/palette/category20.js
  var Category20 = () => {
    return [
      "#5B8FF9",
      "#CDDDFD",
      "#5AD8A6",
      "#CDF3E4",
      "#5D7092",
      "#CED4DE",
      "#F6BD16",
      "#FCEBB9",
      "#6F5EF9",
      "#D3CEFD",
      "#6DC8EC",
      "#D3EEF9",
      "#945FB9",
      "#DECFEA",
      "#FF9845",
      "#FFE0C7",
      "#1E9493",
      "#BBDEDE",
      "#FF99C3",
      "#FFE0ED"
    ];
  };
  Category20.props = {};

  // node_modules/@antv/g2/esm/scale/band.js
  var Band2 = (options) => {
    return new Band(options);
  };
  Band2.props = {};

  // node_modules/@antv/g2/esm/scale/linear.js
  var Linear3 = (options) => {
    return new Linear(options);
  };
  Linear3.props = {};

  // node_modules/@antv/g2/esm/scale/ordinal.js
  var Ordinal2 = (options) => {
    return new Ordinal(options);
  };
  Ordinal2.props = {};

  // node_modules/@antv/g2/esm/scale/identity.js
  var Identity2 = (options) => {
    return new Identity(options);
  };
  Identity2.props = {};

  // node_modules/@antv/g2/esm/scale/point.js
  var Point5 = (options) => {
    return new Point(options);
  };
  Point5.props = {};

  // node_modules/@antv/g2/esm/scale/time.js
  var Time2 = (options) => {
    return new Time(options);
  };
  Time2.props = {};

  // node_modules/@antv/g2/esm/scale/log.js
  var Log2 = (options) => {
    return new Log(options);
  };
  Log2.props = {};

  // node_modules/@antv/g2/esm/scale/pow.js
  var Pow2 = (options) => {
    return new Pow(options);
  };
  Pow2.props = {};

  // node_modules/@antv/g2/esm/scale/threshold.js
  var Threshold2 = (options) => {
    return new Threshold(options);
  };
  Threshold2.props = {};

  // node_modules/@antv/g2/esm/scale/quantile.js
  var Quantile2 = (options) => {
    return new Quantile(options);
  };
  Quantile2.props = {};

  // node_modules/@antv/g2/esm/scale/quantize.js
  var Quantize2 = (options) => {
    return new Quantize(options);
  };
  Quantize2.props = {};

  // node_modules/@antv/g2/esm/scale/sqrt.js
  var Sqrt2 = (options) => {
    return new Sqrt(options);
  };
  Sqrt2.props = {};

  // node_modules/@antv/g2/esm/scale/sequential.js
  var Sequential3 = (options) => {
    return new Sequential(options);
  };
  Sequential3.props = {};

  // node_modules/@antv/g2/esm/scale/constant.js
  var Constant3 = (options) => {
    return new Constant2(options);
  };
  Constant3.props = {};

  // node_modules/@antv/g2/esm/theme/create.js
  function create7({ colorDefault, colorBlack, colorWhite, colorStroke, colorBackground, padding1, padding2, padding3, alpha90, alpha65, alpha45, alpha25, alpha10, category10, category20, sizeDefault = 1, padding = "auto", margin = 16 }) {
    return {
      padding,
      margin,
      size: sizeDefault,
      color: colorDefault,
      category10,
      category20,
      enter: {
        duration: 300,
        fill: "both",
        delay: 0
      },
      update: {
        duration: 300,
        fill: "both",
        delay: 0
      },
      exit: {
        duration: 300,
        fill: "both",
        delay: 0
      },
      view: {
        viewFill: colorBackground,
        plotFill: "transparent",
        mainFill: "transparent",
        contentFill: "transparent"
      },
      line: {
        line: {
          fill: "",
          strokeOpacity: 1,
          lineWidth: 1,
          lineCap: "round"
        }
      },
      point: {
        point: {
          r: 3,
          fillOpacity: 0.95,
          lineWidth: 0
        },
        hollow: {
          r: 3,
          strokeOpacity: 0.95,
          lineWidth: 1
        },
        plus: {
          r: 3,
          strokeOpacity: 0.95,
          lineWidth: 3
        },
        diamond: {
          r: 3,
          strokeOpacity: 0.95,
          lineWidth: 1
        }
      },
      interval: {
        rect: {
          fillOpacity: 0.95
        },
        hollow: {
          fill: "",
          strokeOpacity: 1,
          lineWidth: 2
        }
      },
      area: {
        area: {
          fillOpacity: 0.85,
          lineWidth: 0
        }
      },
      polygon: {
        polygon: {
          fillOpacity: 0.95
        }
      },
      cell: {
        cell: {
          fillOpacity: 0.95
        },
        hollow: {
          fill: "",
          strokeOpacity: 1,
          lineWidth: 2
        }
      },
      rect: {
        rect: {
          fillOpacity: 0.95
        },
        hollow: {
          fill: "",
          strokeOpacity: 1,
          lineWidth: 2
        }
      },
      link: {
        link: {
          fill: "",
          strokeOpacity: 1
        }
      },
      vector: {
        vector: {
          fillOpacity: 1
        }
      },
      box: {
        box: {
          fillOpacity: 0.95,
          stroke: colorBlack,
          lineWidth: 1
        }
      },
      text: {
        text: {
          fill: "#1D2129",
          fontSize: 12,
          lineWidth: 0,
          connectorStroke: colorStroke,
          connectorStrokeOpacity: 0.45,
          connectorLineWidth: 1,
          backgroundFill: colorStroke,
          backgroundFillOpacity: 0.15,
          backgroundPadding: [2, 4],
          startMarkerSymbol: "circle",
          startMarkerSize: 4,
          endMarkerSymbol: "circle",
          endMarkerSize: 4
        },
        badge: {
          fill: "#1D2129",
          fillOpacity: 0.65,
          lineWidth: 0,
          fontSize: 10,
          textAlign: "center",
          textBaseline: "middle",
          markerFill: colorStroke,
          markerFillOpacity: 0.25,
          markerStrokeOpacity: 0
        }
      },
      lineX: {
        line: {
          stroke: colorStroke,
          strokeOpacity: 0.45,
          lineWidth: 1
        }
      },
      lineY: {
        line: {
          stroke: colorStroke,
          strokeOpacity: 0.45,
          lineWidth: 1
        }
      },
      rangeX: {
        range: {
          fill: colorStroke,
          fillOpacity: 0.15,
          lineWidth: 0
        }
      },
      rangeY: {
        range: {
          fill: colorStroke,
          fillOpacity: 0.15,
          lineWidth: 0
        }
      },
      connector: {
        connector: {
          stroke: colorStroke,
          strokeOpacity: 0.45,
          lineWidth: 1,
          connectLength1: 12,
          endMarker: true,
          endMarkerSize: 6,
          endMarkerFill: colorStroke,
          endMarkerFillOpacity: 0.95
        }
      },
      axis: {
        arrow: false,
        gridLineDash: [3, 4],
        gridLineWidth: 0.5,
        gridStroke: colorBlack,
        gridStrokeOpacity: alpha10,
        labelAlign: "horizontal",
        labelFill: colorBlack,
        labelOpacity: alpha45,
        labelFontSize: 12,
        labelFontWeight: "normal",
        labelSpacing: padding1,
        line: false,
        lineLineWidth: 0.5,
        lineStroke: colorBlack,
        lineStrokeOpacity: alpha45,
        tickLength: 4,
        tickLineWidth: 1,
        tickStroke: colorBlack,
        tickOpacity: alpha45,
        titleFill: colorBlack,
        titleOpacity: alpha90,
        titleFontSize: 12,
        titleFontWeight: "normal",
        titleSpacing: 12,
        titleTransformOrigin: "center",
        lineArrowOffset: 6,
        lineArrowSize: 6
      },
      axisTop: {
        gridDirection: "positive",
        labelDirection: "negative",
        tickDirection: "negative",
        titlePosition: "top",
        titleSpacing: 12,
        labelSpacing: 4,
        titleTextBaseline: "middle"
      },
      axisBottom: {
        gridDirection: "negative",
        labelDirection: "positive",
        tickDirection: "positive",
        titlePosition: "bottom",
        titleSpacing: 12,
        labelSpacing: 4,
        titleTextBaseline: "bottom",
        titleTransform: "translate(0, 8)"
      },
      axisLeft: {
        gridDirection: "positive",
        labelDirection: "negative",
        labelSpacing: 4,
        tickDirection: "negative",
        titlePosition: "left",
        titleSpacing: 12,
        titleTextBaseline: "middle",
        titleDirection: "vertical",
        titleTransform: "rotate(-90) translate(0, -8)",
        titleTransformOrigin: "center"
      },
      axisRight: {
        gridDirection: "negative",
        labelDirection: "positive",
        labelSpacing: 4,
        tickDirection: "positive",
        titlePosition: "right",
        titleSpacing: 12,
        titleTextBaseline: "top",
        titleDirection: "vertical",
        titleTransformOrigin: "center"
      },
      axisLinear: {
        girdClosed: true,
        gridConnect: "arc",
        gridDirection: "negative",
        gridType: "surround",
        titlePosition: "top",
        titleSpacing: 0
      },
      axisArc: {
        title: false,
        titlePosition: "inner",
        line: false,
        tick: true,
        labelSpacing: 4
      },
      axisRadar: {
        girdClosed: true,
        gridStrokeOpacity: 0.3,
        gridType: "surround",
        label: false,
        tick: false,
        titlePosition: "start"
      },
      legendCategory: {
        backgroundFill: "transparent",
        itemBackgroundFill: "transparent",
        itemLabelFill: colorBlack,
        itemLabelFillOpacity: alpha90,
        itemLabelFontSize: 12,
        itemLabelFontWeight: "normal",
        itemMarkerFillOpacity: 1,
        itemMarkerSize: 8,
        itemSpacing: [padding1, padding1],
        itemValueFill: colorBlack,
        itemValueFillOpacity: 0.65,
        itemValueFontSize: 12,
        itemValueFontWeight: "normal",
        navButtonFill: colorBlack,
        navButtonFillOpacity: 0.65,
        navPageNumFill: colorBlack,
        navPageNumFillOpacity: 0.45,
        navPageNumFontSize: 12,
        padding: 8,
        title: false,
        titleFill: colorBlack,
        titleFillOpacity: 0.65,
        titleFontSize: 12,
        titleFontWeight: "normal",
        titleSpacing: 4,
        tickStroke: colorBlack,
        tickStrokeOpacity: 0.25,
        rowPadding: padding1,
        colPadding: padding2,
        maxRows: 3,
        maxCols: 3
      },
      legendContinuous: {
        handleHeight: 12,
        handleLabelFill: colorBlack,
        handleLabelFillOpacity: alpha45,
        handleLabelFontSize: 12,
        handleLabelFontWeight: "normal",
        handleMarkerFill: colorBlack,
        handleMarkerFillOpacity: 0.6,
        handleMarkerLineWidth: 1,
        handleMarkerStroke: colorBlack,
        handleMarkerStrokeOpacity: 0.25,
        handleWidth: 10,
        labelFill: colorBlack,
        labelFillOpacity: alpha45,
        labelFontSize: 12,
        labelFontWeight: "normal",
        labelSpacing: 3,
        tick: true,
        tickLength: 12,
        ribbonSize: 12,
        ribbonFill: "#aaa",
        handle: true,
        handleLabel: false,
        handleShape: "slider",
        handleIconSize: 12 / 1.8,
        indicator: false,
        titleFontSize: 12,
        titleSpacing: 4,
        titleFontWeight: "normal",
        titleFillOpacity: alpha90,
        tickStroke: colorBlack,
        tickStrokeOpacity: alpha45
      },
      label: {
        fill: colorBlack,
        fillOpacity: 0.65,
        fontSize: 12,
        fontWeight: "normal",
        stroke: void 0,
        offset: 12,
        connectorStroke: colorBlack,
        connectorStrokeOpacity: 0.45,
        connectorLineWidth: 1,
        connectorLength: 12,
        connectorLength2: 8,
        connectorDistance: 4
      },
      innerLabel: {
        fill: colorWhite,
        fontSize: 12,
        fillOpacity: 0.85,
        fontWeight: "normal",
        stroke: void 0,
        offset: 0
      },
      htmlLabel: {
        fontSize: 12,
        opacity: 0.65,
        color: colorBlack,
        fontWeight: "normal"
      },
      slider: {
        trackSize: 16,
        trackFill: colorStroke,
        trackFillOpacity: 1,
        selectionFill: colorDefault,
        selectionFillOpacity: 0.15,
        handleIconSize: 10,
        handleIconFill: "#f7f7f7",
        handleIconFillOpacity: 1,
        handleIconStroke: colorBlack,
        handleIconStrokeOpacity: 0.25,
        handleIconLineWidth: 1,
        handleIconRadius: 2,
        handleLabelFill: colorBlack,
        handleLabelFillOpacity: 0.45,
        handleLabelFontSize: 12,
        handleLabelFontWeight: "normal"
      },
      scrollbar: {
        padding: [0, 0, 0, 0],
        trackSize: 6,
        isRound: true,
        slidable: true,
        scrollable: true,
        trackFill: "#e5e5e5",
        trackFillOpacity: 0,
        thumbFill: "#000",
        thumbFillOpacity: 0.15,
        thumbHighlightedFillOpacity: 0.2
      },
      title: {
        spacing: 8,
        titleFill: colorBlack,
        titleFillOpacity: alpha90,
        titleFontSize: 16,
        titleFontWeight: "bold",
        titleTextBaseline: "top",
        subtitleFill: colorBlack,
        subtitleFillOpacity: alpha65,
        subtitleFontSize: 12,
        subtitleFontWeight: "normal",
        subtitleTextBaseline: "top"
      },
      tooltip: {
        css: {
          ".g2-tooltip": {
            "font-family": "sans-serif"
          }
        }
      }
    };
  }

  // node_modules/@antv/g2/esm/theme/light.js
  var tokens = {
    colorBlack: "#1D2129",
    colorWhite: "#ffffff",
    colorStroke: "#416180",
    colorDefault: "#1783FF",
    colorBackground: "transparent",
    category10: [
      "#1783FF",
      "#00C9C9",
      "#F0884D",
      "#D580FF",
      "#7863FF",
      "#60C42D",
      "#BD8F24",
      "#FF80CA",
      "#2491B3",
      "#17C76F"
    ],
    category20: [
      "#1783FF",
      "#00C9C9",
      "#F0884D",
      "#D580FF",
      "#7863FF",
      "#60C42D",
      "#BD8F24",
      "#FF80CA",
      "#2491B3",
      "#17C76F",
      "#AABA01",
      "#BC7CFC",
      "#237CBC",
      "#2DE379",
      "#CE8032",
      "#FF7AF4",
      "#545FD3",
      "#AFE410",
      "#D8C608",
      "#FFA1E0"
    ],
    padding1: 8,
    padding2: 12,
    padding3: 20,
    alpha90: 0.9,
    alpha65: 0.65,
    alpha45: 0.45,
    alpha25: 0.25,
    alpha10: 0.1
  };
  var defaults2 = create7(tokens);
  var Light = (options) => {
    return deep_mix_default({}, defaults2, options);
  };
  Light.props = {};

  // node_modules/@antv/g2/esm/theme/classic.js
  var Classic = (options) => {
    return deep_mix_default({}, Light(), {
      category10: "category10",
      category20: "category20"
    }, options);
  };
  Classic.props = {};

  // node_modules/@antv/g2/esm/theme/dark.js
  var tokens2 = {
    colorBlack: "#fff",
    colorWhite: "#000",
    colorStroke: "#416180",
    colorDefault: "#1783FF",
    colorBackground: "transparent",
    category10: [
      "#1783FF",
      "#00C9C9",
      "#F0884D",
      "#D580FF",
      "#7863FF",
      "#60C42D",
      "#BD8F24",
      "#FF80CA",
      "#2491B3",
      "#17C76F"
    ],
    category20: [
      "#1783FF",
      "#00C9C9",
      "#F0884D",
      "#D580FF",
      "#7863FF",
      "#60C42D",
      "#BD8F24",
      "#FF80CA",
      "#2491B3",
      "#17C76F",
      "#AABA01",
      "#BC7CFC",
      "#237CBC",
      "#2DE379",
      "#CE8032",
      "#FF7AF4",
      "#545FD3",
      "#AFE410",
      "#D8C608",
      "#FFA1E0"
    ],
    padding1: 8,
    padding2: 12,
    padding3: 20,
    alpha90: 0.9,
    alpha65: 0.65,
    alpha45: 0.45,
    alpha25: 0.25,
    alpha10: 0.25
  };
  var defaults3 = create7(tokens2);
  var Dark = (options) => {
    return deep_mix_default({}, defaults3, {
      tooltip: {
        crosshairsStroke: "#fff",
        crosshairsLineWidth: 1,
        crosshairsStrokeOpacity: 0.25,
        css: {
          ".g2-tooltip": {
            background: "#1f1f1f",
            opacity: 0.95
          },
          ".g2-tooltip-title": {
            color: "#A6A6A6"
          },
          ".g2-tooltip-list-item-name-label": {
            color: "#A6A6A6"
          },
          ".g2-tooltip-list-item-value": {
            color: "#A6A6A6"
          }
        }
      }
    }, options);
  };

  // node_modules/@antv/g2/esm/theme/classicDark.js
  var ClassicDark = (options) => {
    return Object.assign({}, Dark(), {
      category10: "category10",
      category20: "category20"
    }, options);
  };
  ClassicDark.props = {};

  // node_modules/@antv/g2/esm/theme/academy.js
  var tokens3 = {
    colorBlack: "#000",
    colorWhite: "#fff",
    colorStroke: "#888",
    colorDefault: "#4e79a7",
    colorBackground: "transparent",
    category10: [
      "#4e79a7",
      "#f28e2c",
      "#e15759",
      "#76b7b2",
      "#59a14f",
      "#edc949",
      "#af7aa1",
      "#ff9da7",
      "#9c755f",
      "#bab0ab"
    ],
    category20: [
      "#4e79a7",
      "#f28e2c",
      "#e15759",
      "#76b7b2",
      "#59a14f",
      "#edc949",
      "#af7aa1",
      "#ff9da7",
      "#9c755f",
      "#bab0ab"
    ],
    padding1: 8,
    padding2: 12,
    padding3: 20,
    alpha90: 0.9,
    alpha65: 0.65,
    alpha45: 0.45,
    alpha25: 0.25,
    alpha10: 0.1
  };
  var defaults4 = create7(tokens3);
  var Academy = (options) => {
    return deep_mix_default({}, defaults4, {
      text: { text: { fontSize: 10 } },
      axis: {
        gridLineDash: [0, 0],
        gridLineWidth: 1,
        gridStroke: "#ddd",
        gridStrokeOpacity: 1,
        labelOpacity: 1,
        labelStrokeOpacity: 1,
        labelFontSize: 10,
        line: true,
        lineLineWidth: 1,
        lineStroke: "#888",
        lineStrokeOpacity: 1,
        tickLength: 5,
        tickStrokeOpacity: 1,
        titleOpacity: 1,
        titleStrokeOpacity: 1,
        titleFillOpacity: 1,
        titleFontSize: 11,
        titleFontWeight: "bold"
      },
      axisLeft: {
        gridFilter: (_2, i) => i !== 0
      },
      axisRight: {
        gridFilter: (_2, i) => i !== 0
      },
      legendCategory: {
        itemLabelFillOpacity: 1,
        itemLabelFontSize: 10,
        itemValueFillOpacity: 1,
        itemValueFontSize: 10,
        titleFillOpacity: 1,
        titleFontSize: 11,
        titleFontWeight: "bold"
      },
      legendContinuous: {
        handleLabelFontSize: 10,
        labelFillOpacity: 0.45,
        labelFontSize: 10
      },
      label: {
        fontSize: 10
      },
      innerLabel: {
        fontSize: 10
      },
      htmlLabel: {
        fontSize: 10
      },
      slider: {
        handleLabelFontSize: 10,
        trackFillOpacity: 0.05
      }
    }, options);
  };
  Academy.props = {};

  // node_modules/d3-format/src/formatDecimal.js
  function formatDecimal_default(x3) {
    return Math.abs(x3 = Math.round(x3)) >= 1e21 ? x3.toLocaleString("en").replace(/,/g, "") : x3.toString(10);
  }
  function formatDecimalParts(x3, p2) {
    if ((i = (x3 = p2 ? x3.toExponential(p2 - 1) : x3.toExponential()).indexOf("e")) < 0) return null;
    var i, coefficient = x3.slice(0, i);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x3.slice(i + 1)
    ];
  }

  // node_modules/d3-format/src/exponent.js
  function exponent_default(x3) {
    return x3 = formatDecimalParts(Math.abs(x3)), x3 ? x3[1] : NaN;
  }

  // node_modules/d3-format/src/formatGroup.js
  function formatGroup_default(grouping, thousands) {
    return function(value2, width) {
      var i = value2.length, t = [], j = 0, g = grouping[0], length5 = 0;
      while (i > 0 && g > 0) {
        if (length5 + g + 1 > width) g = Math.max(1, width - length5);
        t.push(value2.substring(i -= g, i + g));
        if ((length5 += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }
      return t.reverse().join(thousands);
    };
  }

  // node_modules/d3-format/src/formatNumerals.js
  function formatNumerals_default(numerals) {
    return function(value2) {
      return value2.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // node_modules/d3-format/src/formatSpecifier.js
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match2 = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match2;
    return new FormatSpecifier({
      fill: match2[1],
      align: match2[2],
      sign: match2[3],
      symbol: match2[4],
      zero: match2[5],
      width: match2[6],
      comma: match2[7],
      precision: match2[8] && match2[8].slice(1),
      trim: match2[9],
      type: match2[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };

  // node_modules/d3-format/src/formatTrim.js
  function formatTrim_default(s3) {
    out: for (var n2 = s3.length, i = 1, i0 = -1, i1; i < n2; ++i) {
      switch (s3[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0) i0 = i;
          i1 = i;
          break;
        default:
          if (!+s3[i]) break out;
          if (i0 > 0) i0 = 0;
          break;
      }
    }
    return i0 > 0 ? s3.slice(0, i0) + s3.slice(i1 + 1) : s3;
  }

  // node_modules/d3-format/src/formatPrefixAuto.js
  var prefixExponent;
  function formatPrefixAuto_default(x3, p2) {
    var d3 = formatDecimalParts(x3, p2);
    if (!d3) return x3 + "";
    var coefficient = d3[0], exponent = d3[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n2 = coefficient.length;
    return i === n2 ? coefficient : i > n2 ? coefficient + new Array(i - n2 + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x3, Math.max(0, p2 + i - 1))[0];
  }

  // node_modules/d3-format/src/formatRounded.js
  function formatRounded_default(x3, p2) {
    var d3 = formatDecimalParts(x3, p2);
    if (!d3) return x3 + "";
    var coefficient = d3[0], exponent = d3[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  // node_modules/d3-format/src/formatTypes.js
  var formatTypes_default = {
    "%": (x3, p2) => (x3 * 100).toFixed(p2),
    "b": (x3) => Math.round(x3).toString(2),
    "c": (x3) => x3 + "",
    "d": formatDecimal_default,
    "e": (x3, p2) => x3.toExponential(p2),
    "f": (x3, p2) => x3.toFixed(p2),
    "g": (x3, p2) => x3.toPrecision(p2),
    "o": (x3) => Math.round(x3).toString(8),
    "p": (x3, p2) => formatRounded_default(x3 * 100, p2),
    "r": formatRounded_default,
    "s": formatPrefixAuto_default,
    "X": (x3) => Math.round(x3).toString(16).toUpperCase(),
    "x": (x3) => Math.round(x3).toString(16)
  };

  // node_modules/d3-format/src/identity.js
  function identity_default2(x3) {
    return x3;
  }

  // node_modules/d3-format/src/locale.js
  var map2 = Array.prototype.map;
  var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function locale_default(locale2) {
    var group3 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default2 : formatGroup_default(map2.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default2 : formatNumerals_default(map2.call(locale2.numerals, String)), percent2 = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero5 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
      if (type === "n") comma = true, type = "g";
      else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
      if (zero5 || fill === "0" && align === "=") zero5 = true, fill = "0", align = "=";
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent2 : "";
      var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
      precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format3(value2) {
        var valuePrefix = prefix, valueSuffix = suffix, i, n2, c5;
        if (type === "c") {
          valueSuffix = formatType(value2) + valueSuffix;
          value2 = "";
        } else {
          value2 = +value2;
          var valueNegative = value2 < 0 || 1 / value2 < 0;
          value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
          if (trim) value2 = formatTrim_default(value2);
          if (valueNegative && +value2 === 0 && sign3 !== "+") valueNegative = false;
          valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
          if (maybeSuffix) {
            i = -1, n2 = value2.length;
            while (++i < n2) {
              if (c5 = value2.charCodeAt(i), 48 > c5 || c5 > 57) {
                valueSuffix = (c5 === 46 ? decimal + value2.slice(i + 1) : value2.slice(i)) + valueSuffix;
                value2 = value2.slice(0, i);
                break;
              }
            }
          }
        }
        if (comma && !zero5) value2 = group3(value2, Infinity);
        var length5 = valuePrefix.length + value2.length + valueSuffix.length, padding = length5 < width ? new Array(width - length5 + 1).join(fill) : "";
        if (comma && zero5) value2 = group3(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
        switch (align) {
          case "<":
            value2 = valuePrefix + value2 + valueSuffix + padding;
            break;
          case "=":
            value2 = valuePrefix + padding + value2 + valueSuffix;
            break;
          case "^":
            value2 = padding.slice(0, length5 = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length5);
            break;
          default:
            value2 = padding + valuePrefix + value2 + valueSuffix;
            break;
        }
        return numerals(value2);
      }
      format3.toString = function() {
        return specifier + "";
      };
      return format3;
    }
    function formatPrefix2(specifier, value2) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value2) / 3))) * 3, k = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
      return function(value3) {
        return f(k * value3) + prefix;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }

  // node_modules/d3-format/src/defaultLocale.js
  var locale;
  var format2;
  var formatPrefix;
  defaultLocale2({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale2(definition) {
    locale = locale_default(definition);
    format2 = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  // node_modules/@antv/g2/esm/component/utils.js
  var __rest53 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function createComponent(descriptor) {
    return class extends CustomElement {
      constructor(config2) {
        super(config2);
        this.descriptor = descriptor;
      }
      connectedCallback() {
        var _a, _b;
        (_b = (_a = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a, this.attributes, this);
      }
      update(cfg = {}) {
        var _a, _b;
        this.attr(deep_mix_default({}, this.attributes, cfg));
        (_b = (_a = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a, this.attributes, this);
      }
    };
  }
  function maybeAppend2(parent, selector, node) {
    if (!parent.querySelector(selector)) {
      return select(parent).append(node);
    }
    return select(parent).select(selector);
  }
  function titleContent(field3) {
    return Array.isArray(field3) ? field3.join(", ") : `${field3 || ""}`;
  }
  function inferComponentLayout(position, userDefinitions) {
    const preset = {
      display: "flex",
      flexDirection: "row",
      justifyContent: "flex-start",
      alignItems: "center"
    };
    let { flexDirection, justifyContent, alignItems } = preset;
    const layout = {
      top: ["row", "flex-start", "center"],
      bottom: ["row", "flex-start", "center"],
      left: ["column", "flex-start", "center"],
      right: ["column", "flex-start", "center"],
      center: ["column", "center", "center"]
    };
    if (position in layout) {
      [flexDirection, justifyContent, alignItems] = layout[position];
    }
    return Object.assign({
      display: "flex",
      flexDirection,
      justifyContent,
      alignItems
    }, userDefinitions);
  }
  var G2Layout = class extends Layout {
    get child() {
      var _a;
      return (_a = this.children) === null || _a === void 0 ? void 0 : _a[0];
    }
    update(options) {
      var _a;
      this.attr(options);
      const { subOptions } = options;
      (_a = this.child) === null || _a === void 0 ? void 0 : _a.update(subOptions);
    }
  };
  var LegendCategoryLayout = class extends G2Layout {
    update(options) {
      var _a;
      const { subOptions } = options;
      this.attr(options);
      (_a = this.child) === null || _a === void 0 ? void 0 : _a.update(subOptions);
    }
  };
  function scaleOf(scales, type) {
    var _a;
    return (_a = scales.filter((s3) => s3.getOptions().name === type)) === null || _a === void 0 ? void 0 : _a[0];
  }
  function isHorizontal2(orientation) {
    return orientation === "horizontal" || orientation === 0;
  }
  function isVertical(orientation) {
    return orientation === "vertical" || orientation === -Math.PI / 2;
  }
  function inferComponentShape(value2, options, component) {
    const { bbox } = value2;
    const { position = "top", size: userDefinedSize, length: userDefinedLength } = options;
    const isHorizontal3 = ["top", "bottom", "center"].includes(position);
    const [bboxSize, bboxLength] = isHorizontal3 ? [bbox.height, bbox.width] : [bbox.width, bbox.height];
    const { defaultSize, defaultLength } = component.props;
    const size2 = userDefinedSize || defaultSize || bboxSize;
    const length5 = userDefinedLength || defaultLength || bboxLength;
    const orientation = isHorizontal3 ? "horizontal" : "vertical";
    const [width, height] = isHorizontal3 ? [length5, size2] : [size2, length5];
    return {
      orientation,
      width,
      height,
      size: size2,
      length: length5
    };
  }
  function domainOf2(scales) {
    return scales.find((scale10) => scale10.getOptions().domain.length > 0).getOptions().domain;
  }
  function adaptor(style) {
    const reservedKeys = [
      "arrow",
      "crosshairs",
      "grid",
      "handle",
      "handleLabel",
      "indicator",
      "label",
      "line",
      "tick",
      "tip",
      "title",
      "trunc"
    ];
    const { style: styles } = style, rest = __rest53(style, ["style"]);
    const finalStyle = {};
    Object.entries(rest).forEach(([key, value2]) => {
      if (reservedKeys.includes(key)) {
        finalStyle[`show${upper_first_default(key)}`] = value2;
      } else
        finalStyle[key] = value2;
    });
    return Object.assign(Object.assign({}, finalStyle), styles);
  }

  // node_modules/@antv/g2/esm/component/axis.js
  var __rest54 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function rotateAxis(axis, options) {
    const { eulerAngles, origin } = options;
    if (origin) {
      axis.setOrigin(origin);
    }
    if (eulerAngles) {
      axis.rotate(eulerAngles[0], eulerAngles[1], eulerAngles[2]);
    }
  }
  function sizeOf(coordinate) {
    const { innerWidth, innerHeight, depth } = coordinate.getOptions();
    return [innerWidth, innerHeight, depth];
  }
  function createFisheye(position, coordinate) {
    const { width, height } = coordinate.getOptions();
    return (tick3) => {
      if (!isFisheye(coordinate))
        return tick3;
      const tickPoint = position === "bottom" ? [tick3, 1] : [0, tick3];
      const vector = coordinate.map(tickPoint);
      if (position === "bottom") {
        const v = vector[0];
        const x3 = new Linear({
          domain: [0, width],
          range: [0, 1]
        });
        return x3.map(v);
      } else if (position === "left") {
        const v = vector[1];
        const x3 = new Linear({
          domain: [0, height],
          range: [0, 1]
        });
        return x3.map(v);
      }
      return tick3;
    };
  }
  function ticksOf(scale10, domain, tickMethod) {
    if (scale10.getTicks)
      return scale10.getTicks();
    if (!tickMethod)
      return domain;
    const [min10, max11] = extent(domain, (d3) => +d3);
    const { tickCount } = scale10.getOptions();
    return tickMethod(min10, max11, tickCount);
  }
  function createInset(position, coordinate) {
    if (isPolar(coordinate))
      return (d3) => d3;
    const options = coordinate.getOptions();
    const { innerWidth, innerHeight, insetTop, insetBottom, insetLeft, insetRight } = options;
    const [start2, end, size2] = position === "left" || position === "right" ? [insetTop, insetBottom, innerHeight] : [insetLeft, insetRight, innerWidth];
    const x3 = new Linear({
      domain: [0, 1],
      range: [start2 / size2, 1 - end / size2]
    });
    return (i) => x3.map(i);
  }
  function getData2(scale10, domain, tickCount, defaultTickFormatter, tickFilter, tickMethod, position, coordinate) {
    var _a;
    if (tickCount !== void 0 || tickMethod !== void 0) {
      scale10.update(Object.assign(Object.assign({}, tickCount && { tickCount }), tickMethod && { tickMethod }));
    }
    const ticks2 = ticksOf(scale10, domain, tickMethod);
    const filteredTicks = tickFilter ? ticks2.filter(tickFilter) : ticks2;
    const toString2 = (d3) => d3 instanceof Date ? String(d3) : typeof d3 === "object" && !!d3 ? d3 : String(d3);
    const labelFormatter = defaultTickFormatter || ((_a = scale10.getFormatter) === null || _a === void 0 ? void 0 : _a.call(scale10)) || toString2;
    const applyInset = createInset(position, coordinate);
    const applyFisheye = createFisheye(position, coordinate);
    const isHorizontal3 = (position2) => ["top", "bottom", "center", "outer"].includes(position2);
    const isVertical2 = (position2) => ["left", "right"].includes(position2);
    if (isPolar(coordinate) || isTranspose(coordinate)) {
      return filteredTicks.map((d3, i, array2) => {
        var _a2, _b;
        const offset3 = ((_a2 = scale10.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scale10, d3)) / 2 || 0;
        const tick3 = applyInset(scale10.map(d3) + offset3);
        const shouldReverse = isRadial(coordinate) && position === "center" || isTranspose(coordinate) && ((_b = scale10.getTicks) === null || _b === void 0 ? void 0 : _b.call(scale10)) && isHorizontal3(position) || isTranspose(coordinate) && isVertical2(position);
        return {
          value: shouldReverse ? 1 - tick3 : tick3,
          label: toString2(labelFormatter(prettyNumber2(d3), i, array2)),
          id: String(i)
        };
      });
    }
    return filteredTicks.map((d3, i, array2) => {
      var _a2;
      const offset3 = ((_a2 = scale10.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scale10, d3)) / 2 || 0;
      const tick3 = applyFisheye(applyInset(scale10.map(d3) + offset3));
      const shouldReverse = isVertical2(position);
      return {
        value: shouldReverse ? 1 - tick3 : tick3,
        label: toString2(labelFormatter(prettyNumber2(d3), i, array2)),
        id: String(i)
      };
    });
  }
  function inferGridLength(position, coordinate, plane = "xy") {
    const [width, height, depth] = sizeOf(coordinate);
    if (plane === "xy") {
      if (position.includes("bottom") || position.includes("top"))
        return height;
      return width;
    } else if (plane === "xz") {
      if (position.includes("bottom") || position.includes("top"))
        return depth;
      return width;
    } else {
      if (position.includes("bottom") || position.includes("top"))
        return height;
      return depth;
    }
  }
  function inferLabelOverlap(transform = [], style) {
    if (transform.length > 0)
      return transform;
    const { labelAutoRotate, labelAutoHide, labelAutoEllipsis, labelAutoWrap } = style;
    const finalTransforms = [];
    const addToTransforms = (overlap, state) => {
      if (state) {
        finalTransforms.push(Object.assign(Object.assign({}, overlap), state));
      }
    };
    addToTransforms({
      type: "rotate",
      optionalAngles: [0, 15, 30, 45, 60, 90]
    }, labelAutoRotate);
    addToTransforms({ type: "ellipsis", minLength: 20 }, labelAutoEllipsis);
    addToTransforms({ type: "hide" }, labelAutoHide);
    addToTransforms({ type: "wrap", wordWrapWidth: 100, maxLines: 3, recoveryWhenFail: true }, labelAutoWrap);
    return finalTransforms;
  }
  function inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate) {
    const { x: x3, y: y3, width, height } = bbox;
    const center2 = [x3 + width / 2, y3 + height / 2];
    const radius = Math.min(width, height) / 2;
    const [startAngle, endAngle] = angleOf(coordinate);
    const [w, h] = sizeOf(coordinate);
    const r = Math.min(w, h) / 2;
    const common = {
      center: center2,
      radius,
      startAngle,
      endAngle,
      gridLength: (outerRadius - innerRadius) * r
    };
    if (position === "inner") {
      const { insetLeft, insetTop } = coordinate.getOptions();
      return Object.assign(Object.assign({}, common), { center: [center2[0] - insetLeft, center2[1] - insetTop], labelAlign: "perpendicular", labelDirection: "positive", tickDirection: "positive", gridDirection: "negative" });
    }
    return Object.assign(Object.assign({}, common), { labelAlign: "parallel", labelDirection: "negative", tickDirection: "negative", gridDirection: "positive" });
  }
  function inferGrid(value2, coordinate, scale10) {
    if (isTheta(coordinate) || isParallel(coordinate))
      return false;
    return value2 === void 0 ? !!scale10.getTicks : value2;
  }
  function infer3DAxisLinearOverrideStyle(coordinate) {
    const { depth } = coordinate.getOptions();
    return depth ? {
      tickIsBillboard: true,
      lineIsBillboard: true,
      labelIsBillboard: true,
      titleIsBillboard: true,
      gridIsBillboard: true
    } : {};
  }
  function inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale) {
    const { x: x3, y: y3, width, height } = bbox;
    if (position === "bottom") {
      return { startPos: [x3, y3], endPos: [x3 + width, y3] };
    }
    if (position === "left") {
      return { startPos: [x3 + width, y3 + height], endPos: [x3 + width, y3] };
    }
    if (position === "right") {
      return { startPos: [x3, y3 + height], endPos: [x3, y3] };
    }
    if (position === "top") {
      return { startPos: [x3, y3 + height], endPos: [x3 + width, y3 + height] };
    }
    if (position === "center") {
      if (orientation === "vertical") {
        return {
          startPos: [x3, y3],
          endPos: [x3, y3 + height]
        };
      } else if (orientation === "horizontal") {
        return {
          startPos: [x3, y3],
          endPos: [x3 + width, y3]
        };
      } else if (typeof orientation === "number") {
        const [cx, cy] = coordinate.getCenter();
        const [innerRadius, outerRadius] = radiusOf(coordinate);
        const [startAngle, endAngle] = angleOf(coordinate);
        const r = Math.min(width, height) / 2;
        const { insetLeft, insetTop } = coordinate.getOptions();
        const innerR = innerRadius * r;
        const outerR = outerRadius * r;
        const [actualCx, actualCy] = [cx + x3 - insetLeft, cy + y3 - insetTop];
        const [cos3, sin3] = [Math.cos(orientation), Math.sin(orientation)];
        const startPos = [
          actualCx + outerR * cos3,
          actualCy + outerR * sin3
        ];
        const endPos = [
          actualCx + innerR * cos3,
          actualCy + innerR * sin3
        ];
        const getAxisXDomainLength = () => {
          const { domain } = xScale.getOptions();
          return domain.length;
        };
        const controllAngleCount = isPolar(coordinate) && xScale ? getAxisXDomainLength() : 3;
        return {
          startPos,
          endPos,
          gridClosed: Math.abs(endAngle - startAngle - 360) < 1e-6,
          gridCenter: [actualCx, actualCy],
          gridControlAngles: new Array(controllAngleCount).fill(0).map((d3, i, arr) => (endAngle - startAngle) / controllAngleCount * i)
        };
      }
    }
    return {};
  }
  var ArcAxisComponent = (options) => {
    const { order, size: size2, position, orientation, labelFormatter, tickFilter, tickCount, tickMethod, important = {}, style = {}, indexBBox, title, grid: grid2 = false } = options, rest = __rest54(options, ["order", "size", "position", "orientation", "labelFormatter", "tickFilter", "tickCount", "tickMethod", "important", "style", "indexBBox", "title", "grid"]);
    return ({ scales: [scale10], value: value2, coordinate, theme }) => {
      const { bbox } = value2;
      const { domain } = scale10.getOptions();
      const data2 = getData2(scale10, domain, tickCount, labelFormatter, tickFilter, tickMethod, position, coordinate);
      const labels = indexBBox ? data2.map((d3, i) => {
        const bbox2 = indexBBox.get(i);
        if (!bbox2)
          return d3;
        if (bbox2[0] !== d3.label)
          return d3;
        return Object.assign(Object.assign({}, d3), { bbox: bbox2[1] });
      }) : data2;
      const [innerRadius, outerRadius] = radiusOf(coordinate);
      const defaultStyle2 = inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate);
      const { axis: axisTheme, axisArc = {} } = theme;
      const finalStyle = adaptor(deep_mix_default({}, axisTheme, axisArc, defaultStyle2, Object.assign(Object.assign({ type: "arc", data: labels, titleText: titleContent(title), grid: grid2 }, rest), important)));
      return new Axis({
        // @fixme transform is not valid for arcAxis.
        // @ts-ignore
        style: omit_default(finalStyle, ["transform"])
      });
    };
  };
  function inferThemeStyle(scale10, coordinate, theme, direction2, position, orientation) {
    const baseStyle = theme.axis;
    const positionStyle = ["top", "right", "bottom", "left"].includes(position) ? theme[`axis${capitalizeFirst(position)}`] : theme.axisLinear;
    const channel = scale10.getOptions().name;
    const channelStyle = theme[`axis${upper_first_default(channel)}`] || {};
    return Object.assign({}, baseStyle, positionStyle, channelStyle);
  }
  function inferDefaultStyle(scale10, coordinate, theme, direction2, position, orientation) {
    const themeStyle = inferThemeStyle(scale10, coordinate, theme, direction2, position, orientation);
    if (position === "center") {
      return Object.assign(Object.assign(Object.assign(Object.assign({}, themeStyle), { labelDirection: direction2 === "right" ? "negative" : "positive" }), direction2 === "center" ? { labelTransform: "translate(50%,0)" } : null), { tickDirection: direction2 === "right" ? "negative" : "positive", labelSpacing: direction2 === "center" ? 0 : 4, titleSpacing: isVertical(orientation) ? 10 : 0, tick: direction2 === "center" ? false : void 0 });
    }
    return themeStyle;
  }
  var LinearAxisComponent = (options) => {
    const { direction: direction2 = "left", important = {}, labelFormatter, order, orientation, actualPosition, position, size: size2, style = {}, title, tickCount, tickFilter, tickMethod, transform, indexBBox } = options, userDefinitions = __rest54(options, ["direction", "important", "labelFormatter", "order", "orientation", "actualPosition", "position", "size", "style", "title", "tickCount", "tickFilter", "tickMethod", "transform", "indexBBox"]);
    return ({ scales, value: value2, coordinate, theme }) => {
      const { bbox } = value2;
      const [scale10] = scales;
      const { domain, xScale } = scale10.getOptions();
      const defaultStyle2 = inferDefaultStyle(scale10, coordinate, theme, direction2, position, orientation);
      const internalAxisStyle = Object.assign(Object.assign(Object.assign({}, defaultStyle2), style), userDefinitions);
      const gridLength = inferGridLength(actualPosition || position, coordinate, options.plane);
      const overrideStyle = inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale);
      const threeDOverrideStyle = infer3DAxisLinearOverrideStyle(coordinate);
      const data2 = getData2(scale10, domain, tickCount, labelFormatter, tickFilter, tickMethod, position, coordinate);
      const labels = indexBBox ? data2.map((d3, i) => {
        const bbox2 = indexBBox.get(i);
        if (!bbox2)
          return d3;
        if (bbox2[0] !== d3.label)
          return d3;
        return Object.assign(Object.assign({}, d3), { bbox: bbox2[1] });
      }) : data2;
      const finalAxisStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, internalAxisStyle), {
        type: "linear",
        data: labels,
        crossSize: size2,
        titleText: titleContent(title),
        labelOverlap: inferLabelOverlap(transform, internalAxisStyle),
        grid: inferGrid(internalAxisStyle.grid, coordinate, scale10),
        gridLength,
        // Always showLine, make title could align the end of axis.
        line: true,
        indexBBox
      }), !internalAxisStyle.line ? { lineOpacity: 0 } : null), overrideStyle), threeDOverrideStyle), important);
      const hasHide = finalAxisStyle.labelOverlap.find((d3) => d3.type === "hide");
      if (hasHide)
        finalAxisStyle.crossSize = false;
      return new Axis({
        className: "axis",
        style: adaptor(finalAxisStyle)
      });
    };
  };
  var axisFactor = (axis) => {
    return (options) => {
      const { labelFormatter: useDefinedLabelFormatter, labelFilter: userDefinedLabelFilter = () => true } = options;
      return (context) => {
        var _a;
        const { scales: [scale10] } = context;
        const ticks2 = ((_a = scale10.getTicks) === null || _a === void 0 ? void 0 : _a.call(scale10)) || scale10.getOptions().domain;
        const labelFormatter = typeof useDefinedLabelFormatter === "string" ? format2(useDefinedLabelFormatter) : useDefinedLabelFormatter;
        const labelFilter = (datum, index4, array2) => userDefinedLabelFilter(ticks2[index4], index4, ticks2);
        const normalizedOptions = Object.assign(Object.assign({}, options), {
          labelFormatter,
          labelFilter,
          scale: scale10
        });
        return axis(normalizedOptions)(context);
      };
    };
  };
  var LinearAxis = axisFactor(LinearAxisComponent);
  var ArcAxis = axisFactor(ArcAxisComponent);
  LinearAxis.props = {
    defaultPosition: "center",
    defaultSize: 45,
    defaultOrder: 0,
    defaultCrossPadding: [12, 12],
    defaultPadding: [12, 12]
  };
  ArcAxis.props = {
    defaultPosition: "outer",
    defaultOrientation: "vertical",
    defaultSize: 45,
    defaultOrder: 0,
    defaultCrossPadding: [12, 12],
    defaultPadding: [12, 12]
  };

  // node_modules/@antv/g2/esm/component/axisX.js
  var AxisX = (options) => {
    return (...args) => {
      const axisX = LinearAxis(Object.assign({}, { crossPadding: 50 }, options))(...args);
      rotateAxis(axisX, options);
      return axisX;
    };
  };
  AxisX.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "bottom" });

  // node_modules/@antv/g2/esm/component/axisY.js
  var AxisY = (options) => {
    return (...args) => {
      const axisY = LinearAxis(Object.assign({}, { crossPadding: 10 }, options))(...args);
      rotateAxis(axisY, options);
      return axisY;
    };
  };
  AxisY.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "left" });

  // node_modules/@antv/g2/esm/component/axisRadar.js
  var __rest55 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function inferTitleTransform(orientation) {
    const internalOrientation = orientation % (Math.PI * 2);
    if (internalOrientation === Math.PI / 2) {
      return { titleTransform: "translate(0, 50%)" };
    }
    if (internalOrientation > -Math.PI / 2 && internalOrientation < Math.PI / 2) {
      return { titleTransform: "translate(50%, 0)" };
    }
    if (internalOrientation > Math.PI / 2 && internalOrientation < Math.PI * 3 / 2) {
      return { titleTransform: "translate(-50%, 0)" };
    }
    return {};
  }
  function inferAxisStyle(options, theme, coordinate, scales) {
    const { radar } = options;
    const [scale10] = scales;
    const name2 = scale10.getOptions().name;
    const [startAngle, endAngle] = angleOf(coordinate);
    const { axisRadar: radarTheme = {} } = theme;
    return Object.assign(Object.assign({}, radarTheme), { grid: name2 === "position", gridConnect: "line", gridControlAngles: new Array(radar.count).fill(0).map((_2, i) => {
      const angle4 = (endAngle - startAngle) / radar.count;
      return angle4 * i;
    }) });
  }
  var AxisRadar = (options) => {
    const { important = {} } = options, restOptions = __rest55(options, ["important"]);
    return (context) => {
      const { theme, coordinate, scales } = context;
      return LinearAxis(Object.assign(Object.assign(Object.assign({}, restOptions), inferTitleTransform(options.orientation)), { important: Object.assign(Object.assign({}, inferAxisStyle(options, theme, coordinate, scales)), important) }))(context);
    };
  };
  AxisRadar.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "center" });

  // node_modules/@antv/g2/esm/component/legendCategory.js
  var __rest56 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function inferShape(scales, markState) {
    const shapeScale = scaleOf(scales, "shape");
    const colorScale = scaleOf(scales, "color");
    const shapeScale1 = shapeScale ? shapeScale.clone() : null;
    const shapes = [];
    for (const [mark, state] of markState) {
      const namespace = mark.type;
      const domain = (colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain.length) > 0 ? colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain : state.data;
      const shape23 = domain.map((d3, i) => {
        var _a;
        if (shapeScale1)
          return shapeScale1.map(d3 || "point");
        return ((_a = mark === null || mark === void 0 ? void 0 : mark.style) === null || _a === void 0 ? void 0 : _a.shape) || state.defaultShape || "point";
      });
      if (typeof namespace === "string")
        shapes.push([namespace, shape23]);
    }
    if (shapes.length === 0)
      return ["point", ["point"]];
    if (shapes.length === 1)
      return shapes[0];
    if (!shapeScale)
      return shapes[0];
    const { range: range3 } = shapeScale.getOptions();
    return shapes.map(([namespace, shape23]) => {
      let sum3 = 0;
      for (let i = 0; i < shapes.length; i++) {
        const targetShape = range3[i % range3.length];
        if (shape23[i] === targetShape)
          sum3++;
      }
      return [sum3 / shape23.length, [namespace, shape23]];
    }).sort((a3, b) => b[0] - a3[0])[0][1];
  }
  function inferItemMarker(options, context) {
    const { scales, library: library3, markState } = context;
    const [mark, shapes] = inferShape(scales, markState);
    const { itemMarker, itemMarkerSize: size2 } = options;
    const create8 = (name2, d3) => {
      var _a, _b, _c;
      const marker = ((_c = (_b = (_a = library3[`mark.${mark}`]) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.shape[name2]) === null || _c === void 0 ? void 0 : _c.props.defaultMarker) || last(name2.split("."));
      const radius = typeof size2 === "function" ? size2(d3) : size2;
      return () => useMarker(marker, { color: d3.color })(0, 0, radius);
    };
    const shapeOf = (i) => `${shapes[i]}`;
    const shapeScale = scaleOf(scales, "shape");
    if (shapeScale && !itemMarker)
      return (d3, i) => create8(shapeOf(i), d3);
    if (typeof itemMarker === "function") {
      return (d3, i) => {
        const node = itemMarker(d3.id, i);
        if (typeof node === "string")
          return create8(node, d3);
        return node;
      };
    }
    return (d3, i) => create8(itemMarker || shapeOf(i), d3);
  }
  function inferItemMarkerOpacity(scales) {
    const scale10 = scaleOf(scales, "opacity");
    if (scale10) {
      const { range: range3 } = scale10.getOptions();
      return (d3, i) => range3[i];
    }
    return void 0;
  }
  function inferItemMarkerSize(scales, defaults5) {
    const scale10 = scaleOf(scales, "size");
    if (scale10 instanceof Identity)
      return scale10.map(NaN) * 2;
    return defaults5;
  }
  function inferCategoryStyle(options, context) {
    const { labelFormatter = (d3) => `${d3}` } = options;
    const { scales, theme } = context;
    const defaultSize = theme.legendCategory.itemMarkerSize;
    const itemMarkerSize = inferItemMarkerSize(scales, defaultSize);
    const baseStyle = {
      itemMarker: inferItemMarker(Object.assign(Object.assign({}, options), { itemMarkerSize }), context),
      itemMarkerSize,
      itemMarkerOpacity: inferItemMarkerOpacity(scales)
    };
    const finalLabelFormatter = typeof labelFormatter === "string" ? format2(labelFormatter) : labelFormatter;
    const colorScale = scaleOf(scales, "color");
    const domain = domainOf2(scales);
    const colorOf = colorScale ? (d3) => colorScale.map(d3) : () => context.theme.color;
    return Object.assign(Object.assign({}, baseStyle), { data: domain.map((d3) => ({
      id: d3,
      label: finalLabelFormatter(d3),
      color: colorOf(d3)
    })) });
  }
  function inferLegendShape(value2, options, component) {
    const { position } = options;
    if (position === "center") {
      const { bbox } = value2;
      const { width: width2, height: height2 } = bbox;
      return { width: width2, height: height2 };
    }
    const { width, height } = inferComponentShape(value2, options, component);
    return { width, height };
  }
  var LegendCategory = (options) => {
    const { labelFormatter, layout, order, orientation, position, size: size2, title, cols, itemMarker } = options, style = __rest56(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "cols", "itemMarker"]);
    const { gridRow } = style;
    return (context) => {
      const { value: value2, theme } = context;
      const { bbox } = value2;
      const { width, height } = inferLegendShape(value2, options, LegendCategory);
      const finalLayout = inferComponentLayout(position, layout);
      const legendStyle = Object.assign(Object.assign(Object.assign(Object.assign({
        orientation: ["right", "left", "center"].includes(position) ? "vertical" : "horizontal",
        width,
        height,
        layout: cols !== void 0 ? "grid" : "flex"
      }, cols !== void 0 && { gridCol: cols }), gridRow !== void 0 && { gridRow }), { titleText: titleContent(title) }), inferCategoryStyle(options, context));
      const { legendCategory: legendTheme = {} } = theme;
      const categoryStyle = adaptor(Object.assign({}, legendTheme, legendStyle, style));
      const layoutWrapper = new LegendCategoryLayout({
        style: Object.assign(Object.assign({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, finalLayout), {
          // @ts-ignore
          subOptions: categoryStyle
        })
      });
      layoutWrapper.appendChild(new Category({
        className: "legend-category",
        style: categoryStyle
      }));
      return layoutWrapper;
    };
  };
  LegendCategory.props = {
    defaultPosition: "top",
    defaultOrder: 1,
    defaultSize: 40,
    defaultCrossPadding: [12, 12],
    defaultPadding: [12, 12]
  };

  // node_modules/@antv/g2/esm/component/legendContinuous.js
  var __rest57 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function updateShapeDimensions(shape23, finalSize, orientation) {
    shape23.size = finalSize;
    if (isHorizontal2(orientation)) {
      shape23.height = finalSize;
    } else {
      shape23.width = finalSize;
    }
    return shape23;
  }
  function inferContinuousShape(value2, options, component) {
    const { size: size2 } = options;
    const shape23 = inferComponentShape(value2, options, component);
    return updateShapeDimensions(shape23, size2, shape23.orientation);
  }
  function getFormatter(max11) {
    return (value2) => ({
      value: value2 / max11,
      label: String(value2)
    });
  }
  function getQuantizeOrQuantileConfig(shape23, colorScale, min10, max11, range3) {
    const thresholds = colorScale.thresholds;
    const formatter2 = getFormatter(max11);
    return Object.assign(Object.assign({}, shape23), { color: range3, data: [min10, ...thresholds, max11].map(formatter2) });
  }
  function getThresholdConfig(shape23, colorScale, range3) {
    const thresholds = colorScale.thresholds;
    const data2 = [-Infinity, ...thresholds, Infinity].map((value2, index4) => ({
      value: index4,
      label: value2
    }));
    return Object.assign(Object.assign({}, shape23), { data: data2, color: range3, labelFilter: (datum, index4) => {
      return index4 > 0 && index4 < data2.length - 1;
    } });
  }
  function rangeOf3(scale10) {
    const { domain } = scale10.getOptions();
    const [min10, max11] = [domain[0], lastOf(domain)];
    return [min10, max11];
  }
  function createColorScale(scale10, defaultColor) {
    const options = scale10.getOptions();
    const newScale = scale10.clone();
    newScale.update(Object.assign(Object.assign({}, options), { range: [parseColor(defaultColor).toString()] }));
    return newScale;
  }
  function getLinearConfig(shape23, colorScale, sizeScale, opacityScale, scales, theme) {
    const { length: length5 } = shape23;
    const definedScale = sizeScale || opacityScale;
    const defaultColor = scales.color ? theme.legendContinuous.ribbonFill || "black" : theme.color;
    const scale10 = colorScale || createColorScale(definedScale, defaultColor);
    const [min10, max11] = rangeOf3(scale10);
    const [domainMin, domainMax] = rangeOf3([colorScale, sizeScale, opacityScale].filter((d3) => d3 !== void 0).find((d3) => !(d3 instanceof Constant2)));
    return Object.assign(Object.assign({}, shape23), { domain: [domainMin, domainMax], data: scale10.getTicks().map((value2) => ({ value: value2 })), color: new Array(Math.floor(length5)).fill(0).map((d3, i) => {
      const value2 = (max11 - min10) / (length5 - 1) * i + min10;
      const color2 = scale10.map(value2) || defaultColor;
      const opacity = opacityScale ? opacityScale.map(value2) : 1;
      return color2.replace(/rgb[a]*\(([\d]{1,3}) *, *([\d]{1,3}) *, *([\d]{1,3})[\S\s]*\)/, (match2, p1, p2, p3) => `rgba(${p1}, ${p2}, ${p3}, ${opacity})`);
    }) });
  }
  function inferContinuousConfig(scales, scale10, value2, options, component, theme) {
    const colorScale = scaleOf(scales, "color");
    const shape23 = inferContinuousShape(value2, options, component);
    if (colorScale instanceof Threshold) {
      const { range: range3 } = colorScale.getOptions();
      const [min10, max11] = rangeOf3(colorScale);
      if (colorScale instanceof Quantize || colorScale instanceof Quantile) {
        return getQuantizeOrQuantileConfig(shape23, colorScale, min10, max11, range3);
      }
      return getThresholdConfig(shape23, colorScale, range3);
    }
    const sizeScale = scaleOf(scales, "size");
    const opacityScale = scaleOf(scales, "opacity");
    return getLinearConfig(shape23, colorScale, sizeScale, opacityScale, scale10, theme);
  }
  var LegendContinuous = (options) => {
    const { labelFormatter, layout, order, orientation, position, size: size2, title, style, crossPadding, padding } = options, rest = __rest57(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "style", "crossPadding", "padding"]);
    return ({ scales, value: value2, theme, scale: scale10 }) => {
      const { bbox } = value2;
      const { x: x3, y: y3, width, height } = bbox;
      const finalLayout = inferComponentLayout(position, layout);
      const { legendContinuous: legendTheme = {} } = theme;
      const finalStyle = adaptor(Object.assign({}, legendTheme, Object.assign(Object.assign({ titleText: titleContent(title), labelAlign: "value", labelFormatter: typeof labelFormatter === "string" ? (d3) => format2(labelFormatter)(d3.label) : labelFormatter }, inferContinuousConfig(scales, scale10, value2, options, LegendContinuous, theme)), style), rest));
      const layoutWrapper = new G2Layout({
        style: Object.assign(Object.assign({
          x: x3,
          y: y3,
          width,
          height
        }, finalLayout), {
          // @ts-ignore
          subOptions: finalStyle
        })
      });
      layoutWrapper.appendChild(new Continuous2({
        className: "legend-continuous",
        style: finalStyle
      }));
      return layoutWrapper;
    };
  };
  LegendContinuous.props = {
    defaultPosition: "top",
    defaultOrientation: "vertical",
    defaultOrder: 1,
    defaultSize: 60,
    defaultLength: 200,
    defaultLegendSize: 60,
    defaultPadding: [20, 10],
    defaultCrossPadding: [12, 12]
    // [horizontal, vertical]
  };

  // node_modules/@antv/g2/esm/component/legendContinuousBlock.js
  var LegendContinuousBlock = (options) => {
    return (...args) => LegendContinuous(Object.assign({}, { block: true }, options))(...args);
  };
  LegendContinuousBlock.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

  // node_modules/@antv/g2/esm/component/legendContinuousSize.js
  var LegendContinuousSize = (options) => {
    return (context) => {
      const { scales } = context;
      const sizeScale = scaleOf(scales, "size");
      return LegendContinuous(Object.assign({}, {
        type: "size",
        data: sizeScale.getTicks().map((value2, index4) => ({
          value: value2,
          label: String(value2)
        }))
      }, options))(context);
    };
  };
  LegendContinuousSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

  // node_modules/@antv/g2/esm/component/legendContinuousBlockSize.js
  var LegendContinuousBlockSize = (options) => {
    return LegendContinuousSize(Object.assign({}, { block: true }, options));
  };
  LegendContinuousBlockSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

  // node_modules/@antv/g2/esm/component/title.js
  var __rest58 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function inferStyleByAlign(x3, y3, width, align) {
    switch (align) {
      case "center":
        return {
          x: x3 + width / 2,
          y: y3,
          textAlign: "middle"
        };
      case "right":
        return {
          x: x3 + width,
          y: y3,
          textAlign: "right"
        };
      default:
        return {
          x: x3,
          y: y3,
          textAlign: "left"
        };
    }
  }
  var Title2 = createComponent({
    render(attributes, container) {
      const { width, title, subtitle, spacing = 2, align = "left", x: x3, y: y3 } = attributes, style = __rest58(attributes, ["width", "title", "subtitle", "spacing", "align", "x", "y"]);
      container.style.transform = `translate(${x3}, ${y3})`;
      const titleStyle = subObject(style, "title");
      const subtitleStyle = subObject(style, "subtitle");
      const mainTitle = maybeAppend2(container, ".title", "text").attr("className", "title").call(applyStyle, Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, 0, width, align)), { fontSize: 14, textBaseline: "top", text: title }), titleStyle)).node();
      const bounds = mainTitle.getLocalBounds();
      maybeAppend2(container, ".sub-title", "text").attr("className", "sub-title").call((selection) => {
        if (!subtitle)
          return selection.node().remove();
        selection.node().attr(Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, bounds.max[1] + spacing, width, align)), { fontSize: 12, textBaseline: "top", text: subtitle }), subtitleStyle));
      });
    }
  });
  var TitleComponent = (options) => {
    return ({ value: value2, theme }) => {
      const { x: x3, y: y3, width, height } = value2.bbox;
      return new Title2({
        style: deep_mix_default({}, theme.title, Object.assign({
          x: x3,
          y: y3,
          width,
          height
        }, options))
      });
    };
  };
  TitleComponent.props = {
    defaultPosition: "top",
    defaultOrder: 2,
    defaultSize: 36,
    defaultCrossPadding: [20, 20],
    defaultPadding: [12, 12]
  };

  // node_modules/@antv/g2/esm/utils/scale.js
  function constrain(x3, lo, hi) {
    return Math.min(hi, Math.max(lo, x3));
  }
  function isOrdinalScale(scale10) {
    return !!scale10.getBandWidth;
  }
  function invert4(scale10, x3, start2) {
    if (!isOrdinalScale(scale10))
      return scale10.invert(x3);
    const { adjustedRange } = scale10;
    const { domain } = scale10.getOptions();
    const offset3 = start2 ? -1 : 0;
    const step2 = scale10.getStep();
    const range3 = start2 ? adjustedRange : adjustedRange.map((d3) => d3 + step2);
    const i0 = bisectLeft(range3, x3);
    const i1 = constrain(i0 + offset3, 0, domain.length - 1);
    return domain[i1];
  }
  function domainOf3(scale10, values, ratioX) {
    if (!values)
      return scale10.getOptions().domain;
    if (!isOrdinalScale(scale10)) {
      const sortedDomain = sort2(values);
      if (!ratioX)
        return sortedDomain;
      const [d3] = sortedDomain;
      const { range: range3 } = scale10.getOptions();
      const [r0, r1] = range3;
      const v = r0 > r1 ? -1 : 1;
      const d1 = scale10.invert(scale10.map(d3) + v * ratioX);
      return [d3, d1];
    }
    const { domain } = scale10.getOptions();
    const v1 = values[0];
    const start2 = domain.indexOf(v1);
    if (ratioX) {
      const end2 = start2 + Math.round(domain.length * ratioX);
      return domain.slice(start2, end2);
    }
    const v2 = values[values.length - 1];
    const end = domain.indexOf(v2);
    return domain.slice(start2, end + 1);
  }
  function selectionOf(x3, y3, x12, y12, scale10, coordinate) {
    const { x: scaleX2, y: scaleY2 } = scale10;
    const abstractDomain = (point6, start2) => {
      const [x4, y4] = coordinate.invert(point6);
      return [invert4(scaleX2, x4, start2), invert4(scaleY2, y4, start2)];
    };
    const p0 = abstractDomain([x3, y3], true);
    const p1 = abstractDomain([x12, y12], false);
    const domainX = domainOf3(scaleX2, [p0[0], p1[0]]);
    const domainY = domainOf3(scaleY2, [p0[1], p1[1]]);
    return [domainX, domainY];
  }
  function abstractOf(domain, scale10) {
    const [d0, d1] = domain;
    const maybeStep = (scale11) => scale11.getStep ? scale11.getStep() : 0;
    return [scale10.map(d0), scale10.map(d1) + maybeStep(scale10)];
  }
  function pixelsOf(selection, scale10, coordinate) {
    const { x: scaleX2, y: scaleY2 } = scale10;
    const [X, Y] = selection;
    const AX = abstractOf(X, scaleX2);
    const AY = abstractOf(Y, scaleY2);
    const p0 = [AX[0], AY[0]];
    const p1 = [AX[1], AY[1]];
    const [x3, y3] = coordinate.map(p0);
    const [x12, y12] = coordinate.map(p1);
    return [x3, y3, x12, y12];
  }

  // node_modules/@antv/g2/esm/component/slider.js
  var __rest59 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function inferPosition2(bbox, position, trackSize) {
    const { x: x3, y: y3, width, height } = bbox;
    if (position === "left")
      return [x3 + width - trackSize, y3];
    if (position === "right")
      return [x3, y3];
    if (position === "bottom")
      return [x3, y3];
    if (position === "top")
      return [x3, y3 + height - trackSize];
  }
  var Slider2 = (options) => {
    const { orientation, labelFormatter, size: size2, style = {}, position } = options, rest = __rest59(options, ["orientation", "labelFormatter", "size", "style", "position"]);
    return (context) => {
      var _a;
      const { scales: [scale10], value: value2, theme, coordinate } = context;
      const { bbox } = value2;
      const { width, height } = bbox;
      const { slider: sliderTheme = {} } = theme;
      const defaultFormatter = ((_a = scale10.getFormatter) === null || _a === void 0 ? void 0 : _a.call(scale10)) || ((v) => v + "");
      const formatter2 = typeof labelFormatter === "string" ? format2(labelFormatter) : labelFormatter;
      const isHorizontal3 = orientation === "horizontal";
      const reverse = isTranspose(coordinate) && isHorizontal3;
      const { trackSize = sliderTheme.trackSize } = style;
      const [x05, y05] = inferPosition2(bbox, position, trackSize);
      return new Slider({
        className: "slider",
        style: Object.assign({}, sliderTheme, Object.assign(Object.assign({ x: x05, y: y05, trackLength: isHorizontal3 ? width : height, orientation, formatter: (v) => {
          const f = formatter2 || defaultFormatter;
          const v1 = reverse ? 1 - v : v;
          const tick3 = invert4(scale10, v1, true);
          return f(tick3);
        }, sparklineData: inferSparklineData(options, context) }, style), rest))
      });
    };
  };
  function markValue(markState, channels) {
    const [value2] = Array.from(markState.entries()).filter(([mark]) => mark.type === "line" || mark.type === "area").filter(([mark]) => mark.slider).map(([mark]) => {
      const { encode, slider } = mark;
      if (slider === null || slider === void 0 ? void 0 : slider.x) {
        const channel = (name2) => {
          const channel2 = encode[name2];
          return [name2, channel2 ? channel2.value : void 0];
        };
        return Object.fromEntries(channels.map(channel));
      }
    });
    if (!(value2 === null || value2 === void 0 ? void 0 : value2.series))
      return value2 === null || value2 === void 0 ? void 0 : value2.y;
    const result = value2.series.reduce((acc, curr, index4) => {
      acc[curr] = acc[curr] || [];
      acc[curr].push(value2.y[index4]);
      return acc;
    }, {});
    return Object.values(result);
  }
  function inferSparklineData(options, context) {
    const { markState } = context;
    if (isArray(options.sparklineData))
      return options.sparklineData;
    return markValue(markState, ["y", "series"]);
  }
  Slider2.props = {
    defaultPosition: "bottom",
    defaultSize: 24,
    defaultOrder: 1,
    defaultCrossPadding: [12, 12],
    defaultPadding: [12, 12]
  };

  // node_modules/@antv/g2/esm/component/sliderX.js
  var SliderX = (options) => {
    return Slider2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
  };
  SliderX.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "bottom" });

  // node_modules/@antv/g2/esm/component/sliderY.js
  var SliderY = (options) => {
    return Slider2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
  };
  SliderY.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "left" });

  // node_modules/@antv/g2/esm/component/scrollbar.js
  var __rest60 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var Scrollbar2 = (options) => {
    const { orientation, labelFormatter, style } = options, rest = __rest60(options, ["orientation", "labelFormatter", "style"]);
    return ({ scales: [scale10], value: value2, theme }) => {
      const { bbox } = value2;
      const { x: x3, y: y3, width, height } = bbox;
      const { scrollbar: scrollbarTheme = {} } = theme;
      const { ratio, range: range3 } = scale10.getOptions();
      const mainSize = orientation === "horizontal" ? width : height;
      const actualSize = mainSize / ratio;
      const [r0, r1] = range3;
      const value1 = r1 > r0 ? 0 : 1;
      return new Scrollbar({
        className: "g2-scrollbar",
        style: Object.assign({}, scrollbarTheme, Object.assign(Object.assign(Object.assign(Object.assign({}, style), {
          x: x3,
          y: y3,
          trackLength: mainSize,
          value: value1
        }), rest), { orientation, contentLength: actualSize, viewportLength: mainSize }))
      });
    };
  };
  Scrollbar2.props = {
    defaultPosition: "bottom",
    defaultSize: 24,
    defaultOrder: 1,
    defaultCrossPadding: [12, 12],
    defaultPadding: [12, 12]
  };

  // node_modules/@antv/g2/esm/component/scrollbarX.js
  var ScrollbarX = (options) => {
    return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
  };
  ScrollbarX.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "bottom" });

  // node_modules/@antv/g2/esm/component/scrollbarY.js
  var ScrollbarY = (options) => {
    return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
  };
  ScrollbarY.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "left" });

  // node_modules/@antv/g2/esm/component/legends.js
  var Legends = (options) => {
    return () => {
      return new Group2();
    };
  };
  Legends.props = {};

  // node_modules/@antv/g2/esm/animation/scaleInX.js
  var ScaleInX = (options, context) => {
    const ZERO = 1e-4;
    const { coordinate } = context;
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const [transformOrigin, transform] = isTranspose(coordinate) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
      const keyframes = [
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          transform: `${prefix} scale(1, 1)`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      return animation;
    };
  };

  // node_modules/@antv/g2/esm/animation/scaleOutX.js
  var ScaleOutX = (options, context) => {
    const ZERO = 1e-4;
    const { coordinate } = context;
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const [transformOrigin, transform] = isTranspose(coordinate) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
      const keyframes = [
        {
          transform: `${prefix} scale(1, 1)`.trimStart(),
          transformOrigin
        },
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.99
        },
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        }
      ];
      const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      return animation;
    };
  };

  // node_modules/@antv/g2/esm/animation/scaleInY.js
  var ScaleInY = (options, context) => {
    const ZERO = 1e-4;
    const { coordinate } = context;
    CSS2.registerProperty({
      name: "scaleInYRadius",
      inherits: false,
      initialValue: "",
      interpolable: true,
      syntax: PropertySyntax.NUMBER
    });
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const PolarScaleInY = (shape24) => {
        const { __data__, style } = shape24;
        const { radius = 0, inset = 0, fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
        const { points, y: y3, y1: y12 } = __data__;
        const arcObject = getArcObject(coordinate, points, [y3, y12]);
        const { innerRadius, outerRadius } = arcObject;
        const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
        const pathForConversion = new Path2({});
        const createArcPath = (arcParams) => {
          pathForConversion.attr({
            d: path2(arcParams)
          });
          const convertedPathDefinition = convertToPath(pathForConversion);
          return convertedPathDefinition;
        };
        const keyframes = [
          {
            scaleInYRadius: innerRadius + ZERO,
            fillOpacity: 0,
            strokeOpacity: 0,
            opacity: 0
          },
          {
            scaleInYRadius: innerRadius + ZERO,
            fillOpacity,
            strokeOpacity,
            opacity,
            offset: 0.01
          },
          {
            scaleInYRadius: outerRadius,
            fillOpacity,
            strokeOpacity,
            opacity
          }
        ];
        const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
        animation.onframe = function() {
          shape24.style.d = createArcPath(Object.assign(Object.assign({}, arcObject), { outerRadius: Number(shape24.style.scaleInYRadius) }));
        };
        animation.onfinish = function() {
          shape24.style.d = createArcPath(Object.assign(Object.assign({}, arcObject), { outerRadius }));
        };
        return animation;
      };
      const RectangularScaleInY = (shape24) => {
        const { style } = shape24;
        const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
        const [transformOrigin, transform] = isTranspose(coordinate) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
        const keyframes = [
          {
            transform: `${prefix} ${transform}`.trimStart(),
            transformOrigin,
            fillOpacity: 0,
            strokeOpacity: 0,
            opacity: 0
          },
          {
            transform: `${prefix} ${transform}`.trimStart(),
            transformOrigin,
            fillOpacity,
            strokeOpacity,
            opacity,
            offset: 0.01
          },
          {
            transform: `${prefix} scale(1, 1)`.trimStart(),
            transformOrigin,
            fillOpacity,
            strokeOpacity,
            opacity
          }
        ];
        const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
        return animation;
      };
      if (isPolar(coordinate)) {
        return PolarScaleInY(shape23);
      } else {
        return RectangularScaleInY(shape23);
      }
    };
  };

  // node_modules/@antv/g2/esm/animation/scaleOutY.js
  var ScaleOutY = (options, context) => {
    const ZERO = 1e-4;
    const { coordinate } = context;
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const [transformOrigin, transform] = isTranspose(coordinate) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
      const keyframes = [
        {
          transform: `${prefix} scale(1, 1)`.trimStart(),
          transformOrigin
        },
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.99
        },
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        }
      ];
      const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      return animation;
    };
  };

  // node_modules/@antv/g2/esm/animation/fadeIn.js
  var FadeIn = (options) => {
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const keyframes = [
        { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
        {
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
    };
  };
  FadeIn.props = {};

  // node_modules/@antv/g2/esm/animation/fadeOut.js
  var FadeOut = (options) => {
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const keyframes = [
        {
          fillOpacity,
          strokeOpacity,
          opacity
        },
        { fillOpacity: 0, strokeOpacity: 0, opacity: 0 }
      ];
      return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
    };
  };
  FadeOut.props = {};

  // node_modules/@antv/g2/esm/animation/utils.js
  var DEFAULT_ATTRIBUTE_VALUE = {
    opacity: 1,
    strokeOpacity: 1,
    fillOpacity: 1,
    lineWidth: 0,
    x: 0,
    y: 0,
    cx: 0,
    cy: 0,
    r: 0,
    rx: 0,
    ry: 0,
    width: 0,
    height: 0
  };
  var GEOMETRY_ATTRIBUTES = {
    [Shape.CIRCLE]: ["cx", "cy", "r"],
    [Shape.ELLIPSE]: ["cx", "cy", "rx", "ry"],
    [Shape.RECT]: ["x", "y", "width", "height"],
    [Shape.IMAGE]: ["x", "y", "width", "height"],
    [Shape.LINE]: ["x1", "y1", "x2", "y2"],
    [Shape.POLYLINE]: ["points"],
    [Shape.POLYGON]: ["points"]
  };
  function attributeOf(shape23, keys2, useDefaultValue = false) {
    const attribute = {};
    for (const key of keys2) {
      const value2 = shape23.style[key];
      if (value2) {
        attribute[key] = value2;
      } else if (useDefaultValue) {
        attribute[key] = DEFAULT_ATTRIBUTE_VALUE[key];
      }
    }
    return attribute;
  }
  var attributeKeys = [
    "fill",
    "stroke",
    "fillOpacity",
    "strokeOpacity",
    "opacity",
    "lineWidth"
  ];

  // node_modules/@antv/g2/esm/animation/morphing.js
  function localBBoxOf(shape23) {
    const { min: min10, max: max11 } = shape23.getLocalBounds();
    const [x05, y05] = min10;
    const [x12, y12] = max11;
    const height = y12 - y05;
    const width = x12 - x05;
    return [x05, y05, width, height];
  }
  function d2(bbox) {
    const [x3, y3, width, height] = bbox;
    return `
    M ${x3} ${y3}
    L ${x3 + width} ${y3}
    L ${x3 + width} ${y3 + height}
    L ${x3} ${y3 + height}
    Z
  `;
  }
  function pack2(shape23, count4) {
    const [x05, y05, width, height] = localBBoxOf(shape23);
    const aspect = height / width;
    const col = Math.ceil(Math.sqrt(count4 / aspect));
    const row2 = Math.ceil(count4 / col);
    const B4 = [];
    const h = height / row2;
    let j = 0;
    let n2 = count4;
    while (n2 > 0) {
      const c5 = Math.min(n2, col);
      const w = width / c5;
      for (let i = 0; i < c5; i++) {
        const x3 = x05 + i * w;
        const y3 = y05 + j * h;
        B4.push(d2([x3, y3, w, h]));
      }
      n2 -= c5;
      j += 1;
    }
    return B4;
  }
  function normalizeSplit(split = "pack") {
    if (typeof split == "function")
      return split;
    return pack2;
  }
  function shapeToShape(from, to, timeEffect) {
    let { transform: fromTransform } = from.style;
    const { transform: toTransform } = to.style;
    replaceChild(to, from);
    let keys2 = attributeKeys;
    if (from.nodeName === Shape.GROUP) {
      const [x05, y05, w0, h0] = localBBoxOf(from);
      const [x12, y12, w1, h1] = localBBoxOf(to);
      const dx = x05 - x12;
      const dy = y05 - y12;
      const sx = w0 / w1;
      const sy = h0 / h1;
      fromTransform = `translate(${dx}, ${dy}) scale(${sx}, ${sy})`;
    } else {
      keys2 = keys2.concat(GEOMETRY_ATTRIBUTES[from.nodeName] || []);
    }
    const keyframes = [
      Object.assign({ transform: fromTransform !== null && fromTransform !== void 0 ? fromTransform : "none" }, attributeOf(from, keys2, true)),
      Object.assign({ transform: toTransform !== null && toTransform !== void 0 ? toTransform : "none" }, attributeOf(to, keys2, true))
    ];
    const animation = to.animate(keyframes, timeEffect);
    return animation;
  }
  function replaceChild(newChild, oldChild) {
    newChild["__data__"] = oldChild["__data__"];
    newChild.className = oldChild.className;
    newChild.markType = oldChild.markType;
    oldChild.parentNode.replaceChild(newChild, oldChild);
  }
  function maybePath(node, d3) {
    const { nodeName } = node;
    if (nodeName === "path")
      return node;
    const path2 = new Path2({
      style: Object.assign(Object.assign({}, attributeOf(node, attributeKeys)), { d: d3 })
    });
    replaceChild(path2, node);
    return path2;
  }
  function hasUniqueString(search2, pattern) {
    const first3 = search2.indexOf(pattern);
    const last4 = search2.lastIndexOf(pattern);
    return first3 === last4;
  }
  function hasSubPath(path2) {
    return !hasUniqueString(path2, "m") || !hasUniqueString(path2, "M");
  }
  function shape2path(shape23) {
    const path2 = convertToPath(shape23);
    if (!path2)
      return;
    if (hasSubPath(path2))
      return;
    return path2;
  }
  function hasMarker(shape23) {
    const { nodeName } = shape23;
    if (nodeName === "path") {
      const attributes = get_default(shape23, "attributes");
      return attributes.markerEnd || attributes.markerStart;
    }
    return false;
  }
  function oneToOne(shape23, from, to, timeEffect) {
    const { nodeName: fromName } = from;
    const { nodeName: toName } = to;
    const fromPath = shape2path(from);
    const toPath = shape2path(to);
    const isSameNodes = fromName === toName && fromName !== "path";
    const hasNonPathNode = fromPath === void 0 || toPath === void 0;
    const isPathWithMarker = hasMarker(from) || hasMarker(to);
    if (isSameNodes || hasNonPathNode || isPathWithMarker)
      return shapeToShape(from, to, timeEffect);
    const pathShape = maybePath(shape23, fromPath);
    const keyframes = [
      Object.assign({}, attributeOf(from, attributeKeys)),
      Object.assign({}, attributeOf(to, attributeKeys))
    ];
    if (fromPath !== toPath) {
      keyframes[0].d = fromPath;
      keyframes[1].d = toPath;
      const animation = pathShape.animate(keyframes, timeEffect);
      animation.onfinish = () => {
        const d3 = pathShape.style.d;
        copyAttributes(pathShape, to);
        pathShape.style.d = d3;
        pathShape.style.transform = "none";
      };
      pathShape.style.transform = "none";
      return animation;
    }
    return null;
  }
  function oneToMultiple(from, to, timeEffect, split) {
    from.style.visibility = "hidden";
    const D2 = split(from, to.length);
    return to.map((shape23, i) => {
      const path2 = new Path2({
        style: Object.assign({ d: D2[i] }, attributeOf(from, attributeKeys))
      });
      return oneToOne(shape23, path2, shape23, timeEffect);
    });
  }
  function multipleToOne(from, to, timeEffect, split) {
    const D2 = split(to, from.length);
    const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = to.style;
    const keyframes = [
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0, offset: 0.99 },
      {
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = to.animate(keyframes, timeEffect);
    const animations = from.map((shape23, i) => {
      const path2 = new Path2({
        style: {
          d: D2[i],
          fill: to.style.fill
        }
      });
      return oneToOne(shape23, shape23, path2, timeEffect);
    });
    return [...animations, animation];
  }
  var Morphing = (options) => {
    return (from, to, defaults5) => {
      const split = normalizeSplit(options.split);
      const timeEffect = Object.assign(Object.assign({}, defaults5), options);
      const { length: fl } = from;
      const { length: tl } = to;
      if (fl === 1 && tl === 1 || fl > 1 && tl > 1) {
        const [f] = from;
        const [t] = to;
        return oneToOne(f, f, t, timeEffect);
      }
      if (fl === 1 && tl > 1) {
        const [f] = from;
        return oneToMultiple(f, to, timeEffect, split);
      }
      if (fl > 1 && tl === 1) {
        const [t] = to;
        return multipleToOne(from, t, timeEffect, split);
      }
      return null;
    };
  };
  Morphing.props = {};

  // node_modules/@antv/g2/esm/animation/waveIn.js
  var WaveIn = (options, context) => {
    const ZERO = 1e-4;
    CSS2.registerProperty({
      name: "waveInArcAngle",
      inherits: false,
      initialValue: "",
      interpolable: true,
      syntax: PropertySyntax.NUMBER
    });
    const { coordinate } = context;
    return (from, to, defaults5) => {
      const [shape23] = from;
      if (!isPolar(coordinate)) {
        return ScaleInX(options, context)(from, to, defaults5);
      }
      const { __data__, style } = shape23;
      const { radius = 0, inset = 0, fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
      const { points, y: y3, y1: y12 } = __data__;
      const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
      const arcObject = getArcObject(coordinate, points, [y3, y12]);
      const { startAngle, endAngle } = arcObject;
      const keyframes = [
        // Use custom interpolable CSS property.
        {
          waveInArcAngle: startAngle + ZERO,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          waveInArcAngle: startAngle + ZERO,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          waveInArcAngle: endAngle,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      animation.onframe = function() {
        shape23.style.d = path2(Object.assign(Object.assign({}, arcObject), { endAngle: Number(shape23.style.waveInArcAngle) }));
      };
      animation.onfinish = function() {
        shape23.style.d = path2(Object.assign(Object.assign({}, arcObject), { endAngle }));
      };
      return animation;
    };
  };
  WaveIn.props = {};

  // node_modules/@antv/g2/esm/animation/zoomIn.js
  var ZoomIn = (options) => {
    const ZERO = 1e-4;
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const transformOrigin = "center center";
      const keyframes = [
        {
          transform: `${prefix} scale(${ZERO})`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          transform: `${prefix} scale(${ZERO})`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          transform: `${prefix} scale(1)`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      return animation;
    };
  };

  // node_modules/@antv/g2/esm/animation/zoomOut.js
  var ZoomOut = (options) => {
    const ZERO = 1e-4;
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const transformOrigin = "center center";
      const keyframes = [
        { transform: `${prefix} scale(1)`.trimStart(), transformOrigin },
        {
          transform: `${prefix} scale(${ZERO})`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.99
        },
        {
          transform: `${prefix} scale(${ZERO})`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        }
      ];
      const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      return animation;
    };
  };

  // node_modules/@antv/g2/esm/animation/pathIn.js
  var PathIn = (options) => {
    return (from, _2, defaults5) => {
      var _a, _b;
      const [shape23] = from;
      const length5 = ((_b = (_a = shape23).getTotalLength) === null || _b === void 0 ? void 0 : _b.call(_a)) || 0;
      const keyframes = [
        { lineDash: [0, length5] },
        { lineDash: [length5, 0] }
      ];
      return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
    };
  };
  PathIn.props = {};

  // node_modules/@antv/g2/esm/animation/growInX.js
  var GrowInX = (options, context) => {
    return (from, to, defaults5) => {
      const [shape23] = from;
      const { min: [x3, y3], halfExtents } = shape23.getLocalBounds();
      const width = halfExtents[0] * 2;
      const height = halfExtents[1] * 2;
      const clipPath = new Path2({
        style: {
          d: `M${x3},${y3}L${x3 + width},${y3}L${x3 + width},${y3 + height}L${x3},${y3 + height}Z`
        }
      });
      shape23.appendChild(clipPath);
      shape23.style.clipPath = clipPath;
      const animation = ScaleInX(options, context)([clipPath], to, defaults5);
      return animation;
    };
  };
  GrowInX.props = {};

  // node_modules/@antv/g2/esm/animation/growInY.js
  var GrowInY = (options, context) => {
    return (from, to, defaults5) => {
      const [shape23] = from;
      const { min: [x3, y3], halfExtents } = shape23.getLocalBounds();
      const width = halfExtents[0] * 2;
      const height = halfExtents[1] * 2;
      const clipPath = new Path2({
        style: {
          d: `M${x3},${y3}L${x3 + width},${y3}L${x3 + width},${y3 + height}L${x3},${y3 + height}Z`
        }
      });
      shape23.appendChild(clipPath);
      shape23.style.clipPath = clipPath;
      const animation = ScaleInY(options, context)([clipPath], to, defaults5);
      return animation;
    };
  };
  GrowInY.props = {};

  // node_modules/@antv/g2/esm/runtime/constant.js
  var MAIN_LAYER_CLASS_NAME = "main-layer";
  var LABEL_LAYER_CLASS_NAME = "label-layer";
  var ELEMENT_CLASS_NAME = "element";
  var VIEW_CLASS_NAME = "view";
  var PLOT_CLASS_NAME = "plot";
  var COMPONENT_CLASS_NAME = "component";
  var LABEL_CLASS_NAME = "label";
  var AREA_CLASS_NAME = "area";

  // node_modules/@antv/g-plugin-canvas-path-generator/dist/index.esm.js
  function generatePath$6(context, parsedStyle) {
    var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, r = parsedStyle.r;
    context.arc(cx, cy, r, 0, Math.PI * 2, false);
  }
  function generatePath$5(context, parsedStyle) {
    var _parsedStyle$cx = parsedStyle.cx, cx = _parsedStyle$cx === void 0 ? 0 : _parsedStyle$cx, _parsedStyle$cy = parsedStyle.cy, cy = _parsedStyle$cy === void 0 ? 0 : _parsedStyle$cy, rx = parsedStyle.rx, ry = parsedStyle.ry;
    if (context.ellipse) {
      context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
    } else {
      var r = rx > ry ? rx : ry;
      var scaleX2 = rx > ry ? 1 : rx / ry;
      var scaleY2 = rx > ry ? ry / rx : 1;
      context.save();
      context.scale(scaleX2, scaleY2);
      context.arc(cx, cy, r, 0, Math.PI * 2);
    }
  }
  function generatePath$4(context, parsedStyle) {
    var x12 = parsedStyle.x1, y12 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad2 = 0;
    var x3;
    var y3;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      x3 = x22 - x12;
      y3 = y22 - y12;
      rad2 = Math.atan2(y3, x3);
      startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      x3 = x12 - x22;
      y3 = y12 - y22;
      rad2 = Math.atan2(y3, x3);
      endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
    }
    context.moveTo(x12 + startOffsetX, y12 + startOffsetY);
    context.lineTo(x22 + endOffsetX, y22 + endOffsetY);
  }
  function generatePath$3(context, parsedStyle) {
    var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var _parsedStyle$d = parsedStyle.d, absolutePath = _parsedStyle$d.absolutePath, segments = _parsedStyle$d.segments;
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad2 = 0;
    var x3;
    var y3;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      var _getStartTangent = markerStart.parentNode.getStartTangent(), _getStartTangent2 = _slicedToArray(_getStartTangent, 2), p1 = _getStartTangent2[0], p2 = _getStartTangent2[1];
      x3 = p1[0] - p2[0];
      y3 = p1[1] - p2[1];
      rad2 = Math.atan2(y3, x3);
      startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      var _getEndTangent = markerEnd.parentNode.getEndTangent(), _getEndTangent2 = _slicedToArray(_getEndTangent, 2), _p = _getEndTangent2[0], _p2 = _getEndTangent2[1];
      x3 = _p[0] - _p2[0];
      y3 = _p[1] - _p2[1];
      rad2 = Math.atan2(y3, x3);
      endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
    }
    for (var i = 0; i < absolutePath.length; i++) {
      var params = absolutePath[i];
      var command = params[0];
      var nextSegment = absolutePath[i + 1];
      var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
      var useEndOffset = (i === absolutePath.length - 1 || nextSegment && (nextSegment[0] === "M" || nextSegment[0] === "Z")) && endOffsetX !== 0 && endOffsetY !== 0;
      var _ref = useStartOffset ? [startOffsetX, startOffsetY] : [0, 0], _ref2 = _slicedToArray(_ref, 2), startOffsetXTemp = _ref2[0], startOffsetYTemp = _ref2[1];
      var _ref3 = useEndOffset ? [endOffsetX, endOffsetY] : [0, 0], _ref4 = _slicedToArray(_ref3, 2), endOffsetXTemp = _ref4[0], endOffsetYTemp = _ref4[1];
      switch (command) {
        case "M":
          context.moveTo(params[1] + startOffsetXTemp, params[2] + startOffsetYTemp);
          break;
        case "L":
          context.lineTo(params[1] + endOffsetXTemp, params[2] + endOffsetYTemp);
          break;
        case "Q":
          context.quadraticCurveTo(params[1], params[2], params[3] + endOffsetXTemp, params[4] + endOffsetYTemp);
          break;
        case "C":
          context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] + endOffsetXTemp, params[6] + endOffsetYTemp);
          break;
        case "A": {
          var arcParams = segments[i].arcParams;
          var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
          if (context.ellipse) {
            context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));
          } else {
            var r = rx > ry ? rx : ry;
            var scaleX2 = rx > ry ? 1 : rx / ry;
            var scaleY2 = rx > ry ? ry / rx : 1;
            context.translate(cx, cy);
            context.rotate(xRotation);
            context.scale(scaleX2, scaleY2);
            context.arc(0, 0, r, startAngle, endAngle, !!(1 - sweepFlag));
            context.scale(1 / scaleX2, 1 / scaleY2);
            context.rotate(-xRotation);
            context.translate(-cx, -cy);
          }
          if (useEndOffset) {
            context.lineTo(params[6] + endOffsetX, params[7] + endOffsetY);
          }
          break;
        }
        case "Z":
          context.closePath();
          break;
      }
    }
  }
  function generatePath$2(context, parsedStyle) {
    var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var points = parsedStyle.points.points;
    var length5 = points.length;
    var x12 = points[0][0];
    var y12 = points[0][1];
    var x22 = points[length5 - 1][0];
    var y22 = points[length5 - 1][1];
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad2 = 0;
    var x3;
    var y3;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      x3 = points[1][0] - points[0][0];
      y3 = points[1][1] - points[0][1];
      rad2 = Math.atan2(y3, x3);
      startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      x3 = points[length5 - 1][0] - points[0][0];
      y3 = points[length5 - 1][1] - points[0][1];
      rad2 = Math.atan2(y3, x3);
      endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
    }
    context.moveTo(x12 + (startOffsetX || endOffsetX), y12 + (startOffsetY || endOffsetY));
    for (var i = 1; i < length5 - 1; i++) {
      var point6 = points[i];
      context.lineTo(point6[0], point6[1]);
    }
    context.lineTo(x22, y22);
  }
  function generatePath$1(context, parsedStyle) {
    var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var points = parsedStyle.points.points;
    var length5 = points.length;
    var x12 = points[0][0];
    var y12 = points[0][1];
    var x22 = points[length5 - 1][0];
    var y22 = points[length5 - 1][1];
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad2 = 0;
    var x3;
    var y3;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      x3 = points[1][0] - points[0][0];
      y3 = points[1][1] - points[0][1];
      rad2 = Math.atan2(y3, x3);
      startOffsetX = Math.cos(rad2) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad2) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      x3 = points[length5 - 2][0] - points[length5 - 1][0];
      y3 = points[length5 - 2][1] - points[length5 - 1][1];
      rad2 = Math.atan2(y3, x3);
      endOffsetX = Math.cos(rad2) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad2) * (markerEndOffset || 0);
    }
    context.moveTo(x12 + startOffsetX, y12 + startOffsetY);
    for (var i = 1; i < length5 - 1; i++) {
      var point6 = points[i];
      context.lineTo(point6[0], point6[1]);
    }
    context.lineTo(x22 + endOffsetX, y22 + endOffsetY);
  }
  function generatePath(context, parsedStyle) {
    var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, radius = parsedStyle.radius, width = parsedStyle.width, height = parsedStyle.height;
    var w = width;
    var h = height;
    var hasRadius = radius && radius.some(function(r) {
      return r !== 0;
    });
    if (!hasRadius) {
      context.rect(x3, y3, w, h);
    } else {
      var signX = width > 0 ? 1 : -1;
      var signY = height > 0 ? 1 : -1;
      var sweepFlag = signX + signY === 0;
      var _radius$map = radius.map(function(r) {
        return clamp_default(r, 0, Math.min(Math.abs(w) / 2, Math.abs(h) / 2));
      }), _radius$map2 = _slicedToArray(_radius$map, 4), tlr = _radius$map2[0], trr = _radius$map2[1], brr = _radius$map2[2], blr = _radius$map2[3];
      context.moveTo(signX * tlr + x3, y3);
      context.lineTo(w - signX * trr + x3, y3);
      if (trr !== 0) {
        context.arc(w - signX * trr + x3, signY * trr + y3, trr, -signY * Math.PI / 2, signX > 0 ? 0 : Math.PI, sweepFlag);
      }
      context.lineTo(w + x3, h - signY * brr + y3);
      if (brr !== 0) {
        context.arc(w - signX * brr + x3, h - signY * brr + y3, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);
      }
      context.lineTo(signX * blr + x3, h + y3);
      if (blr !== 0) {
        context.arc(signX * blr + x3, h - signY * blr + y3, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);
      }
      context.lineTo(x3, signY * tlr + y3);
      if (tlr !== 0) {
        context.arc(signX * tlr + x3, signY * tlr + y3, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);
      }
    }
  }
  var Plugin = /* @__PURE__ */ function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this;
      _classCallCheck(this, Plugin8);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, Plugin8, [].concat(args));
      _this.name = "canvas-path-generator";
      return _this;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init() {
        var _pathGeneratorFactory;
        var pathGeneratorFactory = (_pathGeneratorFactory = {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_pathGeneratorFactory, Shape.CIRCLE, generatePath$6), Shape.ELLIPSE, generatePath$5), Shape.RECT, generatePath), Shape.LINE, generatePath$4), Shape.POLYLINE, generatePath$1), Shape.POLYGON, generatePath$2), Shape.PATH, generatePath$3), Shape.TEXT, void 0), Shape.GROUP, void 0), Shape.IMAGE, void 0), _defineProperty2(_defineProperty2(_defineProperty2(_pathGeneratorFactory, Shape.HTML, void 0), Shape.MESH, void 0), Shape.FRAGMENT, void 0));
        this.context.pathGeneratorFactory = pathGeneratorFactory;
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        delete this.context.pathGeneratorFactory;
      }
    }]);
  }(AbstractRendererPlugin);

  // node_modules/@antv/g-plugin-canvas-picker/dist/index.esm.js
  var tmpVec3a = vec3_exports.create();
  var tmpVec3b = vec3_exports.create();
  var tmpVec3c = vec3_exports.create();
  var tmpMat4 = mat4_exports.create();
  var CanvasPickerPlugin = /* @__PURE__ */ function() {
    function CanvasPickerPlugin2() {
      var _this = this;
      _classCallCheck(this, CanvasPickerPlugin2);
      this.isHit = function(displayObject, position, worldTransform, isClipPath) {
        var pick3 = _this.context.pointInPathPickerFactory[displayObject.nodeName];
        if (pick3) {
          var invertWorldMat = mat4_exports.invert(tmpMat4, worldTransform);
          var localPosition = vec3_exports.transformMat4(tmpVec3b, vec3_exports.set(tmpVec3c, position[0], position[1], 0), invertWorldMat);
          if (pick3(displayObject, new Point2(localPosition[0], localPosition[1]), isClipPath, _this.isPointInPath, _this.context, _this.runtime)) {
            return true;
          }
        }
        return false;
      };
      this.isPointInPath = function(displayObject, position) {
        var context = _this.runtime.offscreenCanvasCreator.getOrCreateContext(_this.context.config.offscreenCanvas);
        var generatePath2 = _this.context.pathGeneratorFactory[displayObject.nodeName];
        if (generatePath2) {
          context.beginPath();
          generatePath2(context, displayObject.parsedStyle);
          context.closePath();
        }
        return context.isPointInPath(position.x, position.y);
      };
    }
    return _createClass(CanvasPickerPlugin2, [{
      key: "apply",
      value: function apply(context, runtime2) {
        var _renderingContext$roo, _this2 = this;
        var renderingService = context.renderingService, renderingContext = context.renderingContext;
        this.context = context;
        this.runtime = runtime2;
        var document2 = (_renderingContext$roo = renderingContext.root) === null || _renderingContext$roo === void 0 ? void 0 : _renderingContext$roo.ownerDocument;
        renderingService.hooks.pick.tapPromise(CanvasPickerPlugin2.tag, /* @__PURE__ */ function() {
          var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(result) {
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  return _context.abrupt("return", _this2.pick(document2, result));
                case 1:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function(_x) {
            return _ref.apply(this, arguments);
          };
        }());
        renderingService.hooks.pickSync.tap(CanvasPickerPlugin2.tag, function(result) {
          return _this2.pick(document2, result);
        });
      }
    }, {
      key: "pick",
      value: function pick3(document2, result) {
        var topmost = result.topmost, _result$position = result.position, x3 = _result$position.x, y3 = _result$position.y;
        var position = vec3_exports.set(tmpVec3a, x3, y3, 0);
        var hitTestList = document2.elementsFromBBox(position[0], position[1], position[0], position[1]);
        var pickedDisplayObjects = [];
        var _iterator = _createForOfIteratorHelper(hitTestList), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var _displayObject = _step.value;
            var worldTransform = _displayObject.getWorldTransform();
            var isHitOriginShape = this.isHit(_displayObject, position, worldTransform, false);
            if (isHitOriginShape) {
              var clipped = findClosestClipPathTarget(_displayObject);
              if (clipped) {
                var clipPath = clipped.parsedStyle.clipPath;
                var isHitClipPath = this.isHit(clipPath, position, clipPath.getWorldTransform(), true);
                if (isHitClipPath) {
                  if (topmost) {
                    result.picked = [_displayObject];
                    return result;
                  }
                  pickedDisplayObjects.push(_displayObject);
                }
              } else {
                if (topmost) {
                  result.picked = [_displayObject];
                  return result;
                }
                pickedDisplayObjects.push(_displayObject);
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        result.picked = pickedDisplayObjects;
        return result;
      }
    }]);
  }();
  CanvasPickerPlugin.tag = "CanvasPicker";
  function isPointInPath$8(displayObject, position, isClipPath) {
    var _ref = displayObject.parsedStyle, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, r = _ref.r, fill = _ref.fill, stroke2 = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
    var halfLineWidth = (lineWidth + increasedLineWidthForHitTesting) / 2;
    var absDistance = distance4(cx, cy, position.x, position.y);
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
    if (hasFill && hasStroke || isClipPath) {
      return absDistance <= r + halfLineWidth;
    }
    if (hasFill) {
      return absDistance <= r;
    }
    if (hasStroke) {
      return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
    }
    return false;
  }
  function ellipseDistance(squareX, squareY, rx, ry) {
    return squareX / (rx * rx) + squareY / (ry * ry);
  }
  function isPointInPath$7(displayObject, position, isClipPath) {
    var _ref = displayObject.parsedStyle, _ref$cx = _ref.cx, cx = _ref$cx === void 0 ? 0 : _ref$cx, _ref$cy = _ref.cy, cy = _ref$cy === void 0 ? 0 : _ref$cy, rx = _ref.rx, ry = _ref.ry, fill = _ref.fill, stroke2 = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
    var x3 = position.x, y3 = position.y;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
    var halfLineWith = (lineWidth + increasedLineWidthForHitTesting) / 2;
    var squareX = (x3 - cx) * (x3 - cx);
    var squareY = (y3 - cy) * (y3 - cy);
    if (hasFill && hasStroke || isClipPath) {
      return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    if (hasFill) {
      return ellipseDistance(squareX, squareY, rx, ry) <= 1;
    }
    if (hasStroke) {
      return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    return false;
  }
  function inBox(minX, minY, width, height, x3, y3) {
    return x3 >= minX && x3 <= minX + width && y3 >= minY && y3 <= minY + height;
  }
  function inRect(minX, minY, width, height, lineWidth, x3, y3) {
    var halfWidth = lineWidth / 2;
    return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x3, y3) || // 上边
    inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x3, y3) || // 右边
    inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x3, y3) || // 下边
    inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x3, y3);
  }
  function inArc(cx, cy, r, startAngle, endAngle, lineWidth, x3, y3) {
    var angle4 = (Math.atan2(y3 - cy, x3 - cx) + Math.PI * 2) % (Math.PI * 2);
    var point6 = {
      x: cx + r * Math.cos(angle4),
      y: cy + r * Math.sin(angle4)
    };
    return distance4(point6.x, point6.y, x3, y3) <= lineWidth / 2;
  }
  function inLine(x12, y12, x22, y22, lineWidth, x3, y3) {
    var minX = Math.min(x12, x22);
    var maxX = Math.max(x12, x22);
    var minY = Math.min(y12, y22);
    var maxY2 = Math.max(y12, y22);
    var halfWidth = lineWidth / 2;
    if (!(x3 >= minX - halfWidth && x3 <= maxX + halfWidth && y3 >= minY - halfWidth && y3 <= maxY2 + halfWidth)) {
      return false;
    }
    return pointToLine(x12, y12, x22, y22, x3, y3) <= lineWidth / 2;
  }
  function inPolyline(points, lineWidth, x3, y3, isClose) {
    var count4 = points.length;
    if (count4 < 2) {
      return false;
    }
    for (var i = 0; i < count4 - 1; i++) {
      var x12 = points[i][0];
      var y12 = points[i][1];
      var x22 = points[i + 1][0];
      var y22 = points[i + 1][1];
      if (inLine(x12, y12, x22, y22, lineWidth, x3, y3)) {
        return true;
      }
    }
    if (isClose) {
      var first3 = points[0];
      var last4 = points[count4 - 1];
      if (inLine(first3[0], first3[1], last4[0], last4[1], lineWidth, x3, y3)) {
        return true;
      }
    }
    return false;
  }
  var tolerance = 1e-6;
  function dcmp(x3) {
    if (Math.abs(x3) < tolerance) {
      return 0;
    }
    return x3 < 0 ? -1 : 1;
  }
  function onSegment(p1, p2, q) {
    if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
      return true;
    }
    return false;
  }
  function inPolygon(points, x3, y3) {
    var isHit = false;
    var n2 = points.length;
    if (n2 <= 2) {
      return false;
    }
    for (var i = 0; i < n2; i++) {
      var p1 = points[i];
      var p2 = points[(i + 1) % n2];
      if (onSegment(p1, p2, [x3, y3])) {
        return true;
      }
      if (dcmp(p1[1] - y3) > 0 !== dcmp(p2[1] - y3) > 0 && dcmp(x3 - (y3 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
        isHit = !isHit;
      }
    }
    return isHit;
  }
  function inPolygons(polygons, x3, y3) {
    var isHit = false;
    for (var i = 0; i < polygons.length; i++) {
      var points = polygons[i];
      isHit = inPolygon(points, x3, y3);
      if (isHit) {
        break;
      }
    }
    return isHit;
  }
  function isPointInPath$6(displayObject, position, isClipPath) {
    var _ref = displayObject.parsedStyle, x12 = _ref.x1, y12 = _ref.y1, x22 = _ref.x2, y22 = _ref.y2, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, fill = _ref.fill, stroke2 = _ref.stroke;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasStroke = _isFillOrStrokeAffect2[1];
    if (!hasStroke && !isClipPath || !lineWidth) {
      return false;
    }
    return inLine(x12, y12, x22, y22, lineWidth + increasedLineWidthForHitTesting, position.x, position.y);
  }
  function isPointInStroke(segments, lineWidth, px2, py, length5) {
    var isHit = false;
    var halfWidth = lineWidth / 2;
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
      if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, px2, py)) {
        continue;
      }
      switch (segment.command) {
        // L 和 Z 都是直线， M 不进行拾取
        case "L":
        case "Z":
          isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px2, py);
          if (isHit) {
            return true;
          }
          break;
        case "Q":
          var qDistance = pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px2, py);
          isHit = qDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
          break;
        case "C":
          var cDistance = pointDistance$3(
            prePoint[0],
            // 上一段结束位置, 即 C 的起始点
            prePoint[1],
            params[1],
            // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点
            params[2],
            params[3],
            params[4],
            params[5],
            params[6],
            px2,
            py,
            length5
          );
          isHit = cDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
          break;
        case "A":
          if (!segment.cubicParams) {
            segment.cubicParams = arcToCubic(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], void 0);
          }
          var args = segment.cubicParams;
          var prePointInCubic = prePoint;
          for (var _i = 0; _i < args.length; _i += 6) {
            var _cDistance = pointDistance$3(
              prePointInCubic[0],
              // 上一段结束位置, 即 C 的起始点
              prePointInCubic[1],
              args[_i],
              args[_i + 1],
              args[_i + 2],
              args[_i + 3],
              args[_i + 4],
              args[_i + 5],
              px2,
              py,
              length5
            );
            prePointInCubic = [args[_i + 4], args[_i + 5]];
            isHit = _cDistance <= lineWidth / 2;
            if (isHit) {
              return true;
            }
          }
          break;
      }
    }
    return isHit;
  }
  function isPointInPath$5(displayObject, position, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
    var _ref = displayObject.parsedStyle, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, stroke2 = _ref.stroke, fill = _ref.fill, d3 = _ref.d, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
    var segments = d3.segments, hasArc = d3.hasArc, polylines = d3.polylines, polygons = d3.polygons;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(
      pointerEvents,
      // Only a closed path can be filled.
      (polygons === null || polygons === void 0 ? void 0 : polygons.length) && fill,
      stroke2
    ), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
    var totalLength = getOrCalculatePathTotalLength(displayObject);
    var isHit = false;
    if (hasFill || isClipPath) {
      if (hasArc) {
        isHit = isPointInPath2(displayObject, position);
      } else {
        isHit = inPolygons(polygons, position.x, position.y) || inPolygons(polylines, position.x, position.y);
      }
      return isHit;
    }
    if (hasStroke || isClipPath) {
      isHit = isPointInStroke(segments, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, totalLength);
    }
    return isHit;
  }
  function isPointInPath$4(displayObject, position, isClipPath) {
    var _ref = displayObject.parsedStyle, stroke2 = _ref.stroke, fill = _ref.fill, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, points = _ref.points, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
    var isHit = false;
    if (hasStroke || isClipPath) {
      isHit = inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, true);
    }
    if (!isHit && (hasFill || isClipPath)) {
      isHit = inPolygon(points.points, position.x, position.y);
    }
    return isHit;
  }
  function isPointInPath$3(displayObject, position, isClipPath) {
    var _ref = displayObject.parsedStyle, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, points = _ref.points, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, fill = _ref.fill, stroke2 = _ref.stroke;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasStroke = _isFillOrStrokeAffect2[1];
    if (!hasStroke && !isClipPath || !lineWidth) {
      return false;
    }
    return inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, false);
  }
  function isPointInPath$2(displayObject, position, isClipPath, isPointInPath2, runtime2) {
    var _ref = displayObject.parsedStyle, radius = _ref.radius, fill = _ref.fill, stroke2 = _ref.stroke, _ref$lineWidth = _ref.lineWidth, lineWidth = _ref$lineWidth === void 0 ? 1 : _ref$lineWidth, _ref$increasedLineWid = _ref.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _ref$increasedLineWid === void 0 ? 0 : _ref$increasedLineWid, _ref$x = _ref.x, x3 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y3 = _ref$y === void 0 ? 0 : _ref$y, width = _ref.width, height = _ref.height, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents;
    var _isFillOrStrokeAffect = isFillOrStrokeAffected(pointerEvents, fill, stroke2), _isFillOrStrokeAffect2 = _slicedToArray(_isFillOrStrokeAffect, 2), hasFill = _isFillOrStrokeAffect2[0], hasStroke = _isFillOrStrokeAffect2[1];
    var hasRadius = radius && radius.some(function(r) {
      return r !== 0;
    });
    var lineWidthForHitTesting = lineWidth + increasedLineWidthForHitTesting;
    if (!hasRadius) {
      var halfWidth = lineWidthForHitTesting / 2;
      if (hasFill && hasStroke || isClipPath) {
        return inBox(x3 - halfWidth, y3 - halfWidth, width + halfWidth, height + halfWidth, position.x, position.y);
      }
      if (hasFill) {
        return inBox(x3, y3, width, height, position.x, position.y);
      }
      if (hasStroke) {
        return inRect(x3, y3, width, height, lineWidthForHitTesting, position.x, position.y);
      }
    } else {
      var isHit = false;
      if (hasStroke || isClipPath) {
        isHit = inRectWithRadius(x3, y3, width, height, radius.map(function(r) {
          return clamp_default(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
        }), lineWidthForHitTesting, position.x, position.y);
      }
      if (!isHit && (hasFill || isClipPath)) {
        isHit = isPointInPath2(displayObject, position);
      }
      return isHit;
    }
    return false;
  }
  function inRectWithRadius(minX, minY, width, height, radiusArray, lineWidth, x3, y3) {
    var _radiusArray = _slicedToArray(radiusArray, 4), tlr = _radiusArray[0], trr = _radiusArray[1], brr = _radiusArray[2], blr = _radiusArray[3];
    return inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x3, y3) || inLine(minX + width, minY + trr, minX + width, minY + height - brr, lineWidth, x3, y3) || inLine(minX + width - brr, minY + height, minX + blr, minY + height, lineWidth, x3, y3) || inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x3, y3) || inArc(minX + width - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x3, y3) || inArc(minX + width - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x3, y3) || inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x3, y3) || inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x3, y3);
  }
  function isPointInPath$1(displayObject, position, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
    var _ref = displayObject.parsedStyle, _ref$pointerEvents = _ref.pointerEvents, pointerEvents = _ref$pointerEvents === void 0 ? "auto" : _ref$pointerEvents, _ref$x = _ref.x, x3 = _ref$x === void 0 ? 0 : _ref$x, _ref$y = _ref.y, y3 = _ref$y === void 0 ? 0 : _ref$y, width = _ref.width, height = _ref.height;
    if (pointerEvents === "non-transparent-pixel") {
      var offscreenCanvas = renderingPluginContext.config.offscreenCanvas;
      var canvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
      var context = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
        willReadFrequently: true
      });
      canvas.width = width;
      canvas.height = height;
      renderingPluginContext.defaultStyleRendererFactory[Shape.IMAGE].render(context, _objectSpread22(_objectSpread22({}, displayObject.parsedStyle), {}, {
        x: 0,
        y: 0
      }), displayObject, void 0, void 0, void 0);
      var imagedata = context.getImageData(position.x - x3, position.y - y3, 1, 1).data;
      return imagedata.every(function(component) {
        return component !== 0;
      });
    }
    return true;
  }
  function isPointInPath(displayObject, position, isClipPath, isPointInPath2) {
    var bounds = displayObject.getGeometryBounds();
    return position.x >= bounds.min[0] && position.y >= bounds.min[1] && position.x <= bounds.max[0] && position.y <= bounds.max[1];
  }
  var Plugin2 = /* @__PURE__ */ function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this;
      _classCallCheck(this, Plugin8);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, Plugin8, [].concat(args));
      _this.name = "canvas-picker";
      return _this;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init() {
        var _pointInPathPickerFac;
        var pointInPathPickerFactory = (_pointInPathPickerFac = {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_pointInPathPickerFac, Shape.CIRCLE, isPointInPath$8), Shape.ELLIPSE, isPointInPath$7), Shape.RECT, isPointInPath$2), Shape.LINE, isPointInPath$6), Shape.POLYLINE, isPointInPath$3), Shape.POLYGON, isPointInPath$4), Shape.PATH, isPointInPath$5), Shape.TEXT, isPointInPath), Shape.GROUP, null), Shape.IMAGE, isPointInPath$1), _defineProperty2(_defineProperty2(_pointInPathPickerFac, Shape.HTML, null), Shape.MESH, null));
        this.context.pointInPathPickerFactory = pointInPathPickerFactory;
        this.addRenderingPlugin(new CanvasPickerPlugin());
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        delete this.context.pointInPathPickerFactory;
        this.removeAllRenderingPlugins();
      }
    }]);
  }(AbstractRendererPlugin);

  // node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js
  function _classPrivateFieldBase(e3, t) {
    if (!{}.hasOwnProperty.call(e3, t)) throw new TypeError("attempted to use private field on non-instance");
    return e3;
  }

  // node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js
  var id3 = 0;
  function _classPrivateFieldKey(e3) {
    return "__private_" + id3++ + "_" + e3;
  }

  // node_modules/@antv/g-plugin-image-loader/dist/index.esm.js
  var RefCountCache = /* @__PURE__ */ function() {
    function RefCountCache2() {
      _classCallCheck(this, RefCountCache2);
      this.cacheStore = /* @__PURE__ */ new Map();
    }
    return _createClass(RefCountCache2, [{
      key: "onRefAdded",
      value: function onRefAdded2(ref) {
      }
    }, {
      key: "has",
      value: function has(key) {
        return this.cacheStore.has(key);
      }
    }, {
      key: "put",
      value: function put(key, item, ref) {
        if (this.cacheStore.has(key)) {
          return false;
        }
        this.cacheStore.set(key, {
          value: item,
          counter: /* @__PURE__ */ new Set([ref])
        });
        this.onRefAdded(ref);
        return true;
      }
    }, {
      key: "get",
      value: function get2(key, ref) {
        var cacheItem = this.cacheStore.get(key);
        if (!cacheItem) {
          return null;
        }
        if (!cacheItem.counter.has(ref)) {
          cacheItem.counter.add(ref);
          this.onRefAdded(ref);
        }
        return cacheItem.value;
      }
    }, {
      key: "update",
      value: function update(key, value2, ref) {
        var cacheItem = this.cacheStore.get(key);
        if (!cacheItem) {
          return false;
        }
        cacheItem.value = _objectSpread22(_objectSpread22({}, cacheItem.value), value2);
        if (!cacheItem.counter.has(ref)) {
          cacheItem.counter.add(ref);
          this.onRefAdded(ref);
        }
        return true;
      }
    }, {
      key: "release",
      value: function release(key, ref) {
        var cacheItem = this.cacheStore.get(key);
        if (!cacheItem) {
          return false;
        }
        cacheItem.counter["delete"](ref);
        if (cacheItem.counter.size <= 0) {
          this.cacheStore["delete"](key);
        }
        return true;
      }
    }, {
      key: "releaseRef",
      value: function releaseRef(ref) {
        var _this = this;
        Array.from(this.cacheStore.keys()).forEach(function(key) {
          _this.release(key, ref);
        });
      }
    }, {
      key: "getSize",
      value: function getSize() {
        return this.cacheStore.size;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.cacheStore.clear();
      }
    }]);
  }();
  var tasks = [];
  var nextFrameTasks = [];
  var ImageSlicer = /* @__PURE__ */ function() {
    function ImageSlicer2() {
      _classCallCheck(this, ImageSlicer2);
    }
    return _createClass(ImageSlicer2, null, [{
      key: "stop",
      value: function stop() {
        var api = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ImageSlicer2.api;
        if (ImageSlicer2.rafId) {
          api.cancelAnimationFrame(ImageSlicer2.rafId);
          ImageSlicer2.rafId = null;
        }
      }
    }, {
      key: "executeTask",
      value: function executeTask() {
        var api = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ImageSlicer2.api;
        if (tasks.length <= 0 && nextFrameTasks.length <= 0) {
          return;
        }
        nextFrameTasks.forEach(function(task) {
          return task();
        });
        nextFrameTasks = tasks.splice(0, ImageSlicer2.TASK_NUM_PER_FRAME);
        ImageSlicer2.rafId = api.requestAnimationFrame(function() {
          ImageSlicer2.executeTask(api);
        });
      }
    }, {
      key: "sliceImage",
      value: function sliceImage(image, sliceWidth, sliceHeight, rerender) {
        var overlap = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
        var api = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : ImageSlicer2.api;
        var imageWidth = image.naturalWidth || image.width;
        var imageHeight = image.naturalHeight || image.height;
        var strideW = sliceWidth - overlap;
        var strideH = sliceHeight - overlap;
        var gridCols = Math.ceil(imageWidth / strideW);
        var gridRows = Math.ceil(imageHeight / strideH);
        var result = {
          tileSize: [sliceWidth, sliceHeight],
          gridSize: [gridRows, gridCols],
          tiles: Array(gridRows).fill(null).map(function() {
            return Array(gridCols).fill(null);
          })
        };
        var _loop = function _loop2(row3) {
          var _loop22 = function _loop23(col2) {
            tasks.push(function() {
              var startX = col2 * strideW;
              var startY = row3 * strideH;
              var _ref = [Math.min(sliceWidth, imageWidth - startX), Math.min(sliceHeight, imageHeight - startY)], tempSliceWidth = _ref[0], tempSliceHeight = _ref[1];
              var sliceCanvas = api.createCanvas();
              sliceCanvas.width = sliceWidth;
              sliceCanvas.height = sliceHeight;
              var sliceCtx = sliceCanvas.getContext("2d");
              sliceCtx.drawImage(image, startX, startY, tempSliceWidth, tempSliceHeight, 0, 0, tempSliceWidth, tempSliceHeight);
              result.tiles[row3][col2] = {
                x: startX,
                y: startY,
                tileX: col2,
                tileY: row3,
                data: sliceCanvas
              };
              rerender();
            });
          };
          for (var col = 0; col < gridCols; col++) {
            _loop22(col);
          }
        };
        for (var row2 = 0; row2 < gridRows; row2++) {
          _loop(row2);
        }
        ImageSlicer2.stop();
        ImageSlicer2.executeTask();
        return result;
      }
    }]);
  }();
  ImageSlicer.TASK_NUM_PER_FRAME = 10;
  var IMAGE_CACHE = new RefCountCache();
  IMAGE_CACHE.onRefAdded = function onRefAdded(ref) {
    var _this = this;
    ref.addEventListener(ElementEvent.DESTROY, function() {
      _this.releaseRef(ref);
    }, {
      once: true
    });
  };
  var ImagePool = /* @__PURE__ */ function() {
    function ImagePool2(context, runtime2) {
      _classCallCheck(this, ImagePool2);
      this.gradientCache = {};
      this.patternCache = {};
      this.context = context;
      this.runtime = runtime2;
    }
    return _createClass(ImagePool2, [{
      key: "getImageSync",
      value: function getImageSync(src, ref, callback) {
        var imageSource = isString2(src) ? src : src.src;
        if (IMAGE_CACHE.has(imageSource)) {
          var imageCache = IMAGE_CACHE.get(imageSource, ref);
          if (imageCache.img.complete) {
            callback === null || callback === void 0 || callback(imageCache);
            return imageCache;
          }
        }
        this.getOrCreateImage(src, ref).then(function(cache3) {
          callback === null || callback === void 0 || callback(cache3);
        })["catch"](function() {
        });
        return null;
      }
    }, {
      key: "getOrCreateImage",
      value: function getOrCreateImage(src, ref) {
        var _this2 = this;
        var imageSource = isString2(src) ? src : src.src;
        if (!isString2(src) && !IMAGE_CACHE.has(imageSource)) {
          var imageCache = {
            img: src,
            size: [src.naturalWidth || src.width, src.naturalHeight || src.height],
            tileSize: calculateImageTileSize(src)
          };
          IMAGE_CACHE.put(imageSource, imageCache, ref);
        }
        if (IMAGE_CACHE.has(imageSource)) {
          var _imageCache = IMAGE_CACHE.get(imageSource, ref);
          if (_imageCache.img.complete) {
            return Promise.resolve(_imageCache);
          }
          return new Promise(function(resolve, reject) {
            _imageCache.img.addEventListener("load", function() {
              _imageCache.size = [_imageCache.img.naturalWidth || _imageCache.img.width, _imageCache.img.naturalHeight || _imageCache.img.height];
              _imageCache.tileSize = calculateImageTileSize(_imageCache.img);
              resolve(_imageCache);
            });
            _imageCache.img.addEventListener("error", function(ev) {
              reject(ev);
            });
          });
        }
        return new Promise(function(resolve, reject) {
          var image = _this2.context.config.createImage();
          if (image) {
            var _imageCache2 = {
              img: image,
              size: [0, 0],
              tileSize: calculateImageTileSize(image)
            };
            IMAGE_CACHE.put(imageSource, _imageCache2, ref);
            image.onload = function() {
              _imageCache2.size = [image.naturalWidth || image.width, image.naturalHeight || image.height];
              _imageCache2.tileSize = calculateImageTileSize(_imageCache2.img);
              resolve(_imageCache2);
            };
            image.onerror = function(ev) {
              reject(ev);
            };
            image.crossOrigin = "Anonymous";
            image.src = imageSource;
          }
        });
      }
    }, {
      key: "createDownSampledImage",
      value: function() {
        var _createDownSampledImage = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(src, ref) {
          var imageCache, enableLargeImageOptimization, _ref, _ref$maxDownSampledIm, maxDownSampledImageSize, _ref$downSamplingRate, downSamplingRateThreshold, createImageBitmapFunc, _imageCache$size, originWidth, originHeight, resizedImage, downSamplingRate, updateCache;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getOrCreateImage(src, ref);
              case 2:
                imageCache = _context.sent;
                if (!(typeof imageCache.downSamplingRate !== "undefined")) {
                  _context.next = 5;
                  break;
                }
                return _context.abrupt("return", imageCache);
              case 5:
                enableLargeImageOptimization = this.context.config.enableLargeImageOptimization;
                _ref = typeof enableLargeImageOptimization === "boolean" ? {} : enableLargeImageOptimization, _ref$maxDownSampledIm = _ref.maxDownSampledImageSize, maxDownSampledImageSize = _ref$maxDownSampledIm === void 0 ? 2048 : _ref$maxDownSampledIm, _ref$downSamplingRate = _ref.downSamplingRateThreshold, downSamplingRateThreshold = _ref$downSamplingRate === void 0 ? 0.5 : _ref$downSamplingRate;
                createImageBitmapFunc = this.runtime.globalThis.createImageBitmap;
                _imageCache$size = _slicedToArray(imageCache.size, 2), originWidth = _imageCache$size[0], originHeight = _imageCache$size[1];
                resizedImage = imageCache.img;
                downSamplingRate = Math.min((maxDownSampledImageSize + maxDownSampledImageSize) / (originWidth + originHeight), Math.max(0.01, Math.min(downSamplingRateThreshold, 0.5)));
                updateCache = _objectSpread22(_objectSpread22({}, imageCache), {}, {
                  downSamplingRate
                });
                IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
                if (!createImageBitmapFunc) {
                  _context.next = 25;
                  break;
                }
                _context.prev = 14;
                _context.next = 17;
                return createImageBitmapFunc(imageCache.img, {
                  resizeWidth: originWidth * downSamplingRate,
                  resizeHeight: originHeight * downSamplingRate
                });
              case 17:
                resizedImage = _context.sent;
                _context.next = 23;
                break;
              case 20:
                _context.prev = 20;
                _context.t0 = _context["catch"](14);
                downSamplingRate = 1;
              case 23:
                _context.next = 26;
                break;
              case 25:
                downSamplingRate = 1;
              case 26:
                updateCache = _objectSpread22(_objectSpread22({}, this.getImageSync(src, ref)), {}, {
                  downSampled: resizedImage,
                  downSamplingRate
                });
                IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
                return _context.abrupt("return", updateCache);
              case 29:
              case "end":
                return _context.stop();
            }
          }, _callee, this, [[14, 20]]);
        }));
        function createDownSampledImage(_x, _x2) {
          return _createDownSampledImage.apply(this, arguments);
        }
        return createDownSampledImage;
      }()
    }, {
      key: "createImageTiles",
      value: function() {
        var _createImageTiles = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(src, tiles, rerender, ref) {
          var imageCache, _ref$ownerDocument$de, requestAnimationFrame2, cancelAnimationFrame2, updateCache;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getOrCreateImage(src, ref);
              case 2:
                imageCache = _context2.sent;
                _ref$ownerDocument$de = ref.ownerDocument.defaultView, requestAnimationFrame2 = _ref$ownerDocument$de.requestAnimationFrame, cancelAnimationFrame2 = _ref$ownerDocument$de.cancelAnimationFrame;
                ImageSlicer.api = {
                  requestAnimationFrame: requestAnimationFrame2,
                  cancelAnimationFrame: cancelAnimationFrame2,
                  createCanvas: function createCanvas() {
                    return OffscreenCanvasCreator.createCanvas();
                  }
                };
                updateCache = _objectSpread22(_objectSpread22({}, imageCache), ImageSlicer.sliceImage(imageCache.img, imageCache.tileSize[0], imageCache.tileSize[0], rerender));
                IMAGE_CACHE.update(imageCache.img.src, updateCache, ref);
                return _context2.abrupt("return", updateCache);
              case 8:
              case "end":
                return _context2.stop();
            }
          }, _callee2, this);
        }));
        function createImageTiles(_x3, _x4, _x5, _x6) {
          return _createImageTiles.apply(this, arguments);
        }
        return createImageTiles;
      }()
    }, {
      key: "releaseImage",
      value: function releaseImage(src, ref) {
        IMAGE_CACHE.release(isString2(src) ? src : src.src, ref);
      }
    }, {
      key: "releaseImageRef",
      value: function releaseImageRef(ref) {
        IMAGE_CACHE.releaseRef(ref);
      }
    }, {
      key: "getOrCreatePatternSync",
      value: function getOrCreatePatternSync(object, pattern, context, $offscreenCanvas, dpr, min10, callback) {
        var patternKey = this.generatePatternKey(pattern);
        if (patternKey && this.patternCache[patternKey]) {
          return this.patternCache[patternKey];
        }
        var image = pattern.image, repetition = pattern.repetition, transform = pattern.transform;
        var src;
        var needScaleWithDPR = false;
        if (isString2(image)) {
          var imageCache = this.getImageSync(image, object, callback);
          src = imageCache === null || imageCache === void 0 ? void 0 : imageCache.img;
        } else if ($offscreenCanvas) {
          src = $offscreenCanvas;
          needScaleWithDPR = true;
        } else {
          src = image;
        }
        var canvasPattern = src && context.createPattern(src, repetition);
        if (canvasPattern) {
          var mat;
          if (transform) {
            mat = parsedTransformToMat4(parseTransform(transform), new DisplayObject({}));
          } else {
            mat = mat4_exports.identity(mat4_exports.create());
          }
          if (needScaleWithDPR) {
            mat4_exports.scale(mat, mat, [1 / dpr, 1 / dpr, 1]);
          }
          canvasPattern.setTransform({
            a: mat[0],
            b: mat[1],
            c: mat[4],
            d: mat[5],
            e: mat[12] + min10[0],
            f: mat[13] + min10[1]
          });
        }
        if (patternKey && canvasPattern) {
          this.patternCache[patternKey] = canvasPattern;
        }
        return canvasPattern;
      }
    }, {
      key: "getOrCreateGradient",
      value: function getOrCreateGradient(params, context) {
        var key = this.generateGradientKey(params);
        var type = params.type, steps = params.steps, min10 = params.min, width = params.width, height = params.height, angle4 = params.angle, cx = params.cx, cy = params.cy, size2 = params.size;
        if (this.gradientCache[key]) {
          return this.gradientCache[key];
        }
        var gradient = null;
        if (type === GradientType.LinearGradient) {
          var _computeLinearGradien = computeLinearGradient(min10, width, height, angle4), x12 = _computeLinearGradien.x1, y12 = _computeLinearGradien.y1, x22 = _computeLinearGradien.x2, y22 = _computeLinearGradien.y2;
          gradient = context.createLinearGradient(x12, y12, x22, y22);
        } else if (type === GradientType.RadialGradient) {
          var _computeRadialGradien = computeRadialGradient(min10, width, height, cx, cy, size2), x3 = _computeRadialGradien.x, y3 = _computeRadialGradien.y, r = _computeRadialGradien.r;
          gradient = context.createRadialGradient(x3, y3, 0, x3, y3, r);
        }
        if (gradient) {
          steps.forEach(function(_ref2) {
            var offset3 = _ref2.offset, color2 = _ref2.color;
            if (offset3.unit === UnitType.kPercentage) {
              var _gradient;
              (_gradient = gradient) === null || _gradient === void 0 || _gradient.addColorStop(offset3.value / 100, color2.toString());
            }
          });
          this.gradientCache[key] = gradient;
        }
        return this.gradientCache[key];
      }
    }, {
      key: "generateGradientKey",
      value: function generateGradientKey(params) {
        var type = params.type, min10 = params.min, width = params.width, height = params.height, steps = params.steps, angle4 = params.angle, cx = params.cx, cy = params.cy, size2 = params.size;
        return "gradient-".concat(type, "-").concat((angle4 === null || angle4 === void 0 ? void 0 : angle4.toString()) || 0, "-").concat((cx === null || cx === void 0 ? void 0 : cx.toString()) || 0, "-").concat((cy === null || cy === void 0 ? void 0 : cy.toString()) || 0, "-").concat((size2 === null || size2 === void 0 ? void 0 : size2.toString()) || 0, "-").concat(min10[0], "-").concat(min10[1], "-").concat(width, "-").concat(height, "-").concat(steps.map(function(_ref3) {
          var offset3 = _ref3.offset, color2 = _ref3.color;
          return "".concat(offset3).concat(color2);
        }).join("-"));
      }
    }, {
      key: "generatePatternKey",
      value: function generatePatternKey(pattern) {
        var image = pattern.image, repetition = pattern.repetition;
        if (isString2(image)) {
          return "pattern-".concat(image, "-").concat(repetition);
        }
        if (image.nodeName === "rect") {
          return "pattern-".concat(image.entity, "-").concat(repetition);
        }
      }
    }]);
  }();
  ImagePool.isSupportTile = !!OffscreenCanvasCreator.createCanvas();
  function calculateImageTileSize(img) {
    if (!img.complete) {
      return [0, 0];
    }
    var width = img.naturalWidth || img.width, height = img.naturalHeight || img.height;
    var tileSize = 256;
    [256, 512].forEach(function(size2) {
      var rows = Math.ceil(height / size2);
      var cols = Math.ceil(width / size2);
      if (rows * cols < 1e3) {
        tileSize = size2;
      }
    });
    return [tileSize, tileSize];
  }
  var LoadImagePlugin = /* @__PURE__ */ function() {
    function LoadImagePlugin2() {
      _classCallCheck(this, LoadImagePlugin2);
    }
    return _createClass(LoadImagePlugin2, [{
      key: "apply",
      value: function apply(context) {
        var renderingService = context.renderingService, renderingContext = context.renderingContext, imagePool = context.imagePool;
        var canvas = renderingContext.root.ownerDocument.defaultView;
        var calculateWithAspectRatio = function calculateWithAspectRatio2(object, imageWidth, imageHeight) {
          var _object$parsedStyle = object.parsedStyle, width = _object$parsedStyle.width, height = _object$parsedStyle.height;
          if (width && !height) {
            object.setAttribute("height", imageHeight / imageWidth * width);
          } else if (!width && height) {
            object.setAttribute("width", imageWidth / imageHeight * height);
          }
        };
        var handleMounted = function handleMounted2(e3) {
          var object = e3.target;
          var nodeName = object.nodeName, attributes = object.attributes;
          if (nodeName === Shape.IMAGE) {
            var src = attributes.src, keepAspectRatio = attributes.keepAspectRatio;
            imagePool.getImageSync(src, object, function(_ref) {
              var _ref$img = _ref.img, width = _ref$img.width, height = _ref$img.height;
              if (keepAspectRatio) {
                calculateWithAspectRatio(object, width, height);
              }
              object.renderable.dirty = true;
              renderingService.dirtify();
            });
          }
        };
        var handleAttributeChanged = function handleAttributeChanged2(e3) {
          var object = e3.target;
          var attrName = e3.attrName, prevValue = e3.prevValue, newValue = e3.newValue;
          if (object.nodeName !== Shape.IMAGE || attrName !== "src") {
            return;
          }
          if (prevValue !== newValue) {
            imagePool.releaseImage(prevValue, object);
          }
          if (isString2(newValue)) {
            imagePool.getOrCreateImage(newValue, object).then(function(_ref2) {
              var _ref2$img = _ref2.img, width = _ref2$img.width, height = _ref2$img.height;
              if (object.attributes.keepAspectRatio) {
                calculateWithAspectRatio(object, width, height);
              }
              object.renderable.dirty = true;
              renderingService.dirtify();
            })["catch"](function() {
            });
          }
        };
        renderingService.hooks.init.tap(LoadImagePlugin2.tag, function() {
          canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        });
        renderingService.hooks.destroy.tap(LoadImagePlugin2.tag, function() {
          canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        });
      }
    }]);
  }();
  LoadImagePlugin.tag = "LoadImage";
  var Plugin3 = /* @__PURE__ */ function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this;
      _classCallCheck(this, Plugin8);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, Plugin8, [].concat(args));
      _this.name = "image-loader";
      return _this;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init(runtime2) {
        this.context.imagePool = new ImagePool(this.context, runtime2);
        this.addRenderingPlugin(new LoadImagePlugin());
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        this.removeAllRenderingPlugins();
      }
    }]);
  }(AbstractRendererPlugin);

  // node_modules/@antv/g-plugin-canvas-renderer/dist/index.esm.js
  var _renderState = /* @__PURE__ */ _classPrivateFieldKey("renderState");
  var CanvasRendererPlugin = /* @__PURE__ */ function() {
    function CanvasRendererPlugin2(canvasRendererPluginOptions) {
      _classCallCheck(this, CanvasRendererPlugin2);
      this.removedRBushNodeAABBs = [];
      this.renderQueue = [];
      Object.defineProperty(this, _renderState, {
        writable: true,
        value: {
          restoreStack: [],
          prevObject: null,
          currentContext: /* @__PURE__ */ new Map()
        }
      });
      this.clearFullScreenLastFrame = false;
      this.clearFullScreen = false;
      this.vpMatrix = mat4_exports.create();
      this.dprMatrix = mat4_exports.create();
      this.tmpMat4 = mat4_exports.create();
      this.vec3a = vec3_exports.create();
      this.vec3b = vec3_exports.create();
      this.vec3c = vec3_exports.create();
      this.vec3d = vec3_exports.create();
      this.canvasRendererPluginOptions = canvasRendererPluginOptions;
    }
    return _createClass(CanvasRendererPlugin2, [{
      key: "apply",
      value: function apply(context, runtime2) {
        var _this = this;
        this.context = context;
        var _this$context = this.context, config2 = _this$context.config, camera = _this$context.camera, renderingService = _this$context.renderingService, renderingContext = _this$context.renderingContext, rBushRoot = _this$context.rBushRoot, pathGeneratorFactory = _this$context.pathGeneratorFactory;
        var enableRenderingOptimization = config2.renderer.getConfig().enableRenderingOptimization;
        config2.renderer.getConfig().enableDirtyCheck = false;
        config2.renderer.getConfig().enableDirtyRectangleRendering = false;
        this.rBush = rBushRoot;
        this.pathGeneratorFactory = pathGeneratorFactory;
        var contextService = context.contextService;
        var canvas = renderingContext.root.ownerDocument.defaultView;
        var handleUnmounted = function handleUnmounted2(e3) {
          var object = e3.target;
          var rBushNode = object.rBushNode;
          if (rBushNode.aabb) {
            _this.removedRBushNodeAABBs.push(rBushNode.aabb);
          }
        };
        var handleCulled = function handleCulled2(e3) {
          var object = e3.target;
          var rBushNode = object.rBushNode;
          if (rBushNode.aabb) {
            _this.removedRBushNodeAABBs.push(rBushNode.aabb);
          }
        };
        renderingService.hooks.init.tap(CanvasRendererPlugin2.tag, function() {
          canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas.addEventListener(ElementEvent.CULLED, handleCulled);
          var dpr = contextService.getDPR();
          var width = config2.width, height = config2.height;
          var context2 = contextService.getContext();
          _this.clearRect(context2, 0, 0, width * dpr, height * dpr, config2.background);
        });
        renderingService.hooks.destroy.tap(CanvasRendererPlugin2.tag, function() {
          canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas.removeEventListener(ElementEvent.CULLED, handleCulled);
          _this.renderQueue = [];
          _this.removedRBushNodeAABBs = [];
          _classPrivateFieldBase(_this, _renderState)[_renderState] = {
            restoreStack: [],
            prevObject: null,
            currentContext: null
          };
        });
        renderingService.hooks.beginFrame.tap(CanvasRendererPlugin2.tag, function() {
          var _canvas$context$rende;
          var context2 = contextService.getContext();
          var dpr = contextService.getDPR();
          var width = config2.width, height = config2.height;
          var _this$canvasRendererP = _this.canvasRendererPluginOptions, dirtyObjectNumThreshold = _this$canvasRendererP.dirtyObjectNumThreshold, dirtyObjectRatioThreshold = _this$canvasRendererP.dirtyObjectRatioThreshold;
          var _renderingService$get = renderingService.getStats(), total = _renderingService$get.total, rendered = _renderingService$get.rendered;
          var ratio = rendered / total;
          _this.clearFullScreen = _this.clearFullScreenLastFrame || // @ts-ignore
          !((_canvas$context$rende = canvas.context.renderingPlugins[1]) !== null && _canvas$context$rende !== void 0 && _canvas$context$rende.isFirstTimeRenderingFinished) || renderingService.disableDirtyRectangleRendering() || rendered > dirtyObjectNumThreshold && ratio > dirtyObjectRatioThreshold;
          if (context2) {
            if (typeof context2.resetTransform === "function") {
              context2.resetTransform();
            } else {
              context2.setTransform(1, 0, 0, 1, 0, 0);
            }
            if (_this.clearFullScreen) {
              _this.clearRect(context2, 0, 0, width * dpr, height * dpr, config2.background);
            }
          }
        });
        var renderByZIndex = function renderByZIndex2(object, context2) {
          var stack = [object];
          while (stack.length > 0) {
            var currentObject = stack.pop();
            if (currentObject.isVisible() && !currentObject.isCulled()) {
              if (enableRenderingOptimization) {
                _this.renderDisplayObjectOptimized(currentObject, context2, _this.context, _classPrivateFieldBase(_this, _renderState)[_renderState], runtime2);
              } else {
                _this.renderDisplayObject(currentObject, context2, _this.context, _classPrivateFieldBase(_this, _renderState)[_renderState], runtime2);
              }
            }
            var objects = currentObject.sortable.sorted || currentObject.childNodes;
            for (var i = objects.length - 1; i >= 0; i--) {
              stack.push(objects[i]);
            }
          }
        };
        renderingService.hooks.endFrame.tap(CanvasRendererPlugin2.tag, function() {
          if (renderingContext.root.childNodes.length === 0) {
            _this.clearFullScreenLastFrame = true;
            return;
          }
          enableRenderingOptimization = config2.renderer.getConfig().enableRenderingOptimization;
          _classPrivateFieldBase(_this, _renderState)[_renderState] = {
            restoreStack: [],
            prevObject: null,
            currentContext: _classPrivateFieldBase(_this, _renderState)[_renderState].currentContext
          };
          _classPrivateFieldBase(_this, _renderState)[_renderState].currentContext.clear();
          _this.clearFullScreenLastFrame = false;
          var context2 = contextService.getContext();
          var dpr = contextService.getDPR();
          mat4_exports.fromScaling(_this.dprMatrix, [dpr, dpr, 1]);
          mat4_exports.multiply(_this.vpMatrix, _this.dprMatrix, camera.getOrthoMatrix());
          if (_this.clearFullScreen) {
            if (enableRenderingOptimization) {
              context2.save();
              renderByZIndex(renderingContext.root, context2);
              context2.restore();
            } else {
              renderByZIndex(renderingContext.root, context2);
            }
            _this.removedRBushNodeAABBs = [];
          } else {
            var dirtyRenderBounds = _this.safeMergeAABB.apply(_this, [_this.mergeDirtyAABBs(_this.renderQueue)].concat(_toConsumableArray(_this.removedRBushNodeAABBs.map(function(_ref) {
              var minX = _ref.minX, minY = _ref.minY, maxX = _ref.maxX, maxY2 = _ref.maxY;
              var aabb = new AABB();
              aabb.setMinMax(
                // vec3.fromValues(minX, minY, 0),
                // vec3.fromValues(maxX, maxY, 0),
                [minX, minY, 0],
                [maxX, maxY2, 0]
              );
              return aabb;
            }))));
            _this.removedRBushNodeAABBs = [];
            if (AABB.isEmpty(dirtyRenderBounds)) {
              _this.renderQueue = [];
              return;
            }
            var dirtyRect = _this.convertAABB2Rect(dirtyRenderBounds);
            var x3 = dirtyRect.x, y3 = dirtyRect.y, width = dirtyRect.width, height = dirtyRect.height;
            var tl = vec3_exports.transformMat4(_this.vec3a, [x3, y3, 0], _this.vpMatrix);
            var tr = vec3_exports.transformMat4(_this.vec3b, [x3 + width, y3, 0], _this.vpMatrix);
            var bl = vec3_exports.transformMat4(_this.vec3c, [x3, y3 + height, 0], _this.vpMatrix);
            var br = vec3_exports.transformMat4(_this.vec3d, [x3 + width, y3 + height, 0], _this.vpMatrix);
            var minx = Math.min(tl[0], tr[0], br[0], bl[0]);
            var miny = Math.min(tl[1], tr[1], br[1], bl[1]);
            var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);
            var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);
            var ix = Math.floor(minx);
            var iy = Math.floor(miny);
            var iwidth = Math.ceil(maxx - minx);
            var iheight = Math.ceil(maxy - miny);
            context2.save();
            _this.clearRect(context2, ix, iy, iwidth, iheight, config2.background);
            context2.beginPath();
            context2.rect(ix, iy, iwidth, iheight);
            context2.clip();
            context2.setTransform(_this.vpMatrix[0], _this.vpMatrix[1], _this.vpMatrix[4], _this.vpMatrix[5], _this.vpMatrix[12], _this.vpMatrix[13]);
            var _config$renderer$getC = config2.renderer.getConfig(), enableDirtyRectangleRenderingDebug = _config$renderer$getC.enableDirtyRectangleRenderingDebug;
            if (enableDirtyRectangleRenderingDebug) {
              canvas.dispatchEvent(new CustomEvent2(CanvasEvent.DIRTY_RECTANGLE, {
                dirtyRect: {
                  x: ix,
                  y: iy,
                  width: iwidth,
                  height: iheight
                }
              }));
            }
            var dirtyObjects = _this.searchDirtyObjects(dirtyRenderBounds);
            dirtyObjects.sort(function(a3, b) {
              return a3.sortable.renderOrder - b.sortable.renderOrder;
            }).forEach(function(object) {
              if (object && object.isVisible() && !object.isCulled()) {
                _this.renderDisplayObject(object, context2, _this.context, _classPrivateFieldBase(_this, _renderState)[_renderState], runtime2);
              }
            });
            context2.restore();
            _this.renderQueue.forEach(function(object) {
              _this.saveDirtyAABB(object);
            });
            _this.renderQueue = [];
          }
          _classPrivateFieldBase(_this, _renderState)[_renderState].restoreStack.forEach(function() {
            context2.restore();
          });
          _classPrivateFieldBase(_this, _renderState)[_renderState].restoreStack = [];
        });
        renderingService.hooks.render.tap(CanvasRendererPlugin2.tag, function(object) {
          if (!_this.clearFullScreen) {
            _this.renderQueue.push(object);
          }
        });
      }
    }, {
      key: "clearRect",
      value: function clearRect(context, x3, y3, width, height, background) {
        context.clearRect(x3, y3, width, height);
        if (background) {
          context.fillStyle = background;
          context.fillRect(x3, y3, width, height);
        }
      }
    }, {
      key: "renderDisplayObjectOptimized",
      value: function renderDisplayObjectOptimized(object, context, canvasContext, renderState, runtime2) {
        var nodeName = object.nodeName;
        var updateTransform = false;
        var clipDraw = false;
        var styleRenderer = this.context.styleRendererFactory[nodeName];
        var generatePath2 = this.pathGeneratorFactory[nodeName];
        var clipPath = object.parsedStyle.clipPath;
        if (clipPath) {
          updateTransform = !renderState.prevObject || !mat4_exports.exactEquals(clipPath.getWorldTransform(), renderState.prevObject.getWorldTransform());
          if (updateTransform) {
            this.applyWorldTransform(context, clipPath);
            renderState.prevObject = null;
          }
          var _generatePath = this.pathGeneratorFactory[clipPath.nodeName];
          if (_generatePath) {
            context.save();
            clipDraw = true;
            context.beginPath();
            _generatePath(context, clipPath.parsedStyle);
            context.closePath();
            context.clip();
          }
        }
        if (styleRenderer) {
          updateTransform = !renderState.prevObject || !mat4_exports.exactEquals(object.getWorldTransform(), renderState.prevObject.getWorldTransform());
          if (updateTransform) {
            this.applyWorldTransform(context, object);
          }
          var forceUpdateStyle = !renderState.prevObject;
          if (!forceUpdateStyle) {
            var prevNodeName = renderState.prevObject.nodeName;
            if (nodeName === Shape.TEXT) {
              forceUpdateStyle = prevNodeName !== Shape.TEXT;
            } else if (nodeName === Shape.IMAGE) {
              forceUpdateStyle = prevNodeName !== Shape.IMAGE;
            } else {
              forceUpdateStyle = prevNodeName === Shape.TEXT || prevNodeName === Shape.IMAGE;
            }
          }
          styleRenderer.applyStyleToContext(context, object, forceUpdateStyle, renderState);
          renderState.prevObject = object;
        }
        if (generatePath2) {
          context.beginPath();
          generatePath2(context, object.parsedStyle);
          if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {
            context.closePath();
          }
        }
        if (styleRenderer) {
          styleRenderer.drawToContext(context, object, _classPrivateFieldBase(this, _renderState)[_renderState], this, runtime2);
        }
        if (clipDraw) {
          context.restore();
        }
        object.renderable.dirty = false;
      }
    }, {
      key: "renderDisplayObject",
      value: function renderDisplayObject(object, context, canvasContext, renderState, runtime2) {
        var nodeName = object.nodeName;
        var parent = renderState.restoreStack[renderState.restoreStack.length - 1];
        if (parent && !(object.compareDocumentPosition(parent) & Node2.DOCUMENT_POSITION_CONTAINS)) {
          context.restore();
          renderState.restoreStack.pop();
        }
        var styleRenderer = this.context.styleRendererFactory[nodeName];
        var generatePath2 = this.pathGeneratorFactory[nodeName];
        var clipPath = object.parsedStyle.clipPath;
        if (clipPath) {
          this.applyWorldTransform(context, clipPath);
          var _generatePath2 = this.pathGeneratorFactory[clipPath.nodeName];
          if (_generatePath2) {
            context.save();
            renderState.restoreStack.push(object);
            context.beginPath();
            _generatePath2(context, clipPath.parsedStyle);
            context.closePath();
            context.clip();
          }
        }
        if (styleRenderer) {
          this.applyWorldTransform(context, object);
          context.save();
          this.applyAttributesToContext(context, object);
        }
        if (generatePath2) {
          context.beginPath();
          generatePath2(context, object.parsedStyle);
          if (nodeName !== Shape.LINE && nodeName !== Shape.PATH && nodeName !== Shape.POLYLINE) {
            context.closePath();
          }
        }
        if (styleRenderer) {
          styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime2);
          context.restore();
        }
        object.renderable.dirty = false;
      }
    }, {
      key: "applyAttributesToContext",
      value: function applyAttributesToContext(context, object) {
        var _ref2 = object.parsedStyle, stroke2 = _ref2.stroke, fill = _ref2.fill, opacity = _ref2.opacity, lineDash = _ref2.lineDash, lineDashOffset = _ref2.lineDashOffset;
        if (lineDash) {
          context.setLineDash(lineDash);
        }
        if (!isNil(lineDashOffset)) {
          context.lineDashOffset = lineDashOffset;
        }
        if (!isNil(opacity)) {
          context.globalAlpha *= opacity;
        }
        if (!isNil(stroke2) && !Array.isArray(stroke2) && !stroke2.isNone) {
          context.strokeStyle = object.attributes.stroke;
        }
        if (!isNil(fill) && !Array.isArray(fill) && !fill.isNone) {
          context.fillStyle = object.attributes.fill;
        }
      }
    }, {
      key: "convertAABB2Rect",
      value: function convertAABB2Rect(aabb) {
        var min10 = aabb.getMin();
        var max11 = aabb.getMax();
        var minX = Math.floor(min10[0]);
        var minY = Math.floor(min10[1]);
        var maxX = Math.ceil(max11[0]);
        var maxY2 = Math.ceil(max11[1]);
        var width = maxX - minX;
        var height = maxY2 - minY;
        return {
          x: minX,
          y: minY,
          width,
          height
        };
      }
      /**
       * TODO: merge dirty rectangles with some strategies.
       * For now, we just simply merge all the rectangles into one.
       * @see https://idom.me/articles/841.html
       */
    }, {
      key: "mergeDirtyAABBs",
      value: function mergeDirtyAABBs(dirtyObjects) {
        var aabb = new AABB();
        dirtyObjects.forEach(function(object) {
          var renderBounds = object.getRenderBounds();
          aabb.add(renderBounds);
          var dirtyRenderBounds = object.renderable.dirtyRenderBounds;
          if (dirtyRenderBounds) {
            aabb.add(dirtyRenderBounds);
          }
        });
        return aabb;
      }
    }, {
      key: "searchDirtyObjects",
      value: function searchDirtyObjects(dirtyRectangle) {
        var _dirtyRectangle$getMi = dirtyRectangle.getMin(), _dirtyRectangle$getMi2 = _slicedToArray(_dirtyRectangle$getMi, 2), minX = _dirtyRectangle$getMi2[0], minY = _dirtyRectangle$getMi2[1];
        var _dirtyRectangle$getMa = dirtyRectangle.getMax(), _dirtyRectangle$getMa2 = _slicedToArray(_dirtyRectangle$getMa, 2), maxX = _dirtyRectangle$getMa2[0], maxY2 = _dirtyRectangle$getMa2[1];
        var rBushNodes = this.rBush.search({
          minX,
          minY,
          maxX,
          maxY: maxY2
        });
        return rBushNodes.map(function(_ref3) {
          var displayObject = _ref3.displayObject;
          return displayObject;
        });
      }
    }, {
      key: "saveDirtyAABB",
      value: function saveDirtyAABB(object) {
        var renderable = object.renderable;
        if (!renderable.dirtyRenderBounds) {
          renderable.dirtyRenderBounds = new AABB();
        }
        var renderBounds = object.getRenderBounds();
        if (renderBounds) {
          renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
        }
      }
    }, {
      key: "applyWorldTransform",
      value: function applyWorldTransform(context, object, matrix3) {
        if (matrix3) {
          mat4_exports.copy(this.tmpMat4, object.getLocalTransform());
          mat4_exports.multiply(this.tmpMat4, matrix3, this.tmpMat4);
          mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
        } else {
          mat4_exports.copy(this.tmpMat4, object.getWorldTransform());
          mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
        }
        context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);
      }
    }, {
      key: "safeMergeAABB",
      value: function safeMergeAABB() {
        var merged = new AABB();
        for (var _len = arguments.length, aabbs = new Array(_len), _key = 0; _key < _len; _key++) {
          aabbs[_key] = arguments[_key];
        }
        aabbs.forEach(function(aabb) {
          merged.add(aabb);
        });
        return merged;
      }
    }]);
  }();
  CanvasRendererPlugin.tag = "CanvasRenderer";
  function getPattern(pattern, object, context, canvasContext, plugin, runtime2, imagePool) {
    var $offscreenCanvas;
    var dpr;
    if (pattern.image.nodeName === "rect") {
      var _parsedStyle = pattern.image.parsedStyle, width = _parsedStyle.width, height = _parsedStyle.height;
      dpr = canvasContext.contextService.getDPR();
      var offscreenCanvas = canvasContext.config.offscreenCanvas;
      $offscreenCanvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
      $offscreenCanvas.width = width * dpr;
      $offscreenCanvas.height = height * dpr;
      var offscreenCanvasContext = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
      var renderState = {
        restoreStack: [],
        prevObject: null,
        currentContext: /* @__PURE__ */ new Map()
      };
      pattern.image.forEach(function(object2) {
        plugin.renderDisplayObject(object2, offscreenCanvasContext, canvasContext, renderState, runtime2);
      });
      renderState.restoreStack.forEach(function() {
        offscreenCanvasContext.restore();
      });
    }
    var canvasPattern = imagePool.getOrCreatePatternSync(object, pattern, context, $offscreenCanvas, dpr, object.getGeometryBounds().min, function() {
      object.renderable.dirty = true;
      canvasContext.renderingService.dirtify();
    });
    return canvasPattern;
  }
  function getColor2(parsedColor, object, context, imagePool) {
    var color2;
    if (parsedColor.type === GradientType.LinearGradient || parsedColor.type === GradientType.RadialGradient) {
      var bounds = object.getGeometryBounds();
      var width = bounds && bounds.halfExtents[0] * 2 || 1;
      var height = bounds && bounds.halfExtents[1] * 2 || 1;
      var min10 = bounds && bounds.min || [0, 0];
      color2 = imagePool.getOrCreateGradient(_objectSpread22(_objectSpread22({
        type: parsedColor.type
      }, parsedColor.value), {}, {
        min: min10,
        width,
        height
      }), context);
    }
    return color2;
  }
  var SHADOW_NUMBER_STYLE = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"];
  var STROKE_STYLE = ["lineCap", "lineJoin", "miterLimit"];
  var DEFAULT_STYLE = {
    // common
    globalAlpha: 1,
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: "#000",
    filter: "none",
    globalCompositeOperation: "source-over",
    // stroke/fill
    strokeStyle: "#000",
    strokeOpacity: 1,
    lineWidth: 1,
    lineDash: [],
    lineDashOffset: 0,
    lineCap: "butt",
    lineJoin: "miter",
    miterLimit: 10,
    fillStyle: "#000",
    fillOpacity: 1
    // image
  };
  var defaultParsedStyle = {};
  function updateContextIfNotHitCache(context, key, value2, cache3) {
    var prevValue = cache3.has(key) ? cache3.get(key) : DEFAULT_STYLE[key];
    if (prevValue !== value2) {
      if (key === "lineDash") {
        context.setLineDash(value2);
      } else {
        context[key] = value2;
      }
      cache3.set(key, value2);
    }
    return prevValue;
  }
  var OptimizedDefaultRenderer = /* @__PURE__ */ function() {
    function OptimizedDefaultRenderer2(imagePool) {
      _classCallCheck(this, OptimizedDefaultRenderer2);
      this.imagePool = imagePool;
    }
    return _createClass(OptimizedDefaultRenderer2, [{
      key: "applyAttributesToContext",
      value: function applyAttributesToContext(context, object) {
      }
    }, {
      key: "render",
      value: function render2(context, parsedStyle, object, canvasContext, plugin, runtime2) {
      }
      // #region common style
    }, {
      key: "applyCommonStyleToContext",
      value: function applyCommonStyleToContext(context, object, forceUpdate, renderState) {
        var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;
        var style = object.parsedStyle;
        if (forceUpdate || style.opacity !== prevStyle.opacity) {
          updateContextIfNotHitCache(context, "globalAlpha", !isNil(style.opacity) ? style.opacity : DEFAULT_STYLE.globalAlpha, renderState.currentContext);
        }
        if (forceUpdate || style.blend !== prevStyle.blend) {
          updateContextIfNotHitCache(
            context,
            "globalCompositeOperation",
            // @ts-ignore
            !isNil(style.blend) ? (
              // @ts-ignore
              style.blend
            ) : DEFAULT_STYLE.globalCompositeOperation,
            renderState.currentContext
          );
        }
      }
      // #endregion common style
      // #region stroke/fill style
    }, {
      key: "applyStrokeFillStyleToContext",
      value: function applyStrokeFillStyleToContext(context, object, forceUpdate, renderState) {
        var prevStyle = forceUpdate ? defaultParsedStyle : renderState.prevObject.parsedStyle;
        var style = object.parsedStyle;
        var _style$lineWidth = style.lineWidth, lineWidth = _style$lineWidth === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth;
        var hasFill = style.fill && !style.fill.isNone;
        var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;
        if (hasStroke) {
          if (forceUpdate || object.attributes.stroke !== renderState.prevObject.attributes.stroke) {
            var value2 = !isNil(style.stroke) && !Array.isArray(style.stroke) && !style.stroke.isNone ? object.attributes.stroke : DEFAULT_STYLE.strokeStyle;
            updateContextIfNotHitCache(context, "strokeStyle", value2, renderState.currentContext);
          }
          if (forceUpdate || style.lineWidth !== prevStyle.lineWidth) {
            updateContextIfNotHitCache(context, "lineWidth", !isNil(style.lineWidth) ? style.lineWidth : DEFAULT_STYLE.lineWidth, renderState.currentContext);
          }
          if (forceUpdate || style.lineDash !== prevStyle.lineDash) {
            updateContextIfNotHitCache(context, "lineDash", style.lineDash || DEFAULT_STYLE.lineDash, renderState.currentContext);
          }
          if (forceUpdate || style.lineDashOffset !== prevStyle.lineDashOffset) {
            updateContextIfNotHitCache(context, "lineDashOffset", !isNil(style.lineDashOffset) ? style.lineDashOffset : DEFAULT_STYLE.lineDashOffset, renderState.currentContext);
          }
          for (var i = 0; i < STROKE_STYLE.length; i++) {
            var styleName = STROKE_STYLE[i];
            if (forceUpdate || style[styleName] !== prevStyle[styleName]) {
              updateContextIfNotHitCache(context, styleName, !isNil(style[styleName]) ? style[styleName] : DEFAULT_STYLE[styleName], renderState.currentContext);
            }
          }
        }
        if (hasFill && (forceUpdate || object.attributes.fill !== renderState.prevObject.attributes.fill)) {
          var _value = !isNil(style.fill) && !Array.isArray(style.fill) && !style.fill.isNone ? object.attributes.fill : DEFAULT_STYLE.fillStyle;
          updateContextIfNotHitCache(context, "fillStyle", _value, renderState.currentContext);
        }
      }
      // #endregion stroke/fill style
    }, {
      key: "applyStyleToContext",
      value: function applyStyleToContext(context, object, forceUpdate, renderState) {
        var nodeName = object.nodeName;
        this.applyCommonStyleToContext(context, object, forceUpdate, renderState);
        if (nodeName === Shape.IMAGE) ;
        else {
          this.applyStrokeFillStyleToContext(context, object, forceUpdate, renderState);
        }
      }
    }, {
      key: "applyShadowAndFilterStyleToContext",
      value: function applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState) {
        var style = object.parsedStyle;
        if (hasShadow) {
          updateContextIfNotHitCache(context, "shadowColor", style.shadowColor.toString(), renderState.currentContext);
          for (var i = 0; i < SHADOW_NUMBER_STYLE.length; i++) {
            var styleName = SHADOW_NUMBER_STYLE[i];
            updateContextIfNotHitCache(context, styleName, style[styleName] || DEFAULT_STYLE[styleName], renderState.currentContext);
          }
        }
        if (style.filter && style.filter.length) {
          updateContextIfNotHitCache(
            context,
            "filter",
            // use raw filter string
            object.attributes.filter,
            renderState.currentContext
          );
        }
      }
    }, {
      key: "clearShadowAndFilterStyleForContext",
      value: function clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState) {
        var onlyClearShadowFilter = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
        if (hasShadow) {
          updateContextIfNotHitCache(context, "shadowColor", DEFAULT_STYLE.shadowColor, renderState.currentContext);
          for (var i = 0; i < SHADOW_NUMBER_STYLE.length; i++) {
            var styleName = SHADOW_NUMBER_STYLE[i];
            updateContextIfNotHitCache(context, styleName, DEFAULT_STYLE[styleName], renderState.currentContext);
          }
        }
        if (hasFilter) {
          if (hasShadow && onlyClearShadowFilter) {
            var oldFilter = context.filter;
            if (!isNil(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
              updateContextIfNotHitCache(context, "filter", oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || DEFAULT_STYLE.filter, renderState.currentContext);
            }
          } else {
            updateContextIfNotHitCache(context, "filter", DEFAULT_STYLE.filter, renderState.currentContext);
          }
        }
      }
    }, {
      key: "fillToContext",
      value: function fillToContext(context, object, renderState, plugin, runtime2) {
        var _this = this;
        var _object$parsedStyle = object.parsedStyle, fill = _object$parsedStyle.fill, fillRule = _object$parsedStyle.fillRule;
        var resetStyle = null;
        if (Array.isArray(fill) && fill.length > 0) {
          fill.forEach(function(gradient) {
            var _resetStyle;
            var prevStyle = updateContextIfNotHitCache(context, "fillStyle", getColor2(gradient, object, context, _this.imagePool), renderState.currentContext);
            resetStyle = (_resetStyle = resetStyle) !== null && _resetStyle !== void 0 ? _resetStyle : prevStyle;
            if (fillRule) {
              context.fill(fillRule);
            } else {
              context.fill();
            }
          });
        } else {
          if (isPattern(fill)) {
            var pattern = getPattern(fill, object, context, object.ownerDocument.defaultView.context, plugin, runtime2, this.imagePool);
            if (pattern) {
              context.fillStyle = pattern;
              resetStyle = true;
            }
          }
          if (fillRule) {
            context.fill(fillRule);
          } else {
            context.fill();
          }
        }
        if (resetStyle !== null) {
          updateContextIfNotHitCache(context, "fillStyle", resetStyle, renderState.currentContext);
        }
      }
    }, {
      key: "strokeToContext",
      value: function strokeToContext(context, object, renderState, plugin, runtime2) {
        var _this2 = this;
        var stroke2 = object.parsedStyle.stroke;
        var resetStyle = null;
        if (Array.isArray(stroke2) && stroke2.length > 0) {
          stroke2.forEach(function(gradient) {
            var _resetStyle2;
            var prevStyle2 = updateContextIfNotHitCache(context, "strokeStyle", getColor2(gradient, object, context, _this2.imagePool), renderState.currentContext);
            resetStyle = (_resetStyle2 = resetStyle) !== null && _resetStyle2 !== void 0 ? _resetStyle2 : prevStyle2;
            context.stroke();
          });
        } else {
          if (isPattern(stroke2)) {
            var pattern = getPattern(stroke2, object, context, object.ownerDocument.defaultView.context, plugin, runtime2, this.imagePool);
            if (pattern) {
              var _resetStyle3;
              var prevStyle = updateContextIfNotHitCache(context, "strokeStyle", pattern, renderState.currentContext);
              resetStyle = (_resetStyle3 = resetStyle) !== null && _resetStyle3 !== void 0 ? _resetStyle3 : prevStyle;
            }
          }
          context.stroke();
        }
        if (resetStyle !== null) {
          updateContextIfNotHitCache(context, "strokeStyle", resetStyle, renderState.currentContext);
        }
      }
    }, {
      key: "drawToContext",
      value: function drawToContext(context, object, renderState, plugin, runtime2) {
        var _style$fill;
        var nodeName = object.nodeName;
        var style = object.parsedStyle;
        var _style$opacity = style.opacity, opacity = _style$opacity === void 0 ? DEFAULT_STYLE.globalAlpha : _style$opacity, _style$fillOpacity = style.fillOpacity, fillOpacity = _style$fillOpacity === void 0 ? DEFAULT_STYLE.fillOpacity : _style$fillOpacity, _style$strokeOpacity = style.strokeOpacity, strokeOpacity = _style$strokeOpacity === void 0 ? DEFAULT_STYLE.strokeOpacity : _style$strokeOpacity, _style$lineWidth2 = style.lineWidth, lineWidth = _style$lineWidth2 === void 0 ? DEFAULT_STYLE.lineWidth : _style$lineWidth2;
        var hasFill = style.fill && !style.fill.isNone;
        var hasStroke = style.stroke && !style.stroke.isNone && lineWidth > 0;
        if (!hasFill && !hasStroke) {
          return;
        }
        var hasShadow = !isNil(style.shadowColor) && style.shadowBlur > 0;
        var isInnerShadow = style.shadowType === "inner";
        var isFillTransparent = ((_style$fill = style.fill) === null || _style$fill === void 0 ? void 0 : _style$fill.alpha) === 0;
        var hasFilter = !!(style.filter && style.filter.length);
        var shouldDrawShadowWithStroke = hasShadow && hasStroke && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
        var originGlobalAlpha = null;
        if (hasFill) {
          if (!shouldDrawShadowWithStroke) {
            this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);
          }
          var updateOpacity = opacity * fillOpacity;
          originGlobalAlpha = updateContextIfNotHitCache(context, "globalAlpha", updateOpacity, renderState.currentContext);
          this.fillToContext(context, object, renderState, plugin, runtime2);
          if (!shouldDrawShadowWithStroke) {
            this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);
          }
        }
        if (hasStroke) {
          var clearShadowAndFilter = false;
          var _updateOpacity = opacity * strokeOpacity;
          var prevOpacity = updateContextIfNotHitCache(context, "globalAlpha", _updateOpacity, renderState.currentContext);
          originGlobalAlpha = hasFill ? originGlobalAlpha : prevOpacity;
          if (shouldDrawShadowWithStroke) {
            this.applyShadowAndFilterStyleToContext(context, object, hasShadow, renderState);
            clearShadowAndFilter = true;
            if (isInnerShadow) {
              var originBlend = context.globalCompositeOperation;
              context.globalCompositeOperation = "source-atop";
              this.strokeToContext(context, object, renderState, plugin, runtime2);
              context.globalCompositeOperation = originBlend;
              this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState, true);
            }
          }
          this.strokeToContext(context, object, renderState, plugin, runtime2);
          if (clearShadowAndFilter) {
            this.clearShadowAndFilterStyleForContext(context, hasShadow, hasFilter, renderState);
          }
        }
        if (originGlobalAlpha !== null) {
          updateContextIfNotHitCache(context, "globalAlpha", originGlobalAlpha, renderState.currentContext);
        }
      }
    }]);
  }();
  var DefaultRenderer = /* @__PURE__ */ function(_OptimizedDefaultRend) {
    function DefaultRenderer2() {
      _classCallCheck(this, DefaultRenderer2);
      return _callSuper(this, DefaultRenderer2, arguments);
    }
    _inherits(DefaultRenderer2, _OptimizedDefaultRend);
    return _createClass(DefaultRenderer2, [{
      key: "render",
      value: function render2(context, parsedStyle, object, canvasContext, plugin, runtime2) {
        var fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, _parsedStyle$opacity = parsedStyle.opacity, opacity = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity, _parsedStyle$fillOpac = parsedStyle.fillOpacity, fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac, stroke2 = parsedStyle.stroke, _parsedStyle$strokeOp = parsedStyle.strokeOpacity, strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp, _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, lineCap = parsedStyle.lineCap, lineJoin = parsedStyle.lineJoin, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur, filter2 = parsedStyle.filter, miterLimit = parsedStyle.miterLimit;
        var hasFill = fill && !fill.isNone;
        var hasStroke = stroke2 && !stroke2.isNone && lineWidth > 0;
        var isFillTransparent = (fill === null || fill === void 0 ? void 0 : fill.alpha) === 0;
        var hasFilter = !!(filter2 && filter2.length);
        var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
        var nodeName = object.nodeName;
        var isInnerShadow = shadowType === "inner";
        var shouldDrawShadowWithStroke = hasStroke && hasShadow && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
        if (hasFill) {
          context.globalAlpha = opacity * fillOpacity;
          if (!shouldDrawShadowWithStroke) {
            setShadowAndFilter(object, context, hasShadow);
          }
          applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool);
          if (!shouldDrawShadowWithStroke) {
            this.clearShadowAndFilter(context, hasFilter, hasShadow);
          }
        }
        if (hasStroke) {
          context.globalAlpha = opacity * strokeOpacity;
          context.lineWidth = lineWidth;
          if (!isNil(miterLimit)) {
            context.miterLimit = miterLimit;
          }
          if (!isNil(lineCap)) {
            context.lineCap = lineCap;
          }
          if (!isNil(lineJoin)) {
            context.lineJoin = lineJoin;
          }
          if (shouldDrawShadowWithStroke) {
            if (isInnerShadow) {
              context.globalCompositeOperation = "source-atop";
            }
            setShadowAndFilter(object, context, true);
            if (isInnerShadow) {
              applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, this.imagePool);
              context.globalCompositeOperation = DEFAULT_STYLE.globalCompositeOperation;
              this.clearShadowAndFilter(context, hasFilter, true);
            }
          }
          applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, this.imagePool);
        }
      }
    }, {
      key: "clearShadowAndFilter",
      value: function clearShadowAndFilter(context, hasFilter, hasShadow) {
        if (hasShadow) {
          context.shadowColor = "transparent";
          context.shadowBlur = 0;
        }
        if (hasFilter) {
          var oldFilter = context.filter;
          if (!isNil(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
            context.filter = oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || "none";
          }
        }
      }
    }]);
  }(OptimizedDefaultRenderer);
  function setShadowAndFilter(object, context, hasShadow) {
    var _object$parsedStyle = object.parsedStyle, filter2 = _object$parsedStyle.filter, shadowColor = _object$parsedStyle.shadowColor, shadowBlur = _object$parsedStyle.shadowBlur, shadowOffsetX = _object$parsedStyle.shadowOffsetX, shadowOffsetY = _object$parsedStyle.shadowOffsetY;
    if (filter2 && filter2.length) {
      context.filter = object.style.filter;
    }
    if (hasShadow) {
      context.shadowColor = shadowColor.toString();
      context.shadowBlur = shadowBlur || 0;
      context.shadowOffsetX = shadowOffsetX || 0;
      context.shadowOffsetY = shadowOffsetY || 0;
    }
  }
  function applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, imagePool) {
    var skipFill = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : false;
    if (Array.isArray(fill)) {
      fill.forEach(function(gradient) {
        context.fillStyle = getColor2(gradient, object, context, imagePool);
        if (!skipFill) {
          fillRule ? context.fill(fillRule) : context.fill();
        }
      });
    } else {
      if (isPattern(fill)) {
        context.fillStyle = getPattern(fill, object, context, canvasContext, plugin, runtime2, imagePool);
      }
      if (!skipFill) {
        fillRule ? context.fill(fillRule) : context.fill();
      }
    }
  }
  function applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, imagePool) {
    var skipStroke = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : false;
    if (Array.isArray(stroke2)) {
      stroke2.forEach(function(gradient) {
        context.strokeStyle = getColor2(gradient, object, context, imagePool);
        if (!skipStroke) {
          context.stroke();
        }
      });
    } else {
      if (isPattern(stroke2)) {
        context.strokeStyle = getPattern(stroke2, object, context, canvasContext, plugin, runtime2, imagePool);
      }
      if (!skipStroke) {
        context.stroke();
      }
    }
  }
  function calculateOverlapRect(rect1, rect22) {
    var _rect = _slicedToArray(rect1, 4), x12 = _rect[0], y12 = _rect[1], w1 = _rect[2], h1 = _rect[3];
    var _rect2 = _slicedToArray(rect22, 4), x22 = _rect2[0], y22 = _rect2[1], w2 = _rect2[2], h2 = _rect2[3];
    var overlapLeft = Math.max(x12, x22);
    var overlapTop = Math.max(y12, y22);
    var overlapRight = Math.min(x12 + w1, x22 + w2);
    var overlapBottom = Math.min(y12 + h1, y22 + h2);
    if (overlapRight <= overlapLeft || overlapBottom <= overlapTop) {
      return null;
    }
    return [overlapLeft, overlapTop, overlapRight - overlapLeft, overlapBottom - overlapTop];
  }
  function transformRect(rect4, matrix3) {
    var tl = vec3_exports.transformMat4(vec3_exports.create(), [rect4[0], rect4[1], 0], matrix3);
    var tr = vec3_exports.transformMat4(vec3_exports.create(), [rect4[0] + rect4[2], rect4[1], 0], matrix3);
    var bl = vec3_exports.transformMat4(vec3_exports.create(), [rect4[0], rect4[1] + rect4[3], 0], matrix3);
    var br = vec3_exports.transformMat4(vec3_exports.create(), [rect4[0] + rect4[2], rect4[1] + rect4[3], 0], matrix3);
    return [Math.min(tl[0], tr[0], bl[0], br[0]), Math.min(tl[1], tr[1], bl[1], br[1]), Math.max(tl[0], tr[0], bl[0], br[0]) - Math.min(tl[0], tr[0], bl[0], br[0]), Math.max(tl[1], tr[1], bl[1], br[1]) - Math.min(tl[1], tr[1], bl[1], br[1])];
  }
  var ImageRenderer = /* @__PURE__ */ function(_DefaultRenderer) {
    function ImageRenderer2() {
      _classCallCheck(this, ImageRenderer2);
      return _callSuper(this, ImageRenderer2, arguments);
    }
    _inherits(ImageRenderer2, _DefaultRenderer);
    return _createClass(ImageRenderer2, [{
      key: "renderDownSampled",
      value: function renderDownSampled(context, parsedStyle, object, data2) {
        var src = data2.src, imageCache = data2.imageCache;
        if (!imageCache.downSampled) {
          this.imagePool.createDownSampledImage(src, object).then(function(res) {
            object.renderable.dirty = true;
            object.ownerDocument.defaultView.context.renderingService.dirtify();
          })["catch"](function() {
          });
          return;
        }
        context.drawImage(imageCache.downSampled, Math.floor(data2.drawRect[0]), Math.floor(data2.drawRect[1]), Math.ceil(data2.drawRect[2]), Math.ceil(data2.drawRect[3]));
      }
    }, {
      key: "renderTile",
      value: function renderTile(context, parsedStyle, object, data2) {
        var src = data2.src, imageCache = data2.imageCache, imageRect = data2.imageRect, drawRect = data2.drawRect;
        var originalSize = imageCache.size;
        var _context$getTransform = context.getTransform(), a3 = _context$getTransform.a, b = _context$getTransform.b, c5 = _context$getTransform.c, d3 = _context$getTransform.d, e3 = _context$getTransform.e, f = _context$getTransform.f;
        context.resetTransform();
        if (!(imageCache !== null && imageCache !== void 0 && imageCache.gridSize)) {
          this.imagePool.createImageTiles(src, [], function() {
            object.renderable.dirty = true;
            object.ownerDocument.defaultView.context.renderingService.dirtify();
          }, object)["catch"](function() {
          });
          return;
        }
        var scaleToOrigin = [originalSize[0] / imageRect[2], originalSize[1] / imageRect[3]];
        var scaledTileSize = [imageCache.tileSize[0] / scaleToOrigin[0], imageCache.tileSize[1] / scaleToOrigin[1]];
        var _ref = [Math.floor((drawRect[0] - imageRect[0]) / scaledTileSize[0]), Math.ceil((drawRect[0] + drawRect[2] - imageRect[0]) / scaledTileSize[0])], startTileX = _ref[0], endTileX = _ref[1];
        var _ref2 = [Math.floor((drawRect[1] - imageRect[1]) / scaledTileSize[1]), Math.ceil((drawRect[1] + drawRect[3] - imageRect[1]) / scaledTileSize[1])], startTileY = _ref2[0], endTileY = _ref2[1];
        for (var tileY = startTileY; tileY <= endTileY; tileY++) {
          for (var tileX = startTileX; tileX <= endTileX; tileX++) {
            var item = imageCache.tiles[tileY][tileX];
            if (item) {
              var tileRect = [Math.floor(imageRect[0] + item.tileX * scaledTileSize[0]), Math.floor(imageRect[1] + item.tileY * scaledTileSize[1]), Math.ceil(scaledTileSize[0]), Math.ceil(scaledTileSize[1])];
              context.drawImage(item.data, tileRect[0], tileRect[1], tileRect[2], tileRect[3]);
            }
          }
        }
        context.setTransform(a3, b, c5, d3, e3, f);
      }
    }, {
      key: "render",
      value: function render2(context, parsedStyle, object) {
        var _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, width = parsedStyle.width, height = parsedStyle.height, src = parsedStyle.src, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
        var imageCache = this.imagePool.getImageSync(src, object);
        var image = imageCache === null || imageCache === void 0 ? void 0 : imageCache.img;
        var iw = width;
        var ih = height;
        if (!image) {
          return;
        }
        iw || (iw = image.width);
        ih || (ih = image.height);
        var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
        setShadowAndFilter(object, context, hasShadow);
        try {
          var _object$ownerDocument = object.ownerDocument.defaultView.getContextService().getDomElement(), viewWidth = _object$ownerDocument.width, viewHeight = _object$ownerDocument.height;
          var currentTransform = context.getTransform();
          var a3 = currentTransform.a, b = currentTransform.b, c5 = currentTransform.c, d3 = currentTransform.d, e3 = currentTransform.e, f = currentTransform.f;
          var transformMatrix = mat4_exports.fromValues(a3, c5, 0, 0, b, d3, 0, 0, 0, 0, 1, 0, e3, f, 0, 1);
          var imageRect = transformRect([x3, y3, iw, ih], transformMatrix);
          var drawRect = calculateOverlapRect([0, 0, viewWidth, viewHeight], imageRect);
          if (!drawRect) {
            return;
          }
          if (!object.ownerDocument.defaultView.getConfig().enableLargeImageOptimization) {
            ImageRenderer2.renderFull(context, parsedStyle, object, {
              image,
              drawRect: [x3, y3, iw, ih]
            });
            return;
          }
          var sizeOfOrigin = imageRect[2] / imageCache.size[0];
          if (sizeOfOrigin < (imageCache.downSamplingRate || 0.5)) {
            this.renderDownSampled(context, parsedStyle, object, {
              src,
              imageCache,
              drawRect: [x3, y3, iw, ih]
            });
            return;
          }
          if (!ImagePool.isSupportTile) {
            ImageRenderer2.renderFull(context, parsedStyle, object, {
              image,
              drawRect: [x3, y3, iw, ih]
            });
            return;
          }
          this.renderTile(context, parsedStyle, object, {
            src,
            imageCache,
            imageRect,
            drawRect
          });
        } catch (_unused) {
        }
      }
      // ---
    }, {
      key: "drawToContext",
      value: function drawToContext(context, object, renderState, plugin, runtime2) {
        this.render(context, object.parsedStyle, object);
      }
    }], [{
      key: "renderFull",
      value: function renderFull(context, parsedStyle, object, data2) {
        context.drawImage(data2.image, Math.floor(data2.drawRect[0]), Math.floor(data2.drawRect[1]), Math.ceil(data2.drawRect[2]), Math.ceil(data2.drawRect[3]));
      }
    }]);
  }(DefaultRenderer);
  var TextRenderer = /* @__PURE__ */ function(_DefaultRenderer) {
    function TextRenderer2() {
      _classCallCheck(this, TextRenderer2);
      return _callSuper(this, TextRenderer2, arguments);
    }
    _inherits(TextRenderer2, _DefaultRenderer);
    return _createClass(TextRenderer2, [{
      key: "render",
      value: function render2(context, parsedStyle, object, canvasContext, plugin, runtime2) {
        object.getBounds();
        var _parsedStyle$lineWidt = parsedStyle.lineWidth, lineWidth = _parsedStyle$lineWidt === void 0 ? 1 : _parsedStyle$lineWidt, _parsedStyle$textAlig = parsedStyle.textAlign, textAlign = _parsedStyle$textAlig === void 0 ? "start" : _parsedStyle$textAlig, _parsedStyle$textBase = parsedStyle.textBaseline, textBaseline = _parsedStyle$textBase === void 0 ? "alphabetic" : _parsedStyle$textBase, _parsedStyle$lineJoin = parsedStyle.lineJoin, lineJoin = _parsedStyle$lineJoin === void 0 ? "miter" : _parsedStyle$lineJoin, _parsedStyle$miterLim = parsedStyle.miterLimit, miterLimit = _parsedStyle$miterLim === void 0 ? 10 : _parsedStyle$miterLim, _parsedStyle$letterSp = parsedStyle.letterSpacing, letterSpacing = _parsedStyle$letterSp === void 0 ? 0 : _parsedStyle$letterSp, stroke2 = parsedStyle.stroke, fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, _parsedStyle$fillOpac = parsedStyle.fillOpacity, fillOpacity = _parsedStyle$fillOpac === void 0 ? 1 : _parsedStyle$fillOpac, _parsedStyle$strokeOp = parsedStyle.strokeOpacity, strokeOpacity = _parsedStyle$strokeOp === void 0 ? 1 : _parsedStyle$strokeOp, _parsedStyle$opacity = parsedStyle.opacity, opacity = _parsedStyle$opacity === void 0 ? 1 : _parsedStyle$opacity, metrics = parsedStyle.metrics, _parsedStyle$x = parsedStyle.x, x3 = _parsedStyle$x === void 0 ? 0 : _parsedStyle$x, _parsedStyle$y = parsedStyle.y, y3 = _parsedStyle$y === void 0 ? 0 : _parsedStyle$y, dx = parsedStyle.dx, dy = parsedStyle.dy, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
        var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight = metrics.lineHeight, lineMetrics = metrics.lineMetrics;
        context.font = font;
        context.lineWidth = lineWidth;
        context.textAlign = textAlign === "middle" ? "center" : textAlign;
        var formattedTextBaseline = textBaseline;
        if (formattedTextBaseline === "alphabetic") {
          formattedTextBaseline = "bottom";
        }
        context.lineJoin = lineJoin;
        if (!isNil(miterLimit)) {
          context.miterLimit = miterLimit;
        }
        var linePositionY = y3;
        if (textBaseline === "middle") {
          linePositionY += -height / 2 - lineHeight / 2;
        } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
          linePositionY += -height;
        } else if (textBaseline === "top" || textBaseline === "hanging") {
          linePositionY += -lineHeight;
        }
        var offsetX = x3 + (dx || 0);
        linePositionY += dy || 0;
        if (lines.length === 1) {
          if (formattedTextBaseline === "bottom") {
            formattedTextBaseline = "middle";
            linePositionY -= 0.5 * height;
          } else if (formattedTextBaseline === "top") {
            formattedTextBaseline = "middle";
            linePositionY += 0.5 * height;
          }
        }
        context.textBaseline = formattedTextBaseline;
        var hasShadow = !isNil(shadowColor) && shadowBlur > 0;
        setShadowAndFilter(object, context, hasShadow);
        for (var i = 0; i < lines.length; i++) {
          var linePositionX = lineWidth / 2 + offsetX;
          linePositionY += lineHeight;
          if (!isNil(stroke2) && !stroke2.isNone && lineWidth) {
            this.drawLetterSpacing(context, object, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke2, strokeOpacity, opacity, true, canvasContext, plugin, runtime2);
          }
          if (!isNil(fill)) {
            this.drawLetterSpacing(context, object, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke2, strokeOpacity, opacity, false, canvasContext, plugin, runtime2);
          }
        }
      }
    }, {
      key: "drawLetterSpacing",
      value: function drawLetterSpacing(context, object, text, lineMetrics, textAlign, x3, y3, letterSpacing, fill, fillRule, fillOpacity, stroke2, strokeOpacity, opacity, isStroke, canvasContext, plugin, runtime2) {
        if (letterSpacing === 0) {
          if (isStroke) {
            this.strokeText(context, object, text, x3, y3, stroke2, strokeOpacity, canvasContext, plugin, runtime2);
          } else {
            this.fillText(context, object, text, x3, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2);
          }
          return;
        }
        var currentTextAlign = context.textAlign;
        context.textAlign = "left";
        var currentPosition = x3;
        if (textAlign === "center" || textAlign === "middle") {
          currentPosition = x3 - lineMetrics.width / 2;
        } else if (textAlign === "right" || textAlign === "end") {
          currentPosition = x3 - lineMetrics.width;
        }
        var stringArray = Array.from(text);
        var previousWidth = context.measureText(text).width;
        var currentWidth = 0;
        for (var i = 0; i < stringArray.length; ++i) {
          var currentChar = stringArray[i];
          if (isStroke) {
            this.strokeText(context, object, currentChar, currentPosition, y3, stroke2, strokeOpacity, canvasContext, plugin, runtime2);
          } else {
            this.fillText(context, object, currentChar, currentPosition, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2);
          }
          currentWidth = context.measureText(text.substring(i + 1)).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
        context.textAlign = currentTextAlign;
      }
    }, {
      key: "fillText",
      value: function fillText(context, object, text, x3, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2) {
        applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool, true);
        var currentGlobalAlpha;
        var applyOpacity = !isNil(fillOpacity) && fillOpacity !== 1;
        if (applyOpacity) {
          currentGlobalAlpha = context.globalAlpha;
          context.globalAlpha = fillOpacity * opacity;
        }
        context.fillText(text, x3, y3);
        if (applyOpacity) {
          context.globalAlpha = currentGlobalAlpha;
        }
      }
    }, {
      key: "strokeText",
      value: function strokeText(context, object, text, x3, y3, stroke2, strokeOpacity, canvasContext, plugin, runtime2) {
        applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, this.imagePool, true);
        var currentGlobalAlpha;
        var applyOpacity = !isNil(strokeOpacity) && strokeOpacity !== 1;
        if (applyOpacity) {
          currentGlobalAlpha = context.globalAlpha;
          context.globalAlpha = strokeOpacity;
        }
        context.strokeText(text, x3, y3);
        if (applyOpacity) {
          context.globalAlpha = currentGlobalAlpha;
        }
      }
      // ---
    }, {
      key: "drawToContext",
      value: function drawToContext(context, object, renderState, plugin, runtime2) {
        this.render(context, object.parsedStyle, object, object.ownerDocument.defaultView.context, plugin, runtime2);
      }
    }]);
  }(DefaultRenderer);
  var Plugin4 = /* @__PURE__ */ function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Plugin8);
      _this = _callSuper(this, Plugin8);
      _this.name = "canvas-renderer";
      _this.options = options;
      return _this;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init() {
        var _defaultStyleRenderer;
        var canvasRendererPluginOptions = _objectSpread22({
          dirtyObjectNumThreshold: 500,
          dirtyObjectRatioThreshold: 0.8
        }, this.options);
        var imagePool = this.context.imagePool;
        var defaultRenderer = new DefaultRenderer(imagePool);
        var defaultStyleRendererFactory = (_defaultStyleRenderer = {}, _defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defineProperty2(_defaultStyleRenderer, Shape.CIRCLE, defaultRenderer), Shape.ELLIPSE, defaultRenderer), Shape.RECT, defaultRenderer), Shape.IMAGE, new ImageRenderer(imagePool)), Shape.TEXT, new TextRenderer(imagePool)), Shape.LINE, defaultRenderer), Shape.POLYLINE, defaultRenderer), Shape.POLYGON, defaultRenderer), Shape.PATH, defaultRenderer), Shape.GROUP, void 0), _defineProperty2(_defineProperty2(_defineProperty2(_defaultStyleRenderer, Shape.HTML, void 0), Shape.MESH, void 0), Shape.FRAGMENT, void 0));
        this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;
        this.context.styleRendererFactory = defaultStyleRendererFactory;
        this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        this.removeAllRenderingPlugins();
        delete this.context.defaultStyleRendererFactory;
        delete this.context.styleRendererFactory;
      }
    }]);
  }(AbstractRendererPlugin);

  // node_modules/@antv/g-plugin-dom-interaction/dist/index.esm.js
  var DOMInteractionPlugin = /* @__PURE__ */ function() {
    function DOMInteractionPlugin2() {
      _classCallCheck(this, DOMInteractionPlugin2);
    }
    return _createClass(DOMInteractionPlugin2, [{
      key: "apply",
      value: function apply(context, runtime2) {
        var _this = this;
        var renderingService = context.renderingService, renderingContext = context.renderingContext, config2 = context.config;
        this.context = context;
        var canvas = renderingContext.root.ownerDocument.defaultView;
        var onPointerMove = function onPointerMove2(ev) {
          renderingService.hooks.pointerMove.call(ev);
        };
        var onPointerUp = function onPointerUp2(ev) {
          renderingService.hooks.pointerUp.call(ev);
        };
        var onPointerDown = function onPointerDown2(ev) {
          renderingService.hooks.pointerDown.call(ev);
        };
        var onPointerOver = function onPointerOver2(ev) {
          renderingService.hooks.pointerOver.call(ev);
        };
        var onPointerOut = function onPointerOut2(ev) {
          renderingService.hooks.pointerOut.call(ev);
        };
        var onPointerCancel = function onPointerCancel2(ev) {
          renderingService.hooks.pointerCancel.call(ev);
        };
        var onPointerWheel = function onPointerWheel2(ev) {
          renderingService.hooks.pointerWheel.call(ev);
        };
        var onClick = function onClick2(ev) {
          renderingService.hooks.click.call(ev);
        };
        var addPointerEventListener = function addPointerEventListener2($el) {
          runtime2.globalThis.document.addEventListener("pointermove", onPointerMove, true);
          $el.addEventListener("pointerdown", onPointerDown, true);
          $el.addEventListener("pointerleave", onPointerOut, true);
          $el.addEventListener("pointerover", onPointerOver, true);
          runtime2.globalThis.addEventListener("pointerup", onPointerUp, true);
          runtime2.globalThis.addEventListener("pointercancel", onPointerCancel, true);
        };
        var addTouchEventListener = function addTouchEventListener2($el) {
          $el.addEventListener("touchstart", onPointerDown, true);
          $el.addEventListener("touchend", onPointerUp, true);
          $el.addEventListener("touchmove", onPointerMove, true);
          $el.addEventListener("touchcancel", onPointerCancel, true);
        };
        var addMouseEventListener = function addMouseEventListener2($el) {
          runtime2.globalThis.document.addEventListener("mousemove", onPointerMove, true);
          $el.addEventListener("mousedown", onPointerDown, true);
          $el.addEventListener("mouseout", onPointerOut, true);
          $el.addEventListener("mouseover", onPointerOver, true);
          runtime2.globalThis.addEventListener("mouseup", onPointerUp, true);
        };
        var removePointerEventListener = function removePointerEventListener2($el) {
          runtime2.globalThis.document.removeEventListener("pointermove", onPointerMove, true);
          $el.removeEventListener("pointerdown", onPointerDown, true);
          $el.removeEventListener("pointerleave", onPointerOut, true);
          $el.removeEventListener("pointerover", onPointerOver, true);
          runtime2.globalThis.removeEventListener("pointerup", onPointerUp, true);
          runtime2.globalThis.removeEventListener("pointercancel", onPointerCancel, true);
        };
        var removeTouchEventListener = function removeTouchEventListener2($el) {
          $el.removeEventListener("touchstart", onPointerDown, true);
          $el.removeEventListener("touchend", onPointerUp, true);
          $el.removeEventListener("touchmove", onPointerMove, true);
          $el.removeEventListener("touchcancel", onPointerCancel, true);
        };
        var removeMouseEventListener = function removeMouseEventListener2($el) {
          runtime2.globalThis.document.removeEventListener("mousemove", onPointerMove, true);
          $el.removeEventListener("mousedown", onPointerDown, true);
          $el.removeEventListener("mouseout", onPointerOut, true);
          $el.removeEventListener("mouseover", onPointerOver, true);
          runtime2.globalThis.removeEventListener("mouseup", onPointerUp, true);
        };
        renderingService.hooks.init.tap(DOMInteractionPlugin2.tag, function() {
          var $el = _this.context.contextService.getDomElement();
          if (runtime2.globalThis.navigator.msPointerEnabled) {
            $el.style.msContentZooming = "none";
            $el.style.msTouchAction = "none";
          } else if (canvas.supportsPointerEvents) {
            $el.style.touchAction = "none";
          }
          if (canvas.supportsPointerEvents) {
            addPointerEventListener($el);
          } else {
            addMouseEventListener($el);
          }
          if (canvas.supportsTouchEvents) {
            addTouchEventListener($el);
          }
          if (config2.useNativeClickEvent) {
            $el.addEventListener("click", onClick, true);
          }
          $el.addEventListener("wheel", onPointerWheel, {
            passive: true,
            capture: true
          });
        });
        renderingService.hooks.destroy.tap(DOMInteractionPlugin2.tag, function() {
          var $el = _this.context.contextService.getDomElement();
          if (runtime2.globalThis.navigator.msPointerEnabled) {
            $el.style.msContentZooming = "";
            $el.style.msTouchAction = "";
          } else if (canvas.supportsPointerEvents) {
            $el.style.touchAction = "";
          }
          if (canvas.supportsPointerEvents) {
            removePointerEventListener($el);
          } else {
            removeMouseEventListener($el);
          }
          if (canvas.supportsTouchEvents) {
            removeTouchEventListener($el);
          }
          if (config2.useNativeClickEvent) {
            $el.removeEventListener("click", onClick, true);
          }
          $el.removeEventListener("wheel", onPointerWheel, true);
        });
      }
    }]);
  }();
  DOMInteractionPlugin.tag = "DOMInteraction";
  var Plugin5 = /* @__PURE__ */ function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this;
      _classCallCheck(this, Plugin8);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, Plugin8, [].concat(args));
      _this.name = "dom-interaction";
      return _this;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init() {
        this.addRenderingPlugin(new DOMInteractionPlugin());
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        this.removeAllRenderingPlugins();
      }
    }]);
  }(AbstractRendererPlugin);

  // node_modules/@antv/g-plugin-html-renderer/dist/index.esm.js
  var CANVAS_CAMERA_ID = "g-canvas-camera";
  var HTMLRenderingPlugin = /* @__PURE__ */ function() {
    function HTMLRenderingPlugin2() {
      _classCallCheck(this, HTMLRenderingPlugin2);
      this.displayObjectHTMLElementMap = /* @__PURE__ */ new WeakMap();
    }
    return _createClass(HTMLRenderingPlugin2, [{
      key: "joinTransformMatrix",
      value: (
        /**
         * ! The reason for adding `offset` is that the `transform-origin` coordinate system of DOM is the local coordinate system of the element, while the `transform-origin` coordinate system of canvas drawing is the local coordinate system of the element's parent element. At the same time, the `transform` attribute value of the DOM element does not include `transform-origin`.
         */
        function joinTransformMatrix(matrix3) {
          var offset3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [0, 0, 0];
          return "matrix(".concat([matrix3[0], matrix3[1], matrix3[4], matrix3[5], matrix3[12] + offset3[0], matrix3[13] + offset3[1]].join(","), ")");
        }
      )
    }, {
      key: "apply",
      value: function apply(context, runtime2) {
        var _this = this;
        var camera = context.camera, renderingContext = context.renderingContext, renderingService = context.renderingService;
        this.context = context;
        var canvas = renderingContext.root.ownerDocument.defaultView;
        var nativeHTMLMap = canvas.context.eventService.nativeHTMLMap;
        var setTransform = function setTransform2(object, $el) {
          $el.style.transform = _this.joinTransformMatrix(object.getWorldTransform(), object.getOrigin());
        };
        var handleMounted = function handleMounted2(e3) {
          var object = e3.target;
          if (object.nodeName === Shape.HTML) {
            if (!_this.$camera) {
              _this.$camera = _this.createCamera(camera);
            }
            var $el = _this.getOrCreateEl(object);
            _this.$camera.appendChild($el);
            Object.keys(object.attributes).forEach(function(name2) {
              _this.updateAttribute(name2, object);
            });
            setTransform(object, $el);
            nativeHTMLMap.set($el, object);
          }
        };
        var handleUnmounted = function handleUnmounted2(e3) {
          var object = e3.target;
          if (object.nodeName === Shape.HTML && _this.$camera) {
            var $el = _this.getOrCreateEl(object);
            if ($el) {
              $el.remove();
              nativeHTMLMap["delete"]($el);
            }
          }
        };
        var handleAttributeChanged = function handleAttributeChanged2(e3) {
          var object = e3.target;
          if (object.nodeName === Shape.HTML) {
            var attrName = e3.attrName;
            _this.updateAttribute(attrName, object);
          }
        };
        var handleBoundsChanged = function handleBoundsChanged2(e3) {
          var object = e3.target;
          var nodes = object.nodeName === Shape.FRAGMENT ? object.childNodes : [object];
          nodes.forEach(function(node) {
            if (node.nodeName === Shape.HTML) {
              var $el = _this.getOrCreateEl(node);
              setTransform(node, $el);
            }
          });
        };
        var handleCanvasResize = function handleCanvasResize2() {
          if (_this.$camera) {
            var _this$context$config = _this.context.config, width = _this$context$config.width, height = _this$context$config.height;
            _this.$camera.parentElement.style.width = "".concat(width || 0, "px");
            _this.$camera.parentElement.style.height = "".concat(height || 0, "px");
          }
        };
        renderingService.hooks.init.tap(HTMLRenderingPlugin2.tag, function() {
          canvas.addEventListener(CanvasEvent.RESIZE, handleCanvasResize);
          canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
          canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        });
        renderingService.hooks.endFrame.tap(HTMLRenderingPlugin2.tag, function() {
          if (_this.$camera && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED)) {
            _this.$camera.style.transform = _this.joinTransformMatrix(camera.getOrthoMatrix());
          }
        });
        renderingService.hooks.destroy.tap(HTMLRenderingPlugin2.tag, function() {
          if (_this.$camera) {
            _this.$camera.remove();
          }
          canvas.removeEventListener(CanvasEvent.RESIZE, handleCanvasResize);
          canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
          canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        });
      }
    }, {
      key: "createCamera",
      value: function createCamera(camera) {
        var _this$context$config2 = this.context.config, doc = _this$context$config2.document, width = _this$context$config2.width, height = _this$context$config2.height;
        var $canvas = this.context.contextService.getDomElement();
        var $container = $canvas.parentNode;
        if ($container) {
          var cameraId = CANVAS_CAMERA_ID;
          var $existedCamera = $container.querySelector("#".concat(cameraId));
          if (!$existedCamera) {
            var $cameraContainer = (doc || document).createElement("div");
            $cameraContainer.style.overflow = "hidden";
            $cameraContainer.style.pointerEvents = "none";
            $cameraContainer.style.position = "absolute";
            $cameraContainer.style.left = "0px";
            $cameraContainer.style.top = "0px";
            $cameraContainer.style.width = "".concat(width || 0, "px");
            $cameraContainer.style.height = "".concat(height || 0, "px");
            var $camera = (doc || document).createElement("div");
            $existedCamera = $camera;
            $camera.id = cameraId;
            $camera.style.position = "absolute";
            $camera.style.left = "".concat($canvas.offsetLeft || 0, "px");
            $camera.style.top = "".concat($canvas.offsetTop || 0, "px");
            $camera.style.transformOrigin = "left top";
            $camera.style.transform = this.joinTransformMatrix(camera.getOrthoMatrix());
            $camera.style.pointerEvents = "none";
            $camera.style.width = "100%";
            $camera.style.height = "100%";
            $cameraContainer.appendChild($camera);
            $container.appendChild($cameraContainer);
          }
          return $existedCamera;
        }
        return null;
      }
    }, {
      key: "getOrCreateEl",
      value: function getOrCreateEl(object) {
        var doc = this.context.config.document;
        var $existedElement = this.displayObjectHTMLElementMap.get(object);
        if (!$existedElement) {
          $existedElement = (doc || document).createElement("div");
          object.parsedStyle.$el = $existedElement;
          this.displayObjectHTMLElementMap.set(object, $existedElement);
          if (object.id) {
            $existedElement.id = object.id;
          }
          if (object.name) {
            $existedElement.setAttribute("name", object.name);
          }
          if (object.className) {
            $existedElement.className = object.className;
          }
          $existedElement.style.position = "absolute";
          $existedElement.style["will-change"] = "transform";
          $existedElement.style.transform = this.joinTransformMatrix(object.getWorldTransform(), object.getOrigin());
        }
        return $existedElement;
      }
    }, {
      key: "updateAttribute",
      value: function updateAttribute(name2, object) {
        var $el = this.getOrCreateEl(object);
        switch (name2) {
          case "innerHTML":
            var innerHTML = object.parsedStyle.innerHTML;
            if (isString2(innerHTML)) {
              $el.innerHTML = innerHTML;
            } else {
              $el.innerHTML = "";
              $el.appendChild(innerHTML);
            }
            break;
          case "x":
            $el.style.left = "".concat(object.parsedStyle.x, "px");
            break;
          case "y":
            $el.style.top = "".concat(object.parsedStyle.y, "px");
            break;
          case "transformOrigin":
            var transformOrigin = object.parsedStyle.transformOrigin;
            $el.style["transform-origin"] = "".concat(transformOrigin[0].buildCSSText(null, null, ""), " ").concat(transformOrigin[1].buildCSSText(null, null, ""));
            break;
          case "width":
            var width = object.parsedStyle.width;
            $el.style.width = isNumber2(width) ? "".concat(width, "px") : width.toString();
            break;
          case "height":
            var height = object.parsedStyle.height;
            $el.style.height = isNumber2(height) ? "".concat(height, "px") : height.toString();
            break;
          case "zIndex":
            var zIndex = object.parsedStyle.zIndex;
            $el.style["z-index"] = "".concat(zIndex);
            break;
          case "visibility":
            var visibility2 = object.parsedStyle.visibility;
            $el.style.visibility = visibility2;
            break;
          case "pointerEvents":
            var _object$parsedStyle$p = object.parsedStyle.pointerEvents, pointerEvents = _object$parsedStyle$p === void 0 ? "auto" : _object$parsedStyle$p;
            $el.style.pointerEvents = pointerEvents;
            break;
          case "opacity":
            var opacity = object.parsedStyle.opacity;
            $el.style.opacity = "".concat(opacity);
            break;
          case "fill":
            var fill = object.parsedStyle.fill;
            var color2 = "";
            if (isCSSRGB(fill)) {
              if (fill.isNone) {
                color2 = "transparent";
              } else {
                color2 = object.getAttribute("fill");
              }
            } else if (Array.isArray(fill)) {
              color2 = object.getAttribute("fill");
            } else if (isPattern(fill)) ;
            $el.style.background = color2;
            break;
          case "stroke":
            var stroke2 = object.parsedStyle.stroke;
            var borderColor = "";
            if (isCSSRGB(stroke2)) {
              if (stroke2.isNone) {
                borderColor = "transparent";
              } else {
                borderColor = object.getAttribute("stroke");
              }
            } else if (Array.isArray(stroke2)) {
              borderColor = object.getAttribute("stroke");
            } else if (isPattern(stroke2)) ;
            $el.style["border-color"] = borderColor;
            $el.style["border-style"] = "solid";
            break;
          case "lineWidth":
            var lineWidth = object.parsedStyle.lineWidth;
            $el.style["border-width"] = "".concat(lineWidth || 0, "px");
            break;
          case "lineDash":
            $el.style["border-style"] = "dashed";
            break;
          case "filter":
            var filter2 = object.style.filter;
            $el.style.filter = filter2;
            break;
          default:
            if (!isNil(object.style[name2]) && object.style[name2] !== "") {
              $el.style[name2] = object.style[name2];
            }
        }
      }
    }]);
  }();
  HTMLRenderingPlugin.tag = "HTMLRendering";
  var Plugin6 = /* @__PURE__ */ function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this;
      _classCallCheck(this, Plugin8);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, Plugin8, [].concat(args));
      _this.name = "html-renderer";
      return _this;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init() {
        this.addRenderingPlugin(new HTMLRenderingPlugin());
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        this.removeAllRenderingPlugins();
      }
    }]);
  }(AbstractRendererPlugin);

  // node_modules/@antv/g-canvas/dist/index.esm.js
  var Canvas2DContextService = /* @__PURE__ */ function() {
    function Canvas2DContextService2(context) {
      _classCallCheck(this, Canvas2DContextService2);
      this.renderingContext = context.renderingContext;
      this.canvasConfig = context.config;
    }
    return _createClass(Canvas2DContextService2, [{
      key: "init",
      value: function init() {
        var _this$canvasConfig = this.canvasConfig, container = _this$canvasConfig.container, canvas = _this$canvasConfig.canvas;
        if (canvas) {
          this.$canvas = canvas;
          if (container && canvas.parentElement !== container) {
            container.appendChild(canvas);
          }
          this.$container = canvas.parentElement;
          this.canvasConfig.container = this.$container;
        } else if (container) {
          this.$container = isString2(container) ? document.getElementById(container) : container;
          if (this.$container) {
            var $canvas = document.createElement("canvas");
            this.$container.appendChild($canvas);
            if (!this.$container.style.position) {
              this.$container.style.position = "relative";
            }
            this.$canvas = $canvas;
          }
        }
        this.context = this.$canvas.getContext("2d");
        this.resize(this.canvasConfig.width, this.canvasConfig.height);
      }
    }, {
      key: "getContext",
      value: function getContext() {
        return this.context;
      }
    }, {
      key: "getDomElement",
      value: function getDomElement() {
        return this.$canvas;
      }
    }, {
      key: "getDPR",
      value: function getDPR() {
        return this.dpr;
      }
    }, {
      key: "getBoundingClientRect",
      value: function getBoundingClientRect() {
        if (this.$canvas.getBoundingClientRect) {
          return this.$canvas.getBoundingClientRect();
        }
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        if (this.$container && this.$canvas && this.$canvas.parentNode) {
          this.$container.removeChild(this.$canvas);
        }
      }
    }, {
      key: "resize",
      value: function resize(width, height) {
        var dpr = this.canvasConfig.devicePixelRatio;
        this.dpr = dpr;
        if (this.$canvas) {
          this.$canvas.width = this.dpr * width;
          this.$canvas.height = this.dpr * height;
          setDOMSize(this.$canvas, width, height);
        }
        this.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
      }
    }, {
      key: "applyCursorStyle",
      value: function applyCursorStyle(cursor) {
        if (this.$container && this.$container.style) {
          this.$container.style.cursor = cursor;
        }
      }
    }, {
      key: "toDataURL",
      value: function() {
        var _toDataURL = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee() {
          var options, type, encoderOptions, _args = arguments;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                options = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {};
                type = options.type, encoderOptions = options.encoderOptions;
                return _context.abrupt("return", this.context.canvas.toDataURL(type, encoderOptions));
              case 3:
              case "end":
                return _context.stop();
            }
          }, _callee, this);
        }));
        function toDataURL() {
          return _toDataURL.apply(this, arguments);
        }
        return toDataURL;
      }()
    }]);
  }();
  var ContextRegisterPlugin = /* @__PURE__ */ function(_AbstractRendererPlug) {
    function ContextRegisterPlugin2() {
      var _this;
      _classCallCheck(this, ContextRegisterPlugin2);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, ContextRegisterPlugin2, [].concat(args));
      _this.name = "canvas-context-register";
      return _this;
    }
    _inherits(ContextRegisterPlugin2, _AbstractRendererPlug);
    return _createClass(ContextRegisterPlugin2, [{
      key: "init",
      value: function init() {
        this.context.ContextService = Canvas2DContextService;
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        delete this.context.ContextService;
      }
    }]);
  }(AbstractRendererPlugin);
  var Renderer2 = /* @__PURE__ */ function(_AbstractRenderer) {
    function Renderer3(config2) {
      var _this;
      _classCallCheck(this, Renderer3);
      _this = _callSuper(this, Renderer3, [config2]);
      _this.registerPlugin(new ContextRegisterPlugin());
      _this.registerPlugin(new Plugin3());
      _this.registerPlugin(new Plugin());
      _this.registerPlugin(new Plugin4());
      _this.registerPlugin(new Plugin5());
      _this.registerPlugin(new Plugin2());
      _this.registerPlugin(new Plugin6());
      return _this;
    }
    _inherits(Renderer3, _AbstractRenderer);
    return _createClass(Renderer3);
  }(AbstractRenderer);

  // node_modules/@antv/g-plugin-dragndrop/dist/index.esm.js
  var DragndropPlugin = /* @__PURE__ */ function() {
    function DragndropPlugin2(dragndropPluginOptions) {
      _classCallCheck(this, DragndropPlugin2);
      this.dragndropPluginOptions = dragndropPluginOptions;
    }
    return _createClass(DragndropPlugin2, [{
      key: "apply",
      value: function apply(context) {
        var _this = this;
        var renderingService = context.renderingService, renderingContext = context.renderingContext;
        var document2 = renderingContext.root.ownerDocument;
        var canvas = document2.defaultView;
        var handlePointerdown = function handlePointerdown2(event) {
          var target = event.target;
          var isDocument = target === document2;
          var draggableEventTarget = isDocument && _this.dragndropPluginOptions.isDocumentDraggable ? document2 : target.closest && target.closest("[draggable=true]");
          if (draggableEventTarget) {
            var dragstartTriggered = false;
            var dragstartTimeStamp = event.timeStamp;
            var dragstartClientCoordinates = [event.clientX, event.clientY];
            var currentDroppable = null;
            var lastDragClientCoordinates = [event.clientX, event.clientY];
            var handlePointermove = /* @__PURE__ */ function() {
              var _ref = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(event2) {
                var timeElapsed, distanceMoved, point6, elementsBelow, elementBelow, droppableBelow;
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) switch (_context.prev = _context.next) {
                    case 0:
                      if (dragstartTriggered) {
                        _context.next = 8;
                        break;
                      }
                      timeElapsed = event2.timeStamp - dragstartTimeStamp;
                      distanceMoved = distanceSquareRoot([event2.clientX, event2.clientY], dragstartClientCoordinates);
                      if (!(timeElapsed <= _this.dragndropPluginOptions.dragstartTimeThreshold || distanceMoved <= _this.dragndropPluginOptions.dragstartDistanceThreshold)) {
                        _context.next = 5;
                        break;
                      }
                      return _context.abrupt("return");
                    case 5:
                      event2.type = "dragstart";
                      draggableEventTarget.dispatchEvent(event2);
                      dragstartTriggered = true;
                    case 8:
                      event2.type = "drag";
                      event2.dx = event2.clientX - lastDragClientCoordinates[0];
                      event2.dy = event2.clientY - lastDragClientCoordinates[1];
                      draggableEventTarget.dispatchEvent(event2);
                      lastDragClientCoordinates = [event2.clientX, event2.clientY];
                      if (isDocument) {
                        _context.next = 21;
                        break;
                      }
                      point6 = _this.dragndropPluginOptions.overlap === "pointer" ? [event2.canvasX, event2.canvasY] : target.getBounds().center;
                      _context.next = 17;
                      return document2.elementsFromPoint(point6[0], point6[1]);
                    case 17:
                      elementsBelow = _context.sent;
                      elementBelow = elementsBelow[elementsBelow.indexOf(target) + 1];
                      droppableBelow = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.closest("[droppable=true]")) || (_this.dragndropPluginOptions.isDocumentDroppable ? document2 : null);
                      if (currentDroppable !== droppableBelow) {
                        if (currentDroppable) {
                          event2.type = "dragleave";
                          event2.target = currentDroppable;
                          currentDroppable.dispatchEvent(event2);
                        }
                        if (droppableBelow) {
                          event2.type = "dragenter";
                          event2.target = droppableBelow;
                          droppableBelow.dispatchEvent(event2);
                        }
                        currentDroppable = droppableBelow;
                        if (currentDroppable) {
                          event2.type = "dragover";
                          event2.target = currentDroppable;
                          currentDroppable.dispatchEvent(event2);
                        }
                      }
                    case 21:
                    case "end":
                      return _context.stop();
                  }
                }, _callee);
              }));
              return function handlePointermove2(_x) {
                return _ref.apply(this, arguments);
              };
            }();
            canvas.addEventListener("pointermove", handlePointermove);
            var stopDragging = function stopDragging2(originalPointerUpEvent) {
              if (dragstartTriggered) {
                originalPointerUpEvent.detail = {
                  preventClick: true
                };
                var _event = originalPointerUpEvent.clone();
                if (currentDroppable) {
                  _event.type = "drop";
                  _event.target = currentDroppable;
                  currentDroppable.dispatchEvent(_event);
                }
                _event.type = "dragend";
                draggableEventTarget.dispatchEvent(_event);
                dragstartTriggered = false;
              }
              canvas.removeEventListener("pointermove", handlePointermove);
            };
            target.addEventListener("pointerup", stopDragging, {
              once: true
            });
            target.addEventListener("pointerupoutside", stopDragging, {
              once: true
            });
          }
        };
        renderingService.hooks.init.tap(DragndropPlugin2.tag, function() {
          canvas.addEventListener("pointerdown", handlePointerdown);
        });
        renderingService.hooks.destroy.tap(DragndropPlugin2.tag, function() {
          canvas.removeEventListener("pointerdown", handlePointerdown);
        });
      }
    }]);
  }();
  DragndropPlugin.tag = "Dragndrop";
  var Plugin7 = /* @__PURE__ */ function(_AbstractRendererPlug) {
    function Plugin8() {
      var _this;
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _classCallCheck(this, Plugin8);
      _this = _callSuper(this, Plugin8);
      _this.name = "dragndrop";
      _this.options = options;
      return _this;
    }
    _inherits(Plugin8, _AbstractRendererPlug);
    return _createClass(Plugin8, [{
      key: "init",
      value: function init() {
        this.addRenderingPlugin(new DragndropPlugin(_objectSpread22({
          overlap: "pointer",
          isDocumentDraggable: false,
          isDocumentDroppable: false,
          dragstartDistanceThreshold: 0,
          dragstartTimeThreshold: 0
        }, this.options)));
      }
    }, {
      key: "destroy",
      value: function destroy3() {
        this.removeAllRenderingPlugins();
      }
    }, {
      key: "setOptions",
      value: function setOptions(options) {
        Object.assign(this.plugins[0].dragndropPluginOptions, options);
      }
    }]);
  }(AbstractRendererPlugin);

  // node_modules/@antv/event-emitter/esm/index.js
  var WILDCARD = "*";
  var EventEmitter2 = (
    /** @class */
    function() {
      function EventEmitter3() {
        this._events = {};
      }
      EventEmitter3.prototype.on = function(evt, callback, once) {
        if (!this._events[evt]) {
          this._events[evt] = [];
        }
        this._events[evt].push({
          callback,
          once: !!once
        });
        return this;
      };
      EventEmitter3.prototype.once = function(evt, callback) {
        return this.on(evt, callback, true);
      };
      EventEmitter3.prototype.emit = function(evt) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var events = this._events[evt] || [];
        var wildcardEvents = this._events[WILDCARD] || [];
        var doEmit = function(es) {
          var length5 = es.length;
          for (var i = 0; i < length5; i++) {
            if (!es[i]) {
              continue;
            }
            var _a = es[i], callback = _a.callback, once = _a.once;
            if (once) {
              es.splice(i, 1);
              if (es.length === 0) {
                delete _this._events[evt];
              }
              length5--;
              i--;
            }
            callback.apply(_this, args);
          }
        };
        doEmit(events);
        doEmit(wildcardEvents);
      };
      EventEmitter3.prototype.off = function(evt, callback) {
        if (!evt) {
          this._events = {};
        } else {
          if (!callback) {
            delete this._events[evt];
          } else {
            var events = this._events[evt] || [];
            var length_1 = events.length;
            for (var i = 0; i < length_1; i++) {
              if (events[i].callback === callback) {
                events.splice(i, 1);
                length_1--;
                i--;
              }
            }
            if (events.length === 0) {
              delete this._events[evt];
            }
          }
        }
        return this;
      };
      EventEmitter3.prototype.getEvents = function() {
        return this._events;
      };
      return EventEmitter3;
    }()
  );
  var esm_default = EventEmitter2;

  // node_modules/@antv/g2/esm/utils/event.js
  var ChartEvent = {
    BEFORE_RENDER: "beforerender",
    AFTER_RENDER: "afterrender",
    BEFORE_PAINT: "beforepaint",
    AFTER_PAINT: "afterpaint",
    BEFORE_CHANGE_DATA: "beforechangedata",
    AFTER_CHANGE_DATA: "afterchangedata",
    BEFORE_CLEAR: "beforeclear",
    AFTER_CLEAR: "afterclear",
    BEFORE_DESTROY: "beforedestroy",
    AFTER_DESTROY: "afterdestroy",
    BEFORE_CHANGE_SIZE: "beforechangesize",
    AFTER_CHANGE_SIZE: "afterchangesize",
    POINTER_TAP: "pointertap",
    POINTER_DOWN: "pointerdown",
    POINTER_UP: "pointerup",
    POINTER_OVER: "pointerover",
    POINTER_OUT: "pointerout",
    POINTER_MOVE: "pointermove",
    POINTER_ENTER: "pointerenter",
    POINTER_LEAVE: "pointerleave",
    POINTER_UPOUTSIDE: "pointerupoutside",
    DRAG_START: "dragstart",
    DRAG: "drag",
    DRAG_END: "dragend",
    DRAG_ENTER: "dragenter",
    DRAG_LEAVE: "dragleave",
    DRAG_OVER: "dragover",
    DROP: "DROP",
    CLICK: "click",
    DBLCLICK: "dblclick"
  };

  // node_modules/@antv/g2/esm/component/constant.js
  var LEGEND_INFER_STRATEGIES = [
    [
      "legendCategory",
      [
        [
          ["color", "discrete"],
          ["opacity", "discrete"],
          ["shape", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "constant"],
          ["shape", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "discrete"],
          ["shape", "constant"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "constant"],
          ["shape", "constant"],
          ["size", "constant"]
        ],
        [
          ["color", "constant"],
          ["opacity", "discrete"],
          ["shape", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "constant"],
          ["opacity", "constant"],
          ["shape", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "constant"],
          ["opacity", "discrete"],
          ["shape", "constant"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["shape", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "discrete"],
          ["shape", "discrete"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "constant"],
          ["shape", "discrete"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "constant"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["shape", "constant"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "discrete"],
          ["shape", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "constant"],
          ["shape", "constant"]
        ],
        [
          ["color", "constant"],
          ["shape", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "constant"],
          ["opacity", "discrete"],
          ["shape", "discrete"]
        ],
        [
          ["color", "constant"],
          ["opacity", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "constant"],
          ["opacity", "constant"],
          ["shape", "discrete"]
        ],
        // [
        //   ['color', 'constant'],
        //   ['opacity', 'constant'],
        //   ['size', 'constant'],
        // ],
        // [
        //   ['color', 'constant'],
        //   ['shape', 'constant'],
        //   ['size', 'constant'],
        // ],
        [
          ["color", "constant"],
          ["opacity", "discrete"],
          ["shape", "constant"]
        ],
        [
          ["color", "discrete"],
          ["shape", "discrete"]
        ],
        [
          ["color", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "discrete"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "constant"]
        ],
        [
          ["color", "discrete"],
          ["shape", "constant"]
        ],
        [
          ["color", "constant"],
          ["shape", "discrete"]
        ],
        [
          ["color", "constant"],
          ["size", "constant"]
        ],
        [
          ["color", "constant"],
          ["opacity", "discrete"]
        ],
        // [
        //   ['color', 'constant'],
        //   ['opacity', 'constant'],
        // ],
        // [
        //   ['color', 'constant'],
        //   ['shape', 'constant'],
        // ],
        [["color", "discrete"]]
        // [['color', 'constant']],
      ]
    ],
    [
      "legendContinuousSize",
      [
        [
          ["color", "continuous"],
          ["opacity", "continuous"],
          ["size", "continuous"]
        ],
        [
          ["color", "constant"],
          ["opacity", "continuous"],
          ["size", "continuous"]
        ],
        [
          ["color", "continuous"],
          ["size", "continuous"]
        ],
        [
          ["color", "constant"],
          ["size", "continuous"]
        ],
        [
          ["size", "continuous"],
          ["opacity", "continuous"]
        ],
        [["size", "continuous"]]
      ]
    ],
    [
      "legendContinuousBlockSize",
      [
        [
          ["color", "distribution"],
          ["opacity", "distribution"],
          ["size", "distribution"]
        ],
        [
          ["color", "distribution"],
          ["size", "distribution"]
        ]
      ]
    ],
    [
      "legendContinuousBlock",
      [
        [
          ["color", "distribution"],
          ["opacity", "continuous"]
        ],
        [["color", "distribution"]]
      ]
    ],
    [
      "legendContinuous",
      [
        [
          ["color", "continuous"],
          ["opacity", "continuous"]
        ],
        [["color", "continuous"]],
        [["opacity", "continuous"]]
      ]
    ]
  ];

  // node_modules/@antv/g2/esm/runtime/coordinate.js
  var import_coord = __toESM(require_coordinate_min());

  // node_modules/@antv/g2/esm/composition/utils.js
  var __rest61 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function useDefaultAdaptor(adaptor2) {
    return (options, ...rest) => deep_mix_default({}, adaptor2(options, ...rest), options);
  }
  function useOverrideAdaptor(adaptor2) {
    return (options, ...rest) => deep_mix_default({}, options, adaptor2(options, ...rest));
  }
  function isObject2(d3) {
    if (d3 instanceof Date)
      return false;
    return typeof d3 === "object";
  }
  function mergeData(dataDescriptor, dataValue) {
    if (!dataDescriptor)
      return dataValue;
    if (Array.isArray(dataDescriptor))
      return dataDescriptor;
    if (isObject2(dataDescriptor)) {
      const { value: value2 = dataValue } = dataDescriptor, rest = __rest61(dataDescriptor, ["value"]);
      return Object.assign(Object.assign({}, rest), { value: value2 });
    }
    return dataDescriptor;
  }

  // node_modules/@antv/g2/esm/composition/spaceLayer.js
  var __rest62 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var SpaceLayer = () => {
    return (options) => {
      const { children } = options;
      if (!Array.isArray(children))
        return [];
      const { x: viewX = 0, y: viewY = 0, width: viewWidth, height: viewHeight, data: layerData } = options;
      return children.map((_a) => {
        var { data: data2, x: x3, y: y3, width, height } = _a, rest = __rest62(_a, ["data", "x", "y", "width", "height"]);
        return Object.assign(Object.assign({}, rest), { data: mergeData(data2, layerData), x: x3 !== null && x3 !== void 0 ? x3 : viewX, y: y3 !== null && y3 !== void 0 ? y3 : viewY, width: width !== null && width !== void 0 ? width : viewWidth, height: height !== null && height !== void 0 ? height : viewHeight });
      });
    };
  };
  SpaceLayer.props = {};

  // node_modules/@antv/g2/esm/composition/spaceFlex.js
  var __rest63 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var SpaceFlex = () => {
    return (options) => {
      const { children } = options;
      if (!Array.isArray(children))
        return [];
      const { direction: direction2 = "row", ratio = children.map(() => 1), padding = 0, data: flexData } = options;
      const [mainStart, mainSize, crossSize, crossStart] = direction2 === "col" ? ["y", "height", "width", "x"] : ["x", "width", "height", "y"];
      const sum3 = ratio.reduce((total, value2) => total + value2);
      const totalSize = options[mainSize] - padding * (children.length - 1);
      const sizes = ratio.map((value2) => totalSize * (value2 / sum3));
      const newChildren = [];
      let next = options[mainStart] || 0;
      for (let i = 0; i < sizes.length; i += 1) {
        const _a = children[i], { data: data2 } = _a, rest = __rest63(_a, ["data"]);
        const newData = mergeData(data2, flexData);
        newChildren.push(Object.assign({ [mainStart]: next, [mainSize]: sizes[i], [crossStart]: options[crossStart] || 0, [crossSize]: options[crossSize], data: newData }, rest));
        next += sizes[i] + padding;
      }
      return newChildren;
    };
  };
  SpaceFlex.props = {};

  // node_modules/@antv/g2/esm/composition/view.js
  var __rest64 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var View2 = () => {
    return (options) => {
      const { children } = options, restOptions = __rest64(options, ["children"]);
      if (!Array.isArray(children))
        return [];
      const { data: viewData, scale: viewScale = {}, axis: viewAxis = {}, legend: viewLegend = {}, encode: viewEncode = {}, transform: viewTransform = [] } = restOptions, rest = __rest64(restOptions, ["data", "scale", "axis", "legend", "encode", "transform"]);
      const marks = children.map((_a) => {
        var { data: data2, scale: scale10 = {}, axis = {}, legend = {}, encode = {}, transform = [] } = _a, rest2 = __rest64(_a, ["data", "scale", "axis", "legend", "encode", "transform"]);
        return Object.assign({ data: mergeData(data2, viewData), scale: deep_mix_default({}, viewScale, scale10), encode: deep_mix_default({}, viewEncode, encode), transform: [...viewTransform, ...transform], axis: axis && viewAxis ? deep_mix_default({}, viewAxis, axis) : false, legend: legend && viewLegend ? deep_mix_default({}, viewLegend, legend) : false }, rest2);
      });
      return [Object.assign(Object.assign({}, rest), { marks, type: "standardView" })];
    };
  };
  View2.props = {};

  // node_modules/@antv/g2/esm/composition/mark.js
  var __rest65 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var Mark = ({ static: isStatic = false } = {}) => {
    return (options) => {
      const { width, height, depth, paddingLeft, paddingRight, paddingTop, paddingBottom, padding, inset, insetLeft, insetTop, insetRight, insetBottom, margin, marginLeft, marginBottom, marginTop, marginRight, data: data2, coordinate, theme, component, interaction, x: x3, y: y3, z, key, frame: frame2, labelTransform, parentKey, clip, viewStyle, title } = options, mark = __rest65(options, ["width", "height", "depth", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "padding", "inset", "insetLeft", "insetTop", "insetRight", "insetBottom", "margin", "marginLeft", "marginBottom", "marginTop", "marginRight", "data", "coordinate", "theme", "component", "interaction", "x", "y", "z", "key", "frame", "labelTransform", "parentKey", "clip", "viewStyle", "title"]);
      return [
        Object.assign(Object.assign({
          type: "standardView",
          x: x3,
          y: y3,
          z,
          key,
          width,
          height,
          depth,
          padding,
          paddingLeft,
          paddingRight,
          paddingTop,
          inset,
          insetLeft,
          insetTop,
          insetRight,
          insetBottom,
          paddingBottom,
          theme,
          coordinate,
          component,
          interaction,
          frame: frame2,
          labelTransform,
          margin,
          marginLeft,
          marginBottom,
          marginTop,
          marginRight,
          parentKey,
          clip,
          style: viewStyle
        }, !isStatic && { title }), { marks: [Object.assign(Object.assign(Object.assign({}, mark), { key: `${key}-0`, data: data2 }), isStatic && { title })] })
      ];
    };
  };
  Mark.props = {};

  // node_modules/@antv/g2/esm/utils/container.js
  var Container = class _Container {
    constructor(x3) {
      this.$value = x3;
    }
    static of(x3) {
      return new _Container(x3);
    }
    call(f, ...rest) {
      return this.$value = f(this.$value, ...rest), this;
    }
    value() {
      return this.$value;
    }
  };

  // node_modules/@antv/g2/esm/composition/facetRect.js
  var __rest66 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var setScale = useDefaultAdaptor((options) => {
    const { encode, data: data2, scale: scale10, shareSize = false } = options;
    const { x: x3, y: y3 } = encode;
    const flexDomain = (encode2, channel) => {
      var _a;
      if (encode2 === void 0 || !shareSize)
        return {};
      const groups2 = group(data2, (d3) => d3[encode2]);
      const domain = ((_a = scale10 === null || scale10 === void 0 ? void 0 : scale10[channel]) === null || _a === void 0 ? void 0 : _a.domain) || Array.from(groups2.keys());
      const flex2 = domain.map((key) => {
        if (!groups2.has(key))
          return 1;
        return groups2.get(key).length;
      });
      return { domain, flex: flex2 };
    };
    return {
      scale: {
        x: Object.assign(Object.assign({ paddingOuter: 0, paddingInner: 0.1, guide: x3 === void 0 ? null : { position: "top" } }, x3 === void 0 && { paddingInner: 0 }), flexDomain(x3, "x")),
        y: Object.assign(Object.assign({ range: [0, 1], paddingOuter: 0, paddingInner: 0.1, guide: y3 === void 0 ? null : { position: "right" } }, y3 === void 0 && { paddingInner: 0 }), flexDomain(y3, "y"))
      }
    };
  });
  var inferColor = useOverrideAdaptor((options) => {
    const { data: data2, scale: scale10, legend } = options;
    const discovered = [options];
    let encodeColor;
    let scaleColor;
    let legendColor;
    while (discovered.length) {
      const node = discovered.shift();
      const { children, encode = {}, scale: scale11 = {}, legend: legend2 = {} } = node;
      const { color: c5 } = encode;
      const { color: cs } = scale11;
      const { color: cl } = legend2;
      if (c5 !== void 0)
        encodeColor = c5;
      if (cs !== void 0)
        scaleColor = cs;
      if (cl !== void 0)
        legendColor = cl;
      if (Array.isArray(children)) {
        discovered.push(...children);
      }
    }
    const domainColor = () => {
      var _a;
      const domain2 = (_a = scale10 === null || scale10 === void 0 ? void 0 : scale10.color) === null || _a === void 0 ? void 0 : _a.domain;
      if (domain2 !== void 0)
        return [domain2];
      if (encodeColor === void 0)
        return [void 0];
      const color2 = typeof encodeColor === "function" ? encodeColor : (d3) => d3[encodeColor];
      const values = data2.map(color2);
      if (values.some((d3) => typeof d3 === "number"))
        return [extent(values)];
      return [Array.from(new Set(values)), "ordinal"];
    };
    const title = typeof encodeColor === "string" ? encodeColor : "";
    const [domain, type] = domainColor();
    return Object.assign({ encode: { color: { type: "column", value: domain !== null && domain !== void 0 ? domain : [] } }, scale: { color: deep_mix_default({}, scaleColor, { domain, type }) } }, legend === void 0 && {
      legend: { color: deep_mix_default({ title }, legendColor) }
    });
  });
  var setAnimation = useDefaultAdaptor(() => ({
    animate: {
      enterType: "fadeIn"
    }
  }));
  var setStyle = useOverrideAdaptor(() => ({
    frame: false,
    encode: {
      shape: "hollow"
    },
    style: {
      lineWidth: 0
    }
  }));
  var toCell = useOverrideAdaptor(() => ({
    type: "cell"
  }));
  var setData = useOverrideAdaptor((options) => {
    const { data: data2 } = options;
    const connector = {
      type: "custom",
      callback: () => {
        const { data: data3, encode } = options;
        const { x: x3, y: y3 } = encode;
        const X = x3 ? Array.from(new Set(data3.map((d3) => d3[x3]))) : [];
        const Y = y3 ? Array.from(new Set(data3.map((d3) => d3[y3]))) : [];
        const cellData = () => {
          if (X.length && Y.length) {
            const cellData2 = [];
            for (const vx of X) {
              for (const vy of Y) {
                cellData2.push({ [x3]: vx, [y3]: vy });
              }
            }
            return cellData2;
          }
          if (X.length)
            return X.map((d3) => ({ [x3]: d3 }));
          if (Y.length)
            return Y.map((d3) => ({ [y3]: d3 }));
        };
        return cellData();
      }
    };
    return {
      data: { type: "inline", value: data2, transform: [connector] }
    };
  });
  var setChildren = useOverrideAdaptor((options, subLayout = subLayoutRect, createGuideX2 = createGuideXRect, createGuideY2 = createGuideYRect, childOptions = {}) => {
    const { data: dataValue, encode, children, scale: facetScale, x: originX = 0, y: originY = 0, shareData = false, key: viewKey } = options;
    const { value: data2 } = dataValue;
    const { x: encodeX, y: encodeY } = encode;
    const { color: facetScaleColor } = facetScale;
    const { domain: facetDomainColor } = facetScaleColor;
    const createChildren = (visualData, scale10, layout) => {
      const { x: scaleX2, y: scaleY2 } = scale10;
      const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
      const { domain: domainX } = scaleX2.getOptions();
      const { domain: domainY } = scaleY2.getOptions();
      const index4 = indexOf3(visualData);
      const bboxs = visualData.map(subLayout);
      const values = visualData.map(({ x: x3, y: y3 }) => [
        scaleX2.invert(x3),
        scaleY2.invert(y3)
      ]);
      const filters = values.map(([fx, fy]) => (d3) => {
        const { [encodeX]: x3, [encodeY]: y3 } = d3;
        const inX = encodeX !== void 0 ? x3 === fx : true;
        const inY = encodeY !== void 0 ? y3 === fy : true;
        return inX && inY;
      });
      const facetData2d = filters.map((f) => data2.filter(f));
      const maxDataDomain = shareData ? max5(facetData2d, (data3) => data3.length) : void 0;
      const facets = values.map(([fx, fy]) => ({
        columnField: encodeX,
        columnIndex: domainX.indexOf(fx),
        columnValue: fx,
        columnValuesLength: domainX.length,
        rowField: encodeY,
        rowIndex: domainY.indexOf(fy),
        rowValue: fy,
        rowValuesLength: domainY.length
      }));
      const normalizedChildren = facets.map((facet) => {
        if (Array.isArray(children))
          return children;
        return [children(facet)].flat(1);
      });
      return index4.flatMap((i) => {
        const [left2, top, width, height] = bboxs[i];
        const facet = facets[i];
        const facetData = facetData2d[i];
        const children2 = normalizedChildren[i];
        return children2.map((_a) => {
          var _b, _c;
          var { scale: scale11, key, facet: isFacet = true, axis = {}, legend = {} } = _a, rest = __rest66(_a, ["scale", "key", "facet", "axis", "legend"]);
          const guideY = ((_b = scale11 === null || scale11 === void 0 ? void 0 : scale11.y) === null || _b === void 0 ? void 0 : _b.guide) || axis.y;
          const guideX = ((_c = scale11 === null || scale11 === void 0 ? void 0 : scale11.x) === null || _c === void 0 ? void 0 : _c.guide) || axis.x;
          const defaultScale = {
            x: { tickCount: encodeX ? 5 : void 0 },
            y: { tickCount: encodeY ? 5 : void 0 }
          };
          const newData = isFacet ? facetData : facetData.length === 0 ? [] : data2;
          const newScale = {
            color: { domain: facetDomainColor }
          };
          const newAxis = {
            x: createGuide(guideX, createGuideX2)(facet, newData),
            y: createGuide(guideY, createGuideY2)(facet, newData)
          };
          return Object.assign(Object.assign({
            key: `${key}-${i}`,
            data: newData,
            margin: 0,
            x: left2 + paddingLeft + originX + marginLeft,
            y: top + paddingTop + originY + marginTop,
            parentKey: viewKey,
            width,
            height,
            paddingLeft: 0,
            paddingRight: 0,
            paddingTop: 0,
            paddingBottom: 0,
            frame: newData.length ? true : false,
            dataDomain: maxDataDomain,
            scale: deep_mix_default(defaultScale, scale11, newScale),
            axis: deep_mix_default({}, axis, newAxis),
            // Hide all legends for child mark by default,
            // they are displayed in the top-level.
            legend: false
          }, rest), childOptions);
        });
      });
    };
    return {
      children: createChildren
    };
  });
  function subLayoutRect(data2) {
    const { points } = data2;
    return calcBBox(points);
  }
  function createInnerGuide(guide, data2) {
    return data2.length ? deep_mix_default({
      title: false,
      tick: null,
      label: null
    }, guide) : deep_mix_default({
      title: false,
      tick: null,
      label: null,
      grid: null
    }, guide);
  }
  function createGuideXRect(guide) {
    return (facet, data2) => {
      const { rowIndex, rowValuesLength, columnIndex, columnValuesLength } = facet;
      if (rowIndex !== rowValuesLength - 1)
        return createInnerGuide(guide, data2);
      const title = columnIndex !== columnValuesLength - 1 ? false : void 0;
      const grid2 = data2.length ? void 0 : null;
      return deep_mix_default({ title, grid: grid2 }, guide);
    };
  }
  function createGuideYRect(guide) {
    return (facet, data2) => {
      const { rowIndex, columnIndex } = facet;
      if (columnIndex !== 0)
        return createInnerGuide(guide, data2);
      const title = rowIndex !== 0 ? false : void 0;
      const grid2 = data2.length ? void 0 : null;
      return deep_mix_default({ title, grid: grid2 }, guide);
    };
  }
  function createGuide(guide, factory) {
    if (typeof guide === "function")
      return guide;
    if (guide === null || guide === false)
      return () => null;
    return factory(guide);
  }
  var FacetRect = () => {
    return (options) => {
      const newOptions = Container.of(options).call(toCell).call(inferColor).call(setAnimation).call(setScale).call(setStyle).call(setData).call(setChildren).value();
      return [newOptions];
    };
  };
  FacetRect.props = {};

  // node_modules/@antv/g2/esm/composition/repeatMatrix.js
  var __rest67 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var setScale2 = useDefaultAdaptor((options) => {
    return {
      scale: {
        x: { guide: null, paddingOuter: 0, paddingInner: 0.1 },
        y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
      }
    };
  });
  var setChildren2 = useOverrideAdaptor((options) => {
    const { data: data2, children, x: originX = 0, y: originY = 0, key: viewKey } = options;
    const createChildren = (visualData, scale10, layout) => {
      const { x: scaleX2, y: scaleY2 } = scale10;
      const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
      const { domain: domainX } = scaleX2.getOptions();
      const { domain: domainY } = scaleY2.getOptions();
      const index4 = indexOf3(visualData);
      const bboxs = visualData.map(({ points }) => calcBBox(points));
      const values = visualData.map(({ x: x3, y: y3 }) => [
        scaleX2.invert(x3),
        scaleY2.invert(y3)
      ]);
      const facets = values.map(([fx, fy]) => ({
        columnField: fx,
        columnIndex: domainX.indexOf(fx),
        columnValue: fx,
        columnValuesLength: domainX.length,
        rowField: fy,
        rowIndex: domainY.indexOf(fy),
        rowValue: fy,
        rowValuesLength: domainY.length
      }));
      const normalizedChildren = facets.map((facet) => {
        if (Array.isArray(children))
          return children;
        return [children(facet)].flat(1);
      });
      return index4.flatMap((i) => {
        const [left2, top, width, height] = bboxs[i];
        const [fx, fy] = values[i];
        const facet = facets[i];
        const children2 = normalizedChildren[i];
        return children2.map((d3) => {
          var _a, _b;
          const { scale: scale11, key, encode, axis, interaction } = d3, rest = __rest67(d3, ["scale", "key", "encode", "axis", "interaction"]);
          const guideY = (_a = scale11 === null || scale11 === void 0 ? void 0 : scale11.y) === null || _a === void 0 ? void 0 : _a.guide;
          const guideX = (_b = scale11 === null || scale11 === void 0 ? void 0 : scale11.x) === null || _b === void 0 ? void 0 : _b.guide;
          const defaultScale = {
            // Do not sync position scales among facets by default.
            x: { facet: false },
            // Do not sync position scales among facets by default.
            y: { facet: false }
          };
          const newAxis = {
            x: createGuideX(guideX)(facet, data2),
            y: createGuideY(guideY)(facet, data2)
          };
          const defaultAxis = {
            x: { tickCount: 5 },
            y: { tickCount: 5 }
          };
          return Object.assign({
            data: data2,
            parentKey: viewKey,
            key: `${key}-${i}`,
            x: left2 + paddingLeft + originX + marginLeft,
            y: top + paddingTop + originY + marginTop,
            width,
            height,
            margin: 0,
            paddingLeft: 0,
            paddingRight: 0,
            paddingTop: 0,
            paddingBottom: 0,
            frame: true,
            scale: deep_mix_default(defaultScale, scale11),
            axis: deep_mix_default(defaultAxis, axis, newAxis),
            // Hide all legends for child mark by default,
            // they are displayed in the top-level.
            legend: false,
            encode: deep_mix_default({}, encode, {
              x: fx,
              y: fy
            }),
            interaction: deep_mix_default({}, interaction, {
              // Register this interaction in parent node.
              legendFilter: false
            })
          }, rest);
        });
      });
    };
    return {
      children: createChildren
    };
  });
  var setData2 = useOverrideAdaptor((options) => {
    const { encode } = options, rest = __rest67(options, ["encode"]);
    const { position: P = [], x: X = P, y: Y = [...P].reverse() } = encode, restEncode = __rest67(encode, ["position", "x", "y"]);
    const data2 = [];
    for (const $x of [X].flat(1)) {
      for (const $y of [Y].flat(1)) {
        data2.push({ $x, $y });
      }
    }
    return Object.assign(Object.assign({}, rest), { data: data2, encode: Object.assign(Object.assign({}, restEncode), { x: "$x", y: "$y" }), scale: Object.assign(Object.assign({}, [X].flat(1).length === 1 && { x: { paddingInner: 0 } }), [Y].flat(1).length === 1 && { y: { paddingInner: 0 } }) });
  });
  function createGuideX(guideX) {
    if (typeof guideX === "function")
      return guideX;
    if (guideX === null)
      return () => null;
    return (facet, data2) => {
      const { rowIndex, rowValuesLength } = facet;
      if (rowIndex !== rowValuesLength - 1)
        return createInnerGuide(guideX, data2);
    };
  }
  function createGuideY(guideY) {
    if (typeof guideY === "function")
      return guideY;
    if (guideY === null)
      return () => null;
    return (facet, data2) => {
      const { columnIndex } = facet;
      if (columnIndex !== 0)
        return createInnerGuide(guideY, data2);
    };
  }
  var RepeatMatrix = () => {
    return (options) => {
      const newOptions = Container.of(options).call(toCell).call(inferColor).call(setChildren2).call(setData2).call(setAnimation).call(setStyle).call(setScale2).value();
      return [newOptions];
    };
  };

  // node_modules/@antv/g2/esm/composition/facetCircle.js
  var __rest68 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var setScale3 = useDefaultAdaptor((options) => {
    return {
      scale: {
        x: { guide: { type: "axisArc" }, paddingOuter: 0, paddingInner: 0.1 },
        y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
      }
    };
  });
  var setCoordinate = useDefaultAdaptor((options) => {
    return {
      coordinate: { type: "polar" }
    };
  });
  var setEncode = (options) => {
    const { encode } = options, rest = __rest68(options, ["encode"]);
    const { position } = encode;
    return Object.assign(Object.assign({}, rest), { encode: { x: position } });
  };
  function createGuideFacetCircle(guide) {
    return (facet) => null;
  }
  function subLayoutFacetCircle(data2) {
    const { points } = data2;
    const [p0, p1, p2, p3] = points;
    const sr = dist4(p0, p3);
    const v0 = sub6(p0, p3);
    const v1 = sub6(p1, p2);
    const a01 = angleBetween2(v0, v1);
    const t = 1 / Math.sin(a01 / 2);
    const ir = sr / (1 + t);
    const s3 = ir * Math.sqrt(2);
    const [x05, y05] = p2;
    const a0 = angleWithQuadrant(v0);
    const a3 = a0 + a01 / 2;
    const d3 = ir * t;
    const cx = x05 + d3 * Math.sin(a3);
    const cy = y05 - d3 * Math.cos(a3);
    return [cx - s3 / 2, cy - s3 / 2, s3, s3];
  }
  var FacetCircle = () => {
    return (options) => {
      const newOptions = Container.of(options).call(toCell).call(setEncode).call(inferColor).call(setCoordinate).call(setData).call(setChildren, subLayoutFacetCircle, createGuideFacetCircle, createGuideFacetCircle, { frame: false }).call(setAnimation).call(setStyle).call(setScale3).value();
      return [newOptions];
    };
  };

  // node_modules/@antv/g2/esm/composition/timingKeyframe.js
  function range2(direction2, iterationCount, keyframeCount) {
    const start2 = 0;
    const end = keyframeCount;
    const normal = [start2, end];
    const reverse = [-end + 1, -start2 + 1];
    if (direction2 === "normal")
      return normal;
    if (direction2 === "reverse")
      return reverse;
    if (direction2 === "alternate") {
      return iterationCount % 2 === 0 ? normal : reverse;
    }
    if (direction2 === "reverse-alternate") {
      return iterationCount % 2 === 0 ? reverse : normal;
    }
  }
  function setAnimation2(node, duration, easing) {
    const discovered = [node];
    while (discovered.length) {
      const n2 = discovered.pop();
      n2.animate = deep_mix_default({
        enter: {
          duration
        },
        update: {
          duration,
          easing,
          type: "morphing",
          fill: "both"
        },
        exit: {
          type: "fadeOut",
          duration
        }
      }, n2.animate || {});
      const { children } = n2;
      if (Array.isArray(children))
        discovered.push(...children);
    }
    return node;
  }
  var TimingKeyframe = () => {
    return (options) => {
      const { children = [], duration = 1e3, iterationCount = 1, direction: direction2 = "normal", easing = "ease-in-out-sine" } = options;
      const n2 = children.length;
      if (!Array.isArray(children) || n2 === 0)
        return [];
      const { key } = children[0];
      const newChildren = children.map((d3) => Object.assign(Object.assign({}, d3), { key })).map((d3) => setAnimation2(d3, duration, easing));
      return function* () {
        let count4 = 0;
        let prevIndex;
        while (iterationCount === "infinite" || count4 < iterationCount) {
          const [start2, end] = range2(direction2, count4, n2);
          for (let i = start2; i < end; i += 1) {
            const index4 = Math.abs(i);
            if (prevIndex !== index4)
              yield newChildren[index4];
            prevIndex = index4;
          }
          count4++;
        }
      };
    };
  };
  TimingKeyframe.props = {};

  // node_modules/@antv/g2/esm/composition/geoPath.js
  var __rest69 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var GeoPath = () => {
    return (options) => {
      const { type, data: data2, scale: scale10, encode, style, animate: animate2, key, state } = options, rest = __rest69(options, ["type", "data", "scale", "encode", "style", "animate", "key", "state"]);
      return [
        Object.assign(Object.assign({ type: "geoView" }, rest), { children: [
          {
            type: "geoPath",
            key: `${key}-0`,
            data: {
              value: data2
            },
            scale: scale10,
            encode,
            style,
            animate: animate2,
            state
          }
        ] })
      ];
    };
  };
  GeoPath.props = {};

  // node_modules/d3-geo/src/math.js
  var epsilon3 = 1e-6;
  var epsilon22 = 1e-12;
  var pi3 = Math.PI;
  var halfPi2 = pi3 / 2;
  var quarterPi = pi3 / 4;
  var tau3 = pi3 * 2;
  var degrees2 = 180 / pi3;
  var radians2 = pi3 / 180;
  var abs2 = Math.abs;
  var atan = Math.atan;
  var atan22 = Math.atan2;
  var cos2 = Math.cos;
  var ceil4 = Math.ceil;
  var exp2 = Math.exp;
  var log = Math.log;
  var pow2 = Math.pow;
  var sin2 = Math.sin;
  var sign2 = Math.sign || function(x3) {
    return x3 > 0 ? 1 : x3 < 0 ? -1 : 0;
  };
  var sqrt2 = Math.sqrt;
  var tan = Math.tan;
  function acos2(x3) {
    return x3 > 1 ? 0 : x3 < -1 ? pi3 : Math.acos(x3);
  }
  function asin2(x3) {
    return x3 > 1 ? halfPi2 : x3 < -1 ? -halfPi2 : Math.asin(x3);
  }

  // node_modules/d3-geo/src/noop.js
  function noop2() {
  }

  // node_modules/d3-geo/src/stream.js
  function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
      streamGeometryType[geometry.type](geometry, stream);
    }
  }
  var streamObjectType = {
    Feature: function(object, stream) {
      streamGeometry(object.geometry, stream);
    },
    FeatureCollection: function(object, stream) {
      var features = object.features, i = -1, n2 = features.length;
      while (++i < n2) streamGeometry(features[i].geometry, stream);
    }
  };
  var streamGeometryType = {
    Sphere: function(object, stream) {
      stream.sphere();
    },
    Point: function(object, stream) {
      object = object.coordinates;
      stream.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n2 = coordinates.length;
      while (++i < n2) object = coordinates[i], stream.point(object[0], object[1], object[2]);
    },
    LineString: function(object, stream) {
      streamLine(object.coordinates, stream, 0);
    },
    MultiLineString: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n2 = coordinates.length;
      while (++i < n2) streamLine(coordinates[i], stream, 0);
    },
    Polygon: function(object, stream) {
      streamPolygon(object.coordinates, stream);
    },
    MultiPolygon: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n2 = coordinates.length;
      while (++i < n2) streamPolygon(coordinates[i], stream);
    },
    GeometryCollection: function(object, stream) {
      var geometries = object.geometries, i = -1, n2 = geometries.length;
      while (++i < n2) streamGeometry(geometries[i], stream);
    }
  };
  function streamLine(coordinates, stream, closed) {
    var i = -1, n2 = coordinates.length - closed, coordinate;
    stream.lineStart();
    while (++i < n2) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
  }
  function streamPolygon(coordinates, stream) {
    var i = -1, n2 = coordinates.length;
    stream.polygonStart();
    while (++i < n2) streamLine(coordinates[i], stream, 1);
    stream.polygonEnd();
  }
  function stream_default(object, stream) {
    if (object && streamObjectType.hasOwnProperty(object.type)) {
      streamObjectType[object.type](object, stream);
    } else {
      streamGeometry(object, stream);
    }
  }

  // node_modules/d3-geo/src/cartesian.js
  function spherical(cartesian2) {
    return [atan22(cartesian2[1], cartesian2[0]), asin2(cartesian2[2])];
  }
  function cartesian(spherical2) {
    var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
    return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
  }
  function cartesianDot(a3, b) {
    return a3[0] * b[0] + a3[1] * b[1] + a3[2] * b[2];
  }
  function cartesianCross(a3, b) {
    return [a3[1] * b[2] - a3[2] * b[1], a3[2] * b[0] - a3[0] * b[2], a3[0] * b[1] - a3[1] * b[0]];
  }
  function cartesianAddInPlace(a3, b) {
    a3[0] += b[0], a3[1] += b[1], a3[2] += b[2];
  }
  function cartesianScale(vector, k) {
    return [vector[0] * k, vector[1] * k, vector[2] * k];
  }
  function cartesianNormalizeInPlace(d3) {
    var l2 = sqrt2(d3[0] * d3[0] + d3[1] * d3[1] + d3[2] * d3[2]);
    d3[0] /= l2, d3[1] /= l2, d3[2] /= l2;
  }

  // node_modules/d3-geo/src/compose.js
  function compose_default(a3, b) {
    function compose3(x3, y3) {
      return x3 = a3(x3, y3), b(x3[0], x3[1]);
    }
    if (a3.invert && b.invert) compose3.invert = function(x3, y3) {
      return x3 = b.invert(x3, y3), x3 && a3.invert(x3[0], x3[1]);
    };
    return compose3;
  }

  // node_modules/d3-geo/src/rotation.js
  function rotationIdentity(lambda, phi2) {
    if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau3) * tau3;
    return [lambda, phi2];
  }
  rotationIdentity.invert = rotationIdentity;
  function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
    return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
  }
  function forwardRotationLambda(deltaLambda) {
    return function(lambda, phi2) {
      lambda += deltaLambda;
      if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau3) * tau3;
      return [lambda, phi2];
    };
  }
  function rotationLambda(deltaLambda) {
    var rotation = forwardRotationLambda(deltaLambda);
    rotation.invert = forwardRotationLambda(-deltaLambda);
    return rotation;
  }
  function rotationPhiGamma(deltaPhi, deltaGamma) {
    var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
    function rotation(lambda, phi2) {
      var cosPhi = cos2(phi2), x3 = cos2(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z = sin2(phi2), k = z * cosDeltaPhi + x3 * sinDeltaPhi;
      return [
        atan22(y3 * cosDeltaGamma - k * sinDeltaGamma, x3 * cosDeltaPhi - z * sinDeltaPhi),
        asin2(k * cosDeltaGamma + y3 * sinDeltaGamma)
      ];
    }
    rotation.invert = function(lambda, phi2) {
      var cosPhi = cos2(phi2), x3 = cos2(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z = sin2(phi2), k = z * cosDeltaGamma - y3 * sinDeltaGamma;
      return [
        atan22(y3 * cosDeltaGamma + z * sinDeltaGamma, x3 * cosDeltaPhi + k * sinDeltaPhi),
        asin2(k * cosDeltaPhi - x3 * sinDeltaPhi)
      ];
    };
    return rotation;
  }
  function rotation_default(rotate5) {
    rotate5 = rotateRadians(rotate5[0] * radians2, rotate5[1] * radians2, rotate5.length > 2 ? rotate5[2] * radians2 : 0);
    function forward(coordinates) {
      coordinates = rotate5(coordinates[0] * radians2, coordinates[1] * radians2);
      return coordinates[0] *= degrees2, coordinates[1] *= degrees2, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate5.invert(coordinates[0] * radians2, coordinates[1] * radians2);
      return coordinates[0] *= degrees2, coordinates[1] *= degrees2, coordinates;
    };
    return forward;
  }

  // node_modules/d3-geo/src/circle.js
  function circleStream(stream, radius, delta, direction2, t0, t1) {
    if (!delta) return;
    var cosRadius = cos2(radius), sinRadius = sin2(radius), step2 = direction2 * delta;
    if (t0 == null) {
      t0 = radius + direction2 * tau3;
      t1 = radius - step2 / 2;
    } else {
      t0 = circleRadius(cosRadius, t0);
      t1 = circleRadius(cosRadius, t1);
      if (direction2 > 0 ? t0 < t1 : t0 > t1) t0 += direction2 * tau3;
    }
    for (var point6, t = t0; direction2 > 0 ? t > t1 : t < t1; t -= step2) {
      point6 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
      stream.point(point6[0], point6[1]);
    }
  }
  function circleRadius(cosRadius, point6) {
    point6 = cartesian(point6), point6[0] -= cosRadius;
    cartesianNormalizeInPlace(point6);
    var radius = acos2(-point6[1]);
    return ((-point6[2] < 0 ? -radius : radius) + tau3 - epsilon3) % tau3;
  }

  // node_modules/d3-geo/src/clip/buffer.js
  function buffer_default() {
    var lines = [], line4;
    return {
      point: function(x3, y3, m3) {
        line4.push([x3, y3, m3]);
      },
      lineStart: function() {
        lines.push(line4 = []);
      },
      lineEnd: noop2,
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line4 = null;
        return result;
      }
    };
  }

  // node_modules/d3-geo/src/pointEqual.js
  function pointEqual_default(a3, b) {
    return abs2(a3[0] - b[0]) < epsilon3 && abs2(a3[1] - b[1]) < epsilon3;
  }

  // node_modules/d3-geo/src/clip/rejoin.js
  function Intersection(point6, points, other, entry) {
    this.x = point6;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function rejoin_default(segments, compareIntersection2, startInside, interpolate5, stream) {
    var subject = [], clip = [], i, n2;
    segments.forEach(function(segment) {
      if ((n3 = segment.length - 1) <= 0) return;
      var n3, p0 = segment[0], p1 = segment[n3], x3;
      if (pointEqual_default(p0, p1)) {
        if (!p0[2] && !p1[2]) {
          stream.lineStart();
          for (i = 0; i < n3; ++i) stream.point((p0 = segment[i])[0], p0[1]);
          stream.lineEnd();
          return;
        }
        p1[0] += 2 * epsilon3;
      }
      subject.push(x3 = new Intersection(p0, segment, null, true));
      clip.push(x3.o = new Intersection(p0, null, x3, false));
      subject.push(x3 = new Intersection(p1, segment, null, false));
      clip.push(x3.o = new Intersection(p1, null, x3, true));
    });
    if (!subject.length) return;
    clip.sort(compareIntersection2);
    link(subject);
    link(clip);
    for (i = 0, n2 = clip.length; i < n2; ++i) {
      clip[i].e = startInside = !startInside;
    }
    var start2 = subject[0], points, point6;
    while (1) {
      var current = start2, isSubject = true;
      while (current.v) if ((current = current.n) === start2) return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i = 0, n2 = points.length; i < n2; ++i) stream.point((point6 = points[i])[0], point6[1]);
          } else {
            interpolate5(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i = points.length - 1; i >= 0; --i) stream.point((point6 = points[i])[0], point6[1]);
          } else {
            interpolate5(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }
  function link(array2) {
    if (!(n2 = array2.length)) return;
    var n2, i = 0, a3 = array2[0], b;
    while (++i < n2) {
      a3.n = b = array2[i];
      b.p = a3;
      a3 = b;
    }
    a3.n = b = array2[0];
    b.p = a3;
  }

  // node_modules/d3-geo/src/polygonContains.js
  function longitude(point6) {
    return abs2(point6[0]) <= pi3 ? point6[0] : sign2(point6[0]) * ((abs2(point6[0]) + pi3) % tau3 - pi3);
  }
  function polygonContains_default(polygon, point6) {
    var lambda = longitude(point6), phi2 = point6[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle4 = 0, winding = 0;
    var sum3 = new Adder();
    if (sinPhi === 1) phi2 = halfPi2 + epsilon3;
    else if (sinPhi === -1) phi2 = -halfPi2 - epsilon3;
    for (var i = 0, n2 = polygon.length; i < n2; ++i) {
      if (!(m3 = (ring = polygon[i]).length)) continue;
      var ring, m3, point0 = ring[m3 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi0), cosPhi0 = cos2(phi0);
      for (var j = 0; j < m3; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
        var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi3, k = sinPhi0 * sinPhi1;
        sum3.add(atan22(k * sign3 * sin2(absDelta), cosPhi0 * cosPhi1 + k * cos2(absDelta)));
        angle4 += antimeridian ? delta + sign3 * tau3 : delta;
        if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection = cartesianCross(normal, arc);
          cartesianNormalizeInPlace(intersection);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection[2]);
          if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }
    return (angle4 < -epsilon3 || angle4 < epsilon3 && sum3 < -epsilon22) ^ winding & 1;
  }

  // node_modules/d3-geo/src/clip/index.js
  function clip_default(pointVisible, clipLine, interpolate5, start2) {
    return function(sink) {
      var line4 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
      var clip = {
        point: point6,
        lineStart,
        lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point6;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge(segments);
          var startInside = polygonContains_default(polygon, start2);
          if (segments.length) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            rejoin_default(segments, compareIntersection, startInside, interpolate5, sink);
          } else if (startInside) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate5(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate5(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };
      function point6(lambda, phi2) {
        if (pointVisible(lambda, phi2)) sink.point(lambda, phi2);
      }
      function pointLine(lambda, phi2) {
        line4.point(lambda, phi2);
      }
      function lineStart() {
        clip.point = pointLine;
        line4.lineStart();
      }
      function lineEnd() {
        clip.point = point6;
        line4.lineEnd();
      }
      function pointRing(lambda, phi2) {
        ring.push([lambda, phi2]);
        ringSink.point(lambda, phi2);
      }
      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();
        var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n2 = ringSegments.length, m3, segment, point7;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n2) return;
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m3 = segment.length - 1) > 0) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i = 0; i < m3; ++i) sink.point((point7 = segment[i])[0], point7[1]);
            sink.lineEnd();
          }
          return;
        }
        if (n2 > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(validSegment));
      }
      return clip;
    };
  }
  function validSegment(segment) {
    return segment.length > 1;
  }
  function compareIntersection(a3, b) {
    return ((a3 = a3.x)[0] < 0 ? a3[1] - halfPi2 - epsilon3 : halfPi2 - a3[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi2 - epsilon3 : halfPi2 - b[1]);
  }

  // node_modules/d3-geo/src/clip/antimeridian.js
  var antimeridian_default = clip_default(
    function() {
      return true;
    },
    clipAntimeridianLine,
    clipAntimeridianInterpolate,
    [-pi3, -halfPi2]
  );
  function clipAntimeridianLine(stream) {
    var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
    return {
      lineStart: function() {
        stream.lineStart();
        clean = 1;
      },
      point: function(lambda1, phi1) {
        var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs2(lambda1 - lambda0);
        if (abs2(delta - pi3) < epsilon3) {
          stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi2 : -halfPi2);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          stream.point(lambda1, phi0);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi3) {
          if (abs2(lambda0 - sign0) < epsilon3) lambda0 -= sign0 * epsilon3;
          if (abs2(lambda1 - sign1) < epsilon3) lambda1 -= sign1 * epsilon3;
          phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          clean = 0;
        }
        stream.point(lambda0 = lambda1, phi0 = phi1);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda0 = phi0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
    var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
    return abs2(sinLambda0Lambda1) > epsilon3 ? atan((sin2(phi0) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos2(phi0)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
  }
  function clipAntimeridianInterpolate(from, to, direction2, stream) {
    var phi2;
    if (from == null) {
      phi2 = direction2 * halfPi2;
      stream.point(-pi3, phi2);
      stream.point(0, phi2);
      stream.point(pi3, phi2);
      stream.point(pi3, 0);
      stream.point(pi3, -phi2);
      stream.point(0, -phi2);
      stream.point(-pi3, -phi2);
      stream.point(-pi3, 0);
      stream.point(-pi3, phi2);
    } else if (abs2(from[0] - to[0]) > epsilon3) {
      var lambda = from[0] < to[0] ? pi3 : -pi3;
      phi2 = direction2 * lambda / 2;
      stream.point(-lambda, phi2);
      stream.point(0, phi2);
      stream.point(lambda, phi2);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  // node_modules/d3-geo/src/clip/circle.js
  function circle_default(radius) {
    var cr = cos2(radius), delta = 2 * radians2, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon3;
    function interpolate5(from, to, direction2, stream) {
      circleStream(stream, radius, delta, direction2, from, to);
    }
    function visible(lambda, phi2) {
      return cos2(lambda) * cos2(phi2) > cr;
    }
    function clipLine(stream) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(lambda, phi2) {
          var point1 = [lambda, phi2], point22, v = visible(lambda, phi2), c5 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi2) : 0;
          if (!point0 && (v00 = v0 = v)) stream.lineStart();
          if (v !== v0) {
            point22 = intersect4(point0, point1);
            if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
              point1[2] = 1;
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              stream.lineStart();
              point22 = intersect4(point1, point0);
              stream.point(point22[0], point22[1]);
            } else {
              point22 = intersect4(point0, point1);
              stream.point(point22[0], point22[1], 2);
              stream.lineEnd();
            }
            point0 = point22;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c5 & c0) && (t = intersect4(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                stream.lineStart();
                stream.point(t[0][0], t[0][1]);
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
              } else {
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
                stream.lineStart();
                stream.point(t[0][0], t[0][1], 3);
              }
            }
          }
          if (v && (!point0 || !pointEqual_default(point0, point1))) {
            stream.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c5;
        },
        lineEnd: function() {
          if (v0) stream.lineEnd();
          point0 = null;
        },
        // Rejoin first and last segments if there were intersections and the first
        // and last points were visible.
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect4(a3, b, two) {
      var pa = cartesian(a3), pb = cartesian(b);
      var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant3 = n2n2 - n1n2 * n1n2;
      if (!determinant3) return !two && a3;
      var c1 = cr * n2n2 / determinant3, c22 = -cr * n1n2 / determinant3, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B4 = cartesianScale(n2, c22);
      cartesianAddInPlace(A5, B4);
      var u = n1xn2, w = cartesianDot(A5, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A5, A5) - 1);
      if (t2 < 0) return;
      var t = sqrt2(t2), q = cartesianScale(u, (-w - t) / uu);
      cartesianAddInPlace(q, A5);
      q = spherical(q);
      if (!two) return q;
      var lambda0 = a3[0], lambda1 = b[0], phi0 = a3[1], phi1 = b[1], z;
      if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
      var delta2 = lambda1 - lambda0, polar = abs2(delta2 - pi3) < epsilon3, meridian = polar || delta2 < epsilon3;
      if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;
      if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs2(q[0] - lambda0) < epsilon3 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
        var q12 = cartesianScale(u, (-w + t) / uu);
        cartesianAddInPlace(q12, A5);
        return [q, spherical(q12)];
      }
    }
    function code(lambda, phi2) {
      var r = smallRadius ? radius : pi3 - radius, code2 = 0;
      if (lambda < -r) code2 |= 1;
      else if (lambda > r) code2 |= 2;
      if (phi2 < -r) code2 |= 4;
      else if (phi2 > r) code2 |= 8;
      return code2;
    }
    return clip_default(visible, clipLine, interpolate5, smallRadius ? [0, -radius] : [-pi3, radius - pi3]);
  }

  // node_modules/d3-geo/src/clip/line.js
  function line_default2(a3, b, x05, y05, x12, y12) {
    var ax = a3[0], ay = a3[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
    r = x05 - ax;
    if (!dx && r > 0) return;
    r /= dx;
    if (dx < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dx > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }
    r = x12 - ax;
    if (!dx && r < 0) return;
    r /= dx;
    if (dx < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dx > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }
    r = y05 - ay;
    if (!dy && r > 0) return;
    r /= dy;
    if (dy < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dy > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }
    r = y12 - ay;
    if (!dy && r < 0) return;
    r /= dy;
    if (dy < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dy > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }
    if (t0 > 0) a3[0] = ax + t0 * dx, a3[1] = ay + t0 * dy;
    if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
    return true;
  }

  // node_modules/d3-geo/src/clip/rectangle.js
  var clipMax = 1e9;
  var clipMin = -clipMax;
  function clipRectangle(x05, y05, x12, y12) {
    function visible(x3, y3) {
      return x05 <= x3 && x3 <= x12 && y05 <= y3 && y3 <= y12;
    }
    function interpolate5(from, to, direction2, stream) {
      var a3 = 0, a1 = 0;
      if (from == null || (a3 = corner(from, direction2)) !== (a1 = corner(to, direction2)) || comparePoint(from, to) < 0 ^ direction2 > 0) {
        do
          stream.point(a3 === 0 || a3 === 3 ? x05 : x12, a3 > 1 ? y12 : y05);
        while ((a3 = (a3 + direction2 + 4) % 4) !== a1);
      } else {
        stream.point(to[0], to[1]);
      }
    }
    function corner(p2, direction2) {
      return abs2(p2[0] - x05) < epsilon3 ? direction2 > 0 ? 0 : 3 : abs2(p2[0] - x12) < epsilon3 ? direction2 > 0 ? 2 : 1 : abs2(p2[1] - y05) < epsilon3 ? direction2 > 0 ? 1 : 0 : direction2 > 0 ? 3 : 2;
    }
    function compareIntersection2(a3, b) {
      return comparePoint(a3.x, b.x);
    }
    function comparePoint(a3, b) {
      var ca = corner(a3, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a3[1] : ca === 1 ? a3[0] - b[0] : ca === 2 ? a3[1] - b[1] : b[0] - a3[0];
    }
    return function(stream) {
      var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first3, clean;
      var clipStream = {
        point: point6,
        lineStart,
        lineEnd,
        polygonStart,
        polygonEnd
      };
      function point6(x3, y3) {
        if (visible(x3, y3)) activeStream.point(x3, y3);
      }
      function polygonInside() {
        var winding = 0;
        for (var i = 0, n2 = polygon.length; i < n2; ++i) {
          for (var ring2 = polygon[i], j = 1, m3 = ring2.length, point7 = ring2[0], a0, a1, b0 = point7[0], b1 = point7[1]; j < m3; ++j) {
            a0 = b0, a1 = b1, point7 = ring2[j], b0 = point7[0], b1 = point7[1];
            if (a1 <= y12) {
              if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x05 - a0)) ++winding;
            } else {
              if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x05 - a0)) --winding;
            }
          }
        }
        return winding;
      }
      function polygonStart() {
        activeStream = bufferStream, segments = [], polygon = [], clean = true;
      }
      function polygonEnd() {
        var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
        if (cleanInside || visible2) {
          stream.polygonStart();
          if (cleanInside) {
            stream.lineStart();
            interpolate5(null, null, 1, stream);
            stream.lineEnd();
          }
          if (visible2) {
            rejoin_default(segments, compareIntersection2, startInside, interpolate5, stream);
          }
          stream.polygonEnd();
        }
        activeStream = stream, segments = polygon = ring = null;
      }
      function lineStart() {
        clipStream.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first3 = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferStream.rejoin();
          segments.push(bufferStream.result());
        }
        clipStream.point = point6;
        if (v_) activeStream.lineEnd();
      }
      function linePoint(x3, y3) {
        var v = visible(x3, y3);
        if (polygon) ring.push([x3, y3]);
        if (first3) {
          x__ = x3, y__ = y3, v__ = v;
          first3 = false;
          if (v) {
            activeStream.lineStart();
            activeStream.point(x3, y3);
          }
        } else {
          if (v && v_) activeStream.point(x3, y3);
          else {
            var a3 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x3 = Math.max(clipMin, Math.min(clipMax, x3)), y3 = Math.max(clipMin, Math.min(clipMax, y3))];
            if (line_default2(a3, b, x05, y05, x12, y12)) {
              if (!v_) {
                activeStream.lineStart();
                activeStream.point(a3[0], a3[1]);
              }
              activeStream.point(b[0], b[1]);
              if (!v) activeStream.lineEnd();
              clean = false;
            } else if (v) {
              activeStream.lineStart();
              activeStream.point(x3, y3);
              clean = false;
            }
          }
        }
        x_ = x3, y_ = y3, v_ = v;
      }
      return clipStream;
    };
  }

  // node_modules/d3-geo/src/graticule.js
  function graticuleX(y05, y12, dy) {
    var y3 = range(y05, y12 - epsilon3, dy).concat(y12);
    return function(x3) {
      return y3.map(function(y4) {
        return [x3, y4];
      });
    };
  }
  function graticuleY(x05, x12, dx) {
    var x3 = range(x05, x12 - epsilon3, dx).concat(x12);
    return function(y3) {
      return x3.map(function(x4) {
        return [x4, y3];
      });
    };
  }
  function graticule() {
    var x12, x05, X12, X02, y12, y05, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x3, y3, X, Y, precision = 2.5;
    function graticule2() {
      return { type: "MultiLineString", coordinates: lines() };
    }
    function lines() {
      return range(ceil4(X02 / DX) * DX, X12, DX).map(X).concat(range(ceil4(Y02 / DY) * DY, Y12, DY).map(Y)).concat(range(ceil4(x05 / dx) * dx, x12, dx).filter(function(x4) {
        return abs2(x4 % DX) > epsilon3;
      }).map(x3)).concat(range(ceil4(y05 / dy) * dy, y12, dy).filter(function(y4) {
        return abs2(y4 % DY) > epsilon3;
      }).map(y3));
    }
    graticule2.lines = function() {
      return lines().map(function(coordinates) {
        return { type: "LineString", coordinates };
      });
    };
    graticule2.outline = function() {
      return {
        type: "Polygon",
        coordinates: [
          X(X02).concat(
            Y(Y12).slice(1),
            X(X12).reverse().slice(1),
            Y(Y02).reverse().slice(1)
          )
        ]
      };
    };
    graticule2.extent = function(_2) {
      if (!arguments.length) return graticule2.extentMinor();
      return graticule2.extentMajor(_2).extentMinor(_2);
    };
    graticule2.extentMajor = function(_2) {
      if (!arguments.length) return [[X02, Y02], [X12, Y12]];
      X02 = +_2[0][0], X12 = +_2[1][0];
      Y02 = +_2[0][1], Y12 = +_2[1][1];
      if (X02 > X12) _2 = X02, X02 = X12, X12 = _2;
      if (Y02 > Y12) _2 = Y02, Y02 = Y12, Y12 = _2;
      return graticule2.precision(precision);
    };
    graticule2.extentMinor = function(_2) {
      if (!arguments.length) return [[x05, y05], [x12, y12]];
      x05 = +_2[0][0], x12 = +_2[1][0];
      y05 = +_2[0][1], y12 = +_2[1][1];
      if (x05 > x12) _2 = x05, x05 = x12, x12 = _2;
      if (y05 > y12) _2 = y05, y05 = y12, y12 = _2;
      return graticule2.precision(precision);
    };
    graticule2.step = function(_2) {
      if (!arguments.length) return graticule2.stepMinor();
      return graticule2.stepMajor(_2).stepMinor(_2);
    };
    graticule2.stepMajor = function(_2) {
      if (!arguments.length) return [DX, DY];
      DX = +_2[0], DY = +_2[1];
      return graticule2;
    };
    graticule2.stepMinor = function(_2) {
      if (!arguments.length) return [dx, dy];
      dx = +_2[0], dy = +_2[1];
      return graticule2;
    };
    graticule2.precision = function(_2) {
      if (!arguments.length) return precision;
      precision = +_2;
      x3 = graticuleX(y05, y12, 90);
      y3 = graticuleY(x05, x12, precision);
      X = graticuleX(Y02, Y12, 90);
      Y = graticuleY(X02, X12, precision);
      return graticule2;
    };
    return graticule2.extentMajor([[-180, -90 + epsilon3], [180, 90 - epsilon3]]).extentMinor([[-180, -80 - epsilon3], [180, 80 + epsilon3]]);
  }
  function graticule10() {
    return graticule()();
  }

  // node_modules/d3-geo/src/identity.js
  var identity_default3 = (x3) => x3;

  // node_modules/d3-geo/src/path/area.js
  var areaSum = new Adder();
  var areaRingSum = new Adder();
  var x00;
  var y00;
  var x0;
  var y0;
  var areaStream = {
    point: noop2,
    lineStart: noop2,
    lineEnd: noop2,
    polygonStart: function() {
      areaStream.lineStart = areaRingStart;
      areaStream.lineEnd = areaRingEnd;
    },
    polygonEnd: function() {
      areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop2;
      areaSum.add(abs2(areaRingSum));
      areaRingSum = new Adder();
    },
    result: function() {
      var area2 = areaSum / 2;
      areaSum = new Adder();
      return area2;
    }
  };
  function areaRingStart() {
    areaStream.point = areaPointFirst;
  }
  function areaPointFirst(x3, y3) {
    areaStream.point = areaPoint;
    x00 = x0 = x3, y00 = y0 = y3;
  }
  function areaPoint(x3, y3) {
    areaRingSum.add(y0 * x3 - x0 * y3);
    x0 = x3, y0 = y3;
  }
  function areaRingEnd() {
    areaPoint(x00, y00);
  }
  var area_default2 = areaStream;

  // node_modules/d3-geo/src/path/bounds.js
  var x02 = Infinity;
  var y02 = x02;
  var x1 = -x02;
  var y1 = x1;
  var boundsStream = {
    point: boundsPoint,
    lineStart: noop2,
    lineEnd: noop2,
    polygonStart: noop2,
    polygonEnd: noop2,
    result: function() {
      var bounds = [[x02, y02], [x1, y1]];
      x1 = y1 = -(y02 = x02 = Infinity);
      return bounds;
    }
  };
  function boundsPoint(x3, y3) {
    if (x3 < x02) x02 = x3;
    if (x3 > x1) x1 = x3;
    if (y3 < y02) y02 = y3;
    if (y3 > y1) y1 = y3;
  }
  var bounds_default = boundsStream;

  // node_modules/d3-geo/src/path/centroid.js
  var X0 = 0;
  var Y0 = 0;
  var Z0 = 0;
  var X1 = 0;
  var Y1 = 0;
  var Z1 = 0;
  var X2 = 0;
  var Y2 = 0;
  var Z2 = 0;
  var x002;
  var y002;
  var x03;
  var y03;
  var centroidStream = {
    point: centroidPoint,
    lineStart: centroidLineStart,
    lineEnd: centroidLineEnd,
    polygonStart: function() {
      centroidStream.lineStart = centroidRingStart;
      centroidStream.lineEnd = centroidRingEnd;
    },
    polygonEnd: function() {
      centroidStream.point = centroidPoint;
      centroidStream.lineStart = centroidLineStart;
      centroidStream.lineEnd = centroidLineEnd;
    },
    result: function() {
      var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
      X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
      return centroid;
    }
  };
  function centroidPoint(x3, y3) {
    X0 += x3;
    Y0 += y3;
    ++Z0;
  }
  function centroidLineStart() {
    centroidStream.point = centroidPointFirstLine;
  }
  function centroidPointFirstLine(x3, y3) {
    centroidStream.point = centroidPointLine;
    centroidPoint(x03 = x3, y03 = y3);
  }
  function centroidPointLine(x3, y3) {
    var dx = x3 - x03, dy = y3 - y03, z = sqrt2(dx * dx + dy * dy);
    X1 += z * (x03 + x3) / 2;
    Y1 += z * (y03 + y3) / 2;
    Z1 += z;
    centroidPoint(x03 = x3, y03 = y3);
  }
  function centroidLineEnd() {
    centroidStream.point = centroidPoint;
  }
  function centroidRingStart() {
    centroidStream.point = centroidPointFirstRing;
  }
  function centroidRingEnd() {
    centroidPointRing(x002, y002);
  }
  function centroidPointFirstRing(x3, y3) {
    centroidStream.point = centroidPointRing;
    centroidPoint(x002 = x03 = x3, y002 = y03 = y3);
  }
  function centroidPointRing(x3, y3) {
    var dx = x3 - x03, dy = y3 - y03, z = sqrt2(dx * dx + dy * dy);
    X1 += z * (x03 + x3) / 2;
    Y1 += z * (y03 + y3) / 2;
    Z1 += z;
    z = y03 * x3 - x03 * y3;
    X2 += z * (x03 + x3);
    Y2 += z * (y03 + y3);
    Z2 += z * 3;
    centroidPoint(x03 = x3, y03 = y3);
  }
  var centroid_default = centroidStream;

  // node_modules/d3-geo/src/path/context.js
  function PathContext(context) {
    this._context = context;
  }
  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_2) {
      return this._radius = _2, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0) this._context.closePath();
      this._point = NaN;
    },
    point: function(x3, y3) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x3, y3);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x3, y3);
          break;
        }
        default: {
          this._context.moveTo(x3 + this._radius, y3);
          this._context.arc(x3, y3, this._radius, 0, tau3);
          break;
        }
      }
    },
    result: noop2
  };

  // node_modules/d3-geo/src/path/measure.js
  var lengthSum = new Adder();
  var lengthRing;
  var x003;
  var y003;
  var x04;
  var y04;
  var lengthStream = {
    point: noop2,
    lineStart: function() {
      lengthStream.point = lengthPointFirst;
    },
    lineEnd: function() {
      if (lengthRing) lengthPoint(x003, y003);
      lengthStream.point = noop2;
    },
    polygonStart: function() {
      lengthRing = true;
    },
    polygonEnd: function() {
      lengthRing = null;
    },
    result: function() {
      var length5 = +lengthSum;
      lengthSum = new Adder();
      return length5;
    }
  };
  function lengthPointFirst(x3, y3) {
    lengthStream.point = lengthPoint;
    x003 = x04 = x3, y003 = y04 = y3;
  }
  function lengthPoint(x3, y3) {
    x04 -= x3, y04 -= y3;
    lengthSum.add(sqrt2(x04 * x04 + y04 * y04));
    x04 = x3, y04 = y3;
  }
  var measure_default = lengthStream;

  // node_modules/d3-geo/src/path/string.js
  var cacheDigits;
  var cacheAppend;
  var cacheRadius;
  var cacheCircle;
  var PathString = class {
    constructor(digits) {
      this._append = digits == null ? append2 : appendRound2(digits);
      this._radius = 4.5;
      this._ = "";
    }
    pointRadius(_2) {
      this._radius = +_2;
      return this;
    }
    polygonStart() {
      this._line = 0;
    }
    polygonEnd() {
      this._line = NaN;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
      if (this._line === 0) this._ += "Z";
      this._point = NaN;
    }
    point(x3, y3) {
      switch (this._point) {
        case 0: {
          this._append`M${x3},${y3}`;
          this._point = 1;
          break;
        }
        case 1: {
          this._append`L${x3},${y3}`;
          break;
        }
        default: {
          this._append`M${x3},${y3}`;
          if (this._radius !== cacheRadius || this._append !== cacheAppend) {
            const r = this._radius;
            const s3 = this._;
            this._ = "";
            this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
            cacheRadius = r;
            cacheAppend = this._append;
            cacheCircle = this._;
            this._ = s3;
          }
          this._ += cacheCircle;
          break;
        }
      }
    }
    result() {
      const result = this._;
      this._ = "";
      return result.length ? result : null;
    }
  };
  function append2(strings) {
    let i = 1;
    this._ += strings[0];
    for (const j = strings.length; i < j; ++i) {
      this._ += arguments[i] + strings[i];
    }
  }
  function appendRound2(digits) {
    const d3 = Math.floor(digits);
    if (!(d3 >= 0)) throw new RangeError(`invalid digits: ${digits}`);
    if (d3 > 15) return append2;
    if (d3 !== cacheDigits) {
      const k = 10 ** d3;
      cacheDigits = d3;
      cacheAppend = function append3(strings) {
        let i = 1;
        this._ += strings[0];
        for (const j = strings.length; i < j; ++i) {
          this._ += Math.round(arguments[i] * k) / k + strings[i];
        }
      };
    }
    return cacheAppend;
  }

  // node_modules/d3-geo/src/path/index.js
  function path_default2(projection3, context) {
    let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
    function path2(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        stream_default(object, projectionStream(contextStream));
      }
      return contextStream.result();
    }
    path2.area = function(object) {
      stream_default(object, projectionStream(area_default2));
      return area_default2.result();
    };
    path2.measure = function(object) {
      stream_default(object, projectionStream(measure_default));
      return measure_default.result();
    };
    path2.bounds = function(object) {
      stream_default(object, projectionStream(bounds_default));
      return bounds_default.result();
    };
    path2.centroid = function(object) {
      stream_default(object, projectionStream(centroid_default));
      return centroid_default.result();
    };
    path2.projection = function(_2) {
      if (!arguments.length) return projection3;
      projectionStream = _2 == null ? (projection3 = null, identity_default3) : (projection3 = _2).stream;
      return path2;
    };
    path2.context = function(_2) {
      if (!arguments.length) return context;
      contextStream = _2 == null ? (context = null, new PathString(digits)) : new PathContext(context = _2);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return path2;
    };
    path2.pointRadius = function(_2) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
      return path2;
    };
    path2.digits = function(_2) {
      if (!arguments.length) return digits;
      if (_2 == null) digits = null;
      else {
        const d3 = Math.floor(_2);
        if (!(d3 >= 0)) throw new RangeError(`invalid digits: ${_2}`);
        digits = d3;
      }
      if (context === null) contextStream = new PathString(digits);
      return path2;
    };
    return path2.projection(projection3).digits(digits).context(context);
  }

  // node_modules/d3-geo/src/transform.js
  function transformer(methods2) {
    return function(stream) {
      var s3 = new TransformStream();
      for (var key in methods2) s3[key] = methods2[key];
      s3.stream = stream;
      return s3;
    };
  }
  function TransformStream() {
  }
  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x3, y3) {
      this.stream.point(x3, y3);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };

  // node_modules/d3-geo/src/projection/fit.js
  function fit(projection3, fitBounds, object) {
    var clip = projection3.clipExtent && projection3.clipExtent();
    projection3.scale(150).translate([0, 0]);
    if (clip != null) projection3.clipExtent(null);
    stream_default(object, projection3.stream(bounds_default));
    fitBounds(bounds_default.result());
    if (clip != null) projection3.clipExtent(clip);
    return projection3;
  }
  function fitExtent(projection3, extent2, object) {
    return fit(projection3, function(b) {
      var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x3 = +extent2[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y3 = +extent2[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
      projection3.scale(150 * k).translate([x3, y3]);
    }, object);
  }
  function fitSize(projection3, size2, object) {
    return fitExtent(projection3, [[0, 0], size2], object);
  }
  function fitWidth(projection3, width, object) {
    return fit(projection3, function(b) {
      var w = +width, k = w / (b[1][0] - b[0][0]), x3 = (w - k * (b[1][0] + b[0][0])) / 2, y3 = -k * b[0][1];
      projection3.scale(150 * k).translate([x3, y3]);
    }, object);
  }
  function fitHeight(projection3, height, object) {
    return fit(projection3, function(b) {
      var h = +height, k = h / (b[1][1] - b[0][1]), x3 = -k * b[0][0], y3 = (h - k * (b[1][1] + b[0][1])) / 2;
      projection3.scale(150 * k).translate([x3, y3]);
    }, object);
  }

  // node_modules/d3-geo/src/projection/resample.js
  var maxDepth = 16;
  var cosMinDistance = cos2(30 * radians2);
  function resample_default(project, delta2) {
    return +delta2 ? resample(project, delta2) : resampleNone(project);
  }
  function resampleNone(project) {
    return transformer({
      point: function(x3, y3) {
        x3 = project(x3, y3);
        this.stream.point(x3[0], x3[1]);
      }
    });
  }
  function resample(project, delta2) {
    function resampleLineTo(x05, y05, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
      var dx = x12 - x05, dy = y12 - y05, d22 = dx * dx + dy * dy;
      if (d22 > 4 * delta2 && depth--) {
        var a3 = a0 + a1, b = b0 + b1, c5 = c0 + c1, m3 = sqrt2(a3 * a3 + b * b + c5 * c5), phi2 = asin2(c5 /= m3), lambda2 = abs2(abs2(c5) - 1) < epsilon3 || abs2(lambda0 - lambda1) < epsilon3 ? (lambda0 + lambda1) / 2 : atan22(b, a3), p2 = project(lambda2, phi2), x22 = p2[0], y22 = p2[1], dx2 = x22 - x05, dy2 = y22 - y05, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d22 > delta2 || abs2((dx * dx2 + dy * dy2) / d22 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x05, y05, lambda0, a0, b0, c0, x22, y22, lambda2, a3 /= m3, b /= m3, c5, depth, stream);
          stream.point(x22, y22);
          resampleLineTo(x22, y22, lambda2, a3, b, c5, x12, y12, lambda1, a1, b1, c1, depth, stream);
        }
      }
    }
    return function(stream) {
      var lambda00, x004, y004, a00, b00, c00, lambda0, x05, y05, a0, b0, c0;
      var resampleStream = {
        point: point6,
        lineStart,
        lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resampleStream.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resampleStream.lineStart = lineStart;
        }
      };
      function point6(x3, y3) {
        x3 = project(x3, y3);
        stream.point(x3[0], x3[1]);
      }
      function lineStart() {
        x05 = NaN;
        resampleStream.point = linePoint;
        stream.lineStart();
      }
      function linePoint(lambda, phi2) {
        var c5 = cartesian([lambda, phi2]), p2 = project(lambda, phi2);
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x05 = p2[0], y05 = p2[1], lambda0 = lambda, a0 = c5[0], b0 = c5[1], c0 = c5[2], maxDepth, stream);
        stream.point(x05, y05);
      }
      function lineEnd() {
        resampleStream.point = point6;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resampleStream.point = ringPoint;
        resampleStream.lineEnd = ringEnd;
      }
      function ringPoint(lambda, phi2) {
        linePoint(lambda00 = lambda, phi2), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
        resampleStream.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
        resampleStream.lineEnd = lineEnd;
        lineEnd();
      }
      return resampleStream;
    };
  }

  // node_modules/d3-geo/src/projection/index.js
  var transformRadians = transformer({
    point: function(x3, y3) {
      this.stream.point(x3 * radians2, y3 * radians2);
    }
  });
  function transformRotate(rotate5) {
    return transformer({
      point: function(x3, y3) {
        var r = rotate5(x3, y3);
        return this.stream.point(r[0], r[1]);
      }
    });
  }
  function scaleTranslate(k, dx, dy, sx, sy) {
    function transform(x3, y3) {
      x3 *= sx;
      y3 *= sy;
      return [dx + k * x3, dy - k * y3];
    }
    transform.invert = function(x3, y3) {
      return [(x3 - dx) / k * sx, (dy - y3) / k * sy];
    };
    return transform;
  }
  function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
    if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
    var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a3 = cosAlpha * k, b = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
    function transform(x3, y3) {
      x3 *= sx;
      y3 *= sy;
      return [a3 * x3 - b * y3 + dx, dy - b * x3 - a3 * y3];
    }
    transform.invert = function(x3, y3) {
      return [sx * (ai * x3 - bi * y3 + ci), sy * (fi - bi * x3 - ai * y3)];
    };
    return transform;
  }
  function projection2(project) {
    return projectionMutator(function() {
      return project;
    })();
  }
  function projectionMutator(projectAt) {
    var project, k = 150, x3 = 480, y3 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate5, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x12, y12, postclip = identity_default3, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache3, cacheStream;
    function projection3(point6) {
      return projectRotateTransform(point6[0] * radians2, point6[1] * radians2);
    }
    function invert5(point6) {
      point6 = projectRotateTransform.invert(point6[0], point6[1]);
      return point6 && [point6[0] * degrees2, point6[1] * degrees2];
    }
    projection3.stream = function(stream) {
      return cache3 && cacheStream === stream ? cache3 : cache3 = transformRadians(transformRotate(rotate5)(preclip(projectResample(postclip(cacheStream = stream)))));
    };
    projection3.preclip = function(_2) {
      return arguments.length ? (preclip = _2, theta = void 0, reset()) : preclip;
    };
    projection3.postclip = function(_2) {
      return arguments.length ? (postclip = _2, x05 = y05 = x12 = y12 = null, reset()) : postclip;
    };
    projection3.clipAngle = function(_2) {
      return arguments.length ? (preclip = +_2 ? circle_default(theta = _2 * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees2;
    };
    projection3.clipExtent = function(_2) {
      return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x12 = y12 = null, identity_default3) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
    };
    projection3.scale = function(_2) {
      return arguments.length ? (k = +_2, recenter()) : k;
    };
    projection3.translate = function(_2) {
      return arguments.length ? (x3 = +_2[0], y3 = +_2[1], recenter()) : [x3, y3];
    };
    projection3.center = function(_2) {
      return arguments.length ? (lambda = _2[0] % 360 * radians2, phi2 = _2[1] % 360 * radians2, recenter()) : [lambda * degrees2, phi2 * degrees2];
    };
    projection3.rotate = function(_2) {
      return arguments.length ? (deltaLambda = _2[0] % 360 * radians2, deltaPhi = _2[1] % 360 * radians2, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees2, deltaPhi * degrees2, deltaGamma * degrees2];
    };
    projection3.angle = function(_2) {
      return arguments.length ? (alpha = _2 % 360 * radians2, recenter()) : alpha * degrees2;
    };
    projection3.reflectX = function(_2) {
      return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
    };
    projection3.reflectY = function(_2) {
      return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
    };
    projection3.precision = function(_2) {
      return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _2 * _2), reset()) : sqrt2(delta2);
    };
    projection3.fitExtent = function(extent2, object) {
      return fitExtent(projection3, extent2, object);
    };
    projection3.fitSize = function(size2, object) {
      return fitSize(projection3, size2, object);
    };
    projection3.fitWidth = function(width, object) {
      return fitWidth(projection3, width, object);
    };
    projection3.fitHeight = function(height, object) {
      return fitHeight(projection3, height, object);
    };
    function recenter() {
      var center2 = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform = scaleTranslateRotate(k, x3 - center2[0], y3 - center2[1], sx, sy, alpha);
      rotate5 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
      projectTransform = compose_default(project, transform);
      projectRotateTransform = compose_default(rotate5, projectTransform);
      projectResample = resample_default(projectTransform, delta2);
      return reset();
    }
    function reset() {
      cache3 = cacheStream = null;
      return projection3;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection3.invert = project.invert && invert5;
      return recenter();
    };
  }

  // node_modules/d3-geo/src/projection/conic.js
  function conicProjection(projectAt) {
    var phi0 = 0, phi1 = pi3 / 3, m3 = projectionMutator(projectAt), p2 = m3(phi0, phi1);
    p2.parallels = function(_2) {
      return arguments.length ? m3(phi0 = _2[0] * radians2, phi1 = _2[1] * radians2) : [phi0 * degrees2, phi1 * degrees2];
    };
    return p2;
  }

  // node_modules/d3-geo/src/projection/cylindricalEqualArea.js
  function cylindricalEqualAreaRaw(phi0) {
    var cosPhi0 = cos2(phi0);
    function forward(lambda, phi2) {
      return [lambda * cosPhi0, sin2(phi2) / cosPhi0];
    }
    forward.invert = function(x3, y3) {
      return [x3 / cosPhi0, asin2(y3 * cosPhi0)];
    };
    return forward;
  }

  // node_modules/d3-geo/src/projection/conicEqualArea.js
  function conicEqualAreaRaw(y05, y12) {
    var sy0 = sin2(y05), n2 = (sy0 + sin2(y12)) / 2;
    if (abs2(n2) < epsilon3) return cylindricalEqualAreaRaw(y05);
    var c5 = 1 + sy0 * (2 * n2 - sy0), r0 = sqrt2(c5) / n2;
    function project(x3, y3) {
      var r = sqrt2(c5 - 2 * n2 * sin2(y3)) / n2;
      return [r * sin2(x3 *= n2), r0 - r * cos2(x3)];
    }
    project.invert = function(x3, y3) {
      var r0y = r0 - y3, l2 = atan22(x3, abs2(r0y)) * sign2(r0y);
      if (r0y * n2 < 0)
        l2 -= pi3 * sign2(x3) * sign2(r0y);
      return [l2 / n2, asin2((c5 - (x3 * x3 + r0y * r0y) * n2 * n2) / (2 * n2))];
    };
    return project;
  }
  function conicEqualArea_default() {
    return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
  }

  // node_modules/d3-geo/src/projection/albers.js
  function albers_default() {
    return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
  }

  // node_modules/d3-geo/src/projection/albersUsa.js
  function multiplex(streams) {
    var n2 = streams.length;
    return {
      point: function(x3, y3) {
        var i = -1;
        while (++i < n2) streams[i].point(x3, y3);
      },
      sphere: function() {
        var i = -1;
        while (++i < n2) streams[i].sphere();
      },
      lineStart: function() {
        var i = -1;
        while (++i < n2) streams[i].lineStart();
      },
      lineEnd: function() {
        var i = -1;
        while (++i < n2) streams[i].lineEnd();
      },
      polygonStart: function() {
        var i = -1;
        while (++i < n2) streams[i].polygonStart();
      },
      polygonEnd: function() {
        var i = -1;
        while (++i < n2) streams[i].polygonEnd();
      }
    };
  }
  function albersUsa_default() {
    var cache3, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x3, y3) {
      point6 = [x3, y3];
    } };
    function albersUsa(coordinates) {
      var x3 = coordinates[0], y3 = coordinates[1];
      return point6 = null, (lower48Point.point(x3, y3), point6) || (alaskaPoint.point(x3, y3), point6) || (hawaiiPoint.point(x3, y3), point6);
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x3 = (coordinates[0] - t[0]) / k, y3 = (coordinates[1] - t[1]) / k;
      return (y3 >= 0.12 && y3 < 0.234 && x3 >= -0.425 && x3 < -0.214 ? alaska : y3 >= 0.166 && y3 < 0.234 && x3 >= -0.214 && x3 < -0.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      return cache3 && cacheStream === stream ? cache3 : cache3 = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
    };
    albersUsa.precision = function(_2) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
      return reset();
    };
    albersUsa.scale = function(_2) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_2) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x3 = +_2[0], y3 = +_2[1];
      lower48Point = lower48.translate(_2).clipExtent([[x3 - 0.455 * k, y3 - 0.238 * k], [x3 + 0.455 * k, y3 + 0.238 * k]]).stream(pointStream);
      alaskaPoint = alaska.translate([x3 - 0.307 * k, y3 + 0.201 * k]).clipExtent([[x3 - 0.425 * k + epsilon3, y3 + 0.12 * k + epsilon3], [x3 - 0.214 * k - epsilon3, y3 + 0.234 * k - epsilon3]]).stream(pointStream);
      hawaiiPoint = hawaii.translate([x3 - 0.205 * k, y3 + 0.212 * k]).clipExtent([[x3 - 0.214 * k + epsilon3, y3 + 0.166 * k + epsilon3], [x3 - 0.115 * k - epsilon3, y3 + 0.234 * k - epsilon3]]).stream(pointStream);
      return reset();
    };
    albersUsa.fitExtent = function(extent2, object) {
      return fitExtent(albersUsa, extent2, object);
    };
    albersUsa.fitSize = function(size2, object) {
      return fitSize(albersUsa, size2, object);
    };
    albersUsa.fitWidth = function(width, object) {
      return fitWidth(albersUsa, width, object);
    };
    albersUsa.fitHeight = function(height, object) {
      return fitHeight(albersUsa, height, object);
    };
    function reset() {
      cache3 = cacheStream = null;
      return albersUsa;
    }
    return albersUsa.scale(1070);
  }

  // node_modules/d3-geo/src/projection/azimuthal.js
  function azimuthalRaw(scale10) {
    return function(x3, y3) {
      var cx = cos2(x3), cy = cos2(y3), k = scale10(cx * cy);
      if (k === Infinity) return [2, 0];
      return [
        k * cy * sin2(x3),
        k * sin2(y3)
      ];
    };
  }
  function azimuthalInvert(angle4) {
    return function(x3, y3) {
      var z = sqrt2(x3 * x3 + y3 * y3), c5 = angle4(z), sc = sin2(c5), cc = cos2(c5);
      return [
        atan22(x3 * sc, z * cc),
        asin2(z && y3 * sc / z)
      ];
    };
  }

  // node_modules/d3-geo/src/projection/azimuthalEqualArea.js
  var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
    return sqrt2(2 / (1 + cxcy));
  });
  azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
    return 2 * asin2(z / 2);
  });
  function azimuthalEqualArea_default() {
    return projection2(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
  }

  // node_modules/d3-geo/src/projection/azimuthalEquidistant.js
  var azimuthalEquidistantRaw = azimuthalRaw(function(c5) {
    return (c5 = acos2(c5)) && c5 / sin2(c5);
  });
  azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
    return z;
  });
  function azimuthalEquidistant_default() {
    return projection2(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
  }

  // node_modules/d3-geo/src/projection/mercator.js
  function mercatorRaw(lambda, phi2) {
    return [lambda, log(tan((halfPi2 + phi2) / 2))];
  }
  mercatorRaw.invert = function(x3, y3) {
    return [x3, 2 * atan(exp2(y3)) - halfPi2];
  };
  function mercator_default() {
    return mercatorProjection(mercatorRaw).scale(961 / tau3);
  }
  function mercatorProjection(project) {
    var m3 = projection2(project), center2 = m3.center, scale10 = m3.scale, translate5 = m3.translate, clipExtent = m3.clipExtent, x05 = null, y05, x12, y12;
    m3.scale = function(_2) {
      return arguments.length ? (scale10(_2), reclip()) : scale10();
    };
    m3.translate = function(_2) {
      return arguments.length ? (translate5(_2), reclip()) : translate5();
    };
    m3.center = function(_2) {
      return arguments.length ? (center2(_2), reclip()) : center2();
    };
    m3.clipExtent = function(_2) {
      return arguments.length ? (_2 == null ? x05 = y05 = x12 = y12 = null : (x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x12, y12]];
    };
    function reclip() {
      var k = pi3 * scale10(), t = m3(rotation_default(m3.rotate()).invert([0, 0]));
      return clipExtent(x05 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x05), y05], [Math.min(t[0] + k, x12), y12]] : [[x05, Math.max(t[1] - k, y05)], [x12, Math.min(t[1] + k, y12)]]);
    }
    return reclip();
  }

  // node_modules/d3-geo/src/projection/conicConformal.js
  function tany(y3) {
    return tan((halfPi2 + y3) / 2);
  }
  function conicConformalRaw(y05, y12) {
    var cy0 = cos2(y05), n2 = y05 === y12 ? sin2(y05) : log(cy0 / cos2(y12)) / log(tany(y12) / tany(y05)), f = cy0 * pow2(tany(y05), n2) / n2;
    if (!n2) return mercatorRaw;
    function project(x3, y3) {
      if (f > 0) {
        if (y3 < -halfPi2 + epsilon3) y3 = -halfPi2 + epsilon3;
      } else {
        if (y3 > halfPi2 - epsilon3) y3 = halfPi2 - epsilon3;
      }
      var r = f / pow2(tany(y3), n2);
      return [r * sin2(n2 * x3), f - r * cos2(n2 * x3)];
    }
    project.invert = function(x3, y3) {
      var fy = f - y3, r = sign2(n2) * sqrt2(x3 * x3 + fy * fy), l2 = atan22(x3, abs2(fy)) * sign2(fy);
      if (fy * n2 < 0)
        l2 -= pi3 * sign2(x3) * sign2(fy);
      return [l2 / n2, 2 * atan(pow2(f / r, 1 / n2)) - halfPi2];
    };
    return project;
  }
  function conicConformal_default() {
    return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
  }

  // node_modules/d3-geo/src/projection/equirectangular.js
  function equirectangularRaw(lambda, phi2) {
    return [lambda, phi2];
  }
  equirectangularRaw.invert = equirectangularRaw;
  function equirectangular_default() {
    return projection2(equirectangularRaw).scale(152.63);
  }

  // node_modules/d3-geo/src/projection/conicEquidistant.js
  function conicEquidistantRaw(y05, y12) {
    var cy0 = cos2(y05), n2 = y05 === y12 ? sin2(y05) : (cy0 - cos2(y12)) / (y12 - y05), g = cy0 / n2 + y05;
    if (abs2(n2) < epsilon3) return equirectangularRaw;
    function project(x3, y3) {
      var gy = g - y3, nx = n2 * x3;
      return [gy * sin2(nx), g - gy * cos2(nx)];
    }
    project.invert = function(x3, y3) {
      var gy = g - y3, l2 = atan22(x3, abs2(gy)) * sign2(gy);
      if (gy * n2 < 0)
        l2 -= pi3 * sign2(x3) * sign2(gy);
      return [l2 / n2, g - sign2(n2) * sqrt2(x3 * x3 + gy * gy)];
    };
    return project;
  }
  function conicEquidistant_default() {
    return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
  }

  // node_modules/d3-geo/src/projection/equalEarth.js
  var A1 = 1.340264;
  var A22 = -0.081106;
  var A32 = 893e-6;
  var A4 = 3796e-6;
  var M = sqrt2(3) / 2;
  var iterations = 12;
  function equalEarthRaw(lambda, phi2) {
    var l2 = asin2(M * sin2(phi2)), l22 = l2 * l2, l6 = l22 * l22 * l22;
    return [
      lambda * cos2(l2) / (M * (A1 + 3 * A22 * l22 + l6 * (7 * A32 + 9 * A4 * l22))),
      l2 * (A1 + A22 * l22 + l6 * (A32 + A4 * l22))
    ];
  }
  equalEarthRaw.invert = function(x3, y3) {
    var l2 = y3, l22 = l2 * l2, l6 = l22 * l22 * l22;
    for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
      fy = l2 * (A1 + A22 * l22 + l6 * (A32 + A4 * l22)) - y3;
      fpy = A1 + 3 * A22 * l22 + l6 * (7 * A32 + 9 * A4 * l22);
      l2 -= delta = fy / fpy, l22 = l2 * l2, l6 = l22 * l22 * l22;
      if (abs2(delta) < epsilon22) break;
    }
    return [
      M * x3 * (A1 + 3 * A22 * l22 + l6 * (7 * A32 + 9 * A4 * l22)) / cos2(l2),
      asin2(sin2(l2) / M)
    ];
  };
  function equalEarth_default() {
    return projection2(equalEarthRaw).scale(177.158);
  }

  // node_modules/d3-geo/src/projection/gnomonic.js
  function gnomonicRaw(x3, y3) {
    var cy = cos2(y3), k = cos2(x3) * cy;
    return [cy * sin2(x3) / k, sin2(y3) / k];
  }
  gnomonicRaw.invert = azimuthalInvert(atan);
  function gnomonic_default() {
    return projection2(gnomonicRaw).scale(144.049).clipAngle(60);
  }

  // node_modules/d3-geo/src/projection/identity.js
  function identity_default4() {
    var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x05 = null, y05, x12, y12, kx = 1, ky = 1, transform = transformer({
      point: function(x3, y3) {
        var p2 = projection3([x3, y3]);
        this.stream.point(p2[0], p2[1]);
      }
    }), postclip = identity_default3, cache3, cacheStream;
    function reset() {
      kx = k * sx;
      ky = k * sy;
      cache3 = cacheStream = null;
      return projection3;
    }
    function projection3(p2) {
      var x3 = p2[0] * kx, y3 = p2[1] * ky;
      if (alpha) {
        var t = y3 * ca - x3 * sa;
        x3 = x3 * ca + y3 * sa;
        y3 = t;
      }
      return [x3 + tx, y3 + ty];
    }
    projection3.invert = function(p2) {
      var x3 = p2[0] - tx, y3 = p2[1] - ty;
      if (alpha) {
        var t = y3 * ca + x3 * sa;
        x3 = x3 * ca - y3 * sa;
        y3 = t;
      }
      return [x3 / kx, y3 / ky];
    };
    projection3.stream = function(stream) {
      return cache3 && cacheStream === stream ? cache3 : cache3 = transform(postclip(cacheStream = stream));
    };
    projection3.postclip = function(_2) {
      return arguments.length ? (postclip = _2, x05 = y05 = x12 = y12 = null, reset()) : postclip;
    };
    projection3.clipExtent = function(_2) {
      return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x12 = y12 = null, identity_default3) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
    };
    projection3.scale = function(_2) {
      return arguments.length ? (k = +_2, reset()) : k;
    };
    projection3.translate = function(_2) {
      return arguments.length ? (tx = +_2[0], ty = +_2[1], reset()) : [tx, ty];
    };
    projection3.angle = function(_2) {
      return arguments.length ? (alpha = _2 % 360 * radians2, sa = sin2(alpha), ca = cos2(alpha), reset()) : alpha * degrees2;
    };
    projection3.reflectX = function(_2) {
      return arguments.length ? (sx = _2 ? -1 : 1, reset()) : sx < 0;
    };
    projection3.reflectY = function(_2) {
      return arguments.length ? (sy = _2 ? -1 : 1, reset()) : sy < 0;
    };
    projection3.fitExtent = function(extent2, object) {
      return fitExtent(projection3, extent2, object);
    };
    projection3.fitSize = function(size2, object) {
      return fitSize(projection3, size2, object);
    };
    projection3.fitWidth = function(width, object) {
      return fitWidth(projection3, width, object);
    };
    projection3.fitHeight = function(height, object) {
      return fitHeight(projection3, height, object);
    };
    return projection3;
  }

  // node_modules/d3-geo/src/projection/naturalEarth1.js
  function naturalEarth1Raw(lambda, phi2) {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    return [
      lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
      phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
    ];
  }
  naturalEarth1Raw.invert = function(x3, y3) {
    var phi2 = y3, i = 25, delta;
    do {
      var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
      phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y3) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
    } while (abs2(delta) > epsilon3 && --i > 0);
    return [
      x3 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
      phi2
    ];
  };
  function naturalEarth1_default() {
    return projection2(naturalEarth1Raw).scale(175.295);
  }

  // node_modules/d3-geo/src/projection/orthographic.js
  function orthographicRaw(x3, y3) {
    return [cos2(y3) * sin2(x3), sin2(y3)];
  }
  orthographicRaw.invert = azimuthalInvert(asin2);
  function orthographic_default() {
    return projection2(orthographicRaw).scale(249.5).clipAngle(90 + epsilon3);
  }

  // node_modules/d3-geo/src/projection/stereographic.js
  function stereographicRaw(x3, y3) {
    var cy = cos2(y3), k = 1 + cos2(x3) * cy;
    return [cy * sin2(x3) / k, sin2(y3) / k];
  }
  stereographicRaw.invert = azimuthalInvert(function(z) {
    return 2 * atan(z);
  });
  function stereographic_default() {
    return projection2(stereographicRaw).scale(250).clipAngle(142);
  }

  // node_modules/d3-geo/src/projection/transverseMercator.js
  function transverseMercatorRaw(lambda, phi2) {
    return [log(tan((halfPi2 + phi2) / 2)), -lambda];
  }
  transverseMercatorRaw.invert = function(x3, y3) {
    return [-y3, 2 * atan(exp2(x3)) - halfPi2];
  };
  function transverseMercator_default() {
    var m3 = mercatorProjection(transverseMercatorRaw), center2 = m3.center, rotate5 = m3.rotate;
    m3.center = function(_2) {
      return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
    };
    m3.rotate = function(_2) {
      return arguments.length ? rotate5([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate5(), [_2[0], _2[1], _2[2] - 90]);
    };
    return rotate5([0, 0, 90]).scale(159.155);
  }

  // node_modules/@antv/g2/esm/composition/d3Projection.js
  var d3Projection_exports = {};
  __export(d3Projection_exports, {
    geoAlbers: () => albers_default,
    geoAlbersUsa: () => albersUsa_default,
    geoAzimuthalEqualArea: () => azimuthalEqualArea_default,
    geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,
    geoAzimuthalEquidistant: () => azimuthalEquidistant_default,
    geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,
    geoConicConformal: () => conicConformal_default,
    geoConicConformalRaw: () => conicConformalRaw,
    geoConicEqualArea: () => conicEqualArea_default,
    geoConicEqualAreaRaw: () => conicEqualAreaRaw,
    geoConicEquidistant: () => conicEquidistant_default,
    geoConicEquidistantRaw: () => conicEquidistantRaw,
    geoEqualEarth: () => equalEarth_default,
    geoEqualEarthRaw: () => equalEarthRaw,
    geoEquirectangular: () => equirectangular_default,
    geoEquirectangularRaw: () => equirectangularRaw,
    geoGnomonic: () => gnomonic_default,
    geoGnomonicRaw: () => gnomonicRaw,
    geoIdentity: () => identity_default4,
    geoMercator: () => mercator_default,
    geoMercatorRaw: () => mercatorRaw,
    geoNaturalEarth1: () => naturalEarth1_default,
    geoNaturalEarth1Raw: () => naturalEarth1Raw,
    geoOrthographic: () => orthographic_default,
    geoOrthographicRaw: () => orthographicRaw,
    geoProjection: () => projection2,
    geoProjectionMutator: () => projectionMutator,
    geoStereographic: () => stereographic_default,
    geoStereographicRaw: () => stereographicRaw,
    geoTransverseMercator: () => transverseMercator_default,
    geoTransverseMercatorRaw: () => transverseMercatorRaw
  });

  // node_modules/@antv/g2/esm/composition/geoView.js
  var __rest70 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function normalizeProjection(type) {
    if (typeof type === "function")
      return type;
    const name2 = `geo${upper_first_default(type)}`;
    const projection3 = d3Projection_exports[name2];
    if (!projection3)
      throw new Error(`Unknown coordinate: ${type}`);
    return projection3;
  }
  function mergeGeoJSON(gjs) {
    return {
      type: "FeatureCollection",
      features: gjs.flatMap((gj) => normalizeGeoJSON(gj).features)
    };
  }
  function normalizeGeoJSON(gj) {
    const types = {
      Point: "geometry",
      MultiPoint: "geometry",
      LineString: "geometry",
      MultiLineString: "geometry",
      Polygon: "geometry",
      MultiPolygon: "geometry",
      GeometryCollection: "geometry",
      Feature: "feature",
      FeatureCollection: "featureCollection"
    };
    if (!gj || !gj.type)
      return null;
    const type = types[gj.type];
    if (!type)
      return null;
    if (type === "geometry") {
      return {
        type: "FeatureCollection",
        features: [
          {
            type: "Feature",
            properties: {},
            geometry: gj
          }
        ]
      };
    } else if (type === "feature") {
      return {
        type: "FeatureCollection",
        features: [gj]
      };
    } else if (type === "featureCollection") {
      return gj;
    }
  }
  function setProjectionOptions(projection3, options) {
    var _a;
    for (const [key, value2] of Object.entries(options)) {
      (_a = projection3[key]) === null || _a === void 0 ? void 0 : _a.call(projection3, value2);
    }
  }
  function setProjectionSize(projection3, nodes, layout, options) {
    const defaultOutline = () => {
      const geoNodes = nodes.filter(isGeoPath);
      const sphere = geoNodes.find((d3) => d3.sphere);
      if (sphere)
        return { type: "Sphere" };
      return mergeGeoJSON(geoNodes.filter((d3) => !d3.sphere).flatMap((d3) => d3.data.value));
    };
    const { outline = defaultOutline() } = options;
    const { size: size2 = "fitExtent" } = options;
    if (size2 === "fitExtent") {
      return setFitExtent(projection3, outline, layout);
    } else if (size2 === "fitWidth") {
      return setFitWidth(projection3, outline, layout);
    }
  }
  function setFitExtent(projection3, object, layout) {
    const { x: x3, y: y3, width, height } = layout;
    projection3.fitExtent([
      [x3, y3],
      [width, height]
    ], object);
  }
  function setFitWidth(projection3, object, layout) {
    const { width, height } = layout;
    const [[x05, y05], [x12, y12]] = path_default2(projection3.fitWidth(width, object)).bounds(object);
    const dy = Math.ceil(y12 - y05);
    const l2 = Math.min(Math.ceil(x12 - x05), dy);
    const s3 = projection3.scale() * (l2 - 1) / l2;
    const [tx, ty] = projection3.translate();
    const t = ty + (height - dy) / 2;
    projection3.scale(s3).translate([tx, t]).precision(0.2);
  }
  function normalizeDataSource(node) {
    const { data: data2 } = node;
    if (Array.isArray(data2))
      return Object.assign(Object.assign({}, node), { data: { value: data2 } });
    const { type } = data2;
    if (type === "graticule10") {
      return Object.assign(Object.assign({}, node), { data: { value: [graticule10()] } });
    } else if (type === "sphere") {
      return Object.assign(Object.assign({}, node), { sphere: true, data: { value: [{ type: "Sphere" }] } });
    }
    return node;
  }
  function isGeoPath(d3) {
    return d3.type === "geoPath";
  }
  var GeoView = () => {
    return (options) => {
      const { children, coordinate: projection3 = {} } = options;
      if (!Array.isArray(children))
        return [];
      const { type = "equalEarth" } = projection3, projectionOptions = __rest70(projection3, ["type"]);
      const createProjection = normalizeProjection(type);
      const nodes = children.map(normalizeDataSource);
      let path2;
      function Geo() {
        return [
          [
            "custom",
            (x3, y3, width, height) => {
              const visual = createProjection();
              const layout = { x: x3, y: y3, width, height };
              setProjectionSize(visual, nodes, layout, projectionOptions);
              setProjectionOptions(visual, projectionOptions);
              path2 = path_default2(visual);
              const scaleX2 = new Linear({
                domain: [x3, x3 + width]
              });
              const scaleY2 = new Linear({
                domain: [y3, y3 + height]
              });
              const normalize9 = (point6) => {
                const visualPoint = visual(point6);
                if (!visualPoint)
                  return [null, null];
                const [vx, vy] = visualPoint;
                return [scaleX2.map(vx), scaleY2.map(vy)];
              };
              const normalizeInvert = (point6) => {
                if (!point6)
                  return null;
                const [px2, py] = point6;
                const visualPoint = [scaleX2.invert(px2), scaleY2.invert(py)];
                return visual.invert(visualPoint);
              };
              return {
                transform: (point6) => normalize9(point6),
                untransform: (point6) => normalizeInvert(point6)
              };
            }
          ]
        ];
      }
      function GeoPath2(options2) {
        const { style, tooltip: tooltip2 = {} } = options2;
        return Object.assign(Object.assign({}, options2), { type: "path", tooltip: maybeTooltip(tooltip2, {
          title: "id",
          items: [{ channel: "color" }]
        }), style: Object.assign(Object.assign({}, style), { d: (d3) => path2(d3) || [] }) });
      }
      const t = (d3) => isGeoPath(d3) ? GeoPath2(d3) : d3;
      return [
        Object.assign(Object.assign({}, options), { type: "view", scale: {
          x: { type: "identity" },
          y: { type: "identity" }
        }, axis: false, coordinate: { type: Geo }, children: nodes.flatMap(t) })
      ];
    };
  };
  GeoView.props = {};

  // node_modules/@antv/g2/esm/interaction/event.js
  function dataOf(element, view) {
    const { __data__: datum } = element;
    const { markKey, index: index4, seriesIndex } = datum;
    const { markState } = view;
    const selectedMark = Array.from(markState.keys()).find((mark) => mark.key === markKey);
    if (!selectedMark)
      return;
    if (seriesIndex) {
      return seriesIndex.map((i) => selectedMark.data[i]);
    }
    return selectedMark.data[index4];
  }
  function maybeComponentRoot(node) {
    return maybeRoot(node, (node2) => node2.className === "component");
  }
  function maybeElementRoot(node) {
    return maybeRoot(node, (node2) => node2.className === "element");
  }
  function maybeLabelRoot(node) {
    return maybeRoot(node, (node2) => node2.className === "label");
  }
  function bubblesEvent(eventType, view, emitter, predicate = (event) => true) {
    return (e3) => {
      if (!predicate(e3))
        return;
      emitter.emit(`plot:${eventType}`, e3);
      const { target } = e3;
      if (!target)
        return;
      const { className: className2 } = target;
      if (className2 === "plot")
        return;
      const elementRoot = maybeElementRoot(target);
      const componentRoot = maybeComponentRoot(target);
      const babelRoot = maybeLabelRoot(target);
      const root2 = elementRoot || componentRoot || babelRoot;
      if (!root2)
        return;
      const { className: elementType2, markType } = root2;
      const e1 = Object.assign(Object.assign({}, e3), { nativeEvent: true });
      if (elementType2 === "element") {
        e1["data"] = { data: dataOf(root2, view) };
        emitter.emit(`element:${eventType}`, e1);
        emitter.emit(`${markType}:${eventType}`, e1);
      } else if (elementType2 === "label") {
        e1["data"] = { data: root2.attributes.datum };
        emitter.emit(`label:${eventType}`, e1);
        emitter.emit(`${className2}:${eventType}`, e1);
      } else {
        emitter.emit(`component:${eventType}`, e1);
        emitter.emit(`${className2}:${eventType}`, e1);
      }
    };
  }
  function Event2() {
    return (context, _2, emitter) => {
      const { container, view } = context;
      const click = bubblesEvent(ChartEvent.CLICK, view, emitter, (e3) => e3.detail === 1);
      const dblclick2 = bubblesEvent(ChartEvent.DBLCLICK, view, emitter, (e3) => e3.detail === 2);
      const pointertap = bubblesEvent(ChartEvent.POINTER_TAP, view, emitter);
      const pointerdown = bubblesEvent(ChartEvent.POINTER_DOWN, view, emitter);
      const pointerup = bubblesEvent(ChartEvent.POINTER_UP, view, emitter);
      const pointerover = bubblesEvent(ChartEvent.POINTER_OVER, view, emitter);
      const pointerout = bubblesEvent(ChartEvent.POINTER_OUT, view, emitter);
      const pointermove = bubblesEvent(ChartEvent.POINTER_MOVE, view, emitter);
      const pointerenter = bubblesEvent(ChartEvent.POINTER_ENTER, view, emitter);
      const pointerleave = bubblesEvent(ChartEvent.POINTER_LEAVE, view, emitter);
      const pointerupoutside = bubblesEvent(ChartEvent.POINTER_UPOUTSIDE, view, emitter);
      const dragstart = bubblesEvent(ChartEvent.DRAG_START, view, emitter);
      const drag = bubblesEvent(ChartEvent.DRAG, view, emitter);
      const dragend = bubblesEvent(ChartEvent.DRAG_END, view, emitter);
      const dragenter = bubblesEvent(ChartEvent.DRAG_ENTER, view, emitter);
      const dragleave = bubblesEvent(ChartEvent.DRAG_LEAVE, view, emitter);
      const dragover = bubblesEvent(ChartEvent.DRAG_OVER, view, emitter);
      const drop3 = bubblesEvent(ChartEvent.DROP, view, emitter);
      container.addEventListener("click", click);
      container.addEventListener("click", dblclick2);
      container.addEventListener("pointertap", pointertap);
      container.addEventListener("pointerdown", pointerdown);
      container.addEventListener("pointerup", pointerup);
      container.addEventListener("pointerover", pointerover);
      container.addEventListener("pointerout", pointerout);
      container.addEventListener("pointermove", pointermove);
      container.addEventListener("pointerenter", pointerenter);
      container.addEventListener("pointerleave", pointerleave);
      container.addEventListener("pointerupoutside", pointerupoutside);
      container.addEventListener("dragstart", dragstart);
      container.addEventListener("drag", drag);
      container.addEventListener("dragend", dragend);
      container.addEventListener("dragenter", dragenter);
      container.addEventListener("dragleave", dragleave);
      container.addEventListener("dragover", dragover);
      container.addEventListener("drop", drop3);
      return () => {
        container.removeEventListener("click", click);
        container.removeEventListener("click", dblclick2);
        container.removeEventListener("pointertap", pointertap);
        container.removeEventListener("pointerdown", pointerdown);
        container.removeEventListener("pointerup", pointerup);
        container.removeEventListener("pointerover", pointerover);
        container.removeEventListener("pointerout", pointerout);
        container.removeEventListener("pointermove", pointermove);
        container.removeEventListener("pointerenter", pointerenter);
        container.removeEventListener("pointerleave", pointerleave);
        container.removeEventListener("pointerupoutside", pointerupoutside);
        container.removeEventListener("dragstart", dragstart);
        container.removeEventListener("drag", drag);
        container.removeEventListener("dragend", dragend);
        container.removeEventListener("dragenter", dragenter);
        container.removeEventListener("dragleave", dragleave);
        container.removeEventListener("dragover", dragover);
        container.removeEventListener("drop", drop3);
      };
    };
  }
  Event2.props = {
    reapplyWhenUpdate: true
  };

  // node_modules/@antv/g2/esm/lib/builtinlib.js
  function builtinlib() {
    return {
      "component.axisRadar": AxisRadar,
      "component.axisLinear": LinearAxis,
      "component.axisArc": ArcAxis,
      "component.legendContinuousBlock": LegendContinuousBlock,
      "component.legendContinuousBlockSize": LegendContinuousBlockSize,
      "component.legendContinuousSize": LegendContinuousSize,
      "interaction.event": Event2,
      "composition.mark": Mark,
      "composition.view": View2,
      "shape.label.label": Label
    };
  }

  // node_modules/@antv/g2/esm/runtime/library.js
  var __rest71 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function useLibrary(namespace, publicLibrary) {
    const library3 = Object.assign(Object.assign({}, builtinlib()), publicLibrary);
    const create8 = (type) => {
      if (typeof type !== "string")
        return type;
      const key = `${namespace}.${type}`;
      return library3[key] || error2(`Unknown Component: ${key}`);
    };
    const use = (options, context) => {
      const { type } = options, rest = __rest71(options, ["type"]);
      if (!type)
        error2(`Plot type is required!`);
      const currentLibrary = create8(type);
      return currentLibrary === null || currentLibrary === void 0 ? void 0 : currentLibrary(rest, context);
    };
    return [use, create8];
  }
  function documentOf(library3) {
    const { canvas, group: group3 } = library3;
    return (canvas === null || canvas === void 0 ? void 0 : canvas.document) || (group3 === null || group3 === void 0 ? void 0 : group3.ownerDocument) || error2(`Cannot find library document`);
  }

  // node_modules/@antv/g2/esm/runtime/coordinate.js
  var __rest72 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function createCoordinate(layout, partialOptions, library3) {
    const [useCoordinate] = useLibrary("coordinate", library3);
    const { innerHeight, innerWidth, insetLeft, insetTop, insetRight, insetBottom } = layout;
    const { coordinates: partialTransform = [] } = partialOptions;
    const transform = inferCoordinate(partialTransform);
    const isCartesian3D = transform[0].type === "cartesian3D";
    const options = Object.assign(Object.assign({}, layout), { x: insetLeft, y: insetTop, width: innerWidth - insetLeft - insetRight, height: innerHeight - insetBottom - insetTop, transformations: transform.flatMap(useCoordinate) });
    const coordinate = isCartesian3D ? (
      // @ts-ignore
      new import_coord.Coordinate3D(options)
    ) : new import_coord.Coordinate(options);
    return coordinate;
  }
  function coordinate2Transform(node, library3) {
    const { coordinate = {}, coordinates } = node, rest = __rest72(node, ["coordinate", "coordinates"]);
    if (coordinates)
      return node;
    const { type, transform = [] } = coordinate, options = __rest72(coordinate, ["type", "transform"]);
    if (!type)
      return Object.assign(Object.assign({}, rest), { coordinates: transform });
    const [, createCoordinate2] = useLibrary("coordinate", library3);
    const { transform: isTransform = false } = createCoordinate2(type).props || {};
    if (isTransform) {
      throw new Error(`Unknown coordinate: ${type}.`);
    }
    return Object.assign(Object.assign({}, rest), { coordinates: [Object.assign({ type }, options), ...transform] });
  }
  function coordOf(coordinates, type) {
    return coordinates.filter((d3) => d3.type === type);
  }
  function isPolar2(coordinates) {
    return coordOf(coordinates, "polar").length > 0;
  }
  function isHelix2(coordinates) {
    return coordOf(coordinates, "helix").length > 0;
  }
  function isTranspose2(coordinates) {
    return coordOf(coordinates, "transpose").length % 2 === 1;
  }
  function isParallel2(coordinates) {
    return coordOf(coordinates, "parallel").length > 0;
  }
  function isTheta2(coordinates) {
    return coordOf(coordinates, "theta").length > 0;
  }
  function isReflect(coordinates) {
    return coordOf(coordinates, "reflect").length > 0;
  }
  function isRadial2(coordinates) {
    return coordOf(coordinates, "radial").length > 0;
  }
  function isRadar2(coordinates) {
    return coordOf(coordinates, "radar").length > 0;
  }
  function isReflectY(coordinates) {
    return coordOf(coordinates, "reflectY").length > 0;
  }
  function inferCoordinate(coordinates) {
    if (coordinates.find((d3) => d3.type === "cartesian" || d3.type === "cartesian3D"))
      return coordinates;
    return [...coordinates, { type: "cartesian" }];
  }

  // node_modules/d3-scale-chromatic/src/index.js
  var src_exports3 = {};
  __export(src_exports3, {
    interpolateBlues: () => Blues_default,
    interpolateBrBG: () => BrBG_default,
    interpolateBuGn: () => BuGn_default,
    interpolateBuPu: () => BuPu_default,
    interpolateCividis: () => cividis_default,
    interpolateCool: () => cool,
    interpolateCubehelixDefault: () => cubehelix_default2,
    interpolateGnBu: () => GnBu_default,
    interpolateGreens: () => Greens_default,
    interpolateGreys: () => Greys_default,
    interpolateInferno: () => inferno,
    interpolateMagma: () => magma,
    interpolateOrRd: () => OrRd_default,
    interpolateOranges: () => Oranges_default,
    interpolatePRGn: () => PRGn_default,
    interpolatePiYG: () => PiYG_default,
    interpolatePlasma: () => plasma,
    interpolatePuBu: () => PuBu_default,
    interpolatePuBuGn: () => PuBuGn_default,
    interpolatePuOr: () => PuOr_default,
    interpolatePuRd: () => PuRd_default,
    interpolatePurples: () => Purples_default,
    interpolateRainbow: () => rainbow_default,
    interpolateRdBu: () => RdBu_default,
    interpolateRdGy: () => RdGy_default,
    interpolateRdPu: () => RdPu_default,
    interpolateRdYlBu: () => RdYlBu_default,
    interpolateRdYlGn: () => RdYlGn_default,
    interpolateReds: () => Reds_default,
    interpolateSinebow: () => sinebow_default,
    interpolateSpectral: () => Spectral_default,
    interpolateTurbo: () => turbo_default,
    interpolateViridis: () => viridis_default,
    interpolateWarm: () => warm,
    interpolateYlGn: () => YlGn_default,
    interpolateYlGnBu: () => YlGnBu_default,
    interpolateYlOrBr: () => YlOrBr_default,
    interpolateYlOrRd: () => YlOrRd_default,
    schemeAccent: () => Accent_default,
    schemeBlues: () => scheme22,
    schemeBrBG: () => scheme,
    schemeBuGn: () => scheme10,
    schemeBuPu: () => scheme11,
    schemeCategory10: () => category10_default,
    schemeDark2: () => Dark2_default,
    schemeGnBu: () => scheme12,
    schemeGreens: () => scheme23,
    schemeGreys: () => scheme24,
    schemeObservable10: () => observable10_default,
    schemeOrRd: () => scheme13,
    schemeOranges: () => scheme27,
    schemePRGn: () => scheme2,
    schemePaired: () => Paired_default,
    schemePastel1: () => Pastel1_default,
    schemePastel2: () => Pastel2_default,
    schemePiYG: () => scheme3,
    schemePuBu: () => scheme15,
    schemePuBuGn: () => scheme14,
    schemePuOr: () => scheme4,
    schemePuRd: () => scheme16,
    schemePurples: () => scheme25,
    schemeRdBu: () => scheme5,
    schemeRdGy: () => scheme6,
    schemeRdPu: () => scheme17,
    schemeRdYlBu: () => scheme7,
    schemeRdYlGn: () => scheme8,
    schemeReds: () => scheme26,
    schemeSet1: () => Set1_default,
    schemeSet2: () => Set2_default,
    schemeSet3: () => Set3_default,
    schemeSpectral: () => scheme9,
    schemeTableau10: () => Tableau10_default,
    schemeYlGn: () => scheme19,
    schemeYlGnBu: () => scheme18,
    schemeYlOrBr: () => scheme20,
    schemeYlOrRd: () => scheme21
  });

  // node_modules/d3-scale-chromatic/src/colors.js
  function colors_default(specifier) {
    var n2 = specifier.length / 6 | 0, colors = new Array(n2), i = 0;
    while (i < n2) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
    return colors;
  }

  // node_modules/d3-scale-chromatic/src/categorical/category10.js
  var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

  // node_modules/d3-scale-chromatic/src/categorical/Accent.js
  var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

  // node_modules/d3-scale-chromatic/src/categorical/Dark2.js
  var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

  // node_modules/d3-scale-chromatic/src/categorical/observable10.js
  var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

  // node_modules/d3-scale-chromatic/src/categorical/Paired.js
  var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

  // node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
  var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

  // node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
  var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

  // node_modules/d3-scale-chromatic/src/categorical/Set1.js
  var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

  // node_modules/d3-scale-chromatic/src/categorical/Set2.js
  var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

  // node_modules/d3-scale-chromatic/src/categorical/Set3.js
  var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

  // node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
  var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

  // node_modules/d3-interpolate/src/basis.js
  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values) {
    var n2 = values.length - 1;
    return function(t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n2 - 1) : Math.floor(t * n2), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n2 - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t - i / n2) * n2, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values) {
    var n2 = values.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n2), v0 = values[(i + n2 - 1) % n2], v1 = values[i % n2], v2 = values[(i + 1) % n2], v3 = values[(i + 2) % n2];
      return basis((t - i / n2) * n2, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/constant.js
  var constant_default4 = (x3) => () => x3;

  // node_modules/d3-interpolate/src/color.js
  function linear4(a3, d3) {
    return function(t) {
      return a3 + t * d3;
    };
  }
  function exponential(a3, b, y3) {
    return a3 = Math.pow(a3, y3), b = Math.pow(b, y3) - a3, y3 = 1 / y3, function(t) {
      return Math.pow(a3 + t * b, y3);
    };
  }
  function hue(a3, b) {
    var d3 = b - a3;
    return d3 ? linear4(a3, d3 > 180 || d3 < -180 ? d3 - 360 * Math.round(d3 / 360) : d3) : constant_default4(isNaN(a3) ? b : a3);
  }
  function gamma(y3) {
    return (y3 = +y3) === 1 ? nogamma : function(a3, b) {
      return b - a3 ? exponential(a3, b, y3) : constant_default4(isNaN(a3) ? b : a3);
    };
  }
  function nogamma(a3, b) {
    var d3 = b - a3;
    return d3 ? linear4(a3, d3) : constant_default4(isNaN(a3) ? b : a3);
  }

  // node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y3) {
    var color2 = gamma(y3);
    function rgb2(start2, end) {
      var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.r = r(t);
        start2.g = g(t);
        start2.b = b(t);
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n2 = colors.length, r = new Array(n2), g = new Array(n2), b = new Array(n2), i, color2;
      for (i = 0; i < n2; ++i) {
        color2 = rgb(colors[i]);
        r[i] = color2.r || 0;
        g[i] = color2.g || 0;
        b[i] = color2.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color2.opacity = 1;
      return function(t) {
        color2.r = r(t);
        color2.g = g(t);
        color2.b = b(t);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/d3-interpolate/src/cubehelix.js
  function cubehelix2(hue2) {
    return function cubehelixGamma(y3) {
      y3 = +y3;
      function cubehelix3(start2, end) {
        var h = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s3 = nogamma(start2.s, end.s), l2 = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
        return function(t) {
          start2.h = h(t);
          start2.s = s3(t);
          start2.l = l2(Math.pow(t, y3));
          start2.opacity = opacity(t);
          return start2 + "";
        };
      }
      cubehelix3.gamma = cubehelixGamma;
      return cubehelix3;
    }(1);
  }
  var cubehelix_default = cubehelix2(hue);
  var cubehelixLong = cubehelix2(nogamma);

  // node_modules/d3-scale-chromatic/src/ramp.js
  var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

  // node_modules/d3-scale-chromatic/src/diverging/BrBG.js
  var scheme = new Array(3).concat(
    "d8b365f5f5f55ab4ac",
    "a6611adfc27d80cdc1018571",
    "a6611adfc27df5f5f580cdc1018571",
    "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
    "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
    "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
    "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
    "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
    "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
  ).map(colors_default);
  var BrBG_default = ramp_default(scheme);

  // node_modules/d3-scale-chromatic/src/diverging/PRGn.js
  var scheme2 = new Array(3).concat(
    "af8dc3f7f7f77fbf7b",
    "7b3294c2a5cfa6dba0008837",
    "7b3294c2a5cff7f7f7a6dba0008837",
    "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
    "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
    "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
    "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
    "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
    "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
  ).map(colors_default);
  var PRGn_default = ramp_default(scheme2);

  // node_modules/d3-scale-chromatic/src/diverging/PiYG.js
  var scheme3 = new Array(3).concat(
    "e9a3c9f7f7f7a1d76a",
    "d01c8bf1b6dab8e1864dac26",
    "d01c8bf1b6daf7f7f7b8e1864dac26",
    "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
    "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
    "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
    "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
    "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
    "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
  ).map(colors_default);
  var PiYG_default = ramp_default(scheme3);

  // node_modules/d3-scale-chromatic/src/diverging/PuOr.js
  var scheme4 = new Array(3).concat(
    "998ec3f7f7f7f1a340",
    "5e3c99b2abd2fdb863e66101",
    "5e3c99b2abd2f7f7f7fdb863e66101",
    "542788998ec3d8daebfee0b6f1a340b35806",
    "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
    "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
    "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
    "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
    "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
  ).map(colors_default);
  var PuOr_default = ramp_default(scheme4);

  // node_modules/d3-scale-chromatic/src/diverging/RdBu.js
  var scheme5 = new Array(3).concat(
    "ef8a62f7f7f767a9cf",
    "ca0020f4a58292c5de0571b0",
    "ca0020f4a582f7f7f792c5de0571b0",
    "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
    "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
    "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
    "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
    "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
    "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
  ).map(colors_default);
  var RdBu_default = ramp_default(scheme5);

  // node_modules/d3-scale-chromatic/src/diverging/RdGy.js
  var scheme6 = new Array(3).concat(
    "ef8a62ffffff999999",
    "ca0020f4a582bababa404040",
    "ca0020f4a582ffffffbababa404040",
    "b2182bef8a62fddbc7e0e0e09999994d4d4d",
    "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
    "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
    "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
    "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
    "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
  ).map(colors_default);
  var RdGy_default = ramp_default(scheme6);

  // node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
  var scheme7 = new Array(3).concat(
    "fc8d59ffffbf91bfdb",
    "d7191cfdae61abd9e92c7bb6",
    "d7191cfdae61ffffbfabd9e92c7bb6",
    "d73027fc8d59fee090e0f3f891bfdb4575b4",
    "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
    "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
    "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
    "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
    "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
  ).map(colors_default);
  var RdYlBu_default = ramp_default(scheme7);

  // node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
  var scheme8 = new Array(3).concat(
    "fc8d59ffffbf91cf60",
    "d7191cfdae61a6d96a1a9641",
    "d7191cfdae61ffffbfa6d96a1a9641",
    "d73027fc8d59fee08bd9ef8b91cf601a9850",
    "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
    "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
    "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
    "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
    "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
  ).map(colors_default);
  var RdYlGn_default = ramp_default(scheme8);

  // node_modules/d3-scale-chromatic/src/diverging/Spectral.js
  var scheme9 = new Array(3).concat(
    "fc8d59ffffbf99d594",
    "d7191cfdae61abdda42b83ba",
    "d7191cfdae61ffffbfabdda42b83ba",
    "d53e4ffc8d59fee08be6f59899d5943288bd",
    "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
    "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
    "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
    "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
    "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
  ).map(colors_default);
  var Spectral_default = ramp_default(scheme9);

  // node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
  var scheme10 = new Array(3).concat(
    "e5f5f999d8c92ca25f",
    "edf8fbb2e2e266c2a4238b45",
    "edf8fbb2e2e266c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
  ).map(colors_default);
  var BuGn_default = ramp_default(scheme10);

  // node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
  var scheme11 = new Array(3).concat(
    "e0ecf49ebcda8856a7",
    "edf8fbb3cde38c96c688419d",
    "edf8fbb3cde38c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
  ).map(colors_default);
  var BuPu_default = ramp_default(scheme11);

  // node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
  var scheme12 = new Array(3).concat(
    "e0f3dba8ddb543a2ca",
    "f0f9e8bae4bc7bccc42b8cbe",
    "f0f9e8bae4bc7bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
  ).map(colors_default);
  var GnBu_default = ramp_default(scheme12);

  // node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
  var scheme13 = new Array(3).concat(
    "fee8c8fdbb84e34a33",
    "fef0d9fdcc8afc8d59d7301f",
    "fef0d9fdcc8afc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
  ).map(colors_default);
  var OrRd_default = ramp_default(scheme13);

  // node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
  var scheme14 = new Array(3).concat(
    "ece2f0a6bddb1c9099",
    "f6eff7bdc9e167a9cf02818a",
    "f6eff7bdc9e167a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
  ).map(colors_default);
  var PuBuGn_default = ramp_default(scheme14);

  // node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
  var scheme15 = new Array(3).concat(
    "ece7f2a6bddb2b8cbe",
    "f1eef6bdc9e174a9cf0570b0",
    "f1eef6bdc9e174a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
  ).map(colors_default);
  var PuBu_default = ramp_default(scheme15);

  // node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
  var scheme16 = new Array(3).concat(
    "e7e1efc994c7dd1c77",
    "f1eef6d7b5d8df65b0ce1256",
    "f1eef6d7b5d8df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
  ).map(colors_default);
  var PuRd_default = ramp_default(scheme16);

  // node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
  var scheme17 = new Array(3).concat(
    "fde0ddfa9fb5c51b8a",
    "feebe2fbb4b9f768a1ae017e",
    "feebe2fbb4b9f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
  ).map(colors_default);
  var RdPu_default = ramp_default(scheme17);

  // node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
  var scheme18 = new Array(3).concat(
    "edf8b17fcdbb2c7fb8",
    "ffffcca1dab441b6c4225ea8",
    "ffffcca1dab441b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
  ).map(colors_default);
  var YlGnBu_default = ramp_default(scheme18);

  // node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
  var scheme19 = new Array(3).concat(
    "f7fcb9addd8e31a354",
    "ffffccc2e69978c679238443",
    "ffffccc2e69978c67931a354006837",
    "ffffccd9f0a3addd8e78c67931a354006837",
    "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
  ).map(colors_default);
  var YlGn_default = ramp_default(scheme19);

  // node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
  var scheme20 = new Array(3).concat(
    "fff7bcfec44fd95f0e",
    "ffffd4fed98efe9929cc4c02",
    "ffffd4fed98efe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
  ).map(colors_default);
  var YlOrBr_default = ramp_default(scheme20);

  // node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
  var scheme21 = new Array(3).concat(
    "ffeda0feb24cf03b20",
    "ffffb2fecc5cfd8d3ce31a1c",
    "ffffb2fecc5cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
  ).map(colors_default);
  var YlOrRd_default = ramp_default(scheme21);

  // node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
  var scheme22 = new Array(3).concat(
    "deebf79ecae13182bd",
    "eff3ffbdd7e76baed62171b5",
    "eff3ffbdd7e76baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
  ).map(colors_default);
  var Blues_default = ramp_default(scheme22);

  // node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
  var scheme23 = new Array(3).concat(
    "e5f5e0a1d99b31a354",
    "edf8e9bae4b374c476238b45",
    "edf8e9bae4b374c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
  ).map(colors_default);
  var Greens_default = ramp_default(scheme23);

  // node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
  var scheme24 = new Array(3).concat(
    "f0f0f0bdbdbd636363",
    "f7f7f7cccccc969696525252",
    "f7f7f7cccccc969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
  ).map(colors_default);
  var Greys_default = ramp_default(scheme24);

  // node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
  var scheme25 = new Array(3).concat(
    "efedf5bcbddc756bb1",
    "f2f0f7cbc9e29e9ac86a51a3",
    "f2f0f7cbc9e29e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
  ).map(colors_default);
  var Purples_default = ramp_default(scheme25);

  // node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
  var scheme26 = new Array(3).concat(
    "fee0d2fc9272de2d26",
    "fee5d9fcae91fb6a4acb181d",
    "fee5d9fcae91fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
  ).map(colors_default);
  var Reds_default = ramp_default(scheme26);

  // node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
  var scheme27 = new Array(3).concat(
    "fee6cefdae6be6550d",
    "feeddefdbe85fd8d3cd94701",
    "feeddefdbe85fd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
  ).map(colors_default);
  var Oranges_default = ramp_default(scheme27);

  // node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
  function cividis_default(t) {
    t = Math.max(0, Math.min(1, t));
    return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
  }

  // node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
  var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

  // node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
  var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
  var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
  var c3 = cubehelix();
  function rainbow_default(t) {
    if (t < 0 || t > 1) t -= Math.floor(t);
    var ts = Math.abs(t - 0.5);
    c3.h = 360 * t - 100;
    c3.s = 1.5 - 1.5 * ts;
    c3.l = 0.8 - 0.9 * ts;
    return c3 + "";
  }

  // node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
  var c4 = rgb();
  var pi_1_3 = Math.PI / 3;
  var pi_2_3 = Math.PI * 2 / 3;
  function sinebow_default(t) {
    var x3;
    t = (0.5 - t) * Math.PI;
    c4.r = 255 * (x3 = Math.sin(t)) * x3;
    c4.g = 255 * (x3 = Math.sin(t + pi_1_3)) * x3;
    c4.b = 255 * (x3 = Math.sin(t + pi_2_3)) * x3;
    return c4 + "";
  }

  // node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
  function turbo_default(t) {
    t = Math.max(0, Math.min(1, t));
    return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
  }

  // node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
  function ramp(range3) {
    var n2 = range3.length;
    return function(t) {
      return range3[Math.max(0, Math.min(n2 - 1, Math.floor(t * n2)))];
    };
  }
  var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
  var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
  var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
  var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

  // node_modules/@antv/g2/esm/runtime/scale.js
  function inferScale(name2, values, options, coordinates, theme, library3) {
    const { guide = {} } = options;
    const type = inferScaleType(name2, values, options);
    if (typeof type !== "string")
      return options;
    const expectedDomain = inferScaleDomain(type, name2, values, options);
    const actualDomain = maybeRatio(type, expectedDomain, options);
    return Object.assign(Object.assign(Object.assign({}, options), inferScaleOptions(type, name2, values, options, coordinates)), {
      domain: actualDomain,
      range: inferScaleRange(type, name2, values, options, actualDomain, theme, library3),
      expectedDomain,
      guide,
      name: name2,
      type
    });
  }
  function applyScale(channels, scale10) {
    const scaledValue = {};
    for (const channel of channels) {
      const { values, name: scaleName } = channel;
      const scaleInstance = scale10[scaleName];
      for (const value2 of values) {
        const { name: name2, value: V } = value2;
        scaledValue[name2] = V.map((d3) => scaleInstance.map(d3));
      }
    }
    return scaledValue;
  }
  function groupTransform(markState, uidScale) {
    const channels = Array.from(markState.values()).flatMap((d3) => d3.channels);
    const scaleGroups = rollups(channels, (channels2) => channels2.map((d3) => uidScale.get(d3.scale.uid)), (d3) => d3.name).filter(([, scales]) => scales.some((d3) => typeof d3.getOptions().groupTransform === "function") && // only sync scales with groupTransform options
    scales.every((d3) => d3.getTicks)).map((d3) => d3[1]);
    scaleGroups.forEach((group3) => {
      const groupTransform2 = group3.map((d3) => d3.getOptions().groupTransform)[0];
      groupTransform2(group3);
    });
  }
  function collectScales(states, options) {
    var _a;
    const { components = [] } = options;
    const NONE_STATIC_KEYS = [
      "scale",
      "encode",
      "axis",
      "legend",
      "data",
      "transform"
    ];
    const scales = Array.from(new Set(states.flatMap((d3) => d3.channels.map((d4) => d4.scale))));
    const nameScale = new Map(scales.map((scale10) => [scale10.name, scale10]));
    for (const component of components) {
      const channels = inferChannelsForComponent(component);
      for (const channel of channels) {
        const scale10 = nameScale.get(channel);
        const staticScale = ((_a = component.scale) === null || _a === void 0 ? void 0 : _a[channel]) || {};
        const { independent = false } = staticScale;
        if (scale10 && !independent) {
          const { guide } = scale10;
          const guide1 = typeof guide === "boolean" ? {} : guide;
          scale10.guide = deep_mix_default({}, guide1, component);
          Object.assign(scale10, staticScale);
        } else {
          const options1 = Object.assign(Object.assign({}, staticScale), { expectedDomain: staticScale.domain, name: channel, guide: omit_default(component, NONE_STATIC_KEYS) });
          scales.push(options1);
        }
      }
    }
    return scales;
  }
  function useRelation(relations) {
    if (!relations || !Array.isArray(relations))
      return [identity5, identity5];
    let map3;
    let invert5;
    const conditionalize = (scale10) => {
      var _a;
      map3 = scale10.map.bind(scale10);
      invert5 = (_a = scale10.invert) === null || _a === void 0 ? void 0 : _a.bind(scale10);
      const funcRelations = relations.filter(([v]) => typeof v === "function");
      const valueRelations = relations.filter(([v]) => typeof v !== "function");
      const valueOutput = new Map(valueRelations);
      scale10.map = (x3) => {
        for (const [verify, value2] of funcRelations) {
          if (verify(x3))
            return value2;
        }
        if (valueOutput.has(x3))
          return valueOutput.get(x3);
        return map3(x3);
      };
      if (!invert5)
        return scale10;
      const outputValue = new Map(valueRelations.map(([a3, b]) => [b, a3]));
      const outputFunc = new Map(funcRelations.map(([a3, b]) => [b, a3]));
      scale10.invert = (x3) => {
        if (outputFunc.has(x3))
          return x3;
        if (outputValue.has(x3))
          return outputValue.get(x3);
        return invert5(x3);
      };
      return scale10;
    };
    const deconditionalize = (scale10) => {
      if (map3 !== null)
        scale10.map = map3;
      if (invert5 !== null)
        scale10.invert = invert5;
      return scale10;
    };
    return [conditionalize, deconditionalize];
  }
  function assignScale(target, source) {
    const keys2 = Object.keys(target);
    for (const scale10 of Object.values(source)) {
      const { name: name2 } = scale10.getOptions();
      if (!(name2 in target))
        target[name2] = scale10;
      else {
        const I = keys2.filter((d3) => d3.startsWith(name2)).map((d3) => +(d3.replace(name2, "") || 0));
        const index4 = max5(I) + 1;
        const newKey = `${name2}${index4}`;
        target[newKey] = scale10;
        scale10.getOptions().key = newKey;
      }
    }
    return target;
  }
  function useRelationScale(options, library3) {
    const [useScale] = useLibrary("scale", library3);
    const { relations } = options;
    const [conditionalize] = useRelation(relations);
    const scale10 = useScale(options);
    return conditionalize(scale10);
  }
  function syncFacetsScales(states) {
    const scales = states.flatMap((d3) => Array.from(d3.values())).flatMap((d3) => d3.channels.map((d4) => d4.scale));
    syncFacetsScaleByChannel(scales, "x");
    syncFacetsScaleByChannel(scales, "y");
  }
  function inferChannelsForComponent(component) {
    const { channels = [], type, scale: scale10 = {} } = component;
    const L = ["shape", "color", "opacity", "size"];
    if (channels.length !== 0)
      return channels;
    if (type === "axisX")
      return ["x"];
    if (type === "axisY")
      return ["y"];
    if (type === "legends")
      return Object.keys(scale10).filter((d3) => L.includes(d3));
    return [];
  }
  function syncFacetsScaleByChannel(scales, channel) {
    const S = scales.filter(({ name: name2, facet = true }) => facet && name2 === channel);
    const D2 = S.flatMap((d3) => d3.domain);
    const syncedD = S.every(isQuantitativeScale) ? extent(D2) : S.every(isDiscreteScale) ? Array.from(new Set(D2)) : null;
    if (syncedD === null)
      return;
    for (const scale10 of S) {
      scale10.domain = syncedD;
    }
  }
  function maybeRatio(type, domain, options) {
    const { ratio } = options;
    if (ratio === void 0 || ratio === null)
      return domain;
    if (isQuantitativeScale({ type })) {
      return clampQuantitativeScale(domain, ratio, type);
    }
    if (isDiscreteScale({ type }))
      return clampDiscreteScale(domain, ratio);
    return domain;
  }
  function clampQuantitativeScale(domain, ratio, type) {
    const D2 = domain.map(Number);
    const scale10 = new Linear({
      domain: D2,
      range: [D2[0], D2[0] + (D2[D2.length - 1] - D2[0]) * ratio]
    });
    if (type === "time")
      return domain.map((d3) => new Date(scale10.map(d3)));
    return domain.map((d3) => scale10.map(d3));
  }
  function clampDiscreteScale(domain, ratio) {
    const index4 = Math.round(domain.length * ratio);
    return domain.slice(0, index4);
  }
  function isQuantitativeScale(scale10) {
    const { type } = scale10;
    if (typeof type !== "string")
      return false;
    const names = ["linear", "log", "pow", "time"];
    return names.includes(type);
  }
  function isDiscreteScale(scale10) {
    const { type } = scale10;
    if (typeof type !== "string")
      return false;
    const names = ["band", "point", "ordinal"];
    return names.includes(type);
  }
  function inferScaleType(name2, values, options) {
    const { type, domain, range: range3, quantitative, ordinal } = options;
    if (type !== void 0)
      return type;
    if (isObject3(values))
      return "identity";
    if (typeof range3 === "string")
      return "linear";
    if ((domain || range3 || []).length > 2)
      return asOrdinalType(name2, ordinal);
    if (domain !== void 0) {
      if (isOrdinal([domain]))
        return asOrdinalType(name2, ordinal);
      if (isTemporal(values))
        return "time";
      return asQuantitativeType(name2, range3, quantitative);
    }
    if (isOrdinal(values))
      return asOrdinalType(name2, ordinal);
    if (isTemporal(values))
      return "time";
    return asQuantitativeType(name2, range3, quantitative);
  }
  function inferScaleDomain(type, name2, values, options) {
    const { domain } = options;
    if (domain !== void 0)
      return domain;
    switch (type) {
      case "linear":
      case "time":
      case "log":
      case "pow":
      case "sqrt":
      case "quantize":
      case "threshold":
        return maybeMinMax(inferDomainQ(values, options), options);
      case "band":
      case "ordinal":
      case "point":
        return inferDomainC(values);
      case "quantile":
        return inferDomainO(values);
      case "sequential":
        return maybeMinMax(inferDomainS(values), options);
      default:
        return [];
    }
  }
  function inferScaleRange(type, name2, values, options, domain, theme, library3) {
    const { range: range3 } = options;
    if (typeof range3 === "string")
      return gradientColors(range3);
    if (range3 !== void 0)
      return range3;
    const { rangeMin, rangeMax } = options;
    switch (type) {
      case "linear":
      case "time":
      case "log":
      case "pow":
      case "sqrt": {
        const colors = categoricalColors(values, options, domain, theme, library3);
        const [r0, r1] = inferRangeQ(name2, colors);
        return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : r0, rangeMax !== null && rangeMax !== void 0 ? rangeMax : r1];
      }
      case "band":
      case "point": {
        const min10 = name2 === "size" ? 5 : 0;
        const max11 = name2 === "size" ? 10 : 1;
        return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : min10, rangeMax !== null && rangeMax !== void 0 ? rangeMax : max11];
      }
      case "ordinal": {
        return categoricalColors(values, options, domain, theme, library3);
      }
      case "sequential":
        return void 0;
      case "constant":
        return [values[0][0]];
      default:
        return [];
    }
  }
  function inferScaleOptions(type, name2, values, options, coordinates) {
    switch (type) {
      case "linear":
      case "time":
      case "log":
      case "pow":
      case "sqrt":
        return inferOptionsQ(coordinates, options);
      case "band":
      case "point":
        return inferOptionsC(type, name2, coordinates, options);
      case "sequential":
        return inferOptionsS(options);
      default:
        return options;
    }
  }
  function categoricalColors(values, options, domain, theme, library3) {
    const [usePalette] = useLibrary("palette", library3);
    const { category10: c10, category20: c20 } = theme;
    const defaultPalette = unique(domain).length <= c10.length ? c10 : c20;
    const { palette = defaultPalette, offset: offset3 } = options;
    if (Array.isArray(palette))
      return palette;
    try {
      return usePalette({ type: palette });
    } catch (e3) {
      const colors = interpolatedColors(palette, domain, offset3);
      if (colors)
        return colors;
      throw new Error(`Unknown Component: ${palette} `);
    }
  }
  function gradientColors(range3) {
    return range3.split("-");
  }
  function interpolatedColors(palette, domain, offset3 = (d3) => d3) {
    if (!palette)
      return null;
    const fullName = upper_first_default(palette);
    const scheme28 = src_exports3[`scheme${fullName}`];
    const interpolator = src_exports3[`interpolate${fullName}`];
    if (!scheme28 && !interpolator)
      return null;
    if (scheme28) {
      if (!scheme28.some(Array.isArray))
        return scheme28;
      const schemeColors = scheme28[domain.length];
      if (schemeColors)
        return schemeColors;
    }
    return domain.map((_2, i) => interpolator(offset3(i / domain.length)));
  }
  function inferOptionsS(options) {
    const { palette = "ylGnBu", offset: offset3 } = options;
    const name2 = upper_first_default(palette);
    const interpolator = src_exports3[`interpolate${name2}`];
    if (!interpolator)
      throw new Error(`Unknown palette: ${name2}`);
    return {
      interpolator: offset3 ? (x3) => interpolator(offset3(x3)) : interpolator
    };
  }
  function inferOptionsQ(coordinates, options) {
    const { interpolate: interpolate5 = createInterpolateValue, nice: nice2 = false, tickCount = 5 } = options;
    return Object.assign(Object.assign({}, options), { interpolate: interpolate5, nice: nice2, tickCount });
  }
  function inferOptionsC(type, name2, coordinates, options) {
    if (options.padding !== void 0 || options.paddingInner !== void 0 || options.paddingOuter !== void 0) {
      return Object.assign(Object.assign({}, options), { unknown: NaN });
    }
    const padding = inferPadding(type, name2, coordinates);
    const { paddingInner = padding, paddingOuter = padding } = options;
    return Object.assign(Object.assign({}, options), {
      paddingInner,
      paddingOuter,
      padding,
      unknown: NaN
    });
  }
  function inferPadding(type, name2, coordinates) {
    if (name2 === "enterDelay" || name2 === "enterDuration")
      return 0;
    if (name2 === "size")
      return 0;
    if (type === "band")
      return isTheta2(coordinates) ? 0 : 0.1;
    if (type === "point")
      return 0.5;
    return 0;
  }
  function asOrdinalType(name2, defaults5) {
    if (defaults5)
      return defaults5;
    return isQuantitative(name2) ? "point" : "ordinal";
  }
  function asQuantitativeType(name2, range3, defaults5) {
    if (defaults5)
      return defaults5;
    if (name2 !== "color")
      return "linear";
    return range3 ? "linear" : "sequential";
  }
  function maybeMinMax(domain, options) {
    if (domain.length === 0)
      return domain;
    const { domainMin, domainMax } = options;
    const [d0, d1] = domain;
    return [domainMin !== null && domainMin !== void 0 ? domainMin : d0, domainMax !== null && domainMax !== void 0 ? domainMax : d1];
  }
  function inferDomainQ(values, options) {
    const { zero: zero5 = false } = options;
    let min10 = Infinity;
    let max11 = -Infinity;
    for (const value2 of values) {
      for (const d3 of value2) {
        if (defined(d3)) {
          min10 = Math.min(min10, +d3);
          max11 = Math.max(max11, +d3);
        }
      }
    }
    if (min10 === Infinity)
      return [];
    return zero5 ? [Math.min(0, min10), max11] : [min10, max11];
  }
  function inferDomainC(values) {
    return Array.from(new Set(values.flat()));
  }
  function inferDomainO(values) {
    return values.flat().sort();
  }
  function inferDomainS(values) {
    let min10 = Infinity;
    let max11 = -Infinity;
    for (const value2 of values) {
      for (const d3 of value2) {
        if (defined(d3)) {
          min10 = Math.min(min10, +d3);
          max11 = Math.max(max11, +d3);
        }
      }
    }
    if (min10 === Infinity)
      return [];
    return [min10 < 0 ? -max11 : min10, max11];
  }
  function inferRangeQ(name2, palette) {
    if (name2 === "enterDelay")
      return [0, 1e3];
    if (name2 == "enterDuration")
      return [300, 1e3];
    if (name2.startsWith("y") || name2.startsWith("position"))
      return [1, 0];
    if (name2 === "color")
      return [firstOf(palette), lastOf(palette)];
    if (name2 === "opacity")
      return [0, 1];
    if (name2 === "size")
      return [1, 10];
    return [0, 1];
  }
  function isOrdinal(values) {
    return some(values, (d3) => {
      const type = typeof d3;
      return type === "string" || type === "boolean";
    });
  }
  function isTemporal(values) {
    return some(values, (d3) => d3 instanceof Date);
  }
  function isObject3(values) {
    return some(values, isStrictObject);
  }
  function some(values, callback) {
    for (const V of values) {
      if (V.some(callback))
        return true;
    }
    return false;
  }
  function isQuantitative(name2) {
    return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2.startsWith("size");
  }
  function isPosition(name2) {
    return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2 === "enterDelay" || name2 === "enterDuration" || name2 === "updateDelay" || name2 === "updateDuration" || name2 === "exitDelay" || name2 === "exitDuration";
  }
  function isValidScale(scale10) {
    if (!scale10 || !scale10.type)
      return false;
    if (typeof scale10.type === "function")
      return true;
    const { type, domain, range: range3, interpolator } = scale10;
    const isValidDomain = domain && domain.length > 0;
    const isValidRange = range3 && range3.length > 0;
    if ([
      "linear",
      "sqrt",
      "log",
      "time",
      "pow",
      "threshold",
      "quantize",
      "quantile",
      "ordinal",
      "band",
      "point"
    ].includes(type) && isValidDomain && isValidRange) {
      return true;
    }
    if (["sequential"].includes(type) && isValidDomain && (isValidRange || interpolator)) {
      return true;
    }
    if (["constant", "identity"].includes(type) && isValidRange)
      return true;
    return false;
  }

  // node_modules/@antv/g2/esm/runtime/types/scale.js
  var ContinuousScale = {
    linear: "linear",
    identity: "identity",
    log: "log",
    pow: "pow",
    sqrt: "sqrt",
    sequential: "sequential"
  };
  var DistributionScale = {
    threshold: "threshold",
    quantize: "quantize",
    quantile: "quantile"
  };
  var DiscreteScale = {
    ordinal: "ordinal",
    band: "band",
    point: "point"
  };
  var ConstantScale = {
    constant: "constant"
  };

  // node_modules/@antv/g2/esm/runtime/component.js
  var __rest73 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function inferComponent(scales, partialOptions, library3) {
    const { coordinates = [], title } = partialOptions;
    const [, createGuideComponent] = useLibrary("component", library3);
    const displayedScales = scales.filter(({ guide }) => {
      if (guide === null)
        return false;
      return true;
    });
    const components = [];
    const sliders = inferScrollableComponents(partialOptions, scales, library3);
    components.push(...sliders);
    if (title) {
      const { props } = createGuideComponent("title");
      const { defaultPosition, defaultOrientation, defaultOrder, defaultSize, defaultCrossPadding } = props;
      const titleOptions = typeof title === "string" ? { title } : title;
      components.push(Object.assign({ type: "title", position: defaultPosition, orientation: defaultOrientation, order: defaultOrder, crossPadding: defaultCrossPadding[0], defaultSize }, titleOptions));
    }
    const inferredComponents = inferComponentsType(displayedScales, coordinates);
    inferredComponents.forEach(([type, relativeScales]) => {
      const { props } = createGuideComponent(type);
      const { defaultPosition, defaultPlane = "xy", defaultOrientation, defaultSize, defaultOrder, defaultLength, defaultPadding: DP = [0, 0], defaultCrossPadding: DCP = [0, 0] } = props;
      const scale10 = deep_mix_default({}, ...relativeScales);
      const { guide: guideOptions, field: field3 } = scale10;
      const guides = Array.isArray(guideOptions) ? guideOptions : [guideOptions];
      for (const partialGuide of guides) {
        const [position, orientation] = inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, partialGuide, relativeScales, displayedScales, coordinates);
        if (!position && !orientation)
          continue;
        const isVertical2 = position === "left" || position === "right";
        const defaultPadding = isVertical2 ? DP[1] : DP[0];
        const defaultCrossPadding = isVertical2 ? DCP[1] : DCP[0];
        const { size: size2, order = defaultOrder, length: length5 = defaultLength, padding = defaultPadding, crossPadding = defaultCrossPadding } = partialGuide;
        components.push(Object.assign(Object.assign({ title: field3 }, partialGuide), {
          defaultSize,
          length: length5,
          position,
          plane: defaultPlane,
          orientation,
          padding,
          order,
          crossPadding,
          size: size2,
          type,
          scales: relativeScales
        }));
      }
    });
    return components;
  }
  function renderComponent(component, coordinate, theme, library3, markState) {
    const [useGuideComponent] = useLibrary("component", library3);
    const { scaleInstances: scales, scale: scale10, bbox } = component, options = __rest73(component, ["scaleInstances", "scale", "bbox"]);
    const value2 = { bbox, library: library3 };
    const render2 = useGuideComponent(options);
    return render2({
      coordinate,
      library: library3,
      markState,
      scales,
      theme,
      value: value2,
      scale: scale10
    });
  }
  function normalizeComponents(components) {
    return components.map((d3) => {
      const component = deep_mix_default(d3, d3.style);
      delete component.style;
      return component;
    });
  }
  function groupComponents(components, crossSize) {
    const P = ["left", "right", "bottom", "top"];
    const key = ({ type, position, group: group3 }) => {
      if (!P.includes(position))
        return Symbol("independent");
      if (group3 === void 0) {
        if (type.startsWith("legend"))
          return `legend-${position}`;
        return Symbol("independent");
      }
      if (group3 === "independent")
        return Symbol("independent");
      return group3;
    };
    const grouped = groups(components, key);
    return grouped.flatMap(([, components2]) => {
      if (components2.length === 1)
        return components2[0];
      if (crossSize !== void 0) {
        const DL = components2.filter((d3) => d3.length !== void 0).map((d3) => d3.length);
        const totalLength = sum(DL);
        if (totalLength > crossSize) {
          components2.forEach((d3) => d3.group = Symbol("independent"));
          return components2;
        }
        const emptyLength = crossSize - totalLength;
        const emptyCount = components2.length - DL.length;
        const length5 = emptyLength / emptyCount;
        components2.forEach((d3) => {
          if (d3.length !== void 0)
            return;
          d3.length = length5;
        });
      }
      const size2 = max5(components2, (d3) => d3.size);
      const order = max5(components2, (d3) => d3.order);
      const crossPadding = max5(components2, (d3) => d3.crossPadding);
      const position = components2[0].position;
      return {
        type: "group",
        size: size2,
        order,
        position,
        children: components2,
        crossPadding
      };
    });
  }
  function inferLegendComponentType(scales, coordinates) {
    const channels = ["shape", "size", "color", "opacity"];
    const isConstantSize = (type, name2) => type === "constant" && name2 === "size";
    const accepts = scales.filter(({ type, name: name2 }) => typeof type === "string" && channels.includes(name2) && !isConstantSize(type, name2));
    const constants = accepts.filter(({ type }) => type === "constant");
    const nonConstants = accepts.filter(({ type }) => type !== "constant");
    const groupKey = (d3) => d3.field ? d3.field : Symbol("independent");
    const fieldScales = groups(nonConstants, groupKey).map(([key, scales2]) => [key, [...scales2, ...constants]]).filter(([, scales2]) => scales2.some((scale10) => scale10.type !== "constant"));
    const scalesByField = new Map(fieldScales);
    if (scalesByField.size === 0)
      return [];
    const sort3 = (arr) => arr.sort(([a3], [b]) => a3.localeCompare(b));
    const components = Array.from(scalesByField).map(([, scs]) => {
      const combinations = combine(scs).sort((a3, b) => b.length - a3.length);
      const options = combinations.map((combination) => ({
        combination,
        option: combination.map((scale10) => [scale10.name, getScaleType(scale10)])
      }));
      for (const { option: option2, combination } of options) {
        if (option2.every((d3) => d3[1] === "constant"))
          continue;
        if (option2.every((d3) => d3[1] === "discrete" || d3[1] === "constant")) {
          return ["legendCategory", combination];
        }
      }
      for (const [componentType, accords] of LEGEND_INFER_STRATEGIES) {
        for (const { option: option2, combination } of options) {
          if (accords.some((accord) => is_equal_default(sort3(accord), sort3(option2)))) {
            return [componentType, combination];
          }
        }
      }
      return null;
    }).filter(defined);
    return components;
  }
  function getScaleType(scale10) {
    const { type } = scale10;
    if (typeof type !== "string")
      return null;
    if (type in ContinuousScale)
      return "continuous";
    if (type in DiscreteScale)
      return "discrete";
    if (type in DistributionScale)
      return "distribution";
    if (type in ConstantScale)
      return "constant";
    return null;
  }
  function inferAxisComponentType(scales, coordinates) {
    return scales.map((scale10) => {
      const { name: name2 } = scale10;
      if (isHelix2(coordinates) || isTheta2(coordinates))
        return null;
      if (isTranspose2(coordinates) && (isPolar2(coordinates) || isRadial2(coordinates)))
        return null;
      if (name2.startsWith("x")) {
        if (isPolar2(coordinates))
          return ["axisArc", [scale10]];
        if (isRadial2(coordinates))
          return ["axisLinear", [scale10]];
        return [isTranspose2(coordinates) ? "axisY" : "axisX", [scale10]];
      }
      if (name2.startsWith("y")) {
        if (isPolar2(coordinates))
          return ["axisLinear", [scale10]];
        if (isRadial2(coordinates))
          return ["axisArc", [scale10]];
        return [isTranspose2(coordinates) ? "axisX" : "axisY", [scale10]];
      }
      if (name2.startsWith("z")) {
        return ["axisZ", [scale10]];
      }
      if (name2.startsWith("position")) {
        if (isRadar2(coordinates))
          return ["axisRadar", [scale10]];
        if (!isPolar2(coordinates))
          return ["axisY", [scale10]];
      }
      return null;
    }).filter(defined);
  }
  function inferComponentsType(scales, coordinates) {
    const availableScales = scales.filter((scale10) => isValidScale(scale10));
    return [
      ...inferLegendComponentType(availableScales, coordinates),
      ...inferAxisComponentType(availableScales, coordinates)
    ];
  }
  function angleOf3(coordinates) {
    const polar = coordOf(coordinates, "polar");
    if (polar.length) {
      const lastPolar = polar[polar.length - 1];
      const { startAngle, endAngle } = getPolarOptions(lastPolar);
      return [startAngle, endAngle];
    }
    const radial = coordOf(coordinates, "radial");
    if (radial.length) {
      const lastRadial = radial[radial.length - 1];
      const { startAngle, endAngle } = getRadialOptions(lastRadial);
      return [startAngle, endAngle];
    }
    return [-Math.PI / 2, Math.PI / 2 * 3];
  }
  function matchPosition(name2) {
    const match2 = /position(\d*)/g.exec(name2);
    if (!match2)
      return null;
    return +match2[1];
  }
  function inferAxisPositionAndOrientation(type, ordinalPosition, relativeScales, scales, coordinates) {
    const { name: name2 } = relativeScales[0];
    if (type === "axisRadar") {
      const positions = scales.filter((scale10) => scale10.name.startsWith("position"));
      const index4 = matchPosition(name2);
      if (name2 === positions.slice(-1)[0].name || index4 === null)
        return [null, null];
      const [startAngle, endAngle] = angleOf3(coordinates);
      const angle4 = (endAngle - startAngle) / (positions.length - 1) * index4 + startAngle;
      return ["center", angle4];
    }
    if (type === "axisY" && isParallel2(coordinates)) {
      return isTranspose2(coordinates) ? ["center", "horizontal"] : ["center", "vertical"];
    }
    if (type === "axisLinear") {
      const [startAngle] = angleOf3(coordinates);
      return ["center", startAngle];
    }
    if (type === "axisArc") {
      if (ordinalPosition[0] === "inner")
        return ["inner", null];
      return ["outer", null];
    }
    if (isPolar2(coordinates))
      return ["center", null];
    if (isRadial2(coordinates))
      return ["center", null];
    if (type === "axisX" && isReflect(coordinates) || type === "axisX" && isReflectY(coordinates)) {
      return ["top", null];
    }
    return ordinalPosition;
  }
  function inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, guide, relativeScales, scales, coordinates) {
    const [startAngle] = angleOf3(coordinates);
    const ordinalPositionAndOrientation = [
      guide.position || defaultPosition,
      startAngle !== null && startAngle !== void 0 ? startAngle : defaultOrientation
    ];
    if (typeof type === "string" && type.startsWith("axis")) {
      return inferAxisPositionAndOrientation(type, ordinalPositionAndOrientation, relativeScales, scales, coordinates);
    }
    if (typeof type === "string" && type.startsWith("legend") && isPolar2(coordinates)) {
      if (guide.position === "center")
        return ["center", "vertical"];
    }
    return ordinalPositionAndOrientation;
  }
  function inferScrollableType(name2, type, coordinates = []) {
    if (name2 === "x")
      return isTranspose2(coordinates) ? `${type}Y` : `${type}X`;
    if (name2 === "y")
      return isTranspose2(coordinates) ? `${type}X` : `${type}Y`;
    return null;
  }
  function inferScrollableComponents(partialOptions, scales, library3) {
    const [, createGuideComponent] = useLibrary("component", library3);
    const { coordinates } = partialOptions;
    function normalized(type, channelName, scale10, options) {
      const componentType = inferScrollableType(channelName, type, coordinates);
      if (!options || !componentType)
        return;
      const { props } = createGuideComponent(componentType);
      const { defaultPosition, defaultSize, defaultOrder, defaultCrossPadding: [crossPadding] } = props;
      return Object.assign(Object.assign({ position: defaultPosition, defaultSize, order: defaultOrder, type: componentType, crossPadding }, options), { scales: [scale10] });
    }
    return scales.filter((d3) => d3.slider || d3.scrollbar).flatMap((scale10) => {
      const { slider, scrollbar, name: channelName } = scale10;
      return [
        normalized("slider", channelName, scale10, slider),
        normalized("scrollbar", channelName, scale10, scrollbar)
      ];
    }).filter((d3) => !!d3);
  }
  function computeComponentSize(component, crossSize, crossPadding, position, theme, library3) {
    const { type } = component;
    const paddingAreas = ["left", "right", "bottom", "top"];
    if (!paddingAreas.includes(position))
      return;
    if (typeof type !== "string")
      return;
    const t = type;
    const createCompute = () => {
      if (t.startsWith("axis"))
        return computeAxisSize;
      if (t.startsWith("group"))
        return computeGroupSize;
      if (t.startsWith("legendContinuous"))
        return computeContinuousLegendSize;
      if (t === "legendCategory")
        return computeCategoryLegendSize;
      if (t.startsWith("slider"))
        return computeSliderSize;
      if (t === "title")
        return computeTitleSize;
      if (t.startsWith("scrollbar"))
        return computeScrollbarSize;
      return () => {
      };
    };
    return createCompute()(component, crossSize, crossPadding, position, theme, library3);
  }
  function computeGroupSize(component, crossSize, crossPadding, position, theme, library3) {
    const { children } = component;
    const maxCrossPadding = max5(children, (d3) => d3.crossPadding);
    children.forEach((d3) => d3.crossPadding = maxCrossPadding);
    children.forEach((child) => computeComponentSize(child, crossSize, crossPadding, position, theme, library3));
    const maxSize = max5(children, (d3) => d3.size);
    component.size = maxSize;
    children.forEach((d3) => d3.size = maxSize);
  }
  function computeScrollbarSize(component, crossSize, crossPadding, position, theme, library3) {
    const { trackSize = 6 } = deep_mix_default({}, theme.scrollbar, component);
    component.size = trackSize;
  }
  function computeTitleSize(component, crossSize, crossPadding, position, theme, library3) {
    const _a = deep_mix_default({}, theme.title, component), { title, subtitle, spacing = 0 } = _a, style = __rest73(_a, ["title", "subtitle", "spacing"]);
    if (title) {
      const titleStyle = subObject(style, "title");
      const titleBBox = computeLabelSize(title, titleStyle);
      component.size = titleBBox.height;
    }
    if (subtitle) {
      const subtitleStyle = subObject(style, "subtitle");
      const subtitleBBox = computeLabelSize(subtitle, subtitleStyle);
      component.size += spacing + subtitleBBox.height;
    }
  }
  function computeSliderSize(component, crossSize, crossPadding, position, theme, library3) {
    const styleOf2 = () => {
      const { slider } = theme;
      return deep_mix_default({}, slider, component);
    };
    const { trackSize, handleIconSize } = styleOf2();
    const size2 = Math.max(trackSize, handleIconSize * 2.4);
    component.size = size2;
  }
  function computeAxisSize(component, crossSize, crossPadding, position, theme, library3) {
    var _a;
    component.transform = component.transform || [{ type: "hide" }];
    const isVertical2 = position === "left" || position === "right";
    const style = styleOf(component, position, theme);
    const { tickLength = 0, labelSpacing = 0, titleSpacing = 0, labelAutoRotate } = style, rest = __rest73(style, ["tickLength", "labelSpacing", "titleSpacing", "labelAutoRotate"]);
    const scale10 = createScale(component, library3);
    const labelBBoxes = computeLabelsBBox(rest, scale10);
    const paddingTick = tickLength + labelSpacing;
    if (labelBBoxes && labelBBoxes.length) {
      const maxLabelWidth = max5(labelBBoxes, (d3) => d3.width);
      const maxLabelHeight = max5(labelBBoxes, (d3) => d3.height);
      if (isVertical2) {
        component.size = maxLabelWidth + paddingTick;
      } else {
        const { tickFilter, labelTransform } = component;
        if (overflowX(scale10, labelBBoxes, crossSize, crossPadding, tickFilter) && !labelTransform && labelAutoRotate !== false && labelAutoRotate !== null) {
          component.labelTransform = "rotate(90)";
          component.size = maxLabelWidth + paddingTick;
        } else {
          component.labelTransform = (_a = component.labelTransform) !== null && _a !== void 0 ? _a : "rotate(0)";
          component.size = maxLabelHeight + paddingTick;
        }
      }
    } else {
      component.size = tickLength;
    }
    const titleBBox = computeTitleBBox(rest);
    if (titleBBox) {
      if (isVertical2) {
        component.size += titleSpacing + titleBBox.width;
      } else {
        component.size += titleSpacing + titleBBox.height;
      }
    }
  }
  function computeContinuousLegendSize(component, crossSize, crossPadding, position, theme, library3) {
    const styleOf2 = () => {
      const { legendContinuous } = theme;
      return deep_mix_default({}, legendContinuous, component);
    };
    const _a = styleOf2(), { labelSpacing = 0, titleSpacing = 0 } = _a, rest = __rest73(_a, ["labelSpacing", "titleSpacing"]);
    const isVertical2 = position === "left" || position === "right";
    const ribbonStyles = subObject(rest, "ribbon");
    const { size: ribbonSize } = ribbonStyles;
    const handleIconStyles = subObject(rest, "handleIcon");
    const { size: handleIconSize } = handleIconStyles;
    const mainSize = Math.max(ribbonSize, handleIconSize * 2.4);
    component.size = mainSize;
    const scale10 = createScale(component, library3);
    const labelBBoxes = computeLabelsBBox(rest, scale10);
    if (labelBBoxes) {
      const key = isVertical2 ? "width" : "height";
      const size2 = max5(labelBBoxes, (d3) => d3[key]);
      component.size += size2 + labelSpacing;
    }
    const titleBBox = computeTitleBBox(rest);
    if (titleBBox) {
      if (isVertical2) {
        component.size = Math.max(component.size, titleBBox.width);
      } else {
        component.size += titleSpacing + titleBBox.height;
      }
    }
  }
  function computeCategoryLegendSize(component, crossSize0, crossPadding, position, theme, library3) {
    const styleOf2 = () => {
      const { legendCategory } = theme;
      const { title } = component;
      const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
      return deep_mix_default({ title: defaultTitle }, legendCategory, Object.assign(Object.assign({}, component), { title: specifiedTitle }));
    };
    const _a = styleOf2(), { itemSpacing, itemMarkerSize, titleSpacing, rowPadding, colPadding, maxCols = Infinity, maxRows = Infinity } = _a, rest = __rest73(_a, ["itemSpacing", "itemMarkerSize", "titleSpacing", "rowPadding", "colPadding", "maxCols", "maxRows"]);
    const { cols, length: length5 } = component;
    const getRows = (rows) => Math.min(rows, maxRows);
    const getCols = (cols2) => Math.min(cols2, maxCols);
    const isVertical2 = position === "left" || position === "right";
    const crossSize = length5 === void 0 ? crossSize0 + (isVertical2 ? 0 : crossPadding[0] + crossPadding[1]) : length5;
    const titleBBox = computeTitleBBox(rest);
    const scale10 = createScale(component, library3);
    const labelBBoxes = computeLabelsBBox(rest, scale10, "itemLabel");
    const height = Math.max(labelBBoxes[0].height, itemMarkerSize) + rowPadding;
    const widthOf = (w, padding = 0) => itemMarkerSize + w + itemSpacing[0] + padding;
    const computeVerticalSize = () => {
      let maxSize = -Infinity;
      let pos = 0;
      let cols2 = 1;
      let rows = 0;
      let maxRows2 = -Infinity;
      let maxPos = -Infinity;
      const titleHeight = titleBBox ? titleBBox.height : 0;
      const maxHeight = crossSize - titleHeight;
      for (const { width } of labelBBoxes) {
        const w = widthOf(width, colPadding);
        maxSize = Math.max(maxSize, w);
        if (pos + height > maxHeight) {
          cols2++;
          maxRows2 = Math.max(maxRows2, rows);
          maxPos = Math.max(maxPos, pos);
          rows = 1;
          pos = height;
        } else {
          pos += height;
          rows++;
        }
      }
      if (cols2 <= 1) {
        maxRows2 = rows;
        maxPos = pos;
      }
      component.size = maxSize * getCols(cols2);
      component.length = maxPos + titleHeight;
      deep_mix_default(component, { cols: getCols(cols2), gridRow: maxRows2 });
    };
    const computeHorizontalGrid = () => {
      const rows = Math.ceil(labelBBoxes.length / cols);
      const maxWidth = max5(labelBBoxes, (d3) => widthOf(d3.width)) * cols;
      component.size = height * getRows(rows) - rowPadding;
      component.length = Math.min(maxWidth, crossSize);
    };
    const computeHorizontalFlex = () => {
      let rows = 1;
      let pos = 0;
      let maxPos = -Infinity;
      for (const { width } of labelBBoxes) {
        const w = widthOf(width, colPadding);
        if (pos + w > crossSize) {
          maxPos = Math.max(maxPos, pos);
          pos = w;
          rows++;
        } else {
          pos += w;
        }
      }
      if (rows === 1)
        maxPos = pos;
      component.size = height * getRows(rows) - rowPadding;
      component.length = maxPos;
    };
    if (isVertical2)
      computeVerticalSize();
    else if (typeof cols === "number")
      computeHorizontalGrid();
    else
      computeHorizontalFlex();
    if (titleBBox) {
      if (isVertical2) {
        component.size = Math.max(component.size, titleBBox.width);
      } else {
        component.size += titleSpacing + titleBBox.height;
      }
    }
  }
  function createScale(component, library3) {
    const [useScale] = useLibrary("scale", library3);
    const { scales, tickCount, tickMethod } = component;
    const scaleOptions = scales.find((d3) => d3.type !== "constant" && d3.type !== "identity");
    if (tickCount !== void 0)
      scaleOptions.tickCount = tickCount;
    if (tickMethod !== void 0)
      scaleOptions.tickMethod = tickMethod;
    return useScale(scaleOptions);
  }
  function computeLabelsBBox(component, scale10, key = "label") {
    const { labelFormatter, tickFilter, label = true } = component, style = __rest73(component, ["labelFormatter", "tickFilter", "label"]);
    if (!label)
      return null;
    const labels = labelsOf(scale10, labelFormatter, tickFilter);
    const labelStyle = subObject(style, key);
    const labelStyles = labels.map((d3, i) => Object.fromEntries(Object.entries(labelStyle).map(([key2, value2]) => [
      key2,
      typeof value2 === "function" ? value2(d3, i) : value2
    ])));
    const labelBBoxes = labels.map((d3, i) => {
      const normalizeStyle = labelStyles[i];
      return computeLabelSize(d3, normalizeStyle);
    });
    const hasTransform = labelStyles.some((d3) => d3.transform);
    if (!hasTransform) {
      const I = labels.map((_2, i) => i);
      component.indexBBox = new Map(I.map((i) => [i, [labels[i], labelBBoxes[i]]]));
    }
    return labelBBoxes;
  }
  function computeTitleBBox(component) {
    const isFalsy = (x3) => x3 === false || x3 === null;
    const { title } = component, style = __rest73(component, ["title"]);
    if (isFalsy(title) || title === void 0)
      return null;
    const titleStyle = subObject(style, "title");
    const { direction: direction2, transform } = titleStyle;
    const titleText = Array.isArray(title) ? title.join(",") : title;
    if (typeof titleText !== "string")
      return null;
    const titleBBox = computeLabelSize(titleText, Object.assign(Object.assign({}, titleStyle), { transform: transform || (direction2 === "vertical" ? "rotate(-90)" : "") }));
    return titleBBox;
  }
  function styleOf(axis, position, theme) {
    const { title } = axis;
    const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
    const {
      axis: baseStyle,
      // @ts-ignore
      [`axis${capitalizeFirst(position)}`]: positionStyle
    } = theme;
    return deep_mix_default({ title: defaultTitle }, baseStyle, positionStyle, Object.assign(Object.assign({}, axis), { title: specifiedTitle }));
  }
  function ticksOf2(scale10, tickFilter) {
    const ticks2 = scale10.getTicks ? scale10.getTicks() : scale10.getOptions().domain;
    if (!tickFilter)
      return ticks2;
    return ticks2.filter(tickFilter);
  }
  function labelsOf(scale10, labelFormatter, tickFilter) {
    const T = ticksOf2(scale10, tickFilter);
    const ticks2 = T.map((d3) => typeof d3 === "number" ? prettyNumber2(d3) : d3);
    const formatter2 = labelFormatter ? typeof labelFormatter === "string" ? format2(labelFormatter) : labelFormatter : scale10.getFormatter ? scale10.getFormatter() : (d3) => `${d3}`;
    return ticks2.map(formatter2);
  }
  function offsetOf(scale10, d3) {
    if (!scale10.getBandWidth)
      return 0;
    const offset3 = scale10.getBandWidth(d3) / 2;
    return offset3;
  }
  function overflowX(scale10, labelBBoxes, crossSize, crossPadding, tickFilter) {
    const totalSize = sum(labelBBoxes, (d3) => d3.width);
    if (totalSize > crossSize)
      return true;
    const scaleX2 = scale10.clone();
    scaleX2.update({ range: [0, crossSize] });
    const ticks2 = ticksOf2(scale10, tickFilter);
    const X = ticks2.map((d3) => scaleX2.map(d3) + offsetOf(scaleX2, d3));
    const I = ticks2.map((_2, i) => i);
    const startX = -crossPadding[0];
    const endX = crossSize + crossPadding[1];
    const extent2 = (x3, bbox) => {
      const { width } = bbox;
      return [x3 - width / 2, x3 + width / 2];
    };
    for (let i = 0; i < I.length; i++) {
      const x3 = X[i];
      const [x05, x12] = extent2(x3, labelBBoxes[i]);
      if (x05 < startX || x12 > endX)
        return true;
      const y3 = X[i + 1];
      if (y3) {
        const [y05] = extent2(y3, labelBBoxes[i + 1]);
        if (x12 > y05)
          return true;
      }
    }
    return false;
  }
  function computeLabelSize(d3, style) {
    const shape23 = normalizeLabel(d3);
    const { filter: filter2 } = style, rest = __rest73(style, ["filter"]);
    shape23.attr(Object.assign(Object.assign({}, rest), { visibility: "none" }));
    const bbox = shape23.getBBox();
    return bbox;
  }
  function normalizeLabel(d3) {
    if (d3 instanceof DisplayObject)
      return d3;
    return new Text({ style: { text: `${d3}` } });
  }

  // node_modules/@antv/g2/esm/runtime/layout.js
  function processAxisZ(components) {
    const axisX = components.find(({ type }) => type === "axisX");
    const axisY = components.find(({ type }) => type === "axisY");
    const axisZ = components.find(({ type }) => type === "axisZ");
    if (axisX && axisY && axisZ) {
      axisX.plane = "xy";
      axisY.plane = "xy";
      axisZ.plane = "yz";
      axisZ.origin = [axisX.bbox.x, axisX.bbox.y, 0];
      axisZ.eulerAngles = [0, -90, 0];
      axisZ.bbox.x = axisX.bbox.x;
      axisZ.bbox.y = axisX.bbox.y;
      components.push(Object.assign(Object.assign({}, axisX), { plane: "xz", showLabel: false, showTitle: false, origin: [axisX.bbox.x, axisX.bbox.y, 0], eulerAngles: [-90, 0, 0] }));
      components.push(Object.assign(Object.assign({}, axisY), { plane: "yz", showLabel: false, showTitle: false, origin: [axisY.bbox.x + axisY.bbox.width, axisY.bbox.y, 0], eulerAngles: [0, -90, 0] }));
      components.push(Object.assign(Object.assign({}, axisZ), { plane: "xz", actualPosition: "left", showLabel: false, showTitle: false, eulerAngles: [90, -90, 0] }));
    }
  }
  function computeLayout(components, options, theme, library3) {
    var _a, _b;
    const { width, height, depth, x: x3 = 0, y: y3 = 0, z = 0, inset = (_a = theme.inset) !== null && _a !== void 0 ? _a : 0, insetLeft = inset, insetTop = inset, insetBottom = inset, insetRight = inset, margin = (_b = theme.margin) !== null && _b !== void 0 ? _b : 0, marginLeft = margin, marginBottom = margin, marginTop = margin, marginRight = margin, padding = theme.padding, paddingBottom = padding, paddingLeft = padding, paddingRight = padding, paddingTop = padding } = computeInset(components, options, theme, library3);
    const MIN_CONTENT_RATIO = 1 / 4;
    const maybeClamp = (viewWidth2, paddingLeft2, paddingRight2, pl02, pr02) => {
      const { marks } = options;
      if (marks.length === 0)
        return [pl02, pr02];
      const contentSize = viewWidth2 - pl02 - pr02;
      const diff = contentSize - viewWidth2 * MIN_CONTENT_RATIO;
      if (diff > 0)
        return [pl02, pr02];
      const shrinkSize = viewWidth2 * (1 - MIN_CONTENT_RATIO);
      return [
        paddingLeft2 === "auto" ? shrinkSize * pl02 / (pl02 + pr02) : pl02,
        paddingRight2 === "auto" ? shrinkSize * pr02 / (pl02 + pr02) : pr02
      ];
    };
    const roughPadding = (padding2) => padding2 === "auto" ? 20 : padding2 !== null && padding2 !== void 0 ? padding2 : 20;
    const rpt = roughPadding(paddingTop);
    const rpb = roughPadding(paddingBottom);
    const horizontalPadding = computePadding(components, height - rpt - rpb, [rpt + marginTop, rpb + marginBottom], ["left", "right"], options, theme, library3);
    const { paddingLeft: pl0, paddingRight: pr0 } = horizontalPadding;
    const viewWidth = width - marginLeft - marginRight;
    const [pl, pr] = maybeClamp(viewWidth, paddingLeft, paddingRight, pl0, pr0);
    const iw = viewWidth - pl - pr;
    const verticalPadding = computePadding(components, iw, [pl + marginLeft, pr + marginRight], ["bottom", "top"], options, theme, library3);
    const { paddingTop: pt0, paddingBottom: pb0 } = verticalPadding;
    const viewHeight = height - marginBottom - marginTop;
    const [pb, pt] = maybeClamp(viewHeight, paddingBottom, paddingTop, pb0, pt0);
    const ih = viewHeight - pb - pt;
    return {
      width,
      height,
      depth,
      insetLeft,
      insetTop,
      insetBottom,
      insetRight,
      innerWidth: iw,
      innerHeight: ih,
      paddingLeft: pl,
      paddingRight: pr,
      paddingTop: pt,
      paddingBottom: pb,
      marginLeft,
      marginBottom,
      marginTop,
      marginRight,
      x: x3,
      y: y3,
      z
    };
  }
  function computeRoughPlotSize(options) {
    const { height, width, padding = 0, paddingLeft = padding, paddingRight = padding, paddingTop = padding, paddingBottom = padding, margin = 16, marginLeft = margin, marginRight = margin, marginTop = margin, marginBottom = margin, inset = 0, insetLeft = inset, insetRight = inset, insetTop = inset, insetBottom = inset } = options;
    const maybeAuto = (padding2) => padding2 === "auto" ? 20 : padding2;
    const finalWidth = width - maybeAuto(paddingLeft) - maybeAuto(paddingRight) - marginLeft - marginRight - insetLeft - insetRight;
    const finalHeight = height - maybeAuto(paddingTop) - maybeAuto(paddingBottom) - marginTop - marginBottom - insetTop - insetBottom;
    return { width: finalWidth, height: finalHeight };
  }
  function computeInset(components, options, theme, library3) {
    const { coordinates } = options;
    if (!isPolar2(coordinates) && !isRadial2(coordinates)) {
      return options;
    }
    const axes = components.filter((d3) => typeof d3.type === "string" && d3.type.startsWith("axis"));
    if (axes.length === 0)
      return options;
    const styles = axes.map((component) => {
      const key = component.type === "axisArc" ? "arc" : "linear";
      return styleOf(component, key, theme);
    });
    const maxLabelSpacing = max5(styles, (d3) => {
      var _a;
      return (_a = d3.labelSpacing) !== null && _a !== void 0 ? _a : 0;
    });
    const labelBBoxes = axes.flatMap((component, i) => {
      const style = styles[i];
      const scale10 = createScale(component, library3);
      const labels = computeLabelsBBox(style, scale10);
      return labels;
    }).filter(defined);
    const size2 = max5(labelBBoxes, (d3) => d3.height) + maxLabelSpacing;
    const titleBBoxes = axes.flatMap((_2, i) => {
      const style = styles[i];
      return computeTitleBBox(style);
    }).filter((d3) => d3 !== null);
    const titleSize = titleBBoxes.length === 0 ? 0 : max5(titleBBoxes, (d3) => d3.height);
    const { inset = size2, insetLeft = inset, insetBottom = inset, insetTop = inset + titleSize, insetRight = inset } = options;
    return Object.assign(Object.assign({}, options), { insetLeft, insetBottom, insetTop, insetRight });
  }
  function computePadding(components, crossSize, crossPadding, positions, options, theme, library3) {
    const positionComponents = group(components, (d3) => d3.position);
    const { padding = theme.padding, paddingLeft = padding, paddingRight = padding, paddingBottom = padding, paddingTop = padding } = options;
    const layout = {
      paddingBottom,
      paddingLeft,
      paddingTop,
      paddingRight
    };
    for (const position of positions) {
      const key = `padding${capitalizeFirst(camelCase(position))}`;
      const components2 = positionComponents.get(position) || [];
      const value2 = layout[key];
      const defaultSizeOf = (d3) => {
        if (d3.size === void 0)
          d3.size = d3.defaultSize;
      };
      const sizeOf3 = (d3) => {
        if (d3.type === "group") {
          d3.children.forEach(defaultSizeOf);
          d3.size = max5(d3.children, (d4) => d4.size);
        } else {
          d3.size = d3.defaultSize;
        }
      };
      const autoSizeOf = (d3) => {
        if (d3.size)
          return;
        if (value2 !== "auto")
          sizeOf3(d3);
        else {
          computeComponentSize(d3, crossSize, crossPadding, position, theme, library3);
          defaultSizeOf(d3);
        }
      };
      const maybeHide = (d3) => {
        if (!d3.type.startsWith("axis"))
          return;
        if (d3.labelAutoHide === void 0)
          d3.labelAutoHide = true;
      };
      const isHorizontal3 = position === "bottom" || position === "top";
      const minOrder = min4(components2, (d3) => d3.order);
      const axes = components2.filter((d3) => d3.type.startsWith("axis") && d3.order == minOrder);
      if (axes.length)
        axes[0].crossPadding = 0;
      if (typeof value2 === "number") {
        components2.forEach(defaultSizeOf);
        components2.forEach(maybeHide);
      } else {
        if (components2.length === 0) {
          layout[key] = 0;
        } else {
          const size2 = isHorizontal3 ? crossSize + crossPadding[0] + crossPadding[1] : crossSize;
          const grouped = groupComponents(components2, size2);
          grouped.forEach(autoSizeOf);
          const totalSize = grouped.reduce((sum3, { size: size3, crossPadding: crossPadding2 = 12 }) => sum3 + size3 + crossPadding2, 0);
          layout[key] = totalSize;
        }
      }
    }
    return layout;
  }
  function placeComponents(components, coordinate, layout) {
    const positionComponents = group(components, (d3) => `${d3.plane || "xy"}-${d3.position}`);
    const { paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop, height, width, depth } = layout;
    const planes = {
      xy: createSection({
        width,
        height,
        paddingLeft,
        paddingRight,
        paddingTop,
        paddingBottom,
        marginLeft,
        marginTop,
        marginBottom,
        marginRight,
        innerHeight,
        innerWidth,
        insetBottom,
        insetLeft,
        insetRight,
        insetTop
      }),
      yz: createSection({
        width: depth,
        height,
        paddingLeft: 0,
        paddingRight: 0,
        paddingTop: 0,
        paddingBottom: 0,
        marginLeft: 0,
        marginTop: 0,
        marginBottom: 0,
        marginRight: 0,
        innerWidth: depth,
        innerHeight: height,
        insetBottom: 0,
        insetLeft: 0,
        insetRight: 0,
        insetTop: 0
      }),
      xz: createSection({
        width,
        height: depth,
        paddingLeft: 0,
        paddingRight: 0,
        paddingTop: 0,
        paddingBottom: 0,
        marginLeft: 0,
        marginTop: 0,
        marginBottom: 0,
        marginRight: 0,
        innerWidth: width,
        innerHeight: depth,
        insetBottom: 0,
        insetLeft: 0,
        insetRight: 0,
        insetTop: 0
      })
    };
    for (const [key, components2] of positionComponents.entries()) {
      const [plane, position] = key.split("-");
      const area2 = planes[plane][position];
      const [nonEntityComponents, entityComponents] = divide4(components2, (component) => {
        if (typeof component.type !== "string")
          return false;
        if (position === "center")
          return true;
        if (component.type.startsWith("axis") && ["inner", "outer"].includes(position)) {
          return true;
        }
        return false;
      });
      if (nonEntityComponents.length) {
        placeNonEntityComponents(nonEntityComponents, coordinate, area2, position);
      }
      if (entityComponents.length) {
        placePaddingArea(components2, coordinate, area2);
      }
    }
  }
  function createSection({ width, height, paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop }) {
    const pl = paddingLeft + marginLeft;
    const pt = paddingTop + marginTop;
    const pr = paddingRight + marginRight;
    const pb = paddingBottom + marginBottom;
    const plotWidth = width - marginLeft - marginRight;
    const centerSection = [
      pl + insetLeft,
      pt + insetTop,
      innerWidth - insetLeft - insetRight,
      innerHeight - insetTop - insetBottom,
      "center",
      null,
      null
    ];
    const xySection = {
      top: [
        pl,
        0,
        innerWidth,
        pt,
        "vertical",
        true,
        ascending,
        marginLeft,
        plotWidth
      ],
      right: [width - pr, pt, pr, innerHeight, "horizontal", false, ascending],
      bottom: [
        pl,
        height - pb,
        innerWidth,
        pb,
        "vertical",
        false,
        ascending,
        marginLeft,
        plotWidth
      ],
      left: [0, pt, pl, innerHeight, "horizontal", true, ascending],
      "top-left": [pl, 0, innerWidth, pt, "vertical", true, ascending],
      "top-right": [pl, 0, innerWidth, pt, "vertical", true, ascending],
      "bottom-left": [
        pl,
        height - pb,
        innerWidth,
        pb,
        "vertical",
        false,
        ascending
      ],
      "bottom-right": [
        pl,
        height - pb,
        innerWidth,
        pb,
        "vertical",
        false,
        ascending
      ],
      center: centerSection,
      inner: centerSection,
      outer: centerSection
    };
    return xySection;
  }
  function placeNonEntityComponents(components, coordinate, area2, position) {
    const [axisComponents, nonAxisComponents] = divide4(components, (component) => {
      if (typeof component.type === "string" && component.type.startsWith("axis")) {
        return true;
      }
      return false;
    });
    placeNonEntityAxis(axisComponents, coordinate, area2, position);
    placeCenter(nonAxisComponents, coordinate, area2);
  }
  function placeNonEntityAxis(components, coordinate, area2, position) {
    if (position === "center") {
      if (isRadar(coordinate)) {
        placeAxisRadar(components, coordinate, area2, position);
      } else if (isPolar(coordinate)) {
        placeArcLinear(components, coordinate, area2);
      } else if (isParallel(coordinate)) {
        placeAxisParallel(components, coordinate, area2, components[0].orientation);
      }
    } else if (position === "inner") {
      placeAxisArcInner(components, coordinate, area2);
    } else if (position === "outer") {
      placeAxisArcOuter(components, coordinate, area2);
    }
  }
  function placeAxisArcInner(components, coordinate, area2) {
    const [x3, y3, , height] = area2;
    const [cx, cy] = coordinate.getCenter();
    const [innerRadius] = radiusOf(coordinate);
    const r = height / 2;
    const size2 = innerRadius * r;
    const x05 = cx - size2;
    const y05 = cy - size2;
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      component.bbox = {
        x: x3 + x05,
        y: y3 + y05,
        width: size2 * 2,
        height: size2 * 2
      };
    }
  }
  function placeAxisArcOuter(components, coordinate, area2) {
    const [x3, y3, width, height] = area2;
    for (const component of components) {
      component.bbox = { x: x3, y: y3, width, height };
    }
  }
  function placeArcLinear(components, coordinate, area2) {
    const [x3, y3, width, height] = area2;
    for (const component of components) {
      component.bbox = { x: x3, y: y3, width, height };
    }
  }
  function placeAxisParallel(components, coordinate, area2, orientation) {
    if (orientation === "horizontal") {
      placeAxisParallelHorizontal(components, coordinate, area2);
    } else if (orientation === "vertical") {
      placeAxisParallelVertical(components, coordinate, area2);
    }
  }
  function placeAxisParallelVertical(components, coordinate, area2) {
    const [x3, y3, , height] = area2;
    const vector = new Array(components.length).fill(0);
    const points = coordinate.map(vector);
    const X = points.filter((_2, i) => i % 2 === 0).map((d3) => d3 + x3);
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      const x4 = X[i];
      const width = X[i + 1] - x4;
      component.bbox = { x: x4, y: y3, width, height };
    }
  }
  function placeAxisParallelHorizontal(components, coordinate, area2) {
    const [x3, y3, width] = area2;
    const vector = new Array(components.length).fill(0);
    const points = coordinate.map(vector);
    const Y = points.filter((_2, i) => i % 2 === 1).map((d3) => d3 + y3);
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      const y4 = Y[i];
      const height = Y[i + 1] - y4;
      component.bbox = { x: x3, y: y4, width, height };
    }
  }
  function placeAxisRadar(components, coordinate, area2, position) {
    const [x3, y3, width, height] = area2;
    for (const component of components) {
      component.bbox = { x: x3, y: y3, width, height };
      component.radar = {
        index: components.indexOf(component),
        count: components.length
      };
    }
  }
  function placePaddingArea(components, coordinate, area2) {
    const [x3, y3, width, height, direction2, reverse, comparator, minX, totalSize] = area2;
    const [mainStartKey, mainStartValue, crossStartKey, crossStartValue, mainSizeKey, mainSizeValue, crossSizeKey, crossSizeValue] = direction2 === "vertical" ? ["y", y3, "x", x3, "height", height, "width", width] : ["x", x3, "y", y3, "width", width, "height", height];
    components.sort((a3, b) => comparator === null || comparator === void 0 ? void 0 : comparator(a3.order, b.order));
    const isLarge = (type) => type === "title" || type === "group" || type.startsWith("legend");
    const crossSizeOf = (type, small, bigger) => {
      if (bigger === void 0)
        return small;
      if (isLarge(type))
        return bigger;
      return small;
    };
    const crossStartOf = (type, x4, minX2) => {
      if (minX2 === void 0)
        return x4;
      if (isLarge(type))
        return minX2;
      return x4;
    };
    const startValue = reverse ? mainStartValue + mainSizeValue : mainStartValue;
    for (let i = 0, start2 = startValue; i < components.length; i++) {
      const component = components[i];
      const { crossPadding = 0, type } = component;
      const { size: size2 } = component;
      component.bbox = {
        [mainStartKey]: reverse ? start2 - size2 - crossPadding : start2 + crossPadding,
        [crossStartKey]: crossStartOf(type, crossStartValue, minX),
        [mainSizeKey]: size2,
        [crossSizeKey]: crossSizeOf(type, crossSizeValue, totalSize)
      };
      start2 += (size2 + crossPadding) * (reverse ? -1 : 1);
    }
    const groupComponents2 = components.filter((d3) => d3.type === "group");
    for (const group3 of groupComponents2) {
      const { bbox, children } = group3;
      const size2 = bbox[crossSizeKey];
      const step2 = size2 / children.length;
      const justifyContent = children.reduce((j, child) => {
        var _a;
        const j0 = (_a = child.layout) === null || _a === void 0 ? void 0 : _a.justifyContent;
        return j0 ? j0 : j;
      }, "flex-start");
      const L = children.map((d3, i) => {
        const { length: length5 = step2, padding = 0 } = d3;
        return length5 + (i === children.length - 1 ? 0 : padding);
      });
      const totalLength = sum(L);
      const diff = size2 - totalLength;
      const offset3 = justifyContent === "flex-start" ? 0 : justifyContent === "center" ? diff / 2 : diff;
      for (let i = 0, start2 = bbox[crossStartKey] + offset3; i < children.length; i++) {
        const component = children[i];
        const { padding = 0 } = component;
        const interval2 = i === children.length - 1 ? 0 : padding;
        component.bbox = {
          [mainSizeKey]: bbox[mainSizeKey],
          [mainStartKey]: bbox[mainStartKey],
          [crossStartKey]: start2,
          [crossSizeKey]: L[i] - interval2
        };
        deep_mix_default(component, { layout: { justifyContent } });
        start2 += L[i];
      }
    }
  }
  function placeCenter(components, coordinate, area2) {
    if (components.length === 0)
      return;
    const [x3, y3, width, height] = area2;
    const [innerRadius] = radiusOf(coordinate);
    const r = height / 2 * innerRadius / Math.sqrt(2);
    const cx = x3 + width / 2;
    const cy = y3 + height / 2;
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      component.bbox = { x: cx - r, y: cy - r, width: r * 2, height: r * 2 };
    }
  }

  // node_modules/@antv/g2/esm/runtime/transform.js
  var __awaiter3 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest74 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function applyDefaults(I, mark, context) {
    const { encode = {}, scale: scale10 = {}, transform = [] } = mark, rest = __rest74(mark, ["encode", "scale", "transform"]);
    return [I, Object.assign(Object.assign({}, rest), { encode, scale: scale10, transform })];
  }
  function applyDataTransform(I, mark, context) {
    return __awaiter3(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const { data: data2 } = mark;
      const [useData] = useLibrary("data", library3);
      const descriptor = normalizedDataSource(data2);
      const { transform: T = [] } = descriptor, connector = __rest74(descriptor, ["transform"]);
      const transform = [connector, ...T];
      const transformFunctions2 = transform.map((t) => useData(t, context));
      const transformedData = yield composeAsync(transformFunctions2)(data2);
      const newData = data2 && !Array.isArray(data2) && !Array.isArray(transformedData) ? { value: transformedData } : transformedData;
      return [
        Array.isArray(transformedData) ? indexOf3(transformedData) : [],
        Object.assign(Object.assign({}, mark), { data: newData })
      ];
    });
  }
  function flatEncode(I, mark, context) {
    const { encode } = mark;
    if (!encode)
      return [I, mark];
    const flattenEncode = {};
    for (const [key, value2] of Object.entries(encode)) {
      if (Array.isArray(value2)) {
        for (let i = 0; i < value2.length; i++) {
          const name2 = `${key}${i === 0 ? "" : i}`;
          flattenEncode[name2] = value2[i];
        }
      } else {
        flattenEncode[key] = value2;
      }
    }
    return [I, Object.assign(Object.assign({}, mark), { encode: flattenEncode })];
  }
  function inferChannelsType(I, mark, context) {
    const { encode, data: data2 } = mark;
    if (!encode)
      return [I, mark];
    const typedEncode = mapObject(encode, (channel) => {
      if (isTypedChannel(channel))
        return channel;
      const type = inferChannelType(data2, channel);
      return { type, value: channel };
    });
    return [I, Object.assign(Object.assign({}, mark), { encode: typedEncode })];
  }
  function maybeVisualChannel(I, mark, context) {
    const { encode } = mark;
    if (!encode)
      return [I, mark];
    const newEncode = mapObject(encode, (channel, name2) => {
      const { type } = channel;
      if (type !== "constant" || isPosition(name2))
        return channel;
      return Object.assign(Object.assign({}, channel), { constant: true });
    });
    return [I, Object.assign(Object.assign({}, mark), { encode: newEncode })];
  }
  function extractColumns(I, mark, context) {
    const { encode, data: data2 } = mark;
    if (!encode)
      return [I, mark];
    const { library: library3 } = context;
    const columnOf2 = createColumnOf(library3);
    const valuedEncode = mapObject(encode, (channel) => columnOf2(data2, channel));
    return [I, Object.assign(Object.assign({}, mark), { encode: valuedEncode })];
  }
  function normalizeTooltip(I, mark, context) {
    const { tooltip: tooltip2 = {} } = mark;
    if (isUnset(tooltip2))
      return [I, mark];
    if (Array.isArray(tooltip2)) {
      return [I, Object.assign(Object.assign({}, mark), { tooltip: { items: tooltip2 } })];
    }
    if (isStrictObject(tooltip2) && isFullTooltip(tooltip2)) {
      return [I, Object.assign(Object.assign({}, mark), { tooltip: tooltip2 })];
    }
    return [I, Object.assign(Object.assign({}, mark), { tooltip: { items: [tooltip2] } })];
  }
  function extractTooltip(I, mark, context) {
    const { data: data2, encode, tooltip: tooltip2 = {} } = mark;
    if (isUnset(tooltip2))
      return [I, mark];
    const valueOf4 = (item) => {
      if (!item)
        return item;
      if (typeof item === "string") {
        return I.map((i) => ({ name: item, value: data2[i][item] }));
      }
      if (isStrictObject(item)) {
        const { field: field3, channel, color: color2, name: name2 = field3, valueFormatter = (d3) => d3 } = item;
        const normalizedValueFormatter = typeof valueFormatter === "string" ? format2(valueFormatter) : valueFormatter;
        const definedChannel = channel && encode[channel];
        const channelField = definedChannel && encode[channel].field;
        const name1 = name2 || channelField || channel;
        const values = [];
        for (const i of I) {
          const value1 = field3 ? data2[i][field3] : definedChannel ? encode[channel].value[i] : null;
          values[i] = {
            name: name1,
            color: color2,
            value: normalizedValueFormatter(value1)
          };
        }
        return values;
      }
      if (typeof item === "function") {
        const values = [];
        for (const i of I) {
          const v = item(data2[i], i, data2, encode);
          if (isStrictObject(v))
            values[i] = v;
          else
            values[i] = { value: v };
        }
        return values;
      }
      return item;
    };
    const { title, items = [] } = tooltip2, rest = __rest74(tooltip2, ["title", "items"]);
    const newTooltip = Object.assign({ title: valueOf4(title), items: Array.isArray(items) ? items.map(valueOf4) : [] }, rest);
    return [I, Object.assign(Object.assign({}, mark), { tooltip: newTooltip })];
  }
  function maybeArrayField(I, mark, context) {
    const { encode } = mark, rest = __rest74(mark, ["encode"]);
    if (!encode)
      return [I, mark];
    const columns = Object.entries(encode);
    const arrayColumns = columns.filter(([, channel]) => {
      const { value: V } = channel;
      return Array.isArray(V[0]);
    }).flatMap(([key, V]) => {
      const columns2 = [[key, new Array(I.length).fill(void 0)]];
      const { value: rows } = V, rest2 = __rest74(V, ["value"]);
      for (let i = 0; i < rows.length; i++) {
        const row2 = rows[i];
        if (Array.isArray(row2)) {
          for (let j = 0; j < row2.length; j++) {
            const column2 = columns2[j] || [
              `${key}${j}`,
              new Array(I).fill(void 0)
            ];
            column2[1][i] = row2[j];
            columns2[j] = column2;
          }
        }
      }
      return columns2.map(([key2, value2]) => [
        key2,
        Object.assign({ type: "column", value: value2 }, rest2)
      ]);
    });
    const newEncode = Object.fromEntries([...columns, ...arrayColumns]);
    return [I, Object.assign(Object.assign({}, rest), { encode: newEncode })];
  }
  function addGuideToScale(I, mark, context) {
    const { axis = {}, legend = {}, slider = {}, scrollbar = {} } = mark;
    const normalize9 = (guide, channel) => {
      if (typeof guide === "boolean")
        return guide ? {} : null;
      const eachGuide = guide[channel];
      return eachGuide === void 0 || eachGuide ? eachGuide : null;
    };
    const axisChannels = typeof axis === "object" ? Array.from(/* @__PURE__ */ new Set(["x", "y", "z", ...Object.keys(axis)])) : ["x", "y", "z"];
    deep_mix_default(mark, {
      scale: Object.assign(Object.assign({}, Object.fromEntries(axisChannels.map((channel) => {
        const scrollbarOptions = normalize9(scrollbar, channel);
        return [
          channel,
          Object.assign({ guide: normalize9(axis, channel), slider: normalize9(slider, channel), scrollbar: scrollbarOptions }, scrollbarOptions && {
            ratio: scrollbarOptions.ratio === void 0 ? 0.5 : scrollbarOptions.ratio
          })
        ];
      }))), {
        color: { guide: normalize9(legend, "color") },
        size: { guide: normalize9(legend, "size") },
        shape: { guide: normalize9(legend, "shape") },
        // fixme: opacity is conflict with DisplayObject.opacity
        // to be confirm.
        opacity: { guide: normalize9(legend, "opacity") }
      })
    });
    return [I, mark];
  }
  function maybeNonAnimate(I, mark, context) {
    const { animate: animate2 } = mark;
    if (animate2 || animate2 === void 0)
      return [I, mark];
    deep_mix_default(mark, {
      animate: {
        enter: { type: null },
        exit: { type: null },
        update: { type: null }
      }
    });
    return [I, mark];
  }
  function isTypedChannel(channel) {
    if (typeof channel !== "object" || channel instanceof Date || channel === null) {
      return false;
    }
    const { type } = channel;
    return defined(type);
  }
  function inferChannelType(data2, channel) {
    if (typeof channel === "function")
      return "transform";
    if (typeof channel === "string" && isField(data2, channel))
      return "field";
    return "constant";
  }
  function isField(data2, value2) {
    if (!Array.isArray(data2))
      return false;
    return data2.some((d3) => d3[value2] !== void 0);
  }
  function normalizedDataSource(data2) {
    if (isNumber2(data2))
      return { type: "inline", value: data2 };
    if (!data2)
      return { type: "inline", value: null };
    if (Array.isArray(data2))
      return { type: "inline", value: data2 };
    const { type = "inline" } = data2, rest = __rest74(data2, ["type"]);
    return Object.assign(Object.assign({}, rest), { type });
  }

  // node_modules/@antv/g2/esm/runtime/mark.js
  var __awaiter4 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest75 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function initializeMark(partialMark, partialProps, context) {
    return __awaiter4(this, void 0, void 0, function* () {
      const [I, transformedMark] = yield applyMarkTransform(partialMark, partialProps, context);
      const { encode, scale: scale10, data: data2, tooltip: tooltip2 } = transformedMark;
      if (Array.isArray(data2) === false) {
        return null;
      }
      const { channels: channelDescriptors } = partialProps;
      const nameChannels = rollups(Object.entries(encode).filter(([, value2]) => defined(value2)), (values) => values.map(([key, options]) => Object.assign({ name: key }, options)), ([key]) => {
        var _a;
        const prefix = (_a = /([^\d]+)\d*$/.exec(key)) === null || _a === void 0 ? void 0 : _a[1];
        const descriptor = channelDescriptors.find((d3) => d3.name === prefix);
        if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.independent)
          return key;
        return prefix;
      });
      const channels = channelDescriptors.filter((descriptor) => {
        const { name: name2, required: required2 } = descriptor;
        if (nameChannels.find(([d3]) => d3 === name2))
          return true;
        if (required2)
          throw new Error(`Missing encoding for channel: ${name2}.`);
        return false;
      }).flatMap((descriptor) => {
        const { name: name2, scale: scaleType, scaleKey, range: range3, quantitative, ordinal } = descriptor;
        const valuesArray = nameChannels.filter(([channel]) => channel.startsWith(name2));
        return valuesArray.map(([channel, values], i) => {
          const visual = values.some((d3) => d3.visual);
          const constant4 = values.some((d3) => d3.constant);
          const _a = scale10[channel] || {}, {
            independent = false,
            // Use channel name as default scale key.
            key = scaleKey || channel,
            // Visual channel use identity scale.
            type = constant4 ? "constant" : visual ? "identity" : scaleType
          } = _a, scaleOptions = __rest75(_a, ["independent", "key", "type"]);
          const isConstant = type === "constant";
          const finalRange = isConstant ? void 0 : range3;
          return {
            name: channel,
            values,
            // Generate a unique key for independent channel,
            // which will not group with any other channels.
            scaleKey: independent || isConstant ? Symbol("independent") : key,
            scale: Object.assign(Object.assign({ type, range: finalRange }, scaleOptions), {
              quantitative,
              ordinal
            })
          };
        });
      });
      return [transformedMark, Object.assign(Object.assign({}, partialProps), { index: I, channels, tooltip: tooltip2 })];
    });
  }
  function createColumnOf(library3) {
    const [useEncode] = useLibrary("encode", library3);
    return (data2, encode) => {
      if (encode === void 0)
        return null;
      if (data2 === void 0)
        return null;
      return Object.assign(Object.assign({}, encode), { type: "column", value: useEncode(encode)(data2), field: fieldOf(encode) });
    };
  }
  function applyMarkTransform(mark, props, context) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const [useTransform] = useLibrary("transform", library3);
      const { preInference = [], postInference = [] } = props;
      const { transform = [] } = mark;
      const transforms = [
        applyDefaults,
        applyDataTransform,
        flatEncode,
        inferChannelsType,
        maybeVisualChannel,
        extractColumns,
        maybeArrayField,
        maybeNonAnimate,
        addGuideToScale,
        normalizeTooltip,
        ...preInference.map(useTransform),
        ...transform.map(useTransform),
        ...postInference.map(useTransform),
        extractTooltip
      ];
      let index4 = [];
      let transformedMark = mark;
      for (const t of transforms) {
        [index4, transformedMark] = yield t(index4, transformedMark, context);
      }
      return [index4, transformedMark];
    });
  }
  function fieldOf(encode) {
    const { type, value: value2 } = encode;
    if (type === "field" && typeof value2 === "string")
      return value2;
    return null;
  }

  // node_modules/@antv/g2/esm/runtime/plot.js
  var __awaiter5 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest76 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function plot(options, selection, context) {
    var _a;
    return __awaiter5(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const [useComposition] = useLibrary("composition", library3);
      const [useInteraction] = useLibrary("interaction", library3);
      const marks = new Set(Object.keys(library3).map((d3) => {
        var _a2;
        return (_a2 = /mark\.(.*)/.exec(d3)) === null || _a2 === void 0 ? void 0 : _a2[1];
      }).filter(defined));
      const staticMarks = new Set(Object.keys(library3).map((d3) => {
        var _a2;
        return (_a2 = /component\.(.*)/.exec(d3)) === null || _a2 === void 0 ? void 0 : _a2[1];
      }).filter(defined));
      const typeOf = (node) => {
        const { type } = node;
        if (typeof type === "function") {
          const { props = {} } = type;
          const { composite = true } = props;
          if (composite)
            return "mark";
        }
        if (typeof type !== "string")
          return type;
        if (marks.has(type) || staticMarks.has(type))
          return "mark";
        return type;
      };
      const isMark2 = (node) => typeOf(node) === "mark";
      const isStandardView = (node) => typeOf(node) === "standardView";
      const isStaticMark = (node) => {
        const { type } = node;
        if (typeof type !== "string")
          return false;
        if (staticMarks.has(type))
          return true;
        return false;
      };
      const transform = (node) => {
        if (isStandardView(node))
          return [node];
        const type = typeOf(node);
        const composition = useComposition({ type, static: isStaticMark(node) });
        return composition(node);
      };
      const views = [];
      const viewNode = /* @__PURE__ */ new Map();
      const nodeState = /* @__PURE__ */ new Map();
      const discovered = [options];
      const nodeGenerators = [];
      while (discovered.length) {
        const node = discovered.shift();
        if (isStandardView(node)) {
          const state = nodeState.get(node);
          const [view, children] = state ? initializeState(state, node, library3) : yield initializeView(node, context);
          viewNode.set(view, node);
          views.push(view);
          const transformedNodes = children.flatMap(transform).map((d3) => coordinate2Transform(d3, library3));
          discovered.push(...transformedNodes);
          if (transformedNodes.every(isStandardView)) {
            const states = yield Promise.all(transformedNodes.map((d3) => initializeMarks(d3, context)));
            syncFacetsScales(states);
            for (let i = 0; i < transformedNodes.length; i++) {
              const nodeT = transformedNodes[i];
              const state2 = states[i];
              nodeState.set(nodeT, state2);
            }
          }
        } else {
          const n2 = isMark2(node) ? node : yield applyTransform(node, context);
          const N = transform(n2);
          if (Array.isArray(N))
            discovered.push(...N);
          else if (typeof N === "function")
            nodeGenerators.push(N());
        }
      }
      context.emitter.emit(ChartEvent.BEFORE_PAINT);
      const enterContainer = /* @__PURE__ */ new Map();
      const updateContainer = /* @__PURE__ */ new Map();
      const transitions = [];
      selection.selectAll(className(VIEW_CLASS_NAME)).data(views, (d3) => d3.key).join((enter) => enter.append("g").attr("className", VIEW_CLASS_NAME).attr("id", (view) => view.key).call(applyTranslate).each(function(view, i, element) {
        plotView(view, select(element), transitions, context);
        enterContainer.set(view, element);
      }), (update) => update.call(applyTranslate).each(function(view, i, element) {
        plotView(view, select(element), transitions, context);
        updateContainer.set(view, element);
      }), (exit) => exit.each(function(d3, i, element) {
        const interactions = element["nameInteraction"].values();
        for (const interaction of interactions) {
          interaction.destroy();
        }
      }).remove());
      const viewInstanceof = (viewContainer, updateInteractions2, oldStore) => {
        return Array.from(viewContainer.entries()).map(([view, container]) => {
          const store = oldStore || /* @__PURE__ */ new Map();
          const setState = (key, reducer = (x3) => x3) => store.set(key, reducer);
          const options2 = viewNode.get(view);
          const update = createUpdateView(select(container), options2, context);
          return {
            view,
            container,
            options: options2,
            setState,
            update: (from, updateTypes) => __awaiter5(this, void 0, void 0, function* () {
              const reducer = compose(Array.from(store.values()));
              const newOptions = reducer(options2);
              return yield update(newOptions, from, () => {
                if (isArray(updateTypes)) {
                  updateInteractions2(viewContainer, updateTypes, store);
                }
              });
            })
          };
        });
      };
      const updateInteractions = (container = updateContainer, updateType, oldStore) => {
        var _a2;
        const updateViewInstances = viewInstanceof(container, updateInteractions, oldStore);
        for (const target of updateViewInstances) {
          const { options: options2, container: container2 } = target;
          const nameInteraction = container2["nameInteraction"];
          let typeOptions = inferInteraction(options2);
          if (updateType) {
            typeOptions = typeOptions.filter((v) => updateType.includes(v[0]));
          }
          for (const typeOption of typeOptions) {
            const [type, option2] = typeOption;
            const prevInteraction = nameInteraction.get(type);
            if (prevInteraction)
              (_a2 = prevInteraction.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(prevInteraction);
            if (option2) {
              const interaction = useThemeInteraction(target.view, type, option2, useInteraction);
              const destroy3 = interaction(target, updateViewInstances, context.emitter);
              nameInteraction.set(type, { destroy: destroy3 });
            }
          }
        }
      };
      const enterViewInstances = viewInstanceof(enterContainer, updateInteractions);
      for (const target of enterViewInstances) {
        const { options: options2 } = target;
        const nameInteraction = /* @__PURE__ */ new Map();
        target.container["nameInteraction"] = nameInteraction;
        for (const typeOption of inferInteraction(options2)) {
          const [type, option2] = typeOption;
          if (option2) {
            const interaction = useThemeInteraction(target.view, type, option2, useInteraction);
            const destroy3 = interaction(target, enterViewInstances, context.emitter);
            nameInteraction.set(type, { destroy: destroy3 });
          }
        }
      }
      updateInteractions();
      const { width, height } = options;
      const keyframes = [];
      for (const nodeGenerator of nodeGenerators) {
        const keyframe = new Promise((resolve) => __awaiter5(this, void 0, void 0, function* () {
          for (const node of nodeGenerator) {
            const sizedNode = Object.assign({ width, height }, node);
            yield plot(sizedNode, selection, context);
          }
          resolve();
        }));
        keyframes.push(keyframe);
      }
      context.views = views;
      (_a = context.animations) === null || _a === void 0 ? void 0 : _a.forEach((animation) => animation === null || animation === void 0 ? void 0 : animation.cancel());
      context.animations = transitions;
      context.emitter.emit(ChartEvent.AFTER_PAINT);
      const finished = transitions.filter(defined).map(cancel).map((d3) => d3.finished);
      return Promise.all([...finished, ...keyframes]);
    });
  }
  function applyTranslate(selection) {
    selection.style("transform", (d3) => `translate(${d3.layout.x}, ${d3.layout.y})`);
  }
  function definedInteraction(library3) {
    const [, createInteraction] = useLibrary("interaction", library3);
    return (d3) => {
      const [name2, options] = d3;
      try {
        return [name2, createInteraction(name2)];
      } catch (_a) {
        return [name2, options.type];
      }
    };
  }
  function createUpdateView(selection, options, context) {
    const { library: library3 } = context;
    const createDefinedInteraction = definedInteraction(library3);
    const filter2 = (d3) => d3[1] && d3[1].props && d3[1].props.reapplyWhenUpdate;
    const interactions = inferInteraction(options);
    const updates = interactions.map(createDefinedInteraction).filter(filter2).map((d3) => d3[0]);
    return (newOptions, source, callback) => __awaiter5(this, void 0, void 0, function* () {
      const transitions = [];
      const [newView, newChildren] = yield initializeView(newOptions, context);
      plotView(newView, selection, transitions, context);
      for (const name2 of updates.filter((d3) => d3 !== source)) {
        updateInteraction(name2, selection, newOptions, newView, context);
      }
      for (const child of newChildren) {
        plot(child, selection, context);
      }
      callback();
      return { options: newOptions, view: newView };
    });
  }
  function updateInteraction(name2, selection, options, view, context) {
    var _a;
    const { library: library3 } = context;
    const [useInteraction] = useLibrary("interaction", library3);
    const container = selection.node();
    const nameInteraction = container["nameInteraction"];
    const interactionOptions = inferInteraction(options).find(([d3]) => d3 === name2);
    const interaction = nameInteraction.get(name2);
    if (!interaction)
      return;
    (_a = interaction.destroy) === null || _a === void 0 ? void 0 : _a.call(interaction);
    if (!interactionOptions[1])
      return;
    const applyInteraction = useThemeInteraction(view, name2, interactionOptions[1], useInteraction);
    const target = {
      options,
      view,
      container: selection.node(),
      update: (options2) => Promise.resolve(options2)
    };
    const destroy3 = applyInteraction(target, [], context.emitter);
    nameInteraction.set(name2, { destroy: destroy3 });
  }
  function initializeView(options, context) {
    return __awaiter5(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const flattenOptions = yield transformMarks(options, context);
      const mergedOptions = bubbleOptions(flattenOptions);
      options.interaction = mergedOptions.interaction;
      options.coordinate = mergedOptions.coordinate;
      options.marks = [...mergedOptions.marks, ...mergedOptions.components];
      const transformedOptions = coordinate2Transform(mergedOptions, library3);
      const state = yield initializeMarks(transformedOptions, context);
      return initializeState(state, transformedOptions, library3);
    });
  }
  function bubbleOptions(options) {
    const { coordinate: viewCoordinate = {}, interaction: viewInteraction = {}, style: viewStyle = {}, marks } = options, rest = __rest76(options, ["coordinate", "interaction", "style", "marks"]);
    const markCoordinates = marks.map((d3) => d3.coordinate || {});
    const markInteractions = marks.map((d3) => d3.interaction || {});
    const markViewStyles = marks.map((d3) => d3.viewStyle || {});
    const newCoordinate = [...markCoordinates, viewCoordinate].reduceRight((prev, cur) => deep_mix_default(prev, cur), {});
    const newInteraction = [viewInteraction, ...markInteractions].reduce((prev, cur) => deep_mix_default(prev, cur), {});
    const newStyle = [...markViewStyles, viewStyle].reduce((prev, cur) => deep_mix_default(prev, cur), {});
    return Object.assign(Object.assign({}, rest), { marks, coordinate: newCoordinate, interaction: newInteraction, style: newStyle });
  }
  function transformMarks(options, context) {
    return __awaiter5(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const [useMark, createMark] = useLibrary("mark", library3);
      const staticMarks = new Set(Object.keys(library3).map((d3) => {
        var _a;
        return (_a = /component\.(.*)/.exec(d3)) === null || _a === void 0 ? void 0 : _a[1];
      }).filter(defined));
      const { marks } = options;
      const flattenMarks = [];
      const components = [];
      const discovered = [...marks];
      const { width, height } = computeRoughPlotSize(options);
      const markOptions = { options, width, height };
      while (discovered.length) {
        const [node] = discovered.splice(0, 1);
        const mark = yield applyTransform(node, context);
        const { type = error2("G2Mark type is required."), key } = mark;
        if (staticMarks.has(type))
          components.push(mark);
        else {
          const { props = {} } = createMark(type);
          const { composite = true } = props;
          if (!composite)
            flattenMarks.push(mark);
          else {
            const { data: data2 } = mark;
            const newMark = Object.assign(Object.assign({}, mark), { data: data2 ? Array.isArray(data2) ? data2 : data2.value : data2 });
            const marks2 = yield useMark(newMark, markOptions);
            const M2 = Array.isArray(marks2) ? marks2 : [marks2];
            discovered.unshift(...M2.map((d3, i) => Object.assign(Object.assign({}, d3), { key: `${key}-${i}` })));
          }
        }
      }
      return Object.assign(Object.assign({}, options), { marks: flattenMarks, components });
    });
  }
  function initializeMarks(options, context) {
    return __awaiter5(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const [useTheme] = useLibrary("theme", library3);
      const [, createMark] = useLibrary("mark", library3);
      const { theme: partialTheme, marks: partialMarks, coordinates = [] } = options;
      const theme = useTheme(inferTheme(partialTheme));
      const markState = /* @__PURE__ */ new Map();
      for (const markOptions of partialMarks) {
        const { type } = markOptions;
        const { props = {} } = createMark(type);
        const markAndState = yield initializeMark(markOptions, props, context);
        if (markAndState) {
          const [initializedMark, state] = markAndState;
          markState.set(initializedMark, state);
        }
      }
      const scaleChannels = group(Array.from(markState.values()).flatMap((d3) => d3.channels), ({ scaleKey }) => scaleKey);
      for (const channels of scaleChannels.values()) {
        const scaleOptions = channels.reduce((total, { scale: scale11 }) => deep_mix_default(total, scale11), {});
        const { scaleKey } = channels[0];
        const { values: FV } = channels[0];
        const fields = Array.from(new Set(FV.map((d3) => d3.field).filter(defined)));
        const options2 = deep_mix_default({
          guide: { title: fields.length === 0 ? void 0 : fields },
          field: fields[0]
        }, scaleOptions);
        const { name: name2 } = channels[0];
        const values = channels.flatMap(({ values: values2 }) => values2.map((d3) => d3.value));
        const scale10 = Object.assign(Object.assign({}, inferScale(name2, values, options2, coordinates, theme, library3)), { uid: Symbol("scale"), key: scaleKey });
        channels.forEach((channel) => channel.scale = scale10);
      }
      return markState;
    });
  }
  function useThemeInteraction(view, type, option2, useInteraction) {
    const theme = view.theme;
    const defaults5 = typeof type === "string" ? theme[type] || {} : {};
    const interaction = useInteraction(deep_mix_default(defaults5, Object.assign({ type }, option2)));
    return interaction;
  }
  function initializeState(markState, options, library3) {
    var _a;
    const [useMark] = useLibrary("mark", library3);
    const [useTheme] = useLibrary("theme", library3);
    const [useLabelTransform] = useLibrary("labelTransform", library3);
    const { key, frame: frame2 = false, theme: partialTheme, clip, style = {}, labelTransform = [] } = options;
    const theme = useTheme(inferTheme(partialTheme));
    const states = Array.from(markState.values());
    const scales = collectScales(states, options);
    const components = normalizeComponents(inferComponent(inferComponentScales(Array.from(scales), states, markState), options, library3));
    const layout = computeLayout(components, options, theme, library3);
    const coordinate = createCoordinate(layout, options, library3);
    const framedStyle = frame2 ? deep_mix_default({ mainLineWidth: 1, mainStroke: "#000" }, style) : style;
    placeComponents(groupComponents(components), coordinate, layout);
    processAxisZ(components);
    const uidScale = new Map(Array.from(markState.values()).flatMap((state) => {
      const { channels } = state;
      return channels.map(({ scale: scale10 }) => [
        scale10.uid,
        useRelationScale(scale10, library3)
      ]);
    }));
    groupTransform(markState, uidScale);
    const scaleInstance = {};
    for (const component of components) {
      const { scales: scaleDescriptors = [] } = component;
      const scales2 = [];
      for (const descriptor of scaleDescriptors) {
        const { name: name2, uid } = descriptor;
        const scale10 = (_a = uidScale.get(uid)) !== null && _a !== void 0 ? _a : useRelationScale(descriptor, library3);
        scales2.push(scale10);
        if (name2 === "y") {
          scale10.update(Object.assign(Object.assign({}, scale10.getOptions()), { xScale: scaleInstance.x }));
        }
        assignScale(scaleInstance, { [name2]: scale10 });
      }
      component.scaleInstances = scales2;
    }
    const children = [];
    for (const [mark, state] of markState.entries()) {
      const {
        // scale,
        // Callback to create children options based on this mark.
        children: createChildren,
        // The total count of data (both show and hide)for this facet.
        // This is for unit visualization to sync data domain.
        dataDomain,
        modifier,
        key: markKey
      } = mark;
      const { index: index4, channels, tooltip: tooltip2 } = state;
      const scale10 = Object.fromEntries(channels.map(({ name: name2, scale: scale11 }) => [name2, scale11]));
      const markScaleInstance = mapObject(scale10, ({ uid }) => uidScale.get(uid));
      assignScale(scaleInstance, markScaleInstance);
      const value2 = applyScale(channels, markScaleInstance);
      const calcPoints = useMark(mark);
      const [I, P, S] = filterValid(calcPoints(index4, markScaleInstance, value2, coordinate));
      const count4 = dataDomain || I.length;
      const T = modifier ? modifier(P, count4, layout) : [];
      const titleOf = (i) => {
        var _a2, _b;
        return (_b = (_a2 = tooltip2.title) === null || _a2 === void 0 ? void 0 : _a2[i]) === null || _b === void 0 ? void 0 : _b.value;
      };
      const itemsOf2 = (i) => tooltip2.items.map((V) => V[i]);
      const visualData = I.map((d3, i) => {
        const datum = Object.assign({ points: P[i], transform: T[i], index: d3, markKey, viewKey: key }, tooltip2 && {
          title: titleOf(d3),
          items: itemsOf2(d3)
        });
        for (const [k, V] of Object.entries(value2)) {
          datum[k] = V[d3];
          if (S)
            datum[`series${upper_first_default(k)}`] = S[i].map((i2) => V[i2]);
        }
        if (S)
          datum["seriesIndex"] = S[i];
        if (S && tooltip2) {
          datum["seriesItems"] = S[i].map((si) => itemsOf2(si));
          datum["seriesTitle"] = S[i].map((si) => titleOf(si));
        }
        return datum;
      });
      state.data = visualData;
      state.index = I;
      const markChildren = createChildren === null || createChildren === void 0 ? void 0 : createChildren(visualData, markScaleInstance, layout);
      children.push(...markChildren || []);
    }
    const view = {
      layout,
      theme,
      coordinate,
      markState,
      key,
      clip,
      scale: scaleInstance,
      style: framedStyle,
      components,
      labelTransform: compose(labelTransform.map(useLabelTransform))
    };
    return [view, children];
  }
  function plotView(view, selection, transitions, context) {
    return __awaiter5(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const { components, theme, layout, markState, coordinate, key, style, clip, scale: scale10 } = view;
      const { x: x3, y: y3, width, height } = layout, rest = __rest76(layout, ["x", "y", "width", "height"]);
      const areaKeys = ["view", "plot", "main", "content"];
      const I = areaKeys.map((_2, i) => i);
      const sizeKeys = ["a", "margin", "padding", "inset"];
      const areaStyles = areaKeys.map((d3) => maybeSubObject(Object.assign({}, theme.view, style), d3));
      const areaSizes = sizeKeys.map((d3) => subObject(rest, d3));
      const styleArea = (selection2) => selection2.style("x", (i) => areaLayouts[i].x).style("y", (i) => areaLayouts[i].y).style("width", (i) => areaLayouts[i].width).style("height", (i) => areaLayouts[i].height).each(function(i, d3, element) {
        applyStyle2(select(element), areaStyles[i]);
      });
      let px2 = 0;
      let py = 0;
      let pw = width;
      let ph = height;
      const areaLayouts = I.map((i) => {
        const size2 = areaSizes[i];
        const { left: left2 = 0, top = 0, bottom = 0, right: right2 = 0 } = size2;
        px2 += left2;
        py += top;
        pw -= left2 + right2;
        ph -= top + bottom;
        return {
          x: px2,
          y: py,
          width: pw,
          height: ph
        };
      });
      selection.selectAll(className(AREA_CLASS_NAME)).data(
        // Only render area with defined style.
        I.filter((i) => defined(areaStyles[i])),
        (i) => areaKeys[i]
      ).join((enter) => enter.append("rect").attr("className", AREA_CLASS_NAME).style("zIndex", -2).call(styleArea), (update) => update.call(styleArea), (exit) => exit.remove());
      const animationExtent = computeAnimationExtent(markState);
      const componentAnimateOptions = animationExtent ? { duration: animationExtent[1] } : false;
      for (const [, C4] of groups(components, (d3) => `${d3.type}-${d3.position}`)) {
        C4.forEach((d3, i) => d3.index = i);
      }
      const componentsTransitions = selection.selectAll(className(COMPONENT_CLASS_NAME)).data(components, (d3) => `${d3.type}-${d3.position}-${d3.index}`).join((enter) => enter.append("g").style("zIndex", ({ zIndex }) => zIndex || -1).attr("className", COMPONENT_CLASS_NAME).append((options) => renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale10 }, options), coordinate, theme, library3, markState)), (update) => update.transition(function(options, i, element) {
        const { preserve = false } = options;
        if (preserve)
          return;
        const newComponent = renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale10 }, options), coordinate, theme, library3, markState);
        const { attributes } = newComponent;
        const [node] = element.childNodes;
        return node.update(attributes, false);
      })).transitions();
      transitions.push(...componentsTransitions.flat().filter(defined));
      const T = selection.selectAll(className(PLOT_CLASS_NAME)).data([layout], () => key).join((enter) => enter.append("rect").style("zIndex", 0).style("fill", "transparent").attr("className", PLOT_CLASS_NAME).call(updateBBox).call(updateLayers, Array.from(markState.keys())).call(applyClip, clip), (update) => update.call(updateLayers, Array.from(markState.keys())).call((selection2) => {
        return animationExtent ? animateBBox(selection2, animationExtent) : updateBBox(selection2);
      }).call(applyClip, clip)).transitions();
      transitions.push(...T.flat());
      for (const [mark, state] of markState.entries()) {
        const { data: data2 } = state;
        const { key: key2, class: cls, type } = mark;
        const viewNode = selection.select(`#${key2}`);
        const shapeFunction = createMarkShapeFunction(mark, state, view, context);
        const enterFunction = createEnterFunction(mark, state, view, library3);
        const updateFunction = createUpdateFunction(mark, state, view, library3);
        const exitFunction = createExitFunction(mark, state, view, library3);
        const facetElements = selectFacetElements(selection, viewNode, cls, "element");
        const T2 = viewNode.selectAll(className(ELEMENT_CLASS_NAME)).selectFacetAll(facetElements).data(data2, (d3) => d3.key, (d3) => d3.groupKey).join((enter) => enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data3, i, element) {
          return enterFunction(data3, [element]);
        }), (update) => update.call((selection2) => {
          const parent = selection2.parent();
          const origin = useMemo((node) => {
            const [x4, y4] = node.getBounds().min;
            return [x4, y4];
          });
          selection2.transition(function(data3, index4, element) {
            maybeFacetElement(element, parent, origin);
            const node = shapeFunction(data3, index4);
            const animation = updateFunction(data3, [element], [node]);
            if (animation !== null)
              return animation;
            if (element.nodeName === node.nodeName && node.nodeName !== "g") {
              copyAttributes(element, node);
            } else {
              element.parentNode.replaceChild(node, element);
              node.className = ELEMENT_CLASS_NAME;
              node.markType = type;
              node.__data__ = element.__data__;
            }
            return animation;
          }).attr("markType", type).attr("className", ELEMENT_CLASS_NAME);
        }), (exit) => {
          return exit.each(function(d3, i, element) {
            element.__removed__ = true;
          }).transition(function(data3, i, element) {
            return exitFunction(data3, [element]);
          }).remove();
        }, (merge2) => merge2.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data3, i, element) {
          const { __fromElements__: fromElements } = element;
          const transition2 = updateFunction(data3, fromElements, [element]);
          const exit = new Selection(fromElements, null, element.parentNode);
          exit.transition(transition2).remove();
          return transition2;
        }), (split) => split.transition(function(data3, i, element) {
          const enter = new Selection([], element.__toData__, element.parentNode);
          const toElements = enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).nodes();
          return updateFunction(data3, [element], toElements);
        }).remove()).transitions();
        transitions.push(...T2.flat());
      }
      plotLabel(view, selection, transitions, library3, context);
    });
  }
  function plotLabel(view, selection, transitions, library3, context) {
    const [useLabelTransform] = useLibrary("labelTransform", library3);
    const { markState, labelTransform } = view;
    const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
    const labelShapeFunction = /* @__PURE__ */ new Map();
    const labelDescriptor = /* @__PURE__ */ new Map();
    const labels = Array.from(markState.entries()).flatMap(([mark, state]) => {
      const { labels: labelOptions = [], key } = mark;
      const shapeFunction = createLabelShapeFunction(mark, state, view, library3, context);
      const elements = selection.select(`#${key}`).selectAll(className(ELEMENT_CLASS_NAME)).nodes().filter((n2) => !n2.__removed__);
      return labelOptions.flatMap((labelOption, i) => {
        const { transform = [] } = labelOption, options = __rest76(labelOption, ["transform"]);
        return elements.flatMap((e3) => {
          const L = getLabels(options, i, e3);
          L.forEach((l2) => {
            labelShapeFunction.set(l2, (data2) => shapeFunction(Object.assign(Object.assign({}, data2), { element: e3 })));
            labelDescriptor.set(l2, labelOption);
          });
          return L;
        });
      });
    });
    const labelShapes = select(labelLayer).selectAll(className(LABEL_CLASS_NAME)).data(labels, (d3) => d3.key).join((enter) => enter.append((d3) => labelShapeFunction.get(d3)(d3)).attr("className", LABEL_CLASS_NAME), (update) => update.each(function(d3, i, element) {
      const shapeFunction = labelShapeFunction.get(d3);
      const node = shapeFunction(d3);
      copyAttributes(element, node);
    }), (exit) => exit.remove()).nodes();
    const labelGroups = group(labelShapes, (d3) => labelDescriptor.get(d3.__data__));
    const { coordinate, layout } = view;
    const labelTransformContext = {
      canvas: context.canvas,
      coordinate,
      layout
    };
    for (const [label, shapes] of labelGroups) {
      const { transform = [] } = label;
      const transformFunction = compose(transform.map(useLabelTransform));
      transformFunction(shapes, labelTransformContext);
    }
    if (labelTransform) {
      labelTransform(labelShapes, labelTransformContext);
    }
  }
  function getLabels(label, labelIndex, element) {
    const { seriesIndex: SI, seriesKey, points, key, index: index4 } = element.__data__;
    const bounds = getLocalBounds(element);
    if (!SI) {
      return [
        Object.assign(Object.assign({}, label), {
          key: `${key}-${labelIndex}`,
          bounds,
          index: index4,
          points,
          dependentElement: element
        })
      ];
    }
    const selector = normalizeLabelSelector(label);
    const F = SI.map((index5, i) => Object.assign(Object.assign({}, label), {
      key: `${seriesKey[i]}-${labelIndex}`,
      bounds: [points[i]],
      index: index5,
      points,
      dependentElement: element
    }));
    return selector ? selector(F) : F;
  }
  function filterValid([I, P, S]) {
    if (S)
      return [I, P, S];
    const definedIndex = [];
    const definedPoints = [];
    for (let i = 0; i < I.length; i++) {
      const d3 = I[i];
      const p2 = P[i];
      if (p2.every(([x3, y3]) => defined(x3) && defined(y3))) {
        definedIndex.push(d3);
        definedPoints.push(p2);
      }
    }
    return [definedIndex, definedPoints];
  }
  function normalizeLabelSelector(label) {
    const { selector } = label;
    if (!selector)
      return null;
    if (typeof selector === "function")
      return selector;
    if (selector === "first")
      return (I) => [I[0]];
    if (selector === "last")
      return (I) => [I[I.length - 1]];
    throw new Error(`Unknown selector: ${selector}`);
  }
  function getLocalBounds(element) {
    const cloneElement = element.cloneNode();
    const animations = element.getAnimations();
    cloneElement.style.visibility = "hidden";
    animations.forEach((animation) => {
      const keyframes = animation.effect.getKeyframes();
      cloneElement.attr(keyframes[keyframes.length - 1]);
    });
    element.parentNode.appendChild(cloneElement);
    const bounds = cloneElement.getLocalBounds();
    cloneElement.destroy();
    const { min: min10, max: max11 } = bounds;
    return [min10, max11];
  }
  function createLabelShapeFunction(mark, state, view, library3, context) {
    const [useShape] = useLibrary("shape", library3);
    const { data: abstractData, encode } = mark;
    const { data: visualData, defaultLabelShape } = state;
    const point2d = visualData.map((d3) => d3.points);
    const channel = mapObject(encode, (d3) => d3.value);
    const { theme, coordinate } = view;
    const shapeContext = Object.assign(Object.assign({}, context), {
      document: documentOf(context),
      theme,
      coordinate
    });
    return (options) => {
      const { index: index4, points } = options;
      const datum = abstractData[index4];
      const { formatter: formatter2 = (d3) => `${d3}`, transform, style: abstractStyle, render: render2, selector, element } = options, abstractOptions = __rest76(options, ["formatter", "transform", "style", "render", "selector", "element"]);
      const visualOptions = mapObject(Object.assign(Object.assign({}, abstractOptions), abstractStyle), (d3) => valueOf2(d3, datum, index4, abstractData, {
        channel,
        element
      }));
      const { shape: shape23 = defaultLabelShape, text } = visualOptions, style = __rest76(visualOptions, ["shape", "text"]);
      const f = typeof formatter2 === "string" ? format2(formatter2) : formatter2;
      const value2 = Object.assign(Object.assign({}, style), { text: f(text, datum, index4, abstractData), datum });
      const shapeOptions = Object.assign({ type: `label.${shape23}`, render: render2 }, style);
      const shapeFunction = useShape(shapeOptions, shapeContext);
      const defaults5 = getDefaultsStyle(theme, "label", shape23, "label");
      return shapeFunction(points, value2, defaults5, point2d);
    };
  }
  function valueOf2(value2, datum, i, data2, options) {
    if (typeof value2 === "function")
      return value2(datum, i, data2, options);
    if (typeof value2 !== "string")
      return value2;
    if (isStrictObject(datum) && datum[value2] !== void 0)
      return datum[value2];
    return value2;
  }
  function computeAnimationExtent(markState) {
    let maxDuration = -Infinity;
    let minDelay = Infinity;
    for (const [mark, state] of markState) {
      const { animate: animate2 = {} } = mark;
      const { data: data2 } = state;
      const { enter = {}, update = {}, exit = {} } = animate2;
      const { type: defaultUpdateType, duration: defaultUpdateDuration = 300, delay: defaultUpdateDelay = 0 } = update;
      const { type: defaultEnterType, duration: defaultEnterDuration = 300, delay: defaultEnterDelay = 0 } = enter;
      const { type: defaultExitType, duration: defaultExitDuration = 300, delay: defaultExitDelay = 0 } = exit;
      for (const d3 of data2) {
        const { updateType = defaultUpdateType, updateDuration = defaultUpdateDuration, updateDelay = defaultUpdateDelay, enterType = defaultEnterType, enterDuration = defaultEnterDuration, enterDelay = defaultEnterDelay, exitDuration = defaultExitDuration, exitDelay = defaultExitDelay, exitType = defaultExitType } = d3;
        if (updateType === void 0 || updateType) {
          maxDuration = Math.max(maxDuration, updateDuration + updateDelay);
          minDelay = Math.min(minDelay, updateDelay);
        }
        if (exitType === void 0 || exitType) {
          maxDuration = Math.max(maxDuration, exitDuration + exitDelay);
          minDelay = Math.min(minDelay, exitDelay);
        }
        if (enterType === void 0 || enterType) {
          maxDuration = Math.max(maxDuration, enterDuration + enterDelay);
          minDelay = Math.min(minDelay, enterDelay);
        }
      }
    }
    if (maxDuration === -Infinity)
      return null;
    return [minDelay, maxDuration - minDelay];
  }
  function selectFacetElements(selection, current, facetClassName, elementClassName) {
    const group3 = selection.node().parentElement;
    return group3.findAll((node) => node.style.facet !== void 0 && node.style.facet === facetClassName && node !== current.node()).flatMap((node) => node.getElementsByClassName(elementClassName));
  }
  function maybeFacetElement(element, parent, originOf) {
    if (!element.__facet__)
      return;
    const prePlot = element.parentNode.parentNode;
    const newPlot = parent.parentNode;
    const [px2, py] = originOf(prePlot);
    const [x3, y3] = originOf(newPlot);
    const translate5 = `translate(${px2 - x3}, ${py - y3})`;
    appendTransform(element, translate5);
    parent.append(element);
  }
  function createMarkShapeFunction(mark, state, view, context) {
    const { library: library3 } = context;
    const [useShape] = useLibrary("shape", library3);
    const { data: abstractData, encode } = mark;
    const { defaultShape, data: data2, shape: shapeLibrary } = state;
    const channel = mapObject(encode, (d3) => d3.value);
    const point2d = data2.map((d3) => d3.points);
    const { theme, coordinate } = view;
    const { type: markType, style = {} } = mark;
    const shapeContext = Object.assign(Object.assign({}, context), {
      document: documentOf(context),
      coordinate,
      theme
    });
    return (data3) => {
      const { shape: styleShape = defaultShape } = style;
      const { shape: shape23 = styleShape, points, seriesIndex, index: i } = data3, v = __rest76(data3, ["shape", "points", "seriesIndex", "index"]);
      const value2 = Object.assign(Object.assign({}, v), { index: i });
      const abstractDatum = seriesIndex ? seriesIndex.map((i2) => abstractData[i2]) : abstractData[i];
      const I = seriesIndex ? seriesIndex : i;
      const visualStyle = mapObject(style, (d3) => valueOf2(d3, abstractDatum, I, abstractData, { channel }));
      const shapeFunction = shapeLibrary[shape23] ? shapeLibrary[shape23](visualStyle, shapeContext) : useShape(Object.assign(Object.assign({}, visualStyle), { type: shapeName(mark, shape23) }), shapeContext);
      const defaults5 = getDefaultsStyle(theme, markType, shape23, defaultShape);
      return shapeFunction(points, value2, defaults5, point2d);
    };
  }
  function getDefaultsStyle(theme, mark, shape23, defaultShape) {
    if (typeof mark !== "string")
      return;
    const { color: color2 } = theme;
    const markTheme = theme[mark] || {};
    const shapeTheme = markTheme[shape23] || markTheme[defaultShape];
    return Object.assign({ color: color2 }, shapeTheme);
  }
  function createAnimationFunction(type, mark, state, view, library3) {
    var _a, _b;
    const [, createShape] = useLibrary("shape", library3);
    const [useAnimation] = useLibrary("animation", library3);
    const { defaultShape, shape: shapeLibrary } = state;
    const { theme, coordinate } = view;
    const upperType = upper_first_default(type);
    const key = `default${upperType}Animation`;
    const { [key]: defaultAnimation } = ((_a = shapeLibrary[defaultShape]) === null || _a === void 0 ? void 0 : _a.props) || createShape(shapeName(mark, defaultShape)).props;
    const { [type]: defaultEffectTiming = {} } = theme;
    const animate2 = ((_b = mark.animate) === null || _b === void 0 ? void 0 : _b[type]) || {};
    const context = { coordinate };
    return (data2, from, to) => {
      const { [`${type}Type`]: animation, [`${type}Delay`]: delay, [`${type}Duration`]: duration, [`${type}Easing`]: easing } = data2;
      const options = Object.assign({ type: animation || defaultAnimation }, animate2);
      if (!options.type)
        return null;
      const animateFunction = useAnimation(options, context);
      const value2 = { delay, duration, easing };
      const A5 = animateFunction(from, to, deep_mix_default(defaultEffectTiming, value2));
      if (!Array.isArray(A5))
        return [A5];
      return A5;
    };
  }
  function createEnterFunction(mark, state, view, library3) {
    return createAnimationFunction("enter", mark, state, view, library3);
  }
  function cancel(animation) {
    animation.finished.then(() => {
      animation.cancel();
    });
    return animation;
  }
  function createUpdateFunction(mark, state, view, library3) {
    return createAnimationFunction("update", mark, state, view, library3);
  }
  function createExitFunction(mark, state, view, library3) {
    return createAnimationFunction("exit", mark, state, view, library3);
  }
  function inferTheme(theme = {}) {
    if (typeof theme === "string")
      return { type: theme };
    const { type = "light" } = theme, rest = __rest76(theme, ["type"]);
    return Object.assign(Object.assign({}, rest), { type });
  }
  function inferInteraction(view) {
    const defaults5 = {
      event: true,
      tooltip: true,
      // @todo Inferred by slider self.
      sliderFilter: true,
      legendFilter: true,
      scrollbarFilter: true
    };
    const { interaction = {} } = view;
    return Object.entries(deep_mix_default(defaults5, interaction)).reverse();
  }
  function applyTransform(node, context) {
    return __awaiter5(this, void 0, void 0, function* () {
      const { data: data2 } = node, rest = __rest76(node, ["data"]);
      if (data2 == void 0)
        return node;
      const [, { data: newData }] = yield applyDataTransform([], { data: data2 }, context);
      return Object.assign({ data: newData }, rest);
    });
  }
  function updateBBox(selection) {
    selection.style("transform", (d3) => `translate(${d3.paddingLeft + d3.marginLeft}, ${d3.paddingTop + d3.marginTop})`).style("width", (d3) => d3.innerWidth).style("height", (d3) => d3.innerHeight);
  }
  function animateBBox(selection, extent2) {
    const [delay, duration] = extent2;
    selection.transition(function(data2, i, element) {
      const { transform, width, height } = element.style;
      const { paddingLeft, paddingTop, innerWidth, innerHeight, marginLeft, marginTop } = data2;
      const keyframes = [
        {
          transform,
          width,
          height
        },
        {
          transform: `translate(${paddingLeft + marginLeft}, ${paddingTop + marginTop})`,
          width: innerWidth,
          height: innerHeight
        }
      ];
      return element.animate(keyframes, { delay, duration, fill: "both" });
    });
  }
  function shapeName(mark, name2) {
    const { type } = mark;
    if (typeof name2 === "string")
      return `${type}.${name2}`;
    return name2;
  }
  function updateLayers(selection, marks) {
    const facet = (d3) => d3.class !== void 0 ? `${d3.class}` : "";
    const nodes = selection.nodes();
    if (nodes.length === 0)
      return;
    selection.selectAll(className(MAIN_LAYER_CLASS_NAME)).data(marks, (d3) => d3.key).join((enter) => enter.append("g").attr("className", MAIN_LAYER_CLASS_NAME).attr("id", (d3) => d3.key).style("facet", facet).style("fill", "transparent").style("zIndex", (d3) => {
      var _a;
      return (_a = d3.zIndex) !== null && _a !== void 0 ? _a : 0;
    }), (update) => update.style("facet", facet).style("fill", "transparent").style("zIndex", (d3) => {
      var _a;
      return (_a = d3.zIndex) !== null && _a !== void 0 ? _a : 0;
    }), (exit) => exit.remove());
    const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
    if (labelLayer)
      return;
    selection.append("g").attr("className", LABEL_LAYER_CLASS_NAME).style("zIndex", 0);
  }
  function className(...names) {
    return names.map((d3) => `.${d3}`).join("");
  }
  function applyClip(selection, clip) {
    if (!selection.node())
      return;
    selection.style("clipPath", (data2) => {
      if (!clip)
        return null;
      const { paddingTop: y3, paddingLeft: x3, marginLeft: x12, marginTop: y12, innerWidth: width, innerHeight: height } = data2;
      return new Rect({ style: { x: x3 + x12, y: y3 + y12, width, height } });
    });
  }
  function inferComponentScales(scales, states, markState) {
    var _a;
    for (const [key] of markState.entries()) {
      if (key.type === "cell") {
        return scales.filter((scale10) => scale10.name !== "shape");
      }
    }
    if (states.length !== 1 || scales.some((scale10) => scale10.name === "shape")) {
      return scales;
    }
    const { defaultShape: shape23 } = states[0];
    const acceptMarkTypes = ["point", "line", "rect", "hollow"];
    if (!acceptMarkTypes.includes(shape23))
      return scales;
    const shapeMap = {
      point: "point",
      line: "hyphen",
      rect: "square",
      hollow: "hollow"
    };
    const field3 = ((_a = scales.find((scale10) => scale10.name === "color")) === null || _a === void 0 ? void 0 : _a.field) || null;
    const shapeScale = {
      field: field3,
      name: "shape",
      type: "constant",
      domain: [],
      range: [shapeMap[shape23]]
    };
    return [...scales, shapeScale];
  }
  function applyStyle2(selection, style) {
    for (const [key, value2] of Object.entries(style)) {
      selection.style(key, value2);
    }
  }

  // node_modules/@antv/g2/esm/utils/flow.js
  function flow(...flows) {
    return (param) => {
      return flows.reduce((result, f) => {
        return f(result);
      }, param);
    };
  }

  // node_modules/@antv/g2/esm/runtime/option-preprocess/style.js
  function columnWidthRatio(options) {
    const { style, scale: scale10, type } = options;
    const scaleOption = {};
    const columnWidthRatio2 = get_default(style, "columnWidthRatio");
    if (columnWidthRatio2 && type === "interval") {
      scaleOption.x = Object.assign(Object.assign({}, scale10 === null || scale10 === void 0 ? void 0 : scale10.x), { padding: 1 - columnWidthRatio2 });
    }
    return Object.assign(Object.assign({}, options), { scale: Object.assign(Object.assign({}, scale10), scaleOption) });
  }

  // node_modules/@antv/g2/esm/runtime/option-preprocess/index.js
  function preprocessOption(options) {
    const convertedOptions = adapter(options);
    if (convertedOptions.children && Array.isArray(convertedOptions.children)) {
      convertedOptions.children = convertedOptions.children.map((child) => preprocessOption(child));
    }
    return convertedOptions;
  }
  function adapter(options) {
    return flow(columnWidthRatio)(options);
  }

  // node_modules/@antv/g2/esm/runtime/render.js
  function inferKeys(options) {
    const root2 = deep_mix_default({}, options);
    const nodeParent = /* @__PURE__ */ new Map([[root2, null]]);
    const nodeIndex = /* @__PURE__ */ new Map([[null, -1]]);
    const discovered = [root2];
    while (discovered.length) {
      const node = discovered.shift();
      if (node.key === void 0) {
        const parent = nodeParent.get(node);
        const index4 = nodeIndex.get(node);
        const key = parent === null ? `${0}` : `${parent.key}-${index4}`;
        node.key = key;
      }
      const { children = [] } = node;
      if (Array.isArray(children)) {
        for (let i = 0; i < children.length; i++) {
          const child = deep_mix_default({}, children[i]);
          children[i] = child;
          nodeParent.set(child, node);
          nodeIndex.set(child, i);
          discovered.push(child);
        }
      }
    }
    return root2;
  }
  function Canvas2(width, height) {
    const renderer = new Renderer2();
    renderer.registerPlugin(new Plugin7());
    return new Canvas({
      width,
      height,
      container: document.createElement("div"),
      renderer
    });
  }
  function render(options, context = {}, resolve = () => {
  }, reject = (e3) => {
    throw e3;
  }) {
    const { width = 640, height = 480, depth = 0 } = options;
    const preprocessedOption = preprocessOption(options);
    const keyed2 = inferKeys(preprocessedOption);
    const { canvas = Canvas2(width, height), emitter = new esm_default(), library: library3 } = context;
    context.canvas = canvas;
    context.emitter = emitter;
    const { width: prevWidth, height: prevHeight } = canvas.getConfig();
    if (prevWidth !== width || prevHeight !== height) {
      canvas.resize(width, height);
    }
    emitter.emit(ChartEvent.BEFORE_RENDER);
    const selection = select(canvas.document.documentElement);
    canvas.ready.then(() => plot(Object.assign(Object.assign({}, keyed2), { width, height, depth }), selection, context)).then(() => {
      if (depth) {
        const [x3, y3] = canvas.document.documentElement.getPosition();
        canvas.document.documentElement.setPosition(x3, y3, -depth / 2);
      }
      canvas.requestAnimationFrame(() => {
        canvas.requestAnimationFrame(() => {
          emitter.emit(ChartEvent.AFTER_RENDER);
          resolve === null || resolve === void 0 ? void 0 : resolve();
        });
      });
    }).catch((e3) => {
      reject === null || reject === void 0 ? void 0 : reject(e3);
    });
    return normalizeContainer(canvas.getConfig().container);
  }
  function destroy2(options, context = {}, isDestroyCanvas = false) {
    const { canvas, emitter } = context;
    if (canvas) {
      destroyAllInteractions(canvas);
      isDestroyCanvas ? canvas.destroy() : canvas.destroyChildren();
    }
    emitter.off();
  }
  function destroyAllInteractions(canvas) {
    const viewGroups = canvas.getRoot().querySelectorAll(`.${VIEW_CLASS_NAME}`);
    viewGroups === null || viewGroups === void 0 ? void 0 : viewGroups.forEach((group3) => {
      const { nameInteraction = /* @__PURE__ */ new Map() } = group3;
      if ((nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.size) > 0) {
        Array.from(nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.values()).forEach((value2) => {
          value2 === null || value2 === void 0 ? void 0 : value2.destroy();
        });
      }
    });
  }
  function normalizeContainer(container) {
    return typeof container === "string" ? document.getElementById(container) : container;
  }

  // node_modules/@antv/g2/esm/utils/style.js
  var defaultStyle = {
    visibility: "visible",
    opacity: 1,
    fillOpacity: 1,
    strokeOpacity: 1
  };
  function getStyle2(element, key) {
    var _a;
    return (_a = element.style[key]) !== null && _a !== void 0 ? _a : defaultStyle[key];
  }
  function setStyle2(element, key, value2, recursive) {
    element.style[key] = value2;
    if (recursive) {
      element.children.forEach((child) => setStyle2(child, key, value2, recursive));
    }
  }
  function hide2(element) {
    setStyle2(element, "visibility", "hidden", true);
  }
  function show2(element) {
    setStyle2(element, "visibility", "visible", true);
  }

  // node_modules/@antv/g2/esm/interaction/utils.js
  var __rest77 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function selectG2Elements(root2) {
    return select(root2).selectAll(`.${ELEMENT_CLASS_NAME}`).nodes().filter((d3) => !d3.__removed__);
  }
  function selectFacetG2Elements(target, viewInstances) {
    return selectFacetViews(target, viewInstances).flatMap(({ container }) => selectG2Elements(container));
  }
  function selectFacetViews(target, viewInstances) {
    return viewInstances.filter((d3) => d3 !== target && d3.options.parentKey === target.options.key);
  }
  function selectPlotArea(root2) {
    return select(root2).select(`.${PLOT_CLASS_NAME}`).node();
  }
  function bboxOf(element) {
    if (element.tagName === "g")
      return element.getRenderBounds();
    const bounds = element.getGeometryBounds();
    const aabb = new AABB();
    aabb.setFromTransformedAABB(bounds, element.getWorldTransform());
    return aabb;
  }
  function mousePosition(target, event) {
    const { offsetX, offsetY } = event;
    const bbox = bboxOf(target);
    const { min: [x3, y3], max: [x12, y12] } = bbox;
    const isOutX = offsetX < x3 || offsetX > x12;
    const isOutY = offsetY < y3 || offsetY > y12;
    if (isOutX || isOutY)
      return null;
    return [offsetX - x3, offsetY - y3];
  }
  function brushMousePosition(target, event) {
    const { offsetX, offsetY } = event;
    const [x3, y3, x12, y12] = boundsOfBrushArea(target);
    return [
      Math.min(x12, Math.max(x3, offsetX)) - x3,
      Math.min(y12, Math.max(y3, offsetY)) - y3
    ];
  }
  function boundsOfBrushArea(target) {
    const bbox = target.getRenderBounds();
    const { min: [x05, y05], max: [x12, y12] } = bbox;
    return [x05, y05, x12, y12];
  }
  function createColorKey(view) {
    return (element) => element.__data__.color;
  }
  function createXKey(view) {
    return (element) => element.__data__.x;
  }
  function createDatumof(view) {
    const views = Array.isArray(view) ? view : [view];
    const keyData = new Map(views.flatMap((view2) => {
      const marks = Array.from(view2.markState.keys());
      return marks.map((mark) => [keyed(view2.key, mark.key), mark.data]);
    }));
    return (element) => {
      const { index: index4, markKey, viewKey } = element.__data__;
      const data2 = keyData.get(keyed(viewKey, markKey));
      return data2[index4];
    };
  }
  function useState(style, valueof2 = (d3, element) => d3, setAttribute = (element, key, v) => element.setAttribute(key, v)) {
    const STATES = "__states__";
    const ORIGINAL = "__ordinal__";
    const updateState = (element) => {
      const { [STATES]: states = [], [ORIGINAL]: original = {} } = element;
      const stateStyle = states.reduce((mixedStyle, state) => Object.assign(Object.assign({}, mixedStyle), style[state]), original);
      if (Object.keys(stateStyle).length === 0)
        return;
      for (const [key, value2] of Object.entries(stateStyle)) {
        const currentValue = getStyle2(element, key);
        const v = valueof2(value2, element);
        setAttribute(element, key, v);
        if (!(key in original))
          original[key] = currentValue;
      }
      element[ORIGINAL] = original;
    };
    const initState = (element) => {
      if (element[STATES])
        return;
      element[STATES] = [];
      return;
    };
    const setState = (element, ...states) => {
      initState(element);
      element[STATES] = [...states];
      updateState(element);
    };
    const removeState = (element, ...states) => {
      initState(element);
      for (const state of states) {
        const index4 = element[STATES].indexOf(state);
        if (index4 !== -1) {
          element[STATES].splice(index4, 1);
        }
      }
      updateState(element);
    };
    const hasState = (element, state) => {
      initState(element);
      return element[STATES].indexOf(state) !== -1;
    };
    return {
      setState,
      removeState,
      hasState
    };
  }
  function isEmptyObject(obj) {
    if (obj === void 0)
      return true;
    if (typeof obj !== "object")
      return false;
    return Object.keys(obj).length === 0;
  }
  function keyed(viewKey, markKey) {
    return `${viewKey},${markKey}`;
  }
  function mergeState(options, states) {
    const views = Array.isArray(options) ? options : [options];
    const markState = views.flatMap((view) => view.marks.map((mark) => [keyed(view.key, mark.key), mark.state]));
    const state = {};
    for (const descriptor of states) {
      const [key, defaults5] = Array.isArray(descriptor) ? descriptor : [descriptor, {}];
      state[key] = markState.reduce((merged, mark) => {
        const [markKey, markState2 = {}] = mark;
        const selectedState = isEmptyObject(markState2[key]) ? defaults5 : markState2[key];
        for (const [attr2, value2] of Object.entries(selectedState)) {
          const oldValue = merged[attr2];
          const newValue = (data2, index4, array2, element) => {
            const k = keyed(element.__data__.viewKey, element.__data__.markKey);
            if (markKey !== k)
              return oldValue === null || oldValue === void 0 ? void 0 : oldValue(data2, index4, array2, element);
            if (typeof value2 !== "function")
              return value2;
            return value2(data2, index4, array2, element);
          };
          merged[attr2] = newValue;
        }
        return merged;
      }, {});
    }
    return state;
  }
  function createValueof(elements, datum) {
    const elementIndex = new Map(elements.map((d3, i) => [d3, i]));
    const fa = datum ? elements.map(datum) : elements;
    return (d3, e3) => {
      if (typeof d3 !== "function")
        return d3;
      const i = elementIndex.get(e3);
      const fe = datum ? datum(e3) : e3;
      return d3(fe, i, fa, e3);
    };
  }
  function renderLink(_a) {
    var { link: link2 = false, valueof: valueof2 = (d3, element) => d3, coordinate } = _a, style = __rest77(_a, ["link", "valueof", "coordinate"]);
    const LINK_CLASS_NAME = "element-link";
    if (!link2)
      return [() => {
      }, () => {
      }];
    const pointsOf = (element) => element.__data__.points;
    const pathPointsOf = (P0, P1) => {
      const [, p1, p2] = P0;
      const [p0, , , p3] = P1;
      const P = [p1, p0, p3, p2];
      return P;
    };
    const append3 = (elements) => {
      var _a2;
      if (elements.length <= 1)
        return;
      const sortedElements = sort2(elements, (e0, e1) => {
        const { x: x05 } = e0.__data__;
        const { x: x12 } = e1.__data__;
        const dx = x05 - x12;
        return dx;
      });
      for (let i = 1; i < sortedElements.length; i++) {
        const p2 = path();
        const e0 = sortedElements[i - 1];
        const e1 = sortedElements[i];
        const [p0, p1, p22, p3] = pathPointsOf(pointsOf(e0), pointsOf(e1));
        p2.moveTo(...p0);
        p2.lineTo(...p1);
        p2.lineTo(...p22);
        p2.lineTo(...p3);
        p2.closePath();
        const _b = mapObject(style, (d3) => valueof2(d3, e0)), { fill = e0.getAttribute("fill") } = _b, rest = __rest77(_b, ["fill"]);
        const link3 = new Path2({
          className: LINK_CLASS_NAME,
          style: Object.assign({ d: p2.toString(), fill, zIndex: -2 }, rest)
        });
        (_a2 = e0.link) === null || _a2 === void 0 ? void 0 : _a2.remove();
        e0.parentNode.appendChild(link3);
        e0.link = link3;
      }
    };
    const remove = (element) => {
      var _a2;
      (_a2 = element.link) === null || _a2 === void 0 ? void 0 : _a2.remove();
      element.link = null;
    };
    return [append3, remove];
  }
  function offsetTransform(element, offset3, coordinate) {
    const append3 = (t) => {
      const { transform } = element.style;
      return transform ? `${transform} ${t}` : t;
    };
    if (isPolar(coordinate)) {
      const { points } = element.__data__;
      const [p0, p1] = isTranspose(coordinate) ? reorder(points) : points;
      const center2 = coordinate.getCenter();
      const v0 = sub6(p0, center2);
      const v1 = sub6(p1, center2);
      const a0 = angle3(v0);
      const da = angleBetween2(v0, v1);
      const amid = a0 + da / 2;
      const dx = offset3 * Math.cos(amid);
      const dy = offset3 * Math.sin(amid);
      return append3(`translate(${dx}, ${dy})`);
    }
    if (isTranspose(coordinate))
      return append3(`translate(${offset3}, 0)`);
    return append3(`translate(0, ${-offset3})`);
  }
  function renderBackground(_a) {
    var { document: document2, background, scale: scale10, coordinate, valueof: valueof2 } = _a, rest = __rest77(_a, ["document", "background", "scale", "coordinate", "valueof"]);
    const BACKGROUND_CLASS_NAME = "element-background";
    if (!background)
      return [() => {
      }, () => {
      }];
    const extentOf2 = (scale11, x3, padding) => {
      const ax = scale11.invert(x3);
      const mid2 = x3 + scale11.getBandWidth(ax) / 2;
      const half = scale11.getStep(ax) / 2;
      const offset3 = half * padding;
      return [mid2 - half + offset3, mid2 + half - offset3];
    };
    const sizeXOf = (element, padding) => {
      const { x: scaleX2 } = scale10;
      if (!isOrdinalScale(scaleX2))
        return [0, 1];
      const { __data__: data2 } = element;
      const { x: x3 } = data2;
      const [e1, e23] = extentOf2(scaleX2, x3, padding);
      return [e1, e23];
    };
    const sizeYOf = (element, padding) => {
      const { y: scaleY2 } = scale10;
      if (!isOrdinalScale(scaleY2))
        return [0, 1];
      const { __data__: data2 } = element;
      const { y: y3 } = data2;
      const [e1, e23] = extentOf2(scaleY2, y3, padding);
      return [e1, e23];
    };
    const bandShapeOf = (element, style) => {
      const { padding } = style;
      const [x12, x22] = sizeXOf(element, padding);
      const [y12, y22] = sizeYOf(element, padding);
      const points = [
        [x12, y12],
        [x22, y12],
        [x22, y22],
        [x12, y22]
      ].map((d3) => coordinate.map(d3));
      const { __data__: data2 } = element;
      const { y: dy, y1: dy1 } = data2;
      return rect(document2, points, { y: dy, y1: dy1 }, coordinate, style);
    };
    const cloneShapeOf = (element, style) => {
      const { transform = "scale(1.2, 1.2)", transformOrigin = "center center", stroke: stroke2 = "" } = style, rest2 = __rest77(style, ["transform", "transformOrigin", "stroke"]);
      const finalStyle = Object.assign({ transform, transformOrigin, stroke: stroke2 }, rest2);
      const shape23 = element.cloneNode(true);
      for (const [key, value2] of Object.entries(finalStyle)) {
        shape23.style[key] = value2;
      }
      return shape23;
    };
    const isOrdinalShape = () => {
      const { x: x3, y: y3 } = scale10;
      return [x3, y3].some(isOrdinalScale);
    };
    const append3 = (element) => {
      if (element.background)
        element.background.remove();
      const _a2 = mapObject(rest, (d3) => valueof2(d3, element)), { fill = "#CCD6EC", fillOpacity = 0.3, zIndex = -2, padding = 1e-3, lineWidth = 0 } = _a2, style = __rest77(_a2, ["fill", "fillOpacity", "zIndex", "padding", "lineWidth"]);
      const finalStyle = Object.assign(Object.assign({}, style), {
        fill,
        fillOpacity,
        zIndex,
        padding,
        lineWidth
      });
      const shapeOf = isOrdinalShape() ? bandShapeOf : cloneShapeOf;
      const shape23 = shapeOf(element, finalStyle);
      shape23.className = BACKGROUND_CLASS_NAME;
      element.parentNode.parentNode.appendChild(shape23);
      element.background = shape23;
    };
    const remove = (element) => {
      var _a2;
      (_a2 = element.background) === null || _a2 === void 0 ? void 0 : _a2.remove();
      element.background = null;
    };
    const is2 = (element) => {
      return element.className === BACKGROUND_CLASS_NAME;
    };
    return [append3, remove, is2];
  }
  function setCursor(root2, cursor) {
    const canvas = root2.getRootNode().defaultView;
    const dom2 = canvas.getContextService().getDomElement();
    if (dom2 === null || dom2 === void 0 ? void 0 : dom2.style) {
      root2.cursor = dom2.style.cursor;
      dom2.style.cursor = cursor;
    }
  }
  function restoreCursor(root2) {
    setCursor(root2, root2.cursor);
  }
  function selectElementByData(elements, data2, datum) {
    return elements.find((d3) => Object.entries(data2).every(([key, value2]) => datum(d3)[key] === value2));
  }
  function getPointsR(point6, nextPoint) {
    return Math.sqrt(Math.pow(point6[0] - nextPoint[0], 2) + Math.pow(point6[1] - nextPoint[1], 2));
  }
  function getPointsPath(points, isClose = false) {
    const path2 = filter_default(points, (d3) => !!d3).map((d3, i) => {
      return [i === 0 ? "M" : "L", ...d3];
    });
    if (isClose) {
      path2.push(["Z"]);
    }
    return path2;
  }
  function getElements(plot2) {
    return plot2.querySelectorAll(".element");
  }
  function getThetaPath(center2, points, isBig = 0) {
    const path2 = [["M", ...points[1]]];
    const innerRadius = getPointsR(center2, points[1]);
    const outerRadius = getPointsR(center2, points[0]);
    if (innerRadius === 0) {
      path2.push(["L", ...points[3]], ["A", outerRadius, outerRadius, 0, isBig, 1, ...points[0]], ["Z"]);
    } else {
      path2.push(["A", innerRadius, innerRadius, 0, isBig, 0, ...points[2]], ["L", ...points[3]], ["A", outerRadius, outerRadius, 0, isBig, 1, ...points[0]], ["Z"]);
    }
    return path2;
  }
  function maybeRoot(node, rootOf) {
    if (rootOf(node))
      return node;
    let root2 = node.parent;
    while (root2 && !rootOf(root2))
      root2 = root2.parent;
    return root2;
  }

  // node_modules/@antv/g2/esm/interaction/elementHighlight.js
  var __rest78 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function elementHighlight(root2, {
    elements: elementsof,
    // given the root of chart returns elements to be manipulated
    datum,
    // given each element returns the datum of it
    groupKey = (d3) => d3,
    // group elements by specified key
    link: link2 = false,
    // draw link or not
    background = false,
    // draw background or not
    delay = 60,
    // delay to unhighlighted element
    scale: scale10,
    coordinate,
    emitter,
    state = {}
  }) {
    var _a;
    const elements = elementsof(root2);
    const elementSet = new Set(elements);
    const keyGroup = group(elements, groupKey);
    const valueof2 = createValueof(elements, datum);
    const [appendLink, removeLink] = renderLink(Object.assign({
      elements,
      valueof: valueof2,
      link: link2,
      coordinate
    }, subObject(state.active, "link")));
    const [appendBackground, removeBackground, isBackground] = renderBackground(Object.assign({
      document: root2.ownerDocument,
      scale: scale10,
      coordinate,
      background,
      valueof: valueof2
    }, subObject(state.active, "background")));
    const elementStyle = deep_mix_default(state, {
      active: Object.assign({}, ((_a = state.active) === null || _a === void 0 ? void 0 : _a.offset) && {
        //Apply translate to mock slice out.
        transform: (...params) => {
          const value2 = state.active.offset(...params);
          const [, i] = params;
          return offsetTransform(elements[i], value2, coordinate);
        }
      })
    });
    const { setState, removeState, hasState } = useState(elementStyle, valueof2);
    let out;
    const pointerover = (event) => {
      const { target: element, nativeEvent = true } = event;
      if (!elementSet.has(element))
        return;
      if (out)
        clearTimeout(out);
      const k = groupKey(element);
      const group3 = keyGroup.get(k);
      const groupSet = new Set(group3);
      for (const e3 of elements) {
        if (groupSet.has(e3)) {
          if (!hasState(e3, "active"))
            setState(e3, "active");
        } else {
          setState(e3, "inactive");
          removeLink(e3);
        }
        if (e3 !== element)
          removeBackground(e3);
      }
      appendBackground(element);
      appendLink(group3);
      if (!nativeEvent)
        return;
      emitter.emit("element:highlight", {
        nativeEvent,
        data: {
          data: datum(element),
          group: group3.map(datum)
        }
      });
    };
    const delayUnhighlighted = () => {
      if (out)
        clearTimeout(out);
      out = setTimeout(() => {
        unhighlighted();
        out = null;
      }, delay);
    };
    const unhighlighted = (nativeEvent = true) => {
      for (const e3 of elements) {
        removeState(e3, "active", "inactive");
        removeBackground(e3);
        removeLink(e3);
      }
      if (nativeEvent) {
        emitter.emit("element:unhighlight", { nativeEvent });
      }
    };
    const pointerout = (event) => {
      const { target: element } = event;
      if (background && !isBackground(element))
        return;
      if (!background && !elementSet.has(element))
        return;
      if (delay > 0)
        delayUnhighlighted();
      else
        unhighlighted();
    };
    const pointerleave = () => {
      unhighlighted();
    };
    root2.addEventListener("pointerover", pointerover);
    root2.addEventListener("pointerout", pointerout);
    root2.addEventListener("pointerleave", pointerleave);
    const onRest = (e3) => {
      const { nativeEvent } = e3;
      if (nativeEvent)
        return;
      unhighlighted(false);
    };
    const onHighlight = (e3) => {
      const { nativeEvent } = e3;
      if (nativeEvent)
        return;
      const { data: data2 } = e3.data;
      const element = selectElementByData(elements, data2, datum);
      if (!element)
        return;
      pointerover({ target: element, nativeEvent: false });
    };
    emitter.on("element:highlight", onHighlight);
    emitter.on("element:unhighlight", onRest);
    return () => {
      root2.removeEventListener("pointerover", pointerover);
      root2.removeEventListener("pointerout", pointerout);
      root2.removeEventListener("pointerleave", pointerleave);
      emitter.off("element:highlight", onHighlight);
      emitter.off("element:unhighlight", onRest);
      for (const e3 of elements) {
        removeBackground(e3);
        removeLink(e3);
      }
    };
  }
  function ElementHighlight(_a) {
    var { delay, createGroup, background = false, link: link2 = false } = _a, rest = __rest78(_a, ["delay", "createGroup", "background", "link"]);
    return (context, _2, emitter) => {
      const { container, view, options } = context;
      const { scale: scale10, coordinate } = view;
      const plotArea = selectPlotArea(container);
      return elementHighlight(plotArea, Object.assign({
        elements: selectG2Elements,
        datum: createDatumof(view),
        groupKey: createGroup ? createGroup(view) : void 0,
        coordinate,
        scale: scale10,
        state: mergeState(options, [
          ["active", background ? {} : { lineWidth: "1", stroke: "#000" }],
          "inactive"
        ]),
        background,
        link: link2,
        delay,
        emitter
      }, rest));
    };
  }
  ElementHighlight.props = {
    reapplyWhenUpdate: true
  };

  // node_modules/@antv/g2/esm/interaction/elementHighlightByX.js
  function ElementHighlightByX(options) {
    return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
  }
  ElementHighlightByX.props = {
    reapplyWhenUpdate: true
  };

  // node_modules/@antv/g2/esm/interaction/elementHighlightByColor.js
  function ElementHighlightByColor(options) {
    return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
  }
  ElementHighlightByColor.props = {
    reapplyWhenUpdate: true
  };

  // node_modules/@antv/g2/esm/interaction/elementSelect.js
  var __rest79 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function elementSelect(root2, {
    elements: elementsof,
    // given the root of chart returns elements to be manipulated
    datum,
    // given each element returns the datum of it
    groupKey = (d3) => d3,
    // group elements by specified key
    link: link2 = false,
    // draw link or not
    single = false,
    // single select or not
    coordinate,
    background = false,
    scale: scale10,
    emitter,
    state = {}
  }) {
    var _a;
    const elements = elementsof(root2);
    const elementSet = new Set(elements);
    const keyGroup = group(elements, groupKey);
    const valueof2 = createValueof(elements, datum);
    const [appendLink, removeLink] = renderLink(Object.assign({
      link: link2,
      elements,
      valueof: valueof2,
      coordinate
    }, subObject(state.selected, "link")));
    const [appendBackground, removeBackground] = renderBackground(Object.assign({
      document: root2.ownerDocument,
      background,
      coordinate,
      scale: scale10,
      valueof: valueof2
    }, subObject(state.selected, "background")));
    const elementStyle = deep_mix_default(state, {
      selected: Object.assign({}, ((_a = state.selected) === null || _a === void 0 ? void 0 : _a.offset) && {
        //Apply translate to mock slice out.
        transform: (...params) => {
          const value2 = state.selected.offset(...params);
          const [, i] = params;
          return offsetTransform(elements[i], value2, coordinate);
        }
      })
    });
    const { setState, removeState, hasState } = useState(elementStyle, valueof2);
    const clear = (nativeEvent = true) => {
      for (const e3 of elements) {
        removeState(e3, "selected", "unselected");
        removeLink(e3);
        removeBackground(e3);
      }
      if (nativeEvent)
        emitter.emit("element:unselect", { nativeEvent: true });
      return;
    };
    const singleSelect = (event, element, nativeEvent = true) => {
      if (hasState(element, "selected"))
        clear();
      else {
        const k = groupKey(element);
        const group3 = keyGroup.get(k);
        const groupSet = new Set(group3);
        for (const e3 of elements) {
          if (groupSet.has(e3))
            setState(e3, "selected");
          else {
            setState(e3, "unselected");
            removeLink(e3);
          }
          if (e3 !== element)
            removeBackground(e3);
        }
        appendLink(group3);
        appendBackground(element);
        if (!nativeEvent)
          return;
        emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
          data: [datum(element), ...group3.map(datum)]
        } }));
      }
    };
    const multipleSelect = (event, element, nativeEvent = true) => {
      const k = groupKey(element);
      const group3 = keyGroup.get(k);
      const groupSet = new Set(group3);
      if (!hasState(element, "selected")) {
        const hasSelectedGroup = group3.some((e3) => hasState(e3, "selected"));
        for (const e3 of elements) {
          if (groupSet.has(e3))
            setState(e3, "selected");
          else if (!hasState(e3, "selected"))
            setState(e3, "unselected");
        }
        if (!hasSelectedGroup && link2)
          appendLink(group3);
        appendBackground(element);
      } else {
        const hasSelected = elements.some((e3) => !groupSet.has(e3) && hasState(e3, "selected"));
        if (!hasSelected)
          return clear();
        for (const e3 of group3) {
          setState(e3, "unselected");
          removeLink(e3);
          removeBackground(e3);
        }
      }
      if (!nativeEvent)
        return;
      emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
        data: elements.filter((e3) => hasState(e3, "selected")).map(datum)
      } }));
    };
    const click = (event) => {
      const { target: element, nativeEvent = true } = event;
      if (!elementSet.has(element))
        return clear();
      if (single)
        return singleSelect(event, element, nativeEvent);
      return multipleSelect(event, element, nativeEvent);
    };
    root2.addEventListener("click", click);
    const onSelect = (e3) => {
      const { nativeEvent, data: data2 } = e3;
      if (nativeEvent)
        return;
      const selectedData = single ? data2.data.slice(0, 1) : data2.data;
      for (const d3 of selectedData) {
        const element = selectElementByData(elements, d3, datum);
        click({ target: element, nativeEvent: false });
      }
    };
    const onUnSelect = () => {
      clear(false);
    };
    emitter.on("element:select", onSelect);
    emitter.on("element:unselect", onUnSelect);
    return () => {
      for (const e3 of elements)
        removeLink(e3);
      root2.removeEventListener("click", click);
      emitter.off("element:select", onSelect);
      emitter.off("element:unselect", onUnSelect);
    };
  }
  function ElementSelect(_a) {
    var { createGroup, background = false, link: link2 = false } = _a, rest = __rest79(_a, ["createGroup", "background", "link"]);
    return (context, _2, emitter) => {
      const { container, view, options } = context;
      const { coordinate, scale: scale10 } = view;
      const plotArea = selectPlotArea(container);
      return elementSelect(plotArea, Object.assign({
        elements: selectG2Elements,
        datum: createDatumof(view),
        groupKey: createGroup ? createGroup(view) : void 0,
        coordinate,
        scale: scale10,
        state: mergeState(options, [
          ["selected", background ? {} : { lineWidth: "1", stroke: "#000" }],
          "unselected"
        ]),
        background,
        link: link2,
        emitter
      }, rest));
    };
  }
  ElementSelect.props = {
    reapplyWhenUpdate: true
  };

  // node_modules/@antv/g2/esm/interaction/elementSelectByX.js
  function ElementSelectByX(options) {
    return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
  }
  ElementSelectByX.props = {
    reapplyWhenUpdate: true
  };

  // node_modules/@antv/g2/esm/interaction/elementSelectByColor.js
  function ElementSelectByColor(options) {
    return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
  }
  ElementSelectByColor.props = {
    reapplyWhenUpdate: true
  };

  // node_modules/@antv/g2/esm/interaction/chartIndex.js
  var __awaiter6 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest80 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function maybeTransform(options) {
    const { transform = [] } = options;
    const normalizeY = transform.find((d3) => d3.type === "normalizeY");
    if (normalizeY)
      return normalizeY;
    const newNormalizeY = { type: "normalizeY" };
    transform.push(newNormalizeY);
    options.transform = transform;
    return newNormalizeY;
  }
  function markValue2(markState, markName, channels) {
    const [value2] = Array.from(markState.entries()).filter(([mark]) => mark.type === markName).map(([mark]) => {
      const { encode } = mark;
      const channel = (name2) => {
        const channel2 = encode[name2];
        return [name2, channel2 ? channel2.value : void 0];
      };
      return Object.fromEntries(channels.map(channel));
    });
    return value2;
  }
  function ChartIndex(_a) {
    var { wait = 20, leading, trailing = false, labelFormatter = (date) => `${date}` } = _a, style = __rest80(_a, ["wait", "leading", "trailing", "labelFormatter"]);
    return (context) => {
      const { view, container, update, setState } = context;
      const { markState, scale: scale10, coordinate } = view;
      const value2 = markValue2(markState, "line", ["x", "y", "series"]);
      if (!value2)
        return;
      const { y: Y, x: X, series: S = [] } = value2;
      const I = Y.map((_2, i) => i);
      const sortedX = sort2(I.map((i) => X[i]));
      const plotArea = selectPlotArea(container);
      const lines = container.getElementsByClassName(ELEMENT_CLASS_NAME);
      const labels = container.getElementsByClassName(LABEL_CLASS_NAME);
      const keyofLabel = (d3) => d3.__data__.key.split("-")[0];
      const keyLabels = group(labels, keyofLabel);
      const rule = new Line({
        style: Object.assign({ x1: 0, y1: 0, x2: 0, y2: plotArea.getAttribute("height"), stroke: "black", lineWidth: 1 }, subObject(style, "rule"))
      });
      const text = new Text({
        style: Object.assign({ x: 0, y: plotArea.getAttribute("height"), text: "", fontSize: 10 }, subObject(style, "label"))
      });
      rule.append(text);
      plotArea.appendChild(rule);
      const dateByFocus = (coordinate2, scaleX2, focus) => {
        const [normalizedX] = coordinate2.invert(focus);
        const date = scaleX2.invert(normalizedX);
        return sortedX[bisectCenter(sortedX, date)];
      };
      const updateRule = (focus, date) => {
        rule.setAttribute("x1", focus[0]);
        rule.setAttribute("x2", focus[0]);
        text.setAttribute("text", labelFormatter(date));
      };
      let newView;
      const updateBasisByRerender = (focus) => __awaiter6(this, void 0, void 0, function* () {
        const { x: scaleX2 } = scale10;
        const date = dateByFocus(coordinate, scaleX2, focus);
        updateRule(focus, date);
        setState("chartIndex", (options) => {
          const clonedOptions = deep_mix_default({}, options);
          const lineMark = clonedOptions.marks.find((d3) => d3.type === "line");
          const r = (I2) => max5(I2, (i) => +Y[i]) / min4(I2, (i) => +Y[i]);
          const k = max5(rollup(I, r, (i) => S[i]).values());
          const domainY = [1 / k, k];
          deep_mix_default(lineMark, {
            scale: { y: { domain: domainY } }
          });
          const normalizeY = maybeTransform(lineMark);
          normalizeY.groupBy = "color";
          normalizeY.basis = (I2, Y3) => {
            const i = I2[bisector((i2) => X[+i2]).center(I2, date)];
            return Y3[i];
          };
          for (const mark of clonedOptions.marks)
            mark.animate = false;
          return clonedOptions;
        });
        const newState = yield update("chartIndex");
        newView = newState.view;
      });
      const updateBasisByTranslate = (focus) => {
        const { scale: scale11, coordinate: coordinate2 } = newView;
        const { x: scaleX2, y: scaleY2 } = scale11;
        const date = dateByFocus(coordinate2, scaleX2, focus);
        updateRule(focus, date);
        for (const line4 of lines) {
          const { seriesIndex: SI, key } = line4.__data__;
          const i = SI[bisector((i2) => X[+i2]).center(SI, date)];
          const p0 = [0, scaleY2.map(1)];
          const p1 = [0, scaleY2.map(Y[i] / Y[SI[0]])];
          const [, y05] = coordinate2.map(p0);
          const [, y12] = coordinate2.map(p1);
          const dy = y05 - y12;
          line4.setAttribute("transform", `translate(0, ${dy})`);
          const labels2 = keyLabels.get(key) || [];
          for (const label of labels2) {
            label.setAttribute("dy", dy);
          }
        }
      };
      const updateBasis = throttle_default((event) => {
        const focus = mousePosition(plotArea, event);
        if (!focus)
          return;
        updateBasisByTranslate(focus);
      }, wait, { leading, trailing });
      updateBasisByRerender([0, 0]);
      plotArea.addEventListener("pointerenter", updateBasis);
      plotArea.addEventListener("pointermove", updateBasis);
      plotArea.addEventListener("pointerleave", updateBasis);
      return () => {
        rule.remove();
        plotArea.removeEventListener("pointerenter", updateBasis);
        plotArea.removeEventListener("pointermove", updateBasis);
        plotArea.removeEventListener("pointerleave", updateBasis);
      };
    };
  }
  ChartIndex.props = {
    reapplyWhenUpdate: true
  };

  // node_modules/@antv/g2/esm/interaction/fisheye.js
  function maybeCoordinate(options) {
    const { coordinate = {} } = options;
    const { transform = [] } = coordinate;
    const fisheye = transform.find((d3) => d3.type === "fisheye");
    if (fisheye)
      return fisheye;
    const newFisheye = { type: "fisheye" };
    transform.push(newFisheye);
    coordinate.transform = transform;
    options.coordinate = coordinate;
    return newFisheye;
  }
  function Fisheye2({ wait = 30, leading, trailing = false }) {
    return (context) => {
      const { options, update, setState, container } = context;
      const plotArea = selectPlotArea(container);
      const updateFocus = throttle_default((event) => {
        const focus = mousePosition(plotArea, event);
        if (!focus) {
          setState("fisheye");
          update();
          return;
        }
        setState("fisheye", (options2) => {
          const clonedOptions = deep_mix_default({}, options2, {
            interaction: { tooltip: { preserve: true } }
          });
          for (const mark of clonedOptions.marks)
            mark.animate = false;
          const [x3, y3] = focus;
          const fisheye = maybeCoordinate(clonedOptions);
          fisheye.focusX = x3;
          fisheye.focusY = y3;
          fisheye.visual = true;
          return clonedOptions;
        });
        update();
      }, wait, { leading, trailing });
      plotArea.addEventListener("pointerenter", updateFocus);
      plotArea.addEventListener("pointermove", updateFocus);
      plotArea.addEventListener("pointerleave", updateFocus);
      return () => {
        plotArea.removeEventListener("pointerenter", updateFocus);
        plotArea.removeEventListener("pointermove", updateFocus);
        plotArea.removeEventListener("pointerleave", updateFocus);
      };
    };
  }

  // node_modules/@antv/g2/esm/interaction/tooltip.js
  var __rest81 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function getContainer(group3, mount2) {
    if (mount2) {
      return typeof mount2 === "string" ? document.querySelector(mount2) : mount2;
    }
    const canvas = group3.ownerDocument.defaultView.getContextService().getDomElement();
    return canvas.parentElement;
  }
  function getBounding(root2) {
    const bbox = root2.getRenderBounds();
    const { min: [x12, y12], max: [x22, y22] } = bbox;
    return {
      x: x12,
      y: y12,
      width: x22 - x12,
      height: y22 - y12
    };
  }
  function getContainerOffset(container1, container2) {
    const r1 = container1.getBoundingClientRect();
    const r2 = container2.getBoundingClientRect();
    return {
      x: r1.x - r2.x,
      y: r1.y - r2.y
    };
  }
  function createTooltip(container, x05, y05, position, enterable, bounding, containerOffset, css2 = {}, offset3 = [10, 10]) {
    const defaults5 = {
      ".g2-tooltip": {},
      ".g2-tooltip-title": {
        overflow: "hidden",
        "white-space": "nowrap",
        "text-overflow": "ellipsis"
      }
    };
    const tooltipElement = new Tooltip({
      className: "tooltip",
      style: {
        x: x05,
        y: y05,
        container: containerOffset,
        data: [],
        bounding,
        position,
        enterable,
        title: "",
        offset: offset3,
        template: {
          prefixCls: "g2-"
        },
        style: deep_mix_default(defaults5, css2)
      }
    });
    container.appendChild(tooltipElement.HTMLTooltipElement);
    return tooltipElement;
  }
  function showTooltip({ root: root2, data: data2, x: x3, y: y3, render: render2, event, single, position = "right-bottom", enterable = false, css: css2, mount: mount2, bounding, offset: offset3 }) {
    const container = getContainer(root2, mount2);
    const canvasContainer = getContainer(root2);
    const parent = single ? canvasContainer : root2;
    const b = bounding || getBounding(root2);
    const containerOffset = getContainerOffset(canvasContainer, container);
    const { tooltipElement = createTooltip(container, x3, y3, position, enterable, b, containerOffset, css2, offset3) } = parent;
    const { items, title = "" } = data2;
    tooltipElement.update(Object.assign({
      x: x3,
      y: y3,
      data: items,
      title,
      position,
      enterable,
      container: containerOffset
    }, render2 !== void 0 && {
      content: render2(event, { items, title })
    }));
    parent.tooltipElement = tooltipElement;
  }
  function hideTooltip({ root: root2, single, emitter, nativeEvent = true, event = null }) {
    if (nativeEvent) {
      emitter.emit("tooltip:hide", { nativeEvent });
    }
    const container = getContainer(root2);
    const parent = single ? container : root2;
    const { tooltipElement } = parent;
    if (tooltipElement) {
      tooltipElement.hide(event === null || event === void 0 ? void 0 : event.clientX, event === null || event === void 0 ? void 0 : event.clientY);
    }
    hideRuleY(root2);
    hideRuleX(root2);
    hideMarker(root2);
  }
  function destroyTooltip({ root: root2, single }) {
    const container = getContainer(root2);
    const parent = single ? container : root2;
    if (!parent)
      return;
    const { tooltipElement } = parent;
    if (tooltipElement) {
      tooltipElement.destroy();
      parent.tooltipElement = void 0;
    }
    hideRuleY(root2);
    hideRuleX(root2);
    hideMarker(root2);
  }
  function showUndefined(item) {
    const { value: value2 } = item;
    return Object.assign(Object.assign({}, item), { value: value2 === void 0 ? "undefined" : value2 });
  }
  function singleItem(element) {
    const { __data__: datum } = element;
    const { title, items = [] } = datum;
    const newItems = items.filter(defined).map((_a) => {
      var { color: color2 = itemColorOf(element) } = _a, item = __rest81(_a, ["color"]);
      return Object.assign(Object.assign({}, item), { color: color2 });
    }).map(showUndefined);
    return Object.assign(Object.assign({}, title && { title }), { items: newItems });
  }
  function groupNameOf(scale10, datum) {
    const { color: scaleColor, series: scaleSeries, facet = false } = scale10;
    const { color: color2, series } = datum;
    const invertAble = (scale11) => {
      return scale11 && scale11.invert && !(scale11 instanceof Band) && !(scale11 instanceof Constant2);
    };
    if (invertAble(scaleSeries)) {
      const cloned = scaleSeries.clone();
      return cloned.invert(series);
    }
    if (series && scaleSeries instanceof Band && scaleSeries.invert(series) !== color2 && !facet) {
      return scaleSeries.invert(series);
    }
    if (invertAble(scaleColor)) {
      const name2 = scaleColor.invert(color2);
      if (Array.isArray(name2))
        return null;
      return name2;
    }
    return null;
  }
  function itemColorOf(element) {
    const fill = element.getAttribute("fill");
    const stroke2 = element.getAttribute("stroke");
    const { __data__: datum } = element;
    const { color: color2 = fill && fill !== "transparent" ? fill : stroke2 } = datum;
    return color2;
  }
  function unique2(items, key = (d3) => d3) {
    const valueName = new Map(items.map((d3) => [key(d3), d3]));
    return Array.from(valueName.values());
  }
  function groupItems(elements, scale10, groupName, data2 = elements.map((d3) => d3["__data__"]), theme = {}) {
    const key = (d3) => d3 instanceof Date ? +d3 : d3;
    const T = unique2(data2.map((d3) => d3.title), key).filter(defined);
    const newItems = data2.flatMap((datum, i) => {
      const element = elements[i];
      const { items = [], title } = datum;
      const definedItems = items.filter(defined);
      const useGroupName = groupName !== void 0 ? groupName : items.length <= 1 ? true : false;
      return definedItems.map((_a) => {
        var { color: color2 = itemColorOf(element) || theme.color, name: name2 } = _a, item = __rest81(_a, ["color", "name"]);
        const groupName2 = groupNameOf(scale10, datum);
        const name1 = useGroupName ? groupName2 || name2 : name2 || groupName2;
        return Object.assign(Object.assign({}, item), { color: color2, name: name1 || title });
      });
    }).map(showUndefined);
    return Object.assign(Object.assign({}, T.length > 0 && { title: T.join(",") }), { items: unique2(newItems, (d3) => `(${key(d3.name)}, ${key(d3.value)}, ${key(d3.color)})`) });
  }
  function updateRuleX(root2, points, mouse, _a) {
    var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar, insetLeft, insetTop } = _a, rest = __rest81(_a, ["plotWidth", "plotHeight", "mainWidth", "mainHeight", "startX", "startY", "transposed", "polar", "insetLeft", "insetTop"]);
    const defaults5 = Object.assign({ lineWidth: 1, stroke: "#1b1e23", strokeOpacity: 0.5 }, rest);
    const createCircle = (cx, cy, r) => {
      const circle3 = new Circle({
        style: Object.assign({
          cx,
          cy,
          r
        }, defaults5)
      });
      root2.appendChild(circle3);
      return circle3;
    };
    const createLine = (x12, x22, y12, y22) => {
      const line4 = new Line({
        style: Object.assign({
          x1: x12,
          x2: x22,
          y1: y12,
          y2: y22
        }, defaults5)
      });
      root2.appendChild(line4);
      return line4;
    };
    const minDistPoint = (mouse2, points2) => {
      if (points2.length === 1) {
        return points2[0];
      }
      const dists = points2.map((p2) => dist4(p2, mouse2));
      const minDistIndex = minIndex(dists, (d3) => d3);
      return points2[minDistIndex];
    };
    const target = minDistPoint(mouse, points);
    const pointsOf = () => {
      if (transposed)
        return [
          startX + target[0],
          startX + target[0],
          startY,
          startY + plotHeight
        ];
      return [startX, startX + plotWidth, target[1] + startY, target[1] + startY];
    };
    const pointsOfPolar = () => {
      const cx = startX + insetLeft + mainWidth / 2;
      const cy = startY + insetTop + mainHeight / 2;
      const cdist = dist4([cx, cy], target);
      return [cx, cy, cdist];
    };
    if (polar) {
      const [cx, cy, r] = pointsOfPolar();
      const ruleX = root2.ruleX || createCircle(cx, cy, r);
      ruleX.style.cx = cx;
      ruleX.style.cy = cy;
      ruleX.style.r = r;
      root2.ruleX = ruleX;
    } else {
      const [x12, x22, y12, y22] = pointsOf();
      const ruleX = root2.ruleX || createLine(x12, x22, y12, y22);
      ruleX.style.x1 = x12;
      ruleX.style.x2 = x22;
      ruleX.style.y1 = y12;
      ruleX.style.y2 = y22;
      root2.ruleX = ruleX;
    }
  }
  function updateRuleY(root2, points, _a) {
    var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar, insetLeft, insetTop } = _a, rest = __rest81(_a, ["plotWidth", "plotHeight", "mainWidth", "mainHeight", "startX", "startY", "transposed", "polar", "insetLeft", "insetTop"]);
    const defaults5 = Object.assign({ lineWidth: 1, stroke: "#1b1e23", strokeOpacity: 0.5 }, rest);
    const Y = points.map((p2) => p2[1]);
    const X = points.map((p2) => p2[0]);
    const y3 = mean(Y);
    const x3 = mean(X);
    const pointsOf = () => {
      if (polar) {
        const r = Math.min(mainWidth, mainHeight) / 2;
        const cx = startX + insetLeft + mainWidth / 2;
        const cy = startY + insetTop + mainHeight / 2;
        const a3 = angle3(sub6([x3, y3], [cx, cy]));
        const x05 = cx + r * Math.cos(a3);
        const y05 = cy + r * Math.sin(a3);
        return [cx, x05, cy, y05];
      }
      if (transposed)
        return [startX, startX + plotWidth, y3 + startY, y3 + startY];
      return [x3 + startX, x3 + startX, startY, startY + plotHeight];
    };
    const [x12, x22, y12, y22] = pointsOf();
    const createLine = () => {
      const line4 = new Line({
        style: Object.assign({
          x1: x12,
          x2: x22,
          y1: y12,
          y2: y22
        }, defaults5)
      });
      root2.appendChild(line4);
      return line4;
    };
    if (X.length > 0) {
      const ruleY = root2.ruleY || createLine();
      ruleY.style.x1 = x12;
      ruleY.style.x2 = x22;
      ruleY.style.y1 = y12;
      ruleY.style.y2 = y22;
      root2.ruleY = ruleY;
    }
  }
  function hideRuleY(root2) {
    if (root2.ruleY) {
      root2.ruleY.remove();
      root2.ruleY = void 0;
    }
  }
  function hideRuleX(root2) {
    if (root2.ruleX) {
      root2.ruleX.remove();
      root2.ruleX = void 0;
    }
  }
  function updateMarker(root2, { data: data2, style, theme }) {
    if (root2.markers)
      root2.markers.forEach((d3) => d3.remove());
    const { type = "" } = style;
    const markers = data2.filter((d3) => {
      const [{ x: x3, y: y3 }] = d3;
      return defined(x3) && defined(y3);
    }).map((d3) => {
      const [{ color: color2, element }, point6] = d3;
      const originColor = color2 || // encode value
      element.style.fill || element.style.stroke || theme.color;
      const fill = type === "hollow" ? "transparent" : originColor;
      const stroke2 = type === "hollow" ? originColor : "#fff";
      const shape23 = new Circle({
        className: "g2-tooltip-marker",
        style: Object.assign({ cx: point6[0], cy: point6[1], fill, r: 4, stroke: stroke2, lineWidth: 2 }, style)
      });
      return shape23;
    });
    for (const marker of markers)
      root2.appendChild(marker);
    root2.markers = markers;
  }
  function hideMarker(root2) {
    if (root2.markers) {
      root2.markers.forEach((d3) => d3.remove());
      root2.markers = [];
    }
  }
  function interactionKeyof(markState, key) {
    return Array.from(markState.values()).some(
      // @ts-ignore
      (d3) => {
        var _a;
        return (_a = d3.interaction) === null || _a === void 0 ? void 0 : _a[key];
      }
    );
  }
  function maybeValue(specified, defaults5) {
    return specified === void 0 ? defaults5 : specified;
  }
  function isEmptyTooltipData(data2) {
    const { title, items } = data2;
    if (items.length === 0 && title === void 0)
      return true;
    return false;
  }
  function hasSeries(markState) {
    return Array.from(markState.values()).some(
      // @ts-ignore
      (d3) => {
        var _a;
        return ((_a = d3.interaction) === null || _a === void 0 ? void 0 : _a.seriesTooltip) && d3.tooltip;
      }
    );
  }
  function seriesTooltip(root2, _a) {
    var { elements: elementsof, sort: sortFunction, filter: filterFunction, scale: scale10, coordinate, crosshairs, crosshairsX, crosshairsY, render: render2, groupName, emitter, wait = 50, leading = true, trailing = false, startX = 0, startY = 0, body = true, single = true, position, enterable, mount: mount2, bounding, theme, offset: offset3, disableNative = false, marker = true, preserve = false, style: _style = {}, css: css2 = {} } = _a, rest = __rest81(_a, ["elements", "sort", "filter", "scale", "coordinate", "crosshairs", "crosshairsX", "crosshairsY", "render", "groupName", "emitter", "wait", "leading", "trailing", "startX", "startY", "body", "single", "position", "enterable", "mount", "bounding", "theme", "offset", "disableNative", "marker", "preserve", "style", "css"]);
    const elements = elementsof(root2);
    const transposed = isTranspose(coordinate);
    const polar = isPolar(coordinate);
    const style = deep_mix_default(_style, rest);
    const { innerWidth: plotWidth, innerHeight: plotHeight, width: mainWidth, height: mainHeight, insetLeft, insetTop } = coordinate.getOptions();
    const seriesElements = [];
    const itemElements = [];
    for (const element of elements) {
      const { __data__: data2 } = element;
      const { seriesX, title, items } = data2;
      if (seriesX)
        seriesElements.push(element);
      else if (title || items)
        itemElements.push(element);
    }
    const inInterval = (d3) => d3.markType === "interval";
    const isBar = itemElements.length && itemElements.every(inInterval) && !isPolar(coordinate);
    const xof = (d3) => d3.__data__.x;
    const isBandScale = !!scale10.x.getBandWidth;
    const closest2 = isBandScale && itemElements.length > 0;
    seriesElements.sort((a3, b) => {
      const index4 = transposed ? 0 : 1;
      const minY = (d3) => d3.getBounds().min[index4];
      return transposed ? minY(b) - minY(a3) : minY(a3) - minY(b);
    });
    const extent2 = (d3) => {
      const index4 = transposed ? 1 : 0;
      const { min: min10, max: max11 } = d3.getLocalBounds();
      return sort2([min10[index4], max11[index4]]);
    };
    if (isBar)
      elements.sort((a3, b) => xof(a3) - xof(b));
    else {
      itemElements.sort((a3, b) => {
        const [minA, maxA] = extent2(a3);
        const [minB, maxB] = extent2(b);
        const midA = (minA + maxA) / 2;
        const midB = (minB + maxB) / 2;
        return transposed ? midB - midA : midA - midB;
      });
    }
    const elementSortedX = new Map(seriesElements.map((element) => {
      const { __data__: data2 } = element;
      const { seriesX } = data2;
      const seriesIndex = seriesX.map((_2, i) => i);
      const sortedIndex2 = sort2(seriesIndex, (i) => seriesX[+i]);
      return [element, [sortedIndex2, seriesX]];
    }));
    const { x: scaleX2 } = scale10;
    const offsetX = (scaleX2 === null || scaleX2 === void 0 ? void 0 : scaleX2.getBandWidth) ? scaleX2.getBandWidth() / 2 : 0;
    const abstractX = (focus) => {
      const [normalizedX] = coordinate.invert(focus);
      return normalizedX - offsetX;
    };
    const indexByFocus = (event, focus, I, X) => {
      const { _x } = event;
      const finalX = _x !== void 0 ? scaleX2.map(_x) : abstractX(focus);
      const DX = X.filter(defined);
      const [minX, maxX] = sort2([DX[0], DX[DX.length - 1]]);
      const isOnlyOneElement = minX === maxX;
      if (!closest2 && (finalX < minX || finalX > maxX) && !isOnlyOneElement)
        return null;
      const search2 = bisector((i2) => X[+i2]).center;
      const i = search2(I, finalX);
      return I[i];
    };
    const elementsByFocus = isBar ? (focus, elements2) => {
      const search2 = bisector(xof).center;
      const i = search2(elements2, abstractX(focus));
      const find7 = elements2[i];
      const groups2 = group(elements2, xof);
      const selected = groups2.get(xof(find7));
      return selected;
    } : (focus, elements2) => {
      const index4 = transposed ? 1 : 0;
      const x3 = focus[index4];
      const filtered = elements2.filter((element) => {
        const [min10, max11] = extent2(element);
        return x3 >= min10 && x3 <= max11;
      });
      if (!closest2 || filtered.length > 0)
        return filtered;
      const search2 = bisector((element) => {
        const [min10, max11] = extent2(element);
        return (min10 + max11) / 2;
      }).center;
      const i = search2(elements2, x3);
      return [elements2[i]].filter(defined);
    };
    const seriesData = (element, index4) => {
      const { __data__: data2 } = element;
      return Object.fromEntries(Object.entries(data2).filter(([key]) => key.startsWith("series") && key !== "series").map(([key, V]) => {
        const d3 = V[index4];
        return [lower_first_default(key.replace("series", "")), d3];
      }));
    };
    const update = throttle_default((event) => {
      var _a2;
      const mouse = mousePosition(root2, event);
      if (!mouse)
        return;
      const bbox = bboxOf(root2);
      const x3 = bbox.min[0];
      const y3 = bbox.min[1];
      const focus = [mouse[0] - startX, mouse[1] - startY];
      if (!focus)
        return;
      const selectedItems = elementsByFocus(focus, itemElements);
      const selectedSeriesElements = [];
      const selectedSeriesData = [];
      for (const element of seriesElements) {
        const [sortedIndex2, X] = elementSortedX.get(element);
        const index4 = indexByFocus(event, focus, sortedIndex2, X);
        if (index4 !== null) {
          selectedSeriesElements.push(element);
          const d3 = seriesData(element, index4);
          const { x: x4, y: y4 } = d3;
          const p2 = coordinate.map([(x4 || 0) + offsetX, y4 || 0]);
          selectedSeriesData.push([Object.assign(Object.assign({}, d3), { element }), p2]);
        }
      }
      const SX = Array.from(new Set(selectedSeriesData.map((d3) => d3[0].x)));
      const closestX = SX[minIndex(SX, (x4) => Math.abs(x4 - abstractX(focus)))];
      const filteredSeriesData = selectedSeriesData.filter((d3) => d3[0].x === closestX);
      const selectedData = [
        ...filteredSeriesData.map((d3) => d3[0]),
        ...selectedItems.map((d3) => d3.__data__)
      ];
      const selectedElements = [...selectedSeriesElements, ...selectedItems];
      const tooltipData = groupItems(selectedElements, scale10, groupName, selectedData, theme);
      if (sortFunction) {
        tooltipData.items.sort((a3, b) => sortFunction(a3) - sortFunction(b));
      }
      if (filterFunction) {
        tooltipData.items = tooltipData.items.filter(filterFunction);
      }
      if (selectedElements.length === 0 || isEmptyTooltipData(tooltipData)) {
        hide3(event);
        return;
      }
      if (body) {
        showTooltip({
          root: root2,
          data: tooltipData,
          x: mouse[0] + x3,
          y: mouse[1] + y3,
          render: render2,
          event,
          single,
          position,
          enterable,
          mount: mount2,
          bounding,
          css: css2,
          offset: offset3
        });
      }
      if (crosshairs || crosshairsX || crosshairsY) {
        const ruleStyle = subObject(style, "crosshairs");
        const ruleStyleX = Object.assign(Object.assign({}, ruleStyle), subObject(style, "crosshairsX"));
        const ruleStyleY = Object.assign(Object.assign({}, ruleStyle), subObject(style, "crosshairsY"));
        const points = filteredSeriesData.map((d3) => d3[1]);
        if (crosshairsX) {
          updateRuleX(root2, points, mouse, Object.assign(Object.assign({}, ruleStyleX), {
            plotWidth,
            plotHeight,
            mainWidth,
            mainHeight,
            insetLeft,
            insetTop,
            startX,
            startY,
            transposed,
            polar
          }));
        }
        if (crosshairsY) {
          updateRuleY(root2, points, Object.assign(Object.assign({}, ruleStyleY), {
            plotWidth,
            plotHeight,
            mainWidth,
            mainHeight,
            insetLeft,
            insetTop,
            startX,
            startY,
            transposed,
            polar
          }));
        }
      }
      if (marker) {
        const markerStyles = subObject(style, "marker");
        updateMarker(root2, {
          data: filteredSeriesData,
          style: markerStyles,
          theme
        });
      }
      const firstX = (_a2 = filteredSeriesData[0]) === null || _a2 === void 0 ? void 0 : _a2[0].x;
      const transformedX = firstX !== null && firstX !== void 0 ? firstX : abstractX(focus);
      emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: Object.assign(Object.assign({}, tooltipData), { data: { x: invert4(scale10.x, transformedX, true) } }) }));
    }, wait, { leading, trailing });
    const hide3 = (event) => {
      hideTooltip({ root: root2, single, emitter, event });
    };
    const destroy3 = () => {
      destroyTooltip({ root: root2, single });
    };
    const onTooltipShow = (_a2) => {
      var _b;
      var { nativeEvent, data: data2, offsetX: offsetX2, offsetY } = _a2, rest2 = __rest81(_a2, ["nativeEvent", "data", "offsetX", "offsetY"]);
      if (nativeEvent)
        return;
      const x3 = (_b = data2 === null || data2 === void 0 ? void 0 : data2.data) === null || _b === void 0 ? void 0 : _b.x;
      const scaleX3 = scale10.x;
      const x12 = scaleX3.map(x3);
      const [x22, y22] = coordinate.map([x12, 0.5]);
      const rootBounds = root2.getRenderBounds();
      const minX = rootBounds.min[0];
      const minY = rootBounds.min[1];
      update(Object.assign(Object.assign({}, rest2), { offsetX: offsetX2 !== void 0 ? offsetX2 : minX + x22, offsetY: offsetY !== void 0 ? offsetY : minY + y22, _x: x3 }));
    };
    const onTooltipHide = () => {
      hideTooltip({ root: root2, single, emitter, nativeEvent: false });
    };
    const onTooltipDisable = () => {
      removeEventListeners();
      destroy3();
    };
    const onTooltipEnable = () => {
      addEventListeners();
    };
    const addEventListeners = () => {
      if (!disableNative) {
        root2.addEventListener("pointerenter", update);
        root2.addEventListener("pointermove", update);
        root2.addEventListener("pointerleave", (e3) => {
          if (mousePosition(root2, e3))
            return;
          hide3(e3);
        });
      }
    };
    const removeEventListeners = () => {
      if (!disableNative) {
        root2.removeEventListener("pointerenter", update);
        root2.removeEventListener("pointermove", update);
        root2.removeEventListener("pointerleave", hide3);
      }
    };
    addEventListeners();
    emitter.on("tooltip:show", onTooltipShow);
    emitter.on("tooltip:hide", onTooltipHide);
    emitter.on("tooltip:disable", onTooltipDisable);
    emitter.on("tooltip:enable", onTooltipEnable);
    return () => {
      removeEventListeners();
      emitter.off("tooltip:show", onTooltipShow);
      emitter.off("tooltip:hide", onTooltipHide);
      emitter.off("tooltip:disable", onTooltipDisable);
      emitter.off("tooltip:enable", onTooltipEnable);
      if (preserve) {
        hideTooltip({ root: root2, single, emitter, nativeEvent: false });
      } else {
        destroy3();
      }
    };
  }
  function tooltip(root2, {
    elements: elementsof,
    coordinate,
    scale: scale10,
    render: render2,
    groupName,
    sort: sortFunction,
    filter: filterFunction,
    emitter,
    wait = 50,
    leading = true,
    trailing = false,
    groupKey = (d3) => d3,
    // group elements by specified key
    single = true,
    position,
    enterable,
    datum,
    view,
    mount: mount2,
    bounding,
    theme,
    offset: offset3,
    shared = false,
    body = true,
    disableNative = false,
    preserve = false,
    css: css2 = {}
  }) {
    var _a, _b;
    const elements = elementsof(root2);
    const keyGroup = group(elements, groupKey);
    const inInterval = (d3) => d3.markType === "interval";
    const isBar = elements.every(inInterval) && !isPolar(coordinate);
    const scaleX2 = scale10.x;
    const scaleSeries = scale10.series;
    const bandWidth3 = (_b = (_a = scaleX2 === null || scaleX2 === void 0 ? void 0 : scaleX2.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scaleX2)) !== null && _b !== void 0 ? _b : 0;
    const xof = scaleSeries ? (d3) => {
      const seriesCount = Math.round(1 / scaleSeries.valueBandWidth);
      return d3.__data__.x + d3.__data__.series * bandWidth3 + bandWidth3 / (seriesCount * 2);
    } : (d3) => d3.__data__.x + bandWidth3 / 2;
    if (isBar)
      elements.sort((a3, b) => xof(a3) - xof(b));
    const findElementByTarget = (event) => {
      const { target } = event;
      return maybeRoot(target, (node) => {
        if (!node.classList)
          return false;
        return node.classList.includes("element");
      });
    };
    const findElement2 = isBar ? (event) => {
      const mouse = mousePosition(root2, event);
      if (!mouse)
        return;
      const [abstractX] = coordinate.invert(mouse);
      const search2 = bisector(xof).center;
      const i = search2(elements, abstractX);
      const target = elements[i];
      if (!shared) {
        const isGrouped = elements.find((d3) => d3 !== target && xof(d3) === xof(target));
        if (isGrouped)
          return findElementByTarget(event);
      }
      return target;
    } : findElementByTarget;
    const pointermove = throttle_default((event) => {
      const element = findElement2(event);
      if (!element) {
        hideTooltip({ root: root2, single, emitter, event });
        return;
      }
      const k = groupKey(element);
      const group3 = keyGroup.get(k);
      if (!group3) {
        return;
      }
      const data2 = group3.length === 1 && !shared ? singleItem(group3[0]) : groupItems(group3, scale10, groupName, void 0, theme);
      if (sortFunction) {
        data2.items.sort((a3, b) => sortFunction(a3) - sortFunction(b));
      }
      if (filterFunction) {
        data2.items = data2.items.filter(filterFunction);
      }
      if (isEmptyTooltipData(data2)) {
        hideTooltip({ root: root2, single, emitter, event });
        return;
      }
      const { offsetX, offsetY } = event;
      if (body) {
        showTooltip({
          root: root2,
          data: data2,
          x: offsetX,
          y: offsetY,
          render: render2,
          event,
          single,
          position,
          enterable,
          mount: mount2,
          bounding,
          css: css2,
          offset: offset3
        });
      }
      emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: Object.assign(Object.assign({}, data2), { data: dataOf(element, view) }) }));
    }, wait, { leading, trailing });
    const pointerleave = (event) => {
      hideTooltip({ root: root2, single, emitter, event });
    };
    const addEventListeners = () => {
      if (!disableNative) {
        root2.addEventListener("pointermove", pointermove);
        root2.addEventListener("pointerleave", pointerleave);
      }
    };
    const removeEventListeners = () => {
      if (!disableNative) {
        root2.removeEventListener("pointermove", pointermove);
        root2.removeEventListener("pointerleave", pointerleave);
      }
    };
    const onTooltipShow = ({ nativeEvent, offsetX, offsetY, data: raw }) => {
      if (nativeEvent)
        return;
      const { data: data2 } = raw;
      const element = selectElementByData(elements, data2, datum);
      if (!element)
        return;
      const bbox = element.getBBox();
      const { x: x3, y: y3, width, height } = bbox;
      const rootBBox = root2.getBBox();
      pointermove({
        target: element,
        offsetX: offsetX !== void 0 ? offsetX + rootBBox.x : x3 + width / 2,
        offsetY: offsetY !== void 0 ? offsetY + rootBBox.y : y3 + height / 2
      });
    };
    const onTooltipHide = ({ nativeEvent } = {}) => {
      if (nativeEvent)
        return;
      hideTooltip({ root: root2, single, emitter, nativeEvent: false });
    };
    const onTooltipDisable = () => {
      removeEventListeners();
      destroyTooltip({ root: root2, single });
    };
    const onTooltipEnable = () => {
      addEventListeners();
    };
    emitter.on("tooltip:show", onTooltipShow);
    emitter.on("tooltip:hide", onTooltipHide);
    emitter.on("tooltip:enable", onTooltipEnable);
    emitter.on("tooltip:disable", onTooltipDisable);
    addEventListeners();
    return () => {
      removeEventListeners();
      emitter.off("tooltip:show", onTooltipShow);
      emitter.off("tooltip:hide", onTooltipHide);
      if (preserve) {
        hideTooltip({ root: root2, single, emitter, nativeEvent: false });
      } else {
        destroyTooltip({ root: root2, single });
      }
    };
  }
  function Tooltip2(options) {
    const { shared, crosshairs, crosshairsX, crosshairsY, series, name: name2, item = () => ({}), facet = false } = options, rest = __rest81(options, ["shared", "crosshairs", "crosshairsX", "crosshairsY", "series", "name", "item", "facet"]);
    return (target, viewInstances, emitter) => {
      const { container, view } = target;
      const { scale: scale10, markState, coordinate, theme } = view;
      const defaultSeries = interactionKeyof(markState, "seriesTooltip");
      const defaultShowCrosshairs = interactionKeyof(markState, "crosshairs");
      const plotArea = selectPlotArea(container);
      const isSeries = maybeValue(series, defaultSeries);
      const crosshairsSetting = maybeValue(crosshairs, defaultShowCrosshairs);
      if (isSeries && hasSeries(markState) && !facet) {
        return seriesTooltip(plotArea, Object.assign(Object.assign({}, rest), {
          theme,
          elements: selectG2Elements,
          scale: scale10,
          coordinate,
          crosshairs: crosshairsSetting,
          // the crosshairsX settings level: crosshairsX > crosshairs > false
          // it means crosshairsX default is false
          crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
          // crosshairsY default depend on the crossharisSettings
          crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
          item,
          emitter
        }));
      }
      if (isSeries && facet) {
        const facetInstances = viewInstances.filter((d3) => d3 !== target && d3.options.parentKey === target.options.key);
        const elements = selectFacetG2Elements(target, viewInstances);
        const scale11 = facetInstances[0].view.scale;
        const bbox = plotArea.getBounds();
        const startX = bbox.min[0];
        const startY = bbox.min[1];
        Object.assign(scale11, { facet: true });
        return seriesTooltip(plotArea.parentNode.parentNode, Object.assign(Object.assign({}, rest), {
          theme,
          elements: () => elements,
          scale: scale11,
          coordinate,
          crosshairs: maybeValue(crosshairs, defaultShowCrosshairs),
          // the crosshairsX settings level: crosshairsX > crosshairs > false
          // it means crosshairsX default is false
          crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
          crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
          item,
          startX,
          startY,
          emitter
        }));
      }
      return tooltip(plotArea, Object.assign(Object.assign({}, rest), {
        datum: createDatumof(view),
        elements: selectG2Elements,
        scale: scale10,
        coordinate,
        groupKey: shared ? createXKey(view) : void 0,
        item,
        emitter,
        view,
        theme,
        shared
      }));
    };
  }
  Tooltip2.props = {
    reapplyWhenUpdate: true
  };

  // node_modules/@antv/g2/esm/interaction/legendFilter.js
  var __awaiter7 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var CATEGORY_LEGEND_CLASS_NAME = "legend-category";
  var CONTINUOUS_LEGEND_CLASS_NAME = "legend-continuous";
  var LEGEND_ITEMS_CLASS_NAME = "items-item";
  var LEGEND_MAKER_CLASS_NAME = "legend-category-item-marker";
  var LEGEND_LABEL_CLASS_NAME = "legend-category-item-label";
  function markerOf(item) {
    return item.getElementsByClassName(LEGEND_MAKER_CLASS_NAME)[0];
  }
  function labelOf(item) {
    return item.getElementsByClassName(LEGEND_LABEL_CLASS_NAME)[0];
  }
  function itemsOf(root2) {
    return root2.getElementsByClassName(LEGEND_ITEMS_CLASS_NAME);
  }
  function legendsOf(root2) {
    return root2.getElementsByClassName(CATEGORY_LEGEND_CLASS_NAME);
  }
  function legendsContinuousOf(root2) {
    return root2.getElementsByClassName(CONTINUOUS_LEGEND_CLASS_NAME);
  }
  function legendClearSetState(root2, setState) {
    const legends = [...legendsOf(root2), ...legendsContinuousOf(root2)];
    legends.forEach((legend) => {
      setState(legend, (v) => v);
    });
  }
  function dataOf2(root2) {
    let parent = root2.parentNode;
    while (parent && !parent.__data__) {
      parent = parent.parentNode;
    }
    return parent.__data__;
  }
  function legendFilterOrdinal(root2, {
    legends,
    // given the root of chart returns legends to be manipulated
    marker: markerOf2,
    // given the legend returns the marker
    label: labelOf2,
    // given the legend returns the label
    datum,
    // given the legend returns the value
    filter: filter2,
    // invoke when dispatch filter event,
    emitter,
    channel,
    state = {}
    // state options
  }) {
    const itemClick = /* @__PURE__ */ new Map();
    const itemPointerenter = /* @__PURE__ */ new Map();
    const itemPointerout = /* @__PURE__ */ new Map();
    const { unselected = {
      markerStroke: "#aaa",
      markerFill: "#aaa",
      labelFill: "#aaa"
    } } = state;
    const markerStyle = { unselected: subObject(unselected, "marker") };
    const labelStyle = { unselected: subObject(unselected, "label") };
    const { setState: setM, removeState: removeM } = useState(markerStyle, void 0);
    const { setState: setL, removeState: removeL } = useState(labelStyle, void 0);
    const items = Array.from(legends(root2));
    let selectedValues = items.map(datum);
    const updateLegendState = () => {
      for (const item of items) {
        const value2 = datum(item);
        const marker = markerOf2(item);
        const label = labelOf2(item);
        if (!selectedValues.includes(value2)) {
          setM(marker, "unselected");
          setL(label, "unselected");
        } else {
          removeM(marker, "unselected");
          removeL(label, "unselected");
        }
      }
    };
    for (const item of items) {
      const pointerenter = () => {
        setCursor(root2, "pointer");
      };
      const pointerout = () => {
        restoreCursor(root2);
      };
      const click = (event) => __awaiter7(this, void 0, void 0, function* () {
        const value2 = datum(item);
        const index4 = selectedValues.indexOf(value2);
        if (index4 === -1)
          selectedValues.push(value2);
        else
          selectedValues.splice(index4, 1);
        yield filter2(selectedValues);
        updateLegendState();
        const { nativeEvent = true } = event;
        if (!nativeEvent)
          return;
        if (selectedValues.length === items.length) {
          emitter.emit("legend:reset", { nativeEvent });
        } else {
          emitter.emit("legend:filter", Object.assign(Object.assign({}, event), { nativeEvent, data: {
            channel,
            values: selectedValues
          } }));
        }
      });
      item.addEventListener("click", click);
      item.addEventListener("pointerenter", pointerenter);
      item.addEventListener("pointerout", pointerout);
      itemClick.set(item, click);
      itemPointerenter.set(item, pointerenter);
      itemPointerout.set(item, pointerout);
    }
    const onFilter = (event) => __awaiter7(this, void 0, void 0, function* () {
      const { nativeEvent } = event;
      if (nativeEvent)
        return;
      const { data: data2 } = event;
      const { channel: specifiedChannel, values } = data2;
      if (specifiedChannel !== channel)
        return;
      selectedValues = values;
      yield filter2(selectedValues);
      updateLegendState();
    });
    const onEnd = (event) => __awaiter7(this, void 0, void 0, function* () {
      const { nativeEvent } = event;
      if (nativeEvent)
        return;
      selectedValues = items.map(datum);
      yield filter2(selectedValues);
      updateLegendState();
    });
    emitter.on("legend:filter", onFilter);
    emitter.on("legend:reset", onEnd);
    return () => {
      for (const item of items) {
        item.removeEventListener("click", itemClick.get(item));
        item.removeEventListener("pointerenter", itemPointerenter.get(item));
        item.removeEventListener("pointerout", itemPointerout.get(item));
        emitter.off("legend:filter", onFilter);
        emitter.off("legend:reset", onEnd);
      }
    };
  }
  function legendFilterContinuous(_2, { legend, filter: filter2, emitter, channel }) {
    const onValueChange = ({ detail: { value: value2 } }) => {
      filter2(value2);
      emitter.emit({
        nativeEvent: true,
        data: {
          channel,
          values: value2
        }
      });
    };
    legend.addEventListener("valuechange", onValueChange);
    return () => {
      legend.removeEventListener("valuechange", onValueChange);
    };
  }
  function filterView(context, {
    legend,
    // Legend instance.
    channel,
    // Filter Channel.
    value: value2,
    // Filtered Values.
    ordinal,
    // Data type of the legend.
    channels,
    // Channels for this legend.
    allChannels,
    // Channels for all legends.
    facet = false
    // For facet.
  }) {
    return __awaiter7(this, void 0, void 0, function* () {
      const { view, update, setState } = context;
      setState(legend, (viewOptions) => {
        const { marks } = viewOptions;
        const newMarks = marks.map((mark) => {
          if (mark.type === "legends")
            return mark;
          const { transform = [], data: data2 = [] } = mark;
          const index4 = transform.findIndex(({ type }) => type.startsWith("group") || type.startsWith("bin"));
          const newTransform = [...transform];
          if (data2.length) {
            newTransform.splice(index4 + 1, 0, {
              type: "filter",
              [channel]: { value: value2, ordinal }
            });
          }
          const newScale = Object.fromEntries(channels.map((channel2) => [
            channel2,
            { domain: view.scale[channel2].getOptions().domain }
          ]));
          return deep_mix_default({}, mark, Object.assign(Object.assign({ transform: newTransform, scale: newScale }, !ordinal && { animate: false }), { legend: facet ? false : Object.fromEntries(allChannels.map((d3) => [d3, { preserve: true }])) }));
        });
        return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
      });
      yield update();
    });
  }
  function filterFacets(facets, options) {
    for (const facet of facets) {
      filterView(facet, Object.assign(Object.assign({}, options), { facet: true }));
    }
  }
  function LegendFilter() {
    return (context, contexts, emitter) => {
      const { container } = context;
      const facets = contexts.filter((d3) => d3 !== context);
      const isFacet = facets.length > 0;
      const channelsOf = (legend) => {
        return dataOf2(legend).scales.map((d3) => d3.name);
      };
      const legends = [
        ...legendsOf(container),
        ...legendsContinuousOf(container)
      ];
      const allChannels = legends.flatMap(channelsOf);
      const filter2 = isFacet ? throttle_default(filterFacets, 50, { trailing: true }) : throttle_default(filterView, 50, { trailing: true });
      const removes = legends.map((legend) => {
        const { name: channel, domain } = dataOf2(legend).scales[0];
        const channels = channelsOf(legend);
        const common = {
          legend,
          channel,
          channels,
          allChannels
        };
        if (legend.className === CATEGORY_LEGEND_CLASS_NAME) {
          return legendFilterOrdinal(container, {
            legends: itemsOf,
            marker: markerOf,
            label: labelOf,
            datum: (d3) => {
              const { __data__: datum } = d3;
              const { index: index4 } = datum;
              return domain[index4];
            },
            filter: (value2) => {
              const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: true });
              if (isFacet)
                filter2(facets, options);
              else
                filter2(context, options);
            },
            state: legend.attributes.state,
            channel,
            emitter
          });
        } else {
          return legendFilterContinuous(container, {
            legend,
            filter: (value2) => {
              const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: false });
              if (isFacet)
                filter2(facets, options);
              else
                filter2(context, options);
            },
            emitter,
            channel
          });
        }
      });
      return () => {
        removes.forEach((remove) => remove());
      };
    };
  }

  // node_modules/@antv/g2/esm/interaction/legendHighlight.js
  function LegendHighlight() {
    return (context, _2, emitter) => {
      const { container, view, options } = context;
      const legends = legendsOf(container);
      const elements = selectG2Elements(container);
      const channelOf = (legend) => {
        return dataOf2(legend).scales[0].name;
      };
      const scaleOf2 = (channel) => {
        const { scale: { [channel]: scale10 } } = view;
        return scale10;
      };
      const markState = mergeState(options, ["active", "inactive"]);
      const valueof2 = createValueof(elements, createDatumof(view));
      const destroys = [];
      for (const legend of legends) {
        const datumOf = (item) => {
          const { data: data2 } = legend.attributes;
          const { __data__: datum } = item;
          const { index: index4 } = datum;
          return data2[index4].label;
        };
        const channel = channelOf(legend);
        const items = itemsOf(legend);
        const scale10 = scaleOf2(channel);
        const elementGroup = group(elements, (d3) => scale10.invert(d3.__data__[channel]));
        const { state: legendState = {} } = legend.attributes;
        const { inactive = {} } = legendState;
        const { setState, removeState } = useState(markState, valueof2);
        const markerStyle = { inactive: subObject(inactive, "marker") };
        const labelStyle = { inactive: subObject(inactive, "label") };
        const { setState: setM, removeState: removeM } = useState(markerStyle);
        const { setState: setL, removeState: removeL } = useState(labelStyle);
        const updateLegendState = (highlight) => {
          for (const item of items) {
            const marker = markerOf(item);
            const label = labelOf(item);
            if (item === highlight || highlight === null) {
              removeM(marker, "inactive");
              removeL(label, "inactive");
            } else {
              setM(marker, "inactive");
              setL(label, "inactive");
            }
          }
        };
        const highlightItem = (event, item) => {
          const value2 = datumOf(item);
          const elementSet = new Set(elementGroup.get(value2));
          for (const e3 of elements) {
            if (elementSet.has(e3))
              setState(e3, "active");
            else
              setState(e3, "inactive");
          }
          updateLegendState(item);
          const { nativeEvent = true } = event;
          if (!nativeEvent)
            return;
          emitter.emit("legend:highlight", Object.assign(Object.assign({}, event), { nativeEvent, data: { channel, value: value2 } }));
        };
        const itemPointerover = /* @__PURE__ */ new Map();
        for (const item of items) {
          const pointerover = (event) => {
            highlightItem(event, item);
          };
          item.addEventListener("pointerover", pointerover);
          itemPointerover.set(item, pointerover);
        }
        const pointerleave = (event) => {
          for (const e3 of elements)
            removeState(e3, "inactive", "active");
          updateLegendState(null);
          const { nativeEvent = true } = event;
          if (!nativeEvent)
            return;
          emitter.emit("legend:unhighlight", { nativeEvent });
        };
        const onHighlight = (event) => {
          const { nativeEvent, data: data2 } = event;
          if (nativeEvent)
            return;
          const { channel: specifiedChannel, value: value2 } = data2;
          if (specifiedChannel !== channel)
            return;
          const item = items.find((d3) => datumOf(d3) === value2);
          if (!item)
            return;
          highlightItem({ nativeEvent: false }, item);
        };
        const onUnHighlight = (event) => {
          const { nativeEvent } = event;
          if (nativeEvent)
            return;
          pointerleave({ nativeEvent: false });
        };
        legend.addEventListener("pointerleave", pointerleave);
        emitter.on("legend:highlight", onHighlight);
        emitter.on("legend:unhighlight", onUnHighlight);
        const destroy3 = () => {
          legend.removeEventListener(pointerleave);
          emitter.off("legend:highlight", onHighlight);
          emitter.off("legend:unhighlight", onUnHighlight);
          for (const [item, pointerover] of itemPointerover) {
            item.removeEventListener(pointerover);
          }
        };
        destroys.push(destroy3);
      }
      return () => destroys.forEach((d3) => d3());
    };
  }

  // node_modules/@antv/g2/esm/interaction/brushHighlight.js
  var __rest82 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function intersect3(bbox1, bbox2) {
    const [minX1, minY1, maxX1, maxY1] = bbox1;
    const [minX2, minY2, maxX2, maxY2] = bbox2;
    return !(minX2 > maxX1 || maxX2 < minX1 || minY2 > maxY1 || maxY2 < minY1);
  }
  function normalizeBounds(x3, y3, x12, y12, extent2) {
    const [minX, minY, maxX, maxY2] = extent2;
    return [
      Math.max(minX, Math.min(x3, x12)),
      Math.max(minY, Math.min(y3, y12)),
      Math.min(maxX, Math.max(x3, x12)),
      Math.min(maxY2, Math.max(y3, y12))
    ];
  }
  function bboxOf2(root2) {
    const { width, height } = root2.getBBox();
    return [0, 0, width, height];
  }
  function applyStyle3(selection, style) {
    for (const [key, value2] of Object.entries(style)) {
      selection.style(key, value2);
    }
  }
  var ResizableMask = createElement((g) => {
    const _a = g.attributes, { x: x3, y: y3, width, height, class: className2, renders = {}, handleSize: size2 = 10, document: document2 } = _a, style = __rest82(_a, ["x", "y", "width", "height", "class", "renders", "handleSize", "document"]);
    if (!document2 || width === void 0 || height === void 0 || x3 === void 0 || y3 === void 0)
      return;
    const half = size2 / 2;
    const renderRect = (g2, options, document3) => {
      if (!g2.handle) {
        g2.handle = document3.createElement("rect");
        g2.append(g2.handle);
      }
      const { handle } = g2;
      handle.attr(options);
      return handle;
    };
    const _b = subObject(omitPrefixObject(style, "handleNW", "handleNE"), "handleN"), { render: handleNRender = renderRect } = _b, handleNStyle = __rest82(_b, ["render"]);
    const _c = subObject(style, "handleE"), { render: handleERender = renderRect } = _c, handleEStyle = __rest82(_c, ["render"]);
    const _d = subObject(omitPrefixObject(style, "handleSE", "handleSW"), "handleS"), { render: handleSRender = renderRect } = _d, handleSStyle = __rest82(_d, ["render"]);
    const _e = subObject(style, "handleW"), { render: handleWRender = renderRect } = _e, handleWStyle = __rest82(_e, ["render"]);
    const _f = subObject(style, "handleNW"), { render: handleNWRender = renderRect } = _f, handleNWStyle = __rest82(_f, ["render"]);
    const _g = subObject(style, "handleNE"), { render: handleNERender = renderRect } = _g, handleNEStyle = __rest82(_g, ["render"]);
    const _h = subObject(style, "handleSE"), { render: handleSERender = renderRect } = _h, handleSEStyle = __rest82(_h, ["render"]);
    const _j = subObject(style, "handleSW"), { render: handleSWRender = renderRect } = _j, handleSWStyle = __rest82(_j, ["render"]);
    const renderHandle = (g2, renderNode) => {
      const { id: id5 } = g2;
      const handle = renderNode(g2, g2.attributes, document2);
      handle.id = id5;
      handle.style.draggable = true;
    };
    const appendHandle = (handleRender) => {
      return () => {
        const Node6 = createElement((g2) => renderHandle(g2, handleRender));
        return new Node6({});
      };
    };
    const container = select(g).attr("className", className2).style("transform", `translate(${x3}, ${y3})`).style("draggable", true);
    container.maybeAppend("selection", "rect").style("draggable", true).style("fill", "transparent").call(applyStyle3, Object.assign(Object.assign({
      width,
      height
    }, omitPrefixObject(style, "handle")), { transform: void 0 }));
    container.maybeAppend("handle-n", appendHandle(handleNRender)).style("x", half).style("y", -half).style("width", width - size2).style("height", size2).style("fill", "transparent").call(applyStyle3, handleNStyle);
    container.maybeAppend("handle-e", appendHandle(handleERender)).style("x", width - half).style("y", half).style("width", size2).style("height", height - size2).style("fill", "transparent").call(applyStyle3, handleEStyle);
    container.maybeAppend("handle-s", appendHandle(handleSRender)).style("x", half).style("y", height - half).style("width", width - size2).style("height", size2).style("fill", "transparent").call(applyStyle3, handleSStyle);
    container.maybeAppend("handle-w", appendHandle(handleWRender)).style("x", -half).style("y", half).style("width", size2).style("height", height - size2).style("fill", "transparent").call(applyStyle3, handleWStyle);
    container.maybeAppend("handle-nw", appendHandle(handleNWRender)).style("x", -half).style("y", -half).style("width", size2).style("height", size2).style("fill", "transparent").call(applyStyle3, handleNWStyle);
    container.maybeAppend("handle-ne", appendHandle(handleNERender)).style("x", width - half).style("y", -half).style("width", size2).style("height", size2).style("fill", "transparent").call(applyStyle3, handleNEStyle);
    container.maybeAppend("handle-se", appendHandle(handleSERender)).style("x", width - half).style("y", height - half).style("width", size2).style("height", size2).style("fill", "transparent").call(applyStyle3, handleSEStyle);
    container.maybeAppend("handle-sw", appendHandle(handleSWRender)).style("x", -half).style("y", height - half).style("width", size2).style("height", size2).style("fill", "transparent").call(applyStyle3, handleSWStyle);
  });
  function brush(root2, _a) {
    var { brushed = () => {
    }, brushended = () => {
    }, brushcreated = () => {
    }, brushstarted = () => {
    }, brushupdated = () => {
    }, extent: extent2 = bboxOf2(root2), brushRegion = (x3, y3, x12, y12, extent3) => [x3, y3, x12, y12], reverse = false, fill = "#777", fillOpacity = "0.3", stroke: stroke2 = "#fff", selectedHandles = [
      "handle-n",
      "handle-e",
      "handle-s",
      "handle-w",
      "handle-nw",
      "handle-ne",
      "handle-se",
      "handle-sw"
    ] } = _a, style = __rest82(_a, ["brushed", "brushended", "brushcreated", "brushstarted", "brushupdated", "extent", "brushRegion", "reverse", "fill", "fillOpacity", "stroke", "selectedHandles"]);
    let start2 = null;
    let end = null;
    let moveStart = null;
    let mask = null;
    let background = null;
    let creating = false;
    const [originX, originY, width, height] = extent2;
    setCursor(root2, "crosshair");
    root2.style.draggable = true;
    const initMask = (x3, y3, event) => {
      brushstarted(event);
      if (mask)
        mask.remove();
      if (background)
        background.remove();
      start2 = [x3, y3];
      if (reverse)
        return initReverseMask();
      initNormalMask();
    };
    const initReverseMask = () => {
      background = new Path2({
        style: Object.assign(Object.assign({}, style), {
          fill,
          fillOpacity,
          stroke: stroke2,
          pointerEvents: "none"
        })
      });
      mask = new ResizableMask({
        // @ts-ignore
        style: {
          x: 0,
          y: 0,
          width: 0,
          height: 0,
          draggable: true,
          document: root2.ownerDocument
        },
        className: "mask"
      });
      root2.appendChild(background);
      root2.appendChild(mask);
    };
    const initNormalMask = () => {
      mask = new ResizableMask({
        // @ts-ignore
        style: Object.assign(Object.assign({ document: root2.ownerDocument, x: 0, y: 0 }, style), {
          fill,
          fillOpacity,
          stroke: stroke2,
          draggable: true
        }),
        className: "mask"
      });
      root2.appendChild(mask);
    };
    const removeMask = (emit = true) => {
      if (mask)
        mask.remove();
      if (background)
        background.remove();
      start2 = null;
      end = null;
      moveStart = null;
      creating = false;
      mask = null;
      background = null;
      brushended(emit);
    };
    const updateMask = (start3, end2, emit = true) => {
      const [x3, y3, x12, y12] = normalizeBounds(start3[0], start3[1], end2[0], end2[1], extent2);
      const [fx, fy, fx1, fy1] = brushRegion(x3, y3, x12, y12, extent2);
      if (reverse)
        updateReverseMask(fx, fy, fx1, fy1);
      else
        updateNormalMask(fx, fy, fx1, fy1);
      brushed(fx, fy, fx1, fy1, emit);
      return [fx, fy, fx1, fy1];
    };
    const updateNormalMask = (x3, y3, x12, y12) => {
      mask.style.x = x3;
      mask.style.y = y3;
      mask.style.width = x12 - x3;
      mask.style.height = y12 - y3;
    };
    const updateReverseMask = (x3, y3, x12, y12) => {
      background.style.d = `
      M${originX},${originY}L${width},${originY}L${width},${height}L${originX},${height}Z
      M${x3},${y3}L${x3},${y12}L${x12},${y12}L${x12},${y3}Z
    `;
      mask.style.x = x3;
      mask.style.y = y3;
      mask.style.width = x12 - x3;
      mask.style.height = y12 - y3;
    };
    const moveMask = (current) => {
      const clip = (dt, start3, end2, min10, max11) => {
        if (dt + start3 < min10)
          return min10 - start3;
        if (dt + end2 > max11)
          return max11 - end2;
        return dt;
      };
      const dx = current[0] - moveStart[0];
      const dy = current[1] - moveStart[1];
      const dx1 = clip(dx, start2[0], end[0], originX, width);
      const dy1 = clip(dy, start2[1], end[1], originY, height);
      const currentStart = [start2[0] + dx1, start2[1] + dy1];
      const currentEnd = [end[0] + dx1, end[1] + dy1];
      updateMask(currentStart, currentEnd);
    };
    const handles = {
      "handle-n": { vector: [0, 1, 0, 0], cursor: "ns-resize" },
      "handle-e": { vector: [0, 0, 1, 0], cursor: "ew-resize" },
      "handle-s": { vector: [0, 0, 0, 1], cursor: "ns-resize" },
      "handle-w": { vector: [1, 0, 0, 0], cursor: "ew-resize" },
      "handle-nw": { vector: [1, 1, 0, 0], cursor: "nwse-resize" },
      "handle-ne": { vector: [0, 1, 1, 0], cursor: "nesw-resize" },
      "handle-se": { vector: [0, 0, 1, 1], cursor: "nwse-resize" },
      "handle-sw": { vector: [1, 0, 0, 1], cursor: "nesw-resize" }
    };
    const isMask = (target) => {
      return isSelection(target) || isHandle(target);
    };
    const isHandle = (target) => {
      const { id: id5 } = target;
      if (selectedHandles.indexOf(id5) === -1)
        return false;
      return new Set(Object.keys(handles)).has(id5);
    };
    const isSelection = (target) => {
      return target === mask.getElementById("selection");
    };
    const dragstart = (event) => {
      const { target } = event;
      const [offsetX, offsetY] = brushMousePosition(root2, event);
      if (!mask || !isMask(target)) {
        initMask(offsetX, offsetY, event);
        creating = true;
        return;
      }
      if (isMask(target)) {
        moveStart = [offsetX, offsetY];
      }
    };
    const drag = (event) => {
      const { target } = event;
      const mouse = brushMousePosition(root2, event);
      if (!start2)
        return;
      if (!moveStart)
        return updateMask(start2, mouse);
      if (isSelection(target))
        return moveMask(mouse);
      const [dx, dy] = [mouse[0] - moveStart[0], mouse[1] - moveStart[1]];
      const { id: id5 } = target;
      if (handles[id5]) {
        const [sx, sy, ex, ey] = handles[id5].vector;
        return updateMask([start2[0] + dx * sx, start2[1] + dy * sy], [end[0] + dx * ex, end[1] + dy * ey]);
      }
    };
    const dragend = (event) => {
      if (moveStart) {
        moveStart = null;
        const { x: x3, y: y3, width: width2, height: height2 } = mask.style;
        start2 = [x3, y3];
        end = [x3 + width2, y3 + height2];
        brushupdated(x3, y3, x3 + width2, y3 + height2, event);
        return;
      }
      end = brushMousePosition(root2, event);
      const [fx, fy, fx1, fy1] = updateMask(start2, end);
      creating = false;
      brushcreated(fx, fy, fx1, fy1, event);
    };
    const click = (event) => {
      const { target } = event;
      if (mask && !isMask(target))
        removeMask();
    };
    const pointermove = (event) => {
      const { target } = event;
      if (!mask || !isMask(target) || creating)
        setCursor(root2, "crosshair");
      else if (isSelection(target))
        setCursor(root2, "move");
      else if (isHandle(target))
        setCursor(root2, handles[target.id].cursor);
    };
    const pointerleave = () => {
      setCursor(root2, "default");
    };
    root2.addEventListener("dragstart", dragstart);
    root2.addEventListener("drag", drag);
    root2.addEventListener("dragend", dragend);
    root2.addEventListener("click", click);
    root2.addEventListener("pointermove", pointermove);
    root2.addEventListener("pointerleave", pointerleave);
    return {
      mask,
      move(x3, y3, x12, y12, emit = true) {
        if (!mask)
          initMask(x3, y3, {});
        start2 = [x3, y3];
        end = [x12, y12];
        updateMask([x3, y3], [x12, y12], emit);
      },
      remove(emit = true) {
        if (mask)
          removeMask(emit);
      },
      destroy() {
        if (mask)
          removeMask(false);
        setCursor(root2, "default");
        root2.removeEventListener("dragstart", dragstart);
        root2.removeEventListener("drag", drag);
        root2.removeEventListener("dragend", dragend);
        root2.removeEventListener("click", click);
        root2.removeEventListener("pointermove", pointermove);
        root2.removeEventListener("pointerleave", pointerleave);
      }
    };
  }
  function selectSiblingViews(target, viewInstances, brushKey) {
    return viewInstances.filter((d3) => {
      if (d3 === target)
        return false;
      const { interaction = {} } = d3.options;
      return Object.values(interaction).find((d4) => d4.brushKey === brushKey);
    });
  }
  function selectSiblingContainers(target, viewInstances, brushKey) {
    return selectSiblingViews(target, viewInstances, brushKey).map((d3) => selectPlotArea(d3.container));
  }
  function selectSiblingOptions(target, viewInstances, brushKey) {
    return selectSiblingViews(target, viewInstances, brushKey).map((d3) => d3.options);
  }
  function brushHighlight(root2, _a) {
    var { elements: elementof, selectedHandles, siblings: siblingsof = (root3) => [], datum, brushRegion, extent: optionalExtent, reverse, scale: scale10, coordinate, series = false, key = (d3) => d3, bboxOf: bboxOf3 = (root3) => {
      const { x: x3, y: y3, width, height } = root3.style;
      return { x: x3, y: y3, width, height };
    }, state = {}, emitter } = _a, rest = __rest82(_a, ["elements", "selectedHandles", "siblings", "datum", "brushRegion", "extent", "reverse", "scale", "coordinate", "series", "key", "bboxOf", "state", "emitter"]);
    const elements = elementof(root2);
    const siblings = siblingsof(root2);
    const siblingElements = siblings.flatMap(elementof);
    const valueof2 = createValueof(elements, datum);
    const brushStyle = subObject(rest, "mask");
    const { setState, removeState } = useState(state, valueof2);
    const clonedElement = /* @__PURE__ */ new Map();
    const { width: rootWidth, height: rootHeight, x: ordinalX = 0, y: ordinalY = 0 } = bboxOf3(root2);
    const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
    const brushended = () => {
      for (const element of [...elements, ...siblingElements]) {
        removeState(element, "active", "inactive");
      }
    };
    const brushed = (x3, y3, x12, y12) => {
      var _a2;
      for (const sibling of siblings)
        (_a2 = sibling.brush) === null || _a2 === void 0 ? void 0 : _a2.remove();
      const keys2 = /* @__PURE__ */ new Set();
      for (const element of elements) {
        const { min: min10, max: max11 } = element.getLocalBounds();
        const [ex, ey] = min10;
        const [ex1, ey1] = max11;
        if (!intersect3([ex, ey, ex1, ey1], [x3, y3, x12, y12])) {
          setState(element, "inactive");
        } else {
          setState(element, "active");
          keys2.add(key(element));
        }
      }
      for (const element of siblingElements) {
        if (keys2.has(key(element)))
          setState(element, "active");
        else
          setState(element, "inactive");
      }
    };
    const seriesBrushend = () => {
      for (const element of elements)
        removeState(element, "inactive");
      for (const cloned of clonedElement.values())
        cloned.remove();
      clonedElement.clear();
    };
    const seriesBrushed = (x3, y3, x12, y12) => {
      const clone11 = (element) => {
        const cloned = element.cloneNode();
        cloned.__data__ = element.__data__;
        element.parentNode.appendChild(cloned);
        clonedElement.set(element, cloned);
        return cloned;
      };
      const clipPath = new Rect({
        style: {
          x: x3 + ordinalX,
          y: y3 + ordinalY,
          width: x12 - x3,
          height: y12 - y3
        }
      });
      root2.appendChild(clipPath);
      for (const element of elements) {
        const cloned = clonedElement.get(element) || clone11(element);
        cloned.style.clipPath = clipPath;
        setState(element, "inactive");
        setState(cloned, "active");
      }
    };
    const brushHandler = brush(root2, Object.assign(Object.assign({}, brushStyle), {
      extent: extent2,
      brushRegion,
      reverse,
      selectedHandles,
      brushended: (emit) => {
        const handler = series ? seriesBrushend : brushended;
        if (emit) {
          emitter.emit("brush:remove", { nativeEvent: true });
        }
        handler();
      },
      brushed: (x3, y3, x12, y12, emit) => {
        const selection = selectionOf(x3, y3, x12, y12, scale10, coordinate);
        if (emit) {
          emitter.emit("brush:highlight", {
            nativeEvent: true,
            data: { selection }
          });
        }
        const handler = series ? seriesBrushed : brushed;
        handler(x3, y3, x12, y12);
      },
      brushcreated: (x3, y3, x12, y12, event) => {
        const selection = selectionOf(x3, y3, x12, y12, scale10, coordinate);
        emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
      },
      brushupdated: (x3, y3, x12, y12, event) => {
        const selection = selectionOf(x3, y3, x12, y12, scale10, coordinate);
        emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
      },
      brushstarted: (e3) => {
        emitter.emit("brush:start", e3);
      }
    }));
    const onHighlight = ({ nativeEvent, data: data2 }) => {
      if (nativeEvent)
        return;
      const { selection } = data2;
      const [x3, y3, x12, y12] = pixelsOf(selection, scale10, coordinate);
      brushHandler.move(x3, y3, x12, y12, false);
    };
    emitter.on("brush:highlight", onHighlight);
    const onRemove = ({ nativeEvent } = {}) => {
      if (nativeEvent)
        return;
      brushHandler.remove(false);
    };
    emitter.on("brush:remove", onRemove);
    const preBrushDestroy = brushHandler.destroy.bind(brushHandler);
    brushHandler.destroy = () => {
      emitter.off("brush:highlight", onHighlight);
      emitter.off("brush:remove", onRemove);
      preBrushDestroy();
    };
    return brushHandler;
  }
  function BrushHighlight(_a) {
    var { facet, brushKey } = _a, rest = __rest82(_a, ["facet", "brushKey"]);
    return (target, viewInstances, emitter) => {
      const { container, view, options } = target;
      const plotArea = selectPlotArea(container);
      const defaultOptions2 = {
        maskFill: "#777",
        maskFillOpacity: "0.3",
        maskStroke: "#fff",
        reverse: false
      };
      const defaultStates = ["active", ["inactive", { opacity: 0.5 }]];
      const { scale: scale10, coordinate } = view;
      if (facet) {
        const bbox = plotArea.getBounds();
        const x3 = bbox.min[0];
        const y3 = bbox.min[1];
        const x12 = bbox.max[0];
        const y12 = bbox.max[1];
        return brushHighlight(plotArea.parentNode.parentNode, Object.assign(Object.assign({
          elements: () => selectFacetG2Elements(target, viewInstances),
          datum: createDatumof(selectFacetViews(target, viewInstances).map((d3) => d3.view)),
          brushRegion: (x4, y4, x13, y13) => [x4, y4, x13, y13],
          extent: [x3, y3, x12, y12],
          state: mergeState(selectFacetViews(target, viewInstances).map((d3) => d3.options), defaultStates),
          emitter,
          scale: scale10,
          coordinate,
          selectedHandles: void 0
        }, defaultOptions2), rest));
      }
      const brush2 = brushHighlight(plotArea, Object.assign(Object.assign({
        elements: selectG2Elements,
        key: (element) => element.__data__.key,
        siblings: () => selectSiblingContainers(target, viewInstances, brushKey),
        datum: createDatumof([
          view,
          ...selectSiblingViews(target, viewInstances, brushKey).map((d3) => d3.view)
        ]),
        brushRegion: (x3, y3, x12, y12) => [x3, y3, x12, y12],
        extent: void 0,
        state: mergeState([options, ...selectSiblingOptions(target, viewInstances, brushKey)], defaultStates),
        emitter,
        scale: scale10,
        coordinate,
        selectedHandles: void 0
      }, defaultOptions2), rest));
      plotArea.brush = brush2;
      return () => brush2.destroy();
    };
  }

  // node_modules/@antv/g2/esm/interaction/brushXHighlight.js
  function brushXRegion(x3, y3, x12, y12, extent2) {
    const [, minY, , maxY2] = extent2;
    return [x3, minY, x12, maxY2];
  }
  function BrushXHighlight(options) {
    return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushXRegion, selectedHandles: ["handle-e", "handle-w"] }));
  }

  // node_modules/@antv/g2/esm/interaction/brushYHighlight.js
  function brushYRegion(x3, y3, x12, y12, extent2) {
    const [minX, , maxX] = extent2;
    return [minX, y3, maxX, y12];
  }
  function BrushYHighlight(options) {
    return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushYRegion, selectedHandles: ["handle-n", "handle-s"] }));
  }

  // node_modules/@antv/g2/esm/interaction/brushAxisHighlight.js
  var __rest83 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var AXIS_CLASS_NAME = "axis";
  var AXIS_LINE_CLASS_NAME = "axis-line";
  var AXIS_MAIN_CLASS_NAME = "axis-main-group";
  var AXIS_HOT_AREA_CLASS_NAME = "axis-hot-area";
  function axesOf(container) {
    return container.getElementsByClassName(AXIS_CLASS_NAME);
  }
  function lineOf(axis) {
    return axis.getElementsByClassName(AXIS_LINE_CLASS_NAME)[0];
  }
  function mainGroupOf(axis) {
    return axis.getElementsByClassName(AXIS_MAIN_CLASS_NAME)[0];
  }
  function boundsOfAxis(axis) {
    return mainGroupOf(axis).getLocalBounds();
  }
  function verticalBrush(axis, _a) {
    var { cross: cross6, offsetX, offsetY } = _a, style = __rest83(_a, ["cross", "offsetX", "offsetY"]);
    const bounds = boundsOfAxis(axis);
    const axisLine = lineOf(axis);
    const [lineX] = axisLine.getLocalBounds().min;
    const [minX, minY] = bounds.min;
    const [maxX, maxY2] = bounds.max;
    const size2 = (maxX - minX) * 2;
    return {
      brushRegion: brushYRegion,
      hotZone: new Rect({
        className: AXIS_HOT_AREA_CLASS_NAME,
        style: Object.assign({
          // If it is not cross, draw brush in both side of axisLine,
          // otherwise the draw brush within bounds area.
          width: cross6 ? size2 / 2 : size2,
          transform: `translate(${(cross6 ? minX : lineX - size2 / 2).toFixed(2)}, ${minY})`,
          height: maxY2 - minY
        }, style)
      }),
      extent: cross6 ? (
        // If it is cross, the x range is ignored.
        (x3, y3, x12, y12) => [-Infinity, y3, Infinity, y12]
      ) : (x3, y3, x12, y12) => [
        Math.floor(minX - offsetX),
        y3,
        Math.ceil(maxX - offsetX),
        y12
      ]
    };
  }
  function horizontalBrush(axis, _a) {
    var { offsetY, offsetX, cross: cross6 = false } = _a, style = __rest83(_a, ["offsetY", "offsetX", "cross"]);
    const bounds = boundsOfAxis(axis);
    const axisLine = lineOf(axis);
    const [, lineY] = axisLine.getLocalBounds().min;
    const [minX, minY] = bounds.min;
    const [maxX, maxY2] = bounds.max;
    const size2 = maxY2 - minY;
    return {
      brushRegion: brushXRegion,
      hotZone: new Rect({
        className: AXIS_HOT_AREA_CLASS_NAME,
        style: Object.assign({
          width: maxX - minX,
          // If it is not cross, draw brush in both side of axisLine,
          // otherwise the draw brush within bounds area.
          height: cross6 ? size2 : size2 * 2,
          transform: `translate(${minX}, ${cross6 ? minY : lineY - size2})`
        }, style)
      }),
      extent: cross6 ? (
        // If it is cross, the y range is ignored.
        (x3, y3, x12, y12) => [x3, -Infinity, x12, Infinity]
      ) : (x3, y3, x12, y12) => [
        x3,
        Math.floor(minY - offsetY),
        x12,
        Math.ceil(maxY2 - offsetY)
      ]
    };
  }
  function brushAxisHighlight(root2, _a) {
    var {
      axes: axesOf2,
      // given root, return axes
      elements: elementsOf,
      // given root, return elements
      points: pointsOf,
      // given shape, return control points
      horizontal: isHorizontal3,
      // given axis, return direction
      datum,
      // given shape, return datum
      offsetY,
      // offsetY for shape area
      offsetX,
      // offsetX for shape area
      reverse = false,
      state = {},
      emitter,
      coordinate
    } = _a, rest = __rest83(_a, ["axes", "elements", "points", "horizontal", "datum", "offsetY", "offsetX", "reverse", "state", "emitter", "coordinate"]);
    const elements = elementsOf(root2);
    const axes = axesOf2(root2);
    const valueof2 = createValueof(elements, datum);
    const { setState, removeState } = useState(state, valueof2);
    const axisExtent = /* @__PURE__ */ new Map();
    const brushStyle = subObject(rest, "mask");
    const brushed = (points) => Array.from(axisExtent.values()).every(([x3, y3, x12, y12]) => points.some(([x05, y05]) => {
      return x05 >= x3 && x05 <= x12 && y05 >= y3 && y05 <= y12;
    }));
    const scales = axes.map((d3) => d3.attributes.scale);
    const extentOf2 = (D2) => D2.length > 2 ? [D2[0], D2[D2.length - 1]] : D2;
    const indexDomain = /* @__PURE__ */ new Map();
    const initIndexDomain = () => {
      indexDomain.clear();
      for (let i = 0; i < axes.length; i++) {
        const scale10 = scales[i];
        const { domain } = scale10.getOptions();
        indexDomain.set(i, extentOf2(domain));
      }
    };
    initIndexDomain();
    const updateElement = (i, emit) => {
      const selectedElements = [];
      for (const element of elements) {
        const points = pointsOf(element);
        if (brushed(points)) {
          setState(element, "active");
          selectedElements.push(element);
        } else
          setState(element, "inactive");
      }
      indexDomain.set(i, selectionOf2(selectedElements, i));
      if (!emit)
        return;
      const selection = () => {
        if (!cross6)
          return Array.from(indexDomain.values());
        const S = [];
        for (const [index4, domain] of indexDomain) {
          const scale10 = scales[index4];
          const { name: name2 } = scale10.getOptions();
          if (name2 === "x")
            S[0] = domain;
          else
            S[1] = domain;
        }
        return S;
      };
      emitter.emit("brushAxis:highlight", {
        nativeEvent: true,
        data: {
          selection: selection()
        }
      });
    };
    const clearElement = (emit) => {
      for (const element of elements)
        removeState(element, "active", "inactive");
      initIndexDomain();
      if (!emit)
        return;
      emitter.emit("brushAxis:remove", { nativeEvent: true });
    };
    const selectionOf2 = (selected, i) => {
      const scale10 = scales[i];
      const { name: name2 } = scale10.getOptions();
      const domain = selected.map((d3) => {
        const data2 = d3.__data__;
        return scale10.invert(data2[name2]);
      });
      return extentOf2(domainOf3(scale10, domain));
    };
    const cross6 = axes.some(isHorizontal3) && axes.some((d3) => !isHorizontal3(d3));
    const handlers = [];
    for (let i = 0; i < axes.length; i++) {
      const axis = axes[i];
      const createBrush = isHorizontal3(axis) ? horizontalBrush : verticalBrush;
      const { hotZone, brushRegion, extent: extent2 } = createBrush(axis, {
        offsetY,
        offsetX,
        cross: cross6,
        zIndex: 999,
        fill: "transparent"
        // Make it interactive.
      });
      axis.parentNode.appendChild(hotZone);
      const brushHandler = brush(hotZone, Object.assign(Object.assign({}, brushStyle), {
        reverse,
        brushRegion,
        brushended(emit) {
          axisExtent.delete(axis);
          if (Array.from(axisExtent.entries()).length === 0)
            clearElement(emit);
          else
            updateElement(i, emit);
        },
        brushed(x3, y3, x12, y12, emit) {
          axisExtent.set(axis, extent2(x3, y3, x12, y12));
          updateElement(i, emit);
        }
      }));
      handlers.push(brushHandler);
    }
    const onRemove = (event = {}) => {
      const { nativeEvent } = event;
      if (nativeEvent)
        return;
      handlers.forEach((d3) => d3.remove(false));
    };
    const rangeOf4 = (domain, scale10, axis) => {
      const [d0, d1] = domain;
      const maybeStep = (scale11) => scale11.getStep ? scale11.getStep() : 0;
      const x3 = abstractOf2(d0, scale10, axis);
      const x12 = abstractOf2(d1, scale10, axis) + maybeStep(scale10);
      if (isHorizontal3(axis))
        return [x3, -Infinity, x12, Infinity];
      return [-Infinity, x3, Infinity, x12];
    };
    const abstractOf2 = (x3, scale10, axis) => {
      const { height, width } = coordinate.getOptions();
      const scale1 = scale10.clone();
      if (isHorizontal3(axis))
        scale1.update({ range: [0, width] });
      else
        scale1.update({ range: [height, 0] });
      return scale1.map(x3);
    };
    const onHighlight = (event) => {
      const { nativeEvent } = event;
      if (nativeEvent)
        return;
      const { selection } = event.data;
      for (let i = 0; i < handlers.length; i++) {
        const domain = selection[i];
        const handler = handlers[i];
        const axis = axes[i];
        if (domain) {
          const scale10 = scales[i];
          handler.move(...rangeOf4(domain, scale10, axis), false);
        } else {
          handler.remove(false);
        }
      }
    };
    emitter.on("brushAxis:remove", onRemove);
    emitter.on("brushAxis:highlight", onHighlight);
    return () => {
      handlers.forEach((d3) => d3.destroy());
      emitter.off("brushAxis:remove", onRemove);
      emitter.off("brushAxis:highlight", onHighlight);
    };
  }
  function BrushAxisHighlight(options) {
    return (target, _2, emitter) => {
      const { container, view, options: viewOptions } = target;
      const plotArea = selectPlotArea(container);
      const { x: x05, y: y05 } = plotArea.getBBox();
      const { coordinate } = view;
      return brushAxisHighlight(container, Object.assign({
        elements: selectG2Elements,
        axes: axesOf,
        offsetY: y05,
        offsetX: x05,
        points: (element) => element.__data__.points,
        horizontal: (axis) => {
          const { startPos: [sx, sy], endPos: [ex, ey] } = axis.attributes;
          return sx !== ex && sy === ey;
        },
        datum: createDatumof(view),
        state: mergeState(viewOptions, [
          "active",
          ["inactive", { opacity: 0.5 }]
        ]),
        coordinate,
        emitter
      }, options));
    };
  }

  // node_modules/@antv/g2/esm/interaction/brushFilter.js
  var __awaiter8 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest84 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function dblclick(interval2 = 300) {
    let preTimeStamp = null;
    return (e3) => {
      const { timeStamp } = e3;
      if (preTimeStamp !== null && timeStamp - preTimeStamp < interval2) {
        preTimeStamp = timeStamp;
        return true;
      }
      preTimeStamp = timeStamp;
      return false;
    };
  }
  function brushFilter(root2, _a) {
    var { filter: filter2, reset, brushRegion, extent: optionalExtent, reverse, emitter, scale: scale10, coordinate, selection, series = false } = _a, rest = __rest84(_a, ["filter", "reset", "brushRegion", "extent", "reverse", "emitter", "scale", "coordinate", "selection", "series"]);
    const brushStyle = subObject(rest, "mask");
    const { width: rootWidth, height: rootHeight } = root2.getBBox();
    const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
    const isDblclick = dblclick();
    const brush2 = brush(root2, Object.assign(Object.assign({}, brushStyle), {
      extent: extent2,
      brushRegion,
      reverse,
      brushcreated
    }));
    root2.addEventListener("click", click);
    function brushcreated(x3, y3, x12, y12, event) {
      event.nativeEvent = true;
      filter2(selection(x3, y3, x12, y12), event);
      brush2.remove();
    }
    function click(e3) {
      if (isDblclick(e3)) {
        e3.nativeEvent = true;
        reset(e3);
      }
    }
    const onFilter = ({ nativeEvent, data: data2 }) => {
      if (nativeEvent)
        return;
      const { selection: selection2 } = data2;
      filter2(selection2, { nativeEvent: false });
    };
    emitter.on("brush:filter", onFilter);
    return () => {
      brush2.destroy();
      emitter.off("brush:filter", onFilter);
      root2.removeEventListener("click", click);
    };
  }
  function BrushFilter(_a) {
    var { hideX = true, hideY = true } = _a, rest = __rest84(_a, ["hideX", "hideY"]);
    return (target, viewInstances, emitter) => {
      const { container, view, options: viewOptions, update, setState } = target;
      const plotArea = selectPlotArea(container);
      const defaultOptions2 = {
        maskFill: "#777",
        maskFillOpacity: "0.3",
        maskStroke: "#fff",
        unhighlightedOpacity: 0.5,
        reverse: false
      };
      let filtered = false;
      let filtering = false;
      let newView = view;
      const { scale: scale10, coordinate } = view;
      return brushFilter(plotArea, Object.assign(Object.assign({
        brushRegion: (x3, y3, x12, y12) => [x3, y3, x12, y12],
        selection: (x3, y3, x12, y12) => {
          const { scale: scale11, coordinate: coordinate2 } = newView;
          return selectionOf(x3, y3, x12, y12, scale11, coordinate2);
        },
        filter: (selection, event) => __awaiter8(this, void 0, void 0, function* () {
          if (filtering)
            return;
          filtering = true;
          const [domainX, domainY] = selection;
          setState("brushFilter", (options) => {
            const { marks } = options;
            const newMarks = marks.map((mark) => deep_mix_default({
              // Hide label to keep smooth transition.
              axis: Object.assign(Object.assign({}, hideX && { x: { transform: [{ type: "hide" }] } }), hideY && { y: { transform: [{ type: "hide" }] } })
            }, mark, {
              // Set nice to false to avoid modify domain.
              scale: {
                x: { domain: domainX, nice: false },
                y: { domain: domainY, nice: false }
              }
            }));
            return Object.assign(Object.assign({}, viewOptions), { marks: newMarks, clip: true });
          });
          emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
          const newState = yield update();
          newView = newState.view;
          filtering = false;
          filtered = true;
        }),
        reset: (event) => {
          if (filtering || !filtered)
            return;
          const { scale: scale11 } = view;
          const { x: scaleX2, y: scaleY2 } = scale11;
          const domainX = scaleX2.getOptions().domain;
          const domainY = scaleY2.getOptions().domain;
          emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
          filtered = false;
          newView = view;
          setState("brushFilter");
          update();
        },
        extent: void 0,
        emitter,
        scale: scale10,
        coordinate
      }, defaultOptions2), rest));
    };
  }

  // node_modules/@antv/g2/esm/interaction/brushXFilter.js
  function BrushXFilter(options) {
    return BrushFilter(Object.assign(Object.assign({ hideX: true }, options), { brushRegion: brushXRegion }));
  }

  // node_modules/@antv/g2/esm/interaction/brushYFilter.js
  function BrushYFilter(options) {
    return BrushFilter(Object.assign(Object.assign({ hideY: true }, options), { brushRegion: brushYRegion }));
  }

  // node_modules/@antv/g2/esm/interaction/sliderFilter.js
  var __awaiter9 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var SLIDER_CLASS_NAME = "slider";
  function filterDataByDomain(options, scaleOptions, prefix, hasState = false, channel0 = "x", channel1 = "y") {
    const { marks } = options;
    const newMarks = marks.map((mark) => {
      var _a, _b;
      return deep_mix_default({
        // Hide label to keep smooth transition.
        axis: {
          x: { transform: [{ type: "hide" }] },
          y: { transform: [{ type: "hide" }] }
        }
      }, mark, {
        scale: scaleOptions,
        // Don't rerender sliders.
        [prefix]: Object.assign(Object.assign({}, ((_a = mark[prefix]) === null || _a === void 0 ? void 0 : _a[channel0]) && {
          [channel0]: Object.assign({ preserve: true }, hasState && { ratio: null })
        }), ((_b = mark[prefix]) === null || _b === void 0 ? void 0 : _b[channel1]) && {
          [channel1]: { preserve: true }
        }),
        animate: false
      });
    });
    return Object.assign(Object.assign({}, options), { marks: newMarks, clip: true, animate: false });
  }
  function abstractValue(values, scale10, reverse) {
    const [x3, x12] = values;
    const v = reverse ? (d3) => 1 - d3 : (d3) => d3;
    const d0 = invert4(scale10, v(x3), true);
    const d1 = invert4(scale10, v(x12), false);
    return domainOf3(scale10, [d0, d1]);
  }
  function extentOf(domain) {
    return [domain[0], domain[domain.length - 1]];
  }
  function SliderFilter({ initDomain = {}, className: className2 = SLIDER_CLASS_NAME, prefix = "slider", setValue = (component, values) => component.setValues(values), hasState = false, wait = 50, leading = true, trailing = false, getInitValues = (slider) => {
    var _a;
    const values = (_a = slider === null || slider === void 0 ? void 0 : slider.attributes) === null || _a === void 0 ? void 0 : _a.values;
    if (values[0] !== 0 || values[1] !== 1)
      return values;
  } }) {
    return (context, _2, emitter) => {
      const { container, view, update, setState } = context;
      const sliders = container.getElementsByClassName(className2);
      if (!sliders.length)
        return () => {
        };
      let filtering = false;
      const { scale: scale10, coordinate, layout } = view;
      const { paddingLeft, paddingTop, paddingBottom, paddingRight } = layout;
      const { x: scaleX2, y: scaleY2 } = scale10;
      const transposed = isTranspose(coordinate);
      const channelOf = (orientation) => {
        const channel0 = orientation === "vertical" ? "y" : "x";
        const channel1 = orientation === "vertical" ? "x" : "y";
        if (transposed)
          return [channel1, channel0];
        return [channel0, channel1];
      };
      const sliderHandler = /* @__PURE__ */ new Map();
      const emitHandlers = /* @__PURE__ */ new Set();
      const channelDomain = {
        x: initDomain.x || scaleX2.getOptions().domain,
        y: initDomain.y || scaleY2.getOptions().domain
      };
      for (const slider of sliders) {
        const { orientation } = slider.attributes;
        const [channel0, channel1] = channelOf(orientation);
        const eventName = `${prefix}${upper_first_default(channel0)}:filter`;
        const isX = channel0 === "x";
        const { ratio: ratioX } = scaleX2.getOptions();
        const { ratio: ratioY } = scaleY2.getOptions();
        const domainsOf = (event) => {
          if (event.data) {
            const { selection } = event.data;
            const [X = extentOf(channelDomain.x), Y = extentOf(channelDomain.y)] = selection;
            return isX ? [domainOf3(scaleX2, X, ratioX), domainOf3(scaleY2, Y, ratioY)] : [domainOf3(scaleY2, Y, ratioY), domainOf3(scaleX2, X, ratioX)];
          }
          const { value: values2 } = event.detail;
          const scale0 = scale10[channel0];
          const domain0 = abstractValue(values2, scale0, transposed && orientation === "horizontal");
          const domain1 = channelDomain[channel1];
          return [domain0, domain1];
        };
        const onValueChange = throttle_default((event) => __awaiter9(this, void 0, void 0, function* () {
          const { initValue = false } = event;
          if (filtering && !initValue)
            return;
          filtering = true;
          const { nativeEvent = true } = event;
          const [domain0, domain1] = domainsOf(event);
          channelDomain[channel0] = domain0;
          channelDomain[channel1] = domain1;
          if (nativeEvent) {
            const X = isX ? domain0 : domain1;
            const Y = isX ? domain1 : domain0;
            emitter.emit(eventName, Object.assign(Object.assign({}, event), { nativeEvent, data: { selection: [extentOf(X), extentOf(Y)] } }));
          }
          setState(slider, (options) => Object.assign(Object.assign({}, filterDataByDomain(
            options,
            // Set nice to false to avoid modify domain.
            // Only update domain of current slider / scrollbar.
            { [channel0]: { domain: domain0, nice: false } },
            prefix,
            hasState,
            channel0,
            channel1
          )), {
            paddingLeft,
            paddingTop,
            paddingBottom,
            paddingRight
          }));
          yield update();
          filtering = false;
        }), wait, { leading, trailing });
        const emitHandler = (event) => {
          const { nativeEvent } = event;
          if (nativeEvent)
            return;
          const { data: data2 } = event;
          const { selection } = data2;
          const [X, Y] = selection;
          slider.dispatchEvent(new CustomEvent2("valuechange", {
            data: data2,
            nativeEvent: false
          }));
          const V = isX ? abstractOf(X, scaleX2) : abstractOf(Y, scaleY2);
          setValue(slider, V);
        };
        emitter.on(eventName, emitHandler);
        slider.addEventListener("valuechange", onValueChange);
        sliderHandler.set(slider, onValueChange);
        emitHandlers.add([eventName, emitHandler]);
        const values = getInitValues(slider);
        if (values) {
          slider.dispatchEvent(new CustomEvent2("valuechange", {
            detail: {
              value: values
            },
            nativeEvent: false,
            initValue: true
          }));
        }
      }
      return () => {
        for (const [slider, handler] of sliderHandler) {
          slider.removeEventListener("valuechange", handler);
        }
        for (const [name2, handler] of emitHandlers) {
          emitter.off(name2, handler);
        }
      };
    };
  }

  // node_modules/@antv/g2/esm/interaction/scrollbarFilter.js
  var SCROLLBAR_CLASS_NAME = "g2-scrollbar";
  function ScrollbarFilter(options = {}) {
    return (context, _2, emitter) => {
      const { view, container } = context;
      const scrollbars = container.getElementsByClassName(SCROLLBAR_CLASS_NAME);
      if (!scrollbars.length)
        return () => {
        };
      const { scale: scale10 } = view;
      const { x: scaleX2, y: scaleY2 } = scale10;
      const initDomain = {
        x: [...scaleX2.getOptions().domain],
        y: [...scaleY2.getOptions().domain]
      };
      scaleX2.update({ domain: scaleX2.getOptions().expectedDomain });
      scaleY2.update({ domain: scaleY2.getOptions().expectedDomain });
      const interaction = SliderFilter(Object.assign(Object.assign({}, options), { initDomain, className: SCROLLBAR_CLASS_NAME, prefix: "scrollbar", hasState: true, setValue: (component, values) => component.setValue(values[0]), getInitValues: (scrollbar) => {
        const values = scrollbar.slider.attributes.values;
        if (values[0] !== 0)
          return values;
      } }));
      return interaction(context, _2, emitter);
    };
  }

  // node_modules/@antv/g2/esm/interaction/poptip.js
  var __rest85 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function dom(tag, children, style) {
    return `<${tag} style="${Object.entries(style).map(([key, value2]) => `${kebabCase(key)}:${value2}`).join(";")}">${children}</${tag}>`;
  }
  var defaultTipStyle = {
    backgroundColor: "rgba(0,0,0,0.75)",
    color: "#fff",
    width: "max-content",
    padding: "1px 4px",
    fontSize: "12px",
    borderRadius: "2.5px",
    boxShadow: "0 3px 6px -4px rgba(0,0,0,0.12), 0 6px 16px 0 rgba(0,0,0,0.08), 0 9px 28px 8px rgba(0,0,0,0.05)"
  };
  function isTipText(element) {
    if (element.nodeName !== "text")
      return false;
    if (element.isOverflowing())
      return true;
    return false;
  }
  function Poptip(_a) {
    var { offsetX = 8, offsetY = 8 } = _a, style = __rest85(_a, ["offsetX", "offsetY"]);
    return (context) => {
      const { container } = context;
      const [x05, y05] = container.getBounds().min;
      const tipStyle = subObject(style, "tip");
      const tips = /* @__PURE__ */ new Set();
      const pointerover = (e3) => {
        const { target } = e3;
        if (!isTipText(target)) {
          e3.stopPropagation();
          return;
        }
        const { offsetX: mouseX, offsetY: mouseY } = e3;
        const x3 = mouseX + offsetX - x05;
        const y3 = mouseY + offsetY - y05;
        if (target.tip) {
          target.tip.style.x = x3;
          target.tip.style.y = y3;
          return;
        }
        const { text } = target.style;
        const tipELement = new HTML({
          className: "poptip",
          style: {
            innerHTML: dom("div", text, Object.assign(Object.assign({}, defaultTipStyle), tipStyle)),
            x: x3,
            y: y3
          }
        });
        container.appendChild(tipELement);
        target.tip = tipELement;
        tips.add(tipELement);
      };
      const pointerout = (e3) => {
        const { target } = e3;
        if (!isTipText(target)) {
          e3.stopPropagation();
          return;
        }
        if (!target.tip)
          return;
        target.tip.remove();
        target.tip = null;
        tips.delete(target.tip);
      };
      container.addEventListener("pointerover", pointerover);
      container.addEventListener("pointerout", pointerout);
      return () => {
        container.removeEventListener("pointerover", pointerover);
        container.removeEventListener("pointerout", pointerout);
        tips.forEach((tip) => tip.remove());
      };
    };
  }
  Poptip.props = {
    reapplyWhenUpdate: true
  };

  // node_modules/@antv/g2/esm/interaction/treemapDrillDown.js
  var __awaiter10 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest86 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  function selectPlotArea2(root2) {
    return select(root2).select(`.${PLOT_CLASS_NAME}`).node();
  }
  var DEFAULT_BREADCRUMB_STYLE = {
    breadCrumbFill: "rgba(0, 0, 0, 0.85)",
    breadCrumbFontSize: 12,
    breadCrumbY: 12,
    activeFill: "rgba(0, 0, 0, 0.5)"
  };
  function TreemapDrillDown(drillDownOptions = {}) {
    const { originData = [], layout } = drillDownOptions, style = __rest86(drillDownOptions, ["originData", "layout"]);
    const breadCrumb = deep_mix_default({}, DEFAULT_BREADCRUMB_STYLE, style);
    const breadCrumbStyle = subObject(breadCrumb, "breadCrumb");
    const breadCrumbActiveStyle = subObject(breadCrumb, "active");
    return (context) => {
      const { update, setState, container, options } = context;
      const plotArea = selectPlotArea2(container);
      const mark = options.marks[0];
      const { state } = mark;
      const textGroup = new Group2();
      plotArea.appendChild(textGroup);
      const drillDownClick = (path2, depth) => __awaiter10(this, void 0, void 0, function* () {
        textGroup.removeChildren();
        if (depth) {
          let name2 = "";
          let y3 = breadCrumbStyle.y;
          let x3 = 0;
          const textPath = [];
          const maxWidth = plotArea.getBBox().width;
          const drillTexts = path2.map((text, index4) => {
            name2 = `${name2}${text}/`;
            textPath.push(text);
            const drillText = new Text({
              name: name2.replace(/\/$/, ""),
              style: Object.assign(Object.assign({
                text,
                x: x3,
                // @ts-ignore
                path: [...textPath],
                depth: index4
              }, breadCrumbStyle), { y: y3 })
            });
            textGroup.appendChild(drillText);
            x3 += drillText.getBBox().width;
            const textSeparator = new Text({
              style: Object.assign(Object.assign({ x: x3, text: " / " }, breadCrumbStyle), { y: y3 })
            });
            textGroup.appendChild(textSeparator);
            x3 += textSeparator.getBBox().width;
            if (x3 > maxWidth) {
              y3 = textGroup.getBBox().height + breadCrumbStyle.y;
              x3 = 0;
              drillText.attr({
                x: x3,
                y: y3
              });
              x3 += drillText.getBBox().width;
              textSeparator.attr({
                x: x3,
                y: y3
              });
              x3 += textSeparator.getBBox().width;
            }
            if (index4 === size(path2) - 1) {
              textSeparator.remove();
            }
            return drillText;
          });
          drillTexts.forEach((item, index4) => {
            if (index4 === size(drillTexts) - 1)
              return;
            const originalAttrs = Object.assign({}, item.attributes);
            item.attr("cursor", "pointer");
            item.addEventListener("mouseenter", () => {
              item.attr(breadCrumbActiveStyle);
            });
            item.addEventListener("mouseleave", () => {
              item.attr(originalAttrs);
            });
            item.addEventListener("click", () => {
              drillDownClick(get_default(item, ["style", "path"]), get_default(item, ["style", "depth"]));
            });
          });
        }
        legendClearSetState(container, setState);
        setState("treemapDrillDown", (viewOptions) => {
          const { marks } = viewOptions;
          const strPath = path2.join("/");
          const newMarks = marks.map((mark2) => {
            if (mark2.type !== "rect")
              return mark2;
            let newData = originData;
            if (depth) {
              const filterData = originData.filter((item) => {
                const id5 = get_default(item, ["id"]);
                return id5 && (id5.match(`${strPath}/`) || strPath.match(id5));
              }).map((item) => ({
                value: item.height === 0 ? get_default(item, ["value"]) : void 0,
                name: get_default(item, ["id"])
              }));
              const { paddingLeft, paddingBottom, paddingRight } = layout;
              const newLayout = Object.assign(Object.assign({}, layout), { paddingTop: (layout.paddingTop || textGroup.getBBox().height + 10) / (depth + 1), paddingLeft: paddingLeft / (depth + 1), paddingBottom: paddingBottom / (depth + 1), paddingRight: paddingRight / (depth + 1), path: (d3) => d3.name, layer: (d3) => d3.depth === depth + 1 });
              newData = treeDataTransform(filterData, newLayout, {
                value: "value"
              })[0];
            } else {
              newData = originData.filter((item) => {
                return item.depth === 1;
              });
            }
            const colorDomain = [];
            newData.forEach(({ path: path3 }) => {
              colorDomain.push(last(path3));
            });
            return deep_mix_default({}, mark2, {
              data: newData,
              scale: {
                color: { domain: colorDomain }
              }
            });
          });
          return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
        });
        yield update(void 0, ["legendFilter"]);
      });
      const createDrillClick = (e3) => {
        const item = e3.target;
        if (get_default(item, ["markType"]) !== "rect")
          return;
        const key = get_default(item, ["__data__", "key"]);
        const node = find_default(originData, (d3) => d3.id === key);
        if (get_default(node, "height")) {
          drillDownClick(get_default(node, "path"), get_default(node, "depth"));
        }
      };
      plotArea.addEventListener("click", createDrillClick);
      const changeStyleKey = keys_default(Object.assign(Object.assign({}, state.active), state.inactive));
      const createActive = () => {
        const elements = getElements(plotArea);
        elements.forEach((element) => {
          const cursor = get_default(element, ["style", "cursor"]);
          const node = find_default(originData, (d3) => d3.id === get_default(element, ["__data__", "key"]));
          if (cursor !== "pointer" && (node === null || node === void 0 ? void 0 : node.height)) {
            element.style.cursor = "pointer";
            const originalAttrs = pick_default(element.attributes, changeStyleKey);
            element.addEventListener("mouseenter", () => {
              element.attr(state.active);
            });
            element.addEventListener("mouseleave", () => {
              element.attr(deep_mix_default(originalAttrs, state.inactive));
            });
          }
        });
      };
      createActive();
      plotArea.addEventListener("mousemove", createActive);
      return () => {
        textGroup.remove();
        plotArea.removeEventListener("click", createDrillClick);
        plotArea.removeEventListener("mousemove", createActive);
      };
    };
  }

  // node_modules/@antv/g2/esm/interaction/elementPointMove.js
  var __awaiter11 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest87 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var DEFAULT_STYLE2 = {
    pointR: 6,
    pointStrokeWidth: 1,
    pointStroke: "#888",
    pointActiveStroke: "#f5f5f5",
    pathStroke: "#888",
    pathLineDash: [3, 4],
    labelFontSize: 12,
    labelFill: "#888",
    labelStroke: "#fff",
    labelLineWidth: 1,
    labelY: -6,
    labelX: 2
  };
  var MOVE_POINT_NAME = "movePoint";
  var elementMouseenter = (e3) => {
    const element = e3.target;
    const { markType } = element;
    if (markType === "line") {
      element.attr("_lineWidth", element.attr("lineWidth") || 1);
      element.attr("lineWidth", element.attr("_lineWidth") + 3);
    }
    if (markType === "interval") {
      element.attr("_opacity", element.attr("opacity") || 1);
      element.attr("opacity", 0.7 * element.attr("_opacity"));
    }
  };
  var elementMouseleave = (e3) => {
    const element = e3.target;
    const { markType } = element;
    if (markType === "line") {
      element.attr("lineWidth", element.attr("_lineWidth"));
    }
    if (markType === "interval") {
      element.attr("opacity", element.attr("_opacity"));
    }
  };
  var getNewData = (newChangeData, data2, encode) => {
    return data2.map((d3) => {
      const isUpdate = ["x", "color"].reduce((v, key) => {
        const field3 = encode[key];
        if (!field3)
          return v;
        if (d3[field3] !== newChangeData[field3])
          return false;
        return v;
      }, true);
      return isUpdate ? Object.assign(Object.assign({}, d3), newChangeData) : d3;
    });
  };
  var getIntervalDataRatioTransformFn = (element) => {
    const y3 = get_default(element, ["__data__", "y"]);
    const y12 = get_default(element, ["__data__", "y1"]);
    const v = y12 - y3;
    const { __data__: { data: data2, encode, transform }, childNodes } = element.parentNode;
    const isNormalizeY = find_default(transform, ({ type }) => type === "normalizeY");
    const yField = get_default(encode, ["y", "field"]);
    const value2 = data2[childNodes.indexOf(element)][yField];
    return (newValue, isTheta3 = false) => {
      if (isNormalizeY || isTheta3) {
        return newValue / (1 - newValue) / (v / (1 - v)) * value2;
      }
      return newValue;
    };
  };
  var getPathDataRatioTransformFn = (element, index4) => {
    const v = get_default(element, ["__data__", "seriesItems", index4, "0", "value"]);
    const i = get_default(element, ["__data__", "seriesIndex", index4]);
    const { __data__: { data: data2, encode, transform } } = element.parentNode;
    const isNormalizeY = find_default(transform, ({ type }) => type === "normalizeY");
    const yField = get_default(encode, ["y", "field"]);
    const value2 = data2[i][yField];
    return (newValue) => {
      if (isNormalizeY) {
        if (v === 1) {
          return newValue;
        }
        return newValue / (1 - newValue) / (v / (1 - v)) * value2;
      }
      return newValue;
    };
  };
  var selectedPointsStyle = (pointsShape, selection, defaultStyle2) => {
    pointsShape.forEach((shape23, index4) => {
      shape23.attr("stroke", selection[1] === index4 ? defaultStyle2["activeStroke"] : defaultStyle2["stroke"]);
    });
  };
  var createHelpShape = (group3, circle3, pathStyle, labelStyle) => {
    const pathShape = new Path2({
      style: pathStyle
    });
    const labelShape = new Text({
      style: labelStyle
    });
    circle3.appendChild(labelShape);
    group3.appendChild(pathShape);
    return [pathShape, labelShape];
  };
  var getColorType = (scaleColor, color2) => {
    const indexOf4 = get_default(scaleColor, ["options", "range", "indexOf"]);
    if (!indexOf4)
      return;
    const i = scaleColor.options.range.indexOf(color2);
    return scaleColor.sortedDomain[i];
  };
  var getSamePointPosition = (center2, point6, target) => {
    const oldR = getPointsR(center2, point6);
    const newR = getPointsR(center2, target);
    const ratio = newR / oldR;
    const newX = center2[0] + (point6[0] - center2[0]) * ratio;
    const newY = center2[1] + (point6[1] - center2[1]) * ratio;
    return [newX, newY];
  };
  function ElementPointMove(elementPointMoveOptions = {}) {
    const { selection = [], precision = 2 } = elementPointMoveOptions, style = __rest87(elementPointMoveOptions, ["selection", "precision"]);
    const defaultStyle2 = Object.assign(Object.assign({}, DEFAULT_STYLE2), style || {});
    const pathDefaultStyle = subObject(defaultStyle2, "path");
    const labelDefaultStyle = subObject(defaultStyle2, "label");
    const pointDefaultStyle = subObject(defaultStyle2, "point");
    return (context, _2, emitter) => {
      const { update, setState, container, view, options: { marks, coordinate: coordinateOptions } } = context;
      const plotArea = selectPlotArea(container);
      let elements = getElements(plotArea);
      let newState;
      let newSelection = selection;
      const { transform = [], type: coordinateType } = coordinateOptions;
      const isTranspose3 = !!find_default(transform, ({ type }) => type === "transpose");
      const isPolar3 = coordinateType === "polar";
      const isTheta3 = coordinateType === "theta";
      const isArea = !!find_default(elements, ({ markType }) => markType === "area");
      if (isArea) {
        elements = elements.filter(({ markType }) => markType === "area");
      }
      const pointsGroup = new Group2({
        style: {
          // Tooltip point need down.
          zIndex: 2
        }
      });
      plotArea.appendChild(pointsGroup);
      const selectedChange = () => {
        emitter.emit("element-point:select", {
          nativeEvent: true,
          data: {
            selection: newSelection
          }
        });
      };
      const dataChange = (changeData, data2) => {
        emitter.emit("element-point:moved", {
          nativeEvent: true,
          data: {
            changeData,
            data: data2
          }
        });
      };
      const elementClick = (e3) => {
        const element = e3.target;
        newSelection = [element.parentNode.childNodes.indexOf(element)];
        selectedChange();
        createPoints(element);
      };
      const elementSelect2 = (d3) => {
        const { data: { selection: selection2 }, nativeEvent } = d3;
        if (nativeEvent)
          return;
        newSelection = selection2;
        const element = get_default(elements, [newSelection === null || newSelection === void 0 ? void 0 : newSelection[0]]);
        if (element) {
          createPoints(element);
        }
      };
      const createPoints = (element) => {
        const { attributes, markType, __data__: data2 } = element;
        const { stroke: fill } = attributes;
        const { points, seriesTitle, color: color2, title, seriesX, y1: y12 } = data2;
        if (isTranspose3 && markType !== "interval")
          return;
        const { scale: scale10, coordinate } = (newState === null || newState === void 0 ? void 0 : newState.view) || view;
        const { color: scaleColor, y: scaleY2, x: scaleX2 } = scale10;
        const center2 = coordinate.getCenter();
        pointsGroup.removeChildren();
        let downPoint;
        const updateView = (x3, y3, color3, markTypes) => __awaiter11(this, void 0, void 0, function* () {
          setState("elementPointMove", (viewOptions) => {
            var _a;
            const newMarks = (((_a = newState === null || newState === void 0 ? void 0 : newState.options) === null || _a === void 0 ? void 0 : _a.marks) || marks).map((mark) => {
              if (!markTypes.includes(mark.type))
                return mark;
              const { data: data3, encode } = mark;
              const encodeKeys = Object.keys(encode);
              const newChangeData = encodeKeys.reduce((value2, key) => {
                const dataKey = encode[key];
                if (key === "x") {
                  value2[dataKey] = x3;
                }
                if (key === "y") {
                  value2[dataKey] = y3;
                }
                if (key === "color") {
                  value2[dataKey] = color3;
                }
                return value2;
              }, {});
              const newData = getNewData(newChangeData, data3, encode);
              dataChange(newChangeData, newData);
              return deep_mix_default({}, mark, {
                data: newData,
                // No need animate
                animate: false
              });
            });
            return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
          });
          return yield update("elementPointMove");
        });
        if (["line", "area"].includes(markType)) {
          points.forEach((p2, index4) => {
            const title2 = scaleX2.invert(seriesX[index4]);
            if (!title2)
              return;
            const circle3 = new Circle({
              name: MOVE_POINT_NAME,
              style: Object.assign({ cx: p2[0], cy: p2[1], fill }, pointDefaultStyle)
            });
            const ratioTransform = getPathDataRatioTransformFn(element, index4);
            circle3.addEventListener("mousedown", (e3) => {
              const oldPoint = coordinate.output([seriesX[index4], 0]);
              const pathLength = seriesTitle === null || seriesTitle === void 0 ? void 0 : seriesTitle.length;
              container.attr("cursor", "move");
              if (newSelection[1] !== index4) {
                newSelection[1] = index4;
                selectedChange();
              }
              selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
              const [pathShape, labelShape] = createHelpShape(pointsGroup, circle3, pathDefaultStyle, labelDefaultStyle);
              const pointMousemove = (e4) => {
                const newCy = p2[1] + e4.clientY - downPoint[1];
                if (isArea) {
                  if (isPolar3) {
                    const newCx = p2[0] + e4.clientX - downPoint[0];
                    const [newX, newY] = getSamePointPosition(center2, oldPoint, [
                      newCx,
                      newCy
                    ]);
                    const [, initY] = coordinate.output([1, scaleY2.output(0)]);
                    const [, y3] = coordinate.invert([
                      newX,
                      initY - (points[index4 + pathLength][1] - newY)
                    ]);
                    const nextIndex = (index4 + 1) % pathLength;
                    const lastIndex = (index4 - 1 + pathLength) % pathLength;
                    const newPath = getPointsPath([
                      points[lastIndex],
                      [newX, newY],
                      seriesTitle[nextIndex] && points[nextIndex]
                    ]);
                    labelShape.attr("text", ratioTransform(scaleY2.invert(y3)).toFixed(precision));
                    pathShape.attr("d", newPath);
                    circle3.attr("cx", newX);
                    circle3.attr("cy", newY);
                  } else {
                    const [, initY] = coordinate.output([1, scaleY2.output(0)]);
                    const [, y3] = coordinate.invert([
                      p2[0],
                      initY - (points[index4 + pathLength][1] - newCy)
                    ]);
                    const newPath = getPointsPath([
                      points[index4 - 1],
                      [p2[0], newCy],
                      seriesTitle[index4 + 1] && points[index4 + 1]
                    ]);
                    labelShape.attr("text", ratioTransform(scaleY2.invert(y3)).toFixed(precision));
                    pathShape.attr("d", newPath);
                    circle3.attr("cy", newCy);
                  }
                } else {
                  const [, y3] = coordinate.invert([p2[0], newCy]);
                  const newPath = getPointsPath([
                    points[index4 - 1],
                    [p2[0], newCy],
                    points[index4 + 1]
                  ]);
                  labelShape.attr("text", scaleY2.invert(y3).toFixed(precision));
                  pathShape.attr("d", newPath);
                  circle3.attr("cy", newCy);
                }
              };
              downPoint = [e3.clientX, e3.clientY];
              window.addEventListener("mousemove", pointMousemove);
              const mouseupFn = () => __awaiter11(this, void 0, void 0, function* () {
                container.attr("cursor", "default");
                window.removeEventListener("mousemove", pointMousemove);
                container.removeEventListener("mouseup", mouseupFn);
                if (is_undefined_default(labelShape.attr("text")))
                  return;
                const y3 = Number(labelShape.attr("text"));
                const colorType = getColorType(scaleColor, color2);
                newState = yield updateView(title2, y3, colorType, [
                  "line",
                  "area"
                ]);
                labelShape.remove();
                pathShape.remove();
                createPoints(element);
              });
              container.addEventListener("mouseup", mouseupFn);
            });
            pointsGroup.appendChild(circle3);
          });
          selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
        } else if (markType === "interval") {
          let circlePoint = [(points[0][0] + points[1][0]) / 2, points[0][1]];
          if (isTranspose3) {
            circlePoint = [points[0][0], (points[0][1] + points[1][1]) / 2];
          } else if (isTheta3) {
            circlePoint = points[0];
          }
          const ratioTransform = getIntervalDataRatioTransformFn(element);
          const circle3 = new Circle({
            name: MOVE_POINT_NAME,
            style: Object.assign(Object.assign({ cx: circlePoint[0], cy: circlePoint[1], fill }, pointDefaultStyle), { stroke: pointDefaultStyle["activeStroke"] })
          });
          circle3.addEventListener("mousedown", (e3) => {
            container.attr("cursor", "move");
            const colorType = getColorType(scaleColor, color2);
            const [pathShape, labelShape] = createHelpShape(pointsGroup, circle3, pathDefaultStyle, labelDefaultStyle);
            const pointMousemove = (e4) => {
              if (isTranspose3) {
                const newCx = circlePoint[0] + e4.clientX - downPoint[0];
                const [initX] = coordinate.output([
                  scaleY2.output(0),
                  scaleY2.output(0)
                ]);
                const [, x3] = coordinate.invert([
                  initX + (newCx - points[2][0]),
                  circlePoint[1]
                ]);
                const newPath = getPointsPath([
                  [newCx, points[0][1]],
                  [newCx, points[1][1]],
                  points[2],
                  points[3]
                ], true);
                labelShape.attr("text", ratioTransform(scaleY2.invert(x3)).toFixed(precision));
                pathShape.attr("d", newPath);
                circle3.attr("cx", newCx);
              } else if (isTheta3) {
                const newCy = circlePoint[1] + e4.clientY - downPoint[1];
                const newCx = circlePoint[0] + e4.clientX - downPoint[0];
                const [newXOut, newYOut] = getSamePointPosition(center2, [newCx, newCy], circlePoint);
                const [newXIn, newYIn] = getSamePointPosition(center2, [newCx, newCy], points[1]);
                const lastPercent = coordinate.invert([newXOut, newYOut])[1];
                const percent2 = y12 - lastPercent;
                if (percent2 < 0)
                  return;
                const newPath = getThetaPath(center2, [[newXOut, newYOut], [newXIn, newYIn], points[2], points[3]], percent2 > 0.5 ? 1 : 0);
                labelShape.attr("text", ratioTransform(percent2, true).toFixed(precision));
                pathShape.attr("d", newPath);
                circle3.attr("cx", newXOut);
                circle3.attr("cy", newYOut);
              } else {
                const newCy = circlePoint[1] + e4.clientY - downPoint[1];
                const [, initY] = coordinate.output([1, scaleY2.output(0)]);
                const [, y3] = coordinate.invert([
                  circlePoint[0],
                  initY - (points[2][1] - newCy)
                ]);
                const newPath = getPointsPath([
                  [points[0][0], newCy],
                  [points[1][0], newCy],
                  points[2],
                  points[3]
                ], true);
                labelShape.attr("text", ratioTransform(scaleY2.invert(y3)).toFixed(precision));
                pathShape.attr("d", newPath);
                circle3.attr("cy", newCy);
              }
            };
            downPoint = [e3.clientX, e3.clientY];
            window.addEventListener("mousemove", pointMousemove);
            const mouseupFn = () => __awaiter11(this, void 0, void 0, function* () {
              container.attr("cursor", "default");
              container.removeEventListener("mouseup", mouseupFn);
              window.removeEventListener("mousemove", pointMousemove);
              if (is_undefined_default(labelShape.attr("text")))
                return;
              const y3 = Number(labelShape.attr("text"));
              newState = yield updateView(title, y3, colorType, [markType]);
              labelShape.remove();
              pathShape.remove();
              createPoints(element);
            });
            container.addEventListener("mouseup", mouseupFn);
          });
          pointsGroup.appendChild(circle3);
        }
      };
      elements.forEach((element, index4) => {
        if (newSelection[0] === index4) {
          createPoints(element);
        }
        element.addEventListener("click", elementClick);
        element.addEventListener("mouseenter", elementMouseenter);
        element.addEventListener("mouseleave", elementMouseleave);
      });
      const rootClick = (e3) => {
        const element = e3 === null || e3 === void 0 ? void 0 : e3.target;
        if (!element || element.name !== MOVE_POINT_NAME && !elements.includes(element)) {
          newSelection = [];
          selectedChange();
          pointsGroup.removeChildren();
        }
      };
      emitter.on("element-point:select", elementSelect2);
      emitter.on("element-point:unselect", rootClick);
      container.addEventListener("mousedown", rootClick);
      return () => {
        pointsGroup.remove();
        emitter.off("element-point:select", elementSelect2);
        emitter.off("element-point:unselect", rootClick);
        container.removeEventListener("mousedown", rootClick);
        elements.forEach((element) => {
          element.removeEventListener("click", elementClick);
          element.removeEventListener("mouseenter", elementMouseenter);
          element.removeEventListener("mouseleave", elementMouseleave);
        });
      };
    };
  }

  // node_modules/d3-dsv/src/dsv.js
  var EOL = {};
  var EOF = {};
  var QUOTE = 34;
  var NEWLINE = 10;
  var RETURN = 13;
  function objectConverter(columns) {
    return new Function("d", "return {" + columns.map(function(name2, i) {
      return JSON.stringify(name2) + ": d[" + i + '] || ""';
    }).join(",") + "}");
  }
  function customConverter(columns, f) {
    var object = objectConverter(columns);
    return function(row2, i) {
      return f(object(row2), i, columns);
    };
  }
  function inferColumns(rows) {
    var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
    rows.forEach(function(row2) {
      for (var column2 in row2) {
        if (!(column2 in columnSet)) {
          columns.push(columnSet[column2] = column2);
        }
      }
    });
    return columns;
  }
  function pad2(value2, width) {
    var s3 = value2 + "", length5 = s3.length;
    return length5 < width ? new Array(width - length5 + 1).join(0) + s3 : s3;
  }
  function formatYear(year2) {
    return year2 < 0 ? "-" + pad2(-year2, 6) : year2 > 9999 ? "+" + pad2(year2, 6) : pad2(year2, 4);
  }
  function formatDate(date) {
    var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
    return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad2(date.getUTCMonth() + 1, 2) + "-" + pad2(date.getUTCDate(), 2) + (milliseconds ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + ":" + pad2(seconds, 2) + "." + pad2(milliseconds, 3) + "Z" : seconds ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + ":" + pad2(seconds, 2) + "Z" : minutes || hours ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + "Z" : "");
  }
  function dsv_default(delimiter) {
    var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
    function parse2(text, f) {
      var convert, columns, rows = parseRows(text, function(row2, i) {
        if (convert) return convert(row2, i - 1);
        columns = row2, convert = f ? customConverter(row2, f) : objectConverter(row2);
      });
      rows.columns = columns || [];
      return rows;
    }
    function parseRows(text, f) {
      var rows = [], N = text.length, I = 0, n2 = 0, t, eof = N <= 0, eol = false;
      if (text.charCodeAt(N - 1) === NEWLINE) --N;
      if (text.charCodeAt(N - 1) === RETURN) --N;
      function token2() {
        if (eof) return EOF;
        if (eol) return eol = false, EOL;
        var i, j = I, c5;
        if (text.charCodeAt(j) === QUOTE) {
          while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE) ;
          if ((i = I) >= N) eof = true;
          else if ((c5 = text.charCodeAt(I++)) === NEWLINE) eol = true;
          else if (c5 === RETURN) {
            eol = true;
            if (text.charCodeAt(I) === NEWLINE) ++I;
          }
          return text.slice(j + 1, i - 1).replace(/""/g, '"');
        }
        while (I < N) {
          if ((c5 = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
          else if (c5 === RETURN) {
            eol = true;
            if (text.charCodeAt(I) === NEWLINE) ++I;
          } else if (c5 !== DELIMITER) continue;
          return text.slice(j, i);
        }
        return eof = true, text.slice(j, N);
      }
      while ((t = token2()) !== EOF) {
        var row2 = [];
        while (t !== EOL && t !== EOF) row2.push(t), t = token2();
        if (f && (row2 = f(row2, n2++)) == null) continue;
        rows.push(row2);
      }
      return rows;
    }
    function preformatBody(rows, columns) {
      return rows.map(function(row2) {
        return columns.map(function(column2) {
          return formatValue(row2[column2]);
        }).join(delimiter);
      });
    }
    function format3(rows, columns) {
      if (columns == null) columns = inferColumns(rows);
      return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
    }
    function formatBody(rows, columns) {
      if (columns == null) columns = inferColumns(rows);
      return preformatBody(rows, columns).join("\n");
    }
    function formatRows(rows) {
      return rows.map(formatRow).join("\n");
    }
    function formatRow(row2) {
      return row2.map(formatValue).join(delimiter);
    }
    function formatValue(value2) {
      return value2 == null ? "" : value2 instanceof Date ? formatDate(value2) : reFormat.test(value2 += "") ? '"' + value2.replace(/"/g, '""') + '"' : value2;
    }
    return {
      parse: parse2,
      parseRows,
      format: format3,
      formatBody,
      formatRows,
      formatRow,
      formatValue
    };
  }

  // node_modules/d3-dsv/src/autoType.js
  function autoType(object) {
    for (var key in object) {
      var value2 = object[key].trim(), number3, m3;
      if (!value2) value2 = null;
      else if (value2 === "true") value2 = true;
      else if (value2 === "false") value2 = false;
      else if (value2 === "NaN") value2 = NaN;
      else if (!isNaN(number3 = +value2)) value2 = number3;
      else if (m3 = value2.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
        if (fixtz && !!m3[4] && !m3[7]) value2 = value2.replace(/-/g, "/").replace(/T/, " ");
        value2 = new Date(value2);
      } else continue;
      object[key] = value2;
    }
    return object;
  }
  var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

  // node_modules/@antv/g2/esm/data/fetch.js
  var __awaiter12 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Fetch = (options) => {
    const { value: value2, format: format3 = value2.split(".").pop(), delimiter = ",", autoType: autoType2 = true } = options;
    return () => __awaiter12(void 0, void 0, void 0, function* () {
      const response = yield fetch(value2);
      if (format3 === "csv") {
        const str7 = yield response.text();
        return dsv_default(delimiter).parse(str7, autoType2 ? autoType : identity5);
      } else if (format3 === "json") {
        return yield response.json();
      }
      throw new Error(`Unknown format: ${format3}.`);
    });
  };
  Fetch.props = {};

  // node_modules/@antv/g2/esm/data/fold.js
  function isEmpty(obj) {
    return !obj || Object.keys(obj).length === 0;
  }
  var Fold = (options) => {
    const { fields, key = "key", value: value2 = "value" } = options;
    return (data2) => {
      if (isEmpty(fields))
        return data2;
      return data2.flatMap((d3) => fields.map((f) => Object.assign(Object.assign({}, d3), { [key]: f, [value2]: d3[f] })));
    };
  };
  Fold.props = {};

  // node_modules/@antv/g2/esm/data/filter.js
  function defined3(d3) {
    return d3 !== void 0 && d3 !== null && !Number.isNaN(d3);
  }
  var Filter2 = (options) => {
    const { callback = defined3 } = options;
    return (data2) => data2.filter(callback);
  };
  Filter2.props = {};

  // node_modules/@antv/g2/esm/data/sort.js
  var Sort2 = (options) => {
    const { callback } = options;
    return (data2) => Array.isArray(data2) ? [...data2].sort(callback) : data2;
  };
  Sort2.props = {};

  // node_modules/@antv/g2/esm/data/pick.js
  function pick2(v, fields = []) {
    return fields.reduce((datum, field3) => {
      if (field3 in v) {
        datum[field3] = v[field3];
      }
      return datum;
    }, {});
  }
  var Pick = (options) => {
    const { fields } = options;
    return (data2) => data2.map((d3) => pick2(d3, fields));
  };
  Pick.props = {};

  // node_modules/@antv/g2/esm/data/rename.js
  function isEmpty2(obj) {
    return Object.keys(obj).length === 0;
  }
  var Rename = (options) => {
    return (data2) => {
      if (!options || isEmpty2(options))
        return data2;
      const rename = (v) => Object.entries(v).reduce((datum, [key, value2]) => (datum[options[key] || key] = value2, datum), {});
      return data2.map(rename);
    };
  };
  Rename.props = {};

  // node_modules/@antv/g2/esm/data/utils/fields.js
  function normalizeFields(fields, defaultValue) {
    return fields.map((d3) => {
      if (Array.isArray(d3)) {
        const [field3, value2 = defaultValue] = d3;
        return [field3, value2];
      }
      return [d3, defaultValue];
    });
  }

  // node_modules/@antv/g2/esm/data/sortBy.js
  var SortBy = (options) => {
    const { fields: F = [] } = options;
    const normalizedF = normalizeFields(F, true);
    return (data2) => {
      const comparator = (a3, b) => normalizedF.reduce((ret, [field3, order = true]) => {
        if (ret !== 0) {
          return ret;
        }
        if (order) {
          return a3[field3] < b[field3] ? -1 : +(a3[field3] !== b[field3]);
        } else {
          return a3[field3] > b[field3] ? -1 : +(a3[field3] !== b[field3]);
        }
      }, 0);
      return [...data2].sort(comparator);
    };
  };
  SortBy.props = {};

  // node_modules/@antv/g2/esm/data/inline.js
  var Inline = (options) => {
    const { value: value2 } = options;
    return () => value2;
  };
  Inline.props = {};

  // node_modules/@antv/g2/esm/data/custom.js
  var Custom = (options) => {
    const { callback = identity5 } = options;
    return (data2) => callback(data2);
  };
  Custom.props = {};

  // node_modules/@antv/g2/esm/data/map.js
  var Map2 = (options) => {
    const { callback = identity5 } = options;
    return (data2) => Array.isArray(data2) ? data2.map(callback) : data2;
  };
  Map2.props = {};

  // node_modules/@antv/g2/esm/data/utils/flow.js
  var __awaiter13 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function flow2(target, source) {
    return {
      set(key, normalize9, callback) {
        if (source[key] === void 0)
          return this;
        const value2 = normalize9 ? normalize9.call(null, source[key]) : source[key];
        if (callback)
          callback.call(null, value2);
        else if (typeof target[key] === "function")
          target[key](value2);
        else
          target[key] = value2;
        return this;
      },
      setAsync(key, normalize9, callback) {
        return __awaiter13(this, void 0, void 0, function* () {
          if (source[key] === void 0)
            return this;
          const value2 = normalize9 ? yield normalize9.call(null, source[key]) : source[key];
          if (callback)
            callback.call(null, value2);
          else if (typeof target[key] === "function")
            target[key](value2);
          else
            target[key] = value2;
          return this;
        });
      }
    };
  }

  // node_modules/@antv/g2/esm/data/utils/d3-cloud/index.js
  var cloudRadians = Math.PI / 180;
  var cw = 1 << 11 >> 5;
  var ch = 1 << 11;
  function cloudText(d3) {
    return d3.text;
  }
  function cloudFont() {
    return "serif";
  }
  function cloudFontNormal() {
    return "normal";
  }
  function cloudFontSize(d3) {
    return d3.value;
  }
  function cloudRotate() {
    return ~~(Math.random() * 2) * 90;
  }
  function cloudPadding() {
    return 1;
  }
  function cloudDispatch() {
    return;
  }
  function cloudSprite(contextAndRatio, d3, data2, di) {
    if (d3.sprite)
      return;
    const c5 = contextAndRatio.context, ratio = contextAndRatio.ratio;
    c5.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
    let x3 = 0, y3 = 0, maxh = 0;
    const n2 = data2.length;
    --di;
    while (++di < n2) {
      d3 = data2[di];
      c5.save();
      c5.font = d3.style + " " + d3.weight + " " + ~~((d3.size + 1) / ratio) + "px " + d3.font;
      let w = c5.measureText(d3.text + "m").width * ratio, h = d3.size << 1;
      if (d3.rotate) {
        const sr = Math.sin(d3.rotate * cloudRadians), cr = Math.cos(d3.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
        w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
        h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
      } else {
        w = w + 31 >> 5 << 5;
      }
      if (h > maxh)
        maxh = h;
      if (x3 + w >= cw << 5) {
        x3 = 0;
        y3 += maxh;
        maxh = 0;
      }
      if (y3 + h >= ch)
        break;
      c5.translate((x3 + (w >> 1)) / ratio, (y3 + (h >> 1)) / ratio);
      if (d3.rotate)
        c5.rotate(d3.rotate * cloudRadians);
      c5.fillText(d3.text, 0, 0);
      if (d3.padding) {
        c5.lineWidth = 2 * d3.padding;
        c5.strokeText(d3.text, 0, 0);
      }
      c5.restore();
      d3.width = w;
      d3.height = h;
      d3.xoff = x3;
      d3.yoff = y3;
      d3.x1 = w >> 1;
      d3.y1 = h >> 1;
      d3.x0 = -d3.x1;
      d3.y0 = -d3.y1;
      d3.hasText = true;
      x3 += w;
    }
    const pixels = c5.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
    while (--di >= 0) {
      d3 = data2[di];
      if (!d3.hasText)
        continue;
      const w = d3.width, w32 = w >> 5;
      let h = d3.y1 - d3.y0;
      for (let i = 0; i < h * w32; i++)
        sprite[i] = 0;
      x3 = d3.xoff;
      if (x3 == null)
        return;
      y3 = d3.yoff;
      let seen = 0, seenRow = -1;
      for (let j = 0; j < h; j++) {
        for (let i = 0; i < w; i++) {
          const k = w32 * j + (i >> 5), m3 = pixels[(y3 + j) * (cw << 5) + (x3 + i) << 2] ? 1 << 31 - i % 32 : 0;
          sprite[k] |= m3;
          seen |= m3;
        }
        if (seen)
          seenRow = j;
        else {
          d3.y0++;
          h--;
          j--;
          y3++;
        }
      }
      d3.y1 = d3.y0 + seenRow;
      d3.sprite = sprite.slice(0, (d3.y1 - d3.y0) * w32);
    }
  }
  function cloudCollide(tag, board, sw) {
    sw >>= 5;
    const sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
    let x3 = (tag.y + tag.y0) * sw + (lx >> 5), last4;
    for (let j = 0; j < h; j++) {
      last4 = 0;
      for (let i = 0; i <= w; i++) {
        if ((last4 << msx | (i < w ? (last4 = sprite[j * w + i]) >>> sx : 0)) & board[x3 + i])
          return true;
      }
      x3 += sw;
    }
    return false;
  }
  function cloudBounds(bounds, d3) {
    const b0 = bounds[0], b1 = bounds[1];
    if (d3.x + d3.x0 < b0.x)
      b0.x = d3.x + d3.x0;
    if (d3.y + d3.y0 < b0.y)
      b0.y = d3.y + d3.y0;
    if (d3.x + d3.x1 > b1.x)
      b1.x = d3.x + d3.x1;
    if (d3.y + d3.y1 > b1.y)
      b1.y = d3.y + d3.y1;
  }
  function collideRects(a3, b) {
    return a3.x + a3.x1 > b[0].x && a3.x + a3.x0 < b[1].x && a3.y + a3.y1 > b[0].y && a3.y + a3.y0 < b[1].y;
  }
  function archimedeanSpiral(size2) {
    const e3 = size2[0] / size2[1];
    return function(t) {
      return [e3 * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
    };
  }
  function rectangularSpiral(size2) {
    const dy = 4, dx = dy * size2[0] / size2[1];
    let x3 = 0, y3 = 0;
    return function(t) {
      const sign3 = t < 0 ? -1 : 1;
      switch (Math.sqrt(1 + 4 * sign3 * t) - sign3 & 3) {
        case 0:
          x3 += dx;
          break;
        case 1:
          y3 += dy;
          break;
        case 2:
          x3 -= dx;
          break;
        default:
          y3 -= dy;
          break;
      }
      return [x3, y3];
    };
  }
  function zeroArray(n2) {
    const a3 = [];
    let i = -1;
    while (++i < n2)
      a3[i] = 0;
    return a3;
  }
  function cloudCanvas() {
    return document.createElement("canvas");
  }
  function functor(d3) {
    return typeof d3 === "function" ? d3 : function() {
      return d3;
    };
  }
  var spirals = {
    archimedean: archimedeanSpiral,
    rectangular: rectangularSpiral
  };
  function tagCloud() {
    let size2 = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate5 = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, random5 = Math.random, event = cloudDispatch, words = [], timer2 = null, timeInterval = Infinity, canvas = cloudCanvas;
    const fontStyle = cloudFontNormal;
    const cloud = {};
    cloud.start = function() {
      const [width, height] = size2;
      const contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size2[0] >> 5) * size2[1]), n2 = words.length, tags = [], data2 = words.map(function(d3, i2, data3) {
        d3.text = text.call(this, d3, i2, data3);
        d3.font = font.call(this, d3, i2, data3);
        d3.style = fontStyle.call(this, d3, i2, data3);
        d3.weight = fontWeight.call(this, d3, i2, data3);
        d3.rotate = rotate5.call(this, d3, i2, data3);
        d3.size = ~~fontSize.call(this, d3, i2, data3);
        d3.padding = padding.call(this, d3, i2, data3);
        return d3;
      }).sort(function(a3, b) {
        return b.size - a3.size;
      });
      let i = -1, bounds = !cloud.board ? void 0 : [
        {
          x: 0,
          y: 0
        },
        {
          x: width,
          y: height
        }
      ];
      if (timer2)
        clearInterval(timer2);
      timer2 = setInterval(step2, 0);
      step2();
      function step2() {
        const start2 = Date.now();
        while (Date.now() - start2 < timeInterval && ++i < n2) {
          const d3 = data2[i];
          d3.x = width * (random5() + 0.5) >> 1;
          d3.y = height * (random5() + 0.5) >> 1;
          cloudSprite(contextAndRatio, d3, data2, i);
          if (d3.hasText && place2(board, d3, bounds)) {
            event.call(null, "word", { cloud, word: d3 });
            tags.push(d3);
            if (bounds) {
              if (!cloud.hasImage) {
                cloudBounds(bounds, d3);
              }
            } else {
              bounds = [
                { x: d3.x + d3.x0, y: d3.y + d3.y0 },
                { x: d3.x + d3.x1, y: d3.y + d3.y1 }
              ];
            }
            d3.x -= size2[0] >> 1;
            d3.y -= size2[1] >> 1;
          }
        }
        cloud._tags = tags;
        cloud._bounds = bounds;
        if (i >= n2) {
          cloud.stop();
          event.call(null, "end", { cloud, words: tags, bounds });
        }
      }
      return cloud;
    };
    cloud.stop = function() {
      if (timer2) {
        clearInterval(timer2);
        timer2 = null;
      }
      return cloud;
    };
    function getContext(canvas2) {
      canvas2.width = canvas2.height = 1;
      const ratio = Math.sqrt(canvas2.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
      canvas2.width = (cw << 5) / ratio;
      canvas2.height = ch / ratio;
      const context = canvas2.getContext("2d");
      context.fillStyle = context.strokeStyle = "red";
      context.textAlign = "center";
      context.textBaseline = "middle";
      return { context, ratio };
    }
    function place2(board, tag, bounds) {
      const startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size2[0] * size2[0] + size2[1] * size2[1]), s3 = spiral(size2), dt = random5() < 0.5 ? 1 : -1;
      let dxdy, t = -dt, dx, dy;
      while (dxdy = s3(t += dt)) {
        dx = ~~dxdy[0];
        dy = ~~dxdy[1];
        if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
          break;
        tag.x = startX + dx;
        tag.y = startY + dy;
        if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size2[0] || tag.y + tag.y1 > size2[1])
          continue;
        if (!bounds || !cloudCollide(tag, board, size2[0])) {
          if (!bounds || collideRects(tag, bounds)) {
            const sprite = tag.sprite, w = tag.width >> 5, sw = size2[0] >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
            let last4, x3 = (tag.y + tag.y0) * sw + (lx >> 5);
            for (let j = 0; j < h; j++) {
              last4 = 0;
              for (let i = 0; i <= w; i++) {
                board[x3 + i] |= last4 << msx | (i < w ? (last4 = sprite[j * w + i]) >>> sx : 0);
              }
              x3 += sw;
            }
            delete tag.sprite;
            return true;
          }
        }
      }
      return false;
    }
    cloud.createMask = (img) => {
      const can = document.createElement("canvas");
      const [width, height] = size2;
      if (!width || !height) {
        return;
      }
      const w32 = width >> 5;
      const board = zeroArray((width >> 5) * height);
      can.width = width;
      can.height = height;
      const cxt = can.getContext("2d");
      cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
      const imageData = cxt.getImageData(0, 0, width, height).data;
      for (let j = 0; j < height; j++) {
        for (let i = 0; i < width; i++) {
          const k = w32 * j + (i >> 5);
          const tmp2 = j * width + i << 2;
          const flag = imageData[tmp2] >= 250 && imageData[tmp2 + 1] >= 250 && imageData[tmp2 + 2] >= 250;
          const m3 = flag ? 1 << 31 - i % 32 : 0;
          board[k] |= m3;
        }
      }
      cloud.board = board;
      cloud.hasImage = true;
    };
    cloud.timeInterval = function(_2) {
      timeInterval = _2 == null ? Infinity : _2;
    };
    cloud.words = function(_2) {
      words = _2;
    };
    cloud.size = function(_2 = []) {
      size2 = [+_2[0], +_2[1]];
    };
    cloud.text = function(_2) {
      text = functor(_2);
    };
    cloud.font = function(_2) {
      font = functor(_2);
    };
    cloud.fontWeight = function(_2) {
      fontWeight = functor(_2);
    };
    cloud.rotate = function(_2) {
      rotate5 = functor(_2);
    };
    cloud.canvas = function(_2) {
      canvas = functor(_2);
    };
    cloud.spiral = function(_2) {
      spiral = spirals[_2] || _2;
    };
    cloud.fontSize = function(_2) {
      fontSize = functor(_2);
    };
    cloud.padding = function(_2) {
      padding = functor(_2);
    };
    cloud.random = function(_2) {
      random5 = functor(_2);
    };
    cloud.on = function(_2) {
      event = functor(_2);
    };
    return cloud;
  }

  // node_modules/@antv/g2/esm/data/wordCloud.js
  var __awaiter14 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest88 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var DEFAULT_OPTIONS5 = {
    fontSize: [20, 60],
    font: "Impact",
    padding: 2,
    rotate: function() {
      return (~~(Math.random() * 6) - 3) * 30;
    }
  };
  function processImageMask(img) {
    return new Promise((res, rej) => {
      if (img instanceof HTMLImageElement) {
        res(img);
        return;
      }
      if (typeof img === "string") {
        const image = new Image();
        image.crossOrigin = "anonymous";
        image.src = img;
        image.onload = () => res(image);
        image.onerror = () => {
          console.error(`'image ${img} load failed !!!'`);
          rej();
        };
        return;
      }
      rej();
    });
  }
  function normalizeFontSize(fontSize, range3) {
    if (typeof fontSize === "function")
      return fontSize;
    if (Array.isArray(fontSize)) {
      const [fMin, fMax] = fontSize;
      if (!range3)
        return () => (fMax + fMin) / 2;
      const [min10, max11] = range3;
      if (max11 === min10)
        return () => (fMax + fMin) / 2;
      return ({ value: value2 }) => (fMax - fMin) / (max11 - min10) * (value2 - min10) + fMin;
    }
    return () => fontSize;
  }
  var WordCloud2 = (options, context) => {
    return (data2) => __awaiter14(void 0, void 0, void 0, function* () {
      const cloudOptions = Object.assign({}, DEFAULT_OPTIONS5, options, {
        canvas: context.createCanvas
      });
      const layout = tagCloud();
      yield flow2(layout, cloudOptions).set("fontSize", (v) => {
        const arr = data2.map((d3) => d3.value);
        return normalizeFontSize(v, [min4(arr), max5(arr)]);
      }).set("font").set("fontStyle").set("fontWeight").set("padding").set("rotate").set("size").set("spiral").set("timeInterval").set("random").set("text").set("on").set("canvas").setAsync("imageMask", processImageMask, layout.createMask);
      layout.words([...data2]);
      const result = layout.start();
      const [cw2, ch2] = cloudOptions.size;
      const defaultBounds = [
        { x: 0, y: 0 },
        { x: cw2, y: ch2 }
      ];
      const { _bounds: bounds = defaultBounds, _tags, hasImage } = result;
      const tags = _tags.map((_a) => {
        var { x: x3, y: y3, font } = _a, rest = __rest88(_a, ["x", "y", "font"]);
        return Object.assign(Object.assign({}, rest), { x: x3 + cw2 / 2, y: y3 + ch2 / 2, fontFamily: font });
      });
      const [{ x: tlx, y: tly }, { x: brx, y: bry }] = bounds;
      const invisibleText = { text: "", value: 0, opacity: 0, fontSize: 0 };
      tags.push(Object.assign(Object.assign({}, invisibleText), { x: hasImage ? 0 : tlx, y: hasImage ? 0 : tly }), Object.assign(Object.assign({}, invisibleText), { x: hasImage ? cw2 : brx, y: hasImage ? ch2 : bry }));
      return tags;
    });
  };
  WordCloud2.props = {};

  // node_modules/@antv/g2/esm/data/join.js
  function field2(key) {
    return typeof key === "string" ? (d3) => d3[key] : key;
  }
  var Join = (options) => {
    const { join, on: on2, select: select3 = [], as = select3, unknown = NaN } = options;
    const [key, fromKey] = on2;
    const fk = field2(fromKey);
    const k = field2(key);
    const keyData = rollup(
      join,
      ([d3]) => d3,
      // Get the first matched.
      (d3) => fk(d3)
    );
    return (data2) => data2.map((d3) => {
      const source = keyData.get(k(d3));
      return Object.assign(Object.assign({}, d3), select3.reduce((prev, key2, idx) => (prev[as[idx]] = source ? source[key2] : unknown, prev), {}));
    });
  };
  Join.props = {};

  // node_modules/@antv/g2/esm/data/slice.js
  var Slice = (options) => {
    const { start: start2, end } = options;
    return (data2) => data2.slice(start2, end);
  };
  Slice.props = {};

  // node_modules/@antv/g2/esm/data/kde.js
  var import_pdfast = __toESM(require_src());
  var KDE = (options) => {
    const { field: field3, groupBy: groupBy2, as = ["y", "size"], min: min10, max: max11, size: size2 = 10, width } = options;
    const [yField, sizeField] = as;
    return (data2) => {
      const gs = Array.from(group(data2, (d3) => groupBy2.map((gb) => d3[gb]).join("-")).values());
      return gs.map((g) => {
        const pdfResult = import_pdfast.default.create(g.map((i) => i[field3]), {
          min: min10,
          max: max11,
          size: size2,
          width
        });
        const _y = pdfResult.map((result) => result.x);
        const _size = pdfResult.map((result) => result.y);
        return Object.assign(Object.assign({}, g[0]), { [yField]: _y, [sizeField]: _size });
      });
    };
  };
  KDE.props = {};

  // node_modules/@antv/g2/esm/data/utils/venn/layout.js
  var import_fmin = __toESM(require_fmin());

  // node_modules/@antv/g2/esm/data/utils/venn/circleintersection.js
  var SMALL = 1e-10;
  function intersectionArea(circles, stats) {
    const intersectionPoints = getIntersectionPoints(circles);
    const innerPoints = intersectionPoints.filter(function(p2) {
      return containedInCircles(p2, circles);
    });
    let arcArea = 0, polygonArea = 0, i;
    const arcs = [];
    if (innerPoints.length > 1) {
      const center2 = getCenter(innerPoints);
      for (i = 0; i < innerPoints.length; ++i) {
        const p3 = innerPoints[i];
        p3.angle = Math.atan2(p3.x - center2.x, p3.y - center2.y);
      }
      innerPoints.sort(function(a3, b) {
        return b.angle - a3.angle;
      });
      let p2 = innerPoints[innerPoints.length - 1];
      for (i = 0; i < innerPoints.length; ++i) {
        const p1 = innerPoints[i];
        polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
        const midPoint2 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        let arc = null;
        for (let j = 0; j < p1.parentIndex.length; ++j) {
          if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
            const circle3 = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle3.x, p1.y - circle3.y), a22 = Math.atan2(p2.x - circle3.x, p2.y - circle3.y);
            let angleDiff = a22 - a1;
            if (angleDiff < 0) {
              angleDiff += 2 * Math.PI;
            }
            const a3 = a22 - angleDiff / 2;
            let width = distance6(midPoint2, {
              x: circle3.x + circle3.radius * Math.sin(a3),
              y: circle3.y + circle3.radius * Math.cos(a3)
            });
            if (width > circle3.radius * 2) {
              width = circle3.radius * 2;
            }
            if (arc === null || arc.width > width) {
              arc = { circle: circle3, width, p1, p2 };
            }
          }
        }
        if (arc !== null) {
          arcs.push(arc);
          arcArea += circleArea(arc.circle.radius, arc.width);
          p2 = p1;
        }
      }
    } else {
      let smallest = circles[0];
      for (i = 1; i < circles.length; ++i) {
        if (circles[i].radius < smallest.radius) {
          smallest = circles[i];
        }
      }
      let disjoint = false;
      for (i = 0; i < circles.length; ++i) {
        if (distance6(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
          disjoint = true;
          break;
        }
      }
      if (disjoint) {
        arcArea = polygonArea = 0;
      } else {
        arcArea = smallest.radius * smallest.radius * Math.PI;
        arcs.push({
          circle: smallest,
          p1: { x: smallest.x, y: smallest.y + smallest.radius },
          p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },
          width: smallest.radius * 2
        });
      }
    }
    polygonArea /= 2;
    if (stats) {
      stats.area = arcArea + polygonArea;
      stats.arcArea = arcArea;
      stats.polygonArea = polygonArea;
      stats.arcs = arcs;
      stats.innerPoints = innerPoints;
      stats.intersectionPoints = intersectionPoints;
    }
    return arcArea + polygonArea;
  }
  function containedInCircles(point6, circles) {
    for (let i = 0; i < circles.length; ++i) {
      if (distance6(point6, circles[i]) > circles[i].radius + SMALL) {
        return false;
      }
    }
    return true;
  }
  function getIntersectionPoints(circles) {
    const ret = [];
    for (let i = 0; i < circles.length; ++i) {
      for (let j = i + 1; j < circles.length; ++j) {
        const intersect4 = circleCircleIntersection(circles[i], circles[j]);
        for (let k = 0; k < intersect4.length; ++k) {
          const p2 = intersect4[k];
          p2.parentIndex = [i, j];
          ret.push(p2);
        }
      }
    }
    return ret;
  }
  function circleArea(r, width) {
    return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
  }
  function distance6(p1, p2) {
    return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
  }
  function circleOverlap(r1, r2, d3) {
    if (d3 >= r1 + r2) {
      return 0;
    }
    if (d3 <= Math.abs(r1 - r2)) {
      return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
    }
    const w1 = r1 - (d3 * d3 - r2 * r2 + r1 * r1) / (2 * d3), w2 = r2 - (d3 * d3 - r1 * r1 + r2 * r2) / (2 * d3);
    return circleArea(r1, w1) + circleArea(r2, w2);
  }
  function circleCircleIntersection(p1, p2) {
    const d3 = distance6(p1, p2), r1 = p1.radius, r2 = p2.radius;
    if (d3 >= r1 + r2 || d3 <= Math.abs(r1 - r2)) {
      return [];
    }
    const a3 = (r1 * r1 - r2 * r2 + d3 * d3) / (2 * d3), h = Math.sqrt(r1 * r1 - a3 * a3), x05 = p1.x + a3 * (p2.x - p1.x) / d3, y05 = p1.y + a3 * (p2.y - p1.y) / d3, rx = -(p2.y - p1.y) * (h / d3), ry = -(p2.x - p1.x) * (h / d3);
    return [
      { x: x05 + rx, y: y05 - ry },
      { x: x05 - rx, y: y05 + ry }
    ];
  }
  function getCenter(points) {
    const center2 = { x: 0, y: 0 };
    for (let i = 0; i < points.length; ++i) {
      center2.x += points[i].x;
      center2.y += points[i].y;
    }
    center2.x /= points.length;
    center2.y /= points.length;
    return center2;
  }

  // node_modules/@antv/g2/esm/data/utils/venn/layout.js
  function venn(areas, parameters) {
    parameters = parameters || {};
    parameters.maxIterations = parameters.maxIterations || 500;
    const initialLayout = parameters.initialLayout || bestInitialLayout;
    const loss = parameters.lossFunction || lossFunction;
    areas = addMissingAreas(areas);
    const circles = initialLayout(areas, parameters);
    const initial = [], setids = [];
    let setid;
    for (setid in circles) {
      if (circles.hasOwnProperty(setid)) {
        initial.push(circles[setid].x);
        initial.push(circles[setid].y);
        setids.push(setid);
      }
    }
    const solution = (0, import_fmin.nelderMead)(function(values) {
      const current = {};
      for (let i = 0; i < setids.length; ++i) {
        const setid2 = setids[i];
        current[setid2] = {
          x: values[2 * i],
          y: values[2 * i + 1],
          radius: circles[setid2].radius
        };
      }
      return loss(current, areas);
    }, initial, parameters);
    const positions = solution.x;
    for (let i = 0; i < setids.length; ++i) {
      setid = setids[i];
      circles[setid].x = positions[2 * i];
      circles[setid].y = positions[2 * i + 1];
    }
    return circles;
  }
  var SMALL2 = 1e-10;
  function distanceFromIntersectArea(r1, r2, overlap) {
    if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL2) {
      return Math.abs(r1 - r2);
    }
    return (0, import_fmin.bisect)(function(distance7) {
      return circleOverlap(r1, r2, distance7) - overlap;
    }, 0, r1 + r2);
  }
  function addMissingAreas(areas) {
    areas = areas.slice();
    const ids = [], pairs = {};
    let i, j, a3, b;
    for (i = 0; i < areas.length; ++i) {
      const area2 = areas[i];
      if (area2.sets.length == 1) {
        ids.push(area2.sets[0]);
      } else if (area2.sets.length == 2) {
        a3 = area2.sets[0];
        b = area2.sets[1];
        pairs[[a3, b]] = true;
        pairs[[b, a3]] = true;
      }
    }
    ids.sort((a4, b2) => {
      return a4 > b2 ? 1 : -1;
    });
    for (i = 0; i < ids.length; ++i) {
      a3 = ids[i];
      for (j = i + 1; j < ids.length; ++j) {
        b = ids[j];
        if (!([a3, b] in pairs)) {
          areas.push({ sets: [a3, b], size: 0 });
        }
      }
    }
    return areas;
  }
  function getDistanceMatrices(areas, sets, setids) {
    const distances = (0, import_fmin.zerosM)(sets.length, sets.length), constraints = (0, import_fmin.zerosM)(sets.length, sets.length);
    areas.filter(function(x3) {
      return x3.sets.length == 2;
    }).map(function(current) {
      const left2 = setids[current.sets[0]], right2 = setids[current.sets[1]], r1 = Math.sqrt(sets[left2].size / Math.PI), r2 = Math.sqrt(sets[right2].size / Math.PI), distance7 = distanceFromIntersectArea(r1, r2, current.size);
      distances[left2][right2] = distances[right2][left2] = distance7;
      let c5 = 0;
      if (current.size + 1e-10 >= Math.min(sets[left2].size, sets[right2].size)) {
        c5 = 1;
      } else if (current.size <= 1e-10) {
        c5 = -1;
      }
      constraints[left2][right2] = constraints[right2][left2] = c5;
    });
    return { distances, constraints };
  }
  function constrainedMDSGradient(x3, fxprime, distances, constraints) {
    let loss = 0, i;
    for (i = 0; i < fxprime.length; ++i) {
      fxprime[i] = 0;
    }
    for (i = 0; i < distances.length; ++i) {
      const xi = x3[2 * i], yi = x3[2 * i + 1];
      for (let j = i + 1; j < distances.length; ++j) {
        const xj = x3[2 * j], yj = x3[2 * j + 1], dij = distances[i][j], constraint = constraints[i][j];
        const squaredDistance4 = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance7 = Math.sqrt(squaredDistance4), delta = squaredDistance4 - dij * dij;
        if (constraint > 0 && distance7 <= dij || constraint < 0 && distance7 >= dij) {
          continue;
        }
        loss += 2 * delta * delta;
        fxprime[2 * i] += 4 * delta * (xi - xj);
        fxprime[2 * i + 1] += 4 * delta * (yi - yj);
        fxprime[2 * j] += 4 * delta * (xj - xi);
        fxprime[2 * j + 1] += 4 * delta * (yj - yi);
      }
    }
    return loss;
  }
  function bestInitialLayout(areas, params) {
    let initial = greedyLayout(areas, params);
    const loss = params.lossFunction || lossFunction;
    if (areas.length >= 8) {
      const constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial, areas);
      if (constrainedLoss + 1e-8 < greedyLoss) {
        initial = constrained;
      }
    }
    return initial;
  }
  function constrainedMDSLayout(areas, params) {
    params = params || {};
    const restarts = params.restarts || 10;
    const sets = [], setids = {};
    let i;
    for (i = 0; i < areas.length; ++i) {
      const area2 = areas[i];
      if (area2.sets.length == 1) {
        setids[area2.sets[0]] = sets.length;
        sets.push(area2);
      }
    }
    const matrices = getDistanceMatrices(areas, sets, setids);
    let distances = matrices.distances;
    const constraints = matrices.constraints;
    const norm = (0, import_fmin.norm2)(distances.map(import_fmin.norm2)) / distances.length;
    distances = distances.map(function(row2) {
      return row2.map(function(value2) {
        return value2 / norm;
      });
    });
    const obj = function(x3, fxprime) {
      return constrainedMDSGradient(x3, fxprime, distances, constraints);
    };
    let best, current;
    for (i = 0; i < restarts; ++i) {
      const initial = (0, import_fmin.zeros)(distances.length * 2).map(Math.random);
      current = (0, import_fmin.conjugateGradient)(obj, initial, params);
      if (!best || current.fx < best.fx) {
        best = current;
      }
    }
    const positions = best.x;
    const circles = {};
    for (i = 0; i < sets.length; ++i) {
      const set8 = sets[i];
      circles[set8.sets[0]] = {
        x: positions[2 * i] * norm,
        y: positions[2 * i + 1] * norm,
        radius: Math.sqrt(set8.size / Math.PI)
      };
    }
    if (params.history) {
      for (i = 0; i < params.history.length; ++i) {
        (0, import_fmin.scale)(params.history[i].x, norm);
      }
    }
    return circles;
  }
  function greedyLayout(areas, params) {
    const loss = params && params.lossFunction ? params.lossFunction : lossFunction;
    const circles = {}, setOverlaps = {};
    let set8;
    for (let i = 0; i < areas.length; ++i) {
      const area2 = areas[i];
      if (area2.sets.length == 1) {
        set8 = area2.sets[0];
        circles[set8] = {
          x: 1e10,
          y: 1e10,
          // rowid: circles.length, // fix to ->
          rowid: Object.keys(circles).length,
          size: area2.size,
          radius: Math.sqrt(area2.size / Math.PI)
        };
        setOverlaps[set8] = [];
      }
    }
    areas = areas.filter(function(a3) {
      return a3.sets.length == 2;
    });
    for (let i = 0; i < areas.length; ++i) {
      const current = areas[i];
      let weight2 = current.hasOwnProperty("weight") ? current.weight : 1;
      const left2 = current.sets[0], right2 = current.sets[1];
      if (current.size + SMALL2 >= Math.min(circles[left2].size, circles[right2].size)) {
        weight2 = 0;
      }
      setOverlaps[left2].push({ set: right2, size: current.size, weight: weight2 });
      setOverlaps[right2].push({ set: left2, size: current.size, weight: weight2 });
    }
    const mostOverlapped = [];
    for (set8 in setOverlaps) {
      if (setOverlaps.hasOwnProperty(set8)) {
        let size2 = 0;
        for (let i = 0; i < setOverlaps[set8].length; ++i) {
          size2 += setOverlaps[set8][i].size * setOverlaps[set8][i].weight;
        }
        mostOverlapped.push({ set: set8, size: size2 });
      }
    }
    function sortOrder(a3, b) {
      return b.size - a3.size;
    }
    mostOverlapped.sort(sortOrder);
    const positioned = {};
    function isPositioned(element) {
      return element.set in positioned;
    }
    function positionSet(point6, index4) {
      circles[index4].x = point6.x;
      circles[index4].y = point6.y;
      positioned[index4] = true;
    }
    positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);
    for (let i = 1; i < mostOverlapped.length; ++i) {
      const setIndex = mostOverlapped[i].set, overlap = setOverlaps[setIndex].filter(isPositioned);
      set8 = circles[setIndex];
      overlap.sort(sortOrder);
      if (overlap.length === 0) {
        throw "ERROR: missing pairwise overlap information";
      }
      const points = [];
      for (let j = 0; j < overlap.length; ++j) {
        const p1 = circles[overlap[j].set], d1 = distanceFromIntersectArea(set8.radius, p1.radius, overlap[j].size);
        points.push({ x: p1.x + d1, y: p1.y });
        points.push({ x: p1.x - d1, y: p1.y });
        points.push({ y: p1.y + d1, x: p1.x });
        points.push({ y: p1.y - d1, x: p1.x });
        for (let k = j + 1; k < overlap.length; ++k) {
          const p2 = circles[overlap[k].set], d22 = distanceFromIntersectArea(set8.radius, p2.radius, overlap[k].size);
          const extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p2.x, y: p2.y, radius: d22 });
          for (let l2 = 0; l2 < extraPoints.length; ++l2) {
            points.push(extraPoints[l2]);
          }
        }
      }
      let bestLoss = 1e50, bestPoint = points[0];
      for (let j = 0; j < points.length; ++j) {
        circles[setIndex].x = points[j].x;
        circles[setIndex].y = points[j].y;
        const localLoss = loss(circles, areas);
        if (localLoss < bestLoss) {
          bestLoss = localLoss;
          bestPoint = points[j];
        }
      }
      positionSet(bestPoint, setIndex);
    }
    return circles;
  }
  function lossFunction(sets, overlaps) {
    let output = 0;
    function getCircles(indices) {
      return indices.map(function(i) {
        return sets[i];
      });
    }
    for (let i = 0; i < overlaps.length; ++i) {
      const area2 = overlaps[i];
      let overlap;
      if (area2.sets.length == 1) {
        continue;
      } else if (area2.sets.length == 2) {
        const left2 = sets[area2.sets[0]], right2 = sets[area2.sets[1]];
        overlap = circleOverlap(left2.radius, right2.radius, distance6(left2, right2));
      } else {
        overlap = intersectionArea(getCircles(area2.sets));
      }
      const weight2 = area2.hasOwnProperty("weight") ? area2.weight : 1;
      output += weight2 * (overlap - area2.size) * (overlap - area2.size);
    }
    return output;
  }
  function getBoundingBox(circles) {
    const minMax = function(d3) {
      const hi = Math.max.apply(null, circles.map(function(c5) {
        return c5[d3] + c5.radius;
      })), lo = Math.min.apply(null, circles.map(function(c5) {
        return c5[d3] - c5.radius;
      }));
      return { max: hi, min: lo };
    };
    return { xRange: minMax("x"), yRange: minMax("y") };
  }
  function scaleSolution(solution, width, height, padding) {
    const circles = [], setids = [];
    for (const setid in solution) {
      if (solution.hasOwnProperty(setid)) {
        setids.push(setid);
        circles.push(solution[setid]);
      }
    }
    width -= 2 * padding;
    height -= 2 * padding;
    const bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
    if (xRange.max == xRange.min || yRange.max == yRange.min) {
      console.log("not scaling solution: zero size detected");
      return solution;
    }
    const xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
    const scaled = {};
    for (let i = 0; i < circles.length; ++i) {
      const circle3 = circles[i];
      scaled[setids[i]] = {
        radius: scaling * circle3.radius,
        x: padding + xOffset + (circle3.x - xRange.min) * scaling,
        y: padding + yOffset + (circle3.y - yRange.min) * scaling
      };
    }
    return scaled;
  }

  // node_modules/@antv/g2/esm/data/utils/venn/diagram.js
  function circlePath(x3, y3, r) {
    const ret = [];
    const x05 = x3 - r;
    const y05 = y3;
    ret.push("M", x05, y05);
    ret.push("A", r, r, 0, 1, 0, x05 + 2 * r, y05);
    ret.push("A", r, r, 0, 1, 0, x05, y05);
    return ret.join(" ");
  }
  function intersectionAreaPath(circles) {
    const stats = {};
    intersectionArea(circles, stats);
    const arcs = stats.arcs;
    if (arcs.length === 0) {
      return "M 0 0";
    } else if (arcs.length == 1) {
      const circle3 = arcs[0].circle;
      return circlePath(circle3.x, circle3.y, circle3.radius);
    } else {
      const ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
      for (let i = 0; i < arcs.length; ++i) {
        const arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;
        ret.push("\nA", r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
      }
      return ret.join(" ");
    }
  }

  // node_modules/@antv/g2/esm/data/venn.js
  var Venn = (options) => {
    const { sets = "sets", size: size2 = "size", as = ["key", "path"], padding = 0 } = options;
    const [key, path2] = as;
    return (data2) => {
      const vennData = data2.map((d3) => Object.assign(Object.assign({}, d3), { sets: d3[sets], size: d3[size2], [key]: d3.sets.join("&") }));
      vennData.sort((a3, b) => a3.sets.length - b.sets.length);
      const solution = venn(vennData);
      let circles;
      return vennData.map((datum) => {
        const setsValue = datum[sets];
        const pathFunc = ({ width, height }) => {
          circles = circles ? circles : scaleSolution(solution, width, height, padding);
          const setCircles = setsValue.map((set8) => circles[set8]);
          let p2 = intersectionAreaPath(setCircles);
          if (!/[zZ]$/.test(p2))
            p2 += " Z";
          return p2;
        };
        return Object.assign(Object.assign({}, datum), { [path2]: pathFunc });
      });
    };
  };
  Venn.props = {};

  // node_modules/@antv/g2/esm/data/log.js
  var Log3 = () => {
    return (data2) => {
      console.log("G2 data section:", data2);
      return data2;
    };
  };
  Log3.props = {};

  // node_modules/@antv/g2/esm/data/ema.js
  function ema(values, alpha) {
    if (alpha < 0 || alpha > 1) {
      throw new Error("alpha must be between 0 and 1.");
    }
    if (values.length === 0) {
      return [];
    }
    let last4 = values[0];
    const smoothed = [];
    for (const point6 of values) {
      if (point6 === null || point6 === void 0) {
        smoothed.push(point6);
        console.warn("EMA\uFF1AThe value is null or undefined", values);
        continue;
      }
      if (last4 === null || last4 === void 0) {
        last4 = point6;
      }
      const smoothedVal = last4 * alpha + (1 - alpha) * point6;
      smoothed.push(smoothedVal);
      last4 = smoothedVal;
    }
    return smoothed;
  }
  var EMA = (options) => {
    const { field: field3 = "y", alpha = 0.6, as = field3 } = options;
    return (data2) => {
      const values = data2.map((d3) => {
        return d3[field3];
      });
      const out = ema(values, alpha);
      return data2.map((d3, i) => {
        return Object.assign(Object.assign({}, d3), { [as]: out[i] });
      });
    };
  };
  EMA.props = {};

  // node_modules/@antv/g2/esm/utils/bounds.js
  function parseAABB(min22) {
    const { min: min10, max: max11 } = min22;
    return [
      [min10[0], min10[1]],
      [max11[0], max11[1]]
    ];
  }
  function isInBounds(point6, bounds) {
    const [x3, y3] = point6;
    const [min10, max11] = bounds;
    return x3 >= min10[0] && x3 <= max11[0] && y3 >= min10[1] && y3 <= max11[1];
  }
  function isOverflow(b1, b2) {
    const [min10, max11] = b1;
    return !(isInBounds(min10, b2) && isInBounds(max11, b2));
  }
  function isOverlap(b1, b2) {
    const [min1, max1] = b1;
    const [min22, max22] = b2;
    return min1[0] < max22[0] && max1[0] > min22[0] && min1[1] < max22[1] && max1[1] > min22[1];
  }

  // node_modules/@antv/g2/esm/label-transform/overlapHide.js
  var OverlapHide = (options) => {
    const { priority } = options;
    return (labels) => {
      const displayLabels = [];
      if (priority)
        labels.sort(priority);
      labels.forEach((l2) => {
        show2(l2);
        const b1 = l2.getLocalBounds();
        const overlaping = displayLabels.some((dl) => isOverlap(parseAABB(b1), parseAABB(dl.getLocalBounds())));
        if (overlaping)
          hide2(l2);
        else
          displayLabels.push(l2);
      });
      return labels;
    };
  };

  // node_modules/@antv/g2/esm/label-transform/overlapDodgeY.js
  function isSegmentIntersect([a3, b], [c5, d3]) {
    return d3 > a3 && b > c5;
  }
  function useMap() {
    const map3 = /* @__PURE__ */ new Map();
    const get2 = (key) => map3.get(key);
    const set8 = (key, value2) => map3.set(key, value2);
    return [get2, set8];
  }
  function getBoundsWithoutConnector(shape23) {
    const node = shape23.cloneNode(true);
    const connectorShape = node.getElementById("connector");
    connectorShape && node.removeChild(connectorShape);
    const { min: min10, max: max11 } = node.getRenderBounds();
    node.destroy();
    return { min: min10, max: max11 };
  }
  var OverlapDodgeY = (options) => {
    const { maxIterations = 10, maxError = 0.1, padding = 1 } = options;
    return (labels) => {
      const n2 = labels.length;
      if (n2 <= 1)
        return labels;
      const [y05, setY0] = useMap();
      const [y3, setY] = useMap();
      const [h, setH] = useMap();
      const [xx, setXX] = useMap();
      for (const label of labels) {
        const { min: min10, max: max11 } = getBoundsWithoutConnector(label);
        const [x05, y06] = min10;
        const [x12, y12] = max11;
        setY0(label, y06);
        setY(label, y06);
        setH(label, y12 - y06);
        setXX(label, [x05, x12]);
      }
      for (let iter = 0; iter < maxIterations; iter++) {
        labels.sort((a3, b) => ascending(y3(a3), y3(b)));
        let error4 = 0;
        for (let i = 0; i < n2 - 1; i++) {
          const l0 = labels[i];
          let j = i + 1;
          let l1;
          while ((l1 = labels[j]) && !isSegmentIntersect(xx(l0), xx(l1)))
            j += 1;
          if (l1) {
            const y06 = y3(l0);
            const h0 = h(l0);
            const y12 = y3(l1);
            const delta = y12 - (y06 + h0);
            if (delta < padding) {
              const newDelta = (padding - delta) / 2;
              error4 = Math.max(error4, newDelta);
              setY(l0, y06 - newDelta);
              setY(l1, y12 + newDelta);
            }
          }
        }
        if (error4 < maxError)
          break;
      }
      for (const label of labels) {
        label.style.y += y3(label) - y05(label);
      }
      return labels;
    };
  };

  // node_modules/@antv/g2/esm/utils/color.js
  function parseToRGB(c5) {
    if (typeof c5 === "object")
      return c5;
    return parseColor(c5);
  }

  // node_modules/@antv/g2/esm/label-transform/contrastReverse.js
  function getsRGB(s3) {
    let c5 = s3 / 255;
    c5 = c5 <= 0.03928 ? c5 / 12.92 : Math.pow((c5 + 0.055) / 1.055, 2.4);
    return c5;
  }
  function getL(r, g, b) {
    return 0.2126 * getsRGB(r) + 0.7152 * getsRGB(g) + 0.0722 * getsRGB(b);
  }
  function contrast(foreground, background) {
    if (!foreground || !background || foreground === background)
      return 1;
    const { r, g, b } = foreground;
    const { r: rb, g: gb, b: bb } = background;
    const L1 = getL(r, g, b);
    const L2 = getL(rb, gb, bb);
    return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
  }
  function mostContrast(color2, palette) {
    const i = maxIndex(palette, (c5) => contrast(color2, parseToRGB(c5)));
    return palette[i];
  }
  var ContrastReverse = (options) => {
    const { threshold = 4.5, palette = ["#000", "#fff"] } = options;
    return (labels) => {
      labels.forEach((l2) => {
        const background = l2.attr("dependentElement").parsedStyle.fill;
        const foreground = l2.parsedStyle.fill;
        const c5 = contrast(foreground, background);
        if (c5 < threshold)
          l2.attr("fill", mostContrast(background, palette));
      });
      return labels;
    };
  };

  // node_modules/@antv/g2/esm/label-transform/overflowHide.js
  var OverflowHide = () => {
    return (labels) => {
      labels.forEach((l2) => {
        show2(l2);
        const bounds = l2.attr("bounds");
        const b = l2.getLocalBounds();
        const overflow = isOverflow(parseAABB(b), bounds);
        if (overflow)
          hide2(l2);
      });
      return labels;
    };
  };

  // node_modules/@antv/g2/esm/label-transform/exceedAdjust.js
  var adjustPosition = (target, edge) => {
    const [[minEdgeX, minEdgeY], [maxEdgeX, maxEdgeY]] = edge;
    const [[minX, minY], [maxX, maxY2]] = target;
    let changeX = 0, changeY = 0;
    if (minX < minEdgeX) {
      changeX = minEdgeX - minX;
    } else if (maxX > maxEdgeX) {
      changeX = maxEdgeX - maxX;
    }
    if (minY < minEdgeY) {
      changeY = minEdgeY - minY;
    } else if (maxY2 > maxEdgeY) {
      changeY = maxEdgeY - maxY2;
    }
    return [changeX, changeY];
  };
  var ExceedAdjust = () => {
    return (labels, { canvas, layout }) => {
      labels.forEach((l2) => {
        show2(l2);
        const { max: max11, min: min10 } = l2.getRenderBounds();
        const [xMax, yMax] = max11, [xMin, yMin] = min10;
        const changeValue = adjustPosition(
          [
            [xMin, yMin],
            [xMax, yMax]
          ],
          // Prevent label overlap in multiple charts by calculating layouts separately to avoid collisions.
          [
            [layout.x, layout.y],
            [layout.x + layout.width, layout.y + layout.height]
          ]
        );
        if (l2.style.connector && l2.style.connectorPoints) {
          l2.style.connectorPoints[0][0] -= changeValue[0];
          l2.style.connectorPoints[0][1] -= changeValue[1];
        }
        l2.style.x += changeValue[0];
        l2.style.y += changeValue[1];
      });
      return labels;
    };
  };

  // node_modules/@antv/g2/esm/lib/core.js
  function corelib() {
    return {
      "data.fetch": Fetch,
      "data.inline": Inline,
      "data.sortBy": SortBy,
      "data.sort": Sort2,
      "data.filter": Filter2,
      "data.pick": Pick,
      "data.rename": Rename,
      "data.fold": Fold,
      "data.slice": Slice,
      "data.custom": Custom,
      "data.map": Map2,
      "data.join": Join,
      "data.kde": KDE,
      "data.log": Log3,
      "data.wordCloud": WordCloud2,
      "data.ema": EMA,
      "transform.stackY": StackY,
      "transform.binX": BinX,
      "transform.bin": Bin,
      "transform.dodgeX": DodgeX,
      "transform.jitter": Jitter,
      "transform.jitterX": JitterX,
      "transform.jitterY": JitterY,
      "transform.symmetryY": SymmetryY,
      "transform.diffY": DiffY,
      "transform.stackEnter": StackEnter,
      "transform.normalizeY": NormalizeY,
      "transform.select": Select,
      "transform.selectX": SelectX,
      "transform.selectY": SelectY,
      "transform.groupX": GroupX,
      "transform.groupY": GroupY,
      "transform.groupColor": GroupColor,
      "transform.group": Group,
      "transform.sortX": SortX,
      "transform.sortY": SortY,
      "transform.sortColor": SortColor,
      "transform.flexX": FlexX,
      "transform.pack": Pack,
      "transform.sample": Sample,
      "transform.filter": Filter,
      "coordinate.cartesian": Cartesian,
      "coordinate.polar": Polar,
      "coordinate.transpose": Transpose,
      "coordinate.theta": Theta,
      "coordinate.parallel": Parallel,
      "coordinate.fisheye": Fisheye,
      "coordinate.radial": Radial,
      "coordinate.radar": Radar,
      "encode.constant": Constant,
      "encode.field": Field,
      "encode.transform": Transform,
      "encode.column": Column,
      "mark.interval": Interval2,
      "mark.rect": Rect3,
      "mark.line": Line5,
      "mark.point": Point4,
      "mark.text": Text4,
      "mark.cell": Cell,
      "mark.area": Area2,
      "mark.link": Link2,
      "mark.image": Image4,
      "mark.polygon": Polygon3,
      "mark.box": Box2,
      "mark.vector": Vector2,
      "mark.lineX": LineX,
      "mark.lineY": LineY,
      "mark.connector": Connector2,
      "mark.range": Range,
      "mark.rangeX": RangeX,
      "mark.rangeY": RangeY,
      "mark.path": Path4,
      "mark.shape": Shape3,
      "mark.density": Density2,
      "mark.heatmap": Heatmap2,
      "mark.wordCloud": WordCloud,
      "palette.category10": Category10,
      "palette.category20": Category20,
      "scale.linear": Linear3,
      "scale.ordinal": Ordinal2,
      "scale.band": Band2,
      "scale.identity": Identity2,
      "scale.point": Point5,
      "scale.time": Time2,
      "scale.log": Log2,
      "scale.pow": Pow2,
      "scale.sqrt": Sqrt2,
      "scale.threshold": Threshold2,
      "scale.quantile": Quantile2,
      "scale.quantize": Quantize2,
      "scale.sequential": Sequential3,
      "scale.constant": Constant3,
      "theme.classic": Classic,
      "theme.classicDark": ClassicDark,
      "theme.academy": Academy,
      "theme.light": Light,
      "theme.dark": Dark,
      "component.axisX": AxisX,
      "component.axisY": AxisY,
      "component.legendCategory": LegendCategory,
      "component.legendContinuous": LegendContinuous,
      "component.legends": Legends,
      "component.title": TitleComponent,
      "component.sliderX": SliderX,
      "component.sliderY": SliderY,
      "component.scrollbarX": ScrollbarX,
      "component.scrollbarY": ScrollbarY,
      "animation.scaleInX": ScaleInX,
      "animation.scaleOutX": ScaleOutX,
      "animation.scaleInY": ScaleInY,
      "animation.scaleOutY": ScaleOutY,
      "animation.waveIn": WaveIn,
      "animation.fadeIn": FadeIn,
      "animation.fadeOut": FadeOut,
      "animation.zoomIn": ZoomIn,
      "animation.zoomOut": ZoomOut,
      "animation.pathIn": PathIn,
      "animation.morphing": Morphing,
      "animation.growInX": GrowInX,
      "animation.growInY": GrowInY,
      "interaction.elementHighlight": ElementHighlight,
      "interaction.elementHighlightByX": ElementHighlightByX,
      "interaction.elementHighlightByColor": ElementHighlightByColor,
      "interaction.elementSelect": ElementSelect,
      "interaction.elementSelectByX": ElementSelectByX,
      "interaction.elementSelectByColor": ElementSelectByColor,
      "interaction.fisheye": Fisheye2,
      "interaction.chartIndex": ChartIndex,
      "interaction.tooltip": Tooltip2,
      "interaction.legendFilter": LegendFilter,
      "interaction.legendHighlight": LegendHighlight,
      "interaction.brushHighlight": BrushHighlight,
      "interaction.brushXHighlight": BrushXHighlight,
      "interaction.brushYHighlight": BrushYHighlight,
      "interaction.brushAxisHighlight": BrushAxisHighlight,
      "interaction.brushFilter": BrushFilter,
      "interaction.brushXFilter": BrushXFilter,
      "interaction.brushYFilter": BrushYFilter,
      "interaction.sliderFilter": SliderFilter,
      "interaction.scrollbarFilter": ScrollbarFilter,
      "interaction.poptip": Poptip,
      "interaction.treemapDrillDown": TreemapDrillDown,
      "interaction.elementPointMove": ElementPointMove,
      "composition.spaceLayer": SpaceLayer,
      "composition.spaceFlex": SpaceFlex,
      "composition.facetRect": FacetRect,
      "composition.repeatMatrix": RepeatMatrix,
      "composition.facetCircle": FacetCircle,
      "composition.timingKeyframe": TimingKeyframe,
      "labelTransform.overlapHide": OverlapHide,
      "labelTransform.overlapDodgeY": OverlapDodgeY,
      "labelTransform.overflowHide": OverflowHide,
      "labelTransform.contrastReverse": ContrastReverse,
      "labelTransform.exceedAdjust": ExceedAdjust
    };
  }

  // node_modules/@antv/g2/esm/lib/geo.js
  function geolib() {
    return {
      "composition.geoView": GeoView,
      "composition.geoPath": GeoPath
    };
  }

  // node_modules/@antv/g2/esm/lib/graph.js
  function graphlib() {
    return {
      "data.arc": Arc3,
      "data.cluster": Cluster,
      "mark.forceGraph": ForceGraph,
      "mark.tree": Tree2,
      "mark.pack": Pack2,
      "mark.sankey": Sankey3,
      "mark.chord": Chord,
      "mark.treemap": Treemap
    };
  }

  // node_modules/@antv/g2/esm/lib/plot.js
  function plotlib() {
    return {
      "data.venn": Venn,
      "mark.boxplot": Boxplot,
      "mark.gauge": Gauge,
      "mark.wordCloud": WordCloud,
      "mark.liquid": Liquid2
    };
  }

  // node_modules/@antv/g2/esm/lib/std.js
  function stdlib() {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, geolib()), graphlib()), plotlib()), corelib());
  }

  // node_modules/@antv/g2/esm/api/extend.js
  function extend6(Runtime2, library3) {
    class Chart2 extends Runtime2 {
      constructor(options) {
        super(Object.assign(Object.assign({}, options), { lib: library3 }));
      }
    }
    return Chart2;
  }

  // node_modules/@antv/g2/esm/api/library.js
  var library = {};

  // node_modules/@antv/g2/esm/utils/size.js
  var parseInt10 = (d3) => d3 ? parseInt(d3) : 0;
  function getContainerSize(container) {
    const style = getComputedStyle(container);
    const wrapperWidth = container.clientWidth || parseInt10(style.width);
    const wrapperHeight = container.clientHeight || parseInt10(style.height);
    const widthPadding = parseInt10(style.paddingLeft) + parseInt10(style.paddingRight);
    const heightPadding = parseInt10(style.paddingTop) + parseInt10(style.paddingBottom);
    return {
      width: wrapperWidth - widthPadding,
      height: wrapperHeight - heightPadding
    };
  }

  // node_modules/@antv/g2/esm/api/node.js
  function bfs(node, callback) {
    const discovered = [node];
    while (discovered.length) {
      const currentNode = discovered.shift();
      callback && callback(currentNode);
      const children = currentNode.children || [];
      for (const child of children) {
        discovered.push(child);
      }
    }
  }
  var Node5 = class {
    constructor(value2 = {}, type) {
      this.parentNode = null;
      this.children = [];
      this.index = 0;
      this.type = type;
      this.value = value2;
    }
    /**
     * Apply specified transform to current value. Mount the node
     * to replace the original one in the tree and then return it.
     */
    map(transform = (x3) => x3) {
      const newValue = transform(this.value);
      this.value = newValue;
      return this;
    }
    /**
     * Set or get the specified attribute. It the value is specified, update
     * the attribute of current value and return the node. Otherwise
     * return the the attribute of current value.
     */
    attr(key, value2) {
      if (arguments.length === 1)
        return this.value[key];
      return this.map((v) => (v[key] = value2, v));
    }
    /**
     * Create a new node and append to children nodes.
     */
    append(Ctor) {
      const node = new Ctor({});
      node.children = [];
      this.push(node);
      return node;
    }
    push(node) {
      node.parentNode = this;
      node.index = this.children.length;
      this.children.push(node);
      return this;
    }
    /**
     * Remove current node from parentNode.
     */
    remove() {
      const parent = this.parentNode;
      if (parent) {
        const { children } = parent;
        const index4 = children.findIndex((item) => item === this);
        children.splice(index4, 1);
      }
      return this;
    }
    getNodeByKey(key) {
      let targetNode = null;
      const callback = (node) => {
        if (key === node.attr("key")) {
          targetNode = node;
        }
      };
      bfs(this, callback);
      return targetNode;
    }
    getNodesByType(type) {
      const nodes = [];
      const callback = (node) => {
        if (type === node.type) {
          nodes.push(node);
        }
      };
      bfs(this, callback);
      return nodes;
    }
    getNodeByType(type) {
      let node = null;
      bfs(this, (current) => {
        if (node)
          return;
        if (type === current.type)
          node = current;
      });
      return node;
    }
    /**
     * Apply specified callback to the node value.
     */
    call(callback, ...params) {
      callback(this.map(), ...params);
      return this;
    }
    getRoot() {
      let root2 = this;
      while (root2 && root2.parentNode) {
        root2 = root2.parentNode;
      }
      return root2;
    }
  };

  // node_modules/@antv/g2/esm/api/utils.js
  var __rest89 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var VIEW_KEYS = [
    "width",
    "height",
    "depth",
    "padding",
    "paddingLeft",
    "paddingRight",
    "paddingBottom",
    "paddingTop",
    "inset",
    "insetLeft",
    "insetRight",
    "insetTop",
    "insetBottom",
    "margin",
    "marginLeft",
    "marginRight",
    "marginTop",
    "marginBottom",
    "autoFit",
    "theme",
    "title",
    "interaction"
  ];
  var REMOVE_FLAG = "__remove__";
  var CALLBACK_NODE = "__callback__";
  var MIN_CHART_WIDTH = 1;
  var MIN_CHART_HEIGHT = 1;
  function normalizeContainer2(container) {
    if (container === void 0) {
      const container2 = document.createElement("div");
      container2[REMOVE_FLAG] = true;
      return container2;
    }
    if (typeof container === "string") {
      const node = document.getElementById(container);
      return node;
    }
    return container;
  }
  function removeContainer(container) {
    const parent = container.parentNode;
    if (parent) {
      parent.removeChild(container);
    }
  }
  function normalizeRoot(node) {
    if (node.type !== null)
      return node;
    const root2 = node.children[node.children.length - 1];
    for (const key of VIEW_KEYS)
      root2.attr(key, node.attr(key));
    return root2;
  }
  function valueOf3(node) {
    return Object.assign(Object.assign({}, node.value), { type: node.type });
  }
  function sizeOf2(options, container) {
    const { width, height, autoFit, depth = 0 } = options;
    let effectiveWidth = 640;
    let effectiveHeight = 480;
    if (autoFit) {
      const { width: containerWidth, height: containerHeight } = getContainerSize(container);
      effectiveWidth = containerWidth || effectiveWidth;
      effectiveHeight = containerHeight || effectiveHeight;
    }
    effectiveWidth = width || effectiveWidth;
    effectiveHeight = height || effectiveHeight;
    return {
      width: Math.max(isNumber2(effectiveWidth) ? effectiveWidth : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
      height: Math.max(isNumber2(effectiveHeight) ? effectiveHeight : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT),
      depth
    };
  }
  function optionsOf(node) {
    const root2 = normalizeRoot(node);
    const discovered = [root2];
    const nodeValue = /* @__PURE__ */ new Map();
    nodeValue.set(root2, valueOf3(root2));
    while (discovered.length) {
      const node2 = discovered.pop();
      const value2 = nodeValue.get(node2);
      const { children = [] } = node2;
      for (const child of children) {
        if (child.type === CALLBACK_NODE) {
          value2.children = child.value;
        } else {
          const childValue = valueOf3(child);
          const { children: children2 = [] } = value2;
          children2.push(childValue);
          discovered.push(child);
          nodeValue.set(child, childValue);
          value2.children = children2;
        }
      }
    }
    return nodeValue.get(root2);
  }
  function isMark(type, mark) {
    if (typeof type === "function")
      return true;
    return new Set(Object.keys(mark)).has(type);
  }
  function isComposition(type, composition) {
    return typeof type !== "function" && new Set(Object.keys(composition)).has(type);
  }
  function normalizeRootOptions(node, options, previousType, marks, composition) {
    const { type: oldType } = node;
    const { type = previousType || oldType } = options;
    if (isComposition(type, composition)) {
      for (const key of VIEW_KEYS) {
        if (node.attr(key) !== void 0 && options[key] === void 0) {
          options[key] = node.attr(key);
        }
      }
      return options;
    }
    if (isMark(type, marks)) {
      const view = { type: "view" };
      const mark = Object.assign({}, options);
      for (const key of VIEW_KEYS) {
        if (mark[key] !== void 0) {
          view[key] = mark[key];
          delete mark[key];
        }
      }
      return Object.assign(Object.assign({}, view), { children: [mark] });
    }
    return options;
  }
  function typeCtor(type, mark, composition) {
    if (typeof type === "function")
      return mark.mark;
    const node = Object.assign(Object.assign({}, mark), composition);
    const ctor = node[type];
    if (!ctor)
      throw new Error(`Unknown mark: ${type}.`);
    return ctor;
  }
  function createNode(options, mark, composition) {
    if (typeof options === "function") {
      const node2 = new Node5();
      node2.value = options;
      node2.type = CALLBACK_NODE;
      return node2;
    }
    const { type, children } = options, value2 = __rest89(options, ["type", "children"]);
    const Ctor = typeCtor(type, mark, composition);
    const node = new Ctor();
    node.value = value2;
    node.type = type;
    return node;
  }
  function updateNode(node, newOptions) {
    const { type, children } = newOptions, value2 = __rest89(newOptions, ["type", "children"]);
    if (node.type === type || type === void 0) {
      deepAssign(node.value, value2);
    } else if (typeof type === "string") {
      node.type = type;
      node.value = value2;
    }
  }
  function appendNode(parent, newOptions, mark, composition) {
    if (!parent)
      return;
    const discovered = [[parent, newOptions]];
    while (discovered.length) {
      const [parent2, nodeOptions] = discovered.shift();
      const node = createNode(nodeOptions, mark, composition);
      if (Array.isArray(parent2.children))
        parent2.push(node);
      const { children } = nodeOptions;
      if (Array.isArray(children)) {
        for (const child of children) {
          discovered.push([node, child]);
        }
      } else if (typeof children === "function") {
        discovered.push([node, children]);
      }
    }
  }
  function updateRoot(node, options, definedType, mark, composition) {
    const rootOptions = normalizeRootOptions(node, options, definedType, mark, composition);
    const discovered = [[null, node, rootOptions]];
    while (discovered.length) {
      const [parent, oldNode, newNode] = discovered.shift();
      if (!oldNode) {
        appendNode(parent, newNode, mark, composition);
      } else if (!newNode) {
        oldNode.remove();
      } else {
        updateNode(oldNode, newNode);
        const { children: newChildren } = newNode;
        const { children: oldChildren } = oldNode;
        if (Array.isArray(newChildren) && Array.isArray(oldChildren)) {
          const n2 = Math.max(newChildren.length, oldChildren.length);
          for (let i = 0; i < n2; i++) {
            const newChild = newChildren[i];
            const oldChild = oldChildren[i];
            discovered.push([oldNode, oldChild, newChild]);
          }
        } else if (typeof newChildren === "function") {
          discovered.push([oldNode, null, newChildren]);
        }
      }
    }
  }
  function createEmptyPromise() {
    let reject;
    let resolve;
    const cloned = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    return [cloned, resolve, reject];
  }

  // node_modules/@antv/g2/esm/api/define.js
  function defineValueProp(Node6, name2, { key = name2 }) {
    Node6.prototype[name2] = function(value2) {
      if (arguments.length === 0)
        return this.attr(key);
      return this.attr(key, value2);
    };
  }
  function defineArrayProp(Node6, name2, { key = name2 }) {
    Node6.prototype[name2] = function(value2) {
      if (arguments.length === 0)
        return this.attr(key);
      if (Array.isArray(value2))
        return this.attr(key, value2);
      const array2 = [...this.attr(key) || [], value2];
      return this.attr(key, array2);
    };
  }
  function defineObjectProp(Node6, name2, { key: k = name2 }) {
    Node6.prototype[name2] = function(key, value2) {
      if (arguments.length === 0)
        return this.attr(k);
      if (arguments.length === 1 && typeof key !== "string") {
        return this.attr(k, key);
      }
      const obj = this.attr(k) || {};
      obj[key] = arguments.length === 1 ? true : value2;
      return this.attr(k, obj);
    };
  }
  function defineMixProp(Node6, name2, descriptor) {
    Node6.prototype[name2] = function(key) {
      if (arguments.length === 0)
        return this.attr(name2);
      if (Array.isArray(key))
        return this.attr(name2, { items: key });
      if (isStrictObject(key) && (key.title !== void 0 || key.items !== void 0)) {
        return this.attr(name2, key);
      }
      if (key === null || key === false)
        return this.attr(name2, key);
      const obj = this.attr(name2) || {};
      const { items = [] } = obj;
      items.push(key);
      obj.items = items;
      return this.attr(name2, obj);
    };
  }
  function defineNodeProp(Node6, name2, { ctor }) {
    Node6.prototype[name2] = function(hocMark) {
      const node = this.append(ctor);
      if (name2 === "mark") {
        node.type = hocMark;
      }
      return node;
    };
  }
  function defineContainerProp(Node6, name2, { ctor }) {
    Node6.prototype[name2] = function() {
      this.type = null;
      return this.append(ctor);
    };
  }
  function defineProps(descriptors) {
    return (Node6) => {
      for (const [name2, descriptor] of Object.entries(descriptors)) {
        const { type } = descriptor;
        if (type === "value")
          defineValueProp(Node6, name2, descriptor);
        else if (type === "array")
          defineArrayProp(Node6, name2, descriptor);
        else if (type === "object")
          defineObjectProp(Node6, name2, descriptor);
        else if (type === "node")
          defineNodeProp(Node6, name2, descriptor);
        else if (type === "container")
          defineContainerProp(Node6, name2, descriptor);
        else if (type === "mix")
          defineMixProp(Node6, name2, descriptor);
      }
      return Node6;
    };
  }
  function nodeProps(node) {
    return Object.fromEntries(Object.entries(node).map(([name2, ctor]) => [name2, { type: "node", ctor }]));
  }

  // node_modules/@antv/g2/esm/api/props.js
  var commonProps = {
    encode: { type: "object" },
    scale: { type: "object" },
    data: { type: "value" },
    transform: { type: "array" },
    style: { type: "object" },
    animate: { type: "object" },
    coordinate: { type: "object" },
    interaction: { type: "object" },
    label: { type: "array", key: "labels" },
    axis: { type: "object" },
    legend: { type: "object" },
    slider: { type: "object" },
    scrollbar: { type: "object" },
    state: { type: "object" },
    layout: { type: "object" },
    theme: { type: "object" },
    title: { type: "value" }
  };
  var markProps = Object.assign(Object.assign({}, commonProps), { tooltip: { type: "mix" }, viewStyle: { type: "object" } });
  var compositionProps = Object.assign(Object.assign({}, commonProps), { labelTransform: { type: "array" } });

  // node_modules/@antv/g2/esm/api/composition.js
  var __decorate2 = function(decorators, target, key, desc) {
    var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d3 = decorators[i]) r = (c5 < 3 ? d3(r) : c5 > 3 ? d3(target, key, r) : d3(target, key)) || r;
    return c5 > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var CompositionNode = class CompositionNode2 extends Node5 {
    /**
     * Change current node data and its children data.
     */
    changeData(data2) {
      var _a;
      const chart = this.getRoot();
      if (!chart)
        return;
      this.attr("data", data2);
      if ((_a = this.children) === null || _a === void 0 ? void 0 : _a.length) {
        this.children.forEach((child) => {
          child.attr("data", data2);
        });
      }
      return chart === null || chart === void 0 ? void 0 : chart.render();
    }
    /**
     * Get view instance by key.
     */
    getView() {
      const chart = this.getRoot();
      const { views } = chart.getContext();
      if (!(views === null || views === void 0 ? void 0 : views.length))
        return void 0;
      return views.find((view) => view.key === this._key);
    }
    getScale() {
      var _a;
      return (_a = this.getView()) === null || _a === void 0 ? void 0 : _a.scale;
    }
    getScaleByChannel(channel) {
      const scale10 = this.getScale();
      if (scale10)
        return scale10[channel];
      return;
    }
    getCoordinate() {
      var _a;
      return (_a = this.getView()) === null || _a === void 0 ? void 0 : _a.coordinate;
    }
    getTheme() {
      var _a;
      return (_a = this.getView()) === null || _a === void 0 ? void 0 : _a.theme;
    }
    getGroup() {
      const key = this._key;
      if (!key)
        return void 0;
      const chart = this.getRoot();
      const chartGroup = chart.getContext().canvas.getRoot();
      return chartGroup.getElementById(key);
    }
    /**
     * Show the view.
     */
    show() {
      const group3 = this.getGroup();
      if (!group3)
        return;
      !group3.isVisible() && show2(group3);
    }
    /**
     * Hide the view.
     */
    hide() {
      const group3 = this.getGroup();
      if (!group3)
        return;
      group3.isVisible() && hide2(group3);
    }
  };
  CompositionNode = __decorate2([
    defineProps(compositionProps)
  ], CompositionNode);

  // node_modules/@antv/g2/esm/api/mark.js
  var __decorate3 = function(decorators, target, key, desc) {
    var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d3 = decorators[i]) r = (c5 < 3 ? d3(r) : c5 > 3 ? d3(target, key, r) : d3(target, key)) || r;
    return c5 > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var MarkNode = class MarkNode2 extends Node5 {
    changeData(data2) {
      const chart = this.getRoot();
      if (!chart)
        return;
      this.attr("data", data2);
      return chart === null || chart === void 0 ? void 0 : chart.render();
    }
    /**
     * Get mark from chart views.
     */
    getMark() {
      var _a;
      const chartView = (_a = this.getRoot()) === null || _a === void 0 ? void 0 : _a.getView();
      if (!chartView)
        return void 0;
      const { markState } = chartView;
      const markKey = Array.from(markState.keys()).find((item) => item.key === this.attr("key"));
      return markState.get(markKey);
    }
    /**
     * Get all scales instance.
     */
    getScale() {
      var _a;
      const chartView = (_a = this.getRoot()) === null || _a === void 0 ? void 0 : _a.getView();
      if (!chartView)
        return void 0;
      return chartView === null || chartView === void 0 ? void 0 : chartView.scale;
    }
    /**
     * Get the scale instance by channel.
     */
    getScaleByChannel(channel) {
      var _a, _b;
      const chartView = (_a = this.getRoot()) === null || _a === void 0 ? void 0 : _a.getView();
      if (!chartView)
        return void 0;
      return (_b = chartView === null || chartView === void 0 ? void 0 : chartView.scale) === null || _b === void 0 ? void 0 : _b[channel];
    }
    /**
     * Get canvas group.
     */
    getGroup() {
      const key = this.attr("key");
      if (!key)
        return void 0;
      const chart = this.getRoot();
      const chartGroup = chart.getContext().canvas.getRoot();
      return chartGroup.getElementById(key);
    }
  };
  MarkNode = __decorate3([
    defineProps(markProps)
  ], MarkNode);

  // node_modules/@antv/g2/esm/api/runtime.js
  var __decorate4 = function(decorators, target, key, desc) {
    var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d3 = decorators[i]) r = (c5 < 3 ? d3(r) : c5 > 3 ? d3(target, key, r) : d3(target, key)) || r;
    return c5 > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __rest90 = function(s3, e3) {
    var t = {};
    for (var p2 in s3) if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t[p2] = s3[p2];
    if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s3); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i]))
          t[p2[i]] = s3[p2[i]];
      }
    return t;
  };
  var G2_CHART_KEY = "G2_CHART_KEY";
  var Runtime = class extends CompositionNode {
    constructor(options) {
      const { container, canvas, renderer, plugins: plugins2, lib, createCanvas } = options, rest = __rest90(options, ["container", "canvas", "renderer", "plugins", "lib", "createCanvas"]);
      super(rest, "view");
      this._hasBindAutoFit = false;
      this._rendering = false;
      this._trailing = false;
      this._trailingResolve = null;
      this._trailingReject = null;
      this._previousDefinedType = null;
      this._onResize = debounce_default(() => {
        this.forceFit();
      }, 300);
      this._renderer = renderer || new Renderer2();
      this._plugins = plugins2 || [];
      this._container = normalizeContainer2(container);
      this._emitter = new esm_default();
      this._context = {
        library: Object.assign(Object.assign({}, lib), library),
        emitter: this._emitter,
        canvas,
        createCanvas
      };
      this._create();
    }
    render() {
      if (this._rendering)
        return this._addToTrailing();
      if (!this._context.canvas)
        this._createCanvas();
      this._context.canvas.getConfig().supportsCSSTransform = true;
      this._bindAutoFit();
      this._rendering = true;
      const finished = new Promise((resolve2, reject2) => render(this._computedOptions(), this._context, this._createResolve(resolve2), this._createReject(reject2)));
      const [finished1, resolve, reject] = createEmptyPromise();
      finished.then(resolve).catch(reject).then(() => this._renderTrailing());
      return finished1;
    }
    /**
     * @overload
     * @param {G2ViewTree} [options]
     * @returns {Runtime|Spec}
     */
    options(options) {
      if (arguments.length === 0)
        return optionsOf(this);
      const { type } = options;
      if (type)
        this._previousDefinedType = type;
      updateRoot(this, options, this._previousDefinedType, this._marks, this._compositions);
      return this;
    }
    getContainer() {
      return this._container;
    }
    getContext() {
      return this._context;
    }
    on(event, callback, once) {
      this._emitter.on(event, callback, once);
      return this;
    }
    once(event, callback) {
      this._emitter.once(event, callback);
      return this;
    }
    emit(event, ...args) {
      this._emitter.emit(event, ...args);
      return this;
    }
    off(event, callback) {
      this._emitter.off(event, callback);
      return this;
    }
    clear() {
      const options = this.options();
      this.emit(ChartEvent.BEFORE_CLEAR);
      this._reset();
      destroy2(options, this._context, false);
      this.emit(ChartEvent.AFTER_CLEAR);
    }
    destroy() {
      const options = this.options();
      this.emit(ChartEvent.BEFORE_DESTROY);
      this._unbindAutoFit();
      this._reset();
      destroy2(options, this._context, true);
      if (this._container[REMOVE_FLAG])
        removeContainer(this._container);
      this.emit(ChartEvent.AFTER_DESTROY);
    }
    forceFit() {
      this.options["autoFit"] = true;
      const { width, height } = sizeOf2(this.options(), this._container);
      if (width === this._width && height === this._height) {
        return Promise.resolve(this);
      }
      this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
      const finished = this.render();
      finished.then(() => {
        this.emit(ChartEvent.AFTER_CHANGE_SIZE);
      });
      return finished;
    }
    changeSize(width, height) {
      if (width === this._width && height === this._height) {
        return Promise.resolve(this);
      }
      this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
      this.attr("width", width);
      this.attr("height", height);
      const finished = this.render();
      finished.then(() => {
        this.emit(ChartEvent.AFTER_CHANGE_SIZE);
      });
      return finished;
    }
    _create() {
      const { library: library3 } = this._context;
      const isMark2 = (key) => key.startsWith("mark.") || key === "component.axisX" || key === "component.axisY" || key === "component.legends";
      const marks = [
        "mark.mark",
        ...Object.keys(library3).filter(isMark2)
      ];
      this._marks = {};
      for (const key of marks) {
        const name2 = key.split(".").pop();
        class Mark2 extends MarkNode {
          constructor() {
            super({}, name2);
          }
        }
        this._marks[name2] = Mark2;
        this[name2] = function(composite) {
          const node = this.append(Mark2);
          if (name2 === "mark")
            node.type = composite;
          return node;
        };
      }
      const compositions = [
        "composition.view",
        ...Object.keys(library3).filter((key) => key.startsWith("composition.") && key !== "composition.mark")
      ];
      this._compositions = Object.fromEntries(compositions.map((key) => {
        const name2 = key.split(".").pop();
        let Composition = class Composition extends CompositionNode {
          constructor() {
            super({}, name2);
          }
        };
        Composition = __decorate4([
          defineProps(nodeProps(this._marks))
        ], Composition);
        return [name2, Composition];
      }));
      for (const Ctor of Object.values(this._compositions)) {
        defineProps(nodeProps(this._compositions))(Ctor);
      }
      for (const key of compositions) {
        const name2 = key.split(".").pop();
        this[name2] = function() {
          const Composition = this._compositions[name2];
          this.type = null;
          return this.append(Composition);
        };
      }
    }
    _reset() {
      const KEYS = ["theme", "type", "width", "height", "autoFit"];
      this.type = "view";
      this.value = Object.fromEntries(Object.entries(this.value).filter(([key]) => key.startsWith("margin") || key.startsWith("padding") || key.startsWith("inset") || KEYS.includes(key)));
      this.children = [];
    }
    _renderTrailing() {
      if (!this._trailing)
        return;
      this._trailing = false;
      this.render().then(() => {
        const trailingResolve = this._trailingResolve.bind(this);
        this._trailingResolve = null;
        trailingResolve(this);
      }).catch((error4) => {
        const trailingReject = this._trailingReject.bind(this);
        this._trailingReject = null;
        trailingReject(error4);
      });
    }
    _createResolve(resolve) {
      return () => {
        this._rendering = false;
        resolve(this);
      };
    }
    _createReject(reject) {
      return (error4) => {
        this._rendering = false;
        reject(error4);
      };
    }
    // Update actual size and key.
    _computedOptions() {
      const options = this.options();
      const { key = G2_CHART_KEY } = options;
      const { width, height, depth } = sizeOf2(options, this._container);
      this._width = width;
      this._height = height;
      this._key = key;
      return Object.assign(Object.assign({ key: this._key }, options), { width, height, depth });
    }
    // Create canvas if it does not exist.
    // DragAndDropPlugin is for interaction.
    // It is OK to register more than one time, G will handle this.
    _createCanvas() {
      const { width, height } = sizeOf2(this.options(), this._container);
      this._plugins.push(new Plugin7());
      this._plugins.forEach((d3) => this._renderer.registerPlugin(d3));
      this._context.canvas = new Canvas({
        container: this._container,
        width,
        height,
        renderer: this._renderer
      });
    }
    _addToTrailing() {
      var _a;
      (_a = this._trailingResolve) === null || _a === void 0 ? void 0 : _a.call(this, this);
      this._trailing = true;
      const promise = new Promise((resolve, reject) => {
        this._trailingResolve = resolve;
        this._trailingReject = reject;
      });
      return promise;
    }
    _bindAutoFit() {
      const options = this.options();
      const { autoFit } = options;
      if (this._hasBindAutoFit) {
        if (!autoFit)
          this._unbindAutoFit();
        return;
      }
      if (autoFit) {
        this._hasBindAutoFit = true;
        window.addEventListener("resize", this._onResize);
      }
    }
    _unbindAutoFit() {
      if (this._hasBindAutoFit) {
        this._hasBindAutoFit = false;
        window.removeEventListener("resize", this._onResize);
      }
    }
  };

  // node_modules/@antv/g2/esm/index.js
  var library2 = Object.assign({}, stdlib());
  var Chart = extend6(Runtime, library2);

  // engine/rails_design/app/javascripts/stimulus_antv/antv-line.js
  var antv_line_default = class extends Controller {
    static values = {
      url: String
    };
    connect() {
      this.chart = new Chart({
        container: this.element,
        autoFit: true
      });
      this.chart.options({
        data: {
          type: "fetch",
          value: this.urlValue,
          format: "json"
        },
        encode: {
          x: "year",
          y: "value"
        }
      });
      this.chart.axis("y", { labelFormatter: (v) => `${v}`.replace(/\d{1,3}(?=(\d{3})+$)/g, (s3) => `${s3},`) });
      this.chart.line().encode("shape", "smooth");
      this.chart.point().encode("shape", "point").tooltip(false);
      this.chart.render();
    }
    disconnect() {
      this.chart.destroy();
    }
  };

  // engine/rails_design/app/javascripts/stimulus_antv/index.js
  application.register("antv-line", antv_line_default);

  // engine/rails_design/app/javascripts/stimulus_bulma/bulma-menu.js
  var bulma_menu_default = class extends Controller {
    static values = {
      openClass: String,
      closeClass: String
    };
    toggle() {
      this.element.classList.toggle("is-active");
    }
    enter(event) {
      const ele = event.currentTarget;
      Array.from(ele.parentNode.children).filter((el) => el.classList.contains("is-active")).forEach((i) => {
        i.classList.remove("is-active");
      });
      ele.classList.add("is-active");
    }
    expand(event) {
      let expander = event.currentTarget;
      if (expander.nextElementSibling !== null) {
        expander.nextElementSibling.classList.toggle("display-none");
      }
      if (expander.lastElementChild !== null) {
        expander.lastElementChild.classList.toggle(this.closeClass);
        expander.lastElementChild.classList.toggle(this.openClass);
      }
    }
    get closeClass() {
      return this.openClassValue || "fa-angle-left";
    }
    get openClass() {
      return this.closeClassValue || "fa-angle-down";
    }
  };

  // engine/rails_design/app/javascripts/stimulus_bulma/bulma-modal.js
  var I18N = {
    zh: "\u5DF2\u6539\u53D8\uFF0C\u786E\u8BA4\u5173\u95ED\uFF1F",
    en: " is changed, Are You Sure?"
  };
  var bulma_modal_default = class extends base_controller_default {
    connect() {
      document.documentElement.classList.add("clipped");
    }
    close() {
      if (this.closeCheck()) {
        this.element.remove();
      }
    }
    submitClose(e3) {
      const ele = e3.currentTarget;
      if (this.closeCheck()) {
        ele.form.requestSubmit();
        this.element.remove();
      }
    }
    hide() {
      if (this.closeCheck()) {
        this.element.classList.remove("is-active");
        document.documentElement.classList.remove("clipped");
      }
    }
    show() {
      this.element.classList.add("is-active");
    }
    toggle() {
      if (this.element.classList.contains("is-active")) {
        this.close();
      } else {
        this.show();
      }
    }
    disconnect() {
      document.documentElement.classList.remove("clipped");
    }
    // 关闭前检查下有没有未提交的表单
    closeCheck() {
      let arr = [];
      Array.from(this.element.getElementsByTagName("input")).forEach((el) => {
        if (el.value !== el.defaultValue && el.labels[0]) {
          arr.push(el.labels[0].innerText);
        }
      });
      return arr.length === 0 || confirm(`${arr.join(",")}${I18N[this.locale]}`);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_bulma/bulma-navbar.js
  var bulma_navbar_default = class extends Controller {
    static targets = ["menu", "old", "new"];
    static classes = ["old", "new"];
    static values = {
      scroll: Boolean
    };
    connect() {
      this.scrollLook();
    }
    scrollLook() {
      let scrollEle, scrollEvent;
      if (this.element.parentNode === document.body) {
        scrollEle = document.documentElement;
        scrollEvent = document;
      } else {
        scrollEle = this.element.parentNode;
        scrollEvent = scrollEle;
      }
      if (this.scrollValue) {
        scrollEvent.addEventListener("scroll", () => {
          if (scrollEle.scrollTop > 0) {
            this.element.classList.replace(this.oldClass, this.newClass);
            this.oldTargets.forEach((el) => {
              el.classList.add("display-none");
            });
            this.newTargets.forEach((el) => {
              el.classList.remove("display-none");
            });
          } else {
            this.element.classList.replace(this.newClass, this.oldClass);
            this.newTargets.forEach((el) => {
              el.classList.add("display-none");
            });
            this.oldTargets.forEach((el) => {
              el.classList.remove("display-none");
            });
          }
        });
      }
    }
    toggle(element) {
      element.currentTarget.classList.toggle("is-active");
      this.menuTarget.classList.toggle("is-active");
    }
  };

  // engine/rails_design/app/javascripts/stimulus_bulma/bulma-skeleton.js
  var bulma_skeleton_default = class extends Controller {
    appear(event) {
      const ele = event.currentTarget;
      ele.parentNode.classList.remove("is-skeleton");
    }
  };

  // engine/rails_design/app/javascripts/stimulus_bulma/index.js
  application.register("menu", bulma_menu_default);
  application.register("modal", bulma_modal_default);
  application.register("navbar", bulma_navbar_default);
  application.register("skeleton", bulma_skeleton_default);

  // engine/rails_design/app/javascripts/stimulus_form/check.js
  var I18N2 = {
    zh: "\u5DF2\u9009\u62E9 {value}",
    en: "{value} Selected"
  };
  var check_default = class extends base_controller_default {
    static outlets = ["form"];
    static targets = ["all"];
    static values = {
      container: String,
      range: String,
      total: { type: String, default: "check_total" }
    };
    connect() {
      for (const ingredient of this.checkboxes) {
        if (ingredient.dataset.all) {
          ingredient.dataset.all = ingredient.dataset.all.concat(`, #${this.element.id}`);
        } else {
          ingredient.dataset.all = `#${this.element.id}`;
        }
        ingredient.addEventListener("change", this.updateDisplay);
      }
    }
    // checkbox data-action="check#toggleAll"
    toggleAll(event) {
      const element = event.currentTarget;
      const ids = [];
      for (const checkbox of this.checkboxes) {
        if (!checkbox.disabled) {
          ids.push(checkbox.value);
          checkbox.checked = element.checked;
          checkbox.dispatchEvent(new Event("input"));
          const all = checkbox.dataset.all.split(", ").filter((el) => el !== `#${this.element.id}`).join(", ");
          if (all) {
            console.debug(all);
            const cons = document.querySelectorAll(all);
            cons.forEach((ele) => {
              const con = ele.getController("check");
              con.computeDisplay();
            });
          }
        }
      }
      if (element.checked) {
        this.showCommits(ids);
      } else {
        this.hiddenCommits();
      }
    }
    showCommits(ids) {
      this.formOutlets.forEach((el) => {
        if (ids.length > 0) {
          if (el.hasSubmitTarget) {
            el.submitTarget.disabled = false;
          }
          if (el.hasIdsTarget) {
            el.idsTarget.value = ids;
          }
        }
      });
      if (this.totalContainer) {
        const word2 = I18N2[this.locale];
        this.totalContainer.innerText = word2.replace("{value}", ids.length);
      }
    }
    hiddenCommits() {
      this.formOutlets.forEach((el) => {
        if (el.hasSubmitTarget) {
          el.submitTarget.disabled = true;
        }
        if (el.hasIdsTarget) {
          el.idsTarget.value = "";
        }
      });
      if (this.totalContainer) {
        this.totalContainer.innerText = "";
      }
    }
    // NOTICE: this become event
    updateDisplay(event) {
      const cons = document.querySelectorAll(event.currentTarget.dataset.all);
      cons.forEach((ele) => {
        const con = ele.getController("check");
        con.computeDisplay();
      });
    }
    computeDisplay() {
      let checkedCount = 0;
      const ids = [];
      const overall = this.allTarget;
      for (const ingredient of this.checkboxes) {
        if (ingredient.checked) {
          checkedCount++;
          ids.push(ingredient.value);
        }
      }
      if (checkedCount === 0) {
        overall.checked = false;
        overall.indeterminate = false;
        this.hiddenCommits();
      } else if (checkedCount === this.checkboxes.length) {
        overall.checked = true;
        overall.indeterminate = false;
        this.showCommits(ids);
      } else {
        overall.checked = false;
        overall.indeterminate = true;
        this.showCommits(ids);
      }
    }
    get checkboxes() {
      if (this.hasContainerValue) {
        const container = document.getElementById(this.containerValue);
        return container.querySelectorAll(`input[type=checkbox][name^='${this.allTarget.value}']`);
      } else if (this.hasRangeValue) {
        return document.querySelectorAll(`[id^=${this.rangeValue}] input[type=checkbox][name^='${this.allTarget.value}']`);
      } else {
        return document.querySelectorAll(`input[type=checkbox][name^='${this.allTarget.value}']`);
      }
    }
    get totalContainer() {
      return document.getElementById(this.totalValue);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/coeff.js
  var coeff_default = class extends Controller {
    static targets = ["quantity", "total", "single"];
    updateSingle(event) {
      const single = event.currentTarget;
      let quantity = this.quantityTarget;
      let result = (single.value * quantity.value).toFixed(2);
      if (this.hasTotalTarget) {
        this.totalTarget.value = result;
      }
    }
    updateQuantity(event) {
      let quantity = event.currentTarget;
      let single = this.singleTarget;
      let result = (single.value * quantity.value).toFixed(2);
      if (this.hasTotalTarget) {
        this.totalTarget.value = result;
      }
    }
    updateTotal(event) {
      let total = event.currentTarget;
      let quantity = this.quantityTarget;
      let result = (total.value / quantity.value).toFixed(2);
      if (this.hasSingleTarget) {
        this.singleTarget.value = result;
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/color-range.js
  var color_range_default = class extends Controller {
    static targets = ["hue", "saturation", "lightness"];
    static values = {
      id: String
    };
    // data-action="click->field#add"
    hue() {
      this.changeAll();
    }
    saturation() {
      this.changeAll();
    }
    lightness() {
      this.changeAll();
    }
    changeAll() {
      const color2 = `hsl(${this.hueTarget.value}, ${this.saturationTarget.value}%, ${this.lightnessTarget.value}%)`;
      const darker2 = (this.lightnessTarget.value * 0.8).toFixed();
      const colorDarker = `hsl(${this.hueTarget.value}, ${this.saturationTarget.value}%, ${darker2}%)`;
      this.saturationTarget.setAttribute("style", `background-image: linear-gradient(to right, hsl(${this.hueTarget.value}, 0%, ${this.lightnessTarget.value}%), hsl(${this.hueTarget.value}, 50%, ${this.lightnessTarget.value}%), hsl(${this.hueTarget.value}, 100%, ${this.lightnessTarget.value}%))`);
      this.lightnessTarget.setAttribute("style", `background-image: linear-gradient(to right, hsl(${this.hueTarget.value}, ${this.saturationTarget.value}%, 0%), hsl(${this.hueTarget.value}, ${this.saturationTarget.value}%, 50%), hsl(${this.hueTarget.value}, ${this.saturationTarget.value}%, 100%))`);
      document.getElementById(this.idValue).setAttribute("style", `--admin-menu: ${color2}; --admin-menu-darker: ${colorDarker}`);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/enter.js
  var enter_default = class extends Controller {
    static targets = ["input"];
    static values = {
      index: Number,
      label: Boolean
    };
    // data-action="click->field#add"
    open() {
      this.element.querySelectorAll("input").forEach((el) => {
        el.disabled = false;
      });
    }
    close() {
      this.element.querySelectorAll("input").forEach((el) => {
        el.disabled = true;
      });
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/equal.js
  var equal_default = class extends Controller {
    static targets = ["goal"];
    static values = {
      plus: Object
    };
    update(event) {
      const ele = event.currentTarget;
      if (parseFloat(ele.value) > parseFloat(this.goalTarget.value)) {
        this.goalTarget.value = ele.value;
      }
    }
    updateTime(event) {
      const ele = event.currentTarget;
      const dt = DateTime.fromISO(ele.value).plus(this.plusValue).toFormat("yyyy-MM-dd'T'HH:mm:ss");
      if (this.goalTarget.value === this.goalTarget.defaultValue) {
        this.goalTarget.value = dt;
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/former.js
  var former_default = class extends base_controller_default {
    static values = {
      id: String,
      url: String
    };
    submit() {
      const ele = document.getElementById(this.idValue);
      this.formPost(ele);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/indeterminate.js
  var indeterminate_default = class extends Controller {
    static values = {
      partial: { type: Boolean, default: false }
    };
    connect() {
      if (this.partialValue) {
        this.element.indeterminate = true;
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/form.js
  var I18N3 = {
    zh: {
      badInput: "{label}\u683C\u5F0F\u4E0D\u6B63\u786E",
      customError: "{label}\u8F93\u5165\u9519\u8BEF",
      patternMismatch: "{label}\u4E0D\u7B26\u5408\u683C\u5F0F\u8981\u6C42",
      rangeOverflow: "{label}\u8D85\u51FA\u5141\u8BB8\u7684\u6700\u5927\u503C",
      rangeUnderflow: "{label}\u4F4E\u4E8E\u5141\u8BB8\u7684\u6700\u5C0F\u503C",
      stepMismatch: "{label}\u8F93\u5165\u9519\u8BEF",
      tooLong: "{label}\u592A\u957F\u4E86",
      tooShort: "{label}\u592A\u77ED\u4E86",
      typeMismatch: "{label}\u8F93\u5165\u9519\u8BEF",
      valid: "{label}\u4E3A\u975E\u6CD5\u503C",
      valueMissing: "\u8BF7\u8F93\u5165{label}"
    },
    en: {
      badInput: "Bad Input: {label}",
      customError: "Custom Error: {label}",
      patternMismatch: "Invalid Input: {label}",
      rangeOverflow: "Range Over Flow: {label}",
      rangeUnderflow: "Range Under Flow: {label}",
      stepMismatch: "Step Mismatch",
      tooLong: "{label} is too long",
      tooShort: "{label} is Too Short",
      typeMismatch: "{label} Type Mismatch",
      valid: "{label} is not valid",
      valueMissing: "Please enter: {label}"
    }
  };
  var form_default = class extends base_controller_default {
    static targets = ["ids", "submit"];
    static values = {
      css: { type: String, default: "is-danger" }
    };
    connect() {
      this.setMinLength();
    }
    defaultValid(input) {
      let label, word2;
      for (let key in input.validity) {
        if (input.validity[key]) {
          word2 = I18N3[this.locale][key];
        }
      }
      if (input.labels.length > 0) {
        label = input.labels[0].innerText;
      } else {
        label = input.dataset["label"] || "";
      }
      const text = word2.replace("{label}", label);
      input.classList.add(this.cssValue);
      if (!input.parentNode.nextElementSibling) {
        const help = document.createElement("p");
        help.classList.add("help", this.cssValue);
        help.innerText = text;
        input.parentNode.after(help);
      }
    }
    defaultClear(input) {
      if (input.validity.valid) {
        input.classList.remove(this.cssValue);
        let help = input.parentNode.nextElementSibling;
        if (help && help.classList.contains("help") && help.classList.contains(this.cssValue)) {
          help.remove();
        }
      }
    }
    // data-action="blur->default_valid#check"
    check(event) {
      event.currentTarget.checkValidity();
    }
    // data-action="input->default_valid#clear"
    clear(event) {
      this.defaultClear(event.currentTarget);
    }
    // data-action="invalid->default_valid#notice"
    notice(event) {
      event.preventDefault();
      this.defaultValid(event.currentTarget);
    }
    // data-action="change->form#xx"
    tip(event) {
      const ele = event.currentTarget;
      if (ele.defaultValue !== ele.value) {
        ele.classList.add("is-warning");
      } else {
        ele.classList.remove("is-warning");
      }
    }
    // form[method="get"]
    // submit->xx
    filter(event) {
      const ele = event.currentTarget;
      for (let el of ele.form.elements) {
        if (el.value) {
        } else {
          el.disabled = true;
        }
      }
    }
    focusEnd(event) {
      const ele = event.currentTarget;
      if (ele.type === "text") {
        ele.setSelectionRange(0, ele.value.length);
      }
    }
    setMinLength() {
      const labels = Array.from(this.element.querySelectorAll(".field-label > label.label"));
      const lengths = labels.map((i) => i.innerText.length);
      const max11 = Math.max.apply(null, lengths);
      Array.from(this.element.getElementsByClassName("field-label")).forEach((i) => {
        i.style.minWidth = `${max11}ch`;
      });
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/input.js
  var input_default = class extends base_controller_default {
    static targets = ["checkbox"];
    static values = {
      force: Boolean
    };
    // <label data-action="click->input#check"></label>
    // label out of check
    check() {
      if (this.hasCheckboxTarget) {
        this.checkboxTarget.checked = !this.checkboxTarget.checked;
        this.checkboxTarget.form.requestSubmit();
      }
    }
    // label wrap input
    toggle() {
      if (this.hasCheckboxTarget) {
        const form = new FormData(this.checkboxTarget.form);
        form.append("checked", this.checkboxTarget.checked);
        this.request(this.checkboxTarget.form.action, this.checkboxTarget.form.method, form);
      }
    }
    link(event) {
      const ele = event.currentTarget;
      this.inputGet(ele);
    }
    form(event) {
      const el = event.currentTarget;
      if (el.value.length > 0 || this.forceValue) {
        el.form.requestSubmit();
      }
    }
    filter(event) {
      const ele = event.currentTarget;
      if (!ele.value) {
        return;
      }
      ele.form.requestSubmit();
    }
    remove() {
      this.element.remove();
    }
    // focus->form#blank
    blank(event) {
      const ele = event.currentTarget;
      ele.lastValue = ele.value;
      ele.value = "";
      ele.addEventListener("blur", this.restoreLastValue, { once: true });
    }
    restoreLastValue(event) {
      const ele = event.currentTarget;
      if (isNaN(ele.valueAsNumber)) {
        ele.value = ele.lastValue;
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/keyboard.js
  var keyboard_default = class extends Controller {
    static targets = ["submit"];
    static values = {
      id: String,
      dot: String,
      digit: Number
    };
    enter(event) {
      const element = event.currentTarget;
      let value2;
      if (this.dotElement.hidden) {
        value2 = this.input.value.concat(element.innerText);
      } else {
        value2 = this.input.value.concat(".", element.innerText);
        this.dotElement.hidden = true;
      }
      if (this.hasDigitValue) {
        if (value2.includes(".")) {
          let [left2, right2] = value2.split(".");
          if (right2.length > this.digitValue) {
            this.input.value = [left2, right2.slice(0, this.digitValue)].join(".");
          } else {
            this.input.value = value2;
          }
        } else {
          this.input.value = value2;
        }
      } else {
        this.input.value = value2;
      }
      if (this.input.valueAsNumber > 0) {
        this.submitTarget.disabled = false;
      }
      this.input.dispatchEvent(new Event("input"));
    }
    zeroEnter(event) {
      if (this.input.valueAsNumber !== 0 || this.dotElement.hidden === false) {
        this.enter(event);
      }
    }
    dot() {
      if (this.input.value.includes(".")) {
      } else if (this.input.value === "") {
        this.input.value = "0";
        this.dotElement.hidden = false;
      } else {
        this.dotElement.hidden = false;
      }
    }
    backspace() {
      this.input.value = this.input.value.slice(0, -1);
      if (this.input.value === "") {
        this.dotElement.hidden = true;
      }
      if (this.input.value === "" || this.input.valueAsNumber === 0) {
        this.submitTarget.disabled = true;
      }
    }
    get input() {
      return document.getElementById(this.idValue);
    }
    get dotElement() {
      return document.getElementById(this.dotValue);
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/modify.js
  var modify_default = class extends Controller {
    static targets = ["input"];
    static values = {
      step: { type: Number, default: 1 },
      submit: { type: Boolean, default: false },
      total: Number,
      quantity: String
    };
    plus() {
      this.inputTarget.value = Number(parseFloat(this.inputTarget.value || 0) + this.step).toFixed(this.digit);
      this.inputTarget.dispatchEvent(new Event("change"));
      if (this.submitValue) {
        this.inputTarget.form.requestSubmit();
      }
      if (this.hasQuantityValue) {
        this.doDivide(this.inputTarget.value);
      }
    }
    minus() {
      if (this.inputTarget.value >= this.step) {
        this.inputTarget.value = Number(parseFloat(this.inputTarget.value || 0) - this.step).toFixed(this.digit);
        this.inputTarget.dispatchEvent(new Event("change"));
        if (this.submitValue) {
          this.inputTarget.form.requestSubmit();
        }
        if (this.hasQuantityValue) {
          this.doDivide(this.inputTarget.value);
        }
      }
    }
    divide(event) {
      this.doDivide(event.currentTarget.value);
    }
    doDivide(value2) {
      if (value2 !== 0) {
        this.quantity.innerText = Math.floor(this.totalValue / value2);
      }
    }
    get quantity() {
      return document.getElementById(this.quantityValue);
    }
    get step() {
      if (this.hasStepValue) {
        return this.stepValue;
      } else {
        return parseFloat(this.inputTarget.step);
      }
    }
    get digit() {
      return String(this.step).split(".")[1]?.length || 0;
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/picker.js
  var picker_default = class extends base_controller_default {
    static values = {
      id: String,
      input: String
    };
    static outlets = ["modal"];
    confirmValue() {
      const input = document.getElementById(this.idValue);
      input.value = this.inputValue;
      this.modalOutletElement.remove();
    }
    clear(node) {
      let el = node.nextElementSibling;
      while (el) {
        el.remove();
        el = node.nextElementSibling;
      }
    }
  };

  // node_modules/@rails/activestorage/src/file_checksum.js
  var import_spark_md5 = __toESM(require_spark_md5());
  var fileSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
  var FileChecksum = class _FileChecksum {
    static create(file, callback) {
      const instance = new _FileChecksum(file);
      instance.create(callback);
    }
    constructor(file) {
      this.file = file;
      this.chunkSize = 2097152;
      this.chunkCount = Math.ceil(this.file.size / this.chunkSize);
      this.chunkIndex = 0;
    }
    create(callback) {
      this.callback = callback;
      this.md5Buffer = new import_spark_md5.default.ArrayBuffer();
      this.fileReader = new FileReader();
      this.fileReader.addEventListener("load", (event) => this.fileReaderDidLoad(event));
      this.fileReader.addEventListener("error", (event) => this.fileReaderDidError(event));
      this.readNextChunk();
    }
    fileReaderDidLoad(event) {
      this.md5Buffer.append(event.target.result);
      if (!this.readNextChunk()) {
        const binaryDigest = this.md5Buffer.end(true);
        const base64digest = btoa(binaryDigest);
        this.callback(null, base64digest);
      }
    }
    fileReaderDidError(event) {
      this.callback(`Error reading ${this.file.name}`);
    }
    readNextChunk() {
      if (this.chunkIndex < this.chunkCount || this.chunkIndex == 0 && this.chunkCount == 0) {
        const start2 = this.chunkIndex * this.chunkSize;
        const end = Math.min(start2 + this.chunkSize, this.file.size);
        const bytes = fileSlice.call(this.file, start2, end);
        this.fileReader.readAsArrayBuffer(bytes);
        this.chunkIndex++;
        return true;
      } else {
        return false;
      }
    }
  };

  // node_modules/@rails/activestorage/src/helpers.js
  function getMetaValue(name2) {
    const element = findElement(document.head, `meta[name="${name2}"]`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  function findElement(root2, selector) {
    if (typeof root2 == "string") {
      selector = root2;
      root2 = document;
    }
    return root2.querySelector(selector);
  }
  function dispatchEvent3(element, type, eventInit = {}) {
    const { disabled } = element;
    const { bubbles, cancelable, detail } = eventInit;
    const event = document.createEvent("Event");
    event.initEvent(type, bubbles || true, cancelable || true);
    event.detail = detail || {};
    try {
      element.disabled = false;
      element.dispatchEvent(event);
    } finally {
      element.disabled = disabled;
    }
    return event;
  }

  // node_modules/@rails/activestorage/src/blob_record.js
  var BlobRecord = class {
    constructor(file, checksum, url, customHeaders = {}) {
      this.file = file;
      this.attributes = {
        filename: file.name,
        content_type: file.type || "application/octet-stream",
        byte_size: file.size,
        checksum
      };
      this.xhr = new XMLHttpRequest();
      this.xhr.open("POST", url, true);
      this.xhr.responseType = "json";
      this.xhr.setRequestHeader("Content-Type", "application/json");
      this.xhr.setRequestHeader("Accept", "application/json");
      this.xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
      Object.keys(customHeaders).forEach((headerKey) => {
        this.xhr.setRequestHeader(headerKey, customHeaders[headerKey]);
      });
      const csrfToken = getMetaValue("csrf-token");
      if (csrfToken != void 0) {
        this.xhr.setRequestHeader("X-CSRF-Token", csrfToken);
      }
      this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
      this.xhr.addEventListener("error", (event) => this.requestDidError(event));
    }
    get status() {
      return this.xhr.status;
    }
    get response() {
      const { responseType, response } = this.xhr;
      if (responseType == "json") {
        return response;
      } else {
        return JSON.parse(response);
      }
    }
    create(callback) {
      this.callback = callback;
      this.xhr.send(JSON.stringify({ blob: this.attributes }));
    }
    requestDidLoad(event) {
      if (this.status >= 200 && this.status < 300) {
        const { response } = this;
        const { direct_upload } = response;
        delete response.direct_upload;
        this.attributes = response;
        this.directUploadData = direct_upload;
        this.callback(null, this.toJSON());
      } else {
        this.requestDidError(event);
      }
    }
    requestDidError(event) {
      this.callback(`Error creating Blob for "${this.file.name}". Status: ${this.status}`);
    }
    toJSON() {
      const result = {};
      for (const key in this.attributes) {
        result[key] = this.attributes[key];
      }
      return result;
    }
  };

  // node_modules/@rails/activestorage/src/blob_upload.js
  var BlobUpload = class {
    constructor(blob) {
      this.blob = blob;
      this.file = blob.file;
      const { url, headers } = blob.directUploadData;
      this.xhr = new XMLHttpRequest();
      this.xhr.open("PUT", url, true);
      this.xhr.responseType = "text";
      for (const key in headers) {
        this.xhr.setRequestHeader(key, headers[key]);
      }
      this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
      this.xhr.addEventListener("error", (event) => this.requestDidError(event));
    }
    create(callback) {
      this.callback = callback;
      this.xhr.send(this.file.slice());
    }
    requestDidLoad(event) {
      const { status, response } = this.xhr;
      if (status >= 200 && status < 300) {
        this.callback(null, response);
      } else {
        this.requestDidError(event);
      }
    }
    requestDidError(event) {
      this.callback(`Error storing "${this.file.name}". Status: ${this.xhr.status}`);
    }
  };

  // node_modules/@rails/activestorage/src/direct_upload.js
  var id4 = 0;
  var DirectUpload = class {
    constructor(file, url, delegate, customHeaders = {}) {
      this.id = ++id4;
      this.file = file;
      this.url = url;
      this.delegate = delegate;
      this.customHeaders = customHeaders;
    }
    create(callback) {
      FileChecksum.create(this.file, (error4, checksum) => {
        if (error4) {
          callback(error4);
          return;
        }
        const blob = new BlobRecord(this.file, checksum, this.url, this.customHeaders);
        notify(this.delegate, "directUploadWillCreateBlobWithXHR", blob.xhr);
        blob.create((error5) => {
          if (error5) {
            callback(error5);
          } else {
            const upload = new BlobUpload(blob);
            notify(this.delegate, "directUploadWillStoreFileWithXHR", upload.xhr);
            upload.create((error6) => {
              if (error6) {
                callback(error6);
              } else {
                callback(null, blob.toJSON());
              }
            });
          }
        });
      });
    }
  };
  function notify(object, methodName, ...messages) {
    if (object && typeof object[methodName] == "function") {
      return object[methodName](...messages);
    }
  }

  // node_modules/@rails/activestorage/src/direct_upload_controller.js
  var DirectUploadController = class {
    constructor(input, file) {
      this.input = input;
      this.file = file;
      this.directUpload = new DirectUpload(this.file, this.url, this);
      this.dispatch("initialize");
    }
    start(callback) {
      const hiddenInput = document.createElement("input");
      hiddenInput.type = "hidden";
      hiddenInput.name = this.input.name;
      this.input.insertAdjacentElement("beforebegin", hiddenInput);
      this.dispatch("start");
      this.directUpload.create((error4, attributes) => {
        if (error4) {
          hiddenInput.parentNode.removeChild(hiddenInput);
          this.dispatchError(error4);
        } else {
          hiddenInput.value = attributes.signed_id;
        }
        this.dispatch("end");
        callback(error4);
      });
    }
    uploadRequestDidProgress(event) {
      const progress = event.loaded / event.total * 100;
      if (progress) {
        this.dispatch("progress", { progress });
      }
    }
    get url() {
      return this.input.getAttribute("data-direct-upload-url");
    }
    dispatch(name2, detail = {}) {
      detail.file = this.file;
      detail.id = this.directUpload.id;
      return dispatchEvent3(this.input, `direct-upload:${name2}`, { detail });
    }
    dispatchError(error4) {
      const event = this.dispatch("error", { error: error4 });
      if (!event.defaultPrevented) {
        alert(error4);
      }
    }
    // DirectUpload delegate
    directUploadWillCreateBlobWithXHR(xhr) {
      this.dispatch("before-blob-request", { xhr });
    }
    directUploadWillStoreFileWithXHR(xhr) {
      this.dispatch("before-storage-request", { xhr });
      xhr.upload.addEventListener("progress", (event) => this.uploadRequestDidProgress(event));
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/picture.js
  var picture_default = class extends Controller {
    static targets = ["src", "filename", "preview", "uploadDiv"];
    //<input type="file" data-action="picture#upload">
    upload(event) {
      const input = event.currentTarget;
      const button2 = input.form.querySelector("input[type=submit], button[type=submit]");
      input.disabled = true;
      button2.disabled = true;
      Array.from(input.files).forEach((file) => {
        this.filenameTarget.innerText = file.name;
        this.previewFile(file);
        let controller = new DirectUploadController(input, file);
        controller.start((error4) => {
          console.error("upload,er", error4);
          input.disabled = false;
          button2.disabled = false;
        });
      });
      input.value = null;
    }
    dropFile(event) {
      event.preventDefault();
      event.stopPropagation();
      for (var i = 0; i < event.dataTransfer.files.length; i++) {
        var file = e.dataTransfer.files[i];
        console.debug("drop\u6587\u4EF6", file.name);
      }
    }
    pasteFile(event) {
      const result = false;
      const clipboardData = event.clipboardData;
      let items;
      if (typeof clipboardData === "object") {
        items = clipboardData.items || clipboardData.files || [];
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          console.debug("\u7C98\u8D34", item);
        }
      }
      if (result) {
        event.preventDefault();
      }
    }
    previewFile(file) {
      const template = this.previewTarget;
      const cloned = template.cloneNode(true);
      cloned.style.display = "block";
      let img = cloned.querySelector("img");
      img.src = window.URL.createObjectURL(file);
      img.onload = function(e3) {
        console.debug(e3);
        window.URL.revokeObjectURL(img.src);
      };
      template.after(cloned);
    }
    removePreview(event) {
      const wrap = event.currentTarget.parentNode.parentNode;
      wrap.style.display = "none";
      wrap.querySelector("input").remove();
      const up = this.uploadDivTarget;
      const input = up.querySelector("input[type=file]");
      up.style.display = "block";
      input.disabled = false;
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/qq-map.js
  var qq_map_default = class extends Controller {
    static values = {
      name: String,
      index: Number,
      key: String
    };
    static targets = ["load"];
    connect() {
      const center2 = new TMap.LatLng(39.98412, 116.307484);
      this.map = new TMap.Map(this.element, {
        center: center2,
        zoom: 17.2
      });
    }
    selected(event) {
      this.doSelected(event);
    }
    select(event) {
      this.doSelected(event);
    }
    doSelected(event) {
      console.log("selected", event);
      const loc = event.data;
      if (loc && loc.module === "locationPicker") {
        if (this.hasIndexValue) {
          document.getElementById(`${this.nameValue}_${this.indexValue}_lat`).value = loc.latlng.lat;
          document.getElementById(`${this.nameValue}_${this.indexValue}_lng`).value = loc.latlng.lng;
          document.getElementById(`${this.nameValue}_${this.indexValue}_poiname`).value = loc.poiname;
          document.getElementById(`${this.nameValue}_${this.indexValue}_poiaddress`).value = loc.poiaddress;
          document.getElementById(`${this.nameValue}_${this.indexValue}_cityname`).value = loc.cityname;
          document.getElementById(`${this.indexValue}_name`).innerText = loc.poiname;
        } else {
          document.getElementById(`${this.nameValue}_lat`).value = loc.latlng.lat;
          document.getElementById(`${this.nameValue}_lng`).value = loc.latlng.lng;
          document.getElementById(`${this.nameValue}_poiname`).value = loc.poiname;
          document.getElementById(`${this.nameValue}_poiaddress`).value = loc.poiaddress;
          document.getElementById(`${this.nameValue}_cityname`).value = loc.cityname;
        }
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/search-input.js
  var search_input_default = class extends base_controller_default {
    static targets = ["input", "content"];
    static values = {
      url: String
    };
    connect() {
      this.initInput();
    }
    initInput() {
      const ele = this.inputTarget;
      ele.addEventListener("input", this.form);
      ele.addEventListener("compositionstart", (event) => {
        event.target.removeEventListener("input", this.form);
      });
      ele.addEventListener("compositionend", (event) => {
        event.target.addEventListener("input", this.form);
        this.conForm(ele);
      });
    }
    // NOTICE  here this becomes ele, who call addEventListener
    form() {
      const con = this.closest("[data-controller~=search-input]").getController("search-input");
      if (con.hasUrlValue) {
        con.inputPost(this);
      } else {
        this.form.requestSubmit();
      }
    }
    conForm(ele) {
      if (this.hasUrlValue) {
        this.inputPost(ele);
      } else {
        ele.form.requestSubmit();
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/taxon.js
  var taxon_default = class extends base_controller_default {
    static values = {
      url: String,
      title: String,
      params: Object
    };
    // change
    choose(event) {
      let ele = event.currentTarget;
      if (ele.value === "" || ele.value === null) {
        this.clear(this.element);
      } else {
        let search_url = new URL(this.urlValue, location.origin);
        search_url.searchParams.set("node_id", ele.value);
        search_url.searchParams.set("html_id", this.element.id);
        Object.keys(this.paramsValue).forEach((k) => {
          search_url.searchParams.set(k, this.paramsValue[k]);
        });
        fetch(search_url, {
          method: "GET",
          headers: {
            Accept: "text/vnd.turbo-stream.html"
          }
        }).then((response) => {
          return response.text();
        }).then((body) => {
          this.clear(this.element);
          Turbo.renderStreamMessage(body);
        });
      }
    }
    clear(node) {
      let el = node.nextElementSibling;
      while (el && el.dataset["taxonTitleValue"] === this.titleValue) {
        el.remove();
        el = node.nextElementSibling;
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/time-range.js
  var time_range_default = class extends Controller {
    static targets = ["start", "finish"];
    // action
    time(event) {
      const el = event.currentTarget;
      const start2 = el.dataset.startAt;
      const finish = el.dataset.finishAt;
      this.startTarget.value = start2;
      this.finishTarget.value = finish;
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/total.js
  var total_default = class extends Controller {
    static targets = [
      "reduce",
      "profit",
      // 按道理，可支持多个
      "total"
    ];
    updateReduce(event) {
      const reduce2 = event.currentTarget;
      if (this.hasTotalTarget) {
        const total = parseFloat(this.totalTarget.defaultValue || 0) + parseFloat(reduce2.value) - parseFloat(reduce2.defaultValue || 0);
        if (this.hasProfitTarget) {
          this.totalTarget.value = (total + parseFloat(this.profitTarget.value || 0)).toFixed(2);
        } else {
          this.totalTarget.value = total.toFixed(2);
        }
      }
    }
    updateProfit(event) {
      const profit = event.currentTarget;
      if (this.hasTotalTarget && this.hasReduceTarget) {
        this.totalTarget.value = (parseFloat(this.reduceTarget.value || 0) + parseFloat(profit.value)).toFixed(2);
      }
    }
    updateTotal(event) {
      const total = event.currentTarget;
      if (this.hasReduceTarget) {
        if (this.hasProfitTarget) {
          this.profitTarget.value = (parseFloat(total.value) - parseFloat(this.reduceTarget.value || 0)).toFixed(2);
        } else {
          const reduce2 = parseFloat(this.reduceTarget.defaultValue || 0) + parseFloat(total.value) - parseFloat(total.defaultValue || 0);
          this.reduceTarget.value = reduce2.toFixed(2);
        }
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/typer.js
  var typer_default = class extends base_controller_default {
    static targets = ["input", "value", "content"];
    static values = {
      url: String
    };
    connect() {
      this.initInput();
    }
    initInput() {
      const ele = this.inputTarget;
      ele.addEventListener("input", this.form);
      ele.addEventListener("compositionstart", (event) => {
        event.target.removeEventListener("input", this.form);
      });
      ele.addEventListener("compositionend", (event) => {
        event.target.addEventListener("input", this.form);
        this.conForm(ele);
      });
    }
    // NOTICE  here this becomes ele, who call addEventListener
    form() {
      const con = this.closest("[data-controller~=typer]").getController("typer");
      if (con.hasValueTarget) {
        con.valueTarget.removeAttribute("value");
        if (!this.value) {
          con.clear();
          return;
        }
      }
      if (con.hasUrlValue) {
        con.inputPost(this);
      } else {
        this.form.requestSubmit();
      }
    }
    conForm(ele) {
      this.valueTarget.removeAttribute("value");
      if (!ele.value) {
        this.clear();
        return;
      }
      if (this.hasUrlValue) {
        this.inputPost(ele);
      } else {
        ele.form.requestSubmit();
      }
    }
    clear() {
      Array.from(this.contentTarget.children).forEach((child) => {
        child.remove();
      });
    }
    // click->typer#choose
    choose(event) {
      const ele = event.currentTarget;
      this.valueTarget.value = ele.dataset["id"];
      this.inputTarget.value = ele.dataset["name"];
      ele.parentNode.replaceChildren();
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/field.js
  var field_default = class extends Controller {
    static targets = ["node"];
    static values = {
      index: Number,
      label: { type: String, default: "label.field_label" }
    };
    // data-action="click->field#add"
    add() {
      const el = this.element.cloneNode(true);
      const label = el.querySelector(this.labelValue);
      if (label) {
        label.innerText = "";
      }
      const next = this.element.nextElementSibling;
      let addIndex;
      if (next) {
        const nextItem = next.getController(this.identifier);
        if (nextItem && nextItem.indexValue > this.indexValue) {
          addIndex = (nextItem.indexValue - this.indexValue) / 2;
        } else {
          addIndex = 1;
        }
      } else {
        addIndex = 1;
      }
      const nextIndex = this.indexValue + addIndex;
      el.setAttribute("data-field-index-value", nextIndex);
      el.querySelectorAll("input, select").forEach((input) => {
        input.name = input.name.replace(`[${this.indexValue}]`, `[${nextIndex}]`);
        if (input.id) {
          input.id = input.id.replace(`${this.indexValue}`, `${nextIndex}`);
        }
        input.value = input.defaultValue;
        input.autofocus = true;
        if (input.type === "text") {
          input.setSelectionRange(0, input.value.length);
        }
      });
      if (this.element.parentNode) {
        this.element.parentNode.insertBefore(el, next);
      }
    }
    remove() {
      this.element.remove();
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/datetime.js
  var datetime_default = class extends Controller {
    // data-action="datetime#default"
    default(event) {
      const el = event.currentTarget;
      const date = new Date(el.value);
      const form = el.form;
      this.append(form, el.name.replace("(date)", "(1i)"), date.getFullYear());
      this.append(form, el.name.replace("(date)", "(2i)"), date.getMonth() + 1);
      this.append(form, el.name.replace("(date)", "(3i)"), date.getDate());
    }
    append(form, name2, value2) {
      let input = form.elements.namedItem(name2);
      if (input) {
        input.setAttribute("value", value2);
      } else {
        input = document.createElement("input");
        input.setAttribute("type", "hidden");
        input.setAttribute("name", name2);
        input.setAttribute("value", value2);
        this.element.appendChild(input);
      }
    }
  };

  // engine/rails_design/app/javascripts/stimulus_form/index.js
  application.register("check", check_default);
  application.register("coeff", coeff_default);
  application.register("color-range", color_range_default);
  application.register("enter", enter_default);
  application.register("equal", equal_default);
  application.register("former", former_default);
  application.register("indeterminate", indeterminate_default);
  application.register("form", form_default);
  application.register("input", input_default);
  application.register("keyboard", keyboard_default);
  application.register("modify", modify_default);
  application.register("picker", picker_default);
  application.register("picture", picture_default);
  application.register("qq-map", qq_map_default);
  application.register("search-input", search_input_default);
  application.register("taxon", taxon_default);
  application.register("time-range", time_range_default);
  application.register("total", total_default);
  application.register("typer", typer_default);
  application.register("field", field_default);
  application.register("datetime", datetime_default);

  // engine/rails_design/app/javascripts/turbo/events.js
  document.addEventListener("turbo:before-fetch-request", (event) => {
    const xhr = event.detail.fetchOptions;
    xhr.headers["Timezone"] = Intl.DateTimeFormat().resolvedOptions().timeZone;
  });

  // engine/rails_design/app/javascripts/turbo/override.js
  Object.defineProperties(customElements.get("turbo-stream").prototype, {
    targetElementsById: {
      get: function() {
        let element;
        if (this.target === "body") {
          element = this.ownerDocument.body;
        } else if (this.target) {
          element = this.ownerDocument.getElementById(this.target);
        }
        if (element !== null) {
          return [element];
        } else {
          return [];
        }
      }
    }
  });

  // engine/rails_design/app/javascripts/rails_design/index.js
  window.Idiomorph = Idiomorph2;

  // app/javascript/application.js
  application.debug = true;
})();
/*! Bundled license information:

choices.js/public/assets/scripts/choices.js:
  (*! choices.js v10.2.0 | © 2022 Josh Johnson | https://github.com/jshjohnson/Choices#readme *)

@hotwired/turbo/dist/turbo.es2017-esm.js:
  (*!
  Turbo 8.0.12
  Copyright © 2024 37signals LLC
   *)

sortablejs/modular/sortable.esm.js:
  (**!
   * Sortable 1.15.6
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)

@babel/runtime/helpers/esm/regeneratorRuntime.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

@antv/g-lite/dist/index.esm.js:
  (*!
   * @antv/g-lite
   * @description A core module for rendering engine implements DOM API.
   * @version 2.2.13
   * @date 12/27/2024, 4:20:45 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-camera-api/dist/index.esm.js:
  (*!
   * @antv/g-camera-api
   * @description A simple implementation of Camera API.
   * @version 2.0.32
   * @date 12/27/2024, 4:21:01 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-dom-mutation-observer-api/dist/index.esm.js:
  (*!
   * @antv/g-dom-mutation-observer-api
   * @description A simple implementation of DOM MutationObserver API.
   * @version 2.0.29
   * @date 12/27/2024, 4:21:14 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-web-animations-api/dist/index.esm.js:
  (*!
   * @antv/g-web-animations-api
   * @description A simple implementation of Web Animations API.
   * @version 2.1.18
   * @date 12/27/2024, 4:22:43 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g/dist/index.esm.js:
  (*!
   * @antv/g
   * @description A core module for rendering engine implements DOM API.
   * @version 6.1.18
   * @date 12/27/2024, 4:22:48 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-path-generator/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-path-generator
   * @description A G plugin of path generator with Canvas2D API
   * @version 2.1.13
   * @date 12/27/2024, 4:21:47 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-picker/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-picker
   * @description A G plugin for picking in canvas
   * @version 2.1.15
   * @date 12/27/2024, 4:23:48 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-image-loader/dist/index.esm.js:
  (*!
   * @antv/g-plugin-image-loader
   * @description A G plugin for loading image
   * @version 2.1.15
   * @date 12/27/2024, 4:22:13 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-canvas-renderer/dist/index.esm.js:
  (*!
   * @antv/g-plugin-canvas-renderer
   * @description A G plugin of renderer implementation with Canvas2D API
   * @version 2.2.15
   * @date 12/27/2024, 4:22:58 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-dom-interaction/dist/index.esm.js:
  (*!
   * @antv/g-plugin-dom-interaction
   * @description A G plugin
   * @version 2.1.18
   * @date 12/27/2024, 4:22:00 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-html-renderer/dist/index.esm.js:
  (*!
   * @antv/g-plugin-html-renderer
   * @description A G plugin for rendering HTML
   * @version 2.1.18
   * @date 12/27/2024, 4:22:09 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-canvas/dist/index.esm.js:
  (*!
   * @antv/g-canvas
   * @description A renderer implemented by Canvas 2D API
   * @version 2.0.36
   * @date 12/27/2024, 4:24:32 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)

@antv/g-plugin-dragndrop/dist/index.esm.js:
  (*!
   * @antv/g-plugin-dragndrop
   * @description A G plugin for Drag n Drop implemented with PointerEvents
   * @version 2.0.29
   * @date 12/27/2024, 4:22:03 AM
   * @author AntVis
   * @docs https://g.antv.antgroup.com/
   *)
*/
