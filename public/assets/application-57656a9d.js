(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod3) => function __require() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __export = (target, all) => {
    for (var name2 in all)
      __defProp(target, name2, { get: all[name2], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));

  // ../../engine/rails_design/node_modules/@rails/actioncable/src/adapters.js
  var adapters_default;
  var init_adapters = __esm({
    "../../engine/rails_design/node_modules/@rails/actioncable/src/adapters.js"() {
      adapters_default = {
        logger: self.console,
        WebSocket: self.WebSocket
      };
    }
  });

  // ../../engine/rails_design/node_modules/@rails/actioncable/src/logger.js
  var logger_default;
  var init_logger = __esm({
    "../../engine/rails_design/node_modules/@rails/actioncable/src/logger.js"() {
      init_adapters();
      logger_default = {
        log(...messages) {
          if (this.enabled) {
            messages.push(Date.now());
            adapters_default.logger.log("[ActionCable]", ...messages);
          }
        }
      };
    }
  });

  // ../../engine/rails_design/node_modules/@rails/actioncable/src/connection_monitor.js
  var now, secondsSince, ConnectionMonitor, connection_monitor_default;
  var init_connection_monitor = __esm({
    "../../engine/rails_design/node_modules/@rails/actioncable/src/connection_monitor.js"() {
      init_logger();
      now = () => (/* @__PURE__ */ new Date()).getTime();
      secondsSince = (time) => (now() - time) / 1e3;
      ConnectionMonitor = class {
        constructor(connection) {
          this.visibilityDidChange = this.visibilityDidChange.bind(this);
          this.connection = connection;
          this.reconnectAttempts = 0;
        }
        start() {
          if (!this.isRunning()) {
            this.startedAt = now();
            delete this.stoppedAt;
            this.startPolling();
            addEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log(`ConnectionMonitor started. stale threshold = ${this.constructor.staleThreshold} s`);
          }
        }
        stop() {
          if (this.isRunning()) {
            this.stoppedAt = now();
            this.stopPolling();
            removeEventListener("visibilitychange", this.visibilityDidChange);
            logger_default.log("ConnectionMonitor stopped");
          }
        }
        isRunning() {
          return this.startedAt && !this.stoppedAt;
        }
        recordPing() {
          this.pingedAt = now();
        }
        recordConnect() {
          this.reconnectAttempts = 0;
          this.recordPing();
          delete this.disconnectedAt;
          logger_default.log("ConnectionMonitor recorded connect");
        }
        recordDisconnect() {
          this.disconnectedAt = now();
          logger_default.log("ConnectionMonitor recorded disconnect");
        }
        // Private
        startPolling() {
          this.stopPolling();
          this.poll();
        }
        stopPolling() {
          clearTimeout(this.pollTimeout);
        }
        poll() {
          this.pollTimeout = setTimeout(
            () => {
              this.reconnectIfStale();
              this.poll();
            },
            this.getPollInterval()
          );
        }
        getPollInterval() {
          const { staleThreshold, reconnectionBackoffRate } = this.constructor;
          const backoff = Math.pow(1 + reconnectionBackoffRate, Math.min(this.reconnectAttempts, 10));
          const jitterMax = this.reconnectAttempts === 0 ? 1 : reconnectionBackoffRate;
          const jitter = jitterMax * Math.random();
          return staleThreshold * 1e3 * backoff * (1 + jitter);
        }
        reconnectIfStale() {
          if (this.connectionIsStale()) {
            logger_default.log(`ConnectionMonitor detected stale connection. reconnectAttempts = ${this.reconnectAttempts}, time stale = ${secondsSince(this.refreshedAt)} s, stale threshold = ${this.constructor.staleThreshold} s`);
            this.reconnectAttempts++;
            if (this.disconnectedRecently()) {
              logger_default.log(`ConnectionMonitor skipping reopening recent disconnect. time disconnected = ${secondsSince(this.disconnectedAt)} s`);
            } else {
              logger_default.log("ConnectionMonitor reopening");
              this.connection.reopen();
            }
          }
        }
        get refreshedAt() {
          return this.pingedAt ? this.pingedAt : this.startedAt;
        }
        connectionIsStale() {
          return secondsSince(this.refreshedAt) > this.constructor.staleThreshold;
        }
        disconnectedRecently() {
          return this.disconnectedAt && secondsSince(this.disconnectedAt) < this.constructor.staleThreshold;
        }
        visibilityDidChange() {
          if (document.visibilityState === "visible") {
            setTimeout(
              () => {
                if (this.connectionIsStale() || !this.connection.isOpen()) {
                  logger_default.log(`ConnectionMonitor reopening stale connection on visibilitychange. visibilityState = ${document.visibilityState}`);
                  this.connection.reopen();
                }
              },
              200
            );
          }
        }
      };
      ConnectionMonitor.staleThreshold = 6;
      ConnectionMonitor.reconnectionBackoffRate = 0.15;
      connection_monitor_default = ConnectionMonitor;
    }
  });

  // ../../engine/rails_design/node_modules/@rails/actioncable/src/internal.js
  var internal_default;
  var init_internal = __esm({
    "../../engine/rails_design/node_modules/@rails/actioncable/src/internal.js"() {
      internal_default = {
        "message_types": {
          "welcome": "welcome",
          "disconnect": "disconnect",
          "ping": "ping",
          "confirmation": "confirm_subscription",
          "rejection": "reject_subscription"
        },
        "disconnect_reasons": {
          "unauthorized": "unauthorized",
          "invalid_request": "invalid_request",
          "server_restart": "server_restart",
          "remote": "remote"
        },
        "default_mount_path": "/cable",
        "protocols": [
          "actioncable-v1-json",
          "actioncable-unsupported"
        ]
      };
    }
  });

  // ../../engine/rails_design/node_modules/@rails/actioncable/src/connection.js
  var message_types, protocols, supportedProtocols, indexOf, Connection, connection_default;
  var init_connection = __esm({
    "../../engine/rails_design/node_modules/@rails/actioncable/src/connection.js"() {
      init_adapters();
      init_connection_monitor();
      init_internal();
      init_logger();
      ({ message_types, protocols } = internal_default);
      supportedProtocols = protocols.slice(0, protocols.length - 1);
      indexOf = [].indexOf;
      Connection = class {
        constructor(consumer3) {
          this.open = this.open.bind(this);
          this.consumer = consumer3;
          this.subscriptions = this.consumer.subscriptions;
          this.monitor = new connection_monitor_default(this);
          this.disconnected = true;
        }
        send(data2) {
          if (this.isOpen()) {
            this.webSocket.send(JSON.stringify(data2));
            return true;
          } else {
            return false;
          }
        }
        open() {
          if (this.isActive()) {
            logger_default.log(`Attempted to open WebSocket, but existing socket is ${this.getState()}`);
            return false;
          } else {
            const socketProtocols = [...protocols, ...this.consumer.subprotocols || []];
            logger_default.log(`Opening WebSocket, current state is ${this.getState()}, subprotocols: ${socketProtocols}`);
            if (this.webSocket) {
              this.uninstallEventHandlers();
            }
            this.webSocket = new adapters_default.WebSocket(this.consumer.url, socketProtocols);
            this.installEventHandlers();
            this.monitor.start();
            return true;
          }
        }
        close({ allowReconnect } = { allowReconnect: true }) {
          if (!allowReconnect) {
            this.monitor.stop();
          }
          if (this.isOpen()) {
            return this.webSocket.close();
          }
        }
        reopen() {
          logger_default.log(`Reopening WebSocket, current state is ${this.getState()}`);
          if (this.isActive()) {
            try {
              return this.close();
            } catch (error4) {
              logger_default.log("Failed to reopen WebSocket", error4);
            } finally {
              logger_default.log(`Reopening WebSocket in ${this.constructor.reopenDelay}ms`);
              setTimeout(this.open, this.constructor.reopenDelay);
            }
          } else {
            return this.open();
          }
        }
        getProtocol() {
          if (this.webSocket) {
            return this.webSocket.protocol;
          }
        }
        isOpen() {
          return this.isState("open");
        }
        isActive() {
          return this.isState("open", "connecting");
        }
        triedToReconnect() {
          return this.monitor.reconnectAttempts > 0;
        }
        // Private
        isProtocolSupported() {
          return indexOf.call(supportedProtocols, this.getProtocol()) >= 0;
        }
        isState(...states) {
          return indexOf.call(states, this.getState()) >= 0;
        }
        getState() {
          if (this.webSocket) {
            for (let state in adapters_default.WebSocket) {
              if (adapters_default.WebSocket[state] === this.webSocket.readyState) {
                return state.toLowerCase();
              }
            }
          }
          return null;
        }
        installEventHandlers() {
          for (let eventName in this.events) {
            const handler = this.events[eventName].bind(this);
            this.webSocket[`on${eventName}`] = handler;
          }
        }
        uninstallEventHandlers() {
          for (let eventName in this.events) {
            this.webSocket[`on${eventName}`] = function() {
            };
          }
        }
      };
      Connection.reopenDelay = 500;
      Connection.prototype.events = {
        message(event) {
          if (!this.isProtocolSupported()) {
            return;
          }
          const { identifier, message, reason, reconnect, type } = JSON.parse(event.data);
          switch (type) {
            case message_types.welcome:
              if (this.triedToReconnect()) {
                this.reconnectAttempted = true;
              }
              this.monitor.recordConnect();
              return this.subscriptions.reload();
            case message_types.disconnect:
              logger_default.log(`Disconnecting. Reason: ${reason}`);
              return this.close({ allowReconnect: reconnect });
            case message_types.ping:
              return this.monitor.recordPing();
            case message_types.confirmation:
              this.subscriptions.confirmSubscription(identifier);
              if (this.reconnectAttempted) {
                this.reconnectAttempted = false;
                return this.subscriptions.notify(identifier, "connected", { reconnected: true });
              } else {
                return this.subscriptions.notify(identifier, "connected", { reconnected: false });
              }
            case message_types.rejection:
              return this.subscriptions.reject(identifier);
            default:
              return this.subscriptions.notify(identifier, "received", message);
          }
        },
        open() {
          logger_default.log(`WebSocket onopen event, using '${this.getProtocol()}' subprotocol`);
          this.disconnected = false;
          if (!this.isProtocolSupported()) {
            logger_default.log("Protocol is unsupported. Stopping monitor and disconnecting.");
            return this.close({ allowReconnect: false });
          }
        },
        close(event) {
          logger_default.log("WebSocket onclose event");
          if (this.disconnected) {
            return;
          }
          this.disconnected = true;
          this.monitor.recordDisconnect();
          return this.subscriptions.notifyAll("disconnected", { willAttemptReconnect: this.monitor.isRunning() });
        },
        error() {
          logger_default.log("WebSocket onerror event");
        }
      };
      connection_default = Connection;
    }
  });

  // ../../engine/rails_design/node_modules/@rails/actioncable/src/subscription.js
  var extend, Subscription;
  var init_subscription = __esm({
    "../../engine/rails_design/node_modules/@rails/actioncable/src/subscription.js"() {
      extend = function(object, properties) {
        if (properties != null) {
          for (let key in properties) {
            const value2 = properties[key];
            object[key] = value2;
          }
        }
        return object;
      };
      Subscription = class {
        constructor(consumer3, params = {}, mixin) {
          this.consumer = consumer3;
          this.identifier = JSON.stringify(params);
          extend(this, mixin);
        }
        // Perform a channel action with the optional data passed as an attribute
        perform(action, data2 = {}) {
          data2.action = action;
          return this.send(data2);
        }
        send(data2) {
          return this.consumer.send({ command: "message", identifier: this.identifier, data: JSON.stringify(data2) });
        }
        unsubscribe() {
          return this.consumer.subscriptions.remove(this);
        }
      };
    }
  });

  // ../../engine/rails_design/node_modules/@rails/actioncable/src/subscription_guarantor.js
  var SubscriptionGuarantor, subscription_guarantor_default;
  var init_subscription_guarantor = __esm({
    "../../engine/rails_design/node_modules/@rails/actioncable/src/subscription_guarantor.js"() {
      init_logger();
      SubscriptionGuarantor = class {
        constructor(subscriptions) {
          this.subscriptions = subscriptions;
          this.pendingSubscriptions = [];
        }
        guarantee(subscription) {
          if (this.pendingSubscriptions.indexOf(subscription) == -1) {
            logger_default.log(`SubscriptionGuarantor guaranteeing ${subscription.identifier}`);
            this.pendingSubscriptions.push(subscription);
          } else {
            logger_default.log(`SubscriptionGuarantor already guaranteeing ${subscription.identifier}`);
          }
          this.startGuaranteeing();
        }
        forget(subscription) {
          logger_default.log(`SubscriptionGuarantor forgetting ${subscription.identifier}`);
          this.pendingSubscriptions = this.pendingSubscriptions.filter((s2) => s2 !== subscription);
        }
        startGuaranteeing() {
          this.stopGuaranteeing();
          this.retrySubscribing();
        }
        stopGuaranteeing() {
          clearTimeout(this.retryTimeout);
        }
        retrySubscribing() {
          this.retryTimeout = setTimeout(
            () => {
              if (this.subscriptions && typeof this.subscriptions.subscribe === "function") {
                this.pendingSubscriptions.map((subscription) => {
                  logger_default.log(`SubscriptionGuarantor resubscribing ${subscription.identifier}`);
                  this.subscriptions.subscribe(subscription);
                });
              }
            },
            500
          );
        }
      };
      subscription_guarantor_default = SubscriptionGuarantor;
    }
  });

  // ../../engine/rails_design/node_modules/@rails/actioncable/src/subscriptions.js
  var Subscriptions;
  var init_subscriptions = __esm({
    "../../engine/rails_design/node_modules/@rails/actioncable/src/subscriptions.js"() {
      init_subscription();
      init_subscription_guarantor();
      init_logger();
      Subscriptions = class {
        constructor(consumer3) {
          this.consumer = consumer3;
          this.guarantor = new subscription_guarantor_default(this);
          this.subscriptions = [];
        }
        create(channelName, mixin) {
          const channel = channelName;
          const params = typeof channel === "object" ? channel : { channel };
          const subscription = new Subscription(this.consumer, params, mixin);
          return this.add(subscription);
        }
        // Private
        add(subscription) {
          this.subscriptions.push(subscription);
          this.consumer.ensureActiveConnection();
          this.notify(subscription, "initialized");
          this.subscribe(subscription);
          return subscription;
        }
        remove(subscription) {
          this.forget(subscription);
          if (!this.findAll(subscription.identifier).length) {
            this.sendCommand(subscription, "unsubscribe");
          }
          return subscription;
        }
        reject(identifier) {
          return this.findAll(identifier).map((subscription) => {
            this.forget(subscription);
            this.notify(subscription, "rejected");
            return subscription;
          });
        }
        forget(subscription) {
          this.guarantor.forget(subscription);
          this.subscriptions = this.subscriptions.filter((s2) => s2 !== subscription);
          return subscription;
        }
        findAll(identifier) {
          return this.subscriptions.filter((s2) => s2.identifier === identifier);
        }
        reload() {
          return this.subscriptions.map((subscription) => this.subscribe(subscription));
        }
        notifyAll(callbackName, ...args) {
          return this.subscriptions.map((subscription) => this.notify(subscription, callbackName, ...args));
        }
        notify(subscription, callbackName, ...args) {
          let subscriptions;
          if (typeof subscription === "string") {
            subscriptions = this.findAll(subscription);
          } else {
            subscriptions = [subscription];
          }
          return subscriptions.map((subscription2) => typeof subscription2[callbackName] === "function" ? subscription2[callbackName](...args) : void 0);
        }
        subscribe(subscription) {
          if (this.sendCommand(subscription, "subscribe")) {
            this.guarantor.guarantee(subscription);
          }
        }
        confirmSubscription(identifier) {
          logger_default.log(`Subscription confirmed ${identifier}`);
          this.findAll(identifier).map((subscription) => this.guarantor.forget(subscription));
        }
        sendCommand(subscription, command) {
          const { identifier } = subscription;
          return this.consumer.send({ command, identifier });
        }
      };
    }
  });

  // ../../engine/rails_design/node_modules/@rails/actioncable/src/consumer.js
  function createWebSocketURL(url) {
    if (typeof url === "function") {
      url = url();
    }
    if (url && !/^wss?:/i.test(url)) {
      const a3 = document.createElement("a");
      a3.href = url;
      a3.href = a3.href;
      a3.protocol = a3.protocol.replace("http", "ws");
      return a3.href;
    } else {
      return url;
    }
  }
  var Consumer;
  var init_consumer = __esm({
    "../../engine/rails_design/node_modules/@rails/actioncable/src/consumer.js"() {
      init_connection();
      init_subscriptions();
      Consumer = class {
        constructor(url) {
          this._url = url;
          this.subscriptions = new Subscriptions(this);
          this.connection = new connection_default(this);
          this.subprotocols = [];
        }
        get url() {
          return createWebSocketURL(this._url);
        }
        send(data2) {
          return this.connection.send(data2);
        }
        connect() {
          return this.connection.open();
        }
        disconnect() {
          return this.connection.close({ allowReconnect: false });
        }
        ensureActiveConnection() {
          if (!this.connection.isActive()) {
            return this.connection.open();
          }
        }
        addSubProtocol(subprotocol) {
          this.subprotocols = [...this.subprotocols, subprotocol];
        }
      };
    }
  });

  // ../../engine/rails_design/node_modules/@rails/actioncable/src/index.js
  var src_exports = {};
  __export(src_exports, {
    Connection: () => connection_default,
    ConnectionMonitor: () => connection_monitor_default,
    Consumer: () => Consumer,
    INTERNAL: () => internal_default,
    Subscription: () => Subscription,
    SubscriptionGuarantor: () => subscription_guarantor_default,
    Subscriptions: () => Subscriptions,
    adapters: () => adapters_default,
    createConsumer: () => createConsumer,
    createWebSocketURL: () => createWebSocketURL,
    getConfig: () => getConfig,
    logger: () => logger_default
  });
  function createConsumer(url = getConfig("url") || internal_default.default_mount_path) {
    return new Consumer(url);
  }
  function getConfig(name2) {
    const element = document.head.querySelector(`meta[name='action-cable-${name2}']`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  var init_src = __esm({
    "../../engine/rails_design/node_modules/@rails/actioncable/src/index.js"() {
      init_connection();
      init_connection_monitor();
      init_consumer();
      init_internal();
      init_subscription();
      init_subscriptions();
      init_subscription_guarantor();
      init_adapters();
      init_logger();
    }
  });

  // ../../engine/rails_design/node_modules/choices.js/public/assets/scripts/choices.js
  var require_choices = __commonJS({
    "../../engine/rails_design/node_modules/choices.js/public/assets/scripts/choices.js"(exports, module) {
      (function webpackUniversalModuleDefinition(root2, factory) {
        if (typeof exports === "object" && typeof module === "object")
          module.exports = factory();
        else if (typeof define === "function" && define.amd)
          define([], factory);
        else if (typeof exports === "object")
          exports["Choices"] = factory();
        else
          root2["Choices"] = factory();
      })(window, function() {
        return (
          /******/
          function() {
            "use strict";
            var __webpack_modules__ = {
              /***/
              282: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.clearChoices = exports2.activateChoices = exports2.filterChoices = exports2.addChoice = void 0;
                  var constants_1 = __webpack_require__2(883);
                  var addChoice = function(_a) {
                    var value2 = _a.value, label = _a.label, id4 = _a.id, groupId = _a.groupId, disabled = _a.disabled, elementId = _a.elementId, customProperties = _a.customProperties, placeholder = _a.placeholder, keyCode = _a.keyCode;
                    return {
                      type: constants_1.ACTION_TYPES.ADD_CHOICE,
                      value: value2,
                      label,
                      id: id4,
                      groupId,
                      disabled,
                      elementId,
                      customProperties,
                      placeholder,
                      keyCode
                    };
                  };
                  exports2.addChoice = addChoice;
                  var filterChoices = function(results) {
                    return {
                      type: constants_1.ACTION_TYPES.FILTER_CHOICES,
                      results
                    };
                  };
                  exports2.filterChoices = filterChoices;
                  var activateChoices = function(active) {
                    if (active === void 0) {
                      active = true;
                    }
                    return {
                      type: constants_1.ACTION_TYPES.ACTIVATE_CHOICES,
                      active
                    };
                  };
                  exports2.activateChoices = activateChoices;
                  var clearChoices = function() {
                    return {
                      type: constants_1.ACTION_TYPES.CLEAR_CHOICES
                    };
                  };
                  exports2.clearChoices = clearChoices;
                }
              ),
              /***/
              783: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.addGroup = void 0;
                  var constants_1 = __webpack_require__2(883);
                  var addGroup = function(_a) {
                    var value2 = _a.value, id4 = _a.id, active = _a.active, disabled = _a.disabled;
                    return {
                      type: constants_1.ACTION_TYPES.ADD_GROUP,
                      value: value2,
                      id: id4,
                      active,
                      disabled
                    };
                  };
                  exports2.addGroup = addGroup;
                }
              ),
              /***/
              464: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.highlightItem = exports2.removeItem = exports2.addItem = void 0;
                  var constants_1 = __webpack_require__2(883);
                  var addItem = function(_a) {
                    var value2 = _a.value, label = _a.label, id4 = _a.id, choiceId = _a.choiceId, groupId = _a.groupId, customProperties = _a.customProperties, placeholder = _a.placeholder, keyCode = _a.keyCode;
                    return {
                      type: constants_1.ACTION_TYPES.ADD_ITEM,
                      value: value2,
                      label,
                      id: id4,
                      choiceId,
                      groupId,
                      customProperties,
                      placeholder,
                      keyCode
                    };
                  };
                  exports2.addItem = addItem;
                  var removeItem = function(id4, choiceId) {
                    return {
                      type: constants_1.ACTION_TYPES.REMOVE_ITEM,
                      id: id4,
                      choiceId
                    };
                  };
                  exports2.removeItem = removeItem;
                  var highlightItem = function(id4, highlighted) {
                    return {
                      type: constants_1.ACTION_TYPES.HIGHLIGHT_ITEM,
                      id: id4,
                      highlighted
                    };
                  };
                  exports2.highlightItem = highlightItem;
                }
              ),
              /***/
              137: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.setIsLoading = exports2.resetTo = exports2.clearAll = void 0;
                  var constants_1 = __webpack_require__2(883);
                  var clearAll = function() {
                    return {
                      type: constants_1.ACTION_TYPES.CLEAR_ALL
                    };
                  };
                  exports2.clearAll = clearAll;
                  var resetTo = function(state) {
                    return {
                      type: constants_1.ACTION_TYPES.RESET_TO,
                      state
                    };
                  };
                  exports2.resetTo = resetTo;
                  var setIsLoading = function(isLoading) {
                    return {
                      type: constants_1.ACTION_TYPES.SET_IS_LOADING,
                      isLoading
                    };
                  };
                  exports2.setIsLoading = setIsLoading;
                }
              ),
              /***/
              373: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __spreadArray2 = this && this.__spreadArray || function(to, from, pack3) {
                    if (pack3 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                  };
                  var __importDefault = this && this.__importDefault || function(mod3) {
                    return mod3 && mod3.__esModule ? mod3 : {
                      "default": mod3
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var deepmerge_1 = __importDefault(__webpack_require__2(996));
                  var fuse_js_1 = __importDefault(__webpack_require__2(221));
                  var choices_1 = __webpack_require__2(282);
                  var groups_1 = __webpack_require__2(783);
                  var items_1 = __webpack_require__2(464);
                  var misc_1 = __webpack_require__2(137);
                  var components_1 = __webpack_require__2(520);
                  var constants_1 = __webpack_require__2(883);
                  var defaults_1 = __webpack_require__2(789);
                  var utils_1 = __webpack_require__2(799);
                  var reducers_1 = __webpack_require__2(655);
                  var store_1 = __importDefault(__webpack_require__2(744));
                  var templates_1 = __importDefault(__webpack_require__2(686));
                  var IS_IE11 = "-ms-scroll-limit" in document.documentElement.style && "-ms-ime-align" in document.documentElement.style;
                  var USER_DEFAULTS = {};
                  var Choices2 = (
                    /** @class */
                    function() {
                      function Choices3(element, userConfig) {
                        if (element === void 0) {
                          element = "[data-choice]";
                        }
                        if (userConfig === void 0) {
                          userConfig = {};
                        }
                        var _this = this;
                        if (userConfig.allowHTML === void 0) {
                          console.warn("Deprecation warning: allowHTML will default to false in a future release. To render HTML in Choices, you will need to set it to true. Setting allowHTML will suppress this message.");
                        }
                        this.config = deepmerge_1.default.all(
                          [defaults_1.DEFAULT_CONFIG, Choices3.defaults.options, userConfig],
                          // When merging array configs, replace with a copy of the userConfig array,
                          // instead of concatenating with the default array
                          {
                            arrayMerge: function(_2, sourceArray) {
                              return __spreadArray2([], sourceArray, true);
                            }
                          }
                        );
                        var invalidConfigOptions = (0, utils_1.diff)(this.config, defaults_1.DEFAULT_CONFIG);
                        if (invalidConfigOptions.length) {
                          console.warn("Unknown config option(s) passed", invalidConfigOptions.join(", "));
                        }
                        var passedElement = typeof element === "string" ? document.querySelector(element) : element;
                        if (!(passedElement instanceof HTMLInputElement || passedElement instanceof HTMLSelectElement)) {
                          throw TypeError("Expected one of the following types text|select-one|select-multiple");
                        }
                        this._isTextElement = passedElement.type === constants_1.TEXT_TYPE;
                        this._isSelectOneElement = passedElement.type === constants_1.SELECT_ONE_TYPE;
                        this._isSelectMultipleElement = passedElement.type === constants_1.SELECT_MULTIPLE_TYPE;
                        this._isSelectElement = this._isSelectOneElement || this._isSelectMultipleElement;
                        this.config.searchEnabled = this._isSelectMultipleElement || this.config.searchEnabled;
                        if (!["auto", "always"].includes("".concat(this.config.renderSelectedChoices))) {
                          this.config.renderSelectedChoices = "auto";
                        }
                        if (userConfig.addItemFilter && typeof userConfig.addItemFilter !== "function") {
                          var re2 = userConfig.addItemFilter instanceof RegExp ? userConfig.addItemFilter : new RegExp(userConfig.addItemFilter);
                          this.config.addItemFilter = re2.test.bind(re2);
                        }
                        if (this._isTextElement) {
                          this.passedElement = new components_1.WrappedInput({
                            element: passedElement,
                            classNames: this.config.classNames,
                            delimiter: this.config.delimiter
                          });
                        } else {
                          this.passedElement = new components_1.WrappedSelect({
                            element: passedElement,
                            classNames: this.config.classNames,
                            template: function(data2) {
                              return _this._templates.option(data2);
                            }
                          });
                        }
                        this.initialised = false;
                        this._store = new store_1.default();
                        this._initialState = reducers_1.defaultState;
                        this._currentState = reducers_1.defaultState;
                        this._prevState = reducers_1.defaultState;
                        this._currentValue = "";
                        this._canSearch = !!this.config.searchEnabled;
                        this._isScrollingOnIe = false;
                        this._highlightPosition = 0;
                        this._wasTap = true;
                        this._placeholderValue = this._generatePlaceholderValue();
                        this._baseId = (0, utils_1.generateId)(this.passedElement.element, "choices-");
                        this._direction = this.passedElement.dir;
                        if (!this._direction) {
                          var elementDirection = window.getComputedStyle(this.passedElement.element).direction;
                          var documentDirection = window.getComputedStyle(document.documentElement).direction;
                          if (elementDirection !== documentDirection) {
                            this._direction = elementDirection;
                          }
                        }
                        this._idNames = {
                          itemChoice: "item-choice"
                        };
                        if (this._isSelectElement) {
                          this._presetGroups = this.passedElement.optionGroups;
                          this._presetOptions = this.passedElement.options;
                        }
                        this._presetChoices = this.config.choices;
                        this._presetItems = this.config.items;
                        if (this.passedElement.value && this._isTextElement) {
                          var splitValues = this.passedElement.value.split(this.config.delimiter);
                          this._presetItems = this._presetItems.concat(splitValues);
                        }
                        if (this.passedElement.options) {
                          this.passedElement.options.forEach(function(option2) {
                            _this._presetChoices.push({
                              value: option2.value,
                              label: option2.innerHTML,
                              selected: !!option2.selected,
                              disabled: option2.disabled || option2.parentNode.disabled,
                              placeholder: option2.value === "" || option2.hasAttribute("placeholder"),
                              customProperties: (0, utils_1.parseCustomProperties)(option2.dataset.customProperties)
                            });
                          });
                        }
                        this._render = this._render.bind(this);
                        this._onFocus = this._onFocus.bind(this);
                        this._onBlur = this._onBlur.bind(this);
                        this._onKeyUp = this._onKeyUp.bind(this);
                        this._onKeyDown = this._onKeyDown.bind(this);
                        this._onClick = this._onClick.bind(this);
                        this._onTouchMove = this._onTouchMove.bind(this);
                        this._onTouchEnd = this._onTouchEnd.bind(this);
                        this._onMouseDown = this._onMouseDown.bind(this);
                        this._onMouseOver = this._onMouseOver.bind(this);
                        this._onFormReset = this._onFormReset.bind(this);
                        this._onSelectKey = this._onSelectKey.bind(this);
                        this._onEnterKey = this._onEnterKey.bind(this);
                        this._onEscapeKey = this._onEscapeKey.bind(this);
                        this._onDirectionKey = this._onDirectionKey.bind(this);
                        this._onDeleteKey = this._onDeleteKey.bind(this);
                        if (this.passedElement.isActive) {
                          if (!this.config.silent) {
                            console.warn("Trying to initialise Choices on element already initialised", {
                              element
                            });
                          }
                          this.initialised = true;
                          return;
                        }
                        this.init();
                      }
                      Object.defineProperty(Choices3, "defaults", {
                        get: function() {
                          return Object.preventExtensions({
                            get options() {
                              return USER_DEFAULTS;
                            },
                            get templates() {
                              return templates_1.default;
                            }
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Choices3.prototype.init = function() {
                        if (this.initialised) {
                          return;
                        }
                        this._createTemplates();
                        this._createElements();
                        this._createStructure();
                        this._store.subscribe(this._render);
                        this._render();
                        this._addEventListeners();
                        var shouldDisable = !this.config.addItems || this.passedElement.element.hasAttribute("disabled");
                        if (shouldDisable) {
                          this.disable();
                        }
                        this.initialised = true;
                        var callbackOnInit = this.config.callbackOnInit;
                        if (callbackOnInit && typeof callbackOnInit === "function") {
                          callbackOnInit.call(this);
                        }
                      };
                      Choices3.prototype.destroy = function() {
                        if (!this.initialised) {
                          return;
                        }
                        this._removeEventListeners();
                        this.passedElement.reveal();
                        this.containerOuter.unwrap(this.passedElement.element);
                        this.clearStore();
                        if (this._isSelectElement) {
                          this.passedElement.options = this._presetOptions;
                        }
                        this._templates = templates_1.default;
                        this.initialised = false;
                      };
                      Choices3.prototype.enable = function() {
                        if (this.passedElement.isDisabled) {
                          this.passedElement.enable();
                        }
                        if (this.containerOuter.isDisabled) {
                          this._addEventListeners();
                          this.input.enable();
                          this.containerOuter.enable();
                        }
                        return this;
                      };
                      Choices3.prototype.disable = function() {
                        if (!this.passedElement.isDisabled) {
                          this.passedElement.disable();
                        }
                        if (!this.containerOuter.isDisabled) {
                          this._removeEventListeners();
                          this.input.disable();
                          this.containerOuter.disable();
                        }
                        return this;
                      };
                      Choices3.prototype.highlightItem = function(item, runEvent) {
                        if (runEvent === void 0) {
                          runEvent = true;
                        }
                        if (!item || !item.id) {
                          return this;
                        }
                        var id4 = item.id, _a = item.groupId, groupId = _a === void 0 ? -1 : _a, _b = item.value, value2 = _b === void 0 ? "" : _b, _c = item.label, label = _c === void 0 ? "" : _c;
                        var group3 = groupId >= 0 ? this._store.getGroupById(groupId) : null;
                        this._store.dispatch((0, items_1.highlightItem)(id4, true));
                        if (runEvent) {
                          this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
                            id: id4,
                            value: value2,
                            label,
                            groupValue: group3 && group3.value ? group3.value : null
                          });
                        }
                        return this;
                      };
                      Choices3.prototype.unhighlightItem = function(item) {
                        if (!item || !item.id) {
                          return this;
                        }
                        var id4 = item.id, _a = item.groupId, groupId = _a === void 0 ? -1 : _a, _b = item.value, value2 = _b === void 0 ? "" : _b, _c = item.label, label = _c === void 0 ? "" : _c;
                        var group3 = groupId >= 0 ? this._store.getGroupById(groupId) : null;
                        this._store.dispatch((0, items_1.highlightItem)(id4, false));
                        this.passedElement.triggerEvent(constants_1.EVENTS.highlightItem, {
                          id: id4,
                          value: value2,
                          label,
                          groupValue: group3 && group3.value ? group3.value : null
                        });
                        return this;
                      };
                      Choices3.prototype.highlightAll = function() {
                        var _this = this;
                        this._store.items.forEach(function(item) {
                          return _this.highlightItem(item);
                        });
                        return this;
                      };
                      Choices3.prototype.unhighlightAll = function() {
                        var _this = this;
                        this._store.items.forEach(function(item) {
                          return _this.unhighlightItem(item);
                        });
                        return this;
                      };
                      Choices3.prototype.removeActiveItemsByValue = function(value2) {
                        var _this = this;
                        this._store.activeItems.filter(function(item) {
                          return item.value === value2;
                        }).forEach(function(item) {
                          return _this._removeItem(item);
                        });
                        return this;
                      };
                      Choices3.prototype.removeActiveItems = function(excludedId) {
                        var _this = this;
                        this._store.activeItems.filter(function(_a) {
                          var id4 = _a.id;
                          return id4 !== excludedId;
                        }).forEach(function(item) {
                          return _this._removeItem(item);
                        });
                        return this;
                      };
                      Choices3.prototype.removeHighlightedItems = function(runEvent) {
                        var _this = this;
                        if (runEvent === void 0) {
                          runEvent = false;
                        }
                        this._store.highlightedActiveItems.forEach(function(item) {
                          _this._removeItem(item);
                          if (runEvent) {
                            _this._triggerChange(item.value);
                          }
                        });
                        return this;
                      };
                      Choices3.prototype.showDropdown = function(preventInputFocus) {
                        var _this = this;
                        if (this.dropdown.isActive) {
                          return this;
                        }
                        requestAnimationFrame(function() {
                          _this.dropdown.show();
                          _this.containerOuter.open(_this.dropdown.distanceFromTopWindow);
                          if (!preventInputFocus && _this._canSearch) {
                            _this.input.focus();
                          }
                          _this.passedElement.triggerEvent(constants_1.EVENTS.showDropdown, {});
                        });
                        return this;
                      };
                      Choices3.prototype.hideDropdown = function(preventInputBlur) {
                        var _this = this;
                        if (!this.dropdown.isActive) {
                          return this;
                        }
                        requestAnimationFrame(function() {
                          _this.dropdown.hide();
                          _this.containerOuter.close();
                          if (!preventInputBlur && _this._canSearch) {
                            _this.input.removeActiveDescendant();
                            _this.input.blur();
                          }
                          _this.passedElement.triggerEvent(constants_1.EVENTS.hideDropdown, {});
                        });
                        return this;
                      };
                      Choices3.prototype.getValue = function(valueOnly) {
                        if (valueOnly === void 0) {
                          valueOnly = false;
                        }
                        var values = this._store.activeItems.reduce(function(selectedItems, item) {
                          var itemValue = valueOnly ? item.value : item;
                          selectedItems.push(itemValue);
                          return selectedItems;
                        }, []);
                        return this._isSelectOneElement ? values[0] : values;
                      };
                      Choices3.prototype.setValue = function(items) {
                        var _this = this;
                        if (!this.initialised) {
                          return this;
                        }
                        items.forEach(function(value2) {
                          return _this._setChoiceOrItem(value2);
                        });
                        return this;
                      };
                      Choices3.prototype.setChoiceByValue = function(value2) {
                        var _this = this;
                        if (!this.initialised || this._isTextElement) {
                          return this;
                        }
                        var choiceValue = Array.isArray(value2) ? value2 : [value2];
                        choiceValue.forEach(function(val) {
                          return _this._findAndSelectChoiceByValue(val);
                        });
                        return this;
                      };
                      Choices3.prototype.setChoices = function(choicesArrayOrFetcher, value2, label, replaceChoices) {
                        var _this = this;
                        if (choicesArrayOrFetcher === void 0) {
                          choicesArrayOrFetcher = [];
                        }
                        if (value2 === void 0) {
                          value2 = "value";
                        }
                        if (label === void 0) {
                          label = "label";
                        }
                        if (replaceChoices === void 0) {
                          replaceChoices = false;
                        }
                        if (!this.initialised) {
                          throw new ReferenceError("setChoices was called on a non-initialized instance of Choices");
                        }
                        if (!this._isSelectElement) {
                          throw new TypeError("setChoices can't be used with INPUT based Choices");
                        }
                        if (typeof value2 !== "string" || !value2) {
                          throw new TypeError("value parameter must be a name of 'value' field in passed objects");
                        }
                        if (replaceChoices) {
                          this.clearChoices();
                        }
                        if (typeof choicesArrayOrFetcher === "function") {
                          var fetcher_1 = choicesArrayOrFetcher(this);
                          if (typeof Promise === "function" && fetcher_1 instanceof Promise) {
                            return new Promise(function(resolve) {
                              return requestAnimationFrame(resolve);
                            }).then(function() {
                              return _this._handleLoadingState(true);
                            }).then(function() {
                              return fetcher_1;
                            }).then(function(data2) {
                              return _this.setChoices(data2, value2, label, replaceChoices);
                            }).catch(function(err) {
                              if (!_this.config.silent) {
                                console.error(err);
                              }
                            }).then(function() {
                              return _this._handleLoadingState(false);
                            }).then(function() {
                              return _this;
                            });
                          }
                          if (!Array.isArray(fetcher_1)) {
                            throw new TypeError(".setChoices first argument function must return either array of choices or Promise, got: ".concat(typeof fetcher_1));
                          }
                          return this.setChoices(fetcher_1, value2, label, false);
                        }
                        if (!Array.isArray(choicesArrayOrFetcher)) {
                          throw new TypeError(".setChoices must be called either with array of choices with a function resulting into Promise of array of choices");
                        }
                        this.containerOuter.removeLoadingState();
                        this._startLoading();
                        choicesArrayOrFetcher.forEach(function(groupOrChoice) {
                          if (groupOrChoice.choices) {
                            _this._addGroup({
                              id: groupOrChoice.id ? parseInt("".concat(groupOrChoice.id), 10) : null,
                              group: groupOrChoice,
                              valueKey: value2,
                              labelKey: label
                            });
                          } else {
                            var choice = groupOrChoice;
                            _this._addChoice({
                              value: choice[value2],
                              label: choice[label],
                              isSelected: !!choice.selected,
                              isDisabled: !!choice.disabled,
                              placeholder: !!choice.placeholder,
                              customProperties: choice.customProperties
                            });
                          }
                        });
                        this._stopLoading();
                        return this;
                      };
                      Choices3.prototype.clearChoices = function() {
                        this._store.dispatch((0, choices_1.clearChoices)());
                        return this;
                      };
                      Choices3.prototype.clearStore = function() {
                        this._store.dispatch((0, misc_1.clearAll)());
                        return this;
                      };
                      Choices3.prototype.clearInput = function() {
                        var shouldSetInputWidth = !this._isSelectOneElement;
                        this.input.clear(shouldSetInputWidth);
                        if (!this._isTextElement && this._canSearch) {
                          this._isSearching = false;
                          this._store.dispatch((0, choices_1.activateChoices)(true));
                        }
                        return this;
                      };
                      Choices3.prototype._render = function() {
                        if (this._store.isLoading()) {
                          return;
                        }
                        this._currentState = this._store.state;
                        var stateChanged = this._currentState.choices !== this._prevState.choices || this._currentState.groups !== this._prevState.groups || this._currentState.items !== this._prevState.items;
                        var shouldRenderChoices = this._isSelectElement;
                        var shouldRenderItems = this._currentState.items !== this._prevState.items;
                        if (!stateChanged) {
                          return;
                        }
                        if (shouldRenderChoices) {
                          this._renderChoices();
                        }
                        if (shouldRenderItems) {
                          this._renderItems();
                        }
                        this._prevState = this._currentState;
                      };
                      Choices3.prototype._renderChoices = function() {
                        var _this = this;
                        var _a = this._store, activeGroups = _a.activeGroups, activeChoices = _a.activeChoices;
                        var choiceListFragment = document.createDocumentFragment();
                        this.choiceList.clear();
                        if (this.config.resetScrollPosition) {
                          requestAnimationFrame(function() {
                            return _this.choiceList.scrollToTop();
                          });
                        }
                        if (activeGroups.length >= 1 && !this._isSearching) {
                          var activePlaceholders = activeChoices.filter(function(activeChoice) {
                            return activeChoice.placeholder === true && activeChoice.groupId === -1;
                          });
                          if (activePlaceholders.length >= 1) {
                            choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);
                          }
                          choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);
                        } else if (activeChoices.length >= 1) {
                          choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);
                        }
                        if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {
                          var activeItems = this._store.activeItems;
                          var canAddItem = this._canAddItem(activeItems, this.input.value);
                          if (canAddItem.response) {
                            this.choiceList.append(choiceListFragment);
                            this._highlightChoice();
                          } else {
                            var notice = this._getTemplate("notice", canAddItem.notice);
                            this.choiceList.append(notice);
                          }
                        } else {
                          var dropdownItem = void 0;
                          var notice = void 0;
                          if (this._isSearching) {
                            notice = typeof this.config.noResultsText === "function" ? this.config.noResultsText() : this.config.noResultsText;
                            dropdownItem = this._getTemplate("notice", notice, "no-results");
                          } else {
                            notice = typeof this.config.noChoicesText === "function" ? this.config.noChoicesText() : this.config.noChoicesText;
                            dropdownItem = this._getTemplate("notice", notice, "no-choices");
                          }
                          this.choiceList.append(dropdownItem);
                        }
                      };
                      Choices3.prototype._renderItems = function() {
                        var activeItems = this._store.activeItems || [];
                        this.itemList.clear();
                        var itemListFragment = this._createItemsFragment(activeItems);
                        if (itemListFragment.childNodes) {
                          this.itemList.append(itemListFragment);
                        }
                      };
                      Choices3.prototype._createGroupsFragment = function(groups2, choices, fragment) {
                        var _this = this;
                        if (fragment === void 0) {
                          fragment = document.createDocumentFragment();
                        }
                        var getGroupChoices = function(group3) {
                          return choices.filter(function(choice) {
                            if (_this._isSelectOneElement) {
                              return choice.groupId === group3.id;
                            }
                            return choice.groupId === group3.id && (_this.config.renderSelectedChoices === "always" || !choice.selected);
                          });
                        };
                        if (this.config.shouldSort) {
                          groups2.sort(this.config.sorter);
                        }
                        groups2.forEach(function(group3) {
                          var groupChoices = getGroupChoices(group3);
                          if (groupChoices.length >= 1) {
                            var dropdownGroup = _this._getTemplate("choiceGroup", group3);
                            fragment.appendChild(dropdownGroup);
                            _this._createChoicesFragment(groupChoices, fragment, true);
                          }
                        });
                        return fragment;
                      };
                      Choices3.prototype._createChoicesFragment = function(choices, fragment, withinGroup) {
                        var _this = this;
                        if (fragment === void 0) {
                          fragment = document.createDocumentFragment();
                        }
                        if (withinGroup === void 0) {
                          withinGroup = false;
                        }
                        var _a = this.config, renderSelectedChoices = _a.renderSelectedChoices, searchResultLimit = _a.searchResultLimit, renderChoiceLimit = _a.renderChoiceLimit;
                        var filter2 = this._isSearching ? utils_1.sortByScore : this.config.sorter;
                        var appendChoice = function(choice) {
                          var shouldRender = renderSelectedChoices === "auto" ? _this._isSelectOneElement || !choice.selected : true;
                          if (shouldRender) {
                            var dropdownItem = _this._getTemplate("choice", choice, _this.config.itemSelectText);
                            fragment.appendChild(dropdownItem);
                          }
                        };
                        var rendererableChoices = choices;
                        if (renderSelectedChoices === "auto" && !this._isSelectOneElement) {
                          rendererableChoices = choices.filter(function(choice) {
                            return !choice.selected;
                          });
                        }
                        var _b = rendererableChoices.reduce(function(acc, choice) {
                          if (choice.placeholder) {
                            acc.placeholderChoices.push(choice);
                          } else {
                            acc.normalChoices.push(choice);
                          }
                          return acc;
                        }, {
                          placeholderChoices: [],
                          normalChoices: []
                        }), placeholderChoices = _b.placeholderChoices, normalChoices = _b.normalChoices;
                        if (this.config.shouldSort || this._isSearching) {
                          normalChoices.sort(filter2);
                        }
                        var choiceLimit = rendererableChoices.length;
                        var sortedChoices = this._isSelectOneElement ? __spreadArray2(__spreadArray2([], placeholderChoices, true), normalChoices, true) : normalChoices;
                        if (this._isSearching) {
                          choiceLimit = searchResultLimit;
                        } else if (renderChoiceLimit && renderChoiceLimit > 0 && !withinGroup) {
                          choiceLimit = renderChoiceLimit;
                        }
                        for (var i = 0; i < choiceLimit; i += 1) {
                          if (sortedChoices[i]) {
                            appendChoice(sortedChoices[i]);
                          }
                        }
                        return fragment;
                      };
                      Choices3.prototype._createItemsFragment = function(items, fragment) {
                        var _this = this;
                        if (fragment === void 0) {
                          fragment = document.createDocumentFragment();
                        }
                        var _a = this.config, shouldSortItems = _a.shouldSortItems, sorter = _a.sorter, removeItemButton = _a.removeItemButton;
                        if (shouldSortItems && !this._isSelectOneElement) {
                          items.sort(sorter);
                        }
                        if (this._isTextElement) {
                          this.passedElement.value = items.map(function(_a2) {
                            var value2 = _a2.value;
                            return value2;
                          }).join(this.config.delimiter);
                        } else {
                          this.passedElement.options = items;
                        }
                        var addItemToFragment = function(item) {
                          var listItem = _this._getTemplate("item", item, removeItemButton);
                          fragment.appendChild(listItem);
                        };
                        items.forEach(addItemToFragment);
                        return fragment;
                      };
                      Choices3.prototype._triggerChange = function(value2) {
                        if (value2 === void 0 || value2 === null) {
                          return;
                        }
                        this.passedElement.triggerEvent(constants_1.EVENTS.change, {
                          value: value2
                        });
                      };
                      Choices3.prototype._selectPlaceholderChoice = function(placeholderChoice) {
                        this._addItem({
                          value: placeholderChoice.value,
                          label: placeholderChoice.label,
                          choiceId: placeholderChoice.id,
                          groupId: placeholderChoice.groupId,
                          placeholder: placeholderChoice.placeholder
                        });
                        this._triggerChange(placeholderChoice.value);
                      };
                      Choices3.prototype._handleButtonAction = function(activeItems, element) {
                        if (!activeItems || !element || !this.config.removeItems || !this.config.removeItemButton) {
                          return;
                        }
                        var itemId = element.parentNode && element.parentNode.dataset.id;
                        var itemToRemove = itemId && activeItems.find(function(item) {
                          return item.id === parseInt(itemId, 10);
                        });
                        if (!itemToRemove) {
                          return;
                        }
                        this._removeItem(itemToRemove);
                        this._triggerChange(itemToRemove.value);
                        if (this._isSelectOneElement && this._store.placeholderChoice) {
                          this._selectPlaceholderChoice(this._store.placeholderChoice);
                        }
                      };
                      Choices3.prototype._handleItemAction = function(activeItems, element, hasShiftKey) {
                        var _this = this;
                        if (hasShiftKey === void 0) {
                          hasShiftKey = false;
                        }
                        if (!activeItems || !element || !this.config.removeItems || this._isSelectOneElement) {
                          return;
                        }
                        var passedId = element.dataset.id;
                        activeItems.forEach(function(item) {
                          if (item.id === parseInt("".concat(passedId), 10) && !item.highlighted) {
                            _this.highlightItem(item);
                          } else if (!hasShiftKey && item.highlighted) {
                            _this.unhighlightItem(item);
                          }
                        });
                        this.input.focus();
                      };
                      Choices3.prototype._handleChoiceAction = function(activeItems, element) {
                        if (!activeItems || !element) {
                          return;
                        }
                        var id4 = element.dataset.id;
                        var choice = id4 && this._store.getChoiceById(id4);
                        if (!choice) {
                          return;
                        }
                        var passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : void 0;
                        var hasActiveDropdown = this.dropdown.isActive;
                        choice.keyCode = passedKeyCode;
                        this.passedElement.triggerEvent(constants_1.EVENTS.choice, {
                          choice
                        });
                        if (!choice.selected && !choice.disabled) {
                          var canAddItem = this._canAddItem(activeItems, choice.value);
                          if (canAddItem.response) {
                            this._addItem({
                              value: choice.value,
                              label: choice.label,
                              choiceId: choice.id,
                              groupId: choice.groupId,
                              customProperties: choice.customProperties,
                              placeholder: choice.placeholder,
                              keyCode: choice.keyCode
                            });
                            this._triggerChange(choice.value);
                          }
                        }
                        this.clearInput();
                        if (hasActiveDropdown && this._isSelectOneElement) {
                          this.hideDropdown(true);
                          this.containerOuter.focus();
                        }
                      };
                      Choices3.prototype._handleBackspace = function(activeItems) {
                        if (!this.config.removeItems || !activeItems) {
                          return;
                        }
                        var lastItem = activeItems[activeItems.length - 1];
                        var hasHighlightedItems = activeItems.some(function(item) {
                          return item.highlighted;
                        });
                        if (this.config.editItems && !hasHighlightedItems && lastItem) {
                          this.input.value = lastItem.value;
                          this.input.setWidth();
                          this._removeItem(lastItem);
                          this._triggerChange(lastItem.value);
                        } else {
                          if (!hasHighlightedItems) {
                            this.highlightItem(lastItem, false);
                          }
                          this.removeHighlightedItems(true);
                        }
                      };
                      Choices3.prototype._startLoading = function() {
                        this._store.dispatch((0, misc_1.setIsLoading)(true));
                      };
                      Choices3.prototype._stopLoading = function() {
                        this._store.dispatch((0, misc_1.setIsLoading)(false));
                      };
                      Choices3.prototype._handleLoadingState = function(setLoading) {
                        if (setLoading === void 0) {
                          setLoading = true;
                        }
                        var placeholderItem = this.itemList.getChild(".".concat(this.config.classNames.placeholder));
                        if (setLoading) {
                          this.disable();
                          this.containerOuter.addLoadingState();
                          if (this._isSelectOneElement) {
                            if (!placeholderItem) {
                              placeholderItem = this._getTemplate("placeholder", this.config.loadingText);
                              if (placeholderItem) {
                                this.itemList.append(placeholderItem);
                              }
                            } else {
                              placeholderItem.innerHTML = this.config.loadingText;
                            }
                          } else {
                            this.input.placeholder = this.config.loadingText;
                          }
                        } else {
                          this.enable();
                          this.containerOuter.removeLoadingState();
                          if (this._isSelectOneElement) {
                            if (placeholderItem) {
                              placeholderItem.innerHTML = this._placeholderValue || "";
                            }
                          } else {
                            this.input.placeholder = this._placeholderValue || "";
                          }
                        }
                      };
                      Choices3.prototype._handleSearch = function(value2) {
                        if (!this.input.isFocussed) {
                          return;
                        }
                        var choices = this._store.choices;
                        var _a = this.config, searchFloor = _a.searchFloor, searchChoices = _a.searchChoices;
                        var hasUnactiveChoices = choices.some(function(option2) {
                          return !option2.active;
                        });
                        if (value2 !== null && typeof value2 !== "undefined" && value2.length >= searchFloor) {
                          var resultCount = searchChoices ? this._searchChoices(value2) : 0;
                          this.passedElement.triggerEvent(constants_1.EVENTS.search, {
                            value: value2,
                            resultCount
                          });
                        } else if (hasUnactiveChoices) {
                          this._isSearching = false;
                          this._store.dispatch((0, choices_1.activateChoices)(true));
                        }
                      };
                      Choices3.prototype._canAddItem = function(activeItems, value2) {
                        var canAddItem = true;
                        var notice = typeof this.config.addItemText === "function" ? this.config.addItemText(value2) : this.config.addItemText;
                        if (!this._isSelectOneElement) {
                          var isDuplicateValue = (0, utils_1.existsInArray)(activeItems, value2);
                          if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {
                            canAddItem = false;
                            notice = typeof this.config.maxItemText === "function" ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;
                          }
                          if (!this.config.duplicateItemsAllowed && isDuplicateValue && canAddItem) {
                            canAddItem = false;
                            notice = typeof this.config.uniqueItemText === "function" ? this.config.uniqueItemText(value2) : this.config.uniqueItemText;
                          }
                          if (this._isTextElement && this.config.addItems && canAddItem && typeof this.config.addItemFilter === "function" && !this.config.addItemFilter(value2)) {
                            canAddItem = false;
                            notice = typeof this.config.customAddItemText === "function" ? this.config.customAddItemText(value2) : this.config.customAddItemText;
                          }
                        }
                        return {
                          response: canAddItem,
                          notice
                        };
                      };
                      Choices3.prototype._searchChoices = function(value2) {
                        var newValue = typeof value2 === "string" ? value2.trim() : value2;
                        var currentValue = typeof this._currentValue === "string" ? this._currentValue.trim() : this._currentValue;
                        if (newValue.length < 1 && newValue === "".concat(currentValue, " ")) {
                          return 0;
                        }
                        var haystack = this._store.searchableChoices;
                        var needle = newValue;
                        var options = Object.assign(this.config.fuseOptions, {
                          keys: __spreadArray2([], this.config.searchFields, true),
                          includeMatches: true
                        });
                        var fuse = new fuse_js_1.default(haystack, options);
                        var results = fuse.search(needle);
                        this._currentValue = newValue;
                        this._highlightPosition = 0;
                        this._isSearching = true;
                        this._store.dispatch((0, choices_1.filterChoices)(results));
                        return results.length;
                      };
                      Choices3.prototype._addEventListeners = function() {
                        var documentElement = document.documentElement;
                        documentElement.addEventListener("touchend", this._onTouchEnd, true);
                        this.containerOuter.element.addEventListener("keydown", this._onKeyDown, true);
                        this.containerOuter.element.addEventListener("mousedown", this._onMouseDown, true);
                        documentElement.addEventListener("click", this._onClick, {
                          passive: true
                        });
                        documentElement.addEventListener("touchmove", this._onTouchMove, {
                          passive: true
                        });
                        this.dropdown.element.addEventListener("mouseover", this._onMouseOver, {
                          passive: true
                        });
                        if (this._isSelectOneElement) {
                          this.containerOuter.element.addEventListener("focus", this._onFocus, {
                            passive: true
                          });
                          this.containerOuter.element.addEventListener("blur", this._onBlur, {
                            passive: true
                          });
                        }
                        this.input.element.addEventListener("keyup", this._onKeyUp, {
                          passive: true
                        });
                        this.input.element.addEventListener("focus", this._onFocus, {
                          passive: true
                        });
                        this.input.element.addEventListener("blur", this._onBlur, {
                          passive: true
                        });
                        if (this.input.element.form) {
                          this.input.element.form.addEventListener("reset", this._onFormReset, {
                            passive: true
                          });
                        }
                        this.input.addEventListeners();
                      };
                      Choices3.prototype._removeEventListeners = function() {
                        var documentElement = document.documentElement;
                        documentElement.removeEventListener("touchend", this._onTouchEnd, true);
                        this.containerOuter.element.removeEventListener("keydown", this._onKeyDown, true);
                        this.containerOuter.element.removeEventListener("mousedown", this._onMouseDown, true);
                        documentElement.removeEventListener("click", this._onClick);
                        documentElement.removeEventListener("touchmove", this._onTouchMove);
                        this.dropdown.element.removeEventListener("mouseover", this._onMouseOver);
                        if (this._isSelectOneElement) {
                          this.containerOuter.element.removeEventListener("focus", this._onFocus);
                          this.containerOuter.element.removeEventListener("blur", this._onBlur);
                        }
                        this.input.element.removeEventListener("keyup", this._onKeyUp);
                        this.input.element.removeEventListener("focus", this._onFocus);
                        this.input.element.removeEventListener("blur", this._onBlur);
                        if (this.input.element.form) {
                          this.input.element.form.removeEventListener("reset", this._onFormReset);
                        }
                        this.input.removeEventListeners();
                      };
                      Choices3.prototype._onKeyDown = function(event) {
                        var keyCode = event.keyCode;
                        var activeItems = this._store.activeItems;
                        var hasFocusedInput = this.input.isFocussed;
                        var hasActiveDropdown = this.dropdown.isActive;
                        var hasItems = this.itemList.hasChildren();
                        var keyString = String.fromCharCode(keyCode);
                        var wasPrintableChar = /[^\x00-\x1F]/.test(keyString);
                        var BACK_KEY = constants_1.KEY_CODES.BACK_KEY, DELETE_KEY = constants_1.KEY_CODES.DELETE_KEY, ENTER_KEY = constants_1.KEY_CODES.ENTER_KEY, A_KEY = constants_1.KEY_CODES.A_KEY, ESC_KEY = constants_1.KEY_CODES.ESC_KEY, UP_KEY = constants_1.KEY_CODES.UP_KEY, DOWN_KEY = constants_1.KEY_CODES.DOWN_KEY, PAGE_UP_KEY = constants_1.KEY_CODES.PAGE_UP_KEY, PAGE_DOWN_KEY = constants_1.KEY_CODES.PAGE_DOWN_KEY;
                        if (!this._isTextElement && !hasActiveDropdown && wasPrintableChar) {
                          this.showDropdown();
                          if (!this.input.isFocussed) {
                            this.input.value += event.key.toLowerCase();
                          }
                        }
                        switch (keyCode) {
                          case A_KEY:
                            return this._onSelectKey(event, hasItems);
                          case ENTER_KEY:
                            return this._onEnterKey(event, activeItems, hasActiveDropdown);
                          case ESC_KEY:
                            return this._onEscapeKey(hasActiveDropdown);
                          case UP_KEY:
                          case PAGE_UP_KEY:
                          case DOWN_KEY:
                          case PAGE_DOWN_KEY:
                            return this._onDirectionKey(event, hasActiveDropdown);
                          case DELETE_KEY:
                          case BACK_KEY:
                            return this._onDeleteKey(event, activeItems, hasFocusedInput);
                          default:
                        }
                      };
                      Choices3.prototype._onKeyUp = function(_a) {
                        var target = _a.target, keyCode = _a.keyCode;
                        var value2 = this.input.value;
                        var activeItems = this._store.activeItems;
                        var canAddItem = this._canAddItem(activeItems, value2);
                        var backKey = constants_1.KEY_CODES.BACK_KEY, deleteKey2 = constants_1.KEY_CODES.DELETE_KEY;
                        if (this._isTextElement) {
                          var canShowDropdownNotice = canAddItem.notice && value2;
                          if (canShowDropdownNotice) {
                            var dropdownItem = this._getTemplate("notice", canAddItem.notice);
                            this.dropdown.element.innerHTML = dropdownItem.outerHTML;
                            this.showDropdown(true);
                          } else {
                            this.hideDropdown(true);
                          }
                        } else {
                          var wasRemovalKeyCode = keyCode === backKey || keyCode === deleteKey2;
                          var userHasRemovedValue = wasRemovalKeyCode && target && !target.value;
                          var canReactivateChoices = !this._isTextElement && this._isSearching;
                          var canSearch = this._canSearch && canAddItem.response;
                          if (userHasRemovedValue && canReactivateChoices) {
                            this._isSearching = false;
                            this._store.dispatch((0, choices_1.activateChoices)(true));
                          } else if (canSearch) {
                            this._handleSearch(this.input.rawValue);
                          }
                        }
                        this._canSearch = this.config.searchEnabled;
                      };
                      Choices3.prototype._onSelectKey = function(event, hasItems) {
                        var ctrlKey = event.ctrlKey, metaKey = event.metaKey;
                        var hasCtrlDownKeyPressed = ctrlKey || metaKey;
                        if (hasCtrlDownKeyPressed && hasItems) {
                          this._canSearch = false;
                          var shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;
                          if (shouldHightlightAll) {
                            this.highlightAll();
                          }
                        }
                      };
                      Choices3.prototype._onEnterKey = function(event, activeItems, hasActiveDropdown) {
                        var target = event.target;
                        var enterKey = constants_1.KEY_CODES.ENTER_KEY;
                        var targetWasButton = target && target.hasAttribute("data-button");
                        if (this._isTextElement && target && target.value) {
                          var value2 = this.input.value;
                          var canAddItem = this._canAddItem(activeItems, value2);
                          if (canAddItem.response) {
                            this.hideDropdown(true);
                            this._addItem({
                              value: value2
                            });
                            this._triggerChange(value2);
                            this.clearInput();
                          }
                        }
                        if (targetWasButton) {
                          this._handleButtonAction(activeItems, target);
                          event.preventDefault();
                        }
                        if (hasActiveDropdown) {
                          var highlightedChoice = this.dropdown.getChild(".".concat(this.config.classNames.highlightedState));
                          if (highlightedChoice) {
                            if (activeItems[0]) {
                              activeItems[0].keyCode = enterKey;
                            }
                            this._handleChoiceAction(activeItems, highlightedChoice);
                          }
                          event.preventDefault();
                        } else if (this._isSelectOneElement) {
                          this.showDropdown();
                          event.preventDefault();
                        }
                      };
                      Choices3.prototype._onEscapeKey = function(hasActiveDropdown) {
                        if (hasActiveDropdown) {
                          this.hideDropdown(true);
                          this.containerOuter.focus();
                        }
                      };
                      Choices3.prototype._onDirectionKey = function(event, hasActiveDropdown) {
                        var keyCode = event.keyCode, metaKey = event.metaKey;
                        var downKey = constants_1.KEY_CODES.DOWN_KEY, pageUpKey = constants_1.KEY_CODES.PAGE_UP_KEY, pageDownKey = constants_1.KEY_CODES.PAGE_DOWN_KEY;
                        if (hasActiveDropdown || this._isSelectOneElement) {
                          this.showDropdown();
                          this._canSearch = false;
                          var directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;
                          var skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;
                          var selectableChoiceIdentifier = "[data-choice-selectable]";
                          var nextEl2 = void 0;
                          if (skipKey) {
                            if (directionInt > 0) {
                              nextEl2 = this.dropdown.element.querySelector("".concat(selectableChoiceIdentifier, ":last-of-type"));
                            } else {
                              nextEl2 = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                            }
                          } else {
                            var currentEl = this.dropdown.element.querySelector(".".concat(this.config.classNames.highlightedState));
                            if (currentEl) {
                              nextEl2 = (0, utils_1.getAdjacentEl)(currentEl, selectableChoiceIdentifier, directionInt);
                            } else {
                              nextEl2 = this.dropdown.element.querySelector(selectableChoiceIdentifier);
                            }
                          }
                          if (nextEl2) {
                            if (!(0, utils_1.isScrolledIntoView)(nextEl2, this.choiceList.element, directionInt)) {
                              this.choiceList.scrollToChildElement(nextEl2, directionInt);
                            }
                            this._highlightChoice(nextEl2);
                          }
                          event.preventDefault();
                        }
                      };
                      Choices3.prototype._onDeleteKey = function(event, activeItems, hasFocusedInput) {
                        var target = event.target;
                        if (!this._isSelectOneElement && !target.value && hasFocusedInput) {
                          this._handleBackspace(activeItems);
                          event.preventDefault();
                        }
                      };
                      Choices3.prototype._onTouchMove = function() {
                        if (this._wasTap) {
                          this._wasTap = false;
                        }
                      };
                      Choices3.prototype._onTouchEnd = function(event) {
                        var target = (event || event.touches[0]).target;
                        var touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);
                        if (touchWasWithinContainer) {
                          var containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;
                          if (containerWasExactTarget) {
                            if (this._isTextElement) {
                              this.input.focus();
                            } else if (this._isSelectMultipleElement) {
                              this.showDropdown();
                            }
                          }
                          event.stopPropagation();
                        }
                        this._wasTap = true;
                      };
                      Choices3.prototype._onMouseDown = function(event) {
                        var target = event.target;
                        if (!(target instanceof HTMLElement)) {
                          return;
                        }
                        if (IS_IE11 && this.choiceList.element.contains(target)) {
                          var firstChoice = this.choiceList.element.firstElementChild;
                          var isOnScrollbar = this._direction === "ltr" ? event.offsetX >= firstChoice.offsetWidth : event.offsetX < firstChoice.offsetLeft;
                          this._isScrollingOnIe = isOnScrollbar;
                        }
                        if (target === this.input.element) {
                          return;
                        }
                        var item = target.closest("[data-button],[data-item],[data-choice]");
                        if (item instanceof HTMLElement) {
                          var hasShiftKey = event.shiftKey;
                          var activeItems = this._store.activeItems;
                          var dataset = item.dataset;
                          if ("button" in dataset) {
                            this._handleButtonAction(activeItems, item);
                          } else if ("item" in dataset) {
                            this._handleItemAction(activeItems, item, hasShiftKey);
                          } else if ("choice" in dataset) {
                            this._handleChoiceAction(activeItems, item);
                          }
                        }
                        event.preventDefault();
                      };
                      Choices3.prototype._onMouseOver = function(_a) {
                        var target = _a.target;
                        if (target instanceof HTMLElement && "choice" in target.dataset) {
                          this._highlightChoice(target);
                        }
                      };
                      Choices3.prototype._onClick = function(_a) {
                        var target = _a.target;
                        var clickWasWithinContainer = this.containerOuter.element.contains(target);
                        if (clickWasWithinContainer) {
                          if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {
                            if (this._isTextElement) {
                              if (document.activeElement !== this.input.element) {
                                this.input.focus();
                              }
                            } else {
                              this.showDropdown();
                              this.containerOuter.focus();
                            }
                          } else if (this._isSelectOneElement && target !== this.input.element && !this.dropdown.element.contains(target)) {
                            this.hideDropdown();
                          }
                        } else {
                          var hasHighlightedItems = this._store.highlightedActiveItems.length > 0;
                          if (hasHighlightedItems) {
                            this.unhighlightAll();
                          }
                          this.containerOuter.removeFocusState();
                          this.hideDropdown(true);
                        }
                      };
                      Choices3.prototype._onFocus = function(_a) {
                        var _b;
                        var _this = this;
                        var target = _a.target;
                        var focusWasWithinContainer = target && this.containerOuter.element.contains(target);
                        if (!focusWasWithinContainer) {
                          return;
                        }
                        var focusActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function() {
                          if (target === _this.input.element) {
                            _this.containerOuter.addFocusState();
                          }
                        }, _b[constants_1.SELECT_ONE_TYPE] = function() {
                          _this.containerOuter.addFocusState();
                          if (target === _this.input.element) {
                            _this.showDropdown(true);
                          }
                        }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function() {
                          if (target === _this.input.element) {
                            _this.showDropdown(true);
                            _this.containerOuter.addFocusState();
                          }
                        }, _b);
                        focusActions[this.passedElement.element.type]();
                      };
                      Choices3.prototype._onBlur = function(_a) {
                        var _b;
                        var _this = this;
                        var target = _a.target;
                        var blurWasWithinContainer = target && this.containerOuter.element.contains(target);
                        if (blurWasWithinContainer && !this._isScrollingOnIe) {
                          var activeItems = this._store.activeItems;
                          var hasHighlightedItems_1 = activeItems.some(function(item) {
                            return item.highlighted;
                          });
                          var blurActions = (_b = {}, _b[constants_1.TEXT_TYPE] = function() {
                            if (target === _this.input.element) {
                              _this.containerOuter.removeFocusState();
                              if (hasHighlightedItems_1) {
                                _this.unhighlightAll();
                              }
                              _this.hideDropdown(true);
                            }
                          }, _b[constants_1.SELECT_ONE_TYPE] = function() {
                            _this.containerOuter.removeFocusState();
                            if (target === _this.input.element || target === _this.containerOuter.element && !_this._canSearch) {
                              _this.hideDropdown(true);
                            }
                          }, _b[constants_1.SELECT_MULTIPLE_TYPE] = function() {
                            if (target === _this.input.element) {
                              _this.containerOuter.removeFocusState();
                              _this.hideDropdown(true);
                              if (hasHighlightedItems_1) {
                                _this.unhighlightAll();
                              }
                            }
                          }, _b);
                          blurActions[this.passedElement.element.type]();
                        } else {
                          this._isScrollingOnIe = false;
                          this.input.element.focus();
                        }
                      };
                      Choices3.prototype._onFormReset = function() {
                        this._store.dispatch((0, misc_1.resetTo)(this._initialState));
                      };
                      Choices3.prototype._highlightChoice = function(el) {
                        var _this = this;
                        if (el === void 0) {
                          el = null;
                        }
                        var choices = Array.from(this.dropdown.element.querySelectorAll("[data-choice-selectable]"));
                        if (!choices.length) {
                          return;
                        }
                        var passedEl = el;
                        var highlightedChoices = Array.from(this.dropdown.element.querySelectorAll(".".concat(this.config.classNames.highlightedState)));
                        highlightedChoices.forEach(function(choice) {
                          choice.classList.remove(_this.config.classNames.highlightedState);
                          choice.setAttribute("aria-selected", "false");
                        });
                        if (passedEl) {
                          this._highlightPosition = choices.indexOf(passedEl);
                        } else {
                          if (choices.length > this._highlightPosition) {
                            passedEl = choices[this._highlightPosition];
                          } else {
                            passedEl = choices[choices.length - 1];
                          }
                          if (!passedEl) {
                            passedEl = choices[0];
                          }
                        }
                        passedEl.classList.add(this.config.classNames.highlightedState);
                        passedEl.setAttribute("aria-selected", "true");
                        this.passedElement.triggerEvent(constants_1.EVENTS.highlightChoice, {
                          el: passedEl
                        });
                        if (this.dropdown.isActive) {
                          this.input.setActiveDescendant(passedEl.id);
                          this.containerOuter.setActiveDescendant(passedEl.id);
                        }
                      };
                      Choices3.prototype._addItem = function(_a) {
                        var value2 = _a.value, _b = _a.label, label = _b === void 0 ? null : _b, _c = _a.choiceId, choiceId = _c === void 0 ? -1 : _c, _d = _a.groupId, groupId = _d === void 0 ? -1 : _d, _e = _a.customProperties, customProperties = _e === void 0 ? {} : _e, _f = _a.placeholder, placeholder = _f === void 0 ? false : _f, _g = _a.keyCode, keyCode = _g === void 0 ? -1 : _g;
                        var passedValue = typeof value2 === "string" ? value2.trim() : value2;
                        var items = this._store.items;
                        var passedLabel = label || passedValue;
                        var passedOptionId = choiceId || -1;
                        var group3 = groupId >= 0 ? this._store.getGroupById(groupId) : null;
                        var id4 = items ? items.length + 1 : 1;
                        if (this.config.prependValue) {
                          passedValue = this.config.prependValue + passedValue.toString();
                        }
                        if (this.config.appendValue) {
                          passedValue += this.config.appendValue.toString();
                        }
                        this._store.dispatch((0, items_1.addItem)({
                          value: passedValue,
                          label: passedLabel,
                          id: id4,
                          choiceId: passedOptionId,
                          groupId,
                          customProperties,
                          placeholder,
                          keyCode
                        }));
                        if (this._isSelectOneElement) {
                          this.removeActiveItems(id4);
                        }
                        this.passedElement.triggerEvent(constants_1.EVENTS.addItem, {
                          id: id4,
                          value: passedValue,
                          label: passedLabel,
                          customProperties,
                          groupValue: group3 && group3.value ? group3.value : null,
                          keyCode
                        });
                      };
                      Choices3.prototype._removeItem = function(item) {
                        var id4 = item.id, value2 = item.value, label = item.label, customProperties = item.customProperties, choiceId = item.choiceId, groupId = item.groupId;
                        var group3 = groupId && groupId >= 0 ? this._store.getGroupById(groupId) : null;
                        if (!id4 || !choiceId) {
                          return;
                        }
                        this._store.dispatch((0, items_1.removeItem)(id4, choiceId));
                        this.passedElement.triggerEvent(constants_1.EVENTS.removeItem, {
                          id: id4,
                          value: value2,
                          label,
                          customProperties,
                          groupValue: group3 && group3.value ? group3.value : null
                        });
                      };
                      Choices3.prototype._addChoice = function(_a) {
                        var value2 = _a.value, _b = _a.label, label = _b === void 0 ? null : _b, _c = _a.isSelected, isSelected = _c === void 0 ? false : _c, _d = _a.isDisabled, isDisabled = _d === void 0 ? false : _d, _e = _a.groupId, groupId = _e === void 0 ? -1 : _e, _f = _a.customProperties, customProperties = _f === void 0 ? {} : _f, _g = _a.placeholder, placeholder = _g === void 0 ? false : _g, _h = _a.keyCode, keyCode = _h === void 0 ? -1 : _h;
                        if (typeof value2 === "undefined" || value2 === null) {
                          return;
                        }
                        var choices = this._store.choices;
                        var choiceLabel = label || value2;
                        var choiceId = choices ? choices.length + 1 : 1;
                        var choiceElementId = "".concat(this._baseId, "-").concat(this._idNames.itemChoice, "-").concat(choiceId);
                        this._store.dispatch((0, choices_1.addChoice)({
                          id: choiceId,
                          groupId,
                          elementId: choiceElementId,
                          value: value2,
                          label: choiceLabel,
                          disabled: isDisabled,
                          customProperties,
                          placeholder,
                          keyCode
                        }));
                        if (isSelected) {
                          this._addItem({
                            value: value2,
                            label: choiceLabel,
                            choiceId,
                            customProperties,
                            placeholder,
                            keyCode
                          });
                        }
                      };
                      Choices3.prototype._addGroup = function(_a) {
                        var _this = this;
                        var group3 = _a.group, id4 = _a.id, _b = _a.valueKey, valueKey = _b === void 0 ? "value" : _b, _c = _a.labelKey, labelKey = _c === void 0 ? "label" : _c;
                        var groupChoices = (0, utils_1.isType)("Object", group3) ? group3.choices : Array.from(group3.getElementsByTagName("OPTION"));
                        var groupId = id4 || Math.floor((/* @__PURE__ */ new Date()).valueOf() * Math.random());
                        var isDisabled = group3.disabled ? group3.disabled : false;
                        if (groupChoices) {
                          this._store.dispatch((0, groups_1.addGroup)({
                            value: group3.label,
                            id: groupId,
                            active: true,
                            disabled: isDisabled
                          }));
                          var addGroupChoices = function(choice) {
                            var isOptDisabled = choice.disabled || choice.parentNode && choice.parentNode.disabled;
                            _this._addChoice({
                              value: choice[valueKey],
                              label: (0, utils_1.isType)("Object", choice) ? choice[labelKey] : choice.innerHTML,
                              isSelected: choice.selected,
                              isDisabled: isOptDisabled,
                              groupId,
                              customProperties: choice.customProperties,
                              placeholder: choice.placeholder
                            });
                          };
                          groupChoices.forEach(addGroupChoices);
                        } else {
                          this._store.dispatch((0, groups_1.addGroup)({
                            value: group3.label,
                            id: group3.id,
                            active: false,
                            disabled: group3.disabled
                          }));
                        }
                      };
                      Choices3.prototype._getTemplate = function(template) {
                        var _a;
                        var args = [];
                        for (var _i = 1; _i < arguments.length; _i++) {
                          args[_i - 1] = arguments[_i];
                        }
                        return (_a = this._templates[template]).call.apply(_a, __spreadArray2([this, this.config], args, false));
                      };
                      Choices3.prototype._createTemplates = function() {
                        var callbackOnCreateTemplates = this.config.callbackOnCreateTemplates;
                        var userTemplates = {};
                        if (callbackOnCreateTemplates && typeof callbackOnCreateTemplates === "function") {
                          userTemplates = callbackOnCreateTemplates.call(this, utils_1.strToEl);
                        }
                        this._templates = (0, deepmerge_1.default)(templates_1.default, userTemplates);
                      };
                      Choices3.prototype._createElements = function() {
                        this.containerOuter = new components_1.Container({
                          element: this._getTemplate("containerOuter", this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type, this.config.labelId),
                          classNames: this.config.classNames,
                          type: this.passedElement.element.type,
                          position: this.config.position
                        });
                        this.containerInner = new components_1.Container({
                          element: this._getTemplate("containerInner"),
                          classNames: this.config.classNames,
                          type: this.passedElement.element.type,
                          position: this.config.position
                        });
                        this.input = new components_1.Input({
                          element: this._getTemplate("input", this._placeholderValue),
                          classNames: this.config.classNames,
                          type: this.passedElement.element.type,
                          preventPaste: !this.config.paste
                        });
                        this.choiceList = new components_1.List({
                          element: this._getTemplate("choiceList", this._isSelectOneElement)
                        });
                        this.itemList = new components_1.List({
                          element: this._getTemplate("itemList", this._isSelectOneElement)
                        });
                        this.dropdown = new components_1.Dropdown({
                          element: this._getTemplate("dropdown"),
                          classNames: this.config.classNames,
                          type: this.passedElement.element.type
                        });
                      };
                      Choices3.prototype._createStructure = function() {
                        this.passedElement.conceal();
                        this.containerInner.wrap(this.passedElement.element);
                        this.containerOuter.wrap(this.containerInner.element);
                        if (this._isSelectOneElement) {
                          this.input.placeholder = this.config.searchPlaceholderValue || "";
                        } else if (this._placeholderValue) {
                          this.input.placeholder = this._placeholderValue;
                          this.input.setWidth();
                        }
                        this.containerOuter.element.appendChild(this.containerInner.element);
                        this.containerOuter.element.appendChild(this.dropdown.element);
                        this.containerInner.element.appendChild(this.itemList.element);
                        if (!this._isTextElement) {
                          this.dropdown.element.appendChild(this.choiceList.element);
                        }
                        if (!this._isSelectOneElement) {
                          this.containerInner.element.appendChild(this.input.element);
                        } else if (this.config.searchEnabled) {
                          this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);
                        }
                        if (this._isSelectElement) {
                          this._highlightPosition = 0;
                          this._isSearching = false;
                          this._startLoading();
                          if (this._presetGroups.length) {
                            this._addPredefinedGroups(this._presetGroups);
                          } else {
                            this._addPredefinedChoices(this._presetChoices);
                          }
                          this._stopLoading();
                        }
                        if (this._isTextElement) {
                          this._addPredefinedItems(this._presetItems);
                        }
                      };
                      Choices3.prototype._addPredefinedGroups = function(groups2) {
                        var _this = this;
                        var placeholderChoice = this.passedElement.placeholderOption;
                        if (placeholderChoice && placeholderChoice.parentNode && placeholderChoice.parentNode.tagName === "SELECT") {
                          this._addChoice({
                            value: placeholderChoice.value,
                            label: placeholderChoice.innerHTML,
                            isSelected: placeholderChoice.selected,
                            isDisabled: placeholderChoice.disabled,
                            placeholder: true
                          });
                        }
                        groups2.forEach(function(group3) {
                          return _this._addGroup({
                            group: group3,
                            id: group3.id || null
                          });
                        });
                      };
                      Choices3.prototype._addPredefinedChoices = function(choices) {
                        var _this = this;
                        if (this.config.shouldSort) {
                          choices.sort(this.config.sorter);
                        }
                        var hasSelectedChoice = choices.some(function(choice) {
                          return choice.selected;
                        });
                        var firstEnabledChoiceIndex = choices.findIndex(function(choice) {
                          return choice.disabled === void 0 || !choice.disabled;
                        });
                        choices.forEach(function(choice, index4) {
                          var _a = choice.value, value2 = _a === void 0 ? "" : _a, label = choice.label, customProperties = choice.customProperties, placeholder = choice.placeholder;
                          if (_this._isSelectElement) {
                            if (choice.choices) {
                              _this._addGroup({
                                group: choice,
                                id: choice.id || null
                              });
                            } else {
                              var shouldPreselect = _this._isSelectOneElement && !hasSelectedChoice && index4 === firstEnabledChoiceIndex;
                              var isSelected = shouldPreselect ? true : choice.selected;
                              var isDisabled = choice.disabled;
                              _this._addChoice({
                                value: value2,
                                label,
                                isSelected: !!isSelected,
                                isDisabled: !!isDisabled,
                                placeholder: !!placeholder,
                                customProperties
                              });
                            }
                          } else {
                            _this._addChoice({
                              value: value2,
                              label,
                              isSelected: !!choice.selected,
                              isDisabled: !!choice.disabled,
                              placeholder: !!choice.placeholder,
                              customProperties
                            });
                          }
                        });
                      };
                      Choices3.prototype._addPredefinedItems = function(items) {
                        var _this = this;
                        items.forEach(function(item) {
                          if (typeof item === "object" && item.value) {
                            _this._addItem({
                              value: item.value,
                              label: item.label,
                              choiceId: item.id,
                              customProperties: item.customProperties,
                              placeholder: item.placeholder
                            });
                          }
                          if (typeof item === "string") {
                            _this._addItem({
                              value: item
                            });
                          }
                        });
                      };
                      Choices3.prototype._setChoiceOrItem = function(item) {
                        var _this = this;
                        var itemType = (0, utils_1.getType)(item).toLowerCase();
                        var handleType = {
                          object: function() {
                            if (!item.value) {
                              return;
                            }
                            if (!_this._isTextElement) {
                              _this._addChoice({
                                value: item.value,
                                label: item.label,
                                isSelected: true,
                                isDisabled: false,
                                customProperties: item.customProperties,
                                placeholder: item.placeholder
                              });
                            } else {
                              _this._addItem({
                                value: item.value,
                                label: item.label,
                                choiceId: item.id,
                                customProperties: item.customProperties,
                                placeholder: item.placeholder
                              });
                            }
                          },
                          string: function() {
                            if (!_this._isTextElement) {
                              _this._addChoice({
                                value: item,
                                label: item,
                                isSelected: true,
                                isDisabled: false
                              });
                            } else {
                              _this._addItem({
                                value: item
                              });
                            }
                          }
                        };
                        handleType[itemType]();
                      };
                      Choices3.prototype._findAndSelectChoiceByValue = function(value2) {
                        var _this = this;
                        var choices = this._store.choices;
                        var foundChoice = choices.find(function(choice) {
                          return _this.config.valueComparer(choice.value, value2);
                        });
                        if (foundChoice && !foundChoice.selected) {
                          this._addItem({
                            value: foundChoice.value,
                            label: foundChoice.label,
                            choiceId: foundChoice.id,
                            groupId: foundChoice.groupId,
                            customProperties: foundChoice.customProperties,
                            placeholder: foundChoice.placeholder,
                            keyCode: foundChoice.keyCode
                          });
                        }
                      };
                      Choices3.prototype._generatePlaceholderValue = function() {
                        if (this._isSelectElement && this.passedElement.placeholderOption) {
                          var placeholderOption = this.passedElement.placeholderOption;
                          return placeholderOption ? placeholderOption.text : null;
                        }
                        var _a = this.config, placeholder = _a.placeholder, placeholderValue = _a.placeholderValue;
                        var dataset = this.passedElement.element.dataset;
                        if (placeholder) {
                          if (placeholderValue) {
                            return placeholderValue;
                          }
                          if (dataset.placeholder) {
                            return dataset.placeholder;
                          }
                        }
                        return null;
                      };
                      return Choices3;
                    }()
                  );
                  exports2["default"] = Choices2;
                }
              ),
              /***/
              613: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var utils_1 = __webpack_require__2(799);
                  var constants_1 = __webpack_require__2(883);
                  var Container2 = (
                    /** @class */
                    function() {
                      function Container3(_a) {
                        var element = _a.element, type = _a.type, classNames2 = _a.classNames, position = _a.position;
                        this.element = element;
                        this.classNames = classNames2;
                        this.type = type;
                        this.position = position;
                        this.isOpen = false;
                        this.isFlipped = false;
                        this.isFocussed = false;
                        this.isDisabled = false;
                        this.isLoading = false;
                        this._onFocus = this._onFocus.bind(this);
                        this._onBlur = this._onBlur.bind(this);
                      }
                      Container3.prototype.addEventListeners = function() {
                        this.element.addEventListener("focus", this._onFocus);
                        this.element.addEventListener("blur", this._onBlur);
                      };
                      Container3.prototype.removeEventListeners = function() {
                        this.element.removeEventListener("focus", this._onFocus);
                        this.element.removeEventListener("blur", this._onBlur);
                      };
                      Container3.prototype.shouldFlip = function(dropdownPos) {
                        if (typeof dropdownPos !== "number") {
                          return false;
                        }
                        var shouldFlip = false;
                        if (this.position === "auto") {
                          shouldFlip = !window.matchMedia("(min-height: ".concat(dropdownPos + 1, "px)")).matches;
                        } else if (this.position === "top") {
                          shouldFlip = true;
                        }
                        return shouldFlip;
                      };
                      Container3.prototype.setActiveDescendant = function(activeDescendantID) {
                        this.element.setAttribute("aria-activedescendant", activeDescendantID);
                      };
                      Container3.prototype.removeActiveDescendant = function() {
                        this.element.removeAttribute("aria-activedescendant");
                      };
                      Container3.prototype.open = function(dropdownPos) {
                        this.element.classList.add(this.classNames.openState);
                        this.element.setAttribute("aria-expanded", "true");
                        this.isOpen = true;
                        if (this.shouldFlip(dropdownPos)) {
                          this.element.classList.add(this.classNames.flippedState);
                          this.isFlipped = true;
                        }
                      };
                      Container3.prototype.close = function() {
                        this.element.classList.remove(this.classNames.openState);
                        this.element.setAttribute("aria-expanded", "false");
                        this.removeActiveDescendant();
                        this.isOpen = false;
                        if (this.isFlipped) {
                          this.element.classList.remove(this.classNames.flippedState);
                          this.isFlipped = false;
                        }
                      };
                      Container3.prototype.focus = function() {
                        if (!this.isFocussed) {
                          this.element.focus();
                        }
                      };
                      Container3.prototype.addFocusState = function() {
                        this.element.classList.add(this.classNames.focusState);
                      };
                      Container3.prototype.removeFocusState = function() {
                        this.element.classList.remove(this.classNames.focusState);
                      };
                      Container3.prototype.enable = function() {
                        this.element.classList.remove(this.classNames.disabledState);
                        this.element.removeAttribute("aria-disabled");
                        if (this.type === constants_1.SELECT_ONE_TYPE) {
                          this.element.setAttribute("tabindex", "0");
                        }
                        this.isDisabled = false;
                      };
                      Container3.prototype.disable = function() {
                        this.element.classList.add(this.classNames.disabledState);
                        this.element.setAttribute("aria-disabled", "true");
                        if (this.type === constants_1.SELECT_ONE_TYPE) {
                          this.element.setAttribute("tabindex", "-1");
                        }
                        this.isDisabled = true;
                      };
                      Container3.prototype.wrap = function(element) {
                        (0, utils_1.wrap)(element, this.element);
                      };
                      Container3.prototype.unwrap = function(element) {
                        if (this.element.parentNode) {
                          this.element.parentNode.insertBefore(element, this.element);
                          this.element.parentNode.removeChild(this.element);
                        }
                      };
                      Container3.prototype.addLoadingState = function() {
                        this.element.classList.add(this.classNames.loadingState);
                        this.element.setAttribute("aria-busy", "true");
                        this.isLoading = true;
                      };
                      Container3.prototype.removeLoadingState = function() {
                        this.element.classList.remove(this.classNames.loadingState);
                        this.element.removeAttribute("aria-busy");
                        this.isLoading = false;
                      };
                      Container3.prototype._onFocus = function() {
                        this.isFocussed = true;
                      };
                      Container3.prototype._onBlur = function() {
                        this.isFocussed = false;
                      };
                      return Container3;
                    }()
                  );
                  exports2["default"] = Container2;
                }
              ),
              /***/
              217: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var Dropdown = (
                    /** @class */
                    function() {
                      function Dropdown2(_a) {
                        var element = _a.element, type = _a.type, classNames2 = _a.classNames;
                        this.element = element;
                        this.classNames = classNames2;
                        this.type = type;
                        this.isActive = false;
                      }
                      Object.defineProperty(Dropdown2.prototype, "distanceFromTopWindow", {
                        /**
                         * Bottom position of dropdown in viewport coordinates
                         */
                        get: function() {
                          return this.element.getBoundingClientRect().bottom;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Dropdown2.prototype.getChild = function(selector) {
                        return this.element.querySelector(selector);
                      };
                      Dropdown2.prototype.show = function() {
                        this.element.classList.add(this.classNames.activeState);
                        this.element.setAttribute("aria-expanded", "true");
                        this.isActive = true;
                        return this;
                      };
                      Dropdown2.prototype.hide = function() {
                        this.element.classList.remove(this.classNames.activeState);
                        this.element.setAttribute("aria-expanded", "false");
                        this.isActive = false;
                        return this;
                      };
                      return Dropdown2;
                    }()
                  );
                  exports2["default"] = Dropdown;
                }
              ),
              /***/
              520: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __importDefault = this && this.__importDefault || function(mod3) {
                    return mod3 && mod3.__esModule ? mod3 : {
                      "default": mod3
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.WrappedSelect = exports2.WrappedInput = exports2.List = exports2.Input = exports2.Container = exports2.Dropdown = void 0;
                  var dropdown_1 = __importDefault(__webpack_require__2(217));
                  exports2.Dropdown = dropdown_1.default;
                  var container_1 = __importDefault(__webpack_require__2(613));
                  exports2.Container = container_1.default;
                  var input_1 = __importDefault(__webpack_require__2(11));
                  exports2.Input = input_1.default;
                  var list_1 = __importDefault(__webpack_require__2(624));
                  exports2.List = list_1.default;
                  var wrapped_input_1 = __importDefault(__webpack_require__2(541));
                  exports2.WrappedInput = wrapped_input_1.default;
                  var wrapped_select_1 = __importDefault(__webpack_require__2(982));
                  exports2.WrappedSelect = wrapped_select_1.default;
                }
              ),
              /***/
              11: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var utils_1 = __webpack_require__2(799);
                  var constants_1 = __webpack_require__2(883);
                  var Input = (
                    /** @class */
                    function() {
                      function Input2(_a) {
                        var element = _a.element, type = _a.type, classNames2 = _a.classNames, preventPaste = _a.preventPaste;
                        this.element = element;
                        this.type = type;
                        this.classNames = classNames2;
                        this.preventPaste = preventPaste;
                        this.isFocussed = this.element.isEqualNode(document.activeElement);
                        this.isDisabled = element.disabled;
                        this._onPaste = this._onPaste.bind(this);
                        this._onInput = this._onInput.bind(this);
                        this._onFocus = this._onFocus.bind(this);
                        this._onBlur = this._onBlur.bind(this);
                      }
                      Object.defineProperty(Input2.prototype, "placeholder", {
                        set: function(placeholder) {
                          this.element.placeholder = placeholder;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Input2.prototype, "value", {
                        get: function() {
                          return (0, utils_1.sanitise)(this.element.value);
                        },
                        set: function(value2) {
                          this.element.value = value2;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Input2.prototype, "rawValue", {
                        get: function() {
                          return this.element.value;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Input2.prototype.addEventListeners = function() {
                        this.element.addEventListener("paste", this._onPaste);
                        this.element.addEventListener("input", this._onInput, {
                          passive: true
                        });
                        this.element.addEventListener("focus", this._onFocus, {
                          passive: true
                        });
                        this.element.addEventListener("blur", this._onBlur, {
                          passive: true
                        });
                      };
                      Input2.prototype.removeEventListeners = function() {
                        this.element.removeEventListener("input", this._onInput);
                        this.element.removeEventListener("paste", this._onPaste);
                        this.element.removeEventListener("focus", this._onFocus);
                        this.element.removeEventListener("blur", this._onBlur);
                      };
                      Input2.prototype.enable = function() {
                        this.element.removeAttribute("disabled");
                        this.isDisabled = false;
                      };
                      Input2.prototype.disable = function() {
                        this.element.setAttribute("disabled", "");
                        this.isDisabled = true;
                      };
                      Input2.prototype.focus = function() {
                        if (!this.isFocussed) {
                          this.element.focus();
                        }
                      };
                      Input2.prototype.blur = function() {
                        if (this.isFocussed) {
                          this.element.blur();
                        }
                      };
                      Input2.prototype.clear = function(setWidth) {
                        if (setWidth === void 0) {
                          setWidth = true;
                        }
                        if (this.element.value) {
                          this.element.value = "";
                        }
                        if (setWidth) {
                          this.setWidth();
                        }
                        return this;
                      };
                      Input2.prototype.setWidth = function() {
                        var _a = this.element, style = _a.style, value2 = _a.value, placeholder = _a.placeholder;
                        style.minWidth = "".concat(placeholder.length + 1, "ch");
                        style.width = "".concat(value2.length + 1, "ch");
                      };
                      Input2.prototype.setActiveDescendant = function(activeDescendantID) {
                        this.element.setAttribute("aria-activedescendant", activeDescendantID);
                      };
                      Input2.prototype.removeActiveDescendant = function() {
                        this.element.removeAttribute("aria-activedescendant");
                      };
                      Input2.prototype._onInput = function() {
                        if (this.type !== constants_1.SELECT_ONE_TYPE) {
                          this.setWidth();
                        }
                      };
                      Input2.prototype._onPaste = function(event) {
                        if (this.preventPaste) {
                          event.preventDefault();
                        }
                      };
                      Input2.prototype._onFocus = function() {
                        this.isFocussed = true;
                      };
                      Input2.prototype._onBlur = function() {
                        this.isFocussed = false;
                      };
                      return Input2;
                    }()
                  );
                  exports2["default"] = Input;
                }
              ),
              /***/
              624: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var constants_1 = __webpack_require__2(883);
                  var List = (
                    /** @class */
                    function() {
                      function List2(_a) {
                        var element = _a.element;
                        this.element = element;
                        this.scrollPos = this.element.scrollTop;
                        this.height = this.element.offsetHeight;
                      }
                      List2.prototype.clear = function() {
                        this.element.innerHTML = "";
                      };
                      List2.prototype.append = function(node) {
                        this.element.appendChild(node);
                      };
                      List2.prototype.getChild = function(selector) {
                        return this.element.querySelector(selector);
                      };
                      List2.prototype.hasChildren = function() {
                        return this.element.hasChildNodes();
                      };
                      List2.prototype.scrollToTop = function() {
                        this.element.scrollTop = 0;
                      };
                      List2.prototype.scrollToChildElement = function(element, direction2) {
                        var _this = this;
                        if (!element) {
                          return;
                        }
                        var listHeight = this.element.offsetHeight;
                        var listScrollPosition = this.element.scrollTop + listHeight;
                        var elementHeight = element.offsetHeight;
                        var elementPos = element.offsetTop + elementHeight;
                        var destination = direction2 > 0 ? this.element.scrollTop + elementPos - listScrollPosition : element.offsetTop;
                        requestAnimationFrame(function() {
                          _this._animateScroll(destination, direction2);
                        });
                      };
                      List2.prototype._scrollDown = function(scrollPos, strength, destination) {
                        var easing = (destination - scrollPos) / strength;
                        var distance8 = easing > 1 ? easing : 1;
                        this.element.scrollTop = scrollPos + distance8;
                      };
                      List2.prototype._scrollUp = function(scrollPos, strength, destination) {
                        var easing = (scrollPos - destination) / strength;
                        var distance8 = easing > 1 ? easing : 1;
                        this.element.scrollTop = scrollPos - distance8;
                      };
                      List2.prototype._animateScroll = function(destination, direction2) {
                        var _this = this;
                        var strength = constants_1.SCROLLING_SPEED;
                        var choiceListScrollTop = this.element.scrollTop;
                        var continueAnimation = false;
                        if (direction2 > 0) {
                          this._scrollDown(choiceListScrollTop, strength, destination);
                          if (choiceListScrollTop < destination) {
                            continueAnimation = true;
                          }
                        } else {
                          this._scrollUp(choiceListScrollTop, strength, destination);
                          if (choiceListScrollTop > destination) {
                            continueAnimation = true;
                          }
                        }
                        if (continueAnimation) {
                          requestAnimationFrame(function() {
                            _this._animateScroll(destination, direction2);
                          });
                        }
                      };
                      return List2;
                    }()
                  );
                  exports2["default"] = List;
                }
              ),
              /***/
              730: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var utils_1 = __webpack_require__2(799);
                  var WrappedElement = (
                    /** @class */
                    function() {
                      function WrappedElement2(_a) {
                        var element = _a.element, classNames2 = _a.classNames;
                        this.element = element;
                        this.classNames = classNames2;
                        if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLSelectElement)) {
                          throw new TypeError("Invalid element passed");
                        }
                        this.isDisabled = false;
                      }
                      Object.defineProperty(WrappedElement2.prototype, "isActive", {
                        get: function() {
                          return this.element.dataset.choice === "active";
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(WrappedElement2.prototype, "dir", {
                        get: function() {
                          return this.element.dir;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(WrappedElement2.prototype, "value", {
                        get: function() {
                          return this.element.value;
                        },
                        set: function(value2) {
                          this.element.value = value2;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      WrappedElement2.prototype.conceal = function() {
                        this.element.classList.add(this.classNames.input);
                        this.element.hidden = true;
                        this.element.tabIndex = -1;
                        var origStyle = this.element.getAttribute("style");
                        if (origStyle) {
                          this.element.setAttribute("data-choice-orig-style", origStyle);
                        }
                        this.element.setAttribute("data-choice", "active");
                      };
                      WrappedElement2.prototype.reveal = function() {
                        this.element.classList.remove(this.classNames.input);
                        this.element.hidden = false;
                        this.element.removeAttribute("tabindex");
                        var origStyle = this.element.getAttribute("data-choice-orig-style");
                        if (origStyle) {
                          this.element.removeAttribute("data-choice-orig-style");
                          this.element.setAttribute("style", origStyle);
                        } else {
                          this.element.removeAttribute("style");
                        }
                        this.element.removeAttribute("data-choice");
                        this.element.value = this.element.value;
                      };
                      WrappedElement2.prototype.enable = function() {
                        this.element.removeAttribute("disabled");
                        this.element.disabled = false;
                        this.isDisabled = false;
                      };
                      WrappedElement2.prototype.disable = function() {
                        this.element.setAttribute("disabled", "");
                        this.element.disabled = true;
                        this.isDisabled = true;
                      };
                      WrappedElement2.prototype.triggerEvent = function(eventType, data2) {
                        (0, utils_1.dispatchEvent)(this.element, eventType, data2);
                      };
                      return WrappedElement2;
                    }()
                  );
                  exports2["default"] = WrappedElement;
                }
              ),
              /***/
              541: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __extends2 = this && this.__extends || /* @__PURE__ */ function() {
                    var extendStatics2 = function(d2, b) {
                      extendStatics2 = Object.setPrototypeOf || {
                        __proto__: []
                      } instanceof Array && function(d3, b2) {
                        d3.__proto__ = b2;
                      } || function(d3, b2) {
                        for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
                      };
                      return extendStatics2(d2, b);
                    };
                    return function(d2, b) {
                      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                      extendStatics2(d2, b);
                      function __() {
                        this.constructor = d2;
                      }
                      d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                  }();
                  var __importDefault = this && this.__importDefault || function(mod3) {
                    return mod3 && mod3.__esModule ? mod3 : {
                      "default": mod3
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var wrapped_element_1 = __importDefault(__webpack_require__2(730));
                  var WrappedInput = (
                    /** @class */
                    function(_super) {
                      __extends2(WrappedInput2, _super);
                      function WrappedInput2(_a) {
                        var element = _a.element, classNames2 = _a.classNames, delimiter = _a.delimiter;
                        var _this = _super.call(this, {
                          element,
                          classNames: classNames2
                        }) || this;
                        _this.delimiter = delimiter;
                        return _this;
                      }
                      Object.defineProperty(WrappedInput2.prototype, "value", {
                        get: function() {
                          return this.element.value;
                        },
                        set: function(value2) {
                          this.element.setAttribute("value", value2);
                          this.element.value = value2;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      return WrappedInput2;
                    }(wrapped_element_1.default)
                  );
                  exports2["default"] = WrappedInput;
                }
              ),
              /***/
              982: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __extends2 = this && this.__extends || /* @__PURE__ */ function() {
                    var extendStatics2 = function(d2, b) {
                      extendStatics2 = Object.setPrototypeOf || {
                        __proto__: []
                      } instanceof Array && function(d3, b2) {
                        d3.__proto__ = b2;
                      } || function(d3, b2) {
                        for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
                      };
                      return extendStatics2(d2, b);
                    };
                    return function(d2, b) {
                      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
                      extendStatics2(d2, b);
                      function __() {
                        this.constructor = d2;
                      }
                      d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
                    };
                  }();
                  var __importDefault = this && this.__importDefault || function(mod3) {
                    return mod3 && mod3.__esModule ? mod3 : {
                      "default": mod3
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var wrapped_element_1 = __importDefault(__webpack_require__2(730));
                  var WrappedSelect = (
                    /** @class */
                    function(_super) {
                      __extends2(WrappedSelect2, _super);
                      function WrappedSelect2(_a) {
                        var element = _a.element, classNames2 = _a.classNames, template = _a.template;
                        var _this = _super.call(this, {
                          element,
                          classNames: classNames2
                        }) || this;
                        _this.template = template;
                        return _this;
                      }
                      Object.defineProperty(WrappedSelect2.prototype, "placeholderOption", {
                        get: function() {
                          return this.element.querySelector('option[value=""]') || // Backward compatibility layer for the non-standard placeholder attribute supported in older versions.
                          this.element.querySelector("option[placeholder]");
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(WrappedSelect2.prototype, "optionGroups", {
                        get: function() {
                          return Array.from(this.element.getElementsByTagName("OPTGROUP"));
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(WrappedSelect2.prototype, "options", {
                        get: function() {
                          return Array.from(this.element.options);
                        },
                        set: function(options) {
                          var _this = this;
                          var fragment = document.createDocumentFragment();
                          var addOptionToFragment = function(data2) {
                            var option2 = _this.template(data2);
                            fragment.appendChild(option2);
                          };
                          options.forEach(function(optionData) {
                            return addOptionToFragment(optionData);
                          });
                          this.appendDocFragment(fragment);
                        },
                        enumerable: false,
                        configurable: true
                      });
                      WrappedSelect2.prototype.appendDocFragment = function(fragment) {
                        this.element.innerHTML = "";
                        this.element.appendChild(fragment);
                      };
                      return WrappedSelect2;
                    }(wrapped_element_1.default)
                  );
                  exports2["default"] = WrappedSelect;
                }
              ),
              /***/
              883: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.SCROLLING_SPEED = exports2.SELECT_MULTIPLE_TYPE = exports2.SELECT_ONE_TYPE = exports2.TEXT_TYPE = exports2.KEY_CODES = exports2.ACTION_TYPES = exports2.EVENTS = void 0;
                  exports2.EVENTS = {
                    showDropdown: "showDropdown",
                    hideDropdown: "hideDropdown",
                    change: "change",
                    choice: "choice",
                    search: "search",
                    addItem: "addItem",
                    removeItem: "removeItem",
                    highlightItem: "highlightItem",
                    highlightChoice: "highlightChoice",
                    unhighlightItem: "unhighlightItem"
                  };
                  exports2.ACTION_TYPES = {
                    ADD_CHOICE: "ADD_CHOICE",
                    FILTER_CHOICES: "FILTER_CHOICES",
                    ACTIVATE_CHOICES: "ACTIVATE_CHOICES",
                    CLEAR_CHOICES: "CLEAR_CHOICES",
                    ADD_GROUP: "ADD_GROUP",
                    ADD_ITEM: "ADD_ITEM",
                    REMOVE_ITEM: "REMOVE_ITEM",
                    HIGHLIGHT_ITEM: "HIGHLIGHT_ITEM",
                    CLEAR_ALL: "CLEAR_ALL",
                    RESET_TO: "RESET_TO",
                    SET_IS_LOADING: "SET_IS_LOADING"
                  };
                  exports2.KEY_CODES = {
                    BACK_KEY: 46,
                    DELETE_KEY: 8,
                    ENTER_KEY: 13,
                    A_KEY: 65,
                    ESC_KEY: 27,
                    UP_KEY: 38,
                    DOWN_KEY: 40,
                    PAGE_UP_KEY: 33,
                    PAGE_DOWN_KEY: 34
                  };
                  exports2.TEXT_TYPE = "text";
                  exports2.SELECT_ONE_TYPE = "select-one";
                  exports2.SELECT_MULTIPLE_TYPE = "select-multiple";
                  exports2.SCROLLING_SPEED = 4;
                }
              ),
              /***/
              789: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.DEFAULT_CONFIG = exports2.DEFAULT_CLASSNAMES = void 0;
                  var utils_1 = __webpack_require__2(799);
                  exports2.DEFAULT_CLASSNAMES = {
                    containerOuter: "choices",
                    containerInner: "choices__inner",
                    input: "choices__input",
                    inputCloned: "choices__input--cloned",
                    list: "choices__list",
                    listItems: "choices__list--multiple",
                    listSingle: "choices__list--single",
                    listDropdown: "choices__list--dropdown",
                    item: "choices__item",
                    itemSelectable: "choices__item--selectable",
                    itemDisabled: "choices__item--disabled",
                    itemChoice: "choices__item--choice",
                    placeholder: "choices__placeholder",
                    group: "choices__group",
                    groupHeading: "choices__heading",
                    button: "choices__button",
                    activeState: "is-active",
                    focusState: "is-focused",
                    openState: "is-open",
                    disabledState: "is-disabled",
                    highlightedState: "is-highlighted",
                    selectedState: "is-selected",
                    flippedState: "is-flipped",
                    loadingState: "is-loading",
                    noResults: "has-no-results",
                    noChoices: "has-no-choices"
                  };
                  exports2.DEFAULT_CONFIG = {
                    items: [],
                    choices: [],
                    silent: false,
                    renderChoiceLimit: -1,
                    maxItemCount: -1,
                    addItems: true,
                    addItemFilter: null,
                    removeItems: true,
                    removeItemButton: false,
                    editItems: false,
                    allowHTML: true,
                    duplicateItemsAllowed: true,
                    delimiter: ",",
                    paste: true,
                    searchEnabled: true,
                    searchChoices: true,
                    searchFloor: 1,
                    searchResultLimit: 4,
                    searchFields: ["label", "value"],
                    position: "auto",
                    resetScrollPosition: true,
                    shouldSort: true,
                    shouldSortItems: false,
                    sorter: utils_1.sortByAlpha,
                    placeholder: true,
                    placeholderValue: null,
                    searchPlaceholderValue: null,
                    prependValue: null,
                    appendValue: null,
                    renderSelectedChoices: "auto",
                    loadingText: "Loading...",
                    noResultsText: "No results found",
                    noChoicesText: "No choices to choose from",
                    itemSelectText: "Press to select",
                    uniqueItemText: "Only unique values can be added",
                    customAddItemText: "Only values matching specific conditions can be added",
                    addItemText: function(value2) {
                      return 'Press Enter to add <b>"'.concat((0, utils_1.sanitise)(value2), '"</b>');
                    },
                    maxItemText: function(maxItemCount) {
                      return "Only ".concat(maxItemCount, " values can be added");
                    },
                    valueComparer: function(value1, value2) {
                      return value1 === value2;
                    },
                    fuseOptions: {
                      includeScore: true
                    },
                    labelId: "",
                    callbackOnInit: null,
                    callbackOnCreateTemplates: null,
                    classNames: exports2.DEFAULT_CLASSNAMES
                  };
                }
              ),
              /***/
              18: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              978: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              948: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              359: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              285: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              533: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              187: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __createBinding = this && this.__createBinding || (Object.create ? function(o, m3, k, k2) {
                    if (k2 === void 0) k2 = k;
                    var desc = Object.getOwnPropertyDescriptor(m3, k);
                    if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
                      desc = {
                        enumerable: true,
                        get: function() {
                          return m3[k];
                        }
                      };
                    }
                    Object.defineProperty(o, k2, desc);
                  } : function(o, m3, k, k2) {
                    if (k2 === void 0) k2 = k;
                    o[k2] = m3[k];
                  });
                  var __exportStar = this && this.__exportStar || function(m3, exports3) {
                    for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p2)) __createBinding(exports3, m3, p2);
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  __exportStar(__webpack_require__2(18), exports2);
                  __exportStar(__webpack_require__2(978), exports2);
                  __exportStar(__webpack_require__2(948), exports2);
                  __exportStar(__webpack_require__2(359), exports2);
                  __exportStar(__webpack_require__2(285), exports2);
                  __exportStar(__webpack_require__2(533), exports2);
                  __exportStar(__webpack_require__2(287), exports2);
                  __exportStar(__webpack_require__2(132), exports2);
                  __exportStar(__webpack_require__2(837), exports2);
                  __exportStar(__webpack_require__2(598), exports2);
                  __exportStar(__webpack_require__2(369), exports2);
                  __exportStar(__webpack_require__2(37), exports2);
                  __exportStar(__webpack_require__2(47), exports2);
                  __exportStar(__webpack_require__2(923), exports2);
                  __exportStar(__webpack_require__2(876), exports2);
                }
              ),
              /***/
              287: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              132: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              837: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              598: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              37: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              369: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              47: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              923: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              876: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                }
              ),
              /***/
              799: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.parseCustomProperties = exports2.diff = exports2.cloneObject = exports2.existsInArray = exports2.dispatchEvent = exports2.sortByScore = exports2.sortByAlpha = exports2.strToEl = exports2.sanitise = exports2.isScrolledIntoView = exports2.getAdjacentEl = exports2.wrap = exports2.isType = exports2.getType = exports2.generateId = exports2.generateChars = exports2.getRandomNumber = void 0;
                  var getRandomNumber = function(min10, max10) {
                    return Math.floor(Math.random() * (max10 - min10) + min10);
                  };
                  exports2.getRandomNumber = getRandomNumber;
                  var generateChars = function(length5) {
                    return Array.from({
                      length: length5
                    }, function() {
                      return (0, exports2.getRandomNumber)(0, 36).toString(36);
                    }).join("");
                  };
                  exports2.generateChars = generateChars;
                  var generateId = function(element, prefix) {
                    var id4 = element.id || element.name && "".concat(element.name, "-").concat((0, exports2.generateChars)(2)) || (0, exports2.generateChars)(4);
                    id4 = id4.replace(/(:|\.|\[|\]|,)/g, "");
                    id4 = "".concat(prefix, "-").concat(id4);
                    return id4;
                  };
                  exports2.generateId = generateId;
                  var getType2 = function(obj) {
                    return Object.prototype.toString.call(obj).slice(8, -1);
                  };
                  exports2.getType = getType2;
                  var isType10 = function(type, obj) {
                    return obj !== void 0 && obj !== null && (0, exports2.getType)(obj) === type;
                  };
                  exports2.isType = isType10;
                  var wrap = function(element, wrapper) {
                    if (wrapper === void 0) {
                      wrapper = document.createElement("div");
                    }
                    if (element.parentNode) {
                      if (element.nextSibling) {
                        element.parentNode.insertBefore(wrapper, element.nextSibling);
                      } else {
                        element.parentNode.appendChild(wrapper);
                      }
                    }
                    return wrapper.appendChild(element);
                  };
                  exports2.wrap = wrap;
                  var getAdjacentEl = function(startEl, selector, direction2) {
                    if (direction2 === void 0) {
                      direction2 = 1;
                    }
                    var prop = "".concat(direction2 > 0 ? "next" : "previous", "ElementSibling");
                    var sibling = startEl[prop];
                    while (sibling) {
                      if (sibling.matches(selector)) {
                        return sibling;
                      }
                      sibling = sibling[prop];
                    }
                    return sibling;
                  };
                  exports2.getAdjacentEl = getAdjacentEl;
                  var isScrolledIntoView = function(element, parent, direction2) {
                    if (direction2 === void 0) {
                      direction2 = 1;
                    }
                    if (!element) {
                      return false;
                    }
                    var isVisible;
                    if (direction2 > 0) {
                      isVisible = parent.scrollTop + parent.offsetHeight >= element.offsetTop + element.offsetHeight;
                    } else {
                      isVisible = element.offsetTop >= parent.scrollTop;
                    }
                    return isVisible;
                  };
                  exports2.isScrolledIntoView = isScrolledIntoView;
                  var sanitise = function(value2) {
                    if (typeof value2 !== "string") {
                      return value2;
                    }
                    return value2.replace(/&/g, "&amp;").replace(/>/g, "&gt;").replace(/</g, "&lt;").replace(/"/g, "&quot;");
                  };
                  exports2.sanitise = sanitise;
                  exports2.strToEl = function() {
                    var tmpEl = document.createElement("div");
                    return function(str7) {
                      var cleanedInput = str7.trim();
                      tmpEl.innerHTML = cleanedInput;
                      var firldChild = tmpEl.children[0];
                      while (tmpEl.firstChild) {
                        tmpEl.removeChild(tmpEl.firstChild);
                      }
                      return firldChild;
                    };
                  }();
                  var sortByAlpha = function(_a, _b) {
                    var value2 = _a.value, _c = _a.label, label = _c === void 0 ? value2 : _c;
                    var value22 = _b.value, _d = _b.label, label2 = _d === void 0 ? value22 : _d;
                    return label.localeCompare(label2, [], {
                      sensitivity: "base",
                      ignorePunctuation: true,
                      numeric: true
                    });
                  };
                  exports2.sortByAlpha = sortByAlpha;
                  var sortByScore = function(a3, b) {
                    var _a = a3.score, scoreA = _a === void 0 ? 0 : _a;
                    var _b = b.score, scoreB = _b === void 0 ? 0 : _b;
                    return scoreA - scoreB;
                  };
                  exports2.sortByScore = sortByScore;
                  var dispatchEvent4 = function(element, type, customArgs) {
                    if (customArgs === void 0) {
                      customArgs = null;
                    }
                    var event = new CustomEvent(type, {
                      detail: customArgs,
                      bubbles: true,
                      cancelable: true
                    });
                    return element.dispatchEvent(event);
                  };
                  exports2.dispatchEvent = dispatchEvent4;
                  var existsInArray = function(array2, value2, key) {
                    if (key === void 0) {
                      key = "value";
                    }
                    return array2.some(function(item) {
                      if (typeof value2 === "string") {
                        return item[key] === value2.trim();
                      }
                      return item[key] === value2;
                    });
                  };
                  exports2.existsInArray = existsInArray;
                  var cloneObject = function(obj) {
                    return JSON.parse(JSON.stringify(obj));
                  };
                  exports2.cloneObject = cloneObject;
                  var diff = function(a3, b) {
                    var aKeys = Object.keys(a3).sort();
                    var bKeys = Object.keys(b).sort();
                    return aKeys.filter(function(i) {
                      return bKeys.indexOf(i) < 0;
                    });
                  };
                  exports2.diff = diff;
                  var parseCustomProperties = function(customProperties) {
                    if (typeof customProperties !== "undefined") {
                      try {
                        return JSON.parse(customProperties);
                      } catch (e3) {
                        return customProperties;
                      }
                    }
                    return {};
                  };
                  exports2.parseCustomProperties = parseCustomProperties;
                }
              ),
              /***/
              273: (
                /***/
                function(__unused_webpack_module, exports2) {
                  var __spreadArray2 = this && this.__spreadArray || function(to, from, pack3) {
                    if (pack3 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.defaultState = void 0;
                  exports2.defaultState = [];
                  function choices(state, action) {
                    if (state === void 0) {
                      state = exports2.defaultState;
                    }
                    if (action === void 0) {
                      action = {};
                    }
                    switch (action.type) {
                      case "ADD_CHOICE": {
                        var addChoiceAction = action;
                        var choice = {
                          id: addChoiceAction.id,
                          elementId: addChoiceAction.elementId,
                          groupId: addChoiceAction.groupId,
                          value: addChoiceAction.value,
                          label: addChoiceAction.label || addChoiceAction.value,
                          disabled: addChoiceAction.disabled || false,
                          selected: false,
                          active: true,
                          score: 9999,
                          customProperties: addChoiceAction.customProperties,
                          placeholder: addChoiceAction.placeholder || false
                        };
                        return __spreadArray2(__spreadArray2([], state, true), [choice], false);
                      }
                      case "ADD_ITEM": {
                        var addItemAction_1 = action;
                        if (addItemAction_1.choiceId > -1) {
                          return state.map(function(obj) {
                            var choice2 = obj;
                            if (choice2.id === parseInt("".concat(addItemAction_1.choiceId), 10)) {
                              choice2.selected = true;
                            }
                            return choice2;
                          });
                        }
                        return state;
                      }
                      case "REMOVE_ITEM": {
                        var removeItemAction_1 = action;
                        if (removeItemAction_1.choiceId && removeItemAction_1.choiceId > -1) {
                          return state.map(function(obj) {
                            var choice2 = obj;
                            if (choice2.id === parseInt("".concat(removeItemAction_1.choiceId), 10)) {
                              choice2.selected = false;
                            }
                            return choice2;
                          });
                        }
                        return state;
                      }
                      case "FILTER_CHOICES": {
                        var filterChoicesAction_1 = action;
                        return state.map(function(obj) {
                          var choice2 = obj;
                          choice2.active = filterChoicesAction_1.results.some(function(_a) {
                            var item = _a.item, score2 = _a.score;
                            if (item.id === choice2.id) {
                              choice2.score = score2;
                              return true;
                            }
                            return false;
                          });
                          return choice2;
                        });
                      }
                      case "ACTIVATE_CHOICES": {
                        var activateChoicesAction_1 = action;
                        return state.map(function(obj) {
                          var choice2 = obj;
                          choice2.active = activateChoicesAction_1.active;
                          return choice2;
                        });
                      }
                      case "CLEAR_CHOICES": {
                        return exports2.defaultState;
                      }
                      default: {
                        return state;
                      }
                    }
                  }
                  exports2["default"] = choices;
                }
              ),
              /***/
              871: (
                /***/
                function(__unused_webpack_module, exports2) {
                  var __spreadArray2 = this && this.__spreadArray || function(to, from, pack3) {
                    if (pack3 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.defaultState = void 0;
                  exports2.defaultState = [];
                  function groups2(state, action) {
                    if (state === void 0) {
                      state = exports2.defaultState;
                    }
                    if (action === void 0) {
                      action = {};
                    }
                    switch (action.type) {
                      case "ADD_GROUP": {
                        var addGroupAction = action;
                        return __spreadArray2(__spreadArray2([], state, true), [{
                          id: addGroupAction.id,
                          value: addGroupAction.value,
                          active: addGroupAction.active,
                          disabled: addGroupAction.disabled
                        }], false);
                      }
                      case "CLEAR_CHOICES": {
                        return [];
                      }
                      default: {
                        return state;
                      }
                    }
                  }
                  exports2["default"] = groups2;
                }
              ),
              /***/
              655: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __importDefault = this && this.__importDefault || function(mod3) {
                    return mod3 && mod3.__esModule ? mod3 : {
                      "default": mod3
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.defaultState = void 0;
                  var redux_1 = __webpack_require__2(791);
                  var items_1 = __importDefault(__webpack_require__2(52));
                  var groups_1 = __importDefault(__webpack_require__2(871));
                  var choices_1 = __importDefault(__webpack_require__2(273));
                  var loading_1 = __importDefault(__webpack_require__2(502));
                  var utils_1 = __webpack_require__2(799);
                  exports2.defaultState = {
                    groups: [],
                    items: [],
                    choices: [],
                    loading: false
                  };
                  var appReducer = (0, redux_1.combineReducers)({
                    items: items_1.default,
                    groups: groups_1.default,
                    choices: choices_1.default,
                    loading: loading_1.default
                  });
                  var rootReducer = function(passedState, action) {
                    var state = passedState;
                    if (action.type === "CLEAR_ALL") {
                      state = exports2.defaultState;
                    } else if (action.type === "RESET_TO") {
                      return (0, utils_1.cloneObject)(action.state);
                    }
                    return appReducer(state, action);
                  };
                  exports2["default"] = rootReducer;
                }
              ),
              /***/
              52: (
                /***/
                function(__unused_webpack_module, exports2) {
                  var __spreadArray2 = this && this.__spreadArray || function(to, from, pack3) {
                    if (pack3 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.defaultState = void 0;
                  exports2.defaultState = [];
                  function items(state, action) {
                    if (state === void 0) {
                      state = exports2.defaultState;
                    }
                    if (action === void 0) {
                      action = {};
                    }
                    switch (action.type) {
                      case "ADD_ITEM": {
                        var addItemAction = action;
                        var newState = __spreadArray2(__spreadArray2([], state, true), [{
                          id: addItemAction.id,
                          choiceId: addItemAction.choiceId,
                          groupId: addItemAction.groupId,
                          value: addItemAction.value,
                          label: addItemAction.label,
                          active: true,
                          highlighted: false,
                          customProperties: addItemAction.customProperties,
                          placeholder: addItemAction.placeholder || false,
                          keyCode: null
                        }], false);
                        return newState.map(function(obj) {
                          var item = obj;
                          item.highlighted = false;
                          return item;
                        });
                      }
                      case "REMOVE_ITEM": {
                        return state.map(function(obj) {
                          var item = obj;
                          if (item.id === action.id) {
                            item.active = false;
                          }
                          return item;
                        });
                      }
                      case "HIGHLIGHT_ITEM": {
                        var highlightItemAction_1 = action;
                        return state.map(function(obj) {
                          var item = obj;
                          if (item.id === highlightItemAction_1.id) {
                            item.highlighted = highlightItemAction_1.highlighted;
                          }
                          return item;
                        });
                      }
                      default: {
                        return state;
                      }
                    }
                  }
                  exports2["default"] = items;
                }
              ),
              /***/
              502: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  exports2.defaultState = void 0;
                  exports2.defaultState = false;
                  var general = function(state, action) {
                    if (state === void 0) {
                      state = exports2.defaultState;
                    }
                    if (action === void 0) {
                      action = {};
                    }
                    switch (action.type) {
                      case "SET_IS_LOADING": {
                        return action.isLoading;
                      }
                      default: {
                        return state;
                      }
                    }
                  };
                  exports2["default"] = general;
                }
              ),
              /***/
              744: (
                /***/
                function(__unused_webpack_module, exports2, __webpack_require__2) {
                  var __spreadArray2 = this && this.__spreadArray || function(to, from, pack3) {
                    if (pack3 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
                      if (ar || !(i in from)) {
                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                        ar[i] = from[i];
                      }
                    }
                    return to.concat(ar || Array.prototype.slice.call(from));
                  };
                  var __importDefault = this && this.__importDefault || function(mod3) {
                    return mod3 && mod3.__esModule ? mod3 : {
                      "default": mod3
                    };
                  };
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var redux_1 = __webpack_require__2(791);
                  var index_1 = __importDefault(__webpack_require__2(655));
                  var Store = (
                    /** @class */
                    function() {
                      function Store2() {
                        this._store = (0, redux_1.createStore)(index_1.default, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
                      }
                      Store2.prototype.subscribe = function(onChange) {
                        this._store.subscribe(onChange);
                      };
                      Store2.prototype.dispatch = function(action) {
                        this._store.dispatch(action);
                      };
                      Object.defineProperty(Store2.prototype, "state", {
                        /**
                         * Get store object (wrapping Redux method)
                         */
                        get: function() {
                          return this._store.getState();
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "items", {
                        /**
                         * Get items from store
                         */
                        get: function() {
                          return this.state.items;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "activeItems", {
                        /**
                         * Get active items from store
                         */
                        get: function() {
                          return this.items.filter(function(item) {
                            return item.active === true;
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "highlightedActiveItems", {
                        /**
                         * Get highlighted items from store
                         */
                        get: function() {
                          return this.items.filter(function(item) {
                            return item.active && item.highlighted;
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "choices", {
                        /**
                         * Get choices from store
                         */
                        get: function() {
                          return this.state.choices;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "activeChoices", {
                        /**
                         * Get active choices from store
                         */
                        get: function() {
                          return this.choices.filter(function(choice) {
                            return choice.active === true;
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "selectableChoices", {
                        /**
                         * Get selectable choices from store
                         */
                        get: function() {
                          return this.choices.filter(function(choice) {
                            return choice.disabled !== true;
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "searchableChoices", {
                        /**
                         * Get choices that can be searched (excluding placeholders)
                         */
                        get: function() {
                          return this.selectableChoices.filter(function(choice) {
                            return choice.placeholder !== true;
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "placeholderChoice", {
                        /**
                         * Get placeholder choice from store
                         */
                        get: function() {
                          return __spreadArray2([], this.choices, true).reverse().find(function(choice) {
                            return choice.placeholder === true;
                          });
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "groups", {
                        /**
                         * Get groups from store
                         */
                        get: function() {
                          return this.state.groups;
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Object.defineProperty(Store2.prototype, "activeGroups", {
                        /**
                         * Get active groups from store
                         */
                        get: function() {
                          var _a = this, groups2 = _a.groups, choices = _a.choices;
                          return groups2.filter(function(group3) {
                            var isActive = group3.active === true && group3.disabled === false;
                            var hasActiveOptions = choices.some(function(choice) {
                              return choice.active === true && choice.disabled === false;
                            });
                            return isActive && hasActiveOptions;
                          }, []);
                        },
                        enumerable: false,
                        configurable: true
                      });
                      Store2.prototype.isLoading = function() {
                        return this.state.loading;
                      };
                      Store2.prototype.getChoiceById = function(id4) {
                        return this.activeChoices.find(function(choice) {
                          return choice.id === parseInt(id4, 10);
                        });
                      };
                      Store2.prototype.getGroupById = function(id4) {
                        return this.groups.find(function(group3) {
                          return group3.id === id4;
                        });
                      };
                      return Store2;
                    }()
                  );
                  exports2["default"] = Store;
                }
              ),
              /***/
              686: (
                /***/
                function(__unused_webpack_module, exports2) {
                  Object.defineProperty(exports2, "__esModule", {
                    value: true
                  });
                  var templates = {
                    containerOuter: function(_a, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType, labelId) {
                      var containerOuter = _a.classNames.containerOuter;
                      var div4 = Object.assign(document.createElement("div"), {
                        className: containerOuter
                      });
                      div4.dataset.type = passedElementType;
                      if (dir) {
                        div4.dir = dir;
                      }
                      if (isSelectOneElement) {
                        div4.tabIndex = 0;
                      }
                      if (isSelectElement) {
                        div4.setAttribute("role", searchEnabled ? "combobox" : "listbox");
                        if (searchEnabled) {
                          div4.setAttribute("aria-autocomplete", "list");
                        }
                      }
                      div4.setAttribute("aria-haspopup", "true");
                      div4.setAttribute("aria-expanded", "false");
                      if (labelId) {
                        div4.setAttribute("aria-labelledby", labelId);
                      }
                      return div4;
                    },
                    containerInner: function(_a) {
                      var containerInner = _a.classNames.containerInner;
                      return Object.assign(document.createElement("div"), {
                        className: containerInner
                      });
                    },
                    itemList: function(_a, isSelectOneElement) {
                      var _b = _a.classNames, list = _b.list, listSingle = _b.listSingle, listItems = _b.listItems;
                      return Object.assign(document.createElement("div"), {
                        className: "".concat(list, " ").concat(isSelectOneElement ? listSingle : listItems)
                      });
                    },
                    placeholder: function(_a, value2) {
                      var _b;
                      var allowHTML = _a.allowHTML, placeholder = _a.classNames.placeholder;
                      return Object.assign(document.createElement("div"), (_b = {
                        className: placeholder
                      }, _b[allowHTML ? "innerHTML" : "innerText"] = value2, _b));
                    },
                    item: function(_a, _b, removeItemButton) {
                      var _c, _d;
                      var allowHTML = _a.allowHTML, _e = _a.classNames, item = _e.item, button2 = _e.button, highlightedState = _e.highlightedState, itemSelectable = _e.itemSelectable, placeholder = _e.placeholder;
                      var id4 = _b.id, value2 = _b.value, label = _b.label, customProperties = _b.customProperties, active = _b.active, disabled = _b.disabled, highlighted = _b.highlighted, isPlaceholder = _b.placeholder;
                      var div4 = Object.assign(document.createElement("div"), (_c = {
                        className: item
                      }, _c[allowHTML ? "innerHTML" : "innerText"] = label, _c));
                      Object.assign(div4.dataset, {
                        item: "",
                        id: id4,
                        value: value2,
                        customProperties
                      });
                      if (active) {
                        div4.setAttribute("aria-selected", "true");
                      }
                      if (disabled) {
                        div4.setAttribute("aria-disabled", "true");
                      }
                      if (isPlaceholder) {
                        div4.classList.add(placeholder);
                      }
                      div4.classList.add(highlighted ? highlightedState : itemSelectable);
                      if (removeItemButton) {
                        if (disabled) {
                          div4.classList.remove(itemSelectable);
                        }
                        div4.dataset.deletable = "";
                        var REMOVE_ITEM_TEXT = "Remove item";
                        var removeButton = Object.assign(document.createElement("button"), (_d = {
                          type: "button",
                          className: button2
                        }, _d[allowHTML ? "innerHTML" : "innerText"] = REMOVE_ITEM_TEXT, _d));
                        removeButton.setAttribute("aria-label", "".concat(REMOVE_ITEM_TEXT, ": '").concat(value2, "'"));
                        removeButton.dataset.button = "";
                        div4.appendChild(removeButton);
                      }
                      return div4;
                    },
                    choiceList: function(_a, isSelectOneElement) {
                      var list = _a.classNames.list;
                      var div4 = Object.assign(document.createElement("div"), {
                        className: list
                      });
                      if (!isSelectOneElement) {
                        div4.setAttribute("aria-multiselectable", "true");
                      }
                      div4.setAttribute("role", "listbox");
                      return div4;
                    },
                    choiceGroup: function(_a, _b) {
                      var _c;
                      var allowHTML = _a.allowHTML, _d = _a.classNames, group3 = _d.group, groupHeading = _d.groupHeading, itemDisabled = _d.itemDisabled;
                      var id4 = _b.id, value2 = _b.value, disabled = _b.disabled;
                      var div4 = Object.assign(document.createElement("div"), {
                        className: "".concat(group3, " ").concat(disabled ? itemDisabled : "")
                      });
                      div4.setAttribute("role", "group");
                      Object.assign(div4.dataset, {
                        group: "",
                        id: id4,
                        value: value2
                      });
                      if (disabled) {
                        div4.setAttribute("aria-disabled", "true");
                      }
                      div4.appendChild(Object.assign(document.createElement("div"), (_c = {
                        className: groupHeading
                      }, _c[allowHTML ? "innerHTML" : "innerText"] = value2, _c)));
                      return div4;
                    },
                    choice: function(_a, _b, selectText) {
                      var _c;
                      var allowHTML = _a.allowHTML, _d = _a.classNames, item = _d.item, itemChoice = _d.itemChoice, itemSelectable = _d.itemSelectable, selectedState = _d.selectedState, itemDisabled = _d.itemDisabled, placeholder = _d.placeholder;
                      var id4 = _b.id, value2 = _b.value, label = _b.label, groupId = _b.groupId, elementId = _b.elementId, isDisabled = _b.disabled, isSelected = _b.selected, isPlaceholder = _b.placeholder;
                      var div4 = Object.assign(document.createElement("div"), (_c = {
                        id: elementId
                      }, _c[allowHTML ? "innerHTML" : "innerText"] = label, _c.className = "".concat(item, " ").concat(itemChoice), _c));
                      if (isSelected) {
                        div4.classList.add(selectedState);
                      }
                      if (isPlaceholder) {
                        div4.classList.add(placeholder);
                      }
                      div4.setAttribute("role", groupId && groupId > 0 ? "treeitem" : "option");
                      Object.assign(div4.dataset, {
                        choice: "",
                        id: id4,
                        value: value2,
                        selectText
                      });
                      if (isDisabled) {
                        div4.classList.add(itemDisabled);
                        div4.dataset.choiceDisabled = "";
                        div4.setAttribute("aria-disabled", "true");
                      } else {
                        div4.classList.add(itemSelectable);
                        div4.dataset.choiceSelectable = "";
                      }
                      return div4;
                    },
                    input: function(_a, placeholderValue) {
                      var _b = _a.classNames, input = _b.input, inputCloned = _b.inputCloned;
                      var inp = Object.assign(document.createElement("input"), {
                        type: "search",
                        name: "search_terms",
                        className: "".concat(input, " ").concat(inputCloned),
                        autocomplete: "off",
                        autocapitalize: "off",
                        spellcheck: false
                      });
                      inp.setAttribute("role", "textbox");
                      inp.setAttribute("aria-autocomplete", "list");
                      inp.setAttribute("aria-label", placeholderValue);
                      return inp;
                    },
                    dropdown: function(_a) {
                      var _b = _a.classNames, list = _b.list, listDropdown = _b.listDropdown;
                      var div4 = document.createElement("div");
                      div4.classList.add(list, listDropdown);
                      div4.setAttribute("aria-expanded", "false");
                      return div4;
                    },
                    notice: function(_a, innerText, type) {
                      var _b;
                      var allowHTML = _a.allowHTML, _c = _a.classNames, item = _c.item, itemChoice = _c.itemChoice, noResults = _c.noResults, noChoices = _c.noChoices;
                      if (type === void 0) {
                        type = "";
                      }
                      var classes = [item, itemChoice];
                      if (type === "no-choices") {
                        classes.push(noChoices);
                      } else if (type === "no-results") {
                        classes.push(noResults);
                      }
                      return Object.assign(document.createElement("div"), (_b = {}, _b[allowHTML ? "innerHTML" : "innerText"] = innerText, _b.className = classes.join(" "), _b));
                    },
                    option: function(_a) {
                      var label = _a.label, value2 = _a.value, customProperties = _a.customProperties, active = _a.active, disabled = _a.disabled;
                      var opt = new Option(label, value2, false, active);
                      if (customProperties) {
                        opt.dataset.customProperties = "".concat(customProperties);
                      }
                      opt.disabled = !!disabled;
                      return opt;
                    }
                  };
                  exports2["default"] = templates;
                }
              ),
              /***/
              996: (
                /***/
                function(module2) {
                  var isMergeableObject = function isMergeableObject2(value2) {
                    return isNonNullObject(value2) && !isSpecial(value2);
                  };
                  function isNonNullObject(value2) {
                    return !!value2 && typeof value2 === "object";
                  }
                  function isSpecial(value2) {
                    var stringValue = Object.prototype.toString.call(value2);
                    return stringValue === "[object RegExp]" || stringValue === "[object Date]" || isReactElement(value2);
                  }
                  var canUseSymbol = typeof Symbol === "function" && Symbol.for;
                  var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
                  function isReactElement(value2) {
                    return value2.$$typeof === REACT_ELEMENT_TYPE;
                  }
                  function emptyTarget(val) {
                    return Array.isArray(val) ? [] : {};
                  }
                  function cloneUnlessOtherwiseSpecified(value2, options) {
                    return options.clone !== false && options.isMergeableObject(value2) ? deepmerge(emptyTarget(value2), value2, options) : value2;
                  }
                  function defaultArrayMerge(target, source, options) {
                    return target.concat(source).map(function(element) {
                      return cloneUnlessOtherwiseSpecified(element, options);
                    });
                  }
                  function getMergeFunction(key, options) {
                    if (!options.customMerge) {
                      return deepmerge;
                    }
                    var customMerge = options.customMerge(key);
                    return typeof customMerge === "function" ? customMerge : deepmerge;
                  }
                  function getEnumerableOwnPropertySymbols(target) {
                    return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
                      return target.propertyIsEnumerable(symbol);
                    }) : [];
                  }
                  function getKeys(target) {
                    return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
                  }
                  function propertyIsOnObject(object, property) {
                    try {
                      return property in object;
                    } catch (_2) {
                      return false;
                    }
                  }
                  function propertyIsUnsafe(target, key) {
                    return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
                  }
                  function mergeObject(target, source, options) {
                    var destination = {};
                    if (options.isMergeableObject(target)) {
                      getKeys(target).forEach(function(key) {
                        destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
                      });
                    }
                    getKeys(source).forEach(function(key) {
                      if (propertyIsUnsafe(target, key)) {
                        return;
                      }
                      if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
                        destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
                      } else {
                        destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
                      }
                    });
                    return destination;
                  }
                  function deepmerge(target, source, options) {
                    options = options || {};
                    options.arrayMerge = options.arrayMerge || defaultArrayMerge;
                    options.isMergeableObject = options.isMergeableObject || isMergeableObject;
                    options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
                    var sourceIsArray = Array.isArray(source);
                    var targetIsArray = Array.isArray(target);
                    var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;
                    if (!sourceAndTargetTypesMatch) {
                      return cloneUnlessOtherwiseSpecified(source, options);
                    } else if (sourceIsArray) {
                      return options.arrayMerge(target, source, options);
                    } else {
                      return mergeObject(target, source, options);
                    }
                  }
                  deepmerge.all = function deepmergeAll(array2, options) {
                    if (!Array.isArray(array2)) {
                      throw new Error("first argument should be an array");
                    }
                    return array2.reduce(function(prev, next) {
                      return deepmerge(prev, next, options);
                    }, {});
                  };
                  var deepmerge_1 = deepmerge;
                  module2.exports = deepmerge_1;
                }
              ),
              /***/
              221: (
                /***/
                function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
                  __webpack_require__2.r(__webpack_exports__2);
                  __webpack_require__2.d(__webpack_exports__2, {
                    /* harmony export */
                    "default": function() {
                      return (
                        /* binding */
                        Fuse
                      );
                    }
                    /* harmony export */
                  });
                  function isArray(value2) {
                    return !Array.isArray ? getTag(value2) === "[object Array]" : Array.isArray(value2);
                  }
                  const INFINITY = 1 / 0;
                  function baseToString(value2) {
                    if (typeof value2 == "string") {
                      return value2;
                    }
                    let result = value2 + "";
                    return result == "0" && 1 / value2 == -INFINITY ? "-0" : result;
                  }
                  function toString10(value2) {
                    return value2 == null ? "" : baseToString(value2);
                  }
                  function isString2(value2) {
                    return typeof value2 === "string";
                  }
                  function isNumber8(value2) {
                    return typeof value2 === "number";
                  }
                  function isBoolean2(value2) {
                    return value2 === true || value2 === false || isObjectLike3(value2) && getTag(value2) == "[object Boolean]";
                  }
                  function isObject4(value2) {
                    return typeof value2 === "object";
                  }
                  function isObjectLike3(value2) {
                    return isObject4(value2) && value2 !== null;
                  }
                  function isDefined(value2) {
                    return value2 !== void 0 && value2 !== null;
                  }
                  function isBlank(value2) {
                    return !value2.trim().length;
                  }
                  function getTag(value2) {
                    return value2 == null ? value2 === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value2);
                  }
                  const EXTENDED_SEARCH_UNAVAILABLE = "Extended search is not available";
                  const INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
                  const LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
                  const PATTERN_LENGTH_TOO_LARGE = (max10) => `Pattern length exceeds max of ${max10}.`;
                  const MISSING_KEY_PROPERTY = (name2) => `Missing ${name2} property in key`;
                  const INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
                  const hasOwn3 = Object.prototype.hasOwnProperty;
                  class KeyStore {
                    constructor(keys2) {
                      this._keys = [];
                      this._keyMap = {};
                      let totalWeight = 0;
                      keys2.forEach((key) => {
                        let obj = createKey3(key);
                        totalWeight += obj.weight;
                        this._keys.push(obj);
                        this._keyMap[obj.id] = obj;
                        totalWeight += obj.weight;
                      });
                      this._keys.forEach((key) => {
                        key.weight /= totalWeight;
                      });
                    }
                    get(keyId) {
                      return this._keyMap[keyId];
                    }
                    keys() {
                      return this._keys;
                    }
                    toJSON() {
                      return JSON.stringify(this._keys);
                    }
                  }
                  function createKey3(key) {
                    let path2 = null;
                    let id4 = null;
                    let src = null;
                    let weight2 = 1;
                    let getFn = null;
                    if (isString2(key) || isArray(key)) {
                      src = key;
                      path2 = createKeyPath(key);
                      id4 = createKeyId(key);
                    } else {
                      if (!hasOwn3.call(key, "name")) {
                        throw new Error(MISSING_KEY_PROPERTY("name"));
                      }
                      const name2 = key.name;
                      src = name2;
                      if (hasOwn3.call(key, "weight")) {
                        weight2 = key.weight;
                        if (weight2 <= 0) {
                          throw new Error(INVALID_KEY_WEIGHT_VALUE(name2));
                        }
                      }
                      path2 = createKeyPath(name2);
                      id4 = createKeyId(name2);
                      getFn = key.getFn;
                    }
                    return { path: path2, id: id4, weight: weight2, src, getFn };
                  }
                  function createKeyPath(key) {
                    return isArray(key) ? key : key.split(".");
                  }
                  function createKeyId(key) {
                    return isArray(key) ? key.join(".") : key;
                  }
                  function get2(obj, path2) {
                    let list = [];
                    let arr = false;
                    const deepGet = (obj2, path3, index4) => {
                      if (!isDefined(obj2)) {
                        return;
                      }
                      if (!path3[index4]) {
                        list.push(obj2);
                      } else {
                        let key = path3[index4];
                        const value2 = obj2[key];
                        if (!isDefined(value2)) {
                          return;
                        }
                        if (index4 === path3.length - 1 && (isString2(value2) || isNumber8(value2) || isBoolean2(value2))) {
                          list.push(toString10(value2));
                        } else if (isArray(value2)) {
                          arr = true;
                          for (let i = 0, len5 = value2.length; i < len5; i += 1) {
                            deepGet(value2[i], path3, index4 + 1);
                          }
                        } else if (path3.length) {
                          deepGet(value2, path3, index4 + 1);
                        }
                      }
                    };
                    deepGet(obj, isString2(path2) ? path2.split(".") : path2, 0);
                    return arr ? list : list[0];
                  }
                  const MatchOptions = {
                    // Whether the matches should be included in the result set. When `true`, each record in the result
                    // set will include the indices of the matched characters.
                    // These can consequently be used for highlighting purposes.
                    includeMatches: false,
                    // When `true`, the matching function will continue to the end of a search pattern even if
                    // a perfect match has already been located in the string.
                    findAllMatches: false,
                    // Minimum number of characters that must be matched before a result is considered a match
                    minMatchCharLength: 1
                  };
                  const BasicOptions = {
                    // When `true`, the algorithm continues searching to the end of the input even if a perfect
                    // match is found before the end of the same input.
                    isCaseSensitive: false,
                    // When true, the matching function will continue to the end of a search pattern even if
                    includeScore: false,
                    // List of properties that will be searched. This also supports nested properties.
                    keys: [],
                    // Whether to sort the result list, by score
                    shouldSort: true,
                    // Default sort function: sort by ascending score, ascending index
                    sortFn: (a3, b) => a3.score === b.score ? a3.idx < b.idx ? -1 : 1 : a3.score < b.score ? -1 : 1
                  };
                  const FuzzyOptions = {
                    // Approximately where in the text is the pattern expected to be found?
                    location: 0,
                    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
                    // (of both letters and location), a threshold of '1.0' would match anything.
                    threshold: 0.6,
                    // Determines how close the match must be to the fuzzy location (specified above).
                    // An exact letter match which is 'distance' characters away from the fuzzy location
                    // would score as a complete mismatch. A distance of '0' requires the match be at
                    // the exact location specified, a threshold of '1000' would require a perfect match
                    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
                    distance: 100
                  };
                  const AdvancedOptions = {
                    // When `true`, it enables the use of unix-like search commands
                    useExtendedSearch: false,
                    // The get function to use when fetching an object's properties.
                    // The default will search nested paths *ie foo.bar.baz*
                    getFn: get2,
                    // When `true`, search will ignore `location` and `distance`, so it won't matter
                    // where in the string the pattern appears.
                    // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
                    ignoreLocation: false,
                    // When `true`, the calculation for the relevance score (used for sorting) will
                    // ignore the field-length norm.
                    // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
                    ignoreFieldNorm: false,
                    // The weight to determine how much field length norm effects scoring.
                    fieldNormWeight: 1
                  };
                  var Config2 = {
                    ...BasicOptions,
                    ...MatchOptions,
                    ...FuzzyOptions,
                    ...AdvancedOptions
                  };
                  const SPACE = /[^ ]+/g;
                  function norm(weight2 = 1, mantissa = 3) {
                    const cache3 = /* @__PURE__ */ new Map();
                    const m3 = Math.pow(10, mantissa);
                    return {
                      get(value2) {
                        const numTokens = value2.match(SPACE).length;
                        if (cache3.has(numTokens)) {
                          return cache3.get(numTokens);
                        }
                        const norm3 = 1 / Math.pow(numTokens, 0.5 * weight2);
                        const n2 = parseFloat(Math.round(norm3 * m3) / m3);
                        cache3.set(numTokens, n2);
                        return n2;
                      },
                      clear() {
                        cache3.clear();
                      }
                    };
                  }
                  class FuseIndex {
                    constructor({
                      getFn = Config2.getFn,
                      fieldNormWeight = Config2.fieldNormWeight
                    } = {}) {
                      this.norm = norm(fieldNormWeight, 3);
                      this.getFn = getFn;
                      this.isCreated = false;
                      this.setIndexRecords();
                    }
                    setSources(docs = []) {
                      this.docs = docs;
                    }
                    setIndexRecords(records = []) {
                      this.records = records;
                    }
                    setKeys(keys2 = []) {
                      this.keys = keys2;
                      this._keysMap = {};
                      keys2.forEach((key, idx) => {
                        this._keysMap[key.id] = idx;
                      });
                    }
                    create() {
                      if (this.isCreated || !this.docs.length) {
                        return;
                      }
                      this.isCreated = true;
                      if (isString2(this.docs[0])) {
                        this.docs.forEach((doc, docIndex) => {
                          this._addString(doc, docIndex);
                        });
                      } else {
                        this.docs.forEach((doc, docIndex) => {
                          this._addObject(doc, docIndex);
                        });
                      }
                      this.norm.clear();
                    }
                    // Adds a doc to the end of the index
                    add(doc) {
                      const idx = this.size();
                      if (isString2(doc)) {
                        this._addString(doc, idx);
                      } else {
                        this._addObject(doc, idx);
                      }
                    }
                    // Removes the doc at the specified index of the index
                    removeAt(idx) {
                      this.records.splice(idx, 1);
                      for (let i = idx, len5 = this.size(); i < len5; i += 1) {
                        this.records[i].i -= 1;
                      }
                    }
                    getValueForItemAtKeyId(item, keyId) {
                      return item[this._keysMap[keyId]];
                    }
                    size() {
                      return this.records.length;
                    }
                    _addString(doc, docIndex) {
                      if (!isDefined(doc) || isBlank(doc)) {
                        return;
                      }
                      let record = {
                        v: doc,
                        i: docIndex,
                        n: this.norm.get(doc)
                      };
                      this.records.push(record);
                    }
                    _addObject(doc, docIndex) {
                      let record = { i: docIndex, $: {} };
                      this.keys.forEach((key, keyIndex) => {
                        let value2 = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
                        if (!isDefined(value2)) {
                          return;
                        }
                        if (isArray(value2)) {
                          let subRecords = [];
                          const stack = [{ nestedArrIndex: -1, value: value2 }];
                          while (stack.length) {
                            const { nestedArrIndex, value: value3 } = stack.pop();
                            if (!isDefined(value3)) {
                              continue;
                            }
                            if (isString2(value3) && !isBlank(value3)) {
                              let subRecord = {
                                v: value3,
                                i: nestedArrIndex,
                                n: this.norm.get(value3)
                              };
                              subRecords.push(subRecord);
                            } else if (isArray(value3)) {
                              value3.forEach((item, k) => {
                                stack.push({
                                  nestedArrIndex: k,
                                  value: item
                                });
                              });
                            } else ;
                          }
                          record.$[keyIndex] = subRecords;
                        } else if (isString2(value2) && !isBlank(value2)) {
                          let subRecord = {
                            v: value2,
                            n: this.norm.get(value2)
                          };
                          record.$[keyIndex] = subRecord;
                        }
                      });
                      this.records.push(record);
                    }
                    toJSON() {
                      return {
                        keys: this.keys,
                        records: this.records
                      };
                    }
                  }
                  function createIndex(keys2, docs, { getFn = Config2.getFn, fieldNormWeight = Config2.fieldNormWeight } = {}) {
                    const myIndex = new FuseIndex({ getFn, fieldNormWeight });
                    myIndex.setKeys(keys2.map(createKey3));
                    myIndex.setSources(docs);
                    myIndex.create();
                    return myIndex;
                  }
                  function parseIndex(data2, { getFn = Config2.getFn, fieldNormWeight = Config2.fieldNormWeight } = {}) {
                    const { keys: keys2, records } = data2;
                    const myIndex = new FuseIndex({ getFn, fieldNormWeight });
                    myIndex.setKeys(keys2);
                    myIndex.setIndexRecords(records);
                    return myIndex;
                  }
                  function computeScore$1(pattern, {
                    errors = 0,
                    currentLocation = 0,
                    expectedLocation = 0,
                    distance: distance8 = Config2.distance,
                    ignoreLocation = Config2.ignoreLocation
                  } = {}) {
                    const accuracy = errors / pattern.length;
                    if (ignoreLocation) {
                      return accuracy;
                    }
                    const proximity = Math.abs(expectedLocation - currentLocation);
                    if (!distance8) {
                      return proximity ? 1 : accuracy;
                    }
                    return accuracy + proximity / distance8;
                  }
                  function convertMaskToIndices(matchmask = [], minMatchCharLength = Config2.minMatchCharLength) {
                    let indices = [];
                    let start2 = -1;
                    let end = -1;
                    let i = 0;
                    for (let len5 = matchmask.length; i < len5; i += 1) {
                      let match2 = matchmask[i];
                      if (match2 && start2 === -1) {
                        start2 = i;
                      } else if (!match2 && start2 !== -1) {
                        end = i - 1;
                        if (end - start2 + 1 >= minMatchCharLength) {
                          indices.push([start2, end]);
                        }
                        start2 = -1;
                      }
                    }
                    if (matchmask[i - 1] && i - start2 >= minMatchCharLength) {
                      indices.push([start2, i - 1]);
                    }
                    return indices;
                  }
                  const MAX_BITS = 32;
                  function search2(text, pattern, patternAlphabet, {
                    location: location2 = Config2.location,
                    distance: distance8 = Config2.distance,
                    threshold = Config2.threshold,
                    findAllMatches = Config2.findAllMatches,
                    minMatchCharLength = Config2.minMatchCharLength,
                    includeMatches = Config2.includeMatches,
                    ignoreLocation = Config2.ignoreLocation
                  } = {}) {
                    if (pattern.length > MAX_BITS) {
                      throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
                    }
                    const patternLen = pattern.length;
                    const textLen = text.length;
                    const expectedLocation = Math.max(0, Math.min(location2, textLen));
                    let currentThreshold = threshold;
                    let bestLocation = expectedLocation;
                    const computeMatches = minMatchCharLength > 1 || includeMatches;
                    const matchMask = computeMatches ? Array(textLen) : [];
                    let index4;
                    while ((index4 = text.indexOf(pattern, bestLocation)) > -1) {
                      let score2 = computeScore$1(pattern, {
                        currentLocation: index4,
                        expectedLocation,
                        distance: distance8,
                        ignoreLocation
                      });
                      currentThreshold = Math.min(score2, currentThreshold);
                      bestLocation = index4 + patternLen;
                      if (computeMatches) {
                        let i = 0;
                        while (i < patternLen) {
                          matchMask[index4 + i] = 1;
                          i += 1;
                        }
                      }
                    }
                    bestLocation = -1;
                    let lastBitArr = [];
                    let finalScore = 1;
                    let binMax = patternLen + textLen;
                    const mask = 1 << patternLen - 1;
                    for (let i = 0; i < patternLen; i += 1) {
                      let binMin = 0;
                      let binMid = binMax;
                      while (binMin < binMid) {
                        const score3 = computeScore$1(pattern, {
                          errors: i,
                          currentLocation: expectedLocation + binMid,
                          expectedLocation,
                          distance: distance8,
                          ignoreLocation
                        });
                        if (score3 <= currentThreshold) {
                          binMin = binMid;
                        } else {
                          binMax = binMid;
                        }
                        binMid = Math.floor((binMax - binMin) / 2 + binMin);
                      }
                      binMax = binMid;
                      let start2 = Math.max(1, expectedLocation - binMid + 1);
                      let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
                      let bitArr = Array(finish + 2);
                      bitArr[finish + 1] = (1 << i) - 1;
                      for (let j = finish; j >= start2; j -= 1) {
                        let currentLocation = j - 1;
                        let charMatch = patternAlphabet[text.charAt(currentLocation)];
                        if (computeMatches) {
                          matchMask[currentLocation] = +!!charMatch;
                        }
                        bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
                        if (i) {
                          bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
                        }
                        if (bitArr[j] & mask) {
                          finalScore = computeScore$1(pattern, {
                            errors: i,
                            currentLocation,
                            expectedLocation,
                            distance: distance8,
                            ignoreLocation
                          });
                          if (finalScore <= currentThreshold) {
                            currentThreshold = finalScore;
                            bestLocation = currentLocation;
                            if (bestLocation <= expectedLocation) {
                              break;
                            }
                            start2 = Math.max(1, 2 * expectedLocation - bestLocation);
                          }
                        }
                      }
                      const score2 = computeScore$1(pattern, {
                        errors: i + 1,
                        currentLocation: expectedLocation,
                        expectedLocation,
                        distance: distance8,
                        ignoreLocation
                      });
                      if (score2 > currentThreshold) {
                        break;
                      }
                      lastBitArr = bitArr;
                    }
                    const result = {
                      isMatch: bestLocation >= 0,
                      // Count exact matches (those with a score of 0) to be "almost" exact
                      score: Math.max(1e-3, finalScore)
                    };
                    if (computeMatches) {
                      const indices = convertMaskToIndices(matchMask, minMatchCharLength);
                      if (!indices.length) {
                        result.isMatch = false;
                      } else if (includeMatches) {
                        result.indices = indices;
                      }
                    }
                    return result;
                  }
                  function createPatternAlphabet(pattern) {
                    let mask = {};
                    for (let i = 0, len5 = pattern.length; i < len5; i += 1) {
                      const char = pattern.charAt(i);
                      mask[char] = (mask[char] || 0) | 1 << len5 - i - 1;
                    }
                    return mask;
                  }
                  class BitapSearch {
                    constructor(pattern, {
                      location: location2 = Config2.location,
                      threshold = Config2.threshold,
                      distance: distance8 = Config2.distance,
                      includeMatches = Config2.includeMatches,
                      findAllMatches = Config2.findAllMatches,
                      minMatchCharLength = Config2.minMatchCharLength,
                      isCaseSensitive = Config2.isCaseSensitive,
                      ignoreLocation = Config2.ignoreLocation
                    } = {}) {
                      this.options = {
                        location: location2,
                        threshold,
                        distance: distance8,
                        includeMatches,
                        findAllMatches,
                        minMatchCharLength,
                        isCaseSensitive,
                        ignoreLocation
                      };
                      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
                      this.chunks = [];
                      if (!this.pattern.length) {
                        return;
                      }
                      const addChunk = (pattern2, startIndex) => {
                        this.chunks.push({
                          pattern: pattern2,
                          alphabet: createPatternAlphabet(pattern2),
                          startIndex
                        });
                      };
                      const len5 = this.pattern.length;
                      if (len5 > MAX_BITS) {
                        let i = 0;
                        const remainder = len5 % MAX_BITS;
                        const end = len5 - remainder;
                        while (i < end) {
                          addChunk(this.pattern.substr(i, MAX_BITS), i);
                          i += MAX_BITS;
                        }
                        if (remainder) {
                          const startIndex = len5 - MAX_BITS;
                          addChunk(this.pattern.substr(startIndex), startIndex);
                        }
                      } else {
                        addChunk(this.pattern, 0);
                      }
                    }
                    searchIn(text) {
                      const { isCaseSensitive, includeMatches } = this.options;
                      if (!isCaseSensitive) {
                        text = text.toLowerCase();
                      }
                      if (this.pattern === text) {
                        let result2 = {
                          isMatch: true,
                          score: 0
                        };
                        if (includeMatches) {
                          result2.indices = [[0, text.length - 1]];
                        }
                        return result2;
                      }
                      const {
                        location: location2,
                        distance: distance8,
                        threshold,
                        findAllMatches,
                        minMatchCharLength,
                        ignoreLocation
                      } = this.options;
                      let allIndices = [];
                      let totalScore = 0;
                      let hasMatches = false;
                      this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
                        const { isMatch: isMatch2, score: score2, indices } = search2(text, pattern, alphabet, {
                          location: location2 + startIndex,
                          distance: distance8,
                          threshold,
                          findAllMatches,
                          minMatchCharLength,
                          includeMatches,
                          ignoreLocation
                        });
                        if (isMatch2) {
                          hasMatches = true;
                        }
                        totalScore += score2;
                        if (isMatch2 && indices) {
                          allIndices = [...allIndices, ...indices];
                        }
                      });
                      let result = {
                        isMatch: hasMatches,
                        score: hasMatches ? totalScore / this.chunks.length : 1
                      };
                      if (hasMatches && includeMatches) {
                        result.indices = allIndices;
                      }
                      return result;
                    }
                  }
                  class BaseMatch {
                    constructor(pattern) {
                      this.pattern = pattern;
                    }
                    static isMultiMatch(pattern) {
                      return getMatch(pattern, this.multiRegex);
                    }
                    static isSingleMatch(pattern) {
                      return getMatch(pattern, this.singleRegex);
                    }
                    search() {
                    }
                  }
                  function getMatch(pattern, exp3) {
                    const matches2 = pattern.match(exp3);
                    return matches2 ? matches2[1] : null;
                  }
                  class ExactMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "exact";
                    }
                    static get multiRegex() {
                      return /^="(.*)"$/;
                    }
                    static get singleRegex() {
                      return /^=(.*)$/;
                    }
                    search(text) {
                      const isMatch2 = text === this.pattern;
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices: [0, this.pattern.length - 1]
                      };
                    }
                  }
                  class InverseExactMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "inverse-exact";
                    }
                    static get multiRegex() {
                      return /^!"(.*)"$/;
                    }
                    static get singleRegex() {
                      return /^!(.*)$/;
                    }
                    search(text) {
                      const index4 = text.indexOf(this.pattern);
                      const isMatch2 = index4 === -1;
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices: [0, text.length - 1]
                      };
                    }
                  }
                  class PrefixExactMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "prefix-exact";
                    }
                    static get multiRegex() {
                      return /^\^"(.*)"$/;
                    }
                    static get singleRegex() {
                      return /^\^(.*)$/;
                    }
                    search(text) {
                      const isMatch2 = text.startsWith(this.pattern);
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices: [0, this.pattern.length - 1]
                      };
                    }
                  }
                  class InversePrefixExactMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "inverse-prefix-exact";
                    }
                    static get multiRegex() {
                      return /^!\^"(.*)"$/;
                    }
                    static get singleRegex() {
                      return /^!\^(.*)$/;
                    }
                    search(text) {
                      const isMatch2 = !text.startsWith(this.pattern);
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices: [0, text.length - 1]
                      };
                    }
                  }
                  class SuffixExactMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "suffix-exact";
                    }
                    static get multiRegex() {
                      return /^"(.*)"\$$/;
                    }
                    static get singleRegex() {
                      return /^(.*)\$$/;
                    }
                    search(text) {
                      const isMatch2 = text.endsWith(this.pattern);
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices: [text.length - this.pattern.length, text.length - 1]
                      };
                    }
                  }
                  class InverseSuffixExactMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "inverse-suffix-exact";
                    }
                    static get multiRegex() {
                      return /^!"(.*)"\$$/;
                    }
                    static get singleRegex() {
                      return /^!(.*)\$$/;
                    }
                    search(text) {
                      const isMatch2 = !text.endsWith(this.pattern);
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices: [0, text.length - 1]
                      };
                    }
                  }
                  class FuzzyMatch extends BaseMatch {
                    constructor(pattern, {
                      location: location2 = Config2.location,
                      threshold = Config2.threshold,
                      distance: distance8 = Config2.distance,
                      includeMatches = Config2.includeMatches,
                      findAllMatches = Config2.findAllMatches,
                      minMatchCharLength = Config2.minMatchCharLength,
                      isCaseSensitive = Config2.isCaseSensitive,
                      ignoreLocation = Config2.ignoreLocation
                    } = {}) {
                      super(pattern);
                      this._bitapSearch = new BitapSearch(pattern, {
                        location: location2,
                        threshold,
                        distance: distance8,
                        includeMatches,
                        findAllMatches,
                        minMatchCharLength,
                        isCaseSensitive,
                        ignoreLocation
                      });
                    }
                    static get type() {
                      return "fuzzy";
                    }
                    static get multiRegex() {
                      return /^"(.*)"$/;
                    }
                    static get singleRegex() {
                      return /^(.*)$/;
                    }
                    search(text) {
                      return this._bitapSearch.searchIn(text);
                    }
                  }
                  class IncludeMatch extends BaseMatch {
                    constructor(pattern) {
                      super(pattern);
                    }
                    static get type() {
                      return "include";
                    }
                    static get multiRegex() {
                      return /^'"(.*)"$/;
                    }
                    static get singleRegex() {
                      return /^'(.*)$/;
                    }
                    search(text) {
                      let location2 = 0;
                      let index4;
                      const indices = [];
                      const patternLen = this.pattern.length;
                      while ((index4 = text.indexOf(this.pattern, location2)) > -1) {
                        location2 = index4 + patternLen;
                        indices.push([index4, location2 - 1]);
                      }
                      const isMatch2 = !!indices.length;
                      return {
                        isMatch: isMatch2,
                        score: isMatch2 ? 0 : 1,
                        indices
                      };
                    }
                  }
                  const searchers = [
                    ExactMatch,
                    IncludeMatch,
                    PrefixExactMatch,
                    InversePrefixExactMatch,
                    InverseSuffixExactMatch,
                    SuffixExactMatch,
                    InverseExactMatch,
                    FuzzyMatch
                  ];
                  const searchersLen = searchers.length;
                  const SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
                  const OR_TOKEN = "|";
                  function parseQuery(pattern, options = {}) {
                    return pattern.split(OR_TOKEN).map((item) => {
                      let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
                      let results = [];
                      for (let i = 0, len5 = query.length; i < len5; i += 1) {
                        const queryItem = query[i];
                        let found = false;
                        let idx = -1;
                        while (!found && ++idx < searchersLen) {
                          const searcher = searchers[idx];
                          let token2 = searcher.isMultiMatch(queryItem);
                          if (token2) {
                            results.push(new searcher(token2, options));
                            found = true;
                          }
                        }
                        if (found) {
                          continue;
                        }
                        idx = -1;
                        while (++idx < searchersLen) {
                          const searcher = searchers[idx];
                          let token2 = searcher.isSingleMatch(queryItem);
                          if (token2) {
                            results.push(new searcher(token2, options));
                            break;
                          }
                        }
                      }
                      return results;
                    });
                  }
                  const MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
                  class ExtendedSearch {
                    constructor(pattern, {
                      isCaseSensitive = Config2.isCaseSensitive,
                      includeMatches = Config2.includeMatches,
                      minMatchCharLength = Config2.minMatchCharLength,
                      ignoreLocation = Config2.ignoreLocation,
                      findAllMatches = Config2.findAllMatches,
                      location: location2 = Config2.location,
                      threshold = Config2.threshold,
                      distance: distance8 = Config2.distance
                    } = {}) {
                      this.query = null;
                      this.options = {
                        isCaseSensitive,
                        includeMatches,
                        minMatchCharLength,
                        findAllMatches,
                        ignoreLocation,
                        location: location2,
                        threshold,
                        distance: distance8
                      };
                      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
                      this.query = parseQuery(this.pattern, this.options);
                    }
                    static condition(_2, options) {
                      return options.useExtendedSearch;
                    }
                    searchIn(text) {
                      const query = this.query;
                      if (!query) {
                        return {
                          isMatch: false,
                          score: 1
                        };
                      }
                      const { includeMatches, isCaseSensitive } = this.options;
                      text = isCaseSensitive ? text : text.toLowerCase();
                      let numMatches = 0;
                      let allIndices = [];
                      let totalScore = 0;
                      for (let i = 0, qLen = query.length; i < qLen; i += 1) {
                        const searchers2 = query[i];
                        allIndices.length = 0;
                        numMatches = 0;
                        for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
                          const searcher = searchers2[j];
                          const { isMatch: isMatch2, indices, score: score2 } = searcher.search(text);
                          if (isMatch2) {
                            numMatches += 1;
                            totalScore += score2;
                            if (includeMatches) {
                              const type = searcher.constructor.type;
                              if (MultiMatchSet.has(type)) {
                                allIndices = [...allIndices, ...indices];
                              } else {
                                allIndices.push(indices);
                              }
                            }
                          } else {
                            totalScore = 0;
                            numMatches = 0;
                            allIndices.length = 0;
                            break;
                          }
                        }
                        if (numMatches) {
                          let result = {
                            isMatch: true,
                            score: totalScore / numMatches
                          };
                          if (includeMatches) {
                            result.indices = allIndices;
                          }
                          return result;
                        }
                      }
                      return {
                        isMatch: false,
                        score: 1
                      };
                    }
                  }
                  const registeredSearchers = [];
                  function register(...args) {
                    registeredSearchers.push(...args);
                  }
                  function createSearcher(pattern, options) {
                    for (let i = 0, len5 = registeredSearchers.length; i < len5; i += 1) {
                      let searcherClass = registeredSearchers[i];
                      if (searcherClass.condition(pattern, options)) {
                        return new searcherClass(pattern, options);
                      }
                    }
                    return new BitapSearch(pattern, options);
                  }
                  const LogicalOperator = {
                    AND: "$and",
                    OR: "$or"
                  };
                  const KeyType = {
                    PATH: "$path",
                    PATTERN: "$val"
                  };
                  const isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
                  const isPath = (query) => !!query[KeyType.PATH];
                  const isLeaf = (query) => !isArray(query) && isObject4(query) && !isExpression(query);
                  const convertToExplicit = (query) => ({
                    [LogicalOperator.AND]: Object.keys(query).map((key) => ({
                      [key]: query[key]
                    }))
                  });
                  function parse2(query, options, { auto = true } = {}) {
                    const next = (query2) => {
                      let keys2 = Object.keys(query2);
                      const isQueryPath = isPath(query2);
                      if (!isQueryPath && keys2.length > 1 && !isExpression(query2)) {
                        return next(convertToExplicit(query2));
                      }
                      if (isLeaf(query2)) {
                        const key = isQueryPath ? query2[KeyType.PATH] : keys2[0];
                        const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
                        if (!isString2(pattern)) {
                          throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
                        }
                        const obj = {
                          keyId: createKeyId(key),
                          pattern
                        };
                        if (auto) {
                          obj.searcher = createSearcher(pattern, options);
                        }
                        return obj;
                      }
                      let node = {
                        children: [],
                        operator: keys2[0]
                      };
                      keys2.forEach((key) => {
                        const value2 = query2[key];
                        if (isArray(value2)) {
                          value2.forEach((item) => {
                            node.children.push(next(item));
                          });
                        }
                      });
                      return node;
                    };
                    if (!isExpression(query)) {
                      query = convertToExplicit(query);
                    }
                    return next(query);
                  }
                  function computeScore(results, { ignoreFieldNorm = Config2.ignoreFieldNorm }) {
                    results.forEach((result) => {
                      let totalScore = 1;
                      result.matches.forEach(({ key, norm: norm3, score: score2 }) => {
                        const weight2 = key ? key.weight : null;
                        totalScore *= Math.pow(
                          score2 === 0 && weight2 ? Number.EPSILON : score2,
                          (weight2 || 1) * (ignoreFieldNorm ? 1 : norm3)
                        );
                      });
                      result.score = totalScore;
                    });
                  }
                  function transformMatches(result, data2) {
                    const matches2 = result.matches;
                    data2.matches = [];
                    if (!isDefined(matches2)) {
                      return;
                    }
                    matches2.forEach((match2) => {
                      if (!isDefined(match2.indices) || !match2.indices.length) {
                        return;
                      }
                      const { indices, value: value2 } = match2;
                      let obj = {
                        indices,
                        value: value2
                      };
                      if (match2.key) {
                        obj.key = match2.key.src;
                      }
                      if (match2.idx > -1) {
                        obj.refIndex = match2.idx;
                      }
                      data2.matches.push(obj);
                    });
                  }
                  function transformScore(result, data2) {
                    data2.score = result.score;
                  }
                  function format3(results, docs, {
                    includeMatches = Config2.includeMatches,
                    includeScore = Config2.includeScore
                  } = {}) {
                    const transformers = [];
                    if (includeMatches) transformers.push(transformMatches);
                    if (includeScore) transformers.push(transformScore);
                    return results.map((result) => {
                      const { idx } = result;
                      const data2 = {
                        item: docs[idx],
                        refIndex: idx
                      };
                      if (transformers.length) {
                        transformers.forEach((transformer2) => {
                          transformer2(result, data2);
                        });
                      }
                      return data2;
                    });
                  }
                  class Fuse {
                    constructor(docs, options = {}, index4) {
                      this.options = { ...Config2, ...options };
                      if (this.options.useExtendedSearch && false) {
                      }
                      this._keyStore = new KeyStore(this.options.keys);
                      this.setCollection(docs, index4);
                    }
                    setCollection(docs, index4) {
                      this._docs = docs;
                      if (index4 && !(index4 instanceof FuseIndex)) {
                        throw new Error(INCORRECT_INDEX_TYPE);
                      }
                      this._myIndex = index4 || createIndex(this.options.keys, this._docs, {
                        getFn: this.options.getFn,
                        fieldNormWeight: this.options.fieldNormWeight
                      });
                    }
                    add(doc) {
                      if (!isDefined(doc)) {
                        return;
                      }
                      this._docs.push(doc);
                      this._myIndex.add(doc);
                    }
                    remove(predicate = () => false) {
                      const results = [];
                      for (let i = 0, len5 = this._docs.length; i < len5; i += 1) {
                        const doc = this._docs[i];
                        if (predicate(doc, i)) {
                          this.removeAt(i);
                          i -= 1;
                          len5 -= 1;
                          results.push(doc);
                        }
                      }
                      return results;
                    }
                    removeAt(idx) {
                      this._docs.splice(idx, 1);
                      this._myIndex.removeAt(idx);
                    }
                    getIndex() {
                      return this._myIndex;
                    }
                    search(query, { limit = -1 } = {}) {
                      const {
                        includeMatches,
                        includeScore,
                        shouldSort,
                        sortFn,
                        ignoreFieldNorm
                      } = this.options;
                      let results = isString2(query) ? isString2(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
                      computeScore(results, { ignoreFieldNorm });
                      if (shouldSort) {
                        results.sort(sortFn);
                      }
                      if (isNumber8(limit) && limit > -1) {
                        results = results.slice(0, limit);
                      }
                      return format3(results, this._docs, {
                        includeMatches,
                        includeScore
                      });
                    }
                    _searchStringList(query) {
                      const searcher = createSearcher(query, this.options);
                      const { records } = this._myIndex;
                      const results = [];
                      records.forEach(({ v: text, i: idx, n: norm3 }) => {
                        if (!isDefined(text)) {
                          return;
                        }
                        const { isMatch: isMatch2, score: score2, indices } = searcher.searchIn(text);
                        if (isMatch2) {
                          results.push({
                            item: text,
                            idx,
                            matches: [{ score: score2, value: text, norm: norm3, indices }]
                          });
                        }
                      });
                      return results;
                    }
                    _searchLogical(query) {
                      const expression = parse2(query, this.options);
                      const evaluate = (node, item, idx) => {
                        if (!node.children) {
                          const { keyId, searcher } = node;
                          const matches2 = this._findMatches({
                            key: this._keyStore.get(keyId),
                            value: this._myIndex.getValueForItemAtKeyId(item, keyId),
                            searcher
                          });
                          if (matches2 && matches2.length) {
                            return [
                              {
                                idx,
                                item,
                                matches: matches2
                              }
                            ];
                          }
                          return [];
                        }
                        const res = [];
                        for (let i = 0, len5 = node.children.length; i < len5; i += 1) {
                          const child = node.children[i];
                          const result = evaluate(child, item, idx);
                          if (result.length) {
                            res.push(...result);
                          } else if (node.operator === LogicalOperator.AND) {
                            return [];
                          }
                        }
                        return res;
                      };
                      const records = this._myIndex.records;
                      const resultMap = {};
                      const results = [];
                      records.forEach(({ $: item, i: idx }) => {
                        if (isDefined(item)) {
                          let expResults = evaluate(expression, item, idx);
                          if (expResults.length) {
                            if (!resultMap[idx]) {
                              resultMap[idx] = { idx, item, matches: [] };
                              results.push(resultMap[idx]);
                            }
                            expResults.forEach(({ matches: matches2 }) => {
                              resultMap[idx].matches.push(...matches2);
                            });
                          }
                        }
                      });
                      return results;
                    }
                    _searchObjectList(query) {
                      const searcher = createSearcher(query, this.options);
                      const { keys: keys2, records } = this._myIndex;
                      const results = [];
                      records.forEach(({ $: item, i: idx }) => {
                        if (!isDefined(item)) {
                          return;
                        }
                        let matches2 = [];
                        keys2.forEach((key, keyIndex) => {
                          matches2.push(
                            ...this._findMatches({
                              key,
                              value: item[keyIndex],
                              searcher
                            })
                          );
                        });
                        if (matches2.length) {
                          results.push({
                            idx,
                            item,
                            matches: matches2
                          });
                        }
                      });
                      return results;
                    }
                    _findMatches({ key, value: value2, searcher }) {
                      if (!isDefined(value2)) {
                        return [];
                      }
                      let matches2 = [];
                      if (isArray(value2)) {
                        value2.forEach(({ v: text, i: idx, n: norm3 }) => {
                          if (!isDefined(text)) {
                            return;
                          }
                          const { isMatch: isMatch2, score: score2, indices } = searcher.searchIn(text);
                          if (isMatch2) {
                            matches2.push({
                              score: score2,
                              key,
                              value: text,
                              idx,
                              norm: norm3,
                              indices
                            });
                          }
                        });
                      } else {
                        const { v: text, n: norm3 } = value2;
                        const { isMatch: isMatch2, score: score2, indices } = searcher.searchIn(text);
                        if (isMatch2) {
                          matches2.push({ score: score2, key, value: text, norm: norm3, indices });
                        }
                      }
                      return matches2;
                    }
                  }
                  Fuse.version = "6.6.2";
                  Fuse.createIndex = createIndex;
                  Fuse.parseIndex = parseIndex;
                  Fuse.config = Config2;
                  {
                    Fuse.parseQuery = parse2;
                  }
                  {
                    register(ExtendedSearch);
                  }
                }
              ),
              /***/
              791: (
                /***/
                function(__unused_webpack_module, __webpack_exports__2, __webpack_require__2) {
                  __webpack_require__2.r(__webpack_exports__2);
                  __webpack_require__2.d(__webpack_exports__2, {
                    "__DO_NOT_USE__ActionTypes": function() {
                      return (
                        /* binding */
                        ActionTypes
                      );
                    },
                    "applyMiddleware": function() {
                      return (
                        /* binding */
                        applyMiddleware
                      );
                    },
                    "bindActionCreators": function() {
                      return (
                        /* binding */
                        bindActionCreators
                      );
                    },
                    "combineReducers": function() {
                      return (
                        /* binding */
                        combineReducers
                      );
                    },
                    "compose": function() {
                      return (
                        /* binding */
                        compose4
                      );
                    },
                    "createStore": function() {
                      return (
                        /* binding */
                        createStore
                      );
                    },
                    "legacy_createStore": function() {
                      return (
                        /* binding */
                        legacy_createStore
                      );
                    }
                  });
                  ;
                  function _typeof2(obj) {
                    "@babel/helpers - typeof";
                    return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
                      return typeof obj2;
                    } : function(obj2) {
                      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
                    }, _typeof2(obj);
                  }
                  ;
                  function _toPrimitive(input, hint) {
                    if (_typeof2(input) !== "object" || input === null) return input;
                    var prim = input[Symbol.toPrimitive];
                    if (prim !== void 0) {
                      var res = prim.call(input, hint || "default");
                      if (_typeof2(res) !== "object") return res;
                      throw new TypeError("@@toPrimitive must return a primitive value.");
                    }
                    return (hint === "string" ? String : Number)(input);
                  }
                  ;
                  function _toPropertyKey(arg) {
                    var key = _toPrimitive(arg, "string");
                    return _typeof2(key) === "symbol" ? key : String(key);
                  }
                  ;
                  function _defineProperty2(obj, key, value2) {
                    key = _toPropertyKey(key);
                    if (key in obj) {
                      Object.defineProperty(obj, key, {
                        value: value2,
                        enumerable: true,
                        configurable: true,
                        writable: true
                      });
                    } else {
                      obj[key] = value2;
                    }
                    return obj;
                  }
                  ;
                  function ownKeys2(object, enumerableOnly) {
                    var keys2 = Object.keys(object);
                    if (Object.getOwnPropertySymbols) {
                      var symbols = Object.getOwnPropertySymbols(object);
                      enumerableOnly && (symbols = symbols.filter(function(sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                      })), keys2.push.apply(keys2, symbols);
                    }
                    return keys2;
                  }
                  function _objectSpread22(target) {
                    for (var i = 1; i < arguments.length; i++) {
                      var source = null != arguments[i] ? arguments[i] : {};
                      i % 2 ? ownKeys2(Object(source), true).forEach(function(key) {
                        _defineProperty2(target, key, source[key]);
                      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys2(Object(source)).forEach(function(key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                      });
                    }
                    return target;
                  }
                  ;
                  function formatProdErrorMessage(code) {
                    return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
                  }
                  var $$observable = function() {
                    return typeof Symbol === "function" && Symbol.observable || "@@observable";
                  }();
                  var randomString = function randomString2() {
                    return Math.random().toString(36).substring(7).split("").join(".");
                  };
                  var ActionTypes = {
                    INIT: "@@redux/INIT" + randomString(),
                    REPLACE: "@@redux/REPLACE" + randomString(),
                    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
                      return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
                    }
                  };
                  function isPlainObject3(obj) {
                    if (typeof obj !== "object" || obj === null) return false;
                    var proto = obj;
                    while (Object.getPrototypeOf(proto) !== null) {
                      proto = Object.getPrototypeOf(proto);
                    }
                    return Object.getPrototypeOf(obj) === proto;
                  }
                  function miniKindOf(val) {
                    if (val === void 0) return "undefined";
                    if (val === null) return "null";
                    var type = typeof val;
                    switch (type) {
                      case "boolean":
                      case "string":
                      case "number":
                      case "symbol":
                      case "function": {
                        return type;
                      }
                    }
                    if (Array.isArray(val)) return "array";
                    if (isDate2(val)) return "date";
                    if (isError(val)) return "error";
                    var constructorName = ctorName(val);
                    switch (constructorName) {
                      case "Symbol":
                      case "Promise":
                      case "WeakMap":
                      case "WeakSet":
                      case "Map":
                      case "Set":
                        return constructorName;
                    }
                    return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
                  }
                  function ctorName(val) {
                    return typeof val.constructor === "function" ? val.constructor.name : null;
                  }
                  function isError(val) {
                    return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
                  }
                  function isDate2(val) {
                    if (val instanceof Date) return true;
                    return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
                  }
                  function kindOf(val) {
                    var typeOfVal = typeof val;
                    if (false) {
                    }
                    return typeOfVal;
                  }
                  function createStore(reducer, preloadedState, enhancer) {
                    var _ref2;
                    if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
                      throw new Error(true ? formatProdErrorMessage(0) : 0);
                    }
                    if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
                      enhancer = preloadedState;
                      preloadedState = void 0;
                    }
                    if (typeof enhancer !== "undefined") {
                      if (typeof enhancer !== "function") {
                        throw new Error(true ? formatProdErrorMessage(1) : 0);
                      }
                      return enhancer(createStore)(reducer, preloadedState);
                    }
                    if (typeof reducer !== "function") {
                      throw new Error(true ? formatProdErrorMessage(2) : 0);
                    }
                    var currentReducer = reducer;
                    var currentState = preloadedState;
                    var currentListeners = [];
                    var nextListeners = currentListeners;
                    var isDispatching = false;
                    function ensureCanMutateNextListeners() {
                      if (nextListeners === currentListeners) {
                        nextListeners = currentListeners.slice();
                      }
                    }
                    function getState() {
                      if (isDispatching) {
                        throw new Error(true ? formatProdErrorMessage(3) : 0);
                      }
                      return currentState;
                    }
                    function subscribe(listener) {
                      if (typeof listener !== "function") {
                        throw new Error(true ? formatProdErrorMessage(4) : 0);
                      }
                      if (isDispatching) {
                        throw new Error(true ? formatProdErrorMessage(5) : 0);
                      }
                      var isSubscribed = true;
                      ensureCanMutateNextListeners();
                      nextListeners.push(listener);
                      return function unsubscribe() {
                        if (!isSubscribed) {
                          return;
                        }
                        if (isDispatching) {
                          throw new Error(true ? formatProdErrorMessage(6) : 0);
                        }
                        isSubscribed = false;
                        ensureCanMutateNextListeners();
                        var index4 = nextListeners.indexOf(listener);
                        nextListeners.splice(index4, 1);
                        currentListeners = null;
                      };
                    }
                    function dispatch3(action) {
                      if (!isPlainObject3(action)) {
                        throw new Error(true ? formatProdErrorMessage(7) : 0);
                      }
                      if (typeof action.type === "undefined") {
                        throw new Error(true ? formatProdErrorMessage(8) : 0);
                      }
                      if (isDispatching) {
                        throw new Error(true ? formatProdErrorMessage(9) : 0);
                      }
                      try {
                        isDispatching = true;
                        currentState = currentReducer(currentState, action);
                      } finally {
                        isDispatching = false;
                      }
                      var listeners = currentListeners = nextListeners;
                      for (var i = 0; i < listeners.length; i++) {
                        var listener = listeners[i];
                        listener();
                      }
                      return action;
                    }
                    function replaceReducer(nextReducer) {
                      if (typeof nextReducer !== "function") {
                        throw new Error(true ? formatProdErrorMessage(10) : 0);
                      }
                      currentReducer = nextReducer;
                      dispatch3({
                        type: ActionTypes.REPLACE
                      });
                    }
                    function observable() {
                      var _ref;
                      var outerSubscribe = subscribe;
                      return _ref = {
                        /**
                         * The minimal observable subscription method.
                         * @param {Object} observer Any object that can be used as an observer.
                         * The observer object should have a `next` method.
                         * @returns {subscription} An object with an `unsubscribe` method that can
                         * be used to unsubscribe the observable from the store, and prevent further
                         * emission of values from the observable.
                         */
                        subscribe: function subscribe2(observer) {
                          if (typeof observer !== "object" || observer === null) {
                            throw new Error(true ? formatProdErrorMessage(11) : 0);
                          }
                          function observeState() {
                            if (observer.next) {
                              observer.next(getState());
                            }
                          }
                          observeState();
                          var unsubscribe = outerSubscribe(observeState);
                          return {
                            unsubscribe
                          };
                        }
                      }, _ref[$$observable] = function() {
                        return this;
                      }, _ref;
                    }
                    dispatch3({
                      type: ActionTypes.INIT
                    });
                    return _ref2 = {
                      dispatch: dispatch3,
                      subscribe,
                      getState,
                      replaceReducer
                    }, _ref2[$$observable] = observable, _ref2;
                  }
                  var legacy_createStore = createStore;
                  function warning(message) {
                    if (typeof console !== "undefined" && typeof console.error === "function") {
                      console.error(message);
                    }
                    try {
                      throw new Error(message);
                    } catch (e3) {
                    }
                  }
                  function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
                    var reducerKeys = Object.keys(reducers);
                    var argumentName = action && action.type === ActionTypes.INIT ? "preloadedState argument passed to createStore" : "previous state received by the reducer";
                    if (reducerKeys.length === 0) {
                      return "Store does not have a valid reducer. Make sure the argument passed to combineReducers is an object whose values are reducers.";
                    }
                    if (!isPlainObject3(inputState)) {
                      return "The " + argumentName + ' has unexpected type of "' + kindOf(inputState) + '". Expected argument to be an object with the following ' + ('keys: "' + reducerKeys.join('", "') + '"');
                    }
                    var unexpectedKeys = Object.keys(inputState).filter(function(key) {
                      return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
                    });
                    unexpectedKeys.forEach(function(key) {
                      unexpectedKeyCache[key] = true;
                    });
                    if (action && action.type === ActionTypes.REPLACE) return;
                    if (unexpectedKeys.length > 0) {
                      return "Unexpected " + (unexpectedKeys.length > 1 ? "keys" : "key") + " " + ('"' + unexpectedKeys.join('", "') + '" found in ' + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ('"' + reducerKeys.join('", "') + '". Unexpected keys will be ignored.');
                    }
                  }
                  function assertReducerShape(reducers) {
                    Object.keys(reducers).forEach(function(key) {
                      var reducer = reducers[key];
                      var initialState = reducer(void 0, {
                        type: ActionTypes.INIT
                      });
                      if (typeof initialState === "undefined") {
                        throw new Error(true ? formatProdErrorMessage(12) : 0);
                      }
                      if (typeof reducer(void 0, {
                        type: ActionTypes.PROBE_UNKNOWN_ACTION()
                      }) === "undefined") {
                        throw new Error(true ? formatProdErrorMessage(13) : 0);
                      }
                    });
                  }
                  function combineReducers(reducers) {
                    var reducerKeys = Object.keys(reducers);
                    var finalReducers = {};
                    for (var i = 0; i < reducerKeys.length; i++) {
                      var key = reducerKeys[i];
                      if (false) {
                      }
                      if (typeof reducers[key] === "function") {
                        finalReducers[key] = reducers[key];
                      }
                    }
                    var finalReducerKeys = Object.keys(finalReducers);
                    var unexpectedKeyCache;
                    if (false) {
                    }
                    var shapeAssertionError;
                    try {
                      assertReducerShape(finalReducers);
                    } catch (e3) {
                      shapeAssertionError = e3;
                    }
                    return function combination(state, action) {
                      if (state === void 0) {
                        state = {};
                      }
                      if (shapeAssertionError) {
                        throw shapeAssertionError;
                      }
                      if (false) {
                        var warningMessage;
                      }
                      var hasChanged = false;
                      var nextState = {};
                      for (var _i = 0; _i < finalReducerKeys.length; _i++) {
                        var _key = finalReducerKeys[_i];
                        var reducer = finalReducers[_key];
                        var previousStateForKey = state[_key];
                        var nextStateForKey = reducer(previousStateForKey, action);
                        if (typeof nextStateForKey === "undefined") {
                          var actionType = action && action.type;
                          throw new Error(true ? formatProdErrorMessage(14) : 0);
                        }
                        nextState[_key] = nextStateForKey;
                        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
                      }
                      hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
                      return hasChanged ? nextState : state;
                    };
                  }
                  function bindActionCreator(actionCreator, dispatch3) {
                    return function() {
                      return dispatch3(actionCreator.apply(this, arguments));
                    };
                  }
                  function bindActionCreators(actionCreators, dispatch3) {
                    if (typeof actionCreators === "function") {
                      return bindActionCreator(actionCreators, dispatch3);
                    }
                    if (typeof actionCreators !== "object" || actionCreators === null) {
                      throw new Error(true ? formatProdErrorMessage(16) : 0);
                    }
                    var boundActionCreators = {};
                    for (var key in actionCreators) {
                      var actionCreator = actionCreators[key];
                      if (typeof actionCreator === "function") {
                        boundActionCreators[key] = bindActionCreator(actionCreator, dispatch3);
                      }
                    }
                    return boundActionCreators;
                  }
                  function compose4() {
                    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
                      funcs[_key] = arguments[_key];
                    }
                    if (funcs.length === 0) {
                      return function(arg) {
                        return arg;
                      };
                    }
                    if (funcs.length === 1) {
                      return funcs[0];
                    }
                    return funcs.reduce(function(a3, b) {
                      return function() {
                        return a3(b.apply(void 0, arguments));
                      };
                    });
                  }
                  function applyMiddleware() {
                    for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
                      middlewares[_key] = arguments[_key];
                    }
                    return function(createStore2) {
                      return function() {
                        var store = createStore2.apply(void 0, arguments);
                        var _dispatch = function dispatch3() {
                          throw new Error(true ? formatProdErrorMessage(15) : 0);
                        };
                        var middlewareAPI = {
                          getState: store.getState,
                          dispatch: function dispatch3() {
                            return _dispatch.apply(void 0, arguments);
                          }
                        };
                        var chain = middlewares.map(function(middleware) {
                          return middleware(middlewareAPI);
                        });
                        _dispatch = compose4.apply(void 0, chain)(store.dispatch);
                        return _objectSpread22(_objectSpread22({}, store), {}, {
                          dispatch: _dispatch
                        });
                      };
                    };
                  }
                  function isCrushed() {
                  }
                  if (false) {
                  }
                }
              )
              /******/
            };
            var __webpack_module_cache__ = {};
            function __webpack_require__(moduleId) {
              var cachedModule = __webpack_module_cache__[moduleId];
              if (cachedModule !== void 0) {
                return cachedModule.exports;
              }
              var module2 = __webpack_module_cache__[moduleId] = {
                /******/
                // no module.id needed
                /******/
                // no module.loaded needed
                /******/
                exports: {}
                /******/
              };
              __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
              return module2.exports;
            }
            !function() {
              __webpack_require__.n = function(module2) {
                var getter = module2 && module2.__esModule ? (
                  /******/
                  function() {
                    return module2["default"];
                  }
                ) : (
                  /******/
                  function() {
                    return module2;
                  }
                );
                __webpack_require__.d(getter, { a: getter });
                return getter;
              };
            }();
            !function() {
              __webpack_require__.d = function(exports2, definition) {
                for (var key in definition) {
                  if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                    Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                  }
                }
              };
            }();
            !function() {
              __webpack_require__.o = function(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
              };
            }();
            !function() {
              __webpack_require__.r = function(exports2) {
                if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
                  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
                }
                Object.defineProperty(exports2, "__esModule", { value: true });
              };
            }();
            var __webpack_exports__ = {};
            !function() {
              var _scripts_choices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(373);
              var _scripts_choices__WEBPACK_IMPORTED_MODULE_0___default = /* @__PURE__ */ __webpack_require__.n(_scripts_choices__WEBPACK_IMPORTED_MODULE_0__);
              var _scripts_interfaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(187);
              var _scripts_interfaces__WEBPACK_IMPORTED_MODULE_1___default = /* @__PURE__ */ __webpack_require__.n(_scripts_interfaces__WEBPACK_IMPORTED_MODULE_1__);
              var _scripts_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(883);
              var _scripts_defaults__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(789);
              var _scripts_templates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(686);
              __webpack_exports__["default"] = _scripts_choices__WEBPACK_IMPORTED_MODULE_0___default();
            }();
            __webpack_exports__ = __webpack_exports__["default"];
            return __webpack_exports__;
          }()
        );
      });
    }
  });

  // ../../engine/rails_design/node_modules/color-name/index.js
  var require_color_name = __commonJS({
    "../../engine/rails_design/node_modules/color-name/index.js"(exports, module) {
      "use strict";
      module.exports = {
        "aliceblue": [240, 248, 255],
        "antiquewhite": [250, 235, 215],
        "aqua": [0, 255, 255],
        "aquamarine": [127, 255, 212],
        "azure": [240, 255, 255],
        "beige": [245, 245, 220],
        "bisque": [255, 228, 196],
        "black": [0, 0, 0],
        "blanchedalmond": [255, 235, 205],
        "blue": [0, 0, 255],
        "blueviolet": [138, 43, 226],
        "brown": [165, 42, 42],
        "burlywood": [222, 184, 135],
        "cadetblue": [95, 158, 160],
        "chartreuse": [127, 255, 0],
        "chocolate": [210, 105, 30],
        "coral": [255, 127, 80],
        "cornflowerblue": [100, 149, 237],
        "cornsilk": [255, 248, 220],
        "crimson": [220, 20, 60],
        "cyan": [0, 255, 255],
        "darkblue": [0, 0, 139],
        "darkcyan": [0, 139, 139],
        "darkgoldenrod": [184, 134, 11],
        "darkgray": [169, 169, 169],
        "darkgreen": [0, 100, 0],
        "darkgrey": [169, 169, 169],
        "darkkhaki": [189, 183, 107],
        "darkmagenta": [139, 0, 139],
        "darkolivegreen": [85, 107, 47],
        "darkorange": [255, 140, 0],
        "darkorchid": [153, 50, 204],
        "darkred": [139, 0, 0],
        "darksalmon": [233, 150, 122],
        "darkseagreen": [143, 188, 143],
        "darkslateblue": [72, 61, 139],
        "darkslategray": [47, 79, 79],
        "darkslategrey": [47, 79, 79],
        "darkturquoise": [0, 206, 209],
        "darkviolet": [148, 0, 211],
        "deeppink": [255, 20, 147],
        "deepskyblue": [0, 191, 255],
        "dimgray": [105, 105, 105],
        "dimgrey": [105, 105, 105],
        "dodgerblue": [30, 144, 255],
        "firebrick": [178, 34, 34],
        "floralwhite": [255, 250, 240],
        "forestgreen": [34, 139, 34],
        "fuchsia": [255, 0, 255],
        "gainsboro": [220, 220, 220],
        "ghostwhite": [248, 248, 255],
        "gold": [255, 215, 0],
        "goldenrod": [218, 165, 32],
        "gray": [128, 128, 128],
        "green": [0, 128, 0],
        "greenyellow": [173, 255, 47],
        "grey": [128, 128, 128],
        "honeydew": [240, 255, 240],
        "hotpink": [255, 105, 180],
        "indianred": [205, 92, 92],
        "indigo": [75, 0, 130],
        "ivory": [255, 255, 240],
        "khaki": [240, 230, 140],
        "lavender": [230, 230, 250],
        "lavenderblush": [255, 240, 245],
        "lawngreen": [124, 252, 0],
        "lemonchiffon": [255, 250, 205],
        "lightblue": [173, 216, 230],
        "lightcoral": [240, 128, 128],
        "lightcyan": [224, 255, 255],
        "lightgoldenrodyellow": [250, 250, 210],
        "lightgray": [211, 211, 211],
        "lightgreen": [144, 238, 144],
        "lightgrey": [211, 211, 211],
        "lightpink": [255, 182, 193],
        "lightsalmon": [255, 160, 122],
        "lightseagreen": [32, 178, 170],
        "lightskyblue": [135, 206, 250],
        "lightslategray": [119, 136, 153],
        "lightslategrey": [119, 136, 153],
        "lightsteelblue": [176, 196, 222],
        "lightyellow": [255, 255, 224],
        "lime": [0, 255, 0],
        "limegreen": [50, 205, 50],
        "linen": [250, 240, 230],
        "magenta": [255, 0, 255],
        "maroon": [128, 0, 0],
        "mediumaquamarine": [102, 205, 170],
        "mediumblue": [0, 0, 205],
        "mediumorchid": [186, 85, 211],
        "mediumpurple": [147, 112, 219],
        "mediumseagreen": [60, 179, 113],
        "mediumslateblue": [123, 104, 238],
        "mediumspringgreen": [0, 250, 154],
        "mediumturquoise": [72, 209, 204],
        "mediumvioletred": [199, 21, 133],
        "midnightblue": [25, 25, 112],
        "mintcream": [245, 255, 250],
        "mistyrose": [255, 228, 225],
        "moccasin": [255, 228, 181],
        "navajowhite": [255, 222, 173],
        "navy": [0, 0, 128],
        "oldlace": [253, 245, 230],
        "olive": [128, 128, 0],
        "olivedrab": [107, 142, 35],
        "orange": [255, 165, 0],
        "orangered": [255, 69, 0],
        "orchid": [218, 112, 214],
        "palegoldenrod": [238, 232, 170],
        "palegreen": [152, 251, 152],
        "paleturquoise": [175, 238, 238],
        "palevioletred": [219, 112, 147],
        "papayawhip": [255, 239, 213],
        "peachpuff": [255, 218, 185],
        "peru": [205, 133, 63],
        "pink": [255, 192, 203],
        "plum": [221, 160, 221],
        "powderblue": [176, 224, 230],
        "purple": [128, 0, 128],
        "rebeccapurple": [102, 51, 153],
        "red": [255, 0, 0],
        "rosybrown": [188, 143, 143],
        "royalblue": [65, 105, 225],
        "saddlebrown": [139, 69, 19],
        "salmon": [250, 128, 114],
        "sandybrown": [244, 164, 96],
        "seagreen": [46, 139, 87],
        "seashell": [255, 245, 238],
        "sienna": [160, 82, 45],
        "silver": [192, 192, 192],
        "skyblue": [135, 206, 235],
        "slateblue": [106, 90, 205],
        "slategray": [112, 128, 144],
        "slategrey": [112, 128, 144],
        "snow": [255, 250, 250],
        "springgreen": [0, 255, 127],
        "steelblue": [70, 130, 180],
        "tan": [210, 180, 140],
        "teal": [0, 128, 128],
        "thistle": [216, 191, 216],
        "tomato": [255, 99, 71],
        "turquoise": [64, 224, 208],
        "violet": [238, 130, 238],
        "wheat": [245, 222, 179],
        "white": [255, 255, 255],
        "whitesmoke": [245, 245, 245],
        "yellow": [255, 255, 0],
        "yellowgreen": [154, 205, 50]
      };
    }
  });

  // ../../engine/rails_design/node_modules/simple-swizzle/node_modules/is-arrayish/index.js
  var require_is_arrayish = __commonJS({
    "../../engine/rails_design/node_modules/simple-swizzle/node_modules/is-arrayish/index.js"(exports, module) {
      module.exports = function isArrayish(obj) {
        if (!obj || typeof obj === "string") {
          return false;
        }
        return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
      };
    }
  });

  // ../../engine/rails_design/node_modules/simple-swizzle/index.js
  var require_simple_swizzle = __commonJS({
    "../../engine/rails_design/node_modules/simple-swizzle/index.js"(exports, module) {
      "use strict";
      var isArrayish = require_is_arrayish();
      var concat = Array.prototype.concat;
      var slice3 = Array.prototype.slice;
      var swizzle = module.exports = function swizzle2(args) {
        var results = [];
        for (var i = 0, len5 = args.length; i < len5; i++) {
          var arg = args[i];
          if (isArrayish(arg)) {
            results = concat.call(results, slice3.call(arg));
          } else {
            results.push(arg);
          }
        }
        return results;
      };
      swizzle.wrap = function(fn) {
        return function() {
          return fn(swizzle(arguments));
        };
      };
    }
  });

  // ../../engine/rails_design/node_modules/color-string/index.js
  var require_color_string = __commonJS({
    "../../engine/rails_design/node_modules/color-string/index.js"(exports, module) {
      var colorNames = require_color_name();
      var swizzle = require_simple_swizzle();
      var hasOwnProperty3 = Object.hasOwnProperty;
      var reverseNames = /* @__PURE__ */ Object.create(null);
      for (name2 in colorNames) {
        if (hasOwnProperty3.call(colorNames, name2)) {
          reverseNames[colorNames[name2]] = name2;
        }
      }
      var name2;
      var cs = module.exports = {
        to: {},
        get: {}
      };
      cs.get = function(string) {
        var prefix = string.substring(0, 3).toLowerCase();
        var val;
        var model;
        switch (prefix) {
          case "hsl":
            val = cs.get.hsl(string);
            model = "hsl";
            break;
          case "hwb":
            val = cs.get.hwb(string);
            model = "hwb";
            break;
          default:
            val = cs.get.rgb(string);
            model = "rgb";
            break;
        }
        if (!val) {
          return null;
        }
        return { model, value: val };
      };
      cs.get.rgb = function(string) {
        if (!string) {
          return null;
        }
        var abbr = /^#([a-f0-9]{3,4})$/i;
        var hex2 = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
        var rgba2 = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
        var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
        var keyword = /^(\w+)$/;
        var rgb2 = [0, 0, 0, 1];
        var match2;
        var i;
        var hexAlpha;
        if (match2 = string.match(hex2)) {
          hexAlpha = match2[2];
          match2 = match2[1];
          for (i = 0; i < 3; i++) {
            var i2 = i * 2;
            rgb2[i] = parseInt(match2.slice(i2, i2 + 2), 16);
          }
          if (hexAlpha) {
            rgb2[3] = parseInt(hexAlpha, 16) / 255;
          }
        } else if (match2 = string.match(abbr)) {
          match2 = match2[1];
          hexAlpha = match2[3];
          for (i = 0; i < 3; i++) {
            rgb2[i] = parseInt(match2[i] + match2[i], 16);
          }
          if (hexAlpha) {
            rgb2[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
          }
        } else if (match2 = string.match(rgba2)) {
          for (i = 0; i < 3; i++) {
            rgb2[i] = parseInt(match2[i + 1], 0);
          }
          if (match2[4]) {
            if (match2[5]) {
              rgb2[3] = parseFloat(match2[4]) * 0.01;
            } else {
              rgb2[3] = parseFloat(match2[4]);
            }
          }
        } else if (match2 = string.match(per)) {
          for (i = 0; i < 3; i++) {
            rgb2[i] = Math.round(parseFloat(match2[i + 1]) * 2.55);
          }
          if (match2[4]) {
            if (match2[5]) {
              rgb2[3] = parseFloat(match2[4]) * 0.01;
            } else {
              rgb2[3] = parseFloat(match2[4]);
            }
          }
        } else if (match2 = string.match(keyword)) {
          if (match2[1] === "transparent") {
            return [0, 0, 0, 0];
          }
          if (!hasOwnProperty3.call(colorNames, match2[1])) {
            return null;
          }
          rgb2 = colorNames[match2[1]];
          rgb2[3] = 1;
          return rgb2;
        } else {
          return null;
        }
        for (i = 0; i < 3; i++) {
          rgb2[i] = clamp7(rgb2[i], 0, 255);
        }
        rgb2[3] = clamp7(rgb2[3], 0, 1);
        return rgb2;
      };
      cs.get.hsl = function(string) {
        if (!string) {
          return null;
        }
        var hsl2 = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
        var match2 = string.match(hsl2);
        if (match2) {
          var alpha = parseFloat(match2[4]);
          var h = (parseFloat(match2[1]) % 360 + 360) % 360;
          var s2 = clamp7(parseFloat(match2[2]), 0, 100);
          var l2 = clamp7(parseFloat(match2[3]), 0, 100);
          var a3 = clamp7(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h, s2, l2, a3];
        }
        return null;
      };
      cs.get.hwb = function(string) {
        if (!string) {
          return null;
        }
        var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
        var match2 = string.match(hwb);
        if (match2) {
          var alpha = parseFloat(match2[4]);
          var h = (parseFloat(match2[1]) % 360 + 360) % 360;
          var w = clamp7(parseFloat(match2[2]), 0, 100);
          var b = clamp7(parseFloat(match2[3]), 0, 100);
          var a3 = clamp7(isNaN(alpha) ? 1 : alpha, 0, 1);
          return [h, w, b, a3];
        }
        return null;
      };
      cs.to.hex = function() {
        var rgba2 = swizzle(arguments);
        return "#" + hexDouble(rgba2[0]) + hexDouble(rgba2[1]) + hexDouble(rgba2[2]) + (rgba2[3] < 1 ? hexDouble(Math.round(rgba2[3] * 255)) : "");
      };
      cs.to.rgb = function() {
        var rgba2 = swizzle(arguments);
        return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ")" : "rgba(" + Math.round(rgba2[0]) + ", " + Math.round(rgba2[1]) + ", " + Math.round(rgba2[2]) + ", " + rgba2[3] + ")";
      };
      cs.to.rgb.percent = function() {
        var rgba2 = swizzle(arguments);
        var r = Math.round(rgba2[0] / 255 * 100);
        var g = Math.round(rgba2[1] / 255 * 100);
        var b = Math.round(rgba2[2] / 255 * 100);
        return rgba2.length < 4 || rgba2[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba2[3] + ")";
      };
      cs.to.hsl = function() {
        var hsla2 = swizzle(arguments);
        return hsla2.length < 4 || hsla2[3] === 1 ? "hsl(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%)" : "hsla(" + hsla2[0] + ", " + hsla2[1] + "%, " + hsla2[2] + "%, " + hsla2[3] + ")";
      };
      cs.to.hwb = function() {
        var hwba = swizzle(arguments);
        var a3 = "";
        if (hwba.length >= 4 && hwba[3] !== 1) {
          a3 = ", " + hwba[3];
        }
        return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a3 + ")";
      };
      cs.to.keyword = function(rgb2) {
        return reverseNames[rgb2.slice(0, 3)];
      };
      function clamp7(num, min10, max10) {
        return Math.min(Math.max(min10, num), max10);
      }
      function hexDouble(num) {
        var str7 = Math.round(num).toString(16).toUpperCase();
        return str7.length < 2 ? "0" + str7 : str7;
      }
    }
  });

  // ../../engine/rails_design/node_modules/eventemitter3/index.js
  var require_eventemitter3 = __commonJS({
    "../../engine/rails_design/node_modules/eventemitter3/index.js"(exports, module) {
      "use strict";
      var has = Object.prototype.hasOwnProperty;
      var prefix = "~";
      function Events() {
      }
      if (Object.create) {
        Events.prototype = /* @__PURE__ */ Object.create(null);
        if (!new Events().__proto__) prefix = false;
      }
      function EE(fn, context, once) {
        this.fn = fn;
        this.context = context;
        this.once = once || false;
      }
      function addListener(emitter, event, fn, context, once) {
        if (typeof fn !== "function") {
          throw new TypeError("The listener must be a function");
        }
        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
        if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
        else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
        else emitter._events[evt] = [emitter._events[evt], listener];
        return emitter;
      }
      function clearEvent(emitter, evt) {
        if (--emitter._eventsCount === 0) emitter._events = new Events();
        else delete emitter._events[evt];
      }
      function EventEmitter3() {
        this._events = new Events();
        this._eventsCount = 0;
      }
      EventEmitter3.prototype.eventNames = function eventNames() {
        var names = [], events, name2;
        if (this._eventsCount === 0) return names;
        for (name2 in events = this._events) {
          if (has.call(events, name2)) names.push(prefix ? name2.slice(1) : name2);
        }
        if (Object.getOwnPropertySymbols) {
          return names.concat(Object.getOwnPropertySymbols(events));
        }
        return names;
      };
      EventEmitter3.prototype.listeners = function listeners(event) {
        var evt = prefix ? prefix + event : event, handlers = this._events[evt];
        if (!handlers) return [];
        if (handlers.fn) return [handlers.fn];
        for (var i = 0, l2 = handlers.length, ee = new Array(l2); i < l2; i++) {
          ee[i] = handlers[i].fn;
        }
        return ee;
      };
      EventEmitter3.prototype.listenerCount = function listenerCount(event) {
        var evt = prefix ? prefix + event : event, listeners = this._events[evt];
        if (!listeners) return 0;
        if (listeners.fn) return 1;
        return listeners.length;
      };
      EventEmitter3.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return false;
        var listeners = this._events[evt], len5 = arguments.length, args, i;
        if (listeners.fn) {
          if (listeners.once) this.removeListener(event, listeners.fn, void 0, true);
          switch (len5) {
            case 1:
              return listeners.fn.call(listeners.context), true;
            case 2:
              return listeners.fn.call(listeners.context, a1), true;
            case 3:
              return listeners.fn.call(listeners.context, a1, a22), true;
            case 4:
              return listeners.fn.call(listeners.context, a1, a22, a3), true;
            case 5:
              return listeners.fn.call(listeners.context, a1, a22, a3, a4), true;
            case 6:
              return listeners.fn.call(listeners.context, a1, a22, a3, a4, a5), true;
          }
          for (i = 1, args = new Array(len5 - 1); i < len5; i++) {
            args[i - 1] = arguments[i];
          }
          listeners.fn.apply(listeners.context, args);
        } else {
          var length5 = listeners.length, j;
          for (i = 0; i < length5; i++) {
            if (listeners[i].once) this.removeListener(event, listeners[i].fn, void 0, true);
            switch (len5) {
              case 1:
                listeners[i].fn.call(listeners[i].context);
                break;
              case 2:
                listeners[i].fn.call(listeners[i].context, a1);
                break;
              case 3:
                listeners[i].fn.call(listeners[i].context, a1, a22);
                break;
              case 4:
                listeners[i].fn.call(listeners[i].context, a1, a22, a3);
                break;
              default:
                if (!args) for (j = 1, args = new Array(len5 - 1); j < len5; j++) {
                  args[j - 1] = arguments[j];
                }
                listeners[i].fn.apply(listeners[i].context, args);
            }
          }
        }
        return true;
      };
      EventEmitter3.prototype.on = function on2(event, fn, context) {
        return addListener(this, event, fn, context, false);
      };
      EventEmitter3.prototype.once = function once(event, fn, context) {
        return addListener(this, event, fn, context, true);
      };
      EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
        var evt = prefix ? prefix + event : event;
        if (!this._events[evt]) return this;
        if (!fn) {
          clearEvent(this, evt);
          return this;
        }
        var listeners = this._events[evt];
        if (listeners.fn) {
          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
            clearEvent(this, evt);
          }
        } else {
          for (var i = 0, events = [], length5 = listeners.length; i < length5; i++) {
            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
              events.push(listeners[i]);
            }
          }
          if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
          else clearEvent(this, evt);
        }
        return this;
      };
      EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
        var evt;
        if (event) {
          evt = prefix ? prefix + event : event;
          if (this._events[evt]) clearEvent(this, evt);
        } else {
          this._events = new Events();
          this._eventsCount = 0;
        }
        return this;
      };
      EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
      EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
      EventEmitter3.prefixed = prefix;
      EventEmitter3.EventEmitter = EventEmitter3;
      if ("undefined" !== typeof module) {
        module.exports = EventEmitter3;
      }
    }
  });

  // ../../engine/rails_design/node_modules/@antv/coord/dist/coordinate.min.js
  var require_coordinate_min = __commonJS({
    "../../engine/rails_design/node_modules/@antv/coord/dist/coordinate.min.js"(exports, module) {
      !function(t, r) {
        "object" == typeof exports && "undefined" != typeof module ? r(exports) : "function" == typeof define && define.amd ? define(["exports"], r) : r((t = "undefined" != typeof globalThis ? globalThis : t || self).Coordinate = {});
      }(exports, function(t) {
        "use strict";
        function x3(t2) {
          var r2 = "function" == typeof Symbol && Symbol.iterator, n3 = r2 && t2[r2], e4 = 0;
          if (n3) return n3.call(t2);
          if (t2 && "number" == typeof t2.length) return { next: function() {
            return { value: (t2 = t2 && e4 >= t2.length ? void 0 : t2) && t2[e4++], done: !t2 };
          } };
          throw new TypeError(r2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }
        function k(t2, r2) {
          var n3 = "function" == typeof Symbol && t2[Symbol.iterator];
          if (!n3) return t2;
          var e4, o2, a4 = n3.call(t2), i2 = [];
          try {
            for (; (void 0 === r2 || 0 < r2--) && !(e4 = a4.next()).done; ) i2.push(e4.value);
          } catch (t3) {
            o2 = { error: t3 };
          } finally {
            try {
              e4 && !e4.done && (n3 = a4.return) && n3.call(a4);
            } finally {
              if (o2) throw o2.error;
            }
          }
          return i2;
        }
        function O(t2, r2, n3) {
          if (n3 || 2 === arguments.length) for (var e4, o2 = 0, a4 = r2.length; o2 < a4; o2++) !e4 && o2 in r2 || ((e4 = e4 || Array.prototype.slice.call(r2, 0, o2))[o2] = r2[o2]);
          return t2.concat(e4 || Array.prototype.slice.call(r2));
        }
        function q(t2) {
          return i(t2, "Function");
        }
        var C3 = {}.toString, i = function(t2, r2) {
          return C3.call(t2) === "[object " + r2 + "]";
        }, W = function(t2) {
          return Array.isArray ? Array.isArray(t2) : i(t2, "Array");
        };
        var B3 = function(t2) {
          if ("object" != typeof (r2 = t2) || null === r2 || !i(t2, "Object")) return false;
          var r2;
          if (null === Object.getPrototypeOf(t2)) return true;
          for (var n3 = t2; null !== Object.getPrototypeOf(n3); ) n3 = Object.getPrototypeOf(n3);
          return Object.getPrototypeOf(t2) === n3;
        }, $ = function(t2) {
          return i(t2, "Number");
        }, z = Object.values ? function(t2) {
          return Object.values(t2);
        } : function(n3) {
          var t2, e4 = [], r2 = n3, o2 = function(t3, r3) {
            q(n3) && "prototype" === r3 || e4.push(t3);
          };
          if (r2) {
            if (W(r2)) for (var a4 = 0, i2 = r2.length; a4 < i2 && false !== o2(r2[a4], a4); a4++) ;
            else if (t2 = typeof r2, null !== r2 && "object" == t2 || "function" == t2) {
              for (var u2 in r2) if (r2.hasOwnProperty(u2) && false === o2(r2[u2], u2)) break;
            }
          }
          return e4;
        }, E2 = 5;
        function r(t2) {
          for (var r2 = [], n3 = 1; n3 < arguments.length; n3++) r2[n3 - 1] = arguments[n3];
          for (var e4 = 0; e4 < r2.length; e4 += 1) !function t3(r3, n4, e6, o2) {
            for (var a4 in e6 = e6 || 0, o2 = o2 || E2, n4) {
              var i2;
              n4.hasOwnProperty(a4) && (null !== (i2 = n4[a4]) && B3(i2) ? (B3(r3[a4]) || (r3[a4] = {}), e6 < o2 ? t3(r3[a4], i2, e6 + 1, o2) : r3[a4] = n4[a4]) : W(i2) ? (r3[a4] = [], r3[a4] = r3[a4].concat(i2)) : void 0 !== i2 && (r3[a4] = i2));
            }
          }(t2, r2[e4]);
          return t2;
        }
        function A5(t2) {
          return t2;
        }
        !function(a4, i2) {
          var u2;
          if (q(a4)) return (u2 = function() {
            for (var t2 = [], r2 = 0; r2 < arguments.length; r2++) t2[r2] = arguments[r2];
            var n3, e4 = i2 ? i2.apply(this, t2) : t2[0], o2 = u2.cache;
            return o2.has(e4) ? o2.get(e4) : (n3 = a4.apply(this, t2), o2.set(e4, n3), n3);
          }).cache = /* @__PURE__ */ new Map();
          throw new TypeError("Expected a function");
        }(function(t2, r2) {
          var n3 = (r2 = void 0 === r2 ? {} : r2).fontSize, e4 = r2.fontFamily, o2 = r2.fontWeight, a4 = r2.fontStyle, r2 = r2.fontVariant;
          return (u = u || document.createElement("canvas").getContext("2d")).font = [a4, r2, o2, n3 + "px", e4].join(" "), u.measureText(i(t2, "String") ? t2 : "").width;
        }, function(t2, r2) {
          return function() {
            for (var t3 = 0, r3 = 0, n3 = arguments.length; r3 < n3; r3++) t3 += arguments[r3].length;
            for (var e4 = Array(t3), o2 = 0, r3 = 0; r3 < n3; r3++) for (var a4 = arguments[r3], i2 = 0, u2 = a4.length; i2 < u2; i2++, o2++) e4[o2] = a4[i2];
            return e4;
          }([t2], z(r2 = void 0 === r2 ? {} : r2)).join("");
        });
        var u, P = "undefined" != typeof Float32Array ? Float32Array : Array;
        function g() {
          var t2 = new P(9);
          return P != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[5] = 0, t2[6] = 0, t2[7] = 0), t2[0] = 1, t2[4] = 1, t2[8] = 1, t2;
        }
        Math.hypot || (Math.hypot = function() {
          for (var t2 = 0, r2 = arguments.length; r2--; ) t2 += arguments[r2] * arguments[r2];
          return Math.sqrt(t2);
        });
        var J = function(t2, r2, n3) {
          var e4 = r2[0], o2 = r2[1], a4 = r2[2], i2 = r2[3], u2 = r2[4], s3 = r2[5], l3 = r2[6], h2 = r2[7], r2 = r2[8], c6 = n3[0], p3 = n3[1], f2 = n3[2], d3 = n3[3], g2 = n3[4], v2 = n3[5], m4 = n3[6], y4 = n3[7], n3 = n3[8];
          return t2[0] = c6 * e4 + p3 * i2 + f2 * l3, t2[1] = c6 * o2 + p3 * u2 + f2 * h2, t2[2] = c6 * a4 + p3 * s3 + f2 * r2, t2[3] = d3 * e4 + g2 * i2 + v2 * l3, t2[4] = d3 * o2 + g2 * u2 + v2 * h2, t2[5] = d3 * a4 + g2 * s3 + v2 * r2, t2[6] = m4 * e4 + y4 * i2 + n3 * l3, t2[7] = m4 * o2 + y4 * u2 + n3 * h2, t2[8] = m4 * a4 + y4 * s3 + n3 * r2, t2;
        };
        function R() {
          var t2 = new P(16);
          return P != Float32Array && (t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 0, t2[9] = 0, t2[11] = 0, t2[12] = 0, t2[13] = 0, t2[14] = 0), t2[0] = 1, t2[5] = 1, t2[10] = 1, t2[15] = 1, t2;
        }
        var L = function(t2, r2, n3) {
          var e4 = r2[0], o2 = r2[1], a4 = r2[2], i2 = r2[3], u2 = r2[4], s3 = r2[5], l3 = r2[6], h2 = r2[7], c6 = r2[8], p3 = r2[9], f2 = r2[10], d3 = r2[11], g2 = r2[12], v2 = r2[13], m4 = r2[14], r2 = r2[15], y4 = n3[0], M3 = n3[1], w2 = n3[2], b2 = n3[3];
          return t2[0] = y4 * e4 + M3 * u2 + w2 * c6 + b2 * g2, t2[1] = y4 * o2 + M3 * s3 + w2 * p3 + b2 * v2, t2[2] = y4 * a4 + M3 * l3 + w2 * f2 + b2 * m4, t2[3] = y4 * i2 + M3 * h2 + w2 * d3 + b2 * r2, y4 = n3[4], M3 = n3[5], w2 = n3[6], b2 = n3[7], t2[4] = y4 * e4 + M3 * u2 + w2 * c6 + b2 * g2, t2[5] = y4 * o2 + M3 * s3 + w2 * p3 + b2 * v2, t2[6] = y4 * a4 + M3 * l3 + w2 * f2 + b2 * m4, t2[7] = y4 * i2 + M3 * h2 + w2 * d3 + b2 * r2, y4 = n3[8], M3 = n3[9], w2 = n3[10], b2 = n3[11], t2[8] = y4 * e4 + M3 * u2 + w2 * c6 + b2 * g2, t2[9] = y4 * o2 + M3 * s3 + w2 * p3 + b2 * v2, t2[10] = y4 * a4 + M3 * l3 + w2 * f2 + b2 * m4, t2[11] = y4 * i2 + M3 * h2 + w2 * d3 + b2 * r2, y4 = n3[12], M3 = n3[13], w2 = n3[14], b2 = n3[15], t2[12] = y4 * e4 + M3 * u2 + w2 * c6 + b2 * g2, t2[13] = y4 * o2 + M3 * s3 + w2 * p3 + b2 * v2, t2[14] = y4 * a4 + M3 * l3 + w2 * f2 + b2 * m4, t2[15] = y4 * i2 + M3 * h2 + w2 * d3 + b2 * r2, t2;
        };
        function U(t2) {
          for (var r2 = [], n3 = 1; n3 < arguments.length; n3++) r2[n3 - 1] = arguments[n3];
          return t2 ? r2.reduce(function(r3, n4) {
            return function(t3) {
              return n4(r3(t3));
            };
          }, t2) : A5;
        }
        function _2(t2) {
          return t2 instanceof Float32Array || t2 instanceof Array;
        }
        function V(t2, r2, n3) {
          for (; t2 < r2; ) t2 += 2 * Math.PI;
          for (; n3 < t2; ) t2 -= 2 * Math.PI;
          return t2;
        }
        e3 = new P(3), P != Float32Array && (e3[0] = 0, e3[1] = 0, e3[2] = 0), e3 = new P(4), P != Float32Array && (e3[0] = 0, e3[1] = 0, e3[2] = 0, e3[3] = 0);
        function G(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 2))[0], t2 = t2[1], i2 = g();
          return a4 = [a4, t2], (t2 = i2)[0] = 1, t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = 1, t2[5] = 0, t2[6] = a4[0], t2[7] = a4[1], t2[8] = 1, t2;
        }
        function l2(t2, ...r2) {
          return r2.reduce((r3, n3) => (t3) => r3(n3(t3)), t2);
        }
        function h(r2, n3) {
          return n3 - r2 ? (t2) => (t2 - r2) / (n3 - r2) : (t2) => 0.5;
        }
        const H = Math.sqrt(50), Q = Math.sqrt(10), X = Math.sqrt(2);
        function s2(t2, r2, n3) {
          r2 = (r2 - t2) / Math.max(0, n3), t2 = Math.floor(Math.log(r2) / Math.LN10), n3 = r2 / 10 ** t2;
          return 0 <= t2 ? (n3 >= H ? 10 : n3 >= Q ? 5 : n3 >= X ? 2 : 1) * 10 ** t2 : -(10 ** -t2) / (n3 >= H ? 10 : n3 >= Q ? 5 : n3 >= X ? 2 : 1);
        }
        const Y = (t2, r2, n3 = 5) => {
          t2 = [t2, r2];
          let e4 = 0, o2 = t2.length - 1, a4 = t2[e4], i2 = t2[o2], u2;
          return i2 < a4 && ([a4, i2] = [i2, a4], [e4, o2] = [o2, e4]), 0 < (u2 = s2(a4, i2, n3)) ? (a4 = Math.floor(a4 / u2) * u2, i2 = Math.ceil(i2 / u2) * u2, u2 = s2(a4, i2, n3)) : u2 < 0 && (a4 = Math.ceil(a4 * u2) / u2, i2 = Math.floor(i2 * u2) / u2, u2 = s2(a4, i2, n3)), 0 < u2 ? (t2[e4] = Math.floor(a4 / u2) * u2, t2[o2] = Math.ceil(i2 / u2) * u2) : u2 < 0 && (t2[e4] = Math.ceil(a4 * u2) / u2, t2[o2] = Math.floor(i2 * u2) / u2), t2;
        };
        function Z(t2) {
          return null != t2 && !Number.isNaN(t2);
        }
        function tt(r2, i2) {
          return (t2) => {
            t2.prototype.rescale = function() {
              this.initRange(), this.nice();
              var [t3] = this.chooseTransforms();
              this.composeOutput(t3, this.chooseClamp(t3));
            }, t2.prototype.initRange = function() {
              var t3 = this.options["interpolator"];
              this.options.range = r2(t3);
            }, t2.prototype.composeOutput = function(t3, r3) {
              var n3, { domain: e4, interpolator: o2, round: a4 } = this.getOptions(), e4 = i2(e4.map(t3)), a4 = a4 ? (n3 = o2, (t4) => {
                t4 = n3(t4);
                return $(t4) ? Math.round(t4) : t4;
              }) : o2;
              this.output = l2(a4, e4, r3, t3);
            }, t2.prototype.invert = void 0;
          };
        }
        var n2, e3 = { exports: {} }, o = { exports: {} }, rt = function(t2) {
          return !(!t2 || "string" == typeof t2) && (t2 instanceof Array || Array.isArray(t2) || 0 <= t2.length && (t2.splice instanceof Function || Object.getOwnPropertyDescriptor(t2, t2.length - 1) && "String" !== t2.constructor.name));
        }, nt = Array.prototype.concat, et = Array.prototype.slice, ot = o.exports = function(t2) {
          for (var r2 = [], n3 = 0, e4 = t2.length; n3 < e4; n3++) {
            var o2 = t2[n3];
            rt(o2) ? r2 = nt.call(r2, et.call(o2)) : r2.push(o2);
          }
          return r2;
        }, c5 = (ot.wrap = function(t2) {
          return function() {
            return t2(ot(arguments));
          };
        }, { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] }), a3 = o.exports, at = Object.hasOwnProperty, it = /* @__PURE__ */ Object.create(null);
        for (n2 in c5) at.call(c5, n2) && (it[c5[n2]] = n2);
        var p2 = e3.exports = { to: {}, get: {} };
        function f(t2, r2, n3) {
          return Math.min(Math.max(r2, t2), n3);
        }
        function d2(t2) {
          t2 = Math.round(t2).toString(16).toUpperCase();
          return t2.length < 2 ? "0" + t2 : t2;
        }
        p2.get = function(t2) {
          var r2, n3;
          switch (t2.substring(0, 3).toLowerCase()) {
            case "hsl":
              r2 = p2.get.hsl(t2), n3 = "hsl";
              break;
            case "hwb":
              r2 = p2.get.hwb(t2), n3 = "hwb";
              break;
            default:
              r2 = p2.get.rgb(t2), n3 = "rgb";
          }
          return r2 ? { model: n3, value: r2 } : null;
        }, p2.get.rgb = function(t2) {
          if (!t2) return null;
          var r2, n3, e4, o2 = [0, 0, 0, 1];
          if (r2 = t2.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i)) {
            for (e4 = r2[2], r2 = r2[1], n3 = 0; n3 < 3; n3++) {
              var a4 = 2 * n3;
              o2[n3] = parseInt(r2.slice(a4, 2 + a4), 16);
            }
            e4 && (o2[3] = parseInt(e4, 16) / 255);
          } else if (r2 = t2.match(/^#([a-f0-9]{3,4})$/i)) {
            for (e4 = (r2 = r2[1])[3], n3 = 0; n3 < 3; n3++) o2[n3] = parseInt(r2[n3] + r2[n3], 16);
            e4 && (o2[3] = parseInt(e4 + e4, 16) / 255);
          } else {
            if (r2 = t2.match(/^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/)) for (n3 = 0; n3 < 3; n3++) o2[n3] = parseInt(r2[n3 + 1], 0);
            else {
              if (!(r2 = t2.match(/^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/))) return (r2 = t2.match(/^(\w+)$/)) ? "transparent" === r2[1] ? [0, 0, 0, 0] : at.call(c5, r2[1]) ? ((o2 = c5[r2[1]])[3] = 1, o2) : null : null;
              for (n3 = 0; n3 < 3; n3++) o2[n3] = Math.round(2.55 * parseFloat(r2[n3 + 1]));
            }
            r2[4] && (r2[5] ? o2[3] = 0.01 * parseFloat(r2[4]) : o2[3] = parseFloat(r2[4]));
          }
          for (n3 = 0; n3 < 3; n3++) o2[n3] = f(o2[n3], 0, 255);
          return o2[3] = f(o2[3], 0, 1), o2;
        }, p2.get.hsl = function(t2) {
          var r2;
          return (t2 = t2 && t2.match(/^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/)) ? (r2 = parseFloat(t2[4]), [(parseFloat(t2[1]) % 360 + 360) % 360, f(parseFloat(t2[2]), 0, 100), f(parseFloat(t2[3]), 0, 100), f(isNaN(r2) ? 1 : r2, 0, 1)]) : null;
        }, p2.get.hwb = function(t2) {
          var r2;
          return (t2 = t2 && t2.match(/^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/)) ? (r2 = parseFloat(t2[4]), [(parseFloat(t2[1]) % 360 + 360) % 360, f(parseFloat(t2[2]), 0, 100), f(parseFloat(t2[3]), 0, 100), f(isNaN(r2) ? 1 : r2, 0, 1)]) : null;
        }, p2.to.hex = function() {
          var t2 = a3(arguments);
          return "#" + d2(t2[0]) + d2(t2[1]) + d2(t2[2]) + (t2[3] < 1 ? d2(Math.round(255 * t2[3])) : "");
        }, p2.to.rgb = function() {
          var t2 = a3(arguments);
          return t2.length < 4 || 1 === t2[3] ? "rgb(" + Math.round(t2[0]) + ", " + Math.round(t2[1]) + ", " + Math.round(t2[2]) + ")" : "rgba(" + Math.round(t2[0]) + ", " + Math.round(t2[1]) + ", " + Math.round(t2[2]) + ", " + t2[3] + ")";
        }, p2.to.rgb.percent = function() {
          var t2 = a3(arguments), r2 = Math.round(t2[0] / 255 * 100), n3 = Math.round(t2[1] / 255 * 100), e4 = Math.round(t2[2] / 255 * 100);
          return t2.length < 4 || 1 === t2[3] ? "rgb(" + r2 + "%, " + n3 + "%, " + e4 + "%)" : "rgba(" + r2 + "%, " + n3 + "%, " + e4 + "%, " + t2[3] + ")";
        }, p2.to.hsl = function() {
          var t2 = a3(arguments);
          return t2.length < 4 || 1 === t2[3] ? "hsl(" + t2[0] + ", " + t2[1] + "%, " + t2[2] + "%)" : "hsla(" + t2[0] + ", " + t2[1] + "%, " + t2[2] + "%, " + t2[3] + ")";
        }, p2.to.hwb = function() {
          var t2 = a3(arguments), r2 = "";
          return 4 <= t2.length && 1 !== t2[3] && (r2 = ", " + t2[3]), "hwb(" + t2[0] + ", " + t2[1] + "%, " + t2[2] + "%" + r2 + ")";
        }, p2.to.keyword = function(t2) {
          return it[t2.slice(0, 3)];
        };
        var ut = e3.exports;
        function v(t2, r2, n3) {
          let e4 = n3;
          return e4 < 0 && (e4 += 1), 1 < e4 && --e4, e4 < 1 / 6 ? t2 + 6 * (r2 - t2) * e4 : e4 < 0.5 ? r2 : e4 < 2 / 3 ? t2 + (r2 - t2) * (2 / 3 - e4) * 6 : t2;
        }
        function st(t2) {
          var r2, n3, e4, t2 = ut.get(t2);
          return t2 ? ({ model: t2, value: r2 } = t2, "rgb" === t2 ? r2 : "hsl" === t2 ? (r2 = (t2 = r2)[0] / 360, n3 = t2[1] / 100, e4 = t2[2] / 100, t2 = t2[3], 0 == n3 ? [255 * e4, 255 * e4, 255 * e4, t2] : [255 * v(n3 = 2 * e4 - (e4 = e4 < 0.5 ? e4 * (1 + n3) : e4 + n3 - e4 * n3), e4, r2 + 1 / 3), 255 * v(n3, e4, r2), 255 * v(n3, e4, r2 - 1 / 3), t2]) : null) : null;
        }
        const m3 = (r2, n3) => (t2) => r2 * (1 - t2) + n3 * t2, lt = (t2, r2) => {
          if ("number" == typeof t2 && "number" == typeof r2) return m3(t2, r2);
          if ("string" != typeof t2 || "string" != typeof r2) return () => t2;
          {
            var n3 = t2, e4 = r2;
            const s3 = st(n3), l3 = st(e4);
            return null === s3 || null === l3 ? s3 ? () => n3 : () => e4 : (r3) => {
              var n4 = new Array(4);
              for (let t4 = 0; t4 < 4; t4 += 1) {
                var e6 = s3[t4], o2 = l3[t4];
                n4[t4] = e6 * (1 - r3) + o2 * r3;
              }
              var [t3, a4, i2, u2] = n4;
              return `rgba(${Math.round(t3)}, ${Math.round(a4)}, ${Math.round(i2)}, ${u2})`;
            };
          }
        }, ht = (t2, r2) => {
          const n3 = m3(t2, r2);
          return (t3) => Math.round(n3(t3));
        };
        function ct({ map: t2, initKey: r2 }, n3) {
          r2 = r2(n3);
          return t2.has(r2) ? t2.get(r2) : n3;
        }
        function pt(t2) {
          return "object" == typeof t2 ? t2.valueOf() : t2;
        }
        class ft extends Map {
          constructor(t2) {
            if (super(), this.map = /* @__PURE__ */ new Map(), this.initKey = pt, null !== t2) for (var [r2, n3] of t2) this.set(r2, n3);
          }
          get(t2) {
            return super.get(ct({ map: this.map, initKey: this.initKey }, t2));
          }
          has(t2) {
            return super.has(ct({ map: this.map, initKey: this.initKey }, t2));
          }
          set(t2, r2) {
            return super.set(([{ map: t2, initKey: n3 }, e4] = [{ map: this.map, initKey: this.initKey }, t2], n3 = n3(e4), t2.has(n3) ? t2.get(n3) : (t2.set(n3, e4), e4)), r2);
            var n3, e4;
          }
          delete(t2) {
            return super.delete(([{ map: t2, initKey: r2 }, n3] = [{ map: this.map, initKey: this.initKey }, t2], r2 = r2(n3), t2.has(r2) && (n3 = t2.get(r2), t2.delete(r2)), n3));
            var r2, n3;
          }
        }
        class dt {
          constructor(t2) {
            this.options = r({}, this.getDefaultOptions()), this.update(t2);
          }
          getOptions() {
            return this.options;
          }
          update(t2 = {}) {
            this.options = r({}, this.options, t2), this.rescale(t2);
          }
          rescale(t2) {
          }
        }
        const y3 = Symbol("defaultUnknown");
        function gt(r2, n3, e4) {
          for (let t2 = 0; t2 < n3.length; t2 += 1) r2.has(n3[t2]) || r2.set(e4(n3[t2]), t2);
        }
        function vt(t2) {
          var { value: t2, from: r2, to: n3, mapper: e4, notFoundReturn: o2 } = t2;
          let a4 = e4.get(t2);
          if (void 0 === a4) {
            if (o2 !== y3) return o2;
            a4 = r2.push(t2) - 1, e4.set(t2, a4);
          }
          return n3[a4 % n3.length];
        }
        function mt(t2) {
          return t2 instanceof Date ? (t3) => "" + t3 : "object" == typeof t2 ? (t3) => JSON.stringify(t3) : (t3) => t3;
        }
        class yt extends dt {
          getDefaultOptions() {
            return { domain: [], range: [], unknown: y3 };
          }
          constructor(t2) {
            super(t2);
          }
          map(t2) {
            return 0 === this.domainIndexMap.size && gt(this.domainIndexMap, this.getDomain(), this.domainKey), vt({ value: this.domainKey(t2), mapper: this.domainIndexMap, from: this.getDomain(), to: this.getRange(), notFoundReturn: this.options.unknown });
          }
          invert(t2) {
            return 0 === this.rangeIndexMap.size && gt(this.rangeIndexMap, this.getRange(), this.rangeKey), vt({ value: this.rangeKey(t2), mapper: this.rangeIndexMap, from: this.getRange(), to: this.getDomain(), notFoundReturn: this.options.unknown });
          }
          rescale(t2) {
            var [r2] = this.options.domain, [n3] = this.options.range;
            this.domainKey = mt(r2), this.rangeKey = mt(n3), this.rangeIndexMap ? (t2 && !t2.range || this.rangeIndexMap.clear(), t2 && !t2.domain && !t2.compare || (this.domainIndexMap.clear(), this.sortedDomain = void 0)) : (this.rangeIndexMap = /* @__PURE__ */ new Map(), this.domainIndexMap = /* @__PURE__ */ new Map());
          }
          clone() {
            return new yt(this.options);
          }
          getRange() {
            return this.options.range;
          }
          getDomain() {
            var t2, r2;
            return this.sortedDomain || ({ domain: t2, compare: r2 } = this.options, this.sortedDomain = r2 ? [...t2].sort(r2) : t2), this.sortedDomain;
          }
        }
        function Mt(t2) {
          const { domain: r2, range: n3, paddingOuter: e4, paddingInner: o2, flex: a4, round: i2, align: u2 } = t2;
          var s3 = r2.length, l3 = 0 < (l3 = (t2 = s3) - (h2 = a4).length) ? [...h2, ...new Array(l3).fill(1)] : l3 < 0 ? h2.slice(0, t2) : h2, [t2, h2] = n3, h2 = h2 - t2, c6 = h2 / (2 / s3 * e4 + 1 - 1 / s3 * o2);
          const p3 = c6 * o2 / s3;
          c6 -= s3 * p3;
          const f2 = function(t3) {
            const r3 = Math.min(...t3);
            return t3.map((t4) => t4 / r3);
          }(l3), d3 = c6 / f2.reduce((t3, r3) => t3 + r3);
          var l3 = new ft(r2.map((t3, r3) => {
            r3 = f2[r3] * d3;
            return [t3, i2 ? Math.floor(r3) : r3];
          })), g2 = new ft(r2.map((t3, r3) => {
            r3 = f2[r3] * d3 + p3;
            return [t3, i2 ? Math.floor(r3) : r3];
          })), c6 = Array.from(g2.values()).reduce((t3, r3) => t3 + r3), t2 = t2 + (h2 - (c6 - c6 / s3 * o2)) * u2;
          let v2 = i2 ? Math.round(t2) : t2;
          var m4 = new Array(s3);
          for (let t3 = 0; t3 < s3; t3 += 1) {
            m4[t3] = (y4 = v2, Math.round(1e12 * y4) / 1e12);
            var y4 = r2[t3];
            v2 += g2.get(y4);
          }
          return { valueBandWidth: l3, valueStep: g2, adjustedRange: m4 };
        }
        class wt extends yt {
          getDefaultOptions() {
            return { domain: [], range: [0, 1], align: 0.5, round: false, paddingInner: 0, paddingOuter: 0, padding: 0, unknown: y3, flex: [] };
          }
          constructor(t2) {
            super(t2);
          }
          clone() {
            return new wt(this.options);
          }
          getStep(t2) {
            return void 0 === this.valueStep ? 1 : "number" == typeof this.valueStep ? this.valueStep : void 0 === t2 ? Array.from(this.valueStep.values())[0] : this.valueStep.get(t2);
          }
          getBandWidth(t2) {
            return void 0 === this.valueBandWidth ? 1 : "number" == typeof this.valueBandWidth ? this.valueBandWidth : void 0 === t2 ? Array.from(this.valueBandWidth.values())[0] : this.valueBandWidth.get(t2);
          }
          getRange() {
            return this.adjustedRange;
          }
          getPaddingInner() {
            var { padding: t2, paddingInner: r2 } = this.options;
            return 0 < t2 ? t2 : r2;
          }
          getPaddingOuter() {
            var { padding: t2, paddingOuter: r2 } = this.options;
            return 0 < t2 ? t2 : r2;
          }
          rescale() {
            super.rescale();
            var { align: t2, domain: r2, range: n3, round: e4, flex: o2 } = this.options, { adjustedRange: t2, valueBandWidth: n3, valueStep: e4 } = function(t3) {
              var r3 = t3["domain"];
              if (0 === (r3 = r3.length)) return { valueBandWidth: void 0, valueStep: void 0, adjustedRange: [] };
              if (!(null == (n4 = t3.flex) || !n4.length)) return Mt(t3);
              var { range: n4, paddingOuter: t3, paddingInner: e6, round: o3, align: a4 } = t3;
              let i2, u2, s3 = n4[0];
              return n4 = n4[1] - s3, i2 = n4 / Math.max(1, 2 * t3 + (r3 - e6)), o3 && (i2 = Math.floor(i2)), s3 += (n4 - i2 * (r3 - e6)) * a4, u2 = i2 * (1 - e6), o3 && (s3 = Math.round(s3), u2 = Math.round(u2)), t3 = new Array(r3).fill(0).map((t4, r4) => s3 + r4 * i2), { valueStep: i2, valueBandWidth: u2, adjustedRange: t3 };
            }({ align: t2, range: n3, round: e4, flex: o2, paddingInner: this.getPaddingInner(), paddingOuter: this.getPaddingOuter(), domain: r2 });
            this.valueStep = e4, this.valueBandWidth = n3, this.adjustedRange = t2;
          }
        }
        const M2 = (t2, r2, n3) => {
          let e4, o2, a4 = t2, i2 = r2;
          if (a4 === i2 && 0 < n3) return [a4];
          let u2 = s2(a4, i2, n3);
          if (0 === u2 || !Number.isFinite(u2)) return [];
          if (0 < u2) {
            a4 = Math.ceil(a4 / u2), i2 = Math.floor(i2 / u2), o2 = new Array(e4 = Math.ceil(i2 - a4 + 1));
            for (let t3 = 0; t3 < e4; t3 += 1) o2[t3] = (a4 + t3) * u2;
          } else {
            u2 = -u2, a4 = Math.ceil(a4 * u2), i2 = Math.floor(i2 * u2), o2 = new Array(e4 = Math.ceil(i2 - a4 + 1));
            for (let t3 = 0; t3 < e4; t3 += 1) o2[t3] = (a4 + t3) / u2;
          }
          return o2;
        }, bt = (t2, r2, n3) => {
          var [t2, e4] = t2, [r2, o2] = r2;
          let a4, i2;
          return l2(i2 = t2 < e4 ? (a4 = h(t2, e4), n3(r2, o2)) : (a4 = h(e4, t2), n3(o2, r2)), a4);
        }, xt = (e4, t2, r2) => {
          const o2 = Math.min(e4.length, t2.length) - 1, a4 = new Array(o2), i2 = new Array(o2);
          var n3 = e4[0] > e4[o2], u2 = n3 ? [...e4].reverse() : e4, s3 = n3 ? [...t2].reverse() : t2;
          for (let t3 = 0; t3 < o2; t3 += 1) a4[t3] = h(u2[t3], u2[t3 + 1]), i2[t3] = r2(s3[t3], s3[t3 + 1]);
          return (t3) => {
            var r3 = function(t4, r4, n5, e6, o3) {
              let a5 = n5 || 0, i3 = e6 || t4.length;
              for (var u3 = o3 || ((t5) => t5); a5 < i3; ) {
                var s4 = Math.floor((a5 + i3) / 2);
                u3(t4[s4]) > r4 ? i3 = s4 : a5 = s4 + 1;
              }
              return a5;
            }(e4, t3, 1, o2) - 1, n4 = a4[r3];
            return l2(i2[r3], n4)(t3);
          };
        }, kt = (t2, r2, n3, e4) => {
          return (2 < Math.min(t2.length, r2.length) ? xt : bt)(t2, r2, e4 ? ht : n3);
        };
        class Ot extends dt {
          getDefaultOptions() {
            return { domain: [0, 1], range: [0, 1], nice: false, clamp: false, round: false, interpolate: m3, tickCount: 5 };
          }
          map(t2) {
            return Z(t2) ? this.output(t2) : this.options.unknown;
          }
          invert(t2) {
            return Z(t2) ? this.input(t2) : this.options.unknown;
          }
          nice() {
            var t2, r2, n3, e4;
            this.options.nice && ([t2, r2, n3, ...e4] = this.getTickMethodOptions(), this.options.domain = this.chooseNice()(t2, r2, n3, ...e4));
          }
          getTicks() {
            var t2 = this.options["tickMethod"], [r2, n3, e4, ...o2] = this.getTickMethodOptions();
            return t2(r2, n3, e4, ...o2);
          }
          getTickMethodOptions() {
            var { domain: t2, tickCount: r2 } = this.options;
            return [t2[0], t2[t2.length - 1], r2];
          }
          chooseNice() {
            return Y;
          }
          rescale() {
            this.nice();
            var [t2, r2] = this.chooseTransforms();
            this.composeOutput(t2, this.chooseClamp(t2)), this.composeInput(t2, r2, this.chooseClamp(r2));
          }
          chooseClamp(t2) {
            var { clamp: r2, range: n3 } = this.options, t2 = this.options.domain.map(t2), n3 = Math.min(t2.length, n3.length);
            if (r2) {
              r2 = t2[0], t2 = t2[n3 - 1];
              const e4 = t2 < r2 ? t2 : r2, o2 = t2 < r2 ? r2 : t2;
              return (t3) => Math.min(Math.max(e4, t3), o2);
            }
            return A5;
          }
          composeOutput(t2, r2) {
            var { domain: n3, range: e4, round: o2, interpolate: a4 } = this.options, n3 = kt(n3.map(t2), e4, a4, o2);
            this.output = l2(n3, r2, t2);
          }
          composeInput(t2, r2, n3) {
            var { domain: e4, range: o2 } = this.options, o2 = kt(o2, e4.map(t2), m3);
            this.input = l2(r2, n3, o2);
          }
        }
        class w extends Ot {
          getDefaultOptions() {
            return { domain: [0, 1], range: [0, 1], unknown: void 0, nice: false, clamp: false, round: false, interpolate: lt, tickMethod: M2, tickCount: 5 };
          }
          chooseTransforms() {
            return [A5, A5];
          }
          clone() {
            return new w(this.options);
          }
        }
        class At extends wt {
          getDefaultOptions() {
            return { domain: [], range: [0, 1], align: 0.5, round: false, padding: 0, unknown: y3, paddingInner: 1, paddingOuter: 0 };
          }
          constructor(t2) {
            super(t2);
          }
          getPaddingInner() {
            return 1;
          }
          clone() {
            return new At(this.options);
          }
          update(t2) {
            super.update(t2);
          }
          getPaddingOuter() {
            return this.options.padding;
          }
        }
        function jt(t2, r2) {
          for (var n3 = [], e4 = 0, o2 = t2.length; e4 < o2; e4++) n3.push(t2[e4].substr(0, r2));
          return n3;
        }
        var b, o = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], e3 = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], j = jt(e3, 3);
        !function(t2) {
          for (var r2 = [], n3 = 1; n3 < arguments.length; n3++) r2[n3 - 1] = arguments[n3];
          for (var e4 = 0, o2 = r2; e4 < o2.length; e4++) {
            var a4, i2 = o2[e4];
            for (a4 in i2) t2[a4] = i2[a4];
          }
        }({}, { dayNamesShort: jt(o, 3), dayNames: o, monthNamesShort: j, monthNames: e3, amPm: ["am", "pm"], DoFn: function(t2) {
          return t2 + ["th", "st", "nd", "rd"][3 < t2 % 10 ? 0 : (t2 - t2 % 10 != 10 ? 1 : 0) * t2 % 10];
        } });
        var I;
        let It = b = class extends w {
          getDefaultOptions() {
            return { domain: [0, 1], unknown: void 0, nice: false, clamp: false, round: false, interpolator: A5, tickMethod: M2, tickCount: 5 };
          }
          constructor(t2) {
            super(t2);
          }
          clone() {
            return new b(this.options);
          }
        };
        It = b = function(t2, r2, n3, e4) {
          var o2, a4 = arguments.length, i2 = a4 < 3 ? r2 : null === e4 ? e4 = Object.getOwnPropertyDescriptor(r2, n3) : e4;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i2 = Reflect.decorate(t2, r2, n3, e4);
          else for (var u2 = t2.length - 1; 0 <= u2; u2--) (o2 = t2[u2]) && (i2 = (a4 < 3 ? o2(i2) : 3 < a4 ? o2(r2, n3, i2) : o2(r2, n3)) || i2);
          return 3 < a4 && i2 && Object.defineProperty(r2, n3, i2), i2;
        }([tt(function(t2) {
          return [t2(0), t2(1)];
        }, (t2) => {
          var [t2, r2] = t2;
          return l2(m3(0, 1), h(t2, r2));
        })], It);
        let St = I = class extends w {
          getDefaultOptions() {
            return { domain: [0, 0.5, 1], unknown: void 0, nice: false, clamp: false, round: false, interpolator: A5, tickMethod: M2, tickCount: 5 };
          }
          constructor(t2) {
            super(t2);
          }
          clone() {
            return new I(this.options);
          }
        };
        St = I = function(t2, r2, n3, e4) {
          var o2, a4 = arguments.length, i2 = a4 < 3 ? r2 : null === e4 ? e4 = Object.getOwnPropertyDescriptor(r2, n3) : e4;
          if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i2 = Reflect.decorate(t2, r2, n3, e4);
          else for (var u2 = t2.length - 1; 0 <= u2; u2--) (o2 = t2[u2]) && (i2 = (a4 < 3 ? o2(i2) : 3 < a4 ? o2(r2, n3, i2) : o2(r2, n3)) || i2);
          return 3 < a4 && i2 && Object.defineProperty(r2, n3, i2), i2;
        }([tt(function(t2) {
          return [t2(0), t2(0.5), t2(1)];
        }, (t2) => {
          const [r2, n3, e4] = t2, o2 = l2(m3(0, 0.5), h(r2, n3)), a4 = l2(m3(0.5, 1), h(n3, e4));
          return (t3) => (r2 > e4 ? t3 < n3 ? a4 : o2 : t3 < n3 ? o2 : a4)(t3);
        })], St);
        function Ft(t2, r2, n3, e4, o2) {
          var a4 = new w({ range: [r2, r2 + e4] }), i2 = new w({ range: [n3, n3 + o2] });
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [a4.map(r3), i2.map(t3)];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [a4.invert(r3), i2.invert(t3)];
          } };
        }
        function Dt(t2, r2, n3, e4, o2) {
          return (0, k(t2, 1)[0])(r2, n3, e4, o2);
        }
        function Pt(t2, r2, n3, e4, o2) {
          return k(t2, 1)[0];
        }
        function Rt(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 4))[0], i2 = t2[1], u2 = t2[2], t2 = t2[3], s3 = new w({ range: [u2, t2] }), l3 = new w({ range: [a4, i2] }), h2 = 1 < (u2 = o2 / e4) ? 1 : u2, c6 = 1 < u2 ? 1 / u2 : 1;
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1], r3 = l3.map(r3), t3 = s3.map(t3);
            return [0.5 * (t3 * Math.cos(r3) * h2) + 0.5, 0.5 * (t3 * Math.sin(r3) * c6) + 0.5];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1], r3 = 2 * (r3 - 0.5) / h2, t3 = 2 * (t3 - 0.5) / c6, n4 = Math.sqrt(Math.pow(r3, 2) + Math.pow(t3, 2)), t3 = V(Math.atan2(t3, r3), a4, i2);
            return [l3.invert(t3), s3.invert(n4)];
          } };
        }
        function Tt(t2, r2, n3, e4, o2) {
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0];
            return [t3[1], r3];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0];
            return [t3[1], r3];
          } };
        }
        function Kt(t2) {
          for (var r2 = [], n3 = 1; n3 < arguments.length; n3++) r2[n3 - 1] = arguments[n3];
          return S.apply(void 0, O([[-1, -1]], k(r2), false));
        }
        function Nt(t2) {
          for (var r2 = [], n3 = 1; n3 < arguments.length; n3++) r2[n3 - 1] = arguments[n3];
          return S.apply(void 0, O([[-1, 1]], k(r2), false));
        }
        function qt(t2) {
          for (var r2 = [], n3 = 1; n3 < arguments.length; n3++) r2[n3 - 1] = arguments[n3];
          return S.apply(void 0, O([[1, -1]], k(r2), false));
        }
        function Ct(t2, r2, n3, e4, o2) {
          var a4, t2 = k(t2, 1)[0], i2 = g();
          return i2 = i2, t2 = t2, a4 = Math.sin(t2), t2 = Math.cos(t2), i2[0] = t2, i2[1] = a4, i2[2] = 0, i2[3] = -a4, i2[4] = t2, i2[5] = 0, i2[6] = 0, i2[7] = 0, i2[8] = 1, i2;
        }
        function Wt(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 4))[0], i2 = t2[1], u2 = t2[2], s3 = (t2[3] - u2) / (+i2 / (2 * Math.PI) + 1), l3 = s3 / (2 * Math.PI), h2 = new w({ range: [u2, u2 + 0.99 * s3] }), c6 = new w({ range: [a4, i2] }), p3 = 1 < (t2 = o2 / e4) ? 1 : t2, f2 = 1 < t2 ? 1 / t2 : 1;
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1], r3 = c6.map(r3), t3 = h2.map(t3);
            return [0.5 * (Math.cos(r3) * (l3 * r3 + t3) * p3) + 0.5, 0.5 * (Math.sin(r3) * (l3 * r3 + t3) * f2) + 0.5];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1], r3 = 2 * (r3 - 0.5) / p3, t3 = 2 * (t3 - 0.5) / f2, n4 = Math.sqrt(Math.pow(r3, 2) + Math.pow(t3, 2)), t3 = V(Math.atan2(t3, r3) + Math.floor(n4 / s3) * Math.PI * 2, a4, i2), r3 = n4 - l3 * t3;
            return [c6.invert(t3), h2.invert(r3)];
          } };
        }
        function Bt(t2, r2, n3, e4, o2) {
          var u2 = (t2 = k(t2, 4))[0], s3 = t2[1], a4 = t2[2], t2 = t2[3], l3 = new w({ range: [a4, t2] });
          return { transform: function(t3) {
            for (var r3 = [], n4 = t3.length, e6 = new At({ domain: new Array(n4).fill(0).map(function(t4, r4) {
              return r4;
            }), range: [u2, s3] }), o3 = 0; o3 < n4; o3++) {
              var a5 = t3[o3], i2 = e6.map(o3), a5 = l3.map(a5);
              r3.push(i2, a5);
            }
            return r3;
          }, untransform: function(t3) {
            for (var r3 = [], n4 = 0; n4 < t3.length; n4 += 2) {
              var e6 = t3[n4 + 1];
              r3.push(l3.invert(e6));
            }
            return r3;
          } };
        }
        var S = function(t2, r2, n3, e4, o2) {
          var t2 = k(t2, 2), a4 = t2[0], t2 = t2[1], i2 = g();
          return a4 = [a4, t2], (t2 = i2)[0] = a4[0], t2[1] = 0, t2[2] = 0, t2[3] = 0, t2[4] = a4[1], t2[5] = 0, t2[6] = 0, t2[7] = 0, t2[8] = 1, t2;
        };
        function $t(t2) {
          return 1 / Math.tan(t2);
        }
        function zt(t2, r2, n3, e4, o2) {
          var a4 = $t(k(t2, 1)[0]);
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [r3 + t3 * a4, t3];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [r3 - t3 * a4, t3];
          } };
        }
        function Et(t2, r2, n3, e4, o2) {
          var a4 = $t(k(t2, 1)[0]);
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0];
            return [r3, t3[1] + r3 * a4];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0];
            return [r3, t3[1] - r3 * a4];
          } };
        }
        function F(t2, r2, n3, e4, o2) {
          var a4 = t2 < r2, o2 = (a4 ? r2 - e4 : o2 - r2) || o2 - e4, e4 = a4 ? -1 : 1;
          return e4 * o2 * (n3 + 1) / (n3 + o2 / ((t2 - r2) * e4)) + r2;
        }
        function D2(t2, r2, n3, e4, o2) {
          var a4 = t2 < r2, o2 = (a4 ? r2 - e4 : o2 - r2) || o2 - e4;
          return o2 / (o2 * (n3 + 1) / (t2 - r2) - n3 * (a4 ? -1 : 1)) + r2;
        }
        function T(t2, r2, n3) {
          return n3 ? new w({ range: [0, 1], domain: [0, r2] }).map(t2) : t2;
        }
        function Jt(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 3))[0], i2 = t2[1], t2 = t2[2], u2 = T(a4, e4, void 0 !== t2 && t2);
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [F(r3, u2, i2, 0, 1), t3];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [D2(r3, u2, i2, 0, 1), t3];
          } };
        }
        function Lt(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 3))[0], i2 = t2[1], t2 = t2[2], u2 = T(a4, o2, void 0 !== t2 && t2);
          return { transform: function(t3) {
            t3 = k(t3, 2);
            return [t3[0], F(t3[1], u2, i2, 0, 1)];
          }, untransform: function(t3) {
            t3 = k(t3, 2);
            return [t3[0], D2(t3[1], u2, i2, 0, 1)];
          } };
        }
        function Ut(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 5))[0], i2 = t2[1], u2 = t2[2], s3 = t2[3], t2 = t2[4], l3 = T(a4, e4, t2 = void 0 !== t2 && t2), h2 = T(i2, o2, t2);
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [F(r3, l3, u2, 0, 1), F(t3, h2, s3, 0, 1)];
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1];
            return [D2(r3, l3, u2, 0, 1), D2(t3, h2, s3, 0, 1)];
          } };
        }
        function _t(t2, r2, n3, e4, o2) {
          var a4 = (t2 = k(t2, 5))[0], i2 = t2[1], u2 = t2[2], s3 = t2[3], t2 = void 0 !== (t2 = t2[4]) && t2, l3 = new w({ range: [0, e4] }), h2 = new w({ range: [0, o2] }), c6 = t2 ? a4 : l3.map(a4), p3 = t2 ? i2 : h2.map(i2);
          return { transform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1], n4 = l3.map(r3) - c6, e6 = h2.map(t3) - p3, o3 = Math.sqrt(n4 * n4 + e6 * e6);
            return u2 < o3 ? [r3, t3] : (r3 = F(o3, 0, s3, 0, u2), t3 = Math.atan2(e6, n4), o3 = c6 + r3 * Math.cos(t3), e6 = p3 + r3 * Math.sin(t3), [l3.invert(o3), h2.invert(e6)]);
          }, untransform: function(t3) {
            var t3 = k(t3, 2), r3 = t3[0], t3 = t3[1], n4 = l3.map(r3) - c6, e6 = h2.map(t3) - p3, o3 = Math.sqrt(n4 * n4 + e6 * e6);
            return u2 < o3 ? [r3, t3] : (r3 = D2(o3, 0, s3, 0, u2), t3 = Math.atan2(e6, n4), o3 = c6 + r3 * Math.cos(t3), e6 = p3 + r3 * Math.sin(t3), [l3.invert(o3), h2.invert(e6)]);
          } };
        }
        function Vt(t2, r2, n3, e4, o2, a4, i2) {
          var u2 = new w({ range: [r2, r2 + o2] }), s3 = new w({ range: [n3, n3 + a4] }), l3 = new w({ range: [e4, e4 + i2] });
          return { transform: function(t3) {
            var t3 = k(t3, 3), r3 = t3[0], n4 = t3[1], t3 = t3[2];
            return [u2.map(r3), s3.map(n4), l3.map(t3)];
          }, untransform: function(t3) {
            var t3 = k(t3, 3), r3 = t3[0], n4 = t3[1], t3 = t3[2];
            return [u2.invert(r3), s3.invert(n4), l3.invert(t3)];
          } };
        }
        function Gt(t2, r2, n3, e4, o2, a4, i2) {
          var u2, s3 = (t2 = k(t2, 3))[0], l3 = t2[1], t2 = t2[2];
          return u2 = R(), s3 = [s3, l3, t2], u2[0] = 1, u2[1] = 0, u2[2] = 0, u2[3] = 0, u2[4] = 0, u2[5] = 1, u2[6] = 0, u2[7] = 0, u2[8] = 0, u2[9] = 0, u2[10] = 1, u2[11] = 0, u2[12] = s3[0], u2[13] = s3[1], u2[14] = s3[2], u2[15] = 1, u2;
        }
        function Ht(t2, r2, n3, e4, o2, a4, i2) {
          return { transform: function(t3) {
            var t3 = k(t3, 3), r3 = t3[0];
            return [t3[1], r3, t3[2]];
          }, untransform: function(t3) {
            var t3 = k(t3, 3), r3 = t3[0];
            return [t3[1], r3, t3[2]];
          } };
        }
        function Qt(t2, r2, n3, e4, o2, a4, i2) {
          var u2, s3 = (t2 = k(t2, 3))[0], l3 = t2[1], t2 = t2[2];
          return u2 = R(), s3 = [s3, l3, t2], u2[0] = s3[0], u2[1] = 0, u2[2] = 0, u2[3] = 0, u2[4] = 0, u2[5] = s3[1], u2[6] = 0, u2[7] = 0, u2[8] = 0, u2[9] = 0, u2[10] = s3[2], u2[11] = 0, u2[12] = 0, u2[13] = 0, u2[14] = 0, u2[15] = 1, u2;
        }
        K.prototype.update = function(t2) {
          this.options = r({}, this.options, t2), this.recoordinate();
        }, K.prototype.clone = function() {
          return new K(this.options);
        }, K.prototype.getOptions = function() {
          return this.options;
        }, K.prototype.clear = function() {
          this.update({ transformations: [] });
        }, K.prototype.getSize = function() {
          var t2 = this.options;
          return [t2.width, t2.height];
        }, K.prototype.getCenter = function() {
          var t2 = this.options, r2 = t2.x, n3 = t2.y;
          return [(2 * r2 + t2.width) / 2, (2 * n3 + t2.height) / 2];
        }, K.prototype.transform = function() {
          for (var t2 = [], r2 = 0; r2 < arguments.length; r2++) t2[r2] = arguments[r2];
          var n3 = this.options.transformations;
          return this.update({ transformations: O(O([], k(n3), false), [O([], k(t2), false)], false) }), this;
        }, K.prototype.map = function(t2) {
          return this.output(t2);
        }, K.prototype.invert = function(t2) {
          return this.input(t2);
        }, K.prototype.recoordinate = function() {
          this.output = this.compose(), this.input = this.compose(true);
        }, K.prototype.compose = function(t2) {
          function r2(t3, r3) {
            var o3;
            u2.push((r3 = void 0 === r3 ? true : r3) ? (o3 = t3, function(t4) {
              for (var r4 = [], n4 = 0; n4 < t4.length - 1; n4 += 2) {
                var e6 = [t4[n4], t4[n4 + 1]], e6 = o3(e6);
                r4.push.apply(r4, O([], k(e6), false));
              }
              return r4;
            }) : t3);
          }
          var n3, e4, o2 = (t2 = void 0 === t2 ? false : t2) ? O([], k(this.options.transformations), false).reverse() : this.options.transformations, a4 = t2 ? function(t3) {
            return t3.untransform;
          } : function(t3) {
            return t3.transform;
          }, i2 = [], u2 = [];
          try {
            for (var s3 = x3(o2), l3 = s3.next(); !l3.done; l3 = s3.next()) {
              var h2, c6, p3, f2, d3, g2, v2 = k(l3.value), m4 = v2[0], y4 = v2.slice(1), M3 = this.transformers[m4];
              M3 && (c6 = (h2 = this.options).x, p3 = h2.y, f2 = h2.width, d3 = h2.height, _2(g2 = M3(O([], k(y4), false), c6, p3, f2, d3)) ? i2.push(g2) : (i2.length && (r2(this.createMatrixTransform(i2, t2)), i2.splice(0, i2.length)), r2(a4(g2) || A5, "parallel" !== m4)));
            }
          } catch (t3) {
            n3 = { error: t3 };
          } finally {
            try {
              l3 && !l3.done && (e4 = s3.return) && e4.call(s3);
            } finally {
              if (n3) throw n3.error;
            }
          }
          return i2.length && r2(this.createMatrixTransform(i2, t2)), U.apply(void 0, O([], k(u2), false));
        }, K.prototype.createMatrixTransform = function(t2, r2) {
          var n3, e4, o2, a4, i2, u2, s3, l3, h2, c6, p3, f2, d3 = g();
          return r2 && t2.reverse(), t2.forEach(function(t3) {
            return J(d3, d3, t3);
          }), r2 && (r2 = t2 = d3, (f2 = new P(9))[0] = r2[0], f2[1] = r2[1], f2[2] = r2[2], f2[3] = r2[3], f2[4] = r2[4], f2[5] = r2[5], f2[6] = r2[6], f2[7] = r2[7], f2[8] = r2[8], f2 = (r2 = f2)[0], n3 = r2[1], e4 = r2[2], o2 = r2[3], a4 = r2[4], i2 = r2[5], u2 = r2[6], s3 = r2[7], l3 = (r2 = r2[8]) * a4 - i2 * s3, p3 = f2 * l3 + n3 * (h2 = -r2 * o2 + i2 * u2) + e4 * (c6 = s3 * o2 - a4 * u2)) && (t2[0] = l3 * (p3 = 1 / p3), t2[1] = (-r2 * n3 + e4 * s3) * p3, t2[2] = (i2 * n3 - e4 * a4) * p3, t2[3] = h2 * p3, t2[4] = (r2 * f2 - e4 * u2) * p3, t2[5] = (-i2 * f2 + e4 * o2) * p3, t2[6] = c6 * p3, t2[7] = (-s3 * f2 + n3 * u2) * p3, t2[8] = (a4 * f2 - n3 * o2) * p3), function(t3) {
            var r3, n4, e6, o3, a5, t3 = [t3[0], t3[1], 1];
            return e6 = d3, o3 = (n4 = r3 = t3)[0], a5 = n4[1], n4 = n4[2], r3[0] = o3 * e6[0] + a5 * e6[3] + n4 * e6[6], r3[1] = o3 * e6[1] + a5 * e6[4] + n4 * e6[7], r3[2] = o3 * e6[2] + a5 * e6[5] + n4 * e6[8], [t3[0], t3[1]];
          };
        };
        o = K;
        function K(t2) {
          this.options = { x: 0, y: 0, width: 300, height: 150, transformations: [] }, this.transformers = { cartesian: Ft, translate: G, custom: Dt, matrix: Pt, polar: Rt, transpose: Tt, scale: S, "shear.x": zt, "shear.y": Et, reflect: Kt, "reflect.x": Nt, "reflect.y": qt, rotate: Ct, helix: Wt, parallel: Bt, fisheye: Ut, "fisheye.x": Jt, "fisheye.y": Lt, "fisheye.circular": _t }, this.update(t2);
        }
        N.prototype.update = function(t2) {
          this.options = r({}, this.options, t2), this.recoordinate();
        }, N.prototype.clone = function() {
          return new N(this.options);
        }, N.prototype.getOptions = function() {
          return this.options;
        }, N.prototype.clear = function() {
          this.update({ transformations: [] });
        }, N.prototype.getSize = function() {
          var t2 = this.options;
          return [t2.width, t2.height, t2.depth];
        }, N.prototype.getCenter = function() {
          var t2 = this.options, r2 = t2.x, n3 = t2.y, e4 = t2.z;
          return [(2 * r2 + t2.width) / 2, (2 * n3 + t2.height) / 2, (2 * e4 + t2.depth) / 2];
        }, N.prototype.transform = function() {
          for (var t2 = [], r2 = 0; r2 < arguments.length; r2++) t2[r2] = arguments[r2];
          var n3 = this.options.transformations;
          return this.update({ transformations: O(O([], k(n3), false), [O([], k(t2), false)], false) }), this;
        }, N.prototype.map = function(t2) {
          return this.output(t2);
        }, N.prototype.invert = function(t2) {
          return this.input(t2);
        }, N.prototype.recoordinate = function() {
          this.output = this.compose(), this.input = this.compose(true);
        }, N.prototype.compose = function(t2) {
          function r2(t3, r3) {
            var o3;
            u2.push((r3 = void 0 === r3 ? true : r3) ? (o3 = t3, function(t4) {
              for (var r4 = [], n4 = 0; n4 < t4.length - 1; n4 += 3) {
                var e6 = [t4[n4], t4[n4 + 1], t4[n4 + 2]], e6 = o3(e6);
                r4.push.apply(r4, O([], k(e6), false));
              }
              return r4;
            }) : t3);
          }
          var n3, e4, o2 = (t2 = void 0 === t2 ? false : t2) ? O([], k(this.options.transformations), false).reverse() : this.options.transformations, a4 = t2 ? function(t3) {
            return t3.untransform;
          } : function(t3) {
            return t3.transform;
          }, i2 = [], u2 = [];
          try {
            for (var s3 = x3(o2), l3 = s3.next(); !l3.done; l3 = s3.next()) {
              var h2, c6, p3, f2, d3, g2, v2, m4, y4 = k(l3.value), M3 = y4[0], w2 = y4.slice(1), b2 = this.transformers[M3];
              b2 && (c6 = (h2 = this.options).x, p3 = h2.y, f2 = h2.z, d3 = h2.width, g2 = h2.height, v2 = h2.depth, _2(m4 = b2(O([], k(w2), false), c6, p3, f2, d3, g2, v2)) ? i2.push(m4) : (i2.length && (r2(this.createMatrixTransform(i2, t2)), i2.splice(0, i2.length)), r2(a4(m4) || A5, true)));
            }
          } catch (t3) {
            n3 = { error: t3 };
          } finally {
            try {
              l3 && !l3.done && (e4 = s3.return) && e4.call(s3);
            } finally {
              if (n3) throw n3.error;
            }
          }
          return i2.length && r2(this.createMatrixTransform(i2, t2)), U.apply(void 0, O([], k(u2), false));
        }, N.prototype.createMatrixTransform = function(t2, r2) {
          var n3, e4, o2, a4, i2, u2, s3, l3, h2, c6, p3, f2, d3, g2, v2, m4, y4, M3, w2, b2, x4, k2, O2, A6, j2, I2, S2, F2, D3 = R();
          return r2 && t2.reverse(), t2.forEach(function(t3) {
            return L(D3, D3, t3);
          }), r2 && (r2 = t2 = D3, (F2 = new P(16))[0] = r2[0], F2[1] = r2[1], F2[2] = r2[2], F2[3] = r2[3], F2[4] = r2[4], F2[5] = r2[5], F2[6] = r2[6], F2[7] = r2[7], F2[8] = r2[8], F2[9] = r2[9], F2[10] = r2[10], F2[11] = r2[11], F2[12] = r2[12], F2[13] = r2[13], F2[14] = r2[14], F2[15] = r2[15], F2 = (r2 = F2)[0], n3 = r2[1], e4 = r2[2], o2 = r2[3], a4 = r2[4], i2 = r2[5], u2 = r2[6], s3 = r2[7], l3 = r2[8], h2 = r2[9], c6 = r2[10], p3 = r2[11], f2 = r2[12], d3 = r2[13], g2 = r2[14], r2 = r2[15], S2 = (v2 = F2 * i2 - n3 * a4) * (I2 = c6 * r2 - p3 * g2) - (m4 = F2 * u2 - e4 * a4) * (j2 = h2 * r2 - p3 * d3) + (y4 = F2 * s3 - o2 * a4) * (A6 = h2 * g2 - c6 * d3) + (M3 = n3 * u2 - e4 * i2) * (O2 = l3 * r2 - p3 * f2) - (w2 = n3 * s3 - o2 * i2) * (k2 = l3 * g2 - c6 * f2) + (b2 = e4 * s3 - o2 * u2) * (x4 = l3 * d3 - h2 * f2)) && (t2[0] = (i2 * I2 - u2 * j2 + s3 * A6) * (S2 = 1 / S2), t2[1] = (e4 * j2 - n3 * I2 - o2 * A6) * S2, t2[2] = (d3 * b2 - g2 * w2 + r2 * M3) * S2, t2[3] = (c6 * w2 - h2 * b2 - p3 * M3) * S2, t2[4] = (u2 * O2 - a4 * I2 - s3 * k2) * S2, t2[5] = (F2 * I2 - e4 * O2 + o2 * k2) * S2, t2[6] = (g2 * y4 - f2 * b2 - r2 * m4) * S2, t2[7] = (l3 * b2 - c6 * y4 + p3 * m4) * S2, t2[8] = (a4 * j2 - i2 * O2 + s3 * x4) * S2, t2[9] = (n3 * O2 - F2 * j2 - o2 * x4) * S2, t2[10] = (f2 * w2 - d3 * y4 + r2 * v2) * S2, t2[11] = (h2 * y4 - l3 * w2 - p3 * v2) * S2, t2[12] = (i2 * k2 - a4 * A6 - u2 * x4) * S2, t2[13] = (F2 * A6 - n3 * k2 + e4 * x4) * S2, t2[14] = (d3 * m4 - f2 * M3 - g2 * v2) * S2, t2[15] = (l3 * M3 - h2 * m4 + c6 * v2) * S2), function(t3) {
            var r3, n4, e6, o3, a5, i3, t3 = [t3[0], t3[1], t3[2], 1];
            return e6 = D3, o3 = (n4 = r3 = t3)[0], a5 = n4[1], i3 = n4[2], n4 = n4[3], r3[0] = e6[0] * o3 + e6[4] * a5 + e6[8] * i3 + e6[12] * n4, r3[1] = e6[1] * o3 + e6[5] * a5 + e6[9] * i3 + e6[13] * n4, r3[2] = e6[2] * o3 + e6[6] * a5 + e6[10] * i3 + e6[14] * n4, r3[3] = e6[3] * o3 + e6[7] * a5 + e6[11] * i3 + e6[15] * n4, [t3[0], t3[1], t3[2]];
          };
        };
        j = N;
        function N(t2) {
          this.options = { x: 0, y: 0, z: 0, width: 300, height: 150, depth: 150, transformations: [] }, this.transformers = { cartesian3D: Vt, translate3D: Gt, scale3D: Qt, transpose3D: Ht }, this.update(t2);
        }
        t.Coordinate = o, t.Coordinate3D = j, Object.defineProperty(t, "__esModule", { value: true });
      });
    }
  });

  // ../../engine/rails_design/node_modules/pdfast/src/helper.js
  var require_helper = __commonJS({
    "../../engine/rails_design/node_modules/pdfast/src/helper.js"(exports, module) {
      "use strict";
      var self2 = module.exports;
      module.exports.isNumber = function(x3) {
        return typeof x3 === "number";
      };
      module.exports.findMin = function(arr) {
        if (arr.length === 0) {
          return Infinity;
        }
        var curr = arr[0];
        for (var i = 1; i < arr.length; i++) {
          curr = Math.min(curr, arr[i]);
        }
        return curr;
      };
      module.exports.findMax = function(arr) {
        if (arr.length === 0) {
          return -Infinity;
        }
        var curr = arr[0];
        for (var i = 1; i < arr.length; i++) {
          curr = Math.max(curr, arr[i]);
        }
        return curr;
      };
      module.exports.findMinMulti = function(arr) {
        var curr = self2.findMin(arr[0]);
        for (var i = 1; i < arr.length; i++) {
          curr = Math.min(curr, self2.findMin(arr[i]));
        }
        return curr;
      };
      module.exports.findMaxMulti = function(arr) {
        var curr = self2.findMax(arr[0]);
        for (var i = 1; i < arr.length; i++) {
          curr = Math.max(curr, self2.findMax(arr[i]));
        }
        return curr;
      };
      module.exports.inside = function(min10, max10, x3) {
        return min10 <= x3 && x3 <= max10;
      };
    }
  });

  // ../../engine/rails_design/node_modules/pdfast/src/index.js
  var require_src = __commonJS({
    "../../engine/rails_design/node_modules/pdfast/src/index.js"(exports, module) {
      "use strict";
      var DEFAULT_SIZE = 50;
      var DEFAULT_WIDTH = 2;
      var LN_2 = Math.log(2);
      var self2 = module.exports;
      var helper = require_helper();
      function kernel(x3) {
        return 1 - Math.abs(x3);
      }
      module.exports.getUnifiedMinMax = function(arr, options) {
        return self2.getUnifiedMinMaxMulti([arr], options);
      };
      module.exports.getUnifiedMinMaxMulti = function(arrMulti, options) {
        options = options || {};
        var relaxMin = false;
        var relaxMax = false;
        var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
        var size2 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
        var min10 = helper.isNumber(options.min) ? options.min : (relaxMin = true, helper.findMinMulti(arrMulti));
        var max10 = helper.isNumber(options.max) ? options.max : (relaxMax = true, helper.findMaxMulti(arrMulti));
        var range3 = max10 - min10;
        var step2 = range3 / (size2 - 1);
        if (relaxMin) {
          min10 = min10 - 2 * width * step2;
        }
        if (relaxMax) {
          max10 = max10 + 2 * width * step2;
        }
        return {
          min: min10,
          max: max10
        };
      };
      module.exports.create = function(arr, options) {
        options = options || {};
        if (!arr || arr.length === 0) {
          return [];
        }
        var size2 = helper.isNumber(options.size) ? options.size : DEFAULT_SIZE;
        var width = helper.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
        var normalizedMinMax = self2.getUnifiedMinMax(arr, {
          size: size2,
          width,
          min: options.min,
          max: options.max
        });
        var min10 = normalizedMinMax.min;
        var max10 = normalizedMinMax.max;
        var range3 = max10 - min10;
        var step2 = range3 / (size2 - 1);
        if (range3 === 0) {
          return [{ x: min10, y: 1 }];
        }
        var buckets = [];
        for (var i = 0; i < size2; i++) {
          buckets.push({
            x: min10 + i * step2,
            y: 0
          });
        }
        var xToBucket = function(x3) {
          return Math.floor((x3 - min10) / step2);
        };
        var partialArea = generatePartialAreas(kernel, width);
        var fullArea = partialArea[width];
        var c5 = partialArea[width - 1] - partialArea[width - 2];
        var initalValue = 0;
        arr.forEach(function(x3) {
          var bucket = xToBucket(x3);
          if (bucket + width < 0 || bucket - width >= buckets.length) {
            return;
          }
          var start2 = Math.max(bucket - width, 0);
          var mid2 = bucket;
          var end = Math.min(bucket + width, buckets.length - 1);
          var leftBlockCount = start2 - (bucket - width);
          var rightBlockCount = bucket + width - end;
          var spilledAreaLeft = partialArea[-width - 1 + leftBlockCount] || 0;
          var spilledAreaRight = partialArea[-width - 1 + rightBlockCount] || 0;
          var weight2 = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);
          if (leftBlockCount > 0) {
            initalValue += weight2 * (leftBlockCount - 1) * c5;
          }
          var startGradPos = Math.max(0, bucket - width + 1);
          if (helper.inside(0, buckets.length - 1, startGradPos)) {
            buckets[startGradPos].y += weight2 * 1 * c5;
          }
          if (helper.inside(0, buckets.length - 1, mid2 + 1)) {
            buckets[mid2 + 1].y -= weight2 * 2 * c5;
          }
          if (helper.inside(0, buckets.length - 1, end + 1)) {
            buckets[end + 1].y += weight2 * 1 * c5;
          }
        });
        var accumulator = initalValue;
        var gradAccumulator = 0;
        var area2 = 0;
        buckets.forEach(function(bucket) {
          gradAccumulator += bucket.y;
          accumulator += gradAccumulator;
          bucket.y = accumulator;
          area2 += accumulator;
        });
        if (area2 > 0) {
          buckets.forEach(function(bucket) {
            bucket.y /= area2;
          });
        }
        return buckets;
      };
      function generatePartialAreas(kernel2, width) {
        var partialAreas = {};
        var accumulator = 0;
        for (var i = -width; i <= width; i++) {
          accumulator += kernel2(i / width);
          partialAreas[i] = accumulator;
        }
        return partialAreas;
      }
      module.exports.getExpectedValueFromPdf = function(pdf2) {
        if (!pdf2 || pdf2.length === 0) {
          return void 0;
        }
        var expected = 0;
        pdf2.forEach(function(obj) {
          expected += obj.x * obj.y;
        });
        return expected;
      };
      module.exports.getXWithLeftTailArea = function(pdf2, area2) {
        if (!pdf2 || pdf2.length === 0) {
          return void 0;
        }
        var accumulator = 0;
        var last4 = 0;
        for (var i = 0; i < pdf2.length; i++) {
          last4 = i;
          accumulator += pdf2[i].y;
          if (accumulator >= area2) {
            break;
          }
        }
        return pdf2[last4].x;
      };
      module.exports.getPerplexity = function(pdf2) {
        if (!pdf2 || pdf2.length === 0) {
          return void 0;
        }
        var entropy = 0;
        pdf2.forEach(function(obj) {
          var ln2 = Math.log(obj.y);
          if (isFinite(ln2)) {
            entropy += obj.y * ln2;
          }
        });
        entropy = -entropy / LN_2;
        return Math.pow(2, entropy);
      };
    }
  });

  // ../../engine/rails_design/node_modules/fmin/build/fmin.js
  var require_fmin = __commonJS({
    "../../engine/rails_design/node_modules/fmin/build/fmin.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.fmin = global2.fmin || {});
      })(exports, function(exports2) {
        "use strict";
        function bisect4(f, a3, b, parameters) {
          parameters = parameters || {};
          var maxIterations = parameters.maxIterations || 100, tolerance2 = parameters.tolerance || 1e-10, fA = f(a3), fB = f(b), delta = b - a3;
          if (fA * fB > 0) {
            throw "Initial bisect points must have opposite signs";
          }
          if (fA === 0) return a3;
          if (fB === 0) return b;
          for (var i = 0; i < maxIterations; ++i) {
            delta /= 2;
            var mid2 = a3 + delta, fMid = f(mid2);
            if (fMid * fA >= 0) {
              a3 = mid2;
            }
            if (Math.abs(delta) < tolerance2 || fMid === 0) {
              return mid2;
            }
          }
          return a3 + delta;
        }
        function zeros2(x3) {
          var r = new Array(x3);
          for (var i = 0; i < x3; ++i) {
            r[i] = 0;
          }
          return r;
        }
        function zerosM2(x3, y3) {
          return zeros2(x3).map(function() {
            return zeros2(y3);
          });
        }
        function dot8(a3, b) {
          var ret = 0;
          for (var i = 0; i < a3.length; ++i) {
            ret += a3[i] * b[i];
          }
          return ret;
        }
        function norm22(a3) {
          return Math.sqrt(dot8(a3, a3));
        }
        function scale9(ret, value2, c5) {
          for (var i = 0; i < value2.length; ++i) {
            ret[i] = value2[i] * c5;
          }
        }
        function weightedSum(ret, w1, v1, w2, v2) {
          for (var j = 0; j < ret.length; ++j) {
            ret[j] = w1 * v1[j] + w2 * v2[j];
          }
        }
        function nelderMead2(f, x05, parameters) {
          parameters = parameters || {};
          var maxIterations = parameters.maxIterations || x05.length * 200, nonZeroDelta = parameters.nonZeroDelta || 1.05, zeroDelta = parameters.zeroDelta || 1e-3, minErrorDelta = parameters.minErrorDelta || 1e-6, minTolerance = parameters.minErrorDelta || 1e-5, rho = parameters.rho !== void 0 ? parameters.rho : 1, chi = parameters.chi !== void 0 ? parameters.chi : 2, psi = parameters.psi !== void 0 ? parameters.psi : -0.5, sigma = parameters.sigma !== void 0 ? parameters.sigma : 0.5, maxDiff;
          var N = x05.length, simplex = new Array(N + 1);
          simplex[0] = x05;
          simplex[0].fx = f(x05);
          simplex[0].id = 0;
          for (var i = 0; i < N; ++i) {
            var point6 = x05.slice();
            point6[i] = point6[i] ? point6[i] * nonZeroDelta : zeroDelta;
            simplex[i + 1] = point6;
            simplex[i + 1].fx = f(point6);
            simplex[i + 1].id = i + 1;
          }
          function updateSimplex(value2) {
            for (var i2 = 0; i2 < value2.length; i2++) {
              simplex[N][i2] = value2[i2];
            }
            simplex[N].fx = value2.fx;
          }
          var sortOrder = function(a3, b) {
            return a3.fx - b.fx;
          };
          var centroid = x05.slice(), reflected = x05.slice(), contracted = x05.slice(), expanded = x05.slice();
          for (var iteration = 0; iteration < maxIterations; ++iteration) {
            simplex.sort(sortOrder);
            if (parameters.history) {
              var sortedSimplex = simplex.map(function(x3) {
                var state = x3.slice();
                state.fx = x3.fx;
                state.id = x3.id;
                return state;
              });
              sortedSimplex.sort(function(a3, b) {
                return a3.id - b.id;
              });
              parameters.history.push({
                x: simplex[0].slice(),
                fx: simplex[0].fx,
                simplex: sortedSimplex
              });
            }
            maxDiff = 0;
            for (i = 0; i < N; ++i) {
              maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
            }
            if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {
              break;
            }
            for (i = 0; i < N; ++i) {
              centroid[i] = 0;
              for (var j = 0; j < N; ++j) {
                centroid[i] += simplex[j][i];
              }
              centroid[i] /= N;
            }
            var worst = simplex[N];
            weightedSum(reflected, 1 + rho, centroid, -rho, worst);
            reflected.fx = f(reflected);
            if (reflected.fx < simplex[0].fx) {
              weightedSum(expanded, 1 + chi, centroid, -chi, worst);
              expanded.fx = f(expanded);
              if (expanded.fx < reflected.fx) {
                updateSimplex(expanded);
              } else {
                updateSimplex(reflected);
              }
            } else if (reflected.fx >= simplex[N - 1].fx) {
              var shouldReduce = false;
              if (reflected.fx > worst.fx) {
                weightedSum(contracted, 1 + psi, centroid, -psi, worst);
                contracted.fx = f(contracted);
                if (contracted.fx < worst.fx) {
                  updateSimplex(contracted);
                } else {
                  shouldReduce = true;
                }
              } else {
                weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);
                contracted.fx = f(contracted);
                if (contracted.fx < reflected.fx) {
                  updateSimplex(contracted);
                } else {
                  shouldReduce = true;
                }
              }
              if (shouldReduce) {
                if (sigma >= 1) break;
                for (i = 1; i < simplex.length; ++i) {
                  weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
                  simplex[i].fx = f(simplex[i]);
                }
              }
            } else {
              updateSimplex(reflected);
            }
          }
          simplex.sort(sortOrder);
          return {
            fx: simplex[0].fx,
            x: simplex[0]
          };
        }
        function wolfeLineSearch(f, pk, current, next, a3, c1, c22) {
          var phi0 = current.fx, phiPrime0 = dot8(current.fxprime, pk), phi2 = phi0, phi_old = phi0, phiPrime = phiPrime0, a0 = 0;
          a3 = a3 || 1;
          c1 = c1 || 1e-6;
          c22 = c22 || 0.1;
          function zoom(a_lo, a_high, phi_lo) {
            for (var iteration2 = 0; iteration2 < 16; ++iteration2) {
              a3 = (a_lo + a_high) / 2;
              weightedSum(next.x, 1, current.x, a3, pk);
              phi2 = next.fx = f(next.x, next.fxprime);
              phiPrime = dot8(next.fxprime, pk);
              if (phi2 > phi0 + c1 * a3 * phiPrime0 || phi2 >= phi_lo) {
                a_high = a3;
              } else {
                if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
                  return a3;
                }
                if (phiPrime * (a_high - a_lo) >= 0) {
                  a_high = a_lo;
                }
                a_lo = a3;
                phi_lo = phi2;
              }
            }
            return 0;
          }
          for (var iteration = 0; iteration < 10; ++iteration) {
            weightedSum(next.x, 1, current.x, a3, pk);
            phi2 = next.fx = f(next.x, next.fxprime);
            phiPrime = dot8(next.fxprime, pk);
            if (phi2 > phi0 + c1 * a3 * phiPrime0 || iteration && phi2 >= phi_old) {
              return zoom(a0, a3, phi_old);
            }
            if (Math.abs(phiPrime) <= -c22 * phiPrime0) {
              return a3;
            }
            if (phiPrime >= 0) {
              return zoom(a3, a0, phi2);
            }
            phi_old = phi2;
            a0 = a3;
            a3 *= 2;
          }
          return a3;
        }
        function conjugateGradient2(f, initial, params) {
          var current = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, next = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, yk = initial.slice(), pk, temp, a3 = 1, maxIterations;
          params = params || {};
          maxIterations = params.maxIterations || initial.length * 20;
          current.fx = f(current.x, current.fxprime);
          pk = current.fxprime.slice();
          scale9(pk, current.fxprime, -1);
          for (var i = 0; i < maxIterations; ++i) {
            a3 = wolfeLineSearch(f, pk, current, next, a3);
            if (params.history) {
              params.history.push({
                x: current.x.slice(),
                fx: current.fx,
                fxprime: current.fxprime.slice(),
                alpha: a3
              });
            }
            if (!a3) {
              scale9(pk, current.fxprime, -1);
            } else {
              weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
              var delta_k = dot8(current.fxprime, current.fxprime), beta_k = Math.max(0, dot8(yk, next.fxprime) / delta_k);
              weightedSum(pk, beta_k, pk, -1, next.fxprime);
              temp = current;
              current = next;
              next = temp;
            }
            if (norm22(current.fxprime) <= 1e-5) {
              break;
            }
          }
          if (params.history) {
            params.history.push({
              x: current.x.slice(),
              fx: current.fx,
              fxprime: current.fxprime.slice(),
              alpha: a3
            });
          }
          return current;
        }
        function gradientDescent(f, initial, params) {
          params = params || {};
          var maxIterations = params.maxIterations || initial.length * 100, learnRate = params.learnRate || 1e-3, current = { x: initial.slice(), fx: 0, fxprime: initial.slice() };
          for (var i = 0; i < maxIterations; ++i) {
            current.fx = f(current.x, current.fxprime);
            if (params.history) {
              params.history.push({
                x: current.x.slice(),
                fx: current.fx,
                fxprime: current.fxprime.slice()
              });
            }
            weightedSum(current.x, 1, current.x, -learnRate, current.fxprime);
            if (norm22(current.fxprime) <= 1e-5) {
              break;
            }
          }
          return current;
        }
        function gradientDescentLineSearch(f, initial, params) {
          params = params || {};
          var current = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, next = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, maxIterations = params.maxIterations || initial.length * 100, learnRate = params.learnRate || 1, pk = initial.slice(), c1 = params.c1 || 1e-3, c22 = params.c2 || 0.1, temp, functionCalls = [];
          if (params.history) {
            var inner = f;
            f = function(x3, fxprime) {
              functionCalls.push(x3.slice());
              return inner(x3, fxprime);
            };
          }
          current.fx = f(current.x, current.fxprime);
          for (var i = 0; i < maxIterations; ++i) {
            scale9(pk, current.fxprime, -1);
            learnRate = wolfeLineSearch(f, pk, current, next, learnRate, c1, c22);
            if (params.history) {
              params.history.push({
                x: current.x.slice(),
                fx: current.fx,
                fxprime: current.fxprime.slice(),
                functionCalls,
                learnRate,
                alpha: learnRate
              });
              functionCalls = [];
            }
            temp = current;
            current = next;
            next = temp;
            if (learnRate === 0 || norm22(current.fxprime) < 1e-5) break;
          }
          return current;
        }
        exports2.bisect = bisect4;
        exports2.nelderMead = nelderMead2;
        exports2.conjugateGradient = conjugateGradient2;
        exports2.gradientDescent = gradientDescent;
        exports2.gradientDescentLineSearch = gradientDescentLineSearch;
        exports2.zeros = zeros2;
        exports2.zerosM = zerosM2;
        exports2.norm2 = norm22;
        exports2.weightedSum = weightedSum;
        exports2.scale = scale9;
      });
    }
  });

  // ../../engine/rails_design/node_modules/spark-md5/spark-md5.js
  var require_spark_md5 = __commonJS({
    "../../engine/rails_design/node_modules/spark-md5/spark-md5.js"(exports, module) {
      (function(factory) {
        if (typeof exports === "object") {
          module.exports = factory();
        } else if (typeof define === "function" && define.amd) {
          define(factory);
        } else {
          var glob;
          try {
            glob = window;
          } catch (e3) {
            glob = self;
          }
          glob.SparkMD5 = factory();
        }
      })(function(undefined2) {
        "use strict";
        var add32 = function(a3, b) {
          return a3 + b & 4294967295;
        }, hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
        function cmn(q, a3, b, x3, s2, t) {
          a3 = add32(add32(a3, q), add32(x3, t));
          return add32(a3 << s2 | a3 >>> 32 - s2, b);
        }
        function md5cycle(x3, k) {
          var a3 = x3[0], b = x3[1], c5 = x3[2], d2 = x3[3];
          a3 += (b & c5 | ~b & d2) + k[0] - 680876936 | 0;
          a3 = (a3 << 7 | a3 >>> 25) + b | 0;
          d2 += (a3 & b | ~a3 & c5) + k[1] - 389564586 | 0;
          d2 = (d2 << 12 | d2 >>> 20) + a3 | 0;
          c5 += (d2 & a3 | ~d2 & b) + k[2] + 606105819 | 0;
          c5 = (c5 << 17 | c5 >>> 15) + d2 | 0;
          b += (c5 & d2 | ~c5 & a3) + k[3] - 1044525330 | 0;
          b = (b << 22 | b >>> 10) + c5 | 0;
          a3 += (b & c5 | ~b & d2) + k[4] - 176418897 | 0;
          a3 = (a3 << 7 | a3 >>> 25) + b | 0;
          d2 += (a3 & b | ~a3 & c5) + k[5] + 1200080426 | 0;
          d2 = (d2 << 12 | d2 >>> 20) + a3 | 0;
          c5 += (d2 & a3 | ~d2 & b) + k[6] - 1473231341 | 0;
          c5 = (c5 << 17 | c5 >>> 15) + d2 | 0;
          b += (c5 & d2 | ~c5 & a3) + k[7] - 45705983 | 0;
          b = (b << 22 | b >>> 10) + c5 | 0;
          a3 += (b & c5 | ~b & d2) + k[8] + 1770035416 | 0;
          a3 = (a3 << 7 | a3 >>> 25) + b | 0;
          d2 += (a3 & b | ~a3 & c5) + k[9] - 1958414417 | 0;
          d2 = (d2 << 12 | d2 >>> 20) + a3 | 0;
          c5 += (d2 & a3 | ~d2 & b) + k[10] - 42063 | 0;
          c5 = (c5 << 17 | c5 >>> 15) + d2 | 0;
          b += (c5 & d2 | ~c5 & a3) + k[11] - 1990404162 | 0;
          b = (b << 22 | b >>> 10) + c5 | 0;
          a3 += (b & c5 | ~b & d2) + k[12] + 1804603682 | 0;
          a3 = (a3 << 7 | a3 >>> 25) + b | 0;
          d2 += (a3 & b | ~a3 & c5) + k[13] - 40341101 | 0;
          d2 = (d2 << 12 | d2 >>> 20) + a3 | 0;
          c5 += (d2 & a3 | ~d2 & b) + k[14] - 1502002290 | 0;
          c5 = (c5 << 17 | c5 >>> 15) + d2 | 0;
          b += (c5 & d2 | ~c5 & a3) + k[15] + 1236535329 | 0;
          b = (b << 22 | b >>> 10) + c5 | 0;
          a3 += (b & d2 | c5 & ~d2) + k[1] - 165796510 | 0;
          a3 = (a3 << 5 | a3 >>> 27) + b | 0;
          d2 += (a3 & c5 | b & ~c5) + k[6] - 1069501632 | 0;
          d2 = (d2 << 9 | d2 >>> 23) + a3 | 0;
          c5 += (d2 & b | a3 & ~b) + k[11] + 643717713 | 0;
          c5 = (c5 << 14 | c5 >>> 18) + d2 | 0;
          b += (c5 & a3 | d2 & ~a3) + k[0] - 373897302 | 0;
          b = (b << 20 | b >>> 12) + c5 | 0;
          a3 += (b & d2 | c5 & ~d2) + k[5] - 701558691 | 0;
          a3 = (a3 << 5 | a3 >>> 27) + b | 0;
          d2 += (a3 & c5 | b & ~c5) + k[10] + 38016083 | 0;
          d2 = (d2 << 9 | d2 >>> 23) + a3 | 0;
          c5 += (d2 & b | a3 & ~b) + k[15] - 660478335 | 0;
          c5 = (c5 << 14 | c5 >>> 18) + d2 | 0;
          b += (c5 & a3 | d2 & ~a3) + k[4] - 405537848 | 0;
          b = (b << 20 | b >>> 12) + c5 | 0;
          a3 += (b & d2 | c5 & ~d2) + k[9] + 568446438 | 0;
          a3 = (a3 << 5 | a3 >>> 27) + b | 0;
          d2 += (a3 & c5 | b & ~c5) + k[14] - 1019803690 | 0;
          d2 = (d2 << 9 | d2 >>> 23) + a3 | 0;
          c5 += (d2 & b | a3 & ~b) + k[3] - 187363961 | 0;
          c5 = (c5 << 14 | c5 >>> 18) + d2 | 0;
          b += (c5 & a3 | d2 & ~a3) + k[8] + 1163531501 | 0;
          b = (b << 20 | b >>> 12) + c5 | 0;
          a3 += (b & d2 | c5 & ~d2) + k[13] - 1444681467 | 0;
          a3 = (a3 << 5 | a3 >>> 27) + b | 0;
          d2 += (a3 & c5 | b & ~c5) + k[2] - 51403784 | 0;
          d2 = (d2 << 9 | d2 >>> 23) + a3 | 0;
          c5 += (d2 & b | a3 & ~b) + k[7] + 1735328473 | 0;
          c5 = (c5 << 14 | c5 >>> 18) + d2 | 0;
          b += (c5 & a3 | d2 & ~a3) + k[12] - 1926607734 | 0;
          b = (b << 20 | b >>> 12) + c5 | 0;
          a3 += (b ^ c5 ^ d2) + k[5] - 378558 | 0;
          a3 = (a3 << 4 | a3 >>> 28) + b | 0;
          d2 += (a3 ^ b ^ c5) + k[8] - 2022574463 | 0;
          d2 = (d2 << 11 | d2 >>> 21) + a3 | 0;
          c5 += (d2 ^ a3 ^ b) + k[11] + 1839030562 | 0;
          c5 = (c5 << 16 | c5 >>> 16) + d2 | 0;
          b += (c5 ^ d2 ^ a3) + k[14] - 35309556 | 0;
          b = (b << 23 | b >>> 9) + c5 | 0;
          a3 += (b ^ c5 ^ d2) + k[1] - 1530992060 | 0;
          a3 = (a3 << 4 | a3 >>> 28) + b | 0;
          d2 += (a3 ^ b ^ c5) + k[4] + 1272893353 | 0;
          d2 = (d2 << 11 | d2 >>> 21) + a3 | 0;
          c5 += (d2 ^ a3 ^ b) + k[7] - 155497632 | 0;
          c5 = (c5 << 16 | c5 >>> 16) + d2 | 0;
          b += (c5 ^ d2 ^ a3) + k[10] - 1094730640 | 0;
          b = (b << 23 | b >>> 9) + c5 | 0;
          a3 += (b ^ c5 ^ d2) + k[13] + 681279174 | 0;
          a3 = (a3 << 4 | a3 >>> 28) + b | 0;
          d2 += (a3 ^ b ^ c5) + k[0] - 358537222 | 0;
          d2 = (d2 << 11 | d2 >>> 21) + a3 | 0;
          c5 += (d2 ^ a3 ^ b) + k[3] - 722521979 | 0;
          c5 = (c5 << 16 | c5 >>> 16) + d2 | 0;
          b += (c5 ^ d2 ^ a3) + k[6] + 76029189 | 0;
          b = (b << 23 | b >>> 9) + c5 | 0;
          a3 += (b ^ c5 ^ d2) + k[9] - 640364487 | 0;
          a3 = (a3 << 4 | a3 >>> 28) + b | 0;
          d2 += (a3 ^ b ^ c5) + k[12] - 421815835 | 0;
          d2 = (d2 << 11 | d2 >>> 21) + a3 | 0;
          c5 += (d2 ^ a3 ^ b) + k[15] + 530742520 | 0;
          c5 = (c5 << 16 | c5 >>> 16) + d2 | 0;
          b += (c5 ^ d2 ^ a3) + k[2] - 995338651 | 0;
          b = (b << 23 | b >>> 9) + c5 | 0;
          a3 += (c5 ^ (b | ~d2)) + k[0] - 198630844 | 0;
          a3 = (a3 << 6 | a3 >>> 26) + b | 0;
          d2 += (b ^ (a3 | ~c5)) + k[7] + 1126891415 | 0;
          d2 = (d2 << 10 | d2 >>> 22) + a3 | 0;
          c5 += (a3 ^ (d2 | ~b)) + k[14] - 1416354905 | 0;
          c5 = (c5 << 15 | c5 >>> 17) + d2 | 0;
          b += (d2 ^ (c5 | ~a3)) + k[5] - 57434055 | 0;
          b = (b << 21 | b >>> 11) + c5 | 0;
          a3 += (c5 ^ (b | ~d2)) + k[12] + 1700485571 | 0;
          a3 = (a3 << 6 | a3 >>> 26) + b | 0;
          d2 += (b ^ (a3 | ~c5)) + k[3] - 1894986606 | 0;
          d2 = (d2 << 10 | d2 >>> 22) + a3 | 0;
          c5 += (a3 ^ (d2 | ~b)) + k[10] - 1051523 | 0;
          c5 = (c5 << 15 | c5 >>> 17) + d2 | 0;
          b += (d2 ^ (c5 | ~a3)) + k[1] - 2054922799 | 0;
          b = (b << 21 | b >>> 11) + c5 | 0;
          a3 += (c5 ^ (b | ~d2)) + k[8] + 1873313359 | 0;
          a3 = (a3 << 6 | a3 >>> 26) + b | 0;
          d2 += (b ^ (a3 | ~c5)) + k[15] - 30611744 | 0;
          d2 = (d2 << 10 | d2 >>> 22) + a3 | 0;
          c5 += (a3 ^ (d2 | ~b)) + k[6] - 1560198380 | 0;
          c5 = (c5 << 15 | c5 >>> 17) + d2 | 0;
          b += (d2 ^ (c5 | ~a3)) + k[13] + 1309151649 | 0;
          b = (b << 21 | b >>> 11) + c5 | 0;
          a3 += (c5 ^ (b | ~d2)) + k[4] - 145523070 | 0;
          a3 = (a3 << 6 | a3 >>> 26) + b | 0;
          d2 += (b ^ (a3 | ~c5)) + k[11] - 1120210379 | 0;
          d2 = (d2 << 10 | d2 >>> 22) + a3 | 0;
          c5 += (a3 ^ (d2 | ~b)) + k[2] + 718787259 | 0;
          c5 = (c5 << 15 | c5 >>> 17) + d2 | 0;
          b += (d2 ^ (c5 | ~a3)) + k[9] - 343485551 | 0;
          b = (b << 21 | b >>> 11) + c5 | 0;
          x3[0] = a3 + x3[0] | 0;
          x3[1] = b + x3[1] | 0;
          x3[2] = c5 + x3[2] | 0;
          x3[3] = d2 + x3[3] | 0;
        }
        function md5blk(s2) {
          var md5blks = [], i;
          for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = s2.charCodeAt(i) + (s2.charCodeAt(i + 1) << 8) + (s2.charCodeAt(i + 2) << 16) + (s2.charCodeAt(i + 3) << 24);
          }
          return md5blks;
        }
        function md5blk_array(a3) {
          var md5blks = [], i;
          for (i = 0; i < 64; i += 4) {
            md5blks[i >> 2] = a3[i] + (a3[i + 1] << 8) + (a3[i + 2] << 16) + (a3[i + 3] << 24);
          }
          return md5blks;
        }
        function md51(s2) {
          var n2 = s2.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length5, tail, tmp2, lo, hi;
          for (i = 64; i <= n2; i += 64) {
            md5cycle(state, md5blk(s2.substring(i - 64, i)));
          }
          s2 = s2.substring(i - 64);
          length5 = s2.length;
          tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          for (i = 0; i < length5; i += 1) {
            tail[i >> 2] |= s2.charCodeAt(i) << (i % 4 << 3);
          }
          tail[i >> 2] |= 128 << (i % 4 << 3);
          if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
              tail[i] = 0;
            }
          }
          tmp2 = n2 * 8;
          tmp2 = tmp2.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp2[2], 16);
          hi = parseInt(tmp2[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(state, tail);
          return state;
        }
        function md51_array(a3) {
          var n2 = a3.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length5, tail, tmp2, lo, hi;
          for (i = 64; i <= n2; i += 64) {
            md5cycle(state, md5blk_array(a3.subarray(i - 64, i)));
          }
          a3 = i - 64 < n2 ? a3.subarray(i - 64) : new Uint8Array(0);
          length5 = a3.length;
          tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          for (i = 0; i < length5; i += 1) {
            tail[i >> 2] |= a3[i] << (i % 4 << 3);
          }
          tail[i >> 2] |= 128 << (i % 4 << 3);
          if (i > 55) {
            md5cycle(state, tail);
            for (i = 0; i < 16; i += 1) {
              tail[i] = 0;
            }
          }
          tmp2 = n2 * 8;
          tmp2 = tmp2.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp2[2], 16);
          hi = parseInt(tmp2[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(state, tail);
          return state;
        }
        function rhex(n2) {
          var s2 = "", j;
          for (j = 0; j < 4; j += 1) {
            s2 += hex_chr[n2 >> j * 8 + 4 & 15] + hex_chr[n2 >> j * 8 & 15];
          }
          return s2;
        }
        function hex2(x3) {
          var i;
          for (i = 0; i < x3.length; i += 1) {
            x3[i] = rhex(x3[i]);
          }
          return x3.join("");
        }
        if (hex2(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") {
          add32 = function(x3, y3) {
            var lsw = (x3 & 65535) + (y3 & 65535), msw = (x3 >> 16) + (y3 >> 16) + (lsw >> 16);
            return msw << 16 | lsw & 65535;
          };
        }
        if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
          (function() {
            function clamp7(val, length5) {
              val = val | 0 || 0;
              if (val < 0) {
                return Math.max(val + length5, 0);
              }
              return Math.min(val, length5);
            }
            ArrayBuffer.prototype.slice = function(from, to) {
              var length5 = this.byteLength, begin = clamp7(from, length5), end = length5, num, target, targetArray, sourceArray;
              if (to !== undefined2) {
                end = clamp7(to, length5);
              }
              if (begin > end) {
                return new ArrayBuffer(0);
              }
              num = end - begin;
              target = new ArrayBuffer(num);
              targetArray = new Uint8Array(target);
              sourceArray = new Uint8Array(this, begin, num);
              targetArray.set(sourceArray);
              return target;
            };
          })();
        }
        function toUtf8(str7) {
          if (/[\u0080-\uFFFF]/.test(str7)) {
            str7 = unescape(encodeURIComponent(str7));
          }
          return str7;
        }
        function utf8Str2ArrayBuffer(str7, returnUInt8Array) {
          var length5 = str7.length, buff = new ArrayBuffer(length5), arr = new Uint8Array(buff), i;
          for (i = 0; i < length5; i += 1) {
            arr[i] = str7.charCodeAt(i);
          }
          return returnUInt8Array ? arr : buff;
        }
        function arrayBuffer2Utf8Str(buff) {
          return String.fromCharCode.apply(null, new Uint8Array(buff));
        }
        function concatenateArrayBuffers(first3, second2, returnUInt8Array) {
          var result = new Uint8Array(first3.byteLength + second2.byteLength);
          result.set(new Uint8Array(first3));
          result.set(new Uint8Array(second2), first3.byteLength);
          return returnUInt8Array ? result : result.buffer;
        }
        function hexToBinaryString(hex3) {
          var bytes = [], length5 = hex3.length, x3;
          for (x3 = 0; x3 < length5 - 1; x3 += 2) {
            bytes.push(parseInt(hex3.substr(x3, 2), 16));
          }
          return String.fromCharCode.apply(String, bytes);
        }
        function SparkMD52() {
          this.reset();
        }
        SparkMD52.prototype.append = function(str7) {
          this.appendBinary(toUtf8(str7));
          return this;
        };
        SparkMD52.prototype.appendBinary = function(contents) {
          this._buff += contents;
          this._length += contents.length;
          var length5 = this._buff.length, i;
          for (i = 64; i <= length5; i += 64) {
            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
          }
          this._buff = this._buff.substring(i - 64);
          return this;
        };
        SparkMD52.prototype.end = function(raw) {
          var buff = this._buff, length5 = buff.length, i, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
          for (i = 0; i < length5; i += 1) {
            tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
          }
          this._finish(tail, length5);
          ret = hex2(this._hash);
          if (raw) {
            ret = hexToBinaryString(ret);
          }
          this.reset();
          return ret;
        };
        SparkMD52.prototype.reset = function() {
          this._buff = "";
          this._length = 0;
          this._hash = [1732584193, -271733879, -1732584194, 271733878];
          return this;
        };
        SparkMD52.prototype.getState = function() {
          return {
            buff: this._buff,
            length: this._length,
            hash: this._hash.slice()
          };
        };
        SparkMD52.prototype.setState = function(state) {
          this._buff = state.buff;
          this._length = state.length;
          this._hash = state.hash;
          return this;
        };
        SparkMD52.prototype.destroy = function() {
          delete this._hash;
          delete this._buff;
          delete this._length;
        };
        SparkMD52.prototype._finish = function(tail, length5) {
          var i = length5, tmp2, lo, hi;
          tail[i >> 2] |= 128 << (i % 4 << 3);
          if (i > 55) {
            md5cycle(this._hash, tail);
            for (i = 0; i < 16; i += 1) {
              tail[i] = 0;
            }
          }
          tmp2 = this._length * 8;
          tmp2 = tmp2.toString(16).match(/(.*?)(.{0,8})$/);
          lo = parseInt(tmp2[2], 16);
          hi = parseInt(tmp2[1], 16) || 0;
          tail[14] = lo;
          tail[15] = hi;
          md5cycle(this._hash, tail);
        };
        SparkMD52.hash = function(str7, raw) {
          return SparkMD52.hashBinary(toUtf8(str7), raw);
        };
        SparkMD52.hashBinary = function(content, raw) {
          var hash = md51(content), ret = hex2(hash);
          return raw ? hexToBinaryString(ret) : ret;
        };
        SparkMD52.ArrayBuffer = function() {
          this.reset();
        };
        SparkMD52.ArrayBuffer.prototype.append = function(arr) {
          var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length5 = buff.length, i;
          this._length += arr.byteLength;
          for (i = 64; i <= length5; i += 64) {
            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
          }
          this._buff = i - 64 < length5 ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);
          return this;
        };
        SparkMD52.ArrayBuffer.prototype.end = function(raw) {
          var buff = this._buff, length5 = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i, ret;
          for (i = 0; i < length5; i += 1) {
            tail[i >> 2] |= buff[i] << (i % 4 << 3);
          }
          this._finish(tail, length5);
          ret = hex2(this._hash);
          if (raw) {
            ret = hexToBinaryString(ret);
          }
          this.reset();
          return ret;
        };
        SparkMD52.ArrayBuffer.prototype.reset = function() {
          this._buff = new Uint8Array(0);
          this._length = 0;
          this._hash = [1732584193, -271733879, -1732584194, 271733878];
          return this;
        };
        SparkMD52.ArrayBuffer.prototype.getState = function() {
          var state = SparkMD52.prototype.getState.call(this);
          state.buff = arrayBuffer2Utf8Str(state.buff);
          return state;
        };
        SparkMD52.ArrayBuffer.prototype.setState = function(state) {
          state.buff = utf8Str2ArrayBuffer(state.buff, true);
          return SparkMD52.prototype.setState.call(this, state);
        };
        SparkMD52.ArrayBuffer.prototype.destroy = SparkMD52.prototype.destroy;
        SparkMD52.ArrayBuffer.prototype._finish = SparkMD52.prototype._finish;
        SparkMD52.ArrayBuffer.hash = function(arr, raw) {
          var hash = md51_array(new Uint8Array(arr)), ret = hex2(hash);
          return raw ? hexToBinaryString(ret) : ret;
        };
        return SparkMD52;
      });
    }
  });

  // ../../engine/rails_design/node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js
  var turbo_es2017_esm_exports = {};
  __export(turbo_es2017_esm_exports, {
    FetchEnctype: () => FetchEnctype,
    FetchMethod: () => FetchMethod,
    FetchRequest: () => FetchRequest,
    FetchResponse: () => FetchResponse,
    FrameElement: () => FrameElement,
    FrameLoadingStyle: () => FrameLoadingStyle,
    FrameRenderer: () => FrameRenderer,
    PageRenderer: () => PageRenderer,
    PageSnapshot: () => PageSnapshot,
    StreamActions: () => StreamActions,
    StreamElement: () => StreamElement,
    StreamSourceElement: () => StreamSourceElement,
    cache: () => cache,
    clearCache: () => clearCache,
    config: () => config,
    connectStreamSource: () => connectStreamSource,
    disconnectStreamSource: () => disconnectStreamSource,
    fetch: () => fetchWithTurboHeaders,
    fetchEnctypeFromString: () => fetchEnctypeFromString,
    fetchMethodFromString: () => fetchMethodFromString,
    isSafe: () => isSafe,
    navigator: () => navigator$1,
    registerAdapter: () => registerAdapter,
    renderStreamMessage: () => renderStreamMessage,
    session: () => session,
    setConfirmMethod: () => setConfirmMethod,
    setFormMode: () => setFormMode,
    setProgressBarDelay: () => setProgressBarDelay,
    start: () => start,
    visit: () => visit
  });
  (function(prototype) {
    if (typeof prototype.requestSubmit == "function") return;
    prototype.requestSubmit = function(submitter2) {
      if (submitter2) {
        validateSubmitter(submitter2, this);
        submitter2.click();
      } else {
        submitter2 = document.createElement("input");
        submitter2.type = "submit";
        submitter2.hidden = true;
        this.appendChild(submitter2);
        submitter2.click();
        this.removeChild(submitter2);
      }
    };
    function validateSubmitter(submitter2, form) {
      submitter2 instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
      submitter2.type == "submit" || raise(TypeError, "The specified element is not a submit button");
      submitter2.form == form || raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
    }
    function raise(errorConstructor, message, name2) {
      throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name2);
    }
  })(HTMLFormElement.prototype);
  var submittersByForm = /* @__PURE__ */ new WeakMap();
  function findSubmitterFromClickTarget(target) {
    const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
    const candidate = element ? element.closest("input, button") : null;
    return candidate?.type == "submit" ? candidate : null;
  }
  function clickCaptured(event) {
    const submitter2 = findSubmitterFromClickTarget(event.target);
    if (submitter2 && submitter2.form) {
      submittersByForm.set(submitter2.form, submitter2);
    }
  }
  (function() {
    if ("submitter" in Event.prototype) return;
    let prototype = window.Event.prototype;
    if ("SubmitEvent" in window) {
      const prototypeOfSubmitEvent = window.SubmitEvent.prototype;
      if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
        prototype = prototypeOfSubmitEvent;
      } else {
        return;
      }
    }
    addEventListener("click", clickCaptured, true);
    Object.defineProperty(prototype, "submitter", {
      get() {
        if (this.type == "submit" && this.target instanceof HTMLFormElement) {
          return submittersByForm.get(this.target);
        }
      }
    });
  })();
  var FrameLoadingStyle = {
    eager: "eager",
    lazy: "lazy"
  };
  var FrameElement = class _FrameElement extends HTMLElement {
    static delegateConstructor = void 0;
    loaded = Promise.resolve();
    static get observedAttributes() {
      return ["disabled", "loading", "src"];
    }
    constructor() {
      super();
      this.delegate = new _FrameElement.delegateConstructor(this);
    }
    connectedCallback() {
      this.delegate.connect();
    }
    disconnectedCallback() {
      this.delegate.disconnect();
    }
    reload() {
      return this.delegate.sourceURLReloaded();
    }
    attributeChangedCallback(name2) {
      if (name2 == "loading") {
        this.delegate.loadingStyleChanged();
      } else if (name2 == "src") {
        this.delegate.sourceURLChanged();
      } else if (name2 == "disabled") {
        this.delegate.disabledChanged();
      }
    }
    /**
     * Gets the URL to lazily load source HTML from
     */
    get src() {
      return this.getAttribute("src");
    }
    /**
     * Sets the URL to lazily load source HTML from
     */
    set src(value2) {
      if (value2) {
        this.setAttribute("src", value2);
      } else {
        this.removeAttribute("src");
      }
    }
    /**
     * Gets the refresh mode for the frame.
     */
    get refresh() {
      return this.getAttribute("refresh");
    }
    /**
     * Sets the refresh mode for the frame.
     */
    set refresh(value2) {
      if (value2) {
        this.setAttribute("refresh", value2);
      } else {
        this.removeAttribute("refresh");
      }
    }
    get shouldReloadWithMorph() {
      return this.src && this.refresh === "morph";
    }
    /**
     * Determines if the element is loading
     */
    get loading() {
      return frameLoadingStyleFromString(this.getAttribute("loading") || "");
    }
    /**
     * Sets the value of if the element is loading
     */
    set loading(value2) {
      if (value2) {
        this.setAttribute("loading", value2);
      } else {
        this.removeAttribute("loading");
      }
    }
    /**
     * Gets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    get disabled() {
      return this.hasAttribute("disabled");
    }
    /**
     * Sets the disabled state of the frame.
     *
     * If disabled, no requests will be intercepted by the frame.
     */
    set disabled(value2) {
      if (value2) {
        this.setAttribute("disabled", "");
      } else {
        this.removeAttribute("disabled");
      }
    }
    /**
     * Gets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    get autoscroll() {
      return this.hasAttribute("autoscroll");
    }
    /**
     * Sets the autoscroll state of the frame.
     *
     * If true, the frame will be scrolled into view automatically on update.
     */
    set autoscroll(value2) {
      if (value2) {
        this.setAttribute("autoscroll", "");
      } else {
        this.removeAttribute("autoscroll");
      }
    }
    /**
     * Determines if the element has finished loading
     */
    get complete() {
      return !this.delegate.isLoading;
    }
    /**
     * Gets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isActive() {
      return this.ownerDocument === document && !this.isPreview;
    }
    /**
     * Sets the active state of the frame.
     *
     * If inactive, source changes will not be observed.
     */
    get isPreview() {
      return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview");
    }
  };
  function frameLoadingStyleFromString(style) {
    switch (style.toLowerCase()) {
      case "lazy":
        return FrameLoadingStyle.lazy;
      default:
        return FrameLoadingStyle.eager;
    }
  }
  var drive = {
    enabled: true,
    progressBarDelay: 500,
    unvisitableExtensions: /* @__PURE__ */ new Set(
      [
        ".7z",
        ".aac",
        ".apk",
        ".avi",
        ".bmp",
        ".bz2",
        ".css",
        ".csv",
        ".deb",
        ".dmg",
        ".doc",
        ".docx",
        ".exe",
        ".gif",
        ".gz",
        ".heic",
        ".heif",
        ".ico",
        ".iso",
        ".jpeg",
        ".jpg",
        ".js",
        ".json",
        ".m4a",
        ".mkv",
        ".mov",
        ".mp3",
        ".mp4",
        ".mpeg",
        ".mpg",
        ".msi",
        ".ogg",
        ".ogv",
        ".pdf",
        ".pkg",
        ".png",
        ".ppt",
        ".pptx",
        ".rar",
        ".rtf",
        ".svg",
        ".tar",
        ".tif",
        ".tiff",
        ".txt",
        ".wav",
        ".webm",
        ".webp",
        ".wma",
        ".wmv",
        ".xls",
        ".xlsx",
        ".xml",
        ".zip"
      ]
    )
  };
  function activateScriptElement(element) {
    if (element.getAttribute("data-turbo-eval") == "false") {
      return element;
    } else {
      const createdScriptElement = document.createElement("script");
      const cspNonce = getMetaContent("csp-nonce");
      if (cspNonce) {
        createdScriptElement.nonce = cspNonce;
      }
      createdScriptElement.textContent = element.textContent;
      createdScriptElement.async = false;
      copyElementAttributes(createdScriptElement, element);
      return createdScriptElement;
    }
  }
  function copyElementAttributes(destinationElement, sourceElement) {
    for (const { name: name2, value: value2 } of sourceElement.attributes) {
      destinationElement.setAttribute(name2, value2);
    }
  }
  function createDocumentFragment(html) {
    const template = document.createElement("template");
    template.innerHTML = html;
    return template.content;
  }
  function dispatch(eventName, { target, cancelable, detail } = {}) {
    const event = new CustomEvent(eventName, {
      cancelable,
      bubbles: true,
      composed: true,
      detail
    });
    if (target && target.isConnected) {
      target.dispatchEvent(event);
    } else {
      document.documentElement.dispatchEvent(event);
    }
    return event;
  }
  function cancelEvent(event) {
    event.preventDefault();
    event.stopImmediatePropagation();
  }
  function nextRepaint() {
    if (document.visibilityState === "hidden") {
      return nextEventLoopTick();
    } else {
      return nextAnimationFrame();
    }
  }
  function nextAnimationFrame() {
    return new Promise((resolve) => requestAnimationFrame(() => resolve()));
  }
  function nextEventLoopTick() {
    return new Promise((resolve) => setTimeout(() => resolve(), 0));
  }
  function nextMicrotask() {
    return Promise.resolve();
  }
  function parseHTMLDocument(html = "") {
    return new DOMParser().parseFromString(html, "text/html");
  }
  function unindent(strings, ...values) {
    const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
    const match2 = lines[0].match(/^\s+/);
    const indent = match2 ? match2[0].length : 0;
    return lines.map((line4) => line4.slice(indent)).join("\n");
  }
  function interpolate(strings, values) {
    return strings.reduce((result, string, i) => {
      const value2 = values[i] == void 0 ? "" : values[i];
      return result + string + value2;
    }, "");
  }
  function uuid() {
    return Array.from({ length: 36 }).map((_2, i) => {
      if (i == 8 || i == 13 || i == 18 || i == 23) {
        return "-";
      } else if (i == 14) {
        return "4";
      } else if (i == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16);
      } else {
        return Math.floor(Math.random() * 15).toString(16);
      }
    }).join("");
  }
  function getAttribute(attributeName, ...elements) {
    for (const value2 of elements.map((element) => element?.getAttribute(attributeName))) {
      if (typeof value2 == "string") return value2;
    }
    return null;
  }
  function hasAttribute(attributeName, ...elements) {
    return elements.some((element) => element && element.hasAttribute(attributeName));
  }
  function markAsBusy(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.setAttribute("busy", "");
      }
      element.setAttribute("aria-busy", "true");
    }
  }
  function clearBusyState(...elements) {
    for (const element of elements) {
      if (element.localName == "turbo-frame") {
        element.removeAttribute("busy");
      }
      element.removeAttribute("aria-busy");
    }
  }
  function waitForLoad(element, timeoutInMilliseconds = 2e3) {
    return new Promise((resolve) => {
      const onComplete = () => {
        element.removeEventListener("error", onComplete);
        element.removeEventListener("load", onComplete);
        resolve();
      };
      element.addEventListener("load", onComplete, { once: true });
      element.addEventListener("error", onComplete, { once: true });
      setTimeout(resolve, timeoutInMilliseconds);
    });
  }
  function getHistoryMethodForAction(action) {
    switch (action) {
      case "replace":
        return history.replaceState;
      case "advance":
      case "restore":
        return history.pushState;
    }
  }
  function isAction(action) {
    return action == "advance" || action == "replace" || action == "restore";
  }
  function getVisitAction(...elements) {
    const action = getAttribute("data-turbo-action", ...elements);
    return isAction(action) ? action : null;
  }
  function getMetaElement(name2) {
    return document.querySelector(`meta[name="${name2}"]`);
  }
  function getMetaContent(name2) {
    const element = getMetaElement(name2);
    return element && element.content;
  }
  function setMetaContent(name2, content) {
    let element = getMetaElement(name2);
    if (!element) {
      element = document.createElement("meta");
      element.setAttribute("name", name2);
      document.head.appendChild(element);
    }
    element.setAttribute("content", content);
    return element;
  }
  function findClosestRecursively(element, selector) {
    if (element instanceof Element) {
      return element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector);
    }
  }
  function elementIsFocusable(element) {
    const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";
    return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function";
  }
  function queryAutofocusableElement(elementOrDocumentFragment) {
    return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable);
  }
  async function around(callback, reader) {
    const before = reader();
    callback();
    await nextAnimationFrame();
    const after = reader();
    return [before, after];
  }
  function doesNotTargetIFrame(name2) {
    if (name2 === "_blank") {
      return false;
    } else if (name2) {
      for (const element of document.getElementsByName(name2)) {
        if (element instanceof HTMLIFrameElement) return false;
      }
      return true;
    } else {
      return true;
    }
  }
  function findLinkFromClickTarget(target) {
    return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])");
  }
  function getLocationForLink(link2) {
    return expandURL(link2.getAttribute("href") || "");
  }
  function debounce(fn, delay) {
    let timeoutId = null;
    return (...args) => {
      const callback = () => fn.apply(this, args);
      clearTimeout(timeoutId);
      timeoutId = setTimeout(callback, delay);
    };
  }
  var submitter = {
    "aria-disabled": {
      beforeSubmit: (submitter2) => {
        submitter2.setAttribute("aria-disabled", "true");
        submitter2.addEventListener("click", cancelEvent);
      },
      afterSubmit: (submitter2) => {
        submitter2.removeAttribute("aria-disabled");
        submitter2.removeEventListener("click", cancelEvent);
      }
    },
    "disabled": {
      beforeSubmit: (submitter2) => submitter2.disabled = true,
      afterSubmit: (submitter2) => submitter2.disabled = false
    }
  };
  var Config = class {
    #submitter = null;
    constructor(config2) {
      Object.assign(this, config2);
    }
    get submitter() {
      return this.#submitter;
    }
    set submitter(value2) {
      this.#submitter = submitter[value2] || value2;
    }
  };
  var forms = new Config({
    mode: "on",
    submitter: "disabled"
  });
  var config = {
    drive,
    forms
  };
  function expandURL(locatable) {
    return new URL(locatable.toString(), document.baseURI);
  }
  function getAnchor(url) {
    let anchorMatch;
    if (url.hash) {
      return url.hash.slice(1);
    } else if (anchorMatch = url.href.match(/#(.*)$/)) {
      return anchorMatch[1];
    }
  }
  function getAction$1(form, submitter2) {
    const action = submitter2?.getAttribute("formaction") || form.getAttribute("action") || form.action;
    return expandURL(action);
  }
  function getExtension(url) {
    return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || "";
  }
  function isPrefixedBy(baseURL, url) {
    const prefix = getPrefix(url);
    return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix);
  }
  function locationIsVisitable(location2, rootLocation) {
    return isPrefixedBy(location2, rootLocation) && !config.drive.unvisitableExtensions.has(getExtension(location2));
  }
  function getRequestURL(url) {
    const anchor = getAnchor(url);
    return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href;
  }
  function toCacheKey(url) {
    return getRequestURL(url);
  }
  function urlsAreEqual(left2, right2) {
    return expandURL(left2).href == expandURL(right2).href;
  }
  function getPathComponents(url) {
    return url.pathname.split("/").slice(1);
  }
  function getLastPathComponent(url) {
    return getPathComponents(url).slice(-1)[0];
  }
  function getPrefix(url) {
    return addTrailingSlash(url.origin + url.pathname);
  }
  function addTrailingSlash(value2) {
    return value2.endsWith("/") ? value2 : value2 + "/";
  }
  var FetchResponse = class {
    constructor(response) {
      this.response = response;
    }
    get succeeded() {
      return this.response.ok;
    }
    get failed() {
      return !this.succeeded;
    }
    get clientError() {
      return this.statusCode >= 400 && this.statusCode <= 499;
    }
    get serverError() {
      return this.statusCode >= 500 && this.statusCode <= 599;
    }
    get redirected() {
      return this.response.redirected;
    }
    get location() {
      return expandURL(this.response.url);
    }
    get isHTML() {
      return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/);
    }
    get statusCode() {
      return this.response.status;
    }
    get contentType() {
      return this.header("Content-Type");
    }
    get responseText() {
      return this.response.clone().text();
    }
    get responseHTML() {
      if (this.isHTML) {
        return this.response.clone().text();
      } else {
        return Promise.resolve(void 0);
      }
    }
    header(name2) {
      return this.response.headers.get(name2);
    }
  };
  var LimitedSet = class extends Set {
    constructor(maxSize) {
      super();
      this.maxSize = maxSize;
    }
    add(value2) {
      if (this.size >= this.maxSize) {
        const iterator = this.values();
        const oldestValue = iterator.next().value;
        this.delete(oldestValue);
      }
      super.add(value2);
    }
  };
  var recentRequests = new LimitedSet(20);
  var nativeFetch = window.fetch;
  function fetchWithTurboHeaders(url, options = {}) {
    const modifiedHeaders = new Headers(options.headers || {});
    const requestUID = uuid();
    recentRequests.add(requestUID);
    modifiedHeaders.append("X-Turbo-Request-Id", requestUID);
    return nativeFetch(url, {
      ...options,
      headers: modifiedHeaders
    });
  }
  function fetchMethodFromString(method) {
    switch (method.toLowerCase()) {
      case "get":
        return FetchMethod.get;
      case "post":
        return FetchMethod.post;
      case "put":
        return FetchMethod.put;
      case "patch":
        return FetchMethod.patch;
      case "delete":
        return FetchMethod.delete;
    }
  }
  var FetchMethod = {
    get: "get",
    post: "post",
    put: "put",
    patch: "patch",
    delete: "delete"
  };
  function fetchEnctypeFromString(encoding) {
    switch (encoding.toLowerCase()) {
      case FetchEnctype.multipart:
        return FetchEnctype.multipart;
      case FetchEnctype.plain:
        return FetchEnctype.plain;
      default:
        return FetchEnctype.urlEncoded;
    }
  }
  var FetchEnctype = {
    urlEncoded: "application/x-www-form-urlencoded",
    multipart: "multipart/form-data",
    plain: "text/plain"
  };
  var FetchRequest = class {
    abortController = new AbortController();
    #resolveRequestPromise = (_value) => {
    };
    constructor(delegate, method, location2, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {
      const [url, body] = buildResourceAndBody(expandURL(location2), method, requestBody, enctype);
      this.delegate = delegate;
      this.url = url;
      this.target = target;
      this.fetchOptions = {
        credentials: "same-origin",
        redirect: "follow",
        method: method.toUpperCase(),
        headers: { ...this.defaultHeaders },
        body,
        signal: this.abortSignal,
        referrer: this.delegate.referrer?.href
      };
      this.enctype = enctype;
    }
    get method() {
      return this.fetchOptions.method;
    }
    set method(value2) {
      const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();
      const fetchMethod = fetchMethodFromString(value2) || FetchMethod.get;
      this.url.search = "";
      const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);
      this.url = url;
      this.fetchOptions.body = body;
      this.fetchOptions.method = fetchMethod.toUpperCase();
    }
    get headers() {
      return this.fetchOptions.headers;
    }
    set headers(value2) {
      this.fetchOptions.headers = value2;
    }
    get body() {
      if (this.isSafe) {
        return this.url.searchParams;
      } else {
        return this.fetchOptions.body;
      }
    }
    set body(value2) {
      this.fetchOptions.body = value2;
    }
    get location() {
      return this.url;
    }
    get params() {
      return this.url.searchParams;
    }
    get entries() {
      return this.body ? Array.from(this.body.entries()) : [];
    }
    cancel() {
      this.abortController.abort();
    }
    async perform() {
      const { fetchOptions } = this;
      this.delegate.prepareRequest(this);
      const event = await this.#allowRequestToBeIntercepted(fetchOptions);
      try {
        this.delegate.requestStarted(this);
        if (event.detail.fetchRequest) {
          this.response = event.detail.fetchRequest.response;
        } else {
          this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
        }
        const response = await this.response;
        return await this.receive(response);
      } catch (error4) {
        if (error4.name !== "AbortError") {
          if (this.#willDelegateErrorHandling(error4)) {
            this.delegate.requestErrored(this, error4);
          }
          throw error4;
        }
      } finally {
        this.delegate.requestFinished(this);
      }
    }
    async receive(response) {
      const fetchResponse = new FetchResponse(response);
      const event = dispatch("turbo:before-fetch-response", {
        cancelable: true,
        detail: { fetchResponse },
        target: this.target
      });
      if (event.defaultPrevented) {
        this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
      } else if (fetchResponse.succeeded) {
        this.delegate.requestSucceededWithResponse(this, fetchResponse);
      } else {
        this.delegate.requestFailedWithResponse(this, fetchResponse);
      }
      return fetchResponse;
    }
    get defaultHeaders() {
      return {
        Accept: "text/html, application/xhtml+xml"
      };
    }
    get isSafe() {
      return isSafe(this.method);
    }
    get abortSignal() {
      return this.abortController.signal;
    }
    acceptResponseType(mimeType) {
      this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
    }
    async #allowRequestToBeIntercepted(fetchOptions) {
      const requestInterception = new Promise((resolve) => this.#resolveRequestPromise = resolve);
      const event = dispatch("turbo:before-fetch-request", {
        cancelable: true,
        detail: {
          fetchOptions,
          url: this.url,
          resume: this.#resolveRequestPromise
        },
        target: this.target
      });
      this.url = event.detail.url;
      if (event.defaultPrevented) await requestInterception;
      return event;
    }
    #willDelegateErrorHandling(error4) {
      const event = dispatch("turbo:fetch-request-error", {
        target: this.target,
        cancelable: true,
        detail: { request: this, error: error4 }
      });
      return !event.defaultPrevented;
    }
  };
  function isSafe(fetchMethod) {
    return fetchMethodFromString(fetchMethod) == FetchMethod.get;
  }
  function buildResourceAndBody(resource, method, requestBody, enctype) {
    const searchParams = Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;
    if (isSafe(method)) {
      return [mergeIntoURLSearchParams(resource, searchParams), null];
    } else if (enctype == FetchEnctype.urlEncoded) {
      return [resource, searchParams];
    } else {
      return [resource, requestBody];
    }
  }
  function entriesExcludingFiles(requestBody) {
    const entries = [];
    for (const [name2, value2] of requestBody) {
      if (value2 instanceof File) continue;
      else entries.push([name2, value2]);
    }
    return entries;
  }
  function mergeIntoURLSearchParams(url, requestBody) {
    const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));
    url.search = searchParams.toString();
    return url;
  }
  var AppearanceObserver = class {
    started = false;
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
      this.intersectionObserver = new IntersectionObserver(this.intersect);
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.intersectionObserver.observe(this.element);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.intersectionObserver.unobserve(this.element);
      }
    }
    intersect = (entries) => {
      const lastEntry = entries.slice(-1)[0];
      if (lastEntry?.isIntersecting) {
        this.delegate.elementAppearedInViewport(this.element);
      }
    };
  };
  var StreamMessage = class {
    static contentType = "text/vnd.turbo-stream.html";
    static wrap(message) {
      if (typeof message == "string") {
        return new this(createDocumentFragment(message));
      } else {
        return message;
      }
    }
    constructor(fragment) {
      this.fragment = importStreamElements(fragment);
    }
  };
  function importStreamElements(fragment) {
    for (const element of fragment.querySelectorAll("turbo-stream")) {
      const streamElement = document.importNode(element, true);
      for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
        inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
      }
      element.replaceWith(streamElement);
    }
    return fragment;
  }
  var PREFETCH_DELAY = 100;
  var PrefetchCache = class {
    #prefetchTimeout = null;
    #prefetched = null;
    get(url) {
      if (this.#prefetched && this.#prefetched.url === url && this.#prefetched.expire > Date.now()) {
        return this.#prefetched.request;
      }
    }
    setLater(url, request, ttl) {
      this.clear();
      this.#prefetchTimeout = setTimeout(() => {
        request.perform();
        this.set(url, request, ttl);
        this.#prefetchTimeout = null;
      }, PREFETCH_DELAY);
    }
    set(url, request, ttl) {
      this.#prefetched = { url, request, expire: new Date((/* @__PURE__ */ new Date()).getTime() + ttl) };
    }
    clear() {
      if (this.#prefetchTimeout) clearTimeout(this.#prefetchTimeout);
      this.#prefetched = null;
    }
  };
  var cacheTtl = 10 * 1e3;
  var prefetchCache = new PrefetchCache();
  var FormSubmissionState = {
    initialized: "initialized",
    requesting: "requesting",
    waiting: "waiting",
    receiving: "receiving",
    stopping: "stopping",
    stopped: "stopped"
  };
  var FormSubmission = class _FormSubmission {
    state = FormSubmissionState.initialized;
    static confirmMethod(message) {
      return Promise.resolve(confirm(message));
    }
    constructor(delegate, formElement, submitter2, mustRedirect = false) {
      const method = getMethod(formElement, submitter2);
      const action = getAction(getFormAction(formElement, submitter2), method);
      const body = buildFormData(formElement, submitter2);
      const enctype = getEnctype(formElement, submitter2);
      this.delegate = delegate;
      this.formElement = formElement;
      this.submitter = submitter2;
      this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
      this.mustRedirect = mustRedirect;
    }
    get method() {
      return this.fetchRequest.method;
    }
    set method(value2) {
      this.fetchRequest.method = value2;
    }
    get action() {
      return this.fetchRequest.url.toString();
    }
    set action(value2) {
      this.fetchRequest.url = expandURL(value2);
    }
    get body() {
      return this.fetchRequest.body;
    }
    get enctype() {
      return this.fetchRequest.enctype;
    }
    get isSafe() {
      return this.fetchRequest.isSafe;
    }
    get location() {
      return this.fetchRequest.url;
    }
    // The submission process
    async start() {
      const { initialized, requesting } = FormSubmissionState;
      const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);
      if (typeof confirmationMessage === "string") {
        const confirmMethod = typeof config.forms.confirm === "function" ? config.forms.confirm : _FormSubmission.confirmMethod;
        const answer = await confirmMethod(confirmationMessage, this.formElement, this.submitter);
        if (!answer) {
          return;
        }
      }
      if (this.state == initialized) {
        this.state = requesting;
        return this.fetchRequest.perform();
      }
    }
    stop() {
      const { stopping, stopped } = FormSubmissionState;
      if (this.state != stopping && this.state != stopped) {
        this.state = stopping;
        this.fetchRequest.cancel();
        return true;
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (!request.isSafe) {
        const token2 = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
        if (token2) {
          request.headers["X-CSRF-Token"] = token2;
        }
      }
      if (this.requestAcceptsTurboStreamResponse(request)) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      this.state = FormSubmissionState.waiting;
      if (this.submitter) config.forms.submitter.beforeSubmit(this.submitter);
      this.setSubmitsWith();
      markAsBusy(this.formElement);
      dispatch("turbo:submit-start", {
        target: this.formElement,
        detail: { formSubmission: this }
      });
      this.delegate.formSubmissionStarted(this);
    }
    requestPreventedHandlingResponse(request, response) {
      prefetchCache.clear();
      this.result = { success: response.succeeded, fetchResponse: response };
    }
    requestSucceededWithResponse(request, response) {
      if (response.clientError || response.serverError) {
        this.delegate.formSubmissionFailedWithResponse(this, response);
        return;
      }
      prefetchCache.clear();
      if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
        const error4 = new Error("Form responses must redirect to another location");
        this.delegate.formSubmissionErrored(this, error4);
      } else {
        this.state = FormSubmissionState.receiving;
        this.result = { success: true, fetchResponse: response };
        this.delegate.formSubmissionSucceededWithResponse(this, response);
      }
    }
    requestFailedWithResponse(request, response) {
      this.result = { success: false, fetchResponse: response };
      this.delegate.formSubmissionFailedWithResponse(this, response);
    }
    requestErrored(request, error4) {
      this.result = { success: false, error: error4 };
      this.delegate.formSubmissionErrored(this, error4);
    }
    requestFinished(_request) {
      this.state = FormSubmissionState.stopped;
      if (this.submitter) config.forms.submitter.afterSubmit(this.submitter);
      this.resetSubmitterText();
      clearBusyState(this.formElement);
      dispatch("turbo:submit-end", {
        target: this.formElement,
        detail: { formSubmission: this, ...this.result }
      });
      this.delegate.formSubmissionFinished(this);
    }
    // Private
    setSubmitsWith() {
      if (!this.submitter || !this.submitsWith) return;
      if (this.submitter.matches("button")) {
        this.originalSubmitText = this.submitter.innerHTML;
        this.submitter.innerHTML = this.submitsWith;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        this.originalSubmitText = input.value;
        input.value = this.submitsWith;
      }
    }
    resetSubmitterText() {
      if (!this.submitter || !this.originalSubmitText) return;
      if (this.submitter.matches("button")) {
        this.submitter.innerHTML = this.originalSubmitText;
      } else if (this.submitter.matches("input")) {
        const input = this.submitter;
        input.value = this.originalSubmitText;
      }
    }
    requestMustRedirect(request) {
      return !request.isSafe && this.mustRedirect;
    }
    requestAcceptsTurboStreamResponse(request) {
      return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement);
    }
    get submitsWith() {
      return this.submitter?.getAttribute("data-turbo-submits-with");
    }
  };
  function buildFormData(formElement, submitter2) {
    const formData = new FormData(formElement);
    const name2 = submitter2?.getAttribute("name");
    const value2 = submitter2?.getAttribute("value");
    if (name2) {
      formData.append(name2, value2 || "");
    }
    return formData;
  }
  function getCookieValue(cookieName) {
    if (cookieName != null) {
      const cookies = document.cookie ? document.cookie.split("; ") : [];
      const cookie = cookies.find((cookie2) => cookie2.startsWith(cookieName));
      if (cookie) {
        const value2 = cookie.split("=").slice(1).join("=");
        return value2 ? decodeURIComponent(value2) : void 0;
      }
    }
  }
  function responseSucceededWithoutRedirect(response) {
    return response.statusCode == 200 && !response.redirected;
  }
  function getFormAction(formElement, submitter2) {
    const formElementAction = typeof formElement.action === "string" ? formElement.action : null;
    if (submitter2?.hasAttribute("formaction")) {
      return submitter2.getAttribute("formaction") || "";
    } else {
      return formElement.getAttribute("action") || formElementAction || "";
    }
  }
  function getAction(formAction, fetchMethod) {
    const action = expandURL(formAction);
    if (isSafe(fetchMethod)) {
      action.search = "";
    }
    return action;
  }
  function getMethod(formElement, submitter2) {
    const method = submitter2?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
    return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get;
  }
  function getEnctype(formElement, submitter2) {
    return fetchEnctypeFromString(submitter2?.getAttribute("formenctype") || formElement.enctype);
  }
  var Snapshot = class {
    constructor(element) {
      this.element = element;
    }
    get activeElement() {
      return this.element.ownerDocument.activeElement;
    }
    get children() {
      return [...this.element.children];
    }
    hasAnchor(anchor) {
      return this.getElementForAnchor(anchor) != null;
    }
    getElementForAnchor(anchor) {
      return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null;
    }
    get isConnected() {
      return this.element.isConnected;
    }
    get firstAutofocusableElement() {
      return queryAutofocusableElement(this.element);
    }
    get permanentElements() {
      return queryPermanentElementsAll(this.element);
    }
    getPermanentElementById(id4) {
      return getPermanentElementById(this.element, id4);
    }
    getPermanentElementMapForSnapshot(snapshot) {
      const permanentElementMap = {};
      for (const currentPermanentElement of this.permanentElements) {
        const { id: id4 } = currentPermanentElement;
        const newPermanentElement = snapshot.getPermanentElementById(id4);
        if (newPermanentElement) {
          permanentElementMap[id4] = [currentPermanentElement, newPermanentElement];
        }
      }
      return permanentElementMap;
    }
  };
  function getPermanentElementById(node, id4) {
    return node.querySelector(`#${id4}[data-turbo-permanent]`);
  }
  function queryPermanentElementsAll(node) {
    return node.querySelectorAll("[id][data-turbo-permanent]");
  }
  var FormSubmitObserver = class {
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("submit", this.submitCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
        this.started = false;
      }
    }
    submitCaptured = () => {
      this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
      this.eventTarget.addEventListener("submit", this.submitBubbled, false);
    };
    submitBubbled = (event) => {
      if (!event.defaultPrevented) {
        const form = event.target instanceof HTMLFormElement ? event.target : void 0;
        const submitter2 = event.submitter || void 0;
        if (form && submissionDoesNotDismissDialog(form, submitter2) && submissionDoesNotTargetIFrame(form, submitter2) && this.delegate.willSubmitForm(form, submitter2)) {
          event.preventDefault();
          event.stopImmediatePropagation();
          this.delegate.formSubmitted(form, submitter2);
        }
      }
    };
  };
  function submissionDoesNotDismissDialog(form, submitter2) {
    const method = submitter2?.getAttribute("formmethod") || form.getAttribute("method");
    return method != "dialog";
  }
  function submissionDoesNotTargetIFrame(form, submitter2) {
    const target = submitter2?.getAttribute("formtarget") || form.getAttribute("target");
    return doesNotTargetIFrame(target);
  }
  var View = class {
    #resolveRenderPromise = (_value) => {
    };
    #resolveInterceptionPromise = (_value) => {
    };
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    // Scrolling
    scrollToAnchor(anchor) {
      const element = this.snapshot.getElementForAnchor(anchor);
      if (element) {
        this.scrollToElement(element);
        this.focusElement(element);
      } else {
        this.scrollToPosition({ x: 0, y: 0 });
      }
    }
    scrollToAnchorFromLocation(location2) {
      this.scrollToAnchor(getAnchor(location2));
    }
    scrollToElement(element) {
      element.scrollIntoView();
    }
    focusElement(element) {
      if (element instanceof HTMLElement) {
        if (element.hasAttribute("tabindex")) {
          element.focus();
        } else {
          element.setAttribute("tabindex", "-1");
          element.focus();
          element.removeAttribute("tabindex");
        }
      }
    }
    scrollToPosition({ x: x3, y: y3 }) {
      this.scrollRoot.scrollTo(x3, y3);
    }
    scrollToTop() {
      this.scrollToPosition({ x: 0, y: 0 });
    }
    get scrollRoot() {
      return window;
    }
    // Rendering
    async render(renderer) {
      const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer;
      const shouldInvalidate = willRender;
      if (shouldRender) {
        try {
          this.renderPromise = new Promise((resolve) => this.#resolveRenderPromise = resolve);
          this.renderer = renderer;
          await this.prepareToRenderSnapshot(renderer);
          const renderInterception = new Promise((resolve) => this.#resolveInterceptionPromise = resolve);
          const options = { resume: this.#resolveInterceptionPromise, render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
          const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
          if (!immediateRender) await renderInterception;
          await this.renderSnapshot(renderer);
          this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
          this.delegate.preloadOnLoadLinksForView(this.element);
          this.finishRenderingSnapshot(renderer);
        } finally {
          delete this.renderer;
          this.#resolveRenderPromise(void 0);
          delete this.renderPromise;
        }
      } else if (shouldInvalidate) {
        this.invalidate(renderer.reloadReason);
      }
    }
    invalidate(reason) {
      this.delegate.viewInvalidated(reason);
    }
    async prepareToRenderSnapshot(renderer) {
      this.markAsPreview(renderer.isPreview);
      await renderer.prepareToRender();
    }
    markAsPreview(isPreview) {
      if (isPreview) {
        this.element.setAttribute("data-turbo-preview", "");
      } else {
        this.element.removeAttribute("data-turbo-preview");
      }
    }
    markVisitDirection(direction2) {
      this.element.setAttribute("data-turbo-visit-direction", direction2);
    }
    unmarkVisitDirection() {
      this.element.removeAttribute("data-turbo-visit-direction");
    }
    async renderSnapshot(renderer) {
      await renderer.render();
    }
    finishRenderingSnapshot(renderer) {
      renderer.finishRendering();
    }
  };
  var FrameView = class extends View {
    missing() {
      this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
    }
    get snapshot() {
      return new Snapshot(this.element);
    }
  };
  var LinkInterceptor = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.element = element;
    }
    start() {
      this.element.addEventListener("click", this.clickBubbled);
      document.addEventListener("turbo:click", this.linkClicked);
      document.addEventListener("turbo:before-visit", this.willVisit);
    }
    stop() {
      this.element.removeEventListener("click", this.clickBubbled);
      document.removeEventListener("turbo:click", this.linkClicked);
      document.removeEventListener("turbo:before-visit", this.willVisit);
    }
    clickBubbled = (event) => {
      if (this.clickEventIsSignificant(event)) {
        this.clickEvent = event;
      } else {
        delete this.clickEvent;
      }
    };
    linkClicked = (event) => {
      if (this.clickEvent && this.clickEventIsSignificant(event)) {
        if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
          this.clickEvent.preventDefault();
          event.preventDefault();
          this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
        }
      }
      delete this.clickEvent;
    };
    willVisit = (_event) => {
      delete this.clickEvent;
    };
    clickEventIsSignificant(event) {
      const target = event.composed ? event.target?.parentElement : event.target;
      const element = findLinkFromClickTarget(target) || target;
      return element instanceof Element && element.closest("turbo-frame, html") == this.element;
    }
  };
  var LinkClickObserver = class {
    started = false;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (!this.started) {
        this.eventTarget.addEventListener("click", this.clickCaptured, true);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.eventTarget.removeEventListener("click", this.clickCaptured, true);
        this.started = false;
      }
    }
    clickCaptured = () => {
      this.eventTarget.removeEventListener("click", this.clickBubbled, false);
      this.eventTarget.addEventListener("click", this.clickBubbled, false);
    };
    clickBubbled = (event) => {
      if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
        const target = event.composedPath && event.composedPath()[0] || event.target;
        const link2 = findLinkFromClickTarget(target);
        if (link2 && doesNotTargetIFrame(link2.target)) {
          const location2 = getLocationForLink(link2);
          if (this.delegate.willFollowLinkToLocation(link2, location2, event)) {
            event.preventDefault();
            this.delegate.followedLinkToLocation(link2, location2);
          }
        }
      }
    };
    clickEventIsSignificant(event) {
      return !(event.target && event.target.isContentEditable || event.defaultPrevented || event.which > 1 || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey);
    }
  };
  var FormLinkClickObserver = class {
    constructor(delegate, element) {
      this.delegate = delegate;
      this.linkInterceptor = new LinkClickObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
    }
    stop() {
      this.linkInterceptor.stop();
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link2, location2) {
      return false;
    }
    prefetchAndCacheRequestToLocation(link2, location2) {
      return;
    }
    // Link click observer delegate
    willFollowLinkToLocation(link2, location2, originalEvent) {
      return this.delegate.willSubmitFormLinkToLocation(link2, location2, originalEvent) && (link2.hasAttribute("data-turbo-method") || link2.hasAttribute("data-turbo-stream"));
    }
    followedLinkToLocation(link2, location2) {
      const form = document.createElement("form");
      const type = "hidden";
      for (const [name2, value2] of location2.searchParams) {
        form.append(Object.assign(document.createElement("input"), { type, name: name2, value: value2 }));
      }
      const action = Object.assign(location2, { search: "" });
      form.setAttribute("data-turbo", "true");
      form.setAttribute("action", action.href);
      form.setAttribute("hidden", "");
      const method = link2.getAttribute("data-turbo-method");
      if (method) form.setAttribute("method", method);
      const turboFrame = link2.getAttribute("data-turbo-frame");
      if (turboFrame) form.setAttribute("data-turbo-frame", turboFrame);
      const turboAction = getVisitAction(link2);
      if (turboAction) form.setAttribute("data-turbo-action", turboAction);
      const turboConfirm = link2.getAttribute("data-turbo-confirm");
      if (turboConfirm) form.setAttribute("data-turbo-confirm", turboConfirm);
      const turboStream = link2.hasAttribute("data-turbo-stream");
      if (turboStream) form.setAttribute("data-turbo-stream", "");
      this.delegate.submittedFormLinkToLocation(link2, location2, form);
      document.body.appendChild(form);
      form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
      requestAnimationFrame(() => form.requestSubmit());
    }
  };
  var Bardo = class {
    static async preservingPermanentElements(delegate, permanentElementMap, callback) {
      const bardo = new this(delegate, permanentElementMap);
      bardo.enter();
      await callback();
      bardo.leave();
    }
    constructor(delegate, permanentElementMap) {
      this.delegate = delegate;
      this.permanentElementMap = permanentElementMap;
    }
    enter() {
      for (const id4 in this.permanentElementMap) {
        const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id4];
        this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
        this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
      }
    }
    leave() {
      for (const id4 in this.permanentElementMap) {
        const [currentPermanentElement] = this.permanentElementMap[id4];
        this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
        this.replacePlaceholderWithPermanentElement(currentPermanentElement);
        this.delegate.leavingBardo(currentPermanentElement);
      }
    }
    replaceNewPermanentElementWithPlaceholder(permanentElement) {
      const placeholder = createPlaceholderForPermanentElement(permanentElement);
      permanentElement.replaceWith(placeholder);
    }
    replaceCurrentPermanentElementWithClone(permanentElement) {
      const clone11 = permanentElement.cloneNode(true);
      permanentElement.replaceWith(clone11);
    }
    replacePlaceholderWithPermanentElement(permanentElement) {
      const placeholder = this.getPlaceholderById(permanentElement.id);
      placeholder?.replaceWith(permanentElement);
    }
    getPlaceholderById(id4) {
      return this.placeholders.find((element) => element.content == id4);
    }
    get placeholders() {
      return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")];
    }
  };
  function createPlaceholderForPermanentElement(permanentElement) {
    const element = document.createElement("meta");
    element.setAttribute("name", "turbo-permanent-placeholder");
    element.setAttribute("content", permanentElement.id);
    return element;
  }
  var Renderer = class {
    #activeElement = null;
    static renderElement(currentElement, newElement) {
    }
    constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {
      this.currentSnapshot = currentSnapshot;
      this.newSnapshot = newSnapshot;
      this.isPreview = isPreview;
      this.willRender = willRender;
      this.renderElement = this.constructor.renderElement;
      this.promise = new Promise((resolve, reject) => this.resolvingFunctions = { resolve, reject });
    }
    get shouldRender() {
      return true;
    }
    get shouldAutofocus() {
      return true;
    }
    get reloadReason() {
      return;
    }
    prepareToRender() {
      return;
    }
    render() {
    }
    finishRendering() {
      if (this.resolvingFunctions) {
        this.resolvingFunctions.resolve();
        delete this.resolvingFunctions;
      }
    }
    async preservingPermanentElements(callback) {
      await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
    }
    focusFirstAutofocusableElement() {
      if (this.shouldAutofocus) {
        const element = this.connectedSnapshot.firstAutofocusableElement;
        if (element) {
          element.focus();
        }
      }
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement) {
      if (this.#activeElement) return;
      if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
        this.#activeElement = this.currentSnapshot.activeElement;
      }
    }
    leavingBardo(currentPermanentElement) {
      if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {
        this.#activeElement.focus();
        this.#activeElement = null;
      }
    }
    get connectedSnapshot() {
      return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot;
    }
    get currentElement() {
      return this.currentSnapshot.element;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    get permanentElementMap() {
      return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot);
    }
    get renderMethod() {
      return "replace";
    }
  };
  var FrameRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const destinationRange = document.createRange();
      destinationRange.selectNodeContents(currentElement);
      destinationRange.deleteContents();
      const frameElement = newElement;
      const sourceRange = frameElement.ownerDocument?.createRange();
      if (sourceRange) {
        sourceRange.selectNodeContents(frameElement);
        currentElement.appendChild(sourceRange.extractContents());
      }
    }
    constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
      super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
      this.delegate = delegate;
    }
    get shouldRender() {
      return true;
    }
    async render() {
      await nextRepaint();
      this.preservingPermanentElements(() => {
        this.loadFrameElement();
      });
      this.scrollFrameIntoView();
      await nextRepaint();
      this.focusFirstAutofocusableElement();
      await nextRepaint();
      this.activateScriptElements();
    }
    loadFrameElement() {
      this.delegate.willRenderFrame(this.currentElement, this.newElement);
      this.renderElement(this.currentElement, this.newElement);
    }
    scrollFrameIntoView() {
      if (this.currentElement.autoscroll || this.newElement.autoscroll) {
        const element = this.currentElement.firstElementChild;
        const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
        const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");
        if (element) {
          element.scrollIntoView({ block, behavior });
          return true;
        }
      }
      return false;
    }
    activateScriptElements() {
      for (const inertScriptElement of this.newScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    get newScriptElements() {
      return this.currentElement.querySelectorAll("script");
    }
  };
  function readScrollLogicalPosition(value2, defaultValue) {
    if (value2 == "end" || value2 == "start" || value2 == "center" || value2 == "nearest") {
      return value2;
    } else {
      return defaultValue;
    }
  }
  function readScrollBehavior(value2, defaultValue) {
    if (value2 == "auto" || value2 == "smooth") {
      return value2;
    } else {
      return defaultValue;
    }
  }
  var Idiomorph = /* @__PURE__ */ function() {
    let EMPTY_SET = /* @__PURE__ */ new Set();
    let defaults5 = {
      morphStyle: "outerHTML",
      callbacks: {
        beforeNodeAdded: noOp,
        afterNodeAdded: noOp,
        beforeNodeMorphed: noOp,
        afterNodeMorphed: noOp,
        beforeNodeRemoved: noOp,
        afterNodeRemoved: noOp,
        beforeAttributeUpdated: noOp
      },
      head: {
        style: "merge",
        shouldPreserve: function(elt) {
          return elt.getAttribute("im-preserve") === "true";
        },
        shouldReAppend: function(elt) {
          return elt.getAttribute("im-re-append") === "true";
        },
        shouldRemove: noOp,
        afterHeadMorphed: noOp
      }
    };
    function morph(oldNode, newContent, config2 = {}) {
      if (oldNode instanceof Document) {
        oldNode = oldNode.documentElement;
      }
      if (typeof newContent === "string") {
        newContent = parseContent(newContent);
      }
      let normalizedContent = normalizeContent(newContent);
      let ctx2 = createMorphContext(oldNode, normalizedContent, config2);
      return morphNormalizedContent(oldNode, normalizedContent, ctx2);
    }
    function morphNormalizedContent(oldNode, normalizedNewContent, ctx2) {
      if (ctx2.head.block) {
        let oldHead = oldNode.querySelector("head");
        let newHead = normalizedNewContent.querySelector("head");
        if (oldHead && newHead) {
          let promises = handleHeadElement(newHead, oldHead, ctx2);
          Promise.all(promises).then(function() {
            morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx2, {
              head: {
                block: false,
                ignore: true
              }
            }));
          });
          return;
        }
      }
      if (ctx2.morphStyle === "innerHTML") {
        morphChildren2(normalizedNewContent, oldNode, ctx2);
        return oldNode.children;
      } else if (ctx2.morphStyle === "outerHTML" || ctx2.morphStyle == null) {
        let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx2);
        let previousSibling = bestMatch?.previousSibling;
        let nextSibling = bestMatch?.nextSibling;
        let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx2);
        if (bestMatch) {
          return insertSiblings(previousSibling, morphedNode, nextSibling);
        } else {
          return [];
        }
      } else {
        throw "Do not understand how to morph style " + ctx2.morphStyle;
      }
    }
    function ignoreValueOfActiveElement(possibleActiveElement, ctx2) {
      return ctx2.ignoreActiveValue && possibleActiveElement === document.activeElement && possibleActiveElement !== document.body;
    }
    function morphOldNodeTo(oldNode, newContent, ctx2) {
      if (ctx2.ignoreActive && oldNode === document.activeElement) ;
      else if (newContent == null) {
        if (ctx2.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        oldNode.remove();
        ctx2.callbacks.afterNodeRemoved(oldNode);
        return null;
      } else if (!isSoftMatch(oldNode, newContent)) {
        if (ctx2.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        if (ctx2.callbacks.beforeNodeAdded(newContent) === false) return oldNode;
        oldNode.parentElement.replaceChild(newContent, oldNode);
        ctx2.callbacks.afterNodeAdded(newContent);
        ctx2.callbacks.afterNodeRemoved(oldNode);
        return newContent;
      } else {
        if (ctx2.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;
        if (oldNode instanceof HTMLHeadElement && ctx2.head.ignore) ;
        else if (oldNode instanceof HTMLHeadElement && ctx2.head.style !== "morph") {
          handleHeadElement(newContent, oldNode, ctx2);
        } else {
          syncNodeFrom(newContent, oldNode, ctx2);
          if (!ignoreValueOfActiveElement(oldNode, ctx2)) {
            morphChildren2(newContent, oldNode, ctx2);
          }
        }
        ctx2.callbacks.afterNodeMorphed(oldNode, newContent);
        return oldNode;
      }
    }
    function morphChildren2(newParent, oldParent, ctx2) {
      let nextNewChild = newParent.firstChild;
      let insertionPoint = oldParent.firstChild;
      let newChild;
      while (nextNewChild) {
        newChild = nextNewChild;
        nextNewChild = newChild.nextSibling;
        if (insertionPoint == null) {
          if (ctx2.callbacks.beforeNodeAdded(newChild) === false) return;
          oldParent.appendChild(newChild);
          ctx2.callbacks.afterNodeAdded(newChild);
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        if (isIdSetMatch(newChild, insertionPoint, ctx2)) {
          morphOldNodeTo(insertionPoint, newChild, ctx2);
          insertionPoint = insertionPoint.nextSibling;
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx2);
        if (idSetMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx2);
          morphOldNodeTo(idSetMatch, newChild, ctx2);
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx2);
        if (softMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx2);
          morphOldNodeTo(softMatch, newChild, ctx2);
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        if (ctx2.callbacks.beforeNodeAdded(newChild) === false) return;
        oldParent.insertBefore(newChild, insertionPoint);
        ctx2.callbacks.afterNodeAdded(newChild);
        removeIdsFromConsideration(ctx2, newChild);
      }
      while (insertionPoint !== null) {
        let tempNode = insertionPoint;
        insertionPoint = insertionPoint.nextSibling;
        removeNode(tempNode, ctx2);
      }
    }
    function ignoreAttribute(attr2, to, updateType, ctx2) {
      if (attr2 === "value" && ctx2.ignoreActiveValue && to === document.activeElement) {
        return true;
      }
      return ctx2.callbacks.beforeAttributeUpdated(attr2, to, updateType) === false;
    }
    function syncNodeFrom(from, to, ctx2) {
      let type = from.nodeType;
      if (type === 1) {
        const fromAttributes = from.attributes;
        const toAttributes = to.attributes;
        for (const fromAttribute of fromAttributes) {
          if (ignoreAttribute(fromAttribute.name, to, "update", ctx2)) {
            continue;
          }
          if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {
            to.setAttribute(fromAttribute.name, fromAttribute.value);
          }
        }
        for (let i = toAttributes.length - 1; 0 <= i; i--) {
          const toAttribute = toAttributes[i];
          if (ignoreAttribute(toAttribute.name, to, "remove", ctx2)) {
            continue;
          }
          if (!from.hasAttribute(toAttribute.name)) {
            to.removeAttribute(toAttribute.name);
          }
        }
      }
      if (type === 8 || type === 3) {
        if (to.nodeValue !== from.nodeValue) {
          to.nodeValue = from.nodeValue;
        }
      }
      if (!ignoreValueOfActiveElement(to, ctx2)) {
        syncInputValue(from, to, ctx2);
      }
    }
    function syncBooleanAttribute(from, to, attributeName, ctx2) {
      if (from[attributeName] !== to[attributeName]) {
        let ignoreUpdate = ignoreAttribute(attributeName, to, "update", ctx2);
        if (!ignoreUpdate) {
          to[attributeName] = from[attributeName];
        }
        if (from[attributeName]) {
          if (!ignoreUpdate) {
            to.setAttribute(attributeName, from[attributeName]);
          }
        } else {
          if (!ignoreAttribute(attributeName, to, "remove", ctx2)) {
            to.removeAttribute(attributeName);
          }
        }
      }
    }
    function syncInputValue(from, to, ctx2) {
      if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== "file") {
        let fromValue = from.value;
        let toValue = to.value;
        syncBooleanAttribute(from, to, "checked", ctx2);
        syncBooleanAttribute(from, to, "disabled", ctx2);
        if (!from.hasAttribute("value")) {
          if (!ignoreAttribute("value", to, "remove", ctx2)) {
            to.value = "";
            to.removeAttribute("value");
          }
        } else if (fromValue !== toValue) {
          if (!ignoreAttribute("value", to, "update", ctx2)) {
            to.setAttribute("value", fromValue);
            to.value = fromValue;
          }
        }
      } else if (from instanceof HTMLOptionElement) {
        syncBooleanAttribute(from, to, "selected", ctx2);
      } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {
        let fromValue = from.value;
        let toValue = to.value;
        if (ignoreAttribute("value", to, "update", ctx2)) {
          return;
        }
        if (fromValue !== toValue) {
          to.value = fromValue;
        }
        if (to.firstChild && to.firstChild.nodeValue !== fromValue) {
          to.firstChild.nodeValue = fromValue;
        }
      }
    }
    function handleHeadElement(newHeadTag, currentHead, ctx2) {
      let added = [];
      let removed = [];
      let preserved = [];
      let nodesToAppend = [];
      let headMergeStyle = ctx2.head.style;
      let srcToNewHeadNodes = /* @__PURE__ */ new Map();
      for (const newHeadChild of newHeadTag.children) {
        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
      }
      for (const currentHeadElt of currentHead.children) {
        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
        let isReAppended = ctx2.head.shouldReAppend(currentHeadElt);
        let isPreserved = ctx2.head.shouldPreserve(currentHeadElt);
        if (inNewContent || isPreserved) {
          if (isReAppended) {
            removed.push(currentHeadElt);
          } else {
            srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
            preserved.push(currentHeadElt);
          }
        } else {
          if (headMergeStyle === "append") {
            if (isReAppended) {
              removed.push(currentHeadElt);
              nodesToAppend.push(currentHeadElt);
            }
          } else {
            if (ctx2.head.shouldRemove(currentHeadElt) !== false) {
              removed.push(currentHeadElt);
            }
          }
        }
      }
      nodesToAppend.push(...srcToNewHeadNodes.values());
      let promises = [];
      for (const newNode of nodesToAppend) {
        let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
        if (ctx2.callbacks.beforeNodeAdded(newElt) !== false) {
          if (newElt.href || newElt.src) {
            let resolve = null;
            let promise = new Promise(function(_resolve) {
              resolve = _resolve;
            });
            newElt.addEventListener("load", function() {
              resolve();
            });
            promises.push(promise);
          }
          currentHead.appendChild(newElt);
          ctx2.callbacks.afterNodeAdded(newElt);
          added.push(newElt);
        }
      }
      for (const removedElement of removed) {
        if (ctx2.callbacks.beforeNodeRemoved(removedElement) !== false) {
          currentHead.removeChild(removedElement);
          ctx2.callbacks.afterNodeRemoved(removedElement);
        }
      }
      ctx2.head.afterHeadMorphed(currentHead, { added, kept: preserved, removed });
      return promises;
    }
    function noOp() {
    }
    function mergeDefaults(config2) {
      let finalConfig = {};
      Object.assign(finalConfig, defaults5);
      Object.assign(finalConfig, config2);
      finalConfig.callbacks = {};
      Object.assign(finalConfig.callbacks, defaults5.callbacks);
      Object.assign(finalConfig.callbacks, config2.callbacks);
      finalConfig.head = {};
      Object.assign(finalConfig.head, defaults5.head);
      Object.assign(finalConfig.head, config2.head);
      return finalConfig;
    }
    function createMorphContext(oldNode, newContent, config2) {
      config2 = mergeDefaults(config2);
      return {
        target: oldNode,
        newContent,
        config: config2,
        morphStyle: config2.morphStyle,
        ignoreActive: config2.ignoreActive,
        ignoreActiveValue: config2.ignoreActiveValue,
        idMap: createIdMap(oldNode, newContent),
        deadIds: /* @__PURE__ */ new Set(),
        callbacks: config2.callbacks,
        head: config2.head
      };
    }
    function isIdSetMatch(node1, node2, ctx2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {
        if (node1.id !== "" && node1.id === node2.id) {
          return true;
        } else {
          return getIdIntersectionCount(ctx2, node1, node2) > 0;
        }
      }
      return false;
    }
    function isSoftMatch(node1, node2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;
    }
    function removeNodesBetween(startInclusive, endExclusive, ctx2) {
      while (startInclusive !== endExclusive) {
        let tempNode = startInclusive;
        startInclusive = startInclusive.nextSibling;
        removeNode(tempNode, ctx2);
      }
      removeIdsFromConsideration(ctx2, endExclusive);
      return endExclusive.nextSibling;
    }
    function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx2) {
      let newChildPotentialIdCount = getIdIntersectionCount(ctx2, newChild, oldParent);
      let potentialMatch = null;
      if (newChildPotentialIdCount > 0) {
        let potentialMatch2 = insertionPoint;
        let otherMatchCount = 0;
        while (potentialMatch2 != null) {
          if (isIdSetMatch(newChild, potentialMatch2, ctx2)) {
            return potentialMatch2;
          }
          otherMatchCount += getIdIntersectionCount(ctx2, potentialMatch2, newContent);
          if (otherMatchCount > newChildPotentialIdCount) {
            return null;
          }
          potentialMatch2 = potentialMatch2.nextSibling;
        }
      }
      return potentialMatch;
    }
    function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx2) {
      let potentialSoftMatch = insertionPoint;
      let nextSibling = newChild.nextSibling;
      let siblingSoftMatchCount = 0;
      while (potentialSoftMatch != null) {
        if (getIdIntersectionCount(ctx2, potentialSoftMatch, newContent) > 0) {
          return null;
        }
        if (isSoftMatch(newChild, potentialSoftMatch)) {
          return potentialSoftMatch;
        }
        if (isSoftMatch(nextSibling, potentialSoftMatch)) {
          siblingSoftMatchCount++;
          nextSibling = nextSibling.nextSibling;
          if (siblingSoftMatchCount >= 2) {
            return null;
          }
        }
        potentialSoftMatch = potentialSoftMatch.nextSibling;
      }
      return potentialSoftMatch;
    }
    function parseContent(newContent) {
      let parser = new DOMParser();
      let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
      if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
        let content = parser.parseFromString(newContent, "text/html");
        if (contentWithSvgsRemoved.match(/<\/html>/)) {
          content.generatedByIdiomorph = true;
          return content;
        } else {
          let htmlElement = content.firstChild;
          if (htmlElement) {
            htmlElement.generatedByIdiomorph = true;
            return htmlElement;
          } else {
            return null;
          }
        }
      } else {
        let responseDoc = parser.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
        let content = responseDoc.body.querySelector("template").content;
        content.generatedByIdiomorph = true;
        return content;
      }
    }
    function normalizeContent(newContent) {
      if (newContent == null) {
        const dummyParent = document.createElement("div");
        return dummyParent;
      } else if (newContent.generatedByIdiomorph) {
        return newContent;
      } else if (newContent instanceof Node) {
        const dummyParent = document.createElement("div");
        dummyParent.append(newContent);
        return dummyParent;
      } else {
        const dummyParent = document.createElement("div");
        for (const elt of [...newContent]) {
          dummyParent.append(elt);
        }
        return dummyParent;
      }
    }
    function insertSiblings(previousSibling, morphedNode, nextSibling) {
      let stack = [];
      let added = [];
      while (previousSibling != null) {
        stack.push(previousSibling);
        previousSibling = previousSibling.previousSibling;
      }
      while (stack.length > 0) {
        let node = stack.pop();
        added.push(node);
        morphedNode.parentElement.insertBefore(node, morphedNode);
      }
      added.push(morphedNode);
      while (nextSibling != null) {
        stack.push(nextSibling);
        added.push(nextSibling);
        nextSibling = nextSibling.nextSibling;
      }
      while (stack.length > 0) {
        morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);
      }
      return added;
    }
    function findBestNodeMatch(newContent, oldNode, ctx2) {
      let currentElement;
      currentElement = newContent.firstChild;
      let bestElement = currentElement;
      let score2 = 0;
      while (currentElement) {
        let newScore = scoreElement(currentElement, oldNode, ctx2);
        if (newScore > score2) {
          bestElement = currentElement;
          score2 = newScore;
        }
        currentElement = currentElement.nextSibling;
      }
      return bestElement;
    }
    function scoreElement(node1, node2, ctx2) {
      if (isSoftMatch(node1, node2)) {
        return 0.5 + getIdIntersectionCount(ctx2, node1, node2);
      }
      return 0;
    }
    function removeNode(tempNode, ctx2) {
      removeIdsFromConsideration(ctx2, tempNode);
      if (ctx2.callbacks.beforeNodeRemoved(tempNode) === false) return;
      tempNode.remove();
      ctx2.callbacks.afterNodeRemoved(tempNode);
    }
    function isIdInConsideration(ctx2, id4) {
      return !ctx2.deadIds.has(id4);
    }
    function idIsWithinNode(ctx2, id4, targetNode) {
      let idSet = ctx2.idMap.get(targetNode) || EMPTY_SET;
      return idSet.has(id4);
    }
    function removeIdsFromConsideration(ctx2, node) {
      let idSet = ctx2.idMap.get(node) || EMPTY_SET;
      for (const id4 of idSet) {
        ctx2.deadIds.add(id4);
      }
    }
    function getIdIntersectionCount(ctx2, node1, node2) {
      let sourceSet = ctx2.idMap.get(node1) || EMPTY_SET;
      let matchCount = 0;
      for (const id4 of sourceSet) {
        if (isIdInConsideration(ctx2, id4) && idIsWithinNode(ctx2, id4, node2)) {
          ++matchCount;
        }
      }
      return matchCount;
    }
    function populateIdMapForNode(node, idMap) {
      let nodeParent = node.parentElement;
      let idElements = node.querySelectorAll("[id]");
      for (const elt of idElements) {
        let current = elt;
        while (current !== nodeParent && current != null) {
          let idSet = idMap.get(current);
          if (idSet == null) {
            idSet = /* @__PURE__ */ new Set();
            idMap.set(current, idSet);
          }
          idSet.add(elt.id);
          current = current.parentElement;
        }
      }
    }
    function createIdMap(oldContent, newContent) {
      let idMap = /* @__PURE__ */ new Map();
      populateIdMapForNode(oldContent, idMap);
      populateIdMapForNode(newContent, idMap);
      return idMap;
    }
    return {
      morph,
      defaults: defaults5
    };
  }();
  function morphElements(currentElement, newElement, { callbacks, ...options } = {}) {
    Idiomorph.morph(currentElement, newElement, {
      ...options,
      callbacks: new DefaultIdiomorphCallbacks(callbacks)
    });
  }
  function morphChildren(currentElement, newElement) {
    morphElements(currentElement, newElement.children, {
      morphStyle: "innerHTML"
    });
  }
  var DefaultIdiomorphCallbacks = class {
    #beforeNodeMorphed;
    constructor({ beforeNodeMorphed } = {}) {
      this.#beforeNodeMorphed = beforeNodeMorphed || (() => true);
    }
    beforeNodeAdded = (node) => {
      return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id));
    };
    beforeNodeMorphed = (currentElement, newElement) => {
      if (currentElement instanceof Element) {
        if (!currentElement.hasAttribute("data-turbo-permanent") && this.#beforeNodeMorphed(currentElement, newElement)) {
          const event = dispatch("turbo:before-morph-element", {
            cancelable: true,
            target: currentElement,
            detail: { currentElement, newElement }
          });
          return !event.defaultPrevented;
        } else {
          return false;
        }
      }
    };
    beforeAttributeUpdated = (attributeName, target, mutationType) => {
      const event = dispatch("turbo:before-morph-attribute", {
        cancelable: true,
        target,
        detail: { attributeName, mutationType }
      });
      return !event.defaultPrevented;
    };
    beforeNodeRemoved = (node) => {
      return this.beforeNodeMorphed(node);
    };
    afterNodeMorphed = (currentElement, newElement) => {
      if (currentElement instanceof Element) {
        dispatch("turbo:morph-element", {
          target: currentElement,
          detail: { currentElement, newElement }
        });
      }
    };
  };
  var MorphingFrameRenderer = class extends FrameRenderer {
    static renderElement(currentElement, newElement) {
      dispatch("turbo:before-frame-morph", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
      morphChildren(currentElement, newElement);
    }
    async preservingPermanentElements(callback) {
      return await callback();
    }
  };
  var ProgressBar = class _ProgressBar {
    static animationDuration = 300;
    /*ms*/
    static get defaultCSS() {
      return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${_ProgressBar.animationDuration}ms ease-out,
          opacity ${_ProgressBar.animationDuration / 2}ms ${_ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `;
    }
    hiding = false;
    value = 0;
    visible = false;
    constructor() {
      this.stylesheetElement = this.createStylesheetElement();
      this.progressElement = this.createProgressElement();
      this.installStylesheetElement();
      this.setValue(0);
    }
    show() {
      if (!this.visible) {
        this.visible = true;
        this.installProgressElement();
        this.startTrickling();
      }
    }
    hide() {
      if (this.visible && !this.hiding) {
        this.hiding = true;
        this.fadeProgressElement(() => {
          this.uninstallProgressElement();
          this.stopTrickling();
          this.visible = false;
          this.hiding = false;
        });
      }
    }
    setValue(value2) {
      this.value = value2;
      this.refresh();
    }
    // Private
    installStylesheetElement() {
      document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
    }
    installProgressElement() {
      this.progressElement.style.width = "0";
      this.progressElement.style.opacity = "1";
      document.documentElement.insertBefore(this.progressElement, document.body);
      this.refresh();
    }
    fadeProgressElement(callback) {
      this.progressElement.style.opacity = "0";
      setTimeout(callback, _ProgressBar.animationDuration * 1.5);
    }
    uninstallProgressElement() {
      if (this.progressElement.parentNode) {
        document.documentElement.removeChild(this.progressElement);
      }
    }
    startTrickling() {
      if (!this.trickleInterval) {
        this.trickleInterval = window.setInterval(this.trickle, _ProgressBar.animationDuration);
      }
    }
    stopTrickling() {
      window.clearInterval(this.trickleInterval);
      delete this.trickleInterval;
    }
    trickle = () => {
      this.setValue(this.value + Math.random() / 100);
    };
    refresh() {
      requestAnimationFrame(() => {
        this.progressElement.style.width = `${10 + this.value * 90}%`;
      });
    }
    createStylesheetElement() {
      const element = document.createElement("style");
      element.type = "text/css";
      element.textContent = _ProgressBar.defaultCSS;
      if (this.cspNonce) {
        element.nonce = this.cspNonce;
      }
      return element;
    }
    createProgressElement() {
      const element = document.createElement("div");
      element.className = "turbo-progress-bar";
      return element;
    }
    get cspNonce() {
      return getMetaContent("csp-nonce");
    }
  };
  var HeadSnapshot = class extends Snapshot {
    detailsByOuterHTML = this.children.filter((element) => !elementIsNoscript(element)).map((element) => elementWithoutNonce(element)).reduce((result, element) => {
      const { outerHTML } = element;
      const details = outerHTML in result ? result[outerHTML] : {
        type: elementType(element),
        tracked: elementIsTracked(element),
        elements: []
      };
      return {
        ...result,
        [outerHTML]: {
          ...details,
          elements: [...details.elements, element]
        }
      };
    }, {});
    get trackedElementSignature() {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked).join("");
    }
    getScriptElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("script", snapshot);
    }
    getStylesheetElementsNotInSnapshot(snapshot) {
      return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot);
    }
    getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
      return Object.keys(this.detailsByOuterHTML).filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML)).map((outerHTML) => this.detailsByOuterHTML[outerHTML]).filter(({ type }) => type == matchedType).map(({ elements: [element] }) => element);
    }
    get provisionalElements() {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
        if (type == null && !tracked) {
          return [...result, ...elements];
        } else if (elements.length > 1) {
          return [...result, ...elements.slice(1)];
        } else {
          return result;
        }
      }, []);
    }
    getMetaValue(name2) {
      const element = this.findMetaElementByName(name2);
      return element ? element.getAttribute("content") : null;
    }
    findMetaElementByName(name2) {
      return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
        const {
          elements: [element]
        } = this.detailsByOuterHTML[outerHTML];
        return elementIsMetaElementWithName(element, name2) ? element : result;
      }, void 0 | void 0);
    }
  };
  function elementType(element) {
    if (elementIsScript(element)) {
      return "script";
    } else if (elementIsStylesheet(element)) {
      return "stylesheet";
    }
  }
  function elementIsTracked(element) {
    return element.getAttribute("data-turbo-track") == "reload";
  }
  function elementIsScript(element) {
    const tagName = element.localName;
    return tagName == "script";
  }
  function elementIsNoscript(element) {
    const tagName = element.localName;
    return tagName == "noscript";
  }
  function elementIsStylesheet(element) {
    const tagName = element.localName;
    return tagName == "style" || tagName == "link" && element.getAttribute("rel") == "stylesheet";
  }
  function elementIsMetaElementWithName(element, name2) {
    const tagName = element.localName;
    return tagName == "meta" && element.getAttribute("name") == name2;
  }
  function elementWithoutNonce(element) {
    if (element.hasAttribute("nonce")) {
      element.setAttribute("nonce", "");
    }
    return element;
  }
  var PageSnapshot = class _PageSnapshot extends Snapshot {
    static fromHTMLString(html = "") {
      return this.fromDocument(parseHTMLDocument(html));
    }
    static fromElement(element) {
      return this.fromDocument(element.ownerDocument);
    }
    static fromDocument({ documentElement, body, head }) {
      return new this(documentElement, body, new HeadSnapshot(head));
    }
    constructor(documentElement, body, headSnapshot) {
      super(body);
      this.documentElement = documentElement;
      this.headSnapshot = headSnapshot;
    }
    clone() {
      const clonedElement = this.element.cloneNode(true);
      const selectElements = this.element.querySelectorAll("select");
      const clonedSelectElements = clonedElement.querySelectorAll("select");
      for (const [index4, source] of selectElements.entries()) {
        const clone11 = clonedSelectElements[index4];
        for (const option2 of clone11.selectedOptions) option2.selected = false;
        for (const option2 of source.selectedOptions) clone11.options[option2.index].selected = true;
      }
      for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
        clonedPasswordInput.value = "";
      }
      return new _PageSnapshot(this.documentElement, clonedElement, this.headSnapshot);
    }
    get lang() {
      return this.documentElement.getAttribute("lang");
    }
    get headElement() {
      return this.headSnapshot.element;
    }
    get rootLocation() {
      const root2 = this.getSetting("root") ?? "/";
      return expandURL(root2);
    }
    get cacheControlValue() {
      return this.getSetting("cache-control");
    }
    get isPreviewable() {
      return this.cacheControlValue != "no-preview";
    }
    get isCacheable() {
      return this.cacheControlValue != "no-cache";
    }
    get isVisitable() {
      return this.getSetting("visit-control") != "reload";
    }
    get prefersViewTransitions() {
      return this.headSnapshot.getMetaValue("view-transition") === "same-origin";
    }
    get shouldMorphPage() {
      return this.getSetting("refresh-method") === "morph";
    }
    get shouldPreserveScrollPosition() {
      return this.getSetting("refresh-scroll") === "preserve";
    }
    // Private
    getSetting(name2) {
      return this.headSnapshot.getMetaValue(`turbo-${name2}`);
    }
  };
  var ViewTransitioner = class {
    #viewTransitionStarted = false;
    #lastOperation = Promise.resolve();
    renderChange(useViewTransition, render2) {
      if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {
        this.#viewTransitionStarted = true;
        this.#lastOperation = this.#lastOperation.then(async () => {
          await document.startViewTransition(render2).finished;
        });
      } else {
        this.#lastOperation = this.#lastOperation.then(render2);
      }
      return this.#lastOperation;
    }
    get viewTransitionsAvailable() {
      return document.startViewTransition;
    }
  };
  var defaultOptions = {
    action: "advance",
    historyChanged: false,
    visitCachedSnapshot: () => {
    },
    willRender: true,
    updateHistory: true,
    shouldCacheSnapshot: true,
    acceptsStreamResponse: false
  };
  var TimingMetric = {
    visitStart: "visitStart",
    requestStart: "requestStart",
    requestEnd: "requestEnd",
    visitEnd: "visitEnd"
  };
  var VisitState = {
    initialized: "initialized",
    started: "started",
    canceled: "canceled",
    failed: "failed",
    completed: "completed"
  };
  var SystemStatusCode = {
    networkFailure: 0,
    timeoutFailure: -1,
    contentTypeMismatch: -2
  };
  var Direction = {
    advance: "forward",
    restore: "back",
    replace: "none"
  };
  var Visit = class {
    identifier = uuid();
    // Required by turbo-ios
    timingMetrics = {};
    followedRedirect = false;
    historyChanged = false;
    scrolled = false;
    shouldCacheSnapshot = true;
    acceptsStreamResponse = false;
    snapshotCached = false;
    state = VisitState.initialized;
    viewTransitioner = new ViewTransitioner();
    constructor(delegate, location2, restorationIdentifier, options = {}) {
      this.delegate = delegate;
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier || uuid();
      const {
        action,
        historyChanged,
        referrer,
        snapshot,
        snapshotHTML,
        response,
        visitCachedSnapshot,
        willRender,
        updateHistory,
        shouldCacheSnapshot,
        acceptsStreamResponse,
        direction: direction2
      } = {
        ...defaultOptions,
        ...options
      };
      this.action = action;
      this.historyChanged = historyChanged;
      this.referrer = referrer;
      this.snapshot = snapshot;
      this.snapshotHTML = snapshotHTML;
      this.response = response;
      this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
      this.isPageRefresh = this.view.isPageRefresh(this);
      this.visitCachedSnapshot = visitCachedSnapshot;
      this.willRender = willRender;
      this.updateHistory = updateHistory;
      this.scrolled = !willRender;
      this.shouldCacheSnapshot = shouldCacheSnapshot;
      this.acceptsStreamResponse = acceptsStreamResponse;
      this.direction = direction2 || Direction[action];
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get history() {
      return this.delegate.history;
    }
    get restorationData() {
      return this.history.getRestorationDataForIdentifier(this.restorationIdentifier);
    }
    get silent() {
      return this.isSamePage;
    }
    start() {
      if (this.state == VisitState.initialized) {
        this.recordTimingMetric(TimingMetric.visitStart);
        this.state = VisitState.started;
        this.adapter.visitStarted(this);
        this.delegate.visitStarted(this);
      }
    }
    cancel() {
      if (this.state == VisitState.started) {
        if (this.request) {
          this.request.cancel();
        }
        this.cancelRender();
        this.state = VisitState.canceled;
      }
    }
    complete() {
      if (this.state == VisitState.started) {
        this.recordTimingMetric(TimingMetric.visitEnd);
        this.adapter.visitCompleted(this);
        this.state = VisitState.completed;
        this.followRedirect();
        if (!this.followedRedirect) {
          this.delegate.visitCompleted(this);
        }
      }
    }
    fail() {
      if (this.state == VisitState.started) {
        this.state = VisitState.failed;
        this.adapter.visitFailed(this);
        this.delegate.visitCompleted(this);
      }
    }
    changeHistory() {
      if (!this.historyChanged && this.updateHistory) {
        const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
        const method = getHistoryMethodForAction(actionForHistory);
        this.history.update(method, this.location, this.restorationIdentifier);
        this.historyChanged = true;
      }
    }
    issueRequest() {
      if (this.hasPreloadedResponse()) {
        this.simulateRequest();
      } else if (this.shouldIssueRequest() && !this.request) {
        this.request = new FetchRequest(this, FetchMethod.get, this.location);
        this.request.perform();
      }
    }
    simulateRequest() {
      if (this.response) {
        this.startRequest();
        this.recordResponse();
        this.finishRequest();
      }
    }
    startRequest() {
      this.recordTimingMetric(TimingMetric.requestStart);
      this.adapter.visitRequestStarted(this);
    }
    recordResponse(response = this.response) {
      this.response = response;
      if (response) {
        const { statusCode } = response;
        if (isSuccessful(statusCode)) {
          this.adapter.visitRequestCompleted(this);
        } else {
          this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
        }
      }
    }
    finishRequest() {
      this.recordTimingMetric(TimingMetric.requestEnd);
      this.adapter.visitRequestFinished(this);
    }
    loadResponse() {
      if (this.response) {
        const { statusCode, responseHTML } = this.response;
        this.render(async () => {
          if (this.shouldCacheSnapshot) this.cacheSnapshot();
          if (this.view.renderPromise) await this.view.renderPromise;
          if (isSuccessful(statusCode) && responseHTML != null) {
            const snapshot = PageSnapshot.fromHTMLString(responseHTML);
            await this.renderPageSnapshot(snapshot, false);
            this.adapter.visitRendered(this);
            this.complete();
          } else {
            await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
            this.adapter.visitRendered(this);
            this.fail();
          }
        });
      }
    }
    getCachedSnapshot() {
      const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();
      if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
        if (this.action == "restore" || snapshot.isPreviewable) {
          return snapshot;
        }
      }
    }
    getPreloadedSnapshot() {
      if (this.snapshotHTML) {
        return PageSnapshot.fromHTMLString(this.snapshotHTML);
      }
    }
    hasCachedSnapshot() {
      return this.getCachedSnapshot() != null;
    }
    loadCachedSnapshot() {
      const snapshot = this.getCachedSnapshot();
      if (snapshot) {
        const isPreview = this.shouldIssueRequest();
        this.render(async () => {
          this.cacheSnapshot();
          if (this.isSamePage || this.isPageRefresh) {
            this.adapter.visitRendered(this);
          } else {
            if (this.view.renderPromise) await this.view.renderPromise;
            await this.renderPageSnapshot(snapshot, isPreview);
            this.adapter.visitRendered(this);
            if (!isPreview) {
              this.complete();
            }
          }
        });
      }
    }
    followRedirect() {
      if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
        this.adapter.visitProposedToLocation(this.redirectedToLocation, {
          action: "replace",
          response: this.response,
          shouldCacheSnapshot: false,
          willRender: false
        });
        this.followedRedirect = true;
      }
    }
    goToSamePageAnchor() {
      if (this.isSamePage) {
        this.render(async () => {
          this.cacheSnapshot();
          this.performScroll();
          this.changeHistory();
          this.adapter.visitRendered(this);
        });
      }
    }
    // Fetch request delegate
    prepareRequest(request) {
      if (this.acceptsStreamResponse) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted() {
      this.startRequest();
    }
    requestPreventedHandlingResponse(_request, _response) {
    }
    async requestSucceededWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.redirectedToLocation = response.redirected ? response.location : void 0;
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    async requestFailedWithResponse(request, response) {
      const responseHTML = await response.responseHTML;
      const { redirected, statusCode } = response;
      if (responseHTML == void 0) {
        this.recordResponse({
          statusCode: SystemStatusCode.contentTypeMismatch,
          redirected
        });
      } else {
        this.recordResponse({ statusCode, responseHTML, redirected });
      }
    }
    requestErrored(_request, _error) {
      this.recordResponse({
        statusCode: SystemStatusCode.networkFailure,
        redirected: false
      });
    }
    requestFinished() {
      this.finishRequest();
    }
    // Scrolling
    performScroll() {
      if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
        if (this.action == "restore") {
          this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
        } else {
          this.scrollToAnchor() || this.view.scrollToTop();
        }
        if (this.isSamePage) {
          this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
        }
        this.scrolled = true;
      }
    }
    scrollToRestoredPosition() {
      const { scrollPosition } = this.restorationData;
      if (scrollPosition) {
        this.view.scrollToPosition(scrollPosition);
        return true;
      }
    }
    scrollToAnchor() {
      const anchor = getAnchor(this.location);
      if (anchor != null) {
        this.view.scrollToAnchor(anchor);
        return true;
      }
    }
    // Instrumentation
    recordTimingMetric(metric) {
      this.timingMetrics[metric] = (/* @__PURE__ */ new Date()).getTime();
    }
    getTimingMetrics() {
      return { ...this.timingMetrics };
    }
    // Private
    getHistoryMethodForAction(action) {
      switch (action) {
        case "replace":
          return history.replaceState;
        case "advance":
        case "restore":
          return history.pushState;
      }
    }
    hasPreloadedResponse() {
      return typeof this.response == "object";
    }
    shouldIssueRequest() {
      if (this.isSamePage) {
        return false;
      } else if (this.action == "restore") {
        return !this.hasCachedSnapshot();
      } else {
        return this.willRender;
      }
    }
    cacheSnapshot() {
      if (!this.snapshotCached) {
        this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
        this.snapshotCached = true;
      }
    }
    async render(callback) {
      this.cancelRender();
      await new Promise((resolve) => {
        this.frame = document.visibilityState === "hidden" ? setTimeout(() => resolve(), 0) : requestAnimationFrame(() => resolve());
      });
      await callback();
      delete this.frame;
    }
    async renderPageSnapshot(snapshot, isPreview) {
      await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
        await this.view.renderPage(snapshot, isPreview, this.willRender, this);
        this.performScroll();
      });
    }
    cancelRender() {
      if (this.frame) {
        cancelAnimationFrame(this.frame);
        delete this.frame;
      }
    }
  };
  function isSuccessful(statusCode) {
    return statusCode >= 200 && statusCode < 300;
  }
  var BrowserAdapter = class {
    progressBar = new ProgressBar();
    constructor(session2) {
      this.session = session2;
    }
    visitProposedToLocation(location2, options) {
      if (locationIsVisitable(location2, this.navigator.rootLocation)) {
        this.navigator.startVisit(location2, options?.restorationIdentifier || uuid(), options);
      } else {
        window.location.href = location2.toString();
      }
    }
    visitStarted(visit2) {
      this.location = visit2.location;
      visit2.loadCachedSnapshot();
      visit2.issueRequest();
      visit2.goToSamePageAnchor();
    }
    visitRequestStarted(visit2) {
      this.progressBar.setValue(0);
      if (visit2.hasCachedSnapshot() || visit2.action != "restore") {
        this.showVisitProgressBarAfterDelay();
      } else {
        this.showProgressBar();
      }
    }
    visitRequestCompleted(visit2) {
      visit2.loadResponse();
    }
    visitRequestFailedWithStatusCode(visit2, statusCode) {
      switch (statusCode) {
        case SystemStatusCode.networkFailure:
        case SystemStatusCode.timeoutFailure:
        case SystemStatusCode.contentTypeMismatch:
          return this.reload({
            reason: "request_failed",
            context: {
              statusCode
            }
          });
        default:
          return visit2.loadResponse();
      }
    }
    visitRequestFinished(_visit) {
    }
    visitCompleted(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    pageInvalidated(reason) {
      this.reload(reason);
    }
    visitFailed(_visit) {
      this.progressBar.setValue(1);
      this.hideVisitProgressBar();
    }
    visitRendered(_visit) {
    }
    // Form Submission Delegate
    formSubmissionStarted(_formSubmission) {
      this.progressBar.setValue(0);
      this.showFormProgressBarAfterDelay();
    }
    formSubmissionFinished(_formSubmission) {
      this.progressBar.setValue(1);
      this.hideFormProgressBar();
    }
    // Private
    showVisitProgressBarAfterDelay() {
      this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
    hideVisitProgressBar() {
      this.progressBar.hide();
      if (this.visitProgressBarTimeout != null) {
        window.clearTimeout(this.visitProgressBarTimeout);
        delete this.visitProgressBarTimeout;
      }
    }
    showFormProgressBarAfterDelay() {
      if (this.formProgressBarTimeout == null) {
        this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
      }
    }
    hideFormProgressBar() {
      this.progressBar.hide();
      if (this.formProgressBarTimeout != null) {
        window.clearTimeout(this.formProgressBarTimeout);
        delete this.formProgressBarTimeout;
      }
    }
    showProgressBar = () => {
      this.progressBar.show();
    };
    reload(reason) {
      dispatch("turbo:reload", { detail: reason });
      window.location.href = this.location?.toString() || window.location.href;
    }
    get navigator() {
      return this.session.navigator;
    }
  };
  var CacheObserver = class {
    selector = "[data-turbo-temporary]";
    deprecatedSelector = "[data-turbo-cache=false]";
    started = false;
    start() {
      if (!this.started) {
        this.started = true;
        addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
      }
    }
    removeTemporaryElements = (_event) => {
      for (const element of this.temporaryElements) {
        element.remove();
      }
    };
    get temporaryElements() {
      return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation];
    }
    get temporaryElementsWithDeprecation() {
      const elements = document.querySelectorAll(this.deprecatedSelector);
      if (elements.length) {
        console.warn(
          `The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`
        );
      }
      return [...elements];
    }
  };
  var FrameRedirector = class {
    constructor(session2, element) {
      this.session = session2;
      this.element = element;
      this.linkInterceptor = new LinkInterceptor(this, element);
      this.formSubmitObserver = new FormSubmitObserver(this, element);
    }
    start() {
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
    stop() {
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldRedirect(element);
    }
    linkClickIntercepted(element, url, event) {
      const frame2 = this.#findFrameElement(element);
      if (frame2) {
        frame2.delegate.linkClickIntercepted(element, url, event);
      }
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter2) {
      return element.closest("turbo-frame") == null && this.#shouldSubmit(element, submitter2) && this.#shouldRedirect(element, submitter2);
    }
    formSubmitted(element, submitter2) {
      const frame2 = this.#findFrameElement(element, submitter2);
      if (frame2) {
        frame2.delegate.formSubmitted(element, submitter2);
      }
    }
    #shouldSubmit(form, submitter2) {
      const action = getAction$1(form, submitter2);
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const rootLocation = expandURL(meta?.content ?? "/");
      return this.#shouldRedirect(form, submitter2) && locationIsVisitable(action, rootLocation);
    }
    #shouldRedirect(element, submitter2) {
      const isNavigatable = element instanceof HTMLFormElement ? this.session.submissionIsNavigatable(element, submitter2) : this.session.elementIsNavigatable(element);
      if (isNavigatable) {
        const frame2 = this.#findFrameElement(element, submitter2);
        return frame2 ? frame2 != element.closest("turbo-frame") : false;
      } else {
        return false;
      }
    }
    #findFrameElement(element, submitter2) {
      const id4 = submitter2?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
      if (id4 && id4 != "_top") {
        const frame2 = this.element.querySelector(`#${id4}:not([disabled])`);
        if (frame2 instanceof FrameElement) {
          return frame2;
        }
      }
    }
  };
  var History = class {
    location;
    restorationIdentifier = uuid();
    restorationData = {};
    started = false;
    pageLoaded = false;
    currentIndex = 0;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("popstate", this.onPopState, false);
        addEventListener("load", this.onPageLoad, false);
        this.currentIndex = history.state?.turbo?.restorationIndex || 0;
        this.started = true;
        this.replace(new URL(window.location.href));
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("popstate", this.onPopState, false);
        removeEventListener("load", this.onPageLoad, false);
        this.started = false;
      }
    }
    push(location2, restorationIdentifier) {
      this.update(history.pushState, location2, restorationIdentifier);
    }
    replace(location2, restorationIdentifier) {
      this.update(history.replaceState, location2, restorationIdentifier);
    }
    update(method, location2, restorationIdentifier = uuid()) {
      if (method === history.pushState) ++this.currentIndex;
      const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
      method.call(history, state, "", location2.href);
      this.location = location2;
      this.restorationIdentifier = restorationIdentifier;
    }
    // Restoration data
    getRestorationDataForIdentifier(restorationIdentifier) {
      return this.restorationData[restorationIdentifier] || {};
    }
    updateRestorationData(additionalData) {
      const { restorationIdentifier } = this;
      const restorationData = this.restorationData[restorationIdentifier];
      this.restorationData[restorationIdentifier] = {
        ...restorationData,
        ...additionalData
      };
    }
    // Scroll restoration
    assumeControlOfScrollRestoration() {
      if (!this.previousScrollRestoration) {
        this.previousScrollRestoration = history.scrollRestoration ?? "auto";
        history.scrollRestoration = "manual";
      }
    }
    relinquishControlOfScrollRestoration() {
      if (this.previousScrollRestoration) {
        history.scrollRestoration = this.previousScrollRestoration;
        delete this.previousScrollRestoration;
      }
    }
    // Event handlers
    onPopState = (event) => {
      if (this.shouldHandlePopState()) {
        const { turbo } = event.state || {};
        if (turbo) {
          this.location = new URL(window.location.href);
          const { restorationIdentifier, restorationIndex } = turbo;
          this.restorationIdentifier = restorationIdentifier;
          const direction2 = restorationIndex > this.currentIndex ? "forward" : "back";
          this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction2);
          this.currentIndex = restorationIndex;
        }
      }
    };
    onPageLoad = async (_event) => {
      await nextMicrotask();
      this.pageLoaded = true;
    };
    // Private
    shouldHandlePopState() {
      return this.pageIsLoaded();
    }
    pageIsLoaded() {
      return this.pageLoaded || document.readyState == "complete";
    }
  };
  var LinkPrefetchObserver = class {
    started = false;
    #prefetchedLink = null;
    constructor(delegate, eventTarget) {
      this.delegate = delegate;
      this.eventTarget = eventTarget;
    }
    start() {
      if (this.started) return;
      if (this.eventTarget.readyState === "loading") {
        this.eventTarget.addEventListener("DOMContentLoaded", this.#enable, { once: true });
      } else {
        this.#enable();
      }
    }
    stop() {
      if (!this.started) return;
      this.eventTarget.removeEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = false;
    }
    #enable = () => {
      this.eventTarget.addEventListener("mouseenter", this.#tryToPrefetchRequest, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("mouseleave", this.#cancelRequestIfObsolete, {
        capture: true,
        passive: true
      });
      this.eventTarget.addEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
      this.started = true;
    };
    #tryToPrefetchRequest = (event) => {
      if (getMetaContent("turbo-prefetch") === "false") return;
      const target = event.target;
      const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");
      if (isLink && this.#isPrefetchable(target)) {
        const link2 = target;
        const location2 = getLocationForLink(link2);
        if (this.delegate.canPrefetchRequestToLocation(link2, location2)) {
          this.#prefetchedLink = link2;
          const fetchRequest = new FetchRequest(
            this,
            FetchMethod.get,
            location2,
            new URLSearchParams(),
            target
          );
          prefetchCache.setLater(location2.toString(), fetchRequest, this.#cacheTtl);
        }
      }
    };
    #cancelRequestIfObsolete = (event) => {
      if (event.target === this.#prefetchedLink) this.#cancelPrefetchRequest();
    };
    #cancelPrefetchRequest = () => {
      prefetchCache.clear();
      this.#prefetchedLink = null;
    };
    #tryToUsePrefetchedRequest = (event) => {
      if (event.target.tagName !== "FORM" && event.detail.fetchOptions.method === "GET") {
        const cached = prefetchCache.get(event.detail.url.toString());
        if (cached) {
          event.detail.fetchRequest = cached;
        }
        prefetchCache.clear();
      }
    };
    prepareRequest(request) {
      const link2 = request.target;
      request.headers["X-Sec-Purpose"] = "prefetch";
      const turboFrame = link2.closest("turbo-frame");
      const turboFrameTarget = link2.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;
      if (turboFrameTarget && turboFrameTarget !== "_top") {
        request.headers["Turbo-Frame"] = turboFrameTarget;
      }
    }
    // Fetch request interface
    requestSucceededWithResponse() {
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    get #cacheTtl() {
      return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl;
    }
    #isPrefetchable(link2) {
      const href = link2.getAttribute("href");
      if (!href) return false;
      if (unfetchableLink(link2)) return false;
      if (linkToTheSamePage(link2)) return false;
      if (linkOptsOut(link2)) return false;
      if (nonSafeLink(link2)) return false;
      if (eventPrevented(link2)) return false;
      return true;
    }
  };
  var unfetchableLink = (link2) => {
    return link2.origin !== document.location.origin || !["http:", "https:"].includes(link2.protocol) || link2.hasAttribute("target");
  };
  var linkToTheSamePage = (link2) => {
    return link2.pathname + link2.search === document.location.pathname + document.location.search || link2.href.startsWith("#");
  };
  var linkOptsOut = (link2) => {
    if (link2.getAttribute("data-turbo-prefetch") === "false") return true;
    if (link2.getAttribute("data-turbo") === "false") return true;
    const turboPrefetchParent = findClosestRecursively(link2, "[data-turbo-prefetch]");
    if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false") return true;
    return false;
  };
  var nonSafeLink = (link2) => {
    const turboMethod = link2.getAttribute("data-turbo-method");
    if (turboMethod && turboMethod.toLowerCase() !== "get") return true;
    if (isUJS(link2)) return true;
    if (link2.hasAttribute("data-turbo-confirm")) return true;
    if (link2.hasAttribute("data-turbo-stream")) return true;
    return false;
  };
  var isUJS = (link2) => {
    return link2.hasAttribute("data-remote") || link2.hasAttribute("data-behavior") || link2.hasAttribute("data-confirm") || link2.hasAttribute("data-method");
  };
  var eventPrevented = (link2) => {
    const event = dispatch("turbo:before-prefetch", { target: link2, cancelable: true });
    return event.defaultPrevented;
  };
  var Navigator = class {
    constructor(delegate) {
      this.delegate = delegate;
    }
    proposeVisit(location2, options = {}) {
      if (this.delegate.allowsVisitingLocationWithAction(location2, options.action)) {
        this.delegate.visitProposedToLocation(location2, options);
      }
    }
    startVisit(locatable, restorationIdentifier, options = {}) {
      this.stop();
      this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
        referrer: this.location,
        ...options
      });
      this.currentVisit.start();
    }
    submitForm(form, submitter2) {
      this.stop();
      this.formSubmission = new FormSubmission(this, form, submitter2, true);
      this.formSubmission.start();
    }
    stop() {
      if (this.formSubmission) {
        this.formSubmission.stop();
        delete this.formSubmission;
      }
      if (this.currentVisit) {
        this.currentVisit.cancel();
        delete this.currentVisit;
      }
    }
    get adapter() {
      return this.delegate.adapter;
    }
    get view() {
      return this.delegate.view;
    }
    get rootLocation() {
      return this.view.snapshot.rootLocation;
    }
    get history() {
      return this.delegate.history;
    }
    // Form submission delegate
    formSubmissionStarted(formSubmission) {
      if (typeof this.adapter.formSubmissionStarted === "function") {
        this.adapter.formSubmissionStarted(formSubmission);
      }
    }
    async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
      if (formSubmission == this.formSubmission) {
        const responseHTML = await fetchResponse.responseHTML;
        if (responseHTML) {
          const shouldCacheSnapshot = formSubmission.isSafe;
          if (!shouldCacheSnapshot) {
            this.view.clearSnapshotCache();
          }
          const { statusCode, redirected } = fetchResponse;
          const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);
          const visitOptions = {
            action,
            shouldCacheSnapshot,
            response: { statusCode, responseHTML, redirected }
          };
          this.proposeVisit(fetchResponse.location, visitOptions);
        }
      }
    }
    async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        if (fetchResponse.serverError) {
          await this.view.renderError(snapshot, this.currentVisit);
        } else {
          await this.view.renderPage(snapshot, false, true, this.currentVisit);
        }
        if (!snapshot.shouldPreserveScrollPosition) {
          this.view.scrollToTop();
        }
        this.view.clearSnapshotCache();
      }
    }
    formSubmissionErrored(formSubmission, error4) {
      console.error(error4);
    }
    formSubmissionFinished(formSubmission) {
      if (typeof this.adapter.formSubmissionFinished === "function") {
        this.adapter.formSubmissionFinished(formSubmission);
      }
    }
    // Visit delegate
    visitStarted(visit2) {
      this.delegate.visitStarted(visit2);
    }
    visitCompleted(visit2) {
      this.delegate.visitCompleted(visit2);
      delete this.currentVisit;
    }
    locationWithActionIsSamePage(location2, action) {
      const anchor = getAnchor(location2);
      const currentAnchor = getAnchor(this.view.lastRenderedLocation);
      const isRestorationToTop = action === "restore" && typeof anchor === "undefined";
      return action !== "replace" && getRequestURL(location2) === getRequestURL(this.view.lastRenderedLocation) && (isRestorationToTop || anchor != null && anchor !== currentAnchor);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
    }
    // Visits
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    #getActionForFormSubmission(formSubmission, fetchResponse) {
      const { submitter: submitter2, formElement } = formSubmission;
      return getVisitAction(submitter2, formElement) || this.#getDefaultAction(fetchResponse);
    }
    #getDefaultAction(fetchResponse) {
      const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
      return sameLocationRedirect ? "replace" : "advance";
    }
  };
  var PageStage = {
    initial: 0,
    loading: 1,
    interactive: 2,
    complete: 3
  };
  var PageObserver = class {
    stage = PageStage.initial;
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        if (this.stage == PageStage.initial) {
          this.stage = PageStage.loading;
        }
        document.addEventListener("readystatechange", this.interpretReadyState, false);
        addEventListener("pagehide", this.pageWillUnload, false);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        document.removeEventListener("readystatechange", this.interpretReadyState, false);
        removeEventListener("pagehide", this.pageWillUnload, false);
        this.started = false;
      }
    }
    interpretReadyState = () => {
      const { readyState } = this;
      if (readyState == "interactive") {
        this.pageIsInteractive();
      } else if (readyState == "complete") {
        this.pageIsComplete();
      }
    };
    pageIsInteractive() {
      if (this.stage == PageStage.loading) {
        this.stage = PageStage.interactive;
        this.delegate.pageBecameInteractive();
      }
    }
    pageIsComplete() {
      this.pageIsInteractive();
      if (this.stage == PageStage.interactive) {
        this.stage = PageStage.complete;
        this.delegate.pageLoaded();
      }
    }
    pageWillUnload = () => {
      this.delegate.pageWillUnload();
    };
    get readyState() {
      return document.readyState;
    }
  };
  var ScrollObserver = class {
    started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.started) {
        addEventListener("scroll", this.onScroll, false);
        this.onScroll();
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        removeEventListener("scroll", this.onScroll, false);
        this.started = false;
      }
    }
    onScroll = () => {
      this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
    };
    // Private
    updatePosition(position) {
      this.delegate.scrollPositionChanged(position);
    }
  };
  var StreamMessageRenderer = class {
    render({ fragment }) {
      Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
        withAutofocusFromFragment(fragment, () => {
          withPreservedFocus(() => {
            document.documentElement.appendChild(fragment);
          });
        });
      });
    }
    // Bardo delegate
    enteringBardo(currentPermanentElement, newPermanentElement) {
      newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
    }
    leavingBardo() {
    }
  };
  function getPermanentElementMapForFragment(fragment) {
    const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
    const permanentElementMap = {};
    for (const permanentElementInDocument of permanentElementsInDocument) {
      const { id: id4 } = permanentElementInDocument;
      for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
        const elementInStream = getPermanentElementById(streamElement.templateElement.content, id4);
        if (elementInStream) {
          permanentElementMap[id4] = [permanentElementInDocument, elementInStream];
        }
      }
    }
    return permanentElementMap;
  }
  async function withAutofocusFromFragment(fragment, callback) {
    const generatedID = `turbo-stream-autofocus-${uuid()}`;
    const turboStreams = fragment.querySelectorAll("turbo-stream");
    const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
    let willAutofocusId = null;
    if (elementWithAutofocus) {
      if (elementWithAutofocus.id) {
        willAutofocusId = elementWithAutofocus.id;
      } else {
        willAutofocusId = generatedID;
      }
      elementWithAutofocus.id = willAutofocusId;
    }
    callback();
    await nextRepaint();
    const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;
    if (hasNoActiveElement && willAutofocusId) {
      const elementToAutofocus = document.getElementById(willAutofocusId);
      if (elementIsFocusable(elementToAutofocus)) {
        elementToAutofocus.focus();
      }
      if (elementToAutofocus && elementToAutofocus.id == generatedID) {
        elementToAutofocus.removeAttribute("id");
      }
    }
  }
  async function withPreservedFocus(callback) {
    const [activeElementBeforeRender, activeElementAfterRender] = await around(callback, () => document.activeElement);
    const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;
    if (restoreFocusTo) {
      const elementToFocus = document.getElementById(restoreFocusTo);
      if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
        elementToFocus.focus();
      }
    }
  }
  function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
    for (const streamElement of nodeListOfStreamElements) {
      const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);
      if (elementWithAutofocus) return elementWithAutofocus;
    }
    return null;
  }
  var StreamObserver = class {
    sources = /* @__PURE__ */ new Set();
    #started = false;
    constructor(delegate) {
      this.delegate = delegate;
    }
    start() {
      if (!this.#started) {
        this.#started = true;
        addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    stop() {
      if (this.#started) {
        this.#started = false;
        removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
      }
    }
    connectStreamSource(source) {
      if (!this.streamSourceIsConnected(source)) {
        this.sources.add(source);
        source.addEventListener("message", this.receiveMessageEvent, false);
      }
    }
    disconnectStreamSource(source) {
      if (this.streamSourceIsConnected(source)) {
        this.sources.delete(source);
        source.removeEventListener("message", this.receiveMessageEvent, false);
      }
    }
    streamSourceIsConnected(source) {
      return this.sources.has(source);
    }
    inspectFetchResponse = (event) => {
      const response = fetchResponseFromEvent(event);
      if (response && fetchResponseIsStream(response)) {
        event.preventDefault();
        this.receiveMessageResponse(response);
      }
    };
    receiveMessageEvent = (event) => {
      if (this.#started && typeof event.data == "string") {
        this.receiveMessageHTML(event.data);
      }
    };
    async receiveMessageResponse(response) {
      const html = await response.responseHTML;
      if (html) {
        this.receiveMessageHTML(html);
      }
    }
    receiveMessageHTML(html) {
      this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
    }
  };
  function fetchResponseFromEvent(event) {
    const fetchResponse = event.detail?.fetchResponse;
    if (fetchResponse instanceof FetchResponse) {
      return fetchResponse;
    }
  }
  function fetchResponseIsStream(response) {
    const contentType = response.contentType ?? "";
    return contentType.startsWith(StreamMessage.contentType);
  }
  var ErrorRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      const { documentElement, body } = document;
      documentElement.replaceChild(newElement, body);
    }
    async render() {
      this.replaceHeadAndBody();
      this.activateScriptElements();
    }
    replaceHeadAndBody() {
      const { documentElement, head } = document;
      documentElement.replaceChild(this.newHead, head);
      this.renderElement(this.currentElement, this.newElement);
    }
    activateScriptElements() {
      for (const replaceableElement of this.scriptElements) {
        const parentNode = replaceableElement.parentNode;
        if (parentNode) {
          const element = activateScriptElement(replaceableElement);
          parentNode.replaceChild(element, replaceableElement);
        }
      }
    }
    get newHead() {
      return this.newSnapshot.headSnapshot.element;
    }
    get scriptElements() {
      return document.documentElement.querySelectorAll("script");
    }
  };
  var PageRenderer = class extends Renderer {
    static renderElement(currentElement, newElement) {
      if (document.body && newElement instanceof HTMLBodyElement) {
        document.body.replaceWith(newElement);
      } else {
        document.documentElement.appendChild(newElement);
      }
    }
    get shouldRender() {
      return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical;
    }
    get reloadReason() {
      if (!this.newSnapshot.isVisitable) {
        return {
          reason: "turbo_visit_control_is_reload"
        };
      }
      if (!this.trackedElementsAreIdentical) {
        return {
          reason: "tracked_element_mismatch"
        };
      }
    }
    async prepareToRender() {
      this.#setLanguage();
      await this.mergeHead();
    }
    async render() {
      if (this.willRender) {
        await this.replaceBody();
      }
    }
    finishRendering() {
      super.finishRendering();
      if (!this.isPreview) {
        this.focusFirstAutofocusableElement();
      }
    }
    get currentHeadSnapshot() {
      return this.currentSnapshot.headSnapshot;
    }
    get newHeadSnapshot() {
      return this.newSnapshot.headSnapshot;
    }
    get newElement() {
      return this.newSnapshot.element;
    }
    #setLanguage() {
      const { documentElement } = this.currentSnapshot;
      const { lang } = this.newSnapshot;
      if (lang) {
        documentElement.setAttribute("lang", lang);
      } else {
        documentElement.removeAttribute("lang");
      }
    }
    async mergeHead() {
      const mergedHeadElements = this.mergeProvisionalElements();
      const newStylesheetElements = this.copyNewHeadStylesheetElements();
      this.copyNewHeadScriptElements();
      await mergedHeadElements;
      await newStylesheetElements;
      if (this.willRender) {
        this.removeUnusedDynamicStylesheetElements();
      }
    }
    async replaceBody() {
      await this.preservingPermanentElements(async () => {
        this.activateNewBody();
        await this.assignNewBody();
      });
    }
    get trackedElementsAreIdentical() {
      return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature;
    }
    async copyNewHeadStylesheetElements() {
      const loadingElements = [];
      for (const element of this.newHeadStylesheetElements) {
        loadingElements.push(waitForLoad(element));
        document.head.appendChild(element);
      }
      await Promise.all(loadingElements);
    }
    copyNewHeadScriptElements() {
      for (const element of this.newHeadScriptElements) {
        document.head.appendChild(activateScriptElement(element));
      }
    }
    removeUnusedDynamicStylesheetElements() {
      for (const element of this.unusedDynamicStylesheetElements) {
        document.head.removeChild(element);
      }
    }
    async mergeProvisionalElements() {
      const newHeadElements = [...this.newHeadProvisionalElements];
      for (const element of this.currentHeadProvisionalElements) {
        if (!this.isCurrentElementInElementList(element, newHeadElements)) {
          document.head.removeChild(element);
        }
      }
      for (const element of newHeadElements) {
        document.head.appendChild(element);
      }
    }
    isCurrentElementInElementList(element, elementList) {
      for (const [index4, newElement] of elementList.entries()) {
        if (element.tagName == "TITLE") {
          if (newElement.tagName != "TITLE") {
            continue;
          }
          if (element.innerHTML == newElement.innerHTML) {
            elementList.splice(index4, 1);
            return true;
          }
        }
        if (newElement.isEqualNode(element)) {
          elementList.splice(index4, 1);
          return true;
        }
      }
      return false;
    }
    removeCurrentHeadProvisionalElements() {
      for (const element of this.currentHeadProvisionalElements) {
        document.head.removeChild(element);
      }
    }
    copyNewHeadProvisionalElements() {
      for (const element of this.newHeadProvisionalElements) {
        document.head.appendChild(element);
      }
    }
    activateNewBody() {
      document.adoptNode(this.newElement);
      this.activateNewBodyScriptElements();
    }
    activateNewBodyScriptElements() {
      for (const inertScriptElement of this.newBodyScriptElements) {
        const activatedScriptElement = activateScriptElement(inertScriptElement);
        inertScriptElement.replaceWith(activatedScriptElement);
      }
    }
    async assignNewBody() {
      await this.renderElement(this.currentElement, this.newElement);
    }
    get unusedDynamicStylesheetElements() {
      return this.oldHeadStylesheetElements.filter((element) => {
        return element.getAttribute("data-turbo-track") === "dynamic";
      });
    }
    get oldHeadStylesheetElements() {
      return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot);
    }
    get newHeadStylesheetElements() {
      return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get newHeadScriptElements() {
      return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot);
    }
    get currentHeadProvisionalElements() {
      return this.currentHeadSnapshot.provisionalElements;
    }
    get newHeadProvisionalElements() {
      return this.newHeadSnapshot.provisionalElements;
    }
    get newBodyScriptElements() {
      return this.newElement.querySelectorAll("script");
    }
  };
  var MorphingPageRenderer = class extends PageRenderer {
    static renderElement(currentElement, newElement) {
      morphElements(currentElement, newElement, {
        callbacks: {
          beforeNodeMorphed: (element) => !canRefreshFrame(element)
        }
      });
      for (const frame2 of currentElement.querySelectorAll("turbo-frame")) {
        if (canRefreshFrame(frame2)) frame2.reload();
      }
      dispatch("turbo:morph", { detail: { currentElement, newElement } });
    }
    async preservingPermanentElements(callback) {
      return await callback();
    }
    get renderMethod() {
      return "morph";
    }
    get shouldAutofocus() {
      return false;
    }
  };
  function canRefreshFrame(frame2) {
    return frame2 instanceof FrameElement && frame2.src && frame2.refresh === "morph" && !frame2.closest("[data-turbo-permanent]");
  }
  var SnapshotCache = class {
    keys = [];
    snapshots = {};
    constructor(size2) {
      this.size = size2;
    }
    has(location2) {
      return toCacheKey(location2) in this.snapshots;
    }
    get(location2) {
      if (this.has(location2)) {
        const snapshot = this.read(location2);
        this.touch(location2);
        return snapshot;
      }
    }
    put(location2, snapshot) {
      this.write(location2, snapshot);
      this.touch(location2);
      return snapshot;
    }
    clear() {
      this.snapshots = {};
    }
    // Private
    read(location2) {
      return this.snapshots[toCacheKey(location2)];
    }
    write(location2, snapshot) {
      this.snapshots[toCacheKey(location2)] = snapshot;
    }
    touch(location2) {
      const key = toCacheKey(location2);
      const index4 = this.keys.indexOf(key);
      if (index4 > -1) this.keys.splice(index4, 1);
      this.keys.unshift(key);
      this.trim();
    }
    trim() {
      for (const key of this.keys.splice(this.size)) {
        delete this.snapshots[key];
      }
    }
  };
  var PageView = class extends View {
    snapshotCache = new SnapshotCache(10);
    lastRenderedLocation = new URL(location.href);
    forceReloaded = false;
    shouldTransitionTo(newSnapshot) {
      return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions;
    }
    renderPage(snapshot, isPreview = false, willRender = true, visit2) {
      const shouldMorphPage = this.isPageRefresh(visit2) && this.snapshot.shouldMorphPage;
      const rendererClass = shouldMorphPage ? MorphingPageRenderer : PageRenderer;
      const renderer = new rendererClass(this.snapshot, snapshot, isPreview, willRender);
      if (!renderer.shouldRender) {
        this.forceReloaded = true;
      } else {
        visit2?.changeHistory();
      }
      return this.render(renderer);
    }
    renderError(snapshot, visit2) {
      visit2?.changeHistory();
      const renderer = new ErrorRenderer(this.snapshot, snapshot, false);
      return this.render(renderer);
    }
    clearSnapshotCache() {
      this.snapshotCache.clear();
    }
    async cacheSnapshot(snapshot = this.snapshot) {
      if (snapshot.isCacheable) {
        this.delegate.viewWillCacheSnapshot();
        const { lastRenderedLocation: location2 } = this;
        await nextEventLoopTick();
        const cachedSnapshot = snapshot.clone();
        this.snapshotCache.put(location2, cachedSnapshot);
        return cachedSnapshot;
      }
    }
    getCachedSnapshotForLocation(location2) {
      return this.snapshotCache.get(location2);
    }
    isPageRefresh(visit2) {
      return !visit2 || this.lastRenderedLocation.pathname === visit2.location.pathname && visit2.action === "replace";
    }
    shouldPreserveScrollPosition(visit2) {
      return this.isPageRefresh(visit2) && this.snapshot.shouldPreserveScrollPosition;
    }
    get snapshot() {
      return PageSnapshot.fromElement(this.element);
    }
  };
  var Preloader = class {
    selector = "a[data-turbo-preload]";
    constructor(delegate, snapshotCache) {
      this.delegate = delegate;
      this.snapshotCache = snapshotCache;
    }
    start() {
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", this.#preloadAll);
      } else {
        this.preloadOnLoadLinksForView(document.body);
      }
    }
    stop() {
      document.removeEventListener("DOMContentLoaded", this.#preloadAll);
    }
    preloadOnLoadLinksForView(element) {
      for (const link2 of element.querySelectorAll(this.selector)) {
        if (this.delegate.shouldPreloadLink(link2)) {
          this.preloadURL(link2);
        }
      }
    }
    async preloadURL(link2) {
      const location2 = new URL(link2.href);
      if (this.snapshotCache.has(location2)) {
        return;
      }
      const fetchRequest = new FetchRequest(this, FetchMethod.get, location2, new URLSearchParams(), link2);
      await fetchRequest.perform();
    }
    // Fetch request delegate
    prepareRequest(fetchRequest) {
      fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
    }
    async requestSucceededWithResponse(fetchRequest, fetchResponse) {
      try {
        const responseHTML = await fetchResponse.responseHTML;
        const snapshot = PageSnapshot.fromHTMLString(responseHTML);
        this.snapshotCache.put(fetchRequest.url, snapshot);
      } catch (_2) {
      }
    }
    requestStarted(fetchRequest) {
    }
    requestErrored(fetchRequest) {
    }
    requestFinished(fetchRequest) {
    }
    requestPreventedHandlingResponse(fetchRequest, fetchResponse) {
    }
    requestFailedWithResponse(fetchRequest, fetchResponse) {
    }
    #preloadAll = () => {
      this.preloadOnLoadLinksForView(document.body);
    };
  };
  var Cache = class {
    constructor(session2) {
      this.session = session2;
    }
    clear() {
      this.session.clearCache();
    }
    resetCacheControl() {
      this.#setCacheControl("");
    }
    exemptPageFromCache() {
      this.#setCacheControl("no-cache");
    }
    exemptPageFromPreview() {
      this.#setCacheControl("no-preview");
    }
    #setCacheControl(value2) {
      setMetaContent("turbo-cache-control", value2);
    }
  };
  var Session = class {
    navigator = new Navigator(this);
    history = new History(this);
    view = new PageView(this, document.documentElement);
    adapter = new BrowserAdapter(this);
    pageObserver = new PageObserver(this);
    cacheObserver = new CacheObserver();
    linkPrefetchObserver = new LinkPrefetchObserver(this, document);
    linkClickObserver = new LinkClickObserver(this, window);
    formSubmitObserver = new FormSubmitObserver(this, document);
    scrollObserver = new ScrollObserver(this);
    streamObserver = new StreamObserver(this);
    formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement);
    frameRedirector = new FrameRedirector(this, document.documentElement);
    streamMessageRenderer = new StreamMessageRenderer();
    cache = new Cache(this);
    enabled = true;
    started = false;
    #pageRefreshDebouncePeriod = 150;
    constructor(recentRequests2) {
      this.recentRequests = recentRequests2;
      this.preloader = new Preloader(this, this.view.snapshotCache);
      this.debouncedRefresh = this.refresh;
      this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
    }
    start() {
      if (!this.started) {
        this.pageObserver.start();
        this.cacheObserver.start();
        this.linkPrefetchObserver.start();
        this.formLinkClickObserver.start();
        this.linkClickObserver.start();
        this.formSubmitObserver.start();
        this.scrollObserver.start();
        this.streamObserver.start();
        this.frameRedirector.start();
        this.history.start();
        this.preloader.start();
        this.started = true;
        this.enabled = true;
      }
    }
    disable() {
      this.enabled = false;
    }
    stop() {
      if (this.started) {
        this.pageObserver.stop();
        this.cacheObserver.stop();
        this.linkPrefetchObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkClickObserver.stop();
        this.formSubmitObserver.stop();
        this.scrollObserver.stop();
        this.streamObserver.stop();
        this.frameRedirector.stop();
        this.history.stop();
        this.preloader.stop();
        this.started = false;
      }
    }
    registerAdapter(adapter) {
      this.adapter = adapter;
    }
    visit(location2, options = {}) {
      const frameElement = options.frame ? document.getElementById(options.frame) : null;
      if (frameElement instanceof FrameElement) {
        const action = options.action || getVisitAction(frameElement);
        frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
        frameElement.src = location2.toString();
      } else {
        this.navigator.proposeVisit(expandURL(location2), options);
      }
    }
    refresh(url, requestId) {
      const isRecentRequest = requestId && this.recentRequests.has(requestId);
      if (!isRecentRequest && !this.navigator.currentVisit) {
        this.visit(url, { action: "replace", shouldCacheSnapshot: false });
      }
    }
    connectStreamSource(source) {
      this.streamObserver.connectStreamSource(source);
    }
    disconnectStreamSource(source) {
      this.streamObserver.disconnectStreamSource(source);
    }
    renderStreamMessage(message) {
      this.streamMessageRenderer.render(StreamMessage.wrap(message));
    }
    clearCache() {
      this.view.clearSnapshotCache();
    }
    setProgressBarDelay(delay) {
      console.warn(
        "Please replace `session.setProgressBarDelay(delay)` with `session.progressBarDelay = delay`. The function is deprecated and will be removed in a future version of Turbo.`"
      );
      this.progressBarDelay = delay;
    }
    set progressBarDelay(delay) {
      config.drive.progressBarDelay = delay;
    }
    get progressBarDelay() {
      return config.drive.progressBarDelay;
    }
    set drive(value2) {
      config.drive.enabled = value2;
    }
    get drive() {
      return config.drive.enabled;
    }
    set formMode(value2) {
      config.forms.mode = value2;
    }
    get formMode() {
      return config.forms.mode;
    }
    get location() {
      return this.history.location;
    }
    get restorationIdentifier() {
      return this.history.restorationIdentifier;
    }
    get pageRefreshDebouncePeriod() {
      return this.#pageRefreshDebouncePeriod;
    }
    set pageRefreshDebouncePeriod(value2) {
      this.refresh = debounce(this.debouncedRefresh.bind(this), value2);
      this.#pageRefreshDebouncePeriod = value2;
    }
    // Preloader delegate
    shouldPreloadLink(element) {
      const isUnsafe = element.hasAttribute("data-turbo-method");
      const isStream = element.hasAttribute("data-turbo-stream");
      const frameTarget = element.getAttribute("data-turbo-frame");
      const frame2 = frameTarget == "_top" ? null : document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");
      if (isUnsafe || isStream || frame2 instanceof FrameElement) {
        return false;
      } else {
        const location2 = new URL(element.href);
        return this.elementIsNavigatable(element) && locationIsVisitable(location2, this.snapshot.rootLocation);
      }
    }
    // History delegate
    historyPoppedToLocationWithRestorationIdentifierAndDirection(location2, restorationIdentifier, direction2) {
      if (this.enabled) {
        this.navigator.startVisit(location2, restorationIdentifier, {
          action: "restore",
          historyChanged: true,
          direction: direction2
        });
      } else {
        this.adapter.pageInvalidated({
          reason: "turbo_disabled"
        });
      }
    }
    // Scroll observer delegate
    scrollPositionChanged(position) {
      this.history.updateRestorationData({ scrollPosition: position });
    }
    // Form click observer delegate
    willSubmitFormLinkToLocation(link2, location2) {
      return this.elementIsNavigatable(link2) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    submittedFormLinkToLocation() {
    }
    // Link hover observer delegate
    canPrefetchRequestToLocation(link2, location2) {
      return this.elementIsNavigatable(link2) && locationIsVisitable(location2, this.snapshot.rootLocation);
    }
    // Link click observer delegate
    willFollowLinkToLocation(link2, location2, event) {
      return this.elementIsNavigatable(link2) && locationIsVisitable(location2, this.snapshot.rootLocation) && this.applicationAllowsFollowingLinkToLocation(link2, location2, event);
    }
    followedLinkToLocation(link2, location2) {
      const action = this.getActionForLink(link2);
      const acceptsStreamResponse = link2.hasAttribute("data-turbo-stream");
      this.visit(location2.href, { action, acceptsStreamResponse });
    }
    // Navigator delegate
    allowsVisitingLocationWithAction(location2, action) {
      return this.locationWithActionIsSamePage(location2, action) || this.applicationAllowsVisitingLocation(location2);
    }
    visitProposedToLocation(location2, options) {
      extendURLWithDeprecatedProperties(location2);
      this.adapter.visitProposedToLocation(location2, options);
    }
    // Visit delegate
    visitStarted(visit2) {
      if (!visit2.acceptsStreamResponse) {
        markAsBusy(document.documentElement);
        this.view.markVisitDirection(visit2.direction);
      }
      extendURLWithDeprecatedProperties(visit2.location);
      if (!visit2.silent) {
        this.notifyApplicationAfterVisitingLocation(visit2.location, visit2.action);
      }
    }
    visitCompleted(visit2) {
      this.view.unmarkVisitDirection();
      clearBusyState(document.documentElement);
      this.notifyApplicationAfterPageLoad(visit2.getTimingMetrics());
    }
    locationWithActionIsSamePage(location2, action) {
      return this.navigator.locationWithActionIsSamePage(location2, action);
    }
    visitScrolledToSamePageLocation(oldURL, newURL) {
      this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
    }
    // Form submit observer delegate
    willSubmitForm(form, submitter2) {
      const action = getAction$1(form, submitter2);
      return this.submissionIsNavigatable(form, submitter2) && locationIsVisitable(expandURL(action), this.snapshot.rootLocation);
    }
    formSubmitted(form, submitter2) {
      this.navigator.submitForm(form, submitter2);
    }
    // Page observer delegate
    pageBecameInteractive() {
      this.view.lastRenderedLocation = this.location;
      this.notifyApplicationAfterPageLoad();
    }
    pageLoaded() {
      this.history.assumeControlOfScrollRestoration();
    }
    pageWillUnload() {
      this.history.relinquishControlOfScrollRestoration();
    }
    // Stream observer delegate
    receivedMessageFromStream(message) {
      this.renderStreamMessage(message);
    }
    // Page view delegate
    viewWillCacheSnapshot() {
      if (!this.navigator.currentVisit?.silent) {
        this.notifyApplicationBeforeCachingSnapshot();
      }
    }
    allowsImmediateRender({ element }, options) {
      const event = this.notifyApplicationBeforeRender(element, options);
      const {
        defaultPrevented,
        detail: { render: render2 }
      } = event;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
      this.view.lastRenderedLocation = this.history.location;
      this.notifyApplicationAfterRender(renderMethod);
    }
    preloadOnLoadLinksForView(element) {
      this.preloader.preloadOnLoadLinksForView(element);
    }
    viewInvalidated(reason) {
      this.adapter.pageInvalidated(reason);
    }
    // Frame element
    frameLoaded(frame2) {
      this.notifyApplicationAfterFrameLoad(frame2);
    }
    frameRendered(fetchResponse, frame2) {
      this.notifyApplicationAfterFrameRender(fetchResponse, frame2);
    }
    // Application events
    applicationAllowsFollowingLinkToLocation(link2, location2, ev) {
      const event = this.notifyApplicationAfterClickingLinkToLocation(link2, location2, ev);
      return !event.defaultPrevented;
    }
    applicationAllowsVisitingLocation(location2) {
      const event = this.notifyApplicationBeforeVisitingLocation(location2);
      return !event.defaultPrevented;
    }
    notifyApplicationAfterClickingLinkToLocation(link2, location2, event) {
      return dispatch("turbo:click", {
        target: link2,
        detail: { url: location2.href, originalEvent: event },
        cancelable: true
      });
    }
    notifyApplicationBeforeVisitingLocation(location2) {
      return dispatch("turbo:before-visit", {
        detail: { url: location2.href },
        cancelable: true
      });
    }
    notifyApplicationAfterVisitingLocation(location2, action) {
      return dispatch("turbo:visit", { detail: { url: location2.href, action } });
    }
    notifyApplicationBeforeCachingSnapshot() {
      return dispatch("turbo:before-cache");
    }
    notifyApplicationBeforeRender(newBody, options) {
      return dispatch("turbo:before-render", {
        detail: { newBody, ...options },
        cancelable: true
      });
    }
    notifyApplicationAfterRender(renderMethod) {
      return dispatch("turbo:render", { detail: { renderMethod } });
    }
    notifyApplicationAfterPageLoad(timing = {}) {
      return dispatch("turbo:load", {
        detail: { url: this.location.href, timing }
      });
    }
    notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
      dispatchEvent(
        new HashChangeEvent("hashchange", {
          oldURL: oldURL.toString(),
          newURL: newURL.toString()
        })
      );
    }
    notifyApplicationAfterFrameLoad(frame2) {
      return dispatch("turbo:frame-load", { target: frame2 });
    }
    notifyApplicationAfterFrameRender(fetchResponse, frame2) {
      return dispatch("turbo:frame-render", {
        detail: { fetchResponse },
        target: frame2,
        cancelable: true
      });
    }
    // Helpers
    submissionIsNavigatable(form, submitter2) {
      if (config.forms.mode == "off") {
        return false;
      } else {
        const submitterIsNavigatable = submitter2 ? this.elementIsNavigatable(submitter2) : true;
        if (config.forms.mode == "optin") {
          return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null;
        } else {
          return submitterIsNavigatable && this.elementIsNavigatable(form);
        }
      }
    }
    elementIsNavigatable(element) {
      const container = findClosestRecursively(element, "[data-turbo]");
      const withinFrame = findClosestRecursively(element, "turbo-frame");
      if (config.drive.enabled || withinFrame) {
        if (container) {
          return container.getAttribute("data-turbo") != "false";
        } else {
          return true;
        }
      } else {
        if (container) {
          return container.getAttribute("data-turbo") == "true";
        } else {
          return false;
        }
      }
    }
    // Private
    getActionForLink(link2) {
      return getVisitAction(link2) || "advance";
    }
    get snapshot() {
      return this.view.snapshot;
    }
  };
  function extendURLWithDeprecatedProperties(url) {
    Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
  }
  var deprecatedLocationPropertyDescriptors = {
    absoluteURL: {
      get() {
        return this.toString();
      }
    }
  };
  var session = new Session(recentRequests);
  var { cache, navigator: navigator$1 } = session;
  function start() {
    session.start();
  }
  function registerAdapter(adapter) {
    session.registerAdapter(adapter);
  }
  function visit(location2, options) {
    session.visit(location2, options);
  }
  function connectStreamSource(source) {
    session.connectStreamSource(source);
  }
  function disconnectStreamSource(source) {
    session.disconnectStreamSource(source);
  }
  function renderStreamMessage(message) {
    session.renderStreamMessage(message);
  }
  function clearCache() {
    console.warn(
      "Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    session.clearCache();
  }
  function setProgressBarDelay(delay) {
    console.warn(
      "Please replace `Turbo.setProgressBarDelay(delay)` with `Turbo.config.drive.progressBarDelay = delay`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    config.drive.progressBarDelay = delay;
  }
  function setConfirmMethod(confirmMethod) {
    console.warn(
      "Please replace `Turbo.setConfirmMethod(confirmMethod)` with `Turbo.config.forms.confirm = confirmMethod`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    config.forms.confirm = confirmMethod;
  }
  function setFormMode(mode) {
    console.warn(
      "Please replace `Turbo.setFormMode(mode)` with `Turbo.config.forms.mode = mode`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
    );
    config.forms.mode = mode;
  }
  var Turbo2 = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    navigator: navigator$1,
    session,
    cache,
    PageRenderer,
    PageSnapshot,
    FrameRenderer,
    fetch: fetchWithTurboHeaders,
    config,
    start,
    registerAdapter,
    visit,
    connectStreamSource,
    disconnectStreamSource,
    renderStreamMessage,
    clearCache,
    setProgressBarDelay,
    setConfirmMethod,
    setFormMode
  });
  var TurboFrameMissingError = class extends Error {
  };
  var FrameController = class {
    fetchResponseLoaded = (_fetchResponse) => Promise.resolve();
    #currentFetchRequest = null;
    #resolveVisitPromise = () => {
    };
    #connected = false;
    #hasBeenLoaded = false;
    #ignoredAttributes = /* @__PURE__ */ new Set();
    #shouldMorphFrame = false;
    action = null;
    constructor(element) {
      this.element = element;
      this.view = new FrameView(this, this.element);
      this.appearanceObserver = new AppearanceObserver(this, this.element);
      this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
      this.linkInterceptor = new LinkInterceptor(this, this.element);
      this.restorationIdentifier = uuid();
      this.formSubmitObserver = new FormSubmitObserver(this, this.element);
    }
    // Frame delegate
    connect() {
      if (!this.#connected) {
        this.#connected = true;
        if (this.loadingStyle == FrameLoadingStyle.lazy) {
          this.appearanceObserver.start();
        } else {
          this.#loadSourceURL();
        }
        this.formLinkClickObserver.start();
        this.linkInterceptor.start();
        this.formSubmitObserver.start();
      }
    }
    disconnect() {
      if (this.#connected) {
        this.#connected = false;
        this.appearanceObserver.stop();
        this.formLinkClickObserver.stop();
        this.linkInterceptor.stop();
        this.formSubmitObserver.stop();
      }
    }
    disabledChanged() {
      if (this.loadingStyle == FrameLoadingStyle.eager) {
        this.#loadSourceURL();
      }
    }
    sourceURLChanged() {
      if (this.#isIgnoringChangesTo("src")) return;
      if (this.element.isConnected) {
        this.complete = false;
      }
      if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {
        this.#loadSourceURL();
      }
    }
    sourceURLReloaded() {
      const { refresh, src } = this.element;
      this.#shouldMorphFrame = src && refresh === "morph";
      this.element.removeAttribute("complete");
      this.element.src = null;
      this.element.src = src;
      return this.element.loaded;
    }
    loadingStyleChanged() {
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.appearanceObserver.stop();
        this.#loadSourceURL();
      }
    }
    async #loadSourceURL() {
      if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
        this.element.loaded = this.#visit(expandURL(this.sourceURL));
        this.appearanceObserver.stop();
        await this.element.loaded;
        this.#hasBeenLoaded = true;
      }
    }
    async loadResponse(fetchResponse) {
      if (fetchResponse.redirected || fetchResponse.succeeded && fetchResponse.isHTML) {
        this.sourceURL = fetchResponse.response.url;
      }
      try {
        const html = await fetchResponse.responseHTML;
        if (html) {
          const document2 = parseHTMLDocument(html);
          const pageSnapshot = PageSnapshot.fromDocument(document2);
          if (pageSnapshot.isVisitable) {
            await this.#loadFrameResponse(fetchResponse, document2);
          } else {
            await this.#handleUnvisitableFrameResponse(fetchResponse);
          }
        }
      } finally {
        this.#shouldMorphFrame = false;
        this.fetchResponseLoaded = () => Promise.resolve();
      }
    }
    // Appearance observer delegate
    elementAppearedInViewport(element) {
      this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
      this.#loadSourceURL();
    }
    // Form link click observer delegate
    willSubmitFormLinkToLocation(link2) {
      return this.#shouldInterceptNavigation(link2);
    }
    submittedFormLinkToLocation(link2, _location, form) {
      const frame2 = this.#findFrameElement(link2);
      if (frame2) form.setAttribute("data-turbo-frame", frame2.id);
    }
    // Link interceptor delegate
    shouldInterceptLinkClick(element, _location, _event) {
      return this.#shouldInterceptNavigation(element);
    }
    linkClickIntercepted(element, location2) {
      this.#navigateFrame(element, location2);
    }
    // Form submit observer delegate
    willSubmitForm(element, submitter2) {
      return element.closest("turbo-frame") == this.element && this.#shouldInterceptNavigation(element, submitter2);
    }
    formSubmitted(element, submitter2) {
      if (this.formSubmission) {
        this.formSubmission.stop();
      }
      this.formSubmission = new FormSubmission(this, element, submitter2);
      const { fetchRequest } = this.formSubmission;
      this.prepareRequest(fetchRequest);
      this.formSubmission.start();
    }
    // Fetch request delegate
    prepareRequest(request) {
      request.headers["Turbo-Frame"] = this.id;
      if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
        request.acceptResponseType(StreamMessage.contentType);
      }
    }
    requestStarted(_request) {
      markAsBusy(this.element);
    }
    requestPreventedHandlingResponse(_request, _response) {
      this.#resolveVisitPromise();
    }
    async requestSucceededWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    async requestFailedWithResponse(request, response) {
      await this.loadResponse(response);
      this.#resolveVisitPromise();
    }
    requestErrored(request, error4) {
      console.error(error4);
      this.#resolveVisitPromise();
    }
    requestFinished(_request) {
      clearBusyState(this.element);
    }
    // Form submission delegate
    formSubmissionStarted({ formElement }) {
      markAsBusy(formElement, this.#findFrameElement(formElement));
    }
    formSubmissionSucceededWithResponse(formSubmission, response) {
      const frame2 = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);
      frame2.delegate.proposeVisitIfNavigatedWithAction(frame2, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame2));
      frame2.delegate.loadResponse(response);
      if (!formSubmission.isSafe) {
        session.clearCache();
      }
    }
    formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
      this.element.delegate.loadResponse(fetchResponse);
      session.clearCache();
    }
    formSubmissionErrored(formSubmission, error4) {
      console.error(error4);
    }
    formSubmissionFinished({ formElement }) {
      clearBusyState(formElement, this.#findFrameElement(formElement));
    }
    // View delegate
    allowsImmediateRender({ element: newFrame }, options) {
      const event = dispatch("turbo:before-frame-render", {
        target: this.element,
        detail: { newFrame, ...options },
        cancelable: true
      });
      const {
        defaultPrevented,
        detail: { render: render2 }
      } = event;
      if (this.view.renderer && render2) {
        this.view.renderer.renderElement = render2;
      }
      return !defaultPrevented;
    }
    viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {
    }
    preloadOnLoadLinksForView(element) {
      session.preloadOnLoadLinksForView(element);
    }
    viewInvalidated() {
    }
    // Frame renderer delegate
    willRenderFrame(currentElement, _newElement) {
      this.previousFrameElement = currentElement.cloneNode(true);
    }
    visitCachedSnapshot = ({ element }) => {
      const frame2 = element.querySelector("#" + this.element.id);
      if (frame2 && this.previousFrameElement) {
        frame2.replaceChildren(...this.previousFrameElement.children);
      }
      delete this.previousFrameElement;
    };
    // Private
    async #loadFrameResponse(fetchResponse, document2) {
      const newFrameElement = await this.extractForeignFrameElement(document2.body);
      const rendererClass = this.#shouldMorphFrame ? MorphingFrameRenderer : FrameRenderer;
      if (newFrameElement) {
        const snapshot = new Snapshot(newFrameElement);
        const renderer = new rendererClass(this, this.view.snapshot, snapshot, false, false);
        if (this.view.renderPromise) await this.view.renderPromise;
        this.changeHistory();
        await this.view.render(renderer);
        this.complete = true;
        session.frameRendered(fetchResponse, this.element);
        session.frameLoaded(this.element);
        await this.fetchResponseLoaded(fetchResponse);
      } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {
        this.#handleFrameMissingFromResponse(fetchResponse);
      }
    }
    async #visit(url) {
      const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);
      this.#currentFetchRequest?.cancel();
      this.#currentFetchRequest = request;
      return new Promise((resolve) => {
        this.#resolveVisitPromise = () => {
          this.#resolveVisitPromise = () => {
          };
          this.#currentFetchRequest = null;
          resolve();
        };
        request.perform();
      });
    }
    #navigateFrame(element, url, submitter2) {
      const frame2 = this.#findFrameElement(element, submitter2);
      frame2.delegate.proposeVisitIfNavigatedWithAction(frame2, getVisitAction(submitter2, element, frame2));
      this.#withCurrentNavigationElement(element, () => {
        frame2.src = url;
      });
    }
    proposeVisitIfNavigatedWithAction(frame2, action = null) {
      this.action = action;
      if (this.action) {
        const pageSnapshot = PageSnapshot.fromElement(frame2).clone();
        const { visitCachedSnapshot } = frame2.delegate;
        frame2.delegate.fetchResponseLoaded = async (fetchResponse) => {
          if (frame2.src) {
            const { statusCode, redirected } = fetchResponse;
            const responseHTML = await fetchResponse.responseHTML;
            const response = { statusCode, redirected, responseHTML };
            const options = {
              response,
              visitCachedSnapshot,
              willRender: false,
              updateHistory: false,
              restorationIdentifier: this.restorationIdentifier,
              snapshot: pageSnapshot
            };
            if (this.action) options.action = this.action;
            session.visit(frame2.src, options);
          }
        };
      }
    }
    changeHistory() {
      if (this.action) {
        const method = getHistoryMethodForAction(this.action);
        session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
      }
    }
    async #handleUnvisitableFrameResponse(fetchResponse) {
      console.warn(
        `The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`
      );
      await this.#visitResponse(fetchResponse.response);
    }
    #willHandleFrameMissingFromResponse(fetchResponse) {
      this.element.setAttribute("complete", "");
      const response = fetchResponse.response;
      const visit2 = async (url, options) => {
        if (url instanceof Response) {
          this.#visitResponse(url);
        } else {
          session.visit(url, options);
        }
      };
      const event = dispatch("turbo:frame-missing", {
        target: this.element,
        detail: { response, visit: visit2 },
        cancelable: true
      });
      return !event.defaultPrevented;
    }
    #handleFrameMissingFromResponse(fetchResponse) {
      this.view.missing();
      this.#throwFrameMissingError(fetchResponse);
    }
    #throwFrameMissingError(fetchResponse) {
      const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
      throw new TurboFrameMissingError(message);
    }
    async #visitResponse(response) {
      const wrapped = new FetchResponse(response);
      const responseHTML = await wrapped.responseHTML;
      const { location: location2, redirected, statusCode } = wrapped;
      return session.visit(location2, { response: { redirected, statusCode, responseHTML } });
    }
    #findFrameElement(element, submitter2) {
      const id4 = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
      return getFrameElementById(id4) ?? this.element;
    }
    async extractForeignFrameElement(container) {
      let element;
      const id4 = CSS.escape(this.id);
      try {
        element = activateElement(container.querySelector(`turbo-frame#${id4}`), this.sourceURL);
        if (element) {
          return element;
        }
        element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id4}]`), this.sourceURL);
        if (element) {
          await element.loaded;
          return await this.extractForeignFrameElement(element);
        }
      } catch (error4) {
        console.error(error4);
        return new FrameElement();
      }
      return null;
    }
    #formActionIsVisitable(form, submitter2) {
      const action = getAction$1(form, submitter2);
      return locationIsVisitable(expandURL(action), this.rootLocation);
    }
    #shouldInterceptNavigation(element, submitter2) {
      const id4 = getAttribute("data-turbo-frame", submitter2, element) || this.element.getAttribute("target");
      if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter2)) {
        return false;
      }
      if (!this.enabled || id4 == "_top") {
        return false;
      }
      if (id4) {
        const frameElement = getFrameElementById(id4);
        if (frameElement) {
          return !frameElement.disabled;
        }
      }
      if (!session.elementIsNavigatable(element)) {
        return false;
      }
      if (submitter2 && !session.elementIsNavigatable(submitter2)) {
        return false;
      }
      return true;
    }
    // Computed properties
    get id() {
      return this.element.id;
    }
    get enabled() {
      return !this.element.disabled;
    }
    get sourceURL() {
      if (this.element.src) {
        return this.element.src;
      }
    }
    set sourceURL(sourceURL) {
      this.#ignoringChangesToAttribute("src", () => {
        this.element.src = sourceURL ?? null;
      });
    }
    get loadingStyle() {
      return this.element.loading;
    }
    get isLoading() {
      return this.formSubmission !== void 0 || this.#resolveVisitPromise() !== void 0;
    }
    get complete() {
      return this.element.hasAttribute("complete");
    }
    set complete(value2) {
      if (value2) {
        this.element.setAttribute("complete", "");
      } else {
        this.element.removeAttribute("complete");
      }
    }
    get isActive() {
      return this.element.isActive && this.#connected;
    }
    get rootLocation() {
      const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
      const root2 = meta?.content ?? "/";
      return expandURL(root2);
    }
    #isIgnoringChangesTo(attributeName) {
      return this.#ignoredAttributes.has(attributeName);
    }
    #ignoringChangesToAttribute(attributeName, callback) {
      this.#ignoredAttributes.add(attributeName);
      callback();
      this.#ignoredAttributes.delete(attributeName);
    }
    #withCurrentNavigationElement(element, callback) {
      this.currentNavigationElement = element;
      callback();
      delete this.currentNavigationElement;
    }
  };
  function getFrameElementById(id4) {
    if (id4 != null) {
      const element = document.getElementById(id4);
      if (element instanceof FrameElement) {
        return element;
      }
    }
  }
  function activateElement(element, currentURL) {
    if (element) {
      const src = element.getAttribute("src");
      if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
        throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`);
      }
      if (element.ownerDocument !== document) {
        element = document.importNode(element, true);
      }
      if (element instanceof FrameElement) {
        element.connectedCallback();
        element.disconnectedCallback();
        return element;
      }
    }
  }
  var StreamActions = {
    after() {
      this.targetElements.forEach((e3) => e3.parentElement?.insertBefore(this.templateContent, e3.nextSibling));
    },
    append() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e3) => e3.append(this.templateContent));
    },
    before() {
      this.targetElements.forEach((e3) => e3.parentElement?.insertBefore(this.templateContent, e3));
    },
    prepend() {
      this.removeDuplicateTargetChildren();
      this.targetElements.forEach((e3) => e3.prepend(this.templateContent));
    },
    remove() {
      this.targetElements.forEach((e3) => e3.remove());
    },
    replace() {
      const method = this.getAttribute("method");
      this.targetElements.forEach((targetElement) => {
        if (method === "morph") {
          morphElements(targetElement, this.templateContent);
        } else {
          targetElement.replaceWith(this.templateContent);
        }
      });
    },
    update() {
      const method = this.getAttribute("method");
      this.targetElements.forEach((targetElement) => {
        if (method === "morph") {
          morphChildren(targetElement, this.templateContent);
        } else {
          targetElement.innerHTML = "";
          targetElement.append(this.templateContent);
        }
      });
    },
    refresh() {
      session.refresh(this.baseURI, this.requestId);
    }
  };
  var StreamElement = class _StreamElement extends HTMLElement {
    static async renderElement(newElement) {
      await newElement.performAction();
    }
    async connectedCallback() {
      try {
        await this.render();
      } catch (error4) {
        console.error(error4);
      } finally {
        this.disconnect();
      }
    }
    async render() {
      return this.renderPromise ??= (async () => {
        const event = this.beforeRenderEvent;
        if (this.dispatchEvent(event)) {
          await nextRepaint();
          await event.detail.render(this);
        }
      })();
    }
    disconnect() {
      try {
        this.remove();
      } catch {
      }
    }
    /**
     * Removes duplicate children (by ID)
     */
    removeDuplicateTargetChildren() {
      this.duplicateChildren.forEach((c5) => c5.remove());
    }
    /**
     * Gets the list of duplicate children (i.e. those with the same ID)
     */
    get duplicateChildren() {
      const existingChildren = this.targetElements.flatMap((e3) => [...e3.children]).filter((c5) => !!c5.id);
      const newChildrenIds = [...this.templateContent?.children || []].filter((c5) => !!c5.id).map((c5) => c5.id);
      return existingChildren.filter((c5) => newChildrenIds.includes(c5.id));
    }
    /**
     * Gets the action function to be performed.
     */
    get performAction() {
      if (this.action) {
        const actionFunction = StreamActions[this.action];
        if (actionFunction) {
          return actionFunction;
        }
        this.#raise("unknown action");
      }
      this.#raise("action attribute is missing");
    }
    /**
     * Gets the target elements which the template will be rendered to.
     */
    get targetElements() {
      if (this.target) {
        return this.targetElementsById;
      } else if (this.targets) {
        return this.targetElementsByQuery;
      } else {
        this.#raise("target or targets attribute is missing");
      }
    }
    /**
     * Gets the contents of the main `<template>`.
     */
    get templateContent() {
      return this.templateElement.content.cloneNode(true);
    }
    /**
     * Gets the main `<template>` used for rendering
     */
    get templateElement() {
      if (this.firstElementChild === null) {
        const template = this.ownerDocument.createElement("template");
        this.appendChild(template);
        return template;
      } else if (this.firstElementChild instanceof HTMLTemplateElement) {
        return this.firstElementChild;
      }
      this.#raise("first child element must be a <template> element");
    }
    /**
     * Gets the current action.
     */
    get action() {
      return this.getAttribute("action");
    }
    /**
     * Gets the current target (an element ID) to which the result will
     * be rendered.
     */
    get target() {
      return this.getAttribute("target");
    }
    /**
     * Gets the current "targets" selector (a CSS selector)
     */
    get targets() {
      return this.getAttribute("targets");
    }
    /**
     * Reads the request-id attribute
     */
    get requestId() {
      return this.getAttribute("request-id");
    }
    #raise(message) {
      throw new Error(`${this.description}: ${message}`);
    }
    get description() {
      return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>";
    }
    get beforeRenderEvent() {
      return new CustomEvent("turbo:before-stream-render", {
        bubbles: true,
        cancelable: true,
        detail: { newStream: this, render: _StreamElement.renderElement }
      });
    }
    get targetElementsById() {
      const element = this.ownerDocument?.getElementById(this.target);
      if (element !== null) {
        return [element];
      } else {
        return [];
      }
    }
    get targetElementsByQuery() {
      const elements = this.ownerDocument?.querySelectorAll(this.targets);
      if (elements.length !== 0) {
        return Array.prototype.slice.call(elements);
      } else {
        return [];
      }
    }
  };
  var StreamSourceElement = class extends HTMLElement {
    streamSource = null;
    connectedCallback() {
      this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);
      connectStreamSource(this.streamSource);
    }
    disconnectedCallback() {
      if (this.streamSource) {
        this.streamSource.close();
        disconnectStreamSource(this.streamSource);
      }
    }
    get src() {
      return this.getAttribute("src") || "";
    }
  };
  FrameElement.delegateConstructor = FrameController;
  if (customElements.get("turbo-frame") === void 0) {
    customElements.define("turbo-frame", FrameElement);
  }
  if (customElements.get("turbo-stream") === void 0) {
    customElements.define("turbo-stream", StreamElement);
  }
  if (customElements.get("turbo-stream-source") === void 0) {
    customElements.define("turbo-stream-source", StreamSourceElement);
  }
  (() => {
    let element = document.currentScript;
    if (!element) return;
    if (element.hasAttribute("data-turbo-suppress-warning")) return;
    element = element.parentElement;
    while (element) {
      if (element == document.body) {
        return console.warn(
          unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your application’s JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        ——
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `,
          element.outerHTML
        );
      }
      element = element.parentElement;
    }
  })();
  window.Turbo = { ...Turbo2, StreamActions };
  start();

  // ../../engine/rails_design/node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable.js
  var consumer2;
  async function getConsumer() {
    return consumer2 || setConsumer(createConsumer2().then(setConsumer));
  }
  function setConsumer(newConsumer) {
    return consumer2 = newConsumer;
  }
  async function createConsumer2() {
    const { createConsumer: createConsumer3 } = await Promise.resolve().then(() => (init_src(), src_exports));
    return createConsumer3();
  }
  async function subscribeTo(channel, mixin) {
    const { subscriptions } = await getConsumer();
    return subscriptions.create(channel, mixin);
  }

  // ../../engine/rails_design/node_modules/@hotwired/turbo-rails/app/javascript/turbo/snakeize.js
  function walk(obj) {
    if (!obj || typeof obj !== "object") return obj;
    if (obj instanceof Date || obj instanceof RegExp) return obj;
    if (Array.isArray(obj)) return obj.map(walk);
    return Object.keys(obj).reduce(function(acc, key) {
      var camel = key[0].toLowerCase() + key.slice(1).replace(/([A-Z]+)/g, function(m3, x3) {
        return "_" + x3.toLowerCase();
      });
      acc[camel] = walk(obj[key]);
      return acc;
    }, {});
  }

  // ../../engine/rails_design/node_modules/@hotwired/turbo-rails/app/javascript/turbo/cable_stream_source_element.js
  var TurboCableStreamSourceElement = class extends HTMLElement {
    static observedAttributes = ["channel", "signed-stream-name"];
    async connectedCallback() {
      connectStreamSource(this);
      this.subscription = await subscribeTo(this.channel, {
        received: this.dispatchMessageEvent.bind(this),
        connected: this.subscriptionConnected.bind(this),
        disconnected: this.subscriptionDisconnected.bind(this)
      });
    }
    disconnectedCallback() {
      disconnectStreamSource(this);
      if (this.subscription) this.subscription.unsubscribe();
      this.subscriptionDisconnected();
    }
    attributeChangedCallback() {
      if (this.subscription) {
        this.disconnectedCallback();
        this.connectedCallback();
      }
    }
    dispatchMessageEvent(data2) {
      const event = new MessageEvent("message", { data: data2 });
      return this.dispatchEvent(event);
    }
    subscriptionConnected() {
      this.setAttribute("connected", "");
    }
    subscriptionDisconnected() {
      this.removeAttribute("connected");
    }
    get channel() {
      const channel = this.getAttribute("channel");
      const signed_stream_name = this.getAttribute("signed-stream-name");
      return { channel, signed_stream_name, ...walk({ ...this.dataset }) };
    }
  };
  if (customElements.get("turbo-cable-stream-source") === void 0) {
    customElements.define("turbo-cable-stream-source", TurboCableStreamSourceElement);
  }

  // ../../engine/rails_design/node_modules/@hotwired/turbo-rails/app/javascript/turbo/fetch_requests.js
  function encodeMethodIntoRequestBody(event) {
    if (event.target instanceof HTMLFormElement) {
      const { target: form, detail: { fetchOptions } } = event;
      form.addEventListener("turbo:submit-start", ({ detail: { formSubmission: { submitter: submitter2 } } }) => {
        const body = isBodyInit(fetchOptions.body) ? fetchOptions.body : new URLSearchParams();
        const method = determineFetchMethod(submitter2, body, form);
        if (!/get/i.test(method)) {
          if (/post/i.test(method)) {
            body.delete("_method");
          } else {
            body.set("_method", method);
          }
          fetchOptions.method = "post";
        }
      }, { once: true });
    }
  }
  function determineFetchMethod(submitter2, body, form) {
    const formMethod = determineFormMethod(submitter2);
    const overrideMethod = body.get("_method");
    const method = form.getAttribute("method") || "get";
    if (typeof formMethod == "string") {
      return formMethod;
    } else if (typeof overrideMethod == "string") {
      return overrideMethod;
    } else {
      return method;
    }
  }
  function determineFormMethod(submitter2) {
    if (submitter2 instanceof HTMLButtonElement || submitter2 instanceof HTMLInputElement) {
      if (submitter2.name === "_method") {
        return submitter2.value;
      } else if (submitter2.hasAttribute("formmethod")) {
        return submitter2.formMethod;
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
  function isBodyInit(body) {
    return body instanceof FormData || body instanceof URLSearchParams;
  }

  // ../../engine/rails_design/node_modules/@hotwired/turbo-rails/app/javascript/turbo/index.js
  window.Turbo = turbo_es2017_esm_exports;
  addEventListener("turbo:before-fetch-request", encodeMethodIntoRequestBody);

  // ../../engine/rails_design/node_modules/idiomorph/dist/idiomorph.esm.js
  var Idiomorph2 = function() {
    "use strict";
    let EMPTY_SET = /* @__PURE__ */ new Set();
    let defaults5 = {
      morphStyle: "outerHTML",
      callbacks: {
        beforeNodeAdded: noOp,
        afterNodeAdded: noOp,
        beforeNodeMorphed: noOp,
        afterNodeMorphed: noOp,
        beforeNodeRemoved: noOp,
        afterNodeRemoved: noOp,
        beforeAttributeUpdated: noOp
      },
      head: {
        style: "merge",
        shouldPreserve: function(elt) {
          return elt.getAttribute("im-preserve") === "true";
        },
        shouldReAppend: function(elt) {
          return elt.getAttribute("im-re-append") === "true";
        },
        shouldRemove: noOp,
        afterHeadMorphed: noOp
      }
    };
    function morph(oldNode, newContent, config2 = {}) {
      if (oldNode instanceof Document) {
        oldNode = oldNode.documentElement;
      }
      if (typeof newContent === "string") {
        newContent = parseContent(newContent);
      }
      let normalizedContent = normalizeContent(newContent);
      let ctx2 = createMorphContext(oldNode, normalizedContent, config2);
      return morphNormalizedContent(oldNode, normalizedContent, ctx2);
    }
    function morphNormalizedContent(oldNode, normalizedNewContent, ctx2) {
      if (ctx2.head.block) {
        let oldHead = oldNode.querySelector("head");
        let newHead = normalizedNewContent.querySelector("head");
        if (oldHead && newHead) {
          let promises = handleHeadElement(newHead, oldHead, ctx2);
          Promise.all(promises).then(function() {
            morphNormalizedContent(oldNode, normalizedNewContent, Object.assign(ctx2, {
              head: {
                block: false,
                ignore: true
              }
            }));
          });
          return;
        }
      }
      if (ctx2.morphStyle === "innerHTML") {
        morphChildren2(normalizedNewContent, oldNode, ctx2);
        return oldNode.children;
      } else if (ctx2.morphStyle === "outerHTML" || ctx2.morphStyle == null) {
        let bestMatch = findBestNodeMatch(normalizedNewContent, oldNode, ctx2);
        let previousSibling = bestMatch?.previousSibling;
        let nextSibling = bestMatch?.nextSibling;
        let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx2);
        if (bestMatch) {
          return insertSiblings(previousSibling, morphedNode, nextSibling);
        } else {
          return [];
        }
      } else {
        throw "Do not understand how to morph style " + ctx2.morphStyle;
      }
    }
    function ignoreValueOfActiveElement(possibleActiveElement, ctx2) {
      return ctx2.ignoreActiveValue && possibleActiveElement === document.activeElement;
    }
    function morphOldNodeTo(oldNode, newContent, ctx2) {
      if (ctx2.ignoreActive && oldNode === document.activeElement) {
      } else if (newContent == null) {
        if (ctx2.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        oldNode.remove();
        ctx2.callbacks.afterNodeRemoved(oldNode);
        return null;
      } else if (!isSoftMatch(oldNode, newContent)) {
        if (ctx2.callbacks.beforeNodeRemoved(oldNode) === false) return oldNode;
        if (ctx2.callbacks.beforeNodeAdded(newContent) === false) return oldNode;
        oldNode.parentElement.replaceChild(newContent, oldNode);
        ctx2.callbacks.afterNodeAdded(newContent);
        ctx2.callbacks.afterNodeRemoved(oldNode);
        return newContent;
      } else {
        if (ctx2.callbacks.beforeNodeMorphed(oldNode, newContent) === false) return oldNode;
        if (oldNode instanceof HTMLHeadElement && ctx2.head.ignore) {
        } else if (oldNode instanceof HTMLHeadElement && ctx2.head.style !== "morph") {
          handleHeadElement(newContent, oldNode, ctx2);
        } else {
          syncNodeFrom(newContent, oldNode, ctx2);
          if (!ignoreValueOfActiveElement(oldNode, ctx2)) {
            morphChildren2(newContent, oldNode, ctx2);
          }
        }
        ctx2.callbacks.afterNodeMorphed(oldNode, newContent);
        return oldNode;
      }
    }
    function morphChildren2(newParent, oldParent, ctx2) {
      let nextNewChild = newParent.firstChild;
      let insertionPoint = oldParent.firstChild;
      let newChild;
      while (nextNewChild) {
        newChild = nextNewChild;
        nextNewChild = newChild.nextSibling;
        if (insertionPoint == null) {
          if (ctx2.callbacks.beforeNodeAdded(newChild) === false) return;
          oldParent.appendChild(newChild);
          ctx2.callbacks.afterNodeAdded(newChild);
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        if (isIdSetMatch(newChild, insertionPoint, ctx2)) {
          morphOldNodeTo(insertionPoint, newChild, ctx2);
          insertionPoint = insertionPoint.nextSibling;
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        let idSetMatch = findIdSetMatch(newParent, oldParent, newChild, insertionPoint, ctx2);
        if (idSetMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, idSetMatch, ctx2);
          morphOldNodeTo(idSetMatch, newChild, ctx2);
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        let softMatch = findSoftMatch(newParent, oldParent, newChild, insertionPoint, ctx2);
        if (softMatch) {
          insertionPoint = removeNodesBetween(insertionPoint, softMatch, ctx2);
          morphOldNodeTo(softMatch, newChild, ctx2);
          removeIdsFromConsideration(ctx2, newChild);
          continue;
        }
        if (ctx2.callbacks.beforeNodeAdded(newChild) === false) return;
        oldParent.insertBefore(newChild, insertionPoint);
        ctx2.callbacks.afterNodeAdded(newChild);
        removeIdsFromConsideration(ctx2, newChild);
      }
      while (insertionPoint !== null) {
        let tempNode = insertionPoint;
        insertionPoint = insertionPoint.nextSibling;
        removeNode(tempNode, ctx2);
      }
    }
    function ignoreAttribute(attr2, to, updateType, ctx2) {
      if (attr2 === "value" && ctx2.ignoreActiveValue && to === document.activeElement) {
        return true;
      }
      return ctx2.callbacks.beforeAttributeUpdated(attr2, to, updateType) === false;
    }
    function syncNodeFrom(from, to, ctx2) {
      let type = from.nodeType;
      if (type === 1) {
        const fromAttributes = from.attributes;
        const toAttributes = to.attributes;
        for (const fromAttribute of fromAttributes) {
          if (ignoreAttribute(fromAttribute.name, to, "update", ctx2)) {
            continue;
          }
          if (to.getAttribute(fromAttribute.name) !== fromAttribute.value) {
            to.setAttribute(fromAttribute.name, fromAttribute.value);
          }
        }
        for (let i = toAttributes.length - 1; 0 <= i; i--) {
          const toAttribute = toAttributes[i];
          if (ignoreAttribute(toAttribute.name, to, "remove", ctx2)) {
            continue;
          }
          if (!from.hasAttribute(toAttribute.name)) {
            to.removeAttribute(toAttribute.name);
          }
        }
      }
      if (type === 8 || type === 3) {
        if (to.nodeValue !== from.nodeValue) {
          to.nodeValue = from.nodeValue;
        }
      }
      if (!ignoreValueOfActiveElement(to, ctx2)) {
        syncInputValue(from, to, ctx2);
      }
    }
    function syncBooleanAttribute(from, to, attributeName, ctx2) {
      if (from[attributeName] !== to[attributeName]) {
        let ignoreUpdate = ignoreAttribute(attributeName, to, "update", ctx2);
        if (!ignoreUpdate) {
          to[attributeName] = from[attributeName];
        }
        if (from[attributeName]) {
          if (!ignoreUpdate) {
            to.setAttribute(attributeName, from[attributeName]);
          }
        } else {
          if (!ignoreAttribute(attributeName, to, "remove", ctx2)) {
            to.removeAttribute(attributeName);
          }
        }
      }
    }
    function syncInputValue(from, to, ctx2) {
      if (from instanceof HTMLInputElement && to instanceof HTMLInputElement && from.type !== "file") {
        let fromValue = from.value;
        let toValue = to.value;
        syncBooleanAttribute(from, to, "checked", ctx2);
        syncBooleanAttribute(from, to, "disabled", ctx2);
        if (!from.hasAttribute("value")) {
          if (!ignoreAttribute("value", to, "remove", ctx2)) {
            to.value = "";
            to.removeAttribute("value");
          }
        } else if (fromValue !== toValue) {
          if (!ignoreAttribute("value", to, "update", ctx2)) {
            to.setAttribute("value", fromValue);
            to.value = fromValue;
          }
        }
      } else if (from instanceof HTMLOptionElement) {
        syncBooleanAttribute(from, to, "selected", ctx2);
      } else if (from instanceof HTMLTextAreaElement && to instanceof HTMLTextAreaElement) {
        let fromValue = from.value;
        let toValue = to.value;
        if (ignoreAttribute("value", to, "update", ctx2)) {
          return;
        }
        if (fromValue !== toValue) {
          to.value = fromValue;
        }
        if (to.firstChild && to.firstChild.nodeValue !== fromValue) {
          to.firstChild.nodeValue = fromValue;
        }
      }
    }
    function handleHeadElement(newHeadTag, currentHead, ctx2) {
      let added = [];
      let removed = [];
      let preserved = [];
      let nodesToAppend = [];
      let headMergeStyle = ctx2.head.style;
      let srcToNewHeadNodes = /* @__PURE__ */ new Map();
      for (const newHeadChild of newHeadTag.children) {
        srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
      }
      for (const currentHeadElt of currentHead.children) {
        let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
        let isReAppended = ctx2.head.shouldReAppend(currentHeadElt);
        let isPreserved = ctx2.head.shouldPreserve(currentHeadElt);
        if (inNewContent || isPreserved) {
          if (isReAppended) {
            removed.push(currentHeadElt);
          } else {
            srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
            preserved.push(currentHeadElt);
          }
        } else {
          if (headMergeStyle === "append") {
            if (isReAppended) {
              removed.push(currentHeadElt);
              nodesToAppend.push(currentHeadElt);
            }
          } else {
            if (ctx2.head.shouldRemove(currentHeadElt) !== false) {
              removed.push(currentHeadElt);
            }
          }
        }
      }
      nodesToAppend.push(...srcToNewHeadNodes.values());
      log2("to append: ", nodesToAppend);
      let promises = [];
      for (const newNode of nodesToAppend) {
        log2("adding: ", newNode);
        let newElt = document.createRange().createContextualFragment(newNode.outerHTML).firstChild;
        log2(newElt);
        if (ctx2.callbacks.beforeNodeAdded(newElt) !== false) {
          if (newElt.href || newElt.src) {
            let resolve = null;
            let promise = new Promise(function(_resolve) {
              resolve = _resolve;
            });
            newElt.addEventListener("load", function() {
              resolve();
            });
            promises.push(promise);
          }
          currentHead.appendChild(newElt);
          ctx2.callbacks.afterNodeAdded(newElt);
          added.push(newElt);
        }
      }
      for (const removedElement of removed) {
        if (ctx2.callbacks.beforeNodeRemoved(removedElement) !== false) {
          currentHead.removeChild(removedElement);
          ctx2.callbacks.afterNodeRemoved(removedElement);
        }
      }
      ctx2.head.afterHeadMorphed(currentHead, { added, kept: preserved, removed });
      return promises;
    }
    function log2() {
    }
    function noOp() {
    }
    function mergeDefaults(config2) {
      let finalConfig = {};
      Object.assign(finalConfig, defaults5);
      Object.assign(finalConfig, config2);
      finalConfig.callbacks = {};
      Object.assign(finalConfig.callbacks, defaults5.callbacks);
      Object.assign(finalConfig.callbacks, config2.callbacks);
      finalConfig.head = {};
      Object.assign(finalConfig.head, defaults5.head);
      Object.assign(finalConfig.head, config2.head);
      return finalConfig;
    }
    function createMorphContext(oldNode, newContent, config2) {
      config2 = mergeDefaults(config2);
      return {
        target: oldNode,
        newContent,
        config: config2,
        morphStyle: config2.morphStyle,
        ignoreActive: config2.ignoreActive,
        ignoreActiveValue: config2.ignoreActiveValue,
        idMap: createIdMap(oldNode, newContent),
        deadIds: /* @__PURE__ */ new Set(),
        callbacks: config2.callbacks,
        head: config2.head
      };
    }
    function isIdSetMatch(node1, node2, ctx2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      if (node1.nodeType === node2.nodeType && node1.tagName === node2.tagName) {
        if (node1.id !== "" && node1.id === node2.id) {
          return true;
        } else {
          return getIdIntersectionCount(ctx2, node1, node2) > 0;
        }
      }
      return false;
    }
    function isSoftMatch(node1, node2) {
      if (node1 == null || node2 == null) {
        return false;
      }
      return node1.nodeType === node2.nodeType && node1.tagName === node2.tagName;
    }
    function removeNodesBetween(startInclusive, endExclusive, ctx2) {
      while (startInclusive !== endExclusive) {
        let tempNode = startInclusive;
        startInclusive = startInclusive.nextSibling;
        removeNode(tempNode, ctx2);
      }
      removeIdsFromConsideration(ctx2, endExclusive);
      return endExclusive.nextSibling;
    }
    function findIdSetMatch(newContent, oldParent, newChild, insertionPoint, ctx2) {
      let newChildPotentialIdCount = getIdIntersectionCount(ctx2, newChild, oldParent);
      let potentialMatch = null;
      if (newChildPotentialIdCount > 0) {
        let potentialMatch2 = insertionPoint;
        let otherMatchCount = 0;
        while (potentialMatch2 != null) {
          if (isIdSetMatch(newChild, potentialMatch2, ctx2)) {
            return potentialMatch2;
          }
          otherMatchCount += getIdIntersectionCount(ctx2, potentialMatch2, newContent);
          if (otherMatchCount > newChildPotentialIdCount) {
            return null;
          }
          potentialMatch2 = potentialMatch2.nextSibling;
        }
      }
      return potentialMatch;
    }
    function findSoftMatch(newContent, oldParent, newChild, insertionPoint, ctx2) {
      let potentialSoftMatch = insertionPoint;
      let nextSibling = newChild.nextSibling;
      let siblingSoftMatchCount = 0;
      while (potentialSoftMatch != null) {
        if (getIdIntersectionCount(ctx2, potentialSoftMatch, newContent) > 0) {
          return null;
        }
        if (isSoftMatch(newChild, potentialSoftMatch)) {
          return potentialSoftMatch;
        }
        if (isSoftMatch(nextSibling, potentialSoftMatch)) {
          siblingSoftMatchCount++;
          nextSibling = nextSibling.nextSibling;
          if (siblingSoftMatchCount >= 2) {
            return null;
          }
        }
        potentialSoftMatch = potentialSoftMatch.nextSibling;
      }
      return potentialSoftMatch;
    }
    function parseContent(newContent) {
      let parser = new DOMParser();
      let contentWithSvgsRemoved = newContent.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
      if (contentWithSvgsRemoved.match(/<\/html>/) || contentWithSvgsRemoved.match(/<\/head>/) || contentWithSvgsRemoved.match(/<\/body>/)) {
        let content = parser.parseFromString(newContent, "text/html");
        if (contentWithSvgsRemoved.match(/<\/html>/)) {
          content.generatedByIdiomorph = true;
          return content;
        } else {
          let htmlElement = content.firstChild;
          if (htmlElement) {
            htmlElement.generatedByIdiomorph = true;
            return htmlElement;
          } else {
            return null;
          }
        }
      } else {
        let responseDoc = parser.parseFromString("<body><template>" + newContent + "</template></body>", "text/html");
        let content = responseDoc.body.querySelector("template").content;
        content.generatedByIdiomorph = true;
        return content;
      }
    }
    function normalizeContent(newContent) {
      if (newContent == null) {
        const dummyParent = document.createElement("div");
        return dummyParent;
      } else if (newContent.generatedByIdiomorph) {
        return newContent;
      } else if (newContent instanceof Node) {
        const dummyParent = document.createElement("div");
        dummyParent.append(newContent);
        return dummyParent;
      } else {
        const dummyParent = document.createElement("div");
        for (const elt of [...newContent]) {
          dummyParent.append(elt);
        }
        return dummyParent;
      }
    }
    function insertSiblings(previousSibling, morphedNode, nextSibling) {
      let stack = [];
      let added = [];
      while (previousSibling != null) {
        stack.push(previousSibling);
        previousSibling = previousSibling.previousSibling;
      }
      while (stack.length > 0) {
        let node = stack.pop();
        added.push(node);
        morphedNode.parentElement.insertBefore(node, morphedNode);
      }
      added.push(morphedNode);
      while (nextSibling != null) {
        stack.push(nextSibling);
        added.push(nextSibling);
        nextSibling = nextSibling.nextSibling;
      }
      while (stack.length > 0) {
        morphedNode.parentElement.insertBefore(stack.pop(), morphedNode.nextSibling);
      }
      return added;
    }
    function findBestNodeMatch(newContent, oldNode, ctx2) {
      let currentElement;
      currentElement = newContent.firstChild;
      let bestElement = currentElement;
      let score2 = 0;
      while (currentElement) {
        let newScore = scoreElement(currentElement, oldNode, ctx2);
        if (newScore > score2) {
          bestElement = currentElement;
          score2 = newScore;
        }
        currentElement = currentElement.nextSibling;
      }
      return bestElement;
    }
    function scoreElement(node1, node2, ctx2) {
      if (isSoftMatch(node1, node2)) {
        return 0.5 + getIdIntersectionCount(ctx2, node1, node2);
      }
      return 0;
    }
    function removeNode(tempNode, ctx2) {
      removeIdsFromConsideration(ctx2, tempNode);
      if (ctx2.callbacks.beforeNodeRemoved(tempNode) === false) return;
      tempNode.remove();
      ctx2.callbacks.afterNodeRemoved(tempNode);
    }
    function isIdInConsideration(ctx2, id4) {
      return !ctx2.deadIds.has(id4);
    }
    function idIsWithinNode(ctx2, id4, targetNode) {
      let idSet = ctx2.idMap.get(targetNode) || EMPTY_SET;
      return idSet.has(id4);
    }
    function removeIdsFromConsideration(ctx2, node) {
      let idSet = ctx2.idMap.get(node) || EMPTY_SET;
      for (const id4 of idSet) {
        ctx2.deadIds.add(id4);
      }
    }
    function getIdIntersectionCount(ctx2, node1, node2) {
      let sourceSet = ctx2.idMap.get(node1) || EMPTY_SET;
      let matchCount = 0;
      for (const id4 of sourceSet) {
        if (isIdInConsideration(ctx2, id4) && idIsWithinNode(ctx2, id4, node2)) {
          ++matchCount;
        }
      }
      return matchCount;
    }
    function populateIdMapForNode(node, idMap) {
      let nodeParent = node.parentElement;
      let idElements = node.querySelectorAll("[id]");
      for (const elt of idElements) {
        let current = elt;
        while (current !== nodeParent && current != null) {
          let idSet = idMap.get(current);
          if (idSet == null) {
            idSet = /* @__PURE__ */ new Set();
            idMap.set(current, idSet);
          }
          idSet.add(elt.id);
          current = current.parentElement;
        }
      }
    }
    function createIdMap(oldContent, newContent) {
      let idMap = /* @__PURE__ */ new Map();
      populateIdMapForNode(oldContent, idMap);
      populateIdMapForNode(newContent, idMap);
      return idMap;
    }
    return {
      morph,
      defaults: defaults5
    };
  }();

  // ../../engine/rails_design/app/javascripts/rails_design/dataset.js
  DOMStringMap.prototype.add = function(name2, value2) {
    if (typeof this[name2] === "string") {
      const values = this[name2].split(" ");
      if (!values.includes(value2)) {
        values.push(value2);
      }
      this[name2] = values.join(" ");
    } else {
      this[name2] = value2;
    }
  };
  DOMStringMap.prototype.remove = function(name2, value2) {
    if (typeof this[name2] === "string") {
      const values = this[name2].split(" ");
      const index4 = values.indexOf(value2);
      if (index4 > -1) {
        values.splice(index4, 1);
      }
      this[name2] = values.join(" ");
    }
  };
  DOMStringMap.prototype.replace = function(name2, old_value, new_value) {
    if (typeof this[name2] === "string") {
      const values = this[name2].split(" ");
      const reg = new RegExp(old_value);
      values.forEach((ele, index4) => {
        if (reg.test(ele)) {
          values[index4] = String(ele).replace(old_value, new_value);
        }
      });
      this[name2] = values.join(" ");
    }
  };

  // ../../engine/rails_design/app/javascripts/rails_design/utils.js
  window.utils = {
    xx: (date) => {
      const format3 = new Intl.DateTimeFormat("zh-Hans-CN", {
        calendar: "chinese",
        timeZone: "Asia/Shanghai"
      });
      format3.format(date);
    }
  };

  // ../../engine/rails_design/app/javascripts/rails_design/weixin_script.js
  var weixin_fetch2 = function({ url = location.href, success, ...args } = {}) {
    if (typeof wx === "undefined") {
      return;
    }
    fetch("/wechat/js", {
      method: "POST",
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ url })
    }).then((response) => {
      return response.json();
    }).then((body) => {
      let config2 = {
        debug: body["debug"],
        appId: body["appid"],
        timestamp: body["timestamp"],
        nonceStr: body["noncestr"],
        signature: body["signature"],
        jsApiList: body["apis"],
        openTagList: body["open_tags"]
      };
      if (body["beta"]) {
        Object.assign(config2, { beta: true });
      }
      if (body["debug"]) {
        alert("body is:" + JSON.stringify(config2));
      }
      wx.config(config2);
      wx.ready(() => {
        if (body["debug"]) {
          alert("wx.config ready");
        } else {
          console.debug("ready, ok");
        }
        if (success) {
          success(args);
        }
      });
      wx.error((res) => {
        if (body["debug"]) {
          alert("wx.config: " + JSON.stringify(res) + `
location: ${location.href}`);
        } else {
          console.debug("wx.config:", res);
        }
      });
    });
  };
  window.weixin_fetch = weixin_fetch2;
  var weixin_script = document.getElementById("weixin_script");
  var wxwork_script = document.getElementById("wxwork_script");
  if (weixin_script && wxwork_script) {
    wxwork_script.addEventListener("load", (event) => {
      wxwork_fetch();
    });
  } else if (weixin_script) {
    weixin_script.addEventListener("load", (event) => {
      weixin_fetch2();
    });
  }

  // ../../engine/rails_design/app/javascripts/rails_design/wxwork_script.js
  var wxwork_fetch2 = function({ url = location.href, success, ...args } = {}) {
    weixin_fetch({
      url,
      success: () => {
        fetch("/wechat/agent_js", {
          method: "POST",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ url })
        }).then((response) => {
          return response.json();
        }).then((body) => {
          wx.agentConfig({
            corpid: body["corpid"],
            agentid: body["agentid"],
            timestamp: body["timestamp"],
            nonceStr: body["noncestr"],
            signature: body["signature"],
            jsApiList: body["apis"],
            success: (res) => {
              if (body["debug"]) {
                alert("wx.agentConfig success" + JSON.stringify(res));
              } else {
                console.debug("wx.agentConfig success", JSON.stringify(res));
              }
              if (success) {
                success(args);
              }
            },
            fail: (res) => {
              new Error("wx.agentConfig fail " + JSON.stringify(res));
            }
          });
        });
      }
    });
  };
  window.wxwork_fetch = wxwork_fetch2;

  // ../../engine/rails_design/node_modules/@hotwired/stimulus/dist/stimulus.js
  var EventListener = class {
    constructor(eventTarget, eventName, eventOptions) {
      this.eventTarget = eventTarget;
      this.eventName = eventName;
      this.eventOptions = eventOptions;
      this.unorderedBindings = /* @__PURE__ */ new Set();
    }
    connect() {
      this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
      this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
      this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
      this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
      const extendedEvent = extendEvent(event);
      for (const binding of this.bindings) {
        if (extendedEvent.immediatePropagationStopped) {
          break;
        } else {
          binding.handleEvent(extendedEvent);
        }
      }
    }
    hasBindings() {
      return this.unorderedBindings.size > 0;
    }
    get bindings() {
      return Array.from(this.unorderedBindings).sort((left2, right2) => {
        const leftIndex = left2.index, rightIndex = right2.index;
        return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
      });
    }
  };
  function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
      return event;
    } else {
      const { stopImmediatePropagation } = event;
      return Object.assign(event, {
        immediatePropagationStopped: false,
        stopImmediatePropagation() {
          this.immediatePropagationStopped = true;
          stopImmediatePropagation.call(this);
        }
      });
    }
  }
  var Dispatcher = class {
    constructor(application2) {
      this.application = application2;
      this.eventListenerMaps = /* @__PURE__ */ new Map();
      this.started = false;
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.eventListeners.forEach((eventListener) => eventListener.connect());
      }
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.eventListeners.forEach((eventListener) => eventListener.disconnect());
      }
    }
    get eventListeners() {
      return Array.from(this.eventListenerMaps.values()).reduce((listeners, map3) => listeners.concat(Array.from(map3.values())), []);
    }
    bindingConnected(binding) {
      this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
      this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
      if (clearEventListeners)
        this.clearEventListenersForBinding(binding);
    }
    handleError(error4, message, detail = {}) {
      this.application.handleError(error4, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
      const eventListener = this.fetchEventListenerForBinding(binding);
      if (!eventListener.hasBindings()) {
        eventListener.disconnect();
        this.removeMappedEventListenerFor(binding);
      }
    }
    removeMappedEventListenerFor(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      eventListenerMap.delete(cacheKey);
      if (eventListenerMap.size == 0)
        this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
      const { eventTarget, eventName, eventOptions } = binding;
      return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
      const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
      const cacheKey = this.cacheKey(eventName, eventOptions);
      let eventListener = eventListenerMap.get(cacheKey);
      if (!eventListener) {
        eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
        eventListenerMap.set(cacheKey, eventListener);
      }
      return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
      const eventListener = new EventListener(eventTarget, eventName, eventOptions);
      if (this.started) {
        eventListener.connect();
      }
      return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
      let eventListenerMap = this.eventListenerMaps.get(eventTarget);
      if (!eventListenerMap) {
        eventListenerMap = /* @__PURE__ */ new Map();
        this.eventListenerMaps.set(eventTarget, eventListenerMap);
      }
      return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
      const parts = [eventName];
      Object.keys(eventOptions).sort().forEach((key) => {
        parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
      });
      return parts.join(":");
    }
  };
  var defaultActionDescriptorFilters = {
    stop({ event, value: value2 }) {
      if (value2)
        event.stopPropagation();
      return true;
    },
    prevent({ event, value: value2 }) {
      if (value2)
        event.preventDefault();
      return true;
    },
    self({ event, value: value2, element }) {
      if (value2) {
        return element === event.target;
      } else {
        return true;
      }
    }
  };
  var descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
  function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches2 = source.match(descriptorPattern) || [];
    let eventName = matches2[2];
    let keyFilter = matches2[3];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
      eventName += `.${keyFilter}`;
      keyFilter = "";
    }
    return {
      eventTarget: parseEventTarget(matches2[4]),
      eventName,
      eventOptions: matches2[7] ? parseEventOptions(matches2[7]) : {},
      identifier: matches2[5],
      methodName: matches2[6],
      keyFilter: matches2[1] || keyFilter
    };
  }
  function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
      return window;
    } else if (eventTargetName == "document") {
      return document;
    }
  }
  function parseEventOptions(eventOptions) {
    return eventOptions.split(":").reduce((options, token2) => Object.assign(options, { [token2.replace(/^!/, "")]: !/^!/.test(token2) }), {});
  }
  function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
      return "window";
    } else if (eventTarget == document) {
      return "document";
    }
  }
  function camelize(value2) {
    return value2.replace(/(?:[_-])([a-z0-9])/g, (_2, char) => char.toUpperCase());
  }
  function namespaceCamelize(value2) {
    return camelize(value2.replace(/--/g, "-").replace(/__/g, "_"));
  }
  function capitalize(value2) {
    return value2.charAt(0).toUpperCase() + value2.slice(1);
  }
  function dasherize(value2) {
    return value2.replace(/([A-Z])/g, (_2, char) => `-${char.toLowerCase()}`);
  }
  function tokenize(value2) {
    return value2.match(/[^\s]+/g) || [];
  }
  function isSomething(object) {
    return object !== null && object !== void 0;
  }
  function hasProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
  }
  var allModifiers = ["meta", "ctrl", "alt", "shift"];
  var Action = class {
    constructor(element, index4, descriptor, schema) {
      this.element = element;
      this.index = index4;
      this.eventTarget = descriptor.eventTarget || element;
      this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
      this.eventOptions = descriptor.eventOptions || {};
      this.identifier = descriptor.identifier || error("missing identifier");
      this.methodName = descriptor.methodName || error("missing method name");
      this.keyFilter = descriptor.keyFilter || "";
      this.schema = schema;
    }
    static forToken(token2, schema) {
      return new this(token2.element, token2.index, parseActionDescriptorString(token2.content), schema);
    }
    toString() {
      const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
      const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
      return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    shouldIgnoreKeyboardEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = this.keyFilter.split("+");
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
      if (!standardFilter) {
        return false;
      }
      if (!hasProperty(this.keyMappings, standardFilter)) {
        error(`contains unknown key filter: ${this.keyFilter}`);
      }
      return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
    }
    shouldIgnoreMouseEvent(event) {
      if (!this.keyFilter) {
        return false;
      }
      const filters = [this.keyFilter];
      if (this.keyFilterDissatisfied(event, filters)) {
        return true;
      }
      return false;
    }
    get params() {
      const params = {};
      const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
      for (const { name: name2, value: value2 } of Array.from(this.element.attributes)) {
        const match2 = name2.match(pattern);
        const key = match2 && match2[1];
        if (key) {
          params[camelize(key)] = typecast(value2);
        }
      }
      return params;
    }
    get eventTargetName() {
      return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
      return this.schema.keyMappings;
    }
    keyFilterDissatisfied(event, filters) {
      const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
      return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
    }
  };
  var defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e3) => e3.getAttribute("type") == "submit" ? "click" : "input",
    select: () => "change",
    textarea: () => "input"
  };
  function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
      return defaultEventNames[tagName](element);
    }
  }
  function error(message) {
    throw new Error(message);
  }
  function typecast(value2) {
    try {
      return JSON.parse(value2);
    } catch (o_O) {
      return value2;
    }
  }
  var Binding = class {
    constructor(context, action) {
      this.context = context;
      this.action = action;
    }
    get index() {
      return this.action.index;
    }
    get eventTarget() {
      return this.action.eventTarget;
    }
    get eventOptions() {
      return this.action.eventOptions;
    }
    get identifier() {
      return this.context.identifier;
    }
    handleEvent(event) {
      const actionEvent = this.prepareActionEvent(event);
      if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
        this.invokeWithEvent(actionEvent);
      }
    }
    get eventName() {
      return this.action.eventName;
    }
    get method() {
      const method = this.controller[this.methodName];
      if (typeof method == "function") {
        return method;
      }
      throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event) {
      const { element } = this.action;
      const { actionDescriptorFilters } = this.context.application;
      const { controller } = this.context;
      let passes = true;
      for (const [name2, value2] of Object.entries(this.eventOptions)) {
        if (name2 in actionDescriptorFilters) {
          const filter2 = actionDescriptorFilters[name2];
          passes = passes && filter2({ name: name2, value: value2, event, element, controller });
        } else {
          continue;
        }
      }
      return passes;
    }
    prepareActionEvent(event) {
      return Object.assign(event, { params: this.action.params });
    }
    invokeWithEvent(event) {
      const { target, currentTarget } = event;
      try {
        this.method.call(this.controller, event);
        this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
      } catch (error4) {
        const { identifier, controller, element, index: index4 } = this;
        const detail = { identifier, controller, element, index: index4, event };
        this.context.handleError(error4, `invoking action "${this.action}"`, detail);
      }
    }
    willBeInvokedByEvent(event) {
      const eventTarget = event.target;
      if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
        return false;
      }
      if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
        return false;
      }
      if (this.element === eventTarget) {
        return true;
      } else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
        return this.scope.containsElement(eventTarget);
      } else {
        return this.scope.containsElement(this.action.element);
      }
    }
    get controller() {
      return this.context.controller;
    }
    get methodName() {
      return this.action.methodName;
    }
    get element() {
      return this.scope.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  var ElementObserver = class {
    constructor(element, delegate) {
      this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
      this.element = element;
      this.started = false;
      this.delegate = delegate;
      this.elements = /* @__PURE__ */ new Set();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.refresh();
      }
    }
    pause(callback) {
      if (this.started) {
        this.mutationObserver.disconnect();
        this.started = false;
      }
      callback();
      if (!this.started) {
        this.mutationObserver.observe(this.element, this.mutationObserverInit);
        this.started = true;
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        const matches2 = new Set(this.matchElementsInTree());
        for (const element of Array.from(this.elements)) {
          if (!matches2.has(element)) {
            this.removeElement(element);
          }
        }
        for (const element of Array.from(matches2)) {
          this.addElement(element);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      if (mutation.type == "attributes") {
        this.processAttributeChange(mutation.target, mutation.attributeName);
      } else if (mutation.type == "childList") {
        this.processRemovedNodes(mutation.removedNodes);
        this.processAddedNodes(mutation.addedNodes);
      }
    }
    processAttributeChange(element, attributeName) {
      if (this.elements.has(element)) {
        if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
          this.delegate.elementAttributeChanged(element, attributeName);
        } else {
          this.removeElement(element);
        }
      } else if (this.matchElement(element)) {
        this.addElement(element);
      }
    }
    processRemovedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element) {
          this.processTree(element, this.removeElement);
        }
      }
    }
    processAddedNodes(nodes) {
      for (const node of Array.from(nodes)) {
        const element = this.elementFromNode(node);
        if (element && this.elementIsActive(element)) {
          this.processTree(element, this.addElement);
        }
      }
    }
    matchElement(element) {
      return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
      return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
      for (const element of this.matchElementsInTree(tree)) {
        processor.call(this, element);
      }
    }
    elementFromNode(node) {
      if (node.nodeType == Node.ELEMENT_NODE) {
        return node;
      }
    }
    elementIsActive(element) {
      if (element.isConnected != this.element.isConnected) {
        return false;
      } else {
        return this.element.contains(element);
      }
    }
    addElement(element) {
      if (!this.elements.has(element)) {
        if (this.elementIsActive(element)) {
          this.elements.add(element);
          if (this.delegate.elementMatched) {
            this.delegate.elementMatched(element);
          }
        }
      }
    }
    removeElement(element) {
      if (this.elements.has(element)) {
        this.elements.delete(element);
        if (this.delegate.elementUnmatched) {
          this.delegate.elementUnmatched(element);
        }
      }
    }
  };
  var AttributeObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeName = attributeName;
      this.delegate = delegate;
      this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
      return this.elementObserver.element;
    }
    get selector() {
      return `[${this.attributeName}]`;
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get started() {
      return this.elementObserver.started;
    }
    matchElement(element) {
      return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
      const match2 = this.matchElement(tree) ? [tree] : [];
      const matches2 = Array.from(tree.querySelectorAll(this.selector));
      return match2.concat(matches2);
    }
    elementMatched(element) {
      if (this.delegate.elementMatchedAttribute) {
        this.delegate.elementMatchedAttribute(element, this.attributeName);
      }
    }
    elementUnmatched(element) {
      if (this.delegate.elementUnmatchedAttribute) {
        this.delegate.elementUnmatchedAttribute(element, this.attributeName);
      }
    }
    elementAttributeChanged(element, attributeName) {
      if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
        this.delegate.elementAttributeValueChanged(element, attributeName);
      }
    }
  };
  function add(map3, key, value2) {
    fetch2(map3, key).add(value2);
  }
  function del(map3, key, value2) {
    fetch2(map3, key).delete(value2);
    prune(map3, key);
  }
  function fetch2(map3, key) {
    let values = map3.get(key);
    if (!values) {
      values = /* @__PURE__ */ new Set();
      map3.set(key, values);
    }
    return values;
  }
  function prune(map3, key) {
    const values = map3.get(key);
    if (values != null && values.size == 0) {
      map3.delete(key);
    }
  }
  var Multimap = class {
    constructor() {
      this.valuesByKey = /* @__PURE__ */ new Map();
    }
    get keys() {
      return Array.from(this.valuesByKey.keys());
    }
    get values() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((values, set8) => values.concat(Array.from(set8)), []);
    }
    get size() {
      const sets = Array.from(this.valuesByKey.values());
      return sets.reduce((size2, set8) => size2 + set8.size, 0);
    }
    add(key, value2) {
      add(this.valuesByKey, key, value2);
    }
    delete(key, value2) {
      del(this.valuesByKey, key, value2);
    }
    has(key, value2) {
      const values = this.valuesByKey.get(key);
      return values != null && values.has(value2);
    }
    hasKey(key) {
      return this.valuesByKey.has(key);
    }
    hasValue(value2) {
      const sets = Array.from(this.valuesByKey.values());
      return sets.some((set8) => set8.has(value2));
    }
    getValuesForKey(key) {
      const values = this.valuesByKey.get(key);
      return values ? Array.from(values) : [];
    }
    getKeysForValue(value2) {
      return Array.from(this.valuesByKey).filter(([_key, values]) => values.has(value2)).map(([key, _values]) => key);
    }
  };
  var SelectorObserver = class {
    constructor(element, selector, delegate, details) {
      this._selector = selector;
      this.details = details;
      this.elementObserver = new ElementObserver(element, this);
      this.delegate = delegate;
      this.matchesByElement = new Multimap();
    }
    get started() {
      return this.elementObserver.started;
    }
    get selector() {
      return this._selector;
    }
    set selector(selector) {
      this._selector = selector;
      this.refresh();
    }
    start() {
      this.elementObserver.start();
    }
    pause(callback) {
      this.elementObserver.pause(callback);
    }
    stop() {
      this.elementObserver.stop();
    }
    refresh() {
      this.elementObserver.refresh();
    }
    get element() {
      return this.elementObserver.element;
    }
    matchElement(element) {
      const { selector } = this;
      if (selector) {
        const matches2 = element.matches(selector);
        if (this.delegate.selectorMatchElement) {
          return matches2 && this.delegate.selectorMatchElement(element, this.details);
        }
        return matches2;
      } else {
        return false;
      }
    }
    matchElementsInTree(tree) {
      const { selector } = this;
      if (selector) {
        const match2 = this.matchElement(tree) ? [tree] : [];
        const matches2 = Array.from(tree.querySelectorAll(selector)).filter((match3) => this.matchElement(match3));
        return match2.concat(matches2);
      } else {
        return [];
      }
    }
    elementMatched(element) {
      const { selector } = this;
      if (selector) {
        this.selectorMatched(element, selector);
      }
    }
    elementUnmatched(element) {
      const selectors = this.matchesByElement.getKeysForValue(element);
      for (const selector of selectors) {
        this.selectorUnmatched(element, selector);
      }
    }
    elementAttributeChanged(element, _attributeName) {
      const { selector } = this;
      if (selector) {
        const matches2 = this.matchElement(element);
        const matchedBefore = this.matchesByElement.has(selector, element);
        if (matches2 && !matchedBefore) {
          this.selectorMatched(element, selector);
        } else if (!matches2 && matchedBefore) {
          this.selectorUnmatched(element, selector);
        }
      }
    }
    selectorMatched(element, selector) {
      this.delegate.selectorMatched(element, selector, this.details);
      this.matchesByElement.add(selector, element);
    }
    selectorUnmatched(element, selector) {
      this.delegate.selectorUnmatched(element, selector, this.details);
      this.matchesByElement.delete(selector, element);
    }
  };
  var StringMapObserver = class {
    constructor(element, delegate) {
      this.element = element;
      this.delegate = delegate;
      this.started = false;
      this.stringMap = /* @__PURE__ */ new Map();
      this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
      if (!this.started) {
        this.started = true;
        this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
        this.refresh();
      }
    }
    stop() {
      if (this.started) {
        this.mutationObserver.takeRecords();
        this.mutationObserver.disconnect();
        this.started = false;
      }
    }
    refresh() {
      if (this.started) {
        for (const attributeName of this.knownAttributeNames) {
          this.refreshAttribute(attributeName, null);
        }
      }
    }
    processMutations(mutations) {
      if (this.started) {
        for (const mutation of mutations) {
          this.processMutation(mutation);
        }
      }
    }
    processMutation(mutation) {
      const attributeName = mutation.attributeName;
      if (attributeName) {
        this.refreshAttribute(attributeName, mutation.oldValue);
      }
    }
    refreshAttribute(attributeName, oldValue) {
      const key = this.delegate.getStringMapKeyForAttribute(attributeName);
      if (key != null) {
        if (!this.stringMap.has(attributeName)) {
          this.stringMapKeyAdded(key, attributeName);
        }
        const value2 = this.element.getAttribute(attributeName);
        if (this.stringMap.get(attributeName) != value2) {
          this.stringMapValueChanged(value2, key, oldValue);
        }
        if (value2 == null) {
          const oldValue2 = this.stringMap.get(attributeName);
          this.stringMap.delete(attributeName);
          if (oldValue2)
            this.stringMapKeyRemoved(key, attributeName, oldValue2);
        } else {
          this.stringMap.set(attributeName, value2);
        }
      }
    }
    stringMapKeyAdded(key, attributeName) {
      if (this.delegate.stringMapKeyAdded) {
        this.delegate.stringMapKeyAdded(key, attributeName);
      }
    }
    stringMapValueChanged(value2, key, oldValue) {
      if (this.delegate.stringMapValueChanged) {
        this.delegate.stringMapValueChanged(value2, key, oldValue);
      }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      if (this.delegate.stringMapKeyRemoved) {
        this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
      }
    }
    get knownAttributeNames() {
      return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
      return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
      return Array.from(this.stringMap.keys());
    }
  };
  var TokenListObserver = class {
    constructor(element, attributeName, delegate) {
      this.attributeObserver = new AttributeObserver(element, attributeName, this);
      this.delegate = delegate;
      this.tokensByElement = new Multimap();
    }
    get started() {
      return this.attributeObserver.started;
    }
    start() {
      this.attributeObserver.start();
    }
    pause(callback) {
      this.attributeObserver.pause(callback);
    }
    stop() {
      this.attributeObserver.stop();
    }
    refresh() {
      this.attributeObserver.refresh();
    }
    get element() {
      return this.attributeObserver.element;
    }
    get attributeName() {
      return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
      this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
      const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
      this.tokensUnmatched(unmatchedTokens);
      this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
      this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens4) {
      tokens4.forEach((token2) => this.tokenMatched(token2));
    }
    tokensUnmatched(tokens4) {
      tokens4.forEach((token2) => this.tokenUnmatched(token2));
    }
    tokenMatched(token2) {
      this.delegate.tokenMatched(token2);
      this.tokensByElement.add(token2.element, token2);
    }
    tokenUnmatched(token2) {
      this.delegate.tokenUnmatched(token2);
      this.tokensByElement.delete(token2.element, token2);
    }
    refreshTokensForElement(element) {
      const previousTokens = this.tokensByElement.getValuesForKey(element);
      const currentTokens = this.readTokensForElement(element);
      const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
      if (firstDifferingIndex == -1) {
        return [[], []];
      } else {
        return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
      }
    }
    readTokensForElement(element) {
      const attributeName = this.attributeName;
      const tokenString = element.getAttribute(attributeName) || "";
      return parseTokenString(tokenString, element, attributeName);
    }
  };
  function parseTokenString(tokenString, element, attributeName) {
    return tokenString.trim().split(/\s+/).filter((content) => content.length).map((content, index4) => ({ element, attributeName, content, index: index4 }));
  }
  function zip(left2, right2) {
    const length5 = Math.max(left2.length, right2.length);
    return Array.from({ length: length5 }, (_2, index4) => [left2[index4], right2[index4]]);
  }
  function tokensAreEqual(left2, right2) {
    return left2 && right2 && left2.index == right2.index && left2.content == right2.content;
  }
  var ValueListObserver = class {
    constructor(element, attributeName, delegate) {
      this.tokenListObserver = new TokenListObserver(element, attributeName, this);
      this.delegate = delegate;
      this.parseResultsByToken = /* @__PURE__ */ new WeakMap();
      this.valuesByTokenByElement = /* @__PURE__ */ new WeakMap();
    }
    get started() {
      return this.tokenListObserver.started;
    }
    start() {
      this.tokenListObserver.start();
    }
    stop() {
      this.tokenListObserver.stop();
    }
    refresh() {
      this.tokenListObserver.refresh();
    }
    get element() {
      return this.tokenListObserver.element;
    }
    get attributeName() {
      return this.tokenListObserver.attributeName;
    }
    tokenMatched(token2) {
      const { element } = token2;
      const { value: value2 } = this.fetchParseResultForToken(token2);
      if (value2) {
        this.fetchValuesByTokenForElement(element).set(token2, value2);
        this.delegate.elementMatchedValue(element, value2);
      }
    }
    tokenUnmatched(token2) {
      const { element } = token2;
      const { value: value2 } = this.fetchParseResultForToken(token2);
      if (value2) {
        this.fetchValuesByTokenForElement(element).delete(token2);
        this.delegate.elementUnmatchedValue(element, value2);
      }
    }
    fetchParseResultForToken(token2) {
      let parseResult = this.parseResultsByToken.get(token2);
      if (!parseResult) {
        parseResult = this.parseToken(token2);
        this.parseResultsByToken.set(token2, parseResult);
      }
      return parseResult;
    }
    fetchValuesByTokenForElement(element) {
      let valuesByToken = this.valuesByTokenByElement.get(element);
      if (!valuesByToken) {
        valuesByToken = /* @__PURE__ */ new Map();
        this.valuesByTokenByElement.set(element, valuesByToken);
      }
      return valuesByToken;
    }
    parseToken(token2) {
      try {
        const value2 = this.delegate.parseValueForToken(token2);
        return { value: value2 };
      } catch (error4) {
        return { error: error4 };
      }
    }
  };
  var BindingObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.bindingsByAction = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.valueListObserver) {
        this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
        this.valueListObserver.start();
      }
    }
    stop() {
      if (this.valueListObserver) {
        this.valueListObserver.stop();
        delete this.valueListObserver;
        this.disconnectAllActions();
      }
    }
    get element() {
      return this.context.element;
    }
    get identifier() {
      return this.context.identifier;
    }
    get actionAttribute() {
      return this.schema.actionAttribute;
    }
    get schema() {
      return this.context.schema;
    }
    get bindings() {
      return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
      const binding = new Binding(this.context, action);
      this.bindingsByAction.set(action, binding);
      this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
      const binding = this.bindingsByAction.get(action);
      if (binding) {
        this.bindingsByAction.delete(action);
        this.delegate.bindingDisconnected(binding);
      }
    }
    disconnectAllActions() {
      this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
      this.bindingsByAction.clear();
    }
    parseValueForToken(token2) {
      const action = Action.forToken(token2, this.schema);
      if (action.identifier == this.identifier) {
        return action;
      }
    }
    elementMatchedValue(element, action) {
      this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
      this.disconnectAction(action);
    }
  };
  var ValueObserver = class {
    constructor(context, receiver) {
      this.context = context;
      this.receiver = receiver;
      this.stringMapObserver = new StringMapObserver(this.element, this);
      this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
      this.stringMapObserver.start();
      this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
      this.stringMapObserver.stop();
    }
    get element() {
      return this.context.element;
    }
    get controller() {
      return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
      if (attributeName in this.valueDescriptorMap) {
        return this.valueDescriptorMap[attributeName].name;
      }
    }
    stringMapKeyAdded(key, attributeName) {
      const descriptor = this.valueDescriptorMap[attributeName];
      if (!this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
      }
    }
    stringMapValueChanged(value2, name2, oldValue) {
      const descriptor = this.valueDescriptorNameMap[name2];
      if (value2 === null)
        return;
      if (oldValue === null) {
        oldValue = descriptor.writer(descriptor.defaultValue);
      }
      this.invokeChangedCallback(name2, value2, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
      const descriptor = this.valueDescriptorNameMap[key];
      if (this.hasValue(key)) {
        this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
      } else {
        this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
      }
    }
    invokeChangedCallbacksForDefaultValues() {
      for (const { key, name: name2, defaultValue, writer } of this.valueDescriptors) {
        if (defaultValue != void 0 && !this.controller.data.has(key)) {
          this.invokeChangedCallback(name2, writer(defaultValue), void 0);
        }
      }
    }
    invokeChangedCallback(name2, rawValue, rawOldValue) {
      const changedMethodName = `${name2}Changed`;
      const changedMethod = this.receiver[changedMethodName];
      if (typeof changedMethod == "function") {
        const descriptor = this.valueDescriptorNameMap[name2];
        try {
          const value2 = descriptor.reader(rawValue);
          let oldValue = rawOldValue;
          if (rawOldValue) {
            oldValue = descriptor.reader(rawOldValue);
          }
          changedMethod.call(this.receiver, value2, oldValue);
        } catch (error4) {
          if (error4 instanceof TypeError) {
            error4.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error4.message}`;
          }
          throw error4;
        }
      }
    }
    get valueDescriptors() {
      const { valueDescriptorMap } = this;
      return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
      const descriptors = {};
      Object.keys(this.valueDescriptorMap).forEach((key) => {
        const descriptor = this.valueDescriptorMap[key];
        descriptors[descriptor.name] = descriptor;
      });
      return descriptors;
    }
    hasValue(attributeName) {
      const descriptor = this.valueDescriptorNameMap[attributeName];
      const hasMethodName = `has${capitalize(descriptor.name)}`;
      return this.receiver[hasMethodName];
    }
  };
  var TargetObserver = class {
    constructor(context, delegate) {
      this.context = context;
      this.delegate = delegate;
      this.targetsByName = new Multimap();
    }
    start() {
      if (!this.tokenListObserver) {
        this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
        this.tokenListObserver.start();
      }
    }
    stop() {
      if (this.tokenListObserver) {
        this.disconnectAllTargets();
        this.tokenListObserver.stop();
        delete this.tokenListObserver;
      }
    }
    tokenMatched({ element, content: name2 }) {
      if (this.scope.containsElement(element)) {
        this.connectTarget(element, name2);
      }
    }
    tokenUnmatched({ element, content: name2 }) {
      this.disconnectTarget(element, name2);
    }
    connectTarget(element, name2) {
      var _a;
      if (!this.targetsByName.has(name2, element)) {
        this.targetsByName.add(name2, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name2));
      }
    }
    disconnectTarget(element, name2) {
      var _a;
      if (this.targetsByName.has(name2, element)) {
        this.targetsByName.delete(name2, element);
        (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name2));
      }
    }
    disconnectAllTargets() {
      for (const name2 of this.targetsByName.keys) {
        for (const element of this.targetsByName.getValuesForKey(name2)) {
          this.disconnectTarget(element, name2);
        }
      }
    }
    get attributeName() {
      return `data-${this.context.identifier}-target`;
    }
    get element() {
      return this.context.element;
    }
    get scope() {
      return this.context.scope;
    }
  };
  function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor2) => {
      getOwnStaticArrayValues(constructor2, propertyName).forEach((name2) => values.add(name2));
      return values;
    }, /* @__PURE__ */ new Set()));
  }
  function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor2) => {
      pairs.push(...getOwnStaticObjectPairs(constructor2, propertyName));
      return pairs;
    }, []);
  }
  function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
      ancestors.push(constructor);
      constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
  }
  function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
  }
  function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
  }
  var OutletObserver = class {
    constructor(context, delegate) {
      this.started = false;
      this.context = context;
      this.delegate = delegate;
      this.outletsByName = new Multimap();
      this.outletElementsByName = new Multimap();
      this.selectorObserverMap = /* @__PURE__ */ new Map();
      this.attributeObserverMap = /* @__PURE__ */ new Map();
    }
    start() {
      if (!this.started) {
        this.outletDefinitions.forEach((outletName) => {
          this.setupSelectorObserverForOutlet(outletName);
          this.setupAttributeObserverForOutlet(outletName);
        });
        this.started = true;
        this.dependentContexts.forEach((context) => context.refresh());
      }
    }
    refresh() {
      this.selectorObserverMap.forEach((observer) => observer.refresh());
      this.attributeObserverMap.forEach((observer) => observer.refresh());
    }
    stop() {
      if (this.started) {
        this.started = false;
        this.disconnectAllOutlets();
        this.stopSelectorObservers();
        this.stopAttributeObservers();
      }
    }
    stopSelectorObservers() {
      if (this.selectorObserverMap.size > 0) {
        this.selectorObserverMap.forEach((observer) => observer.stop());
        this.selectorObserverMap.clear();
      }
    }
    stopAttributeObservers() {
      if (this.attributeObserverMap.size > 0) {
        this.attributeObserverMap.forEach((observer) => observer.stop());
        this.attributeObserverMap.clear();
      }
    }
    selectorMatched(element, _selector, { outletName }) {
      const outlet = this.getOutlet(element, outletName);
      if (outlet) {
        this.connectOutlet(outlet, element, outletName);
      }
    }
    selectorUnmatched(element, _selector, { outletName }) {
      const outlet = this.getOutletFromMap(element, outletName);
      if (outlet) {
        this.disconnectOutlet(outlet, element, outletName);
      }
    }
    selectorMatchElement(element, { outletName }) {
      const selector = this.selector(outletName);
      const hasOutlet = this.hasOutlet(element, outletName);
      const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
      if (selector) {
        return hasOutlet && hasOutletController && element.matches(selector);
      } else {
        return false;
      }
    }
    elementMatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementAttributeValueChanged(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    elementUnmatchedAttribute(_element, attributeName) {
      const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
      if (outletName) {
        this.updateSelectorObserverForOutlet(outletName);
      }
    }
    connectOutlet(outlet, element, outletName) {
      var _a;
      if (!this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.add(outletName, outlet);
        this.outletElementsByName.add(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
      }
    }
    disconnectOutlet(outlet, element, outletName) {
      var _a;
      if (this.outletElementsByName.has(outletName, element)) {
        this.outletsByName.delete(outletName, outlet);
        this.outletElementsByName.delete(outletName, element);
        (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
      }
    }
    disconnectAllOutlets() {
      for (const outletName of this.outletElementsByName.keys) {
        for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
          for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
            this.disconnectOutlet(outlet, element, outletName);
          }
        }
      }
    }
    updateSelectorObserverForOutlet(outletName) {
      const observer = this.selectorObserverMap.get(outletName);
      if (observer) {
        observer.selector = this.selector(outletName);
      }
    }
    setupSelectorObserverForOutlet(outletName) {
      const selector = this.selector(outletName);
      const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
      this.selectorObserverMap.set(outletName, selectorObserver);
      selectorObserver.start();
    }
    setupAttributeObserverForOutlet(outletName) {
      const attributeName = this.attributeNameForOutletName(outletName);
      const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
      this.attributeObserverMap.set(outletName, attributeObserver);
      attributeObserver.start();
    }
    selector(outletName) {
      return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    attributeNameForOutletName(outletName) {
      return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
    }
    getOutletNameFromOutletAttributeName(attributeName) {
      return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
    }
    get outletDependencies() {
      const dependencies = new Multimap();
      this.router.modules.forEach((module) => {
        const constructor = module.definition.controllerConstructor;
        const outlets = readInheritableStaticArrayValues(constructor, "outlets");
        outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
      });
      return dependencies;
    }
    get outletDefinitions() {
      return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
      return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
      const identifiers = this.dependentControllerIdentifiers;
      return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
    }
    hasOutlet(element, outletName) {
      return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
      return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
      return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
      return this.context.scope;
    }
    get schema() {
      return this.context.schema;
    }
    get identifier() {
      return this.context.identifier;
    }
    get application() {
      return this.context.application;
    }
    get router() {
      return this.application.router;
    }
  };
  var Context = class {
    constructor(module, scope) {
      this.logDebugActivity = (functionName, detail = {}) => {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.logDebugActivity(this.identifier, functionName, detail);
      };
      this.module = module;
      this.scope = scope;
      this.controller = new module.controllerConstructor(this);
      this.bindingObserver = new BindingObserver(this, this.dispatcher);
      this.valueObserver = new ValueObserver(this, this.controller);
      this.targetObserver = new TargetObserver(this, this);
      this.outletObserver = new OutletObserver(this, this);
      try {
        this.controller.initialize();
        this.logDebugActivity("initialize");
      } catch (error4) {
        this.handleError(error4, "initializing controller");
      }
    }
    connect() {
      this.bindingObserver.start();
      this.valueObserver.start();
      this.targetObserver.start();
      this.outletObserver.start();
      try {
        this.controller.connect();
        this.logDebugActivity("connect");
      } catch (error4) {
        this.handleError(error4, "connecting controller");
      }
    }
    refresh() {
      this.outletObserver.refresh();
    }
    disconnect() {
      try {
        this.controller.disconnect();
        this.logDebugActivity("disconnect");
      } catch (error4) {
        this.handleError(error4, "disconnecting controller");
      }
      this.outletObserver.stop();
      this.targetObserver.stop();
      this.valueObserver.stop();
      this.bindingObserver.stop();
    }
    get application() {
      return this.module.application;
    }
    get identifier() {
      return this.module.identifier;
    }
    get schema() {
      return this.application.schema;
    }
    get dispatcher() {
      return this.application.dispatcher;
    }
    get element() {
      return this.scope.element;
    }
    get parentElement() {
      return this.element.parentElement;
    }
    handleError(error4, message, detail = {}) {
      const { identifier, controller, element } = this;
      detail = Object.assign({ identifier, controller, element }, detail);
      this.application.handleError(error4, `Error ${message}`, detail);
    }
    targetConnected(element, name2) {
      this.invokeControllerMethod(`${name2}TargetConnected`, element);
    }
    targetDisconnected(element, name2) {
      this.invokeControllerMethod(`${name2}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name2) {
      this.invokeControllerMethod(`${namespaceCamelize(name2)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name2) {
      this.invokeControllerMethod(`${namespaceCamelize(name2)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
      const controller = this.controller;
      if (typeof controller[methodName] == "function") {
        controller[methodName](...args);
      }
    }
  };
  function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
  }
  function shadow(constructor, properties) {
    const shadowConstructor = extend2(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
  }
  function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
      const properties = blessing(constructor);
      for (const key in properties) {
        const descriptor = blessedProperties[key] || {};
        blessedProperties[key] = Object.assign(descriptor, properties[key]);
      }
      return blessedProperties;
    }, {});
  }
  function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
      const descriptor = getShadowedDescriptor(prototype, properties, key);
      if (descriptor) {
        Object.assign(shadowProperties, { [key]: descriptor });
      }
      return shadowProperties;
    }, {});
  }
  function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
      const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
      if (shadowingDescriptor) {
        descriptor.get = shadowingDescriptor.get || descriptor.get;
        descriptor.set = shadowingDescriptor.set || descriptor.set;
      }
      return descriptor;
    }
  }
  var getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
      return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    } else {
      return Object.getOwnPropertyNames;
    }
  })();
  var extend2 = (() => {
    function extendWithReflect(constructor) {
      function extended() {
        return Reflect.construct(constructor, arguments, new.target);
      }
      extended.prototype = Object.create(constructor.prototype, {
        constructor: { value: extended }
      });
      Reflect.setPrototypeOf(extended, constructor);
      return extended;
    }
    function testReflectExtension() {
      const a3 = function() {
        this.a.call(this);
      };
      const b = extendWithReflect(a3);
      b.prototype.a = function() {
      };
      return new b();
    }
    try {
      testReflectExtension();
      return extendWithReflect;
    } catch (error4) {
      return (constructor) => class extended extends constructor {
      };
    }
  })();
  function blessDefinition(definition) {
    return {
      identifier: definition.identifier,
      controllerConstructor: bless(definition.controllerConstructor)
    };
  }
  var Module = class {
    constructor(application2, definition) {
      this.application = application2;
      this.definition = blessDefinition(definition);
      this.contextsByScope = /* @__PURE__ */ new WeakMap();
      this.connectedContexts = /* @__PURE__ */ new Set();
    }
    get identifier() {
      return this.definition.identifier;
    }
    get controllerConstructor() {
      return this.definition.controllerConstructor;
    }
    get contexts() {
      return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
      const context = this.fetchContextForScope(scope);
      this.connectedContexts.add(context);
      context.connect();
    }
    disconnectContextForScope(scope) {
      const context = this.contextsByScope.get(scope);
      if (context) {
        this.connectedContexts.delete(context);
        context.disconnect();
      }
    }
    fetchContextForScope(scope) {
      let context = this.contextsByScope.get(scope);
      if (!context) {
        context = new Context(this, scope);
        this.contextsByScope.set(scope, context);
      }
      return context;
    }
  };
  var ClassMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    has(name2) {
      return this.data.has(this.getDataKey(name2));
    }
    get(name2) {
      return this.getAll(name2)[0];
    }
    getAll(name2) {
      const tokenString = this.data.get(this.getDataKey(name2)) || "";
      return tokenize(tokenString);
    }
    getAttributeName(name2) {
      return this.data.getAttributeNameForKey(this.getDataKey(name2));
    }
    getDataKey(name2) {
      return `${name2}-class`;
    }
    get data() {
      return this.scope.data;
    }
  };
  var DataMap = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get(key) {
      const name2 = this.getAttributeNameForKey(key);
      return this.element.getAttribute(name2);
    }
    set(key, value2) {
      const name2 = this.getAttributeNameForKey(key);
      this.element.setAttribute(name2, value2);
      return this.get(key);
    }
    has(key) {
      const name2 = this.getAttributeNameForKey(key);
      return this.element.hasAttribute(name2);
    }
    delete(key) {
      if (this.has(key)) {
        const name2 = this.getAttributeNameForKey(key);
        this.element.removeAttribute(name2);
        return true;
      } else {
        return false;
      }
    }
    getAttributeNameForKey(key) {
      return `data-${this.identifier}-${dasherize(key)}`;
    }
  };
  var Guide = class {
    constructor(logger) {
      this.warnedKeysByObject = /* @__PURE__ */ new WeakMap();
      this.logger = logger;
    }
    warn(object, key, message) {
      let warnedKeys = this.warnedKeysByObject.get(object);
      if (!warnedKeys) {
        warnedKeys = /* @__PURE__ */ new Set();
        this.warnedKeysByObject.set(object, warnedKeys);
      }
      if (!warnedKeys.has(key)) {
        warnedKeys.add(key);
        this.logger.warn(message, object);
      }
    }
  };
  function attributeValueContainsToken(attributeName, token2) {
    return `[${attributeName}~="${token2}"]`;
  }
  var TargetSet = class {
    constructor(scope) {
      this.scope = scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(targetName) {
      return this.find(targetName) != null;
    }
    find(...targetNames) {
      return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), void 0);
    }
    findAll(...targetNames) {
      return targetNames.reduce((targets, targetName) => [
        ...targets,
        ...this.findAllTargets(targetName),
        ...this.findAllLegacyTargets(targetName)
      ], []);
    }
    findTarget(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
      const selector = this.getSelectorForTargetName(targetName);
      return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
      const attributeName = this.schema.targetAttributeForScope(this.identifier);
      return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
      const selector = this.getLegacySelectorForTargetName(targetName);
      return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
      const targetDescriptor = `${this.identifier}.${targetName}`;
      return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
      if (element) {
        const { identifier } = this;
        const attributeName = this.schema.targetAttribute;
        const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
        this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
      }
      return element;
    }
    get guide() {
      return this.scope.guide;
    }
  };
  var OutletSet = class {
    constructor(scope, controllerElement) {
      this.scope = scope;
      this.controllerElement = controllerElement;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get schema() {
      return this.scope.schema;
    }
    has(outletName) {
      return this.find(outletName) != null;
    }
    find(...outletNames) {
      return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), void 0);
    }
    findAll(...outletNames) {
      return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
      const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
      return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      if (selector)
        return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
      const selector = this.getSelectorForOutletName(outletName);
      return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
      const elements = this.scope.queryElements(selector);
      return elements.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
      const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
      return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
  };
  var Scope = class _Scope {
    constructor(schema, element, identifier, logger) {
      this.targets = new TargetSet(this);
      this.classes = new ClassMap(this);
      this.data = new DataMap(this);
      this.containsElement = (element2) => {
        return element2.closest(this.controllerSelector) === this.element;
      };
      this.schema = schema;
      this.element = element;
      this.identifier = identifier;
      this.guide = new Guide(logger);
      this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
      return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
      return [
        ...this.element.matches(selector) ? [this.element] : [],
        ...this.queryElements(selector).filter(this.containsElement)
      ];
    }
    queryElements(selector) {
      return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
      return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
      return this.element === document.documentElement;
    }
    get documentScope() {
      return this.isDocumentScope ? this : new _Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
  };
  var ScopeObserver = class {
    constructor(element, schema, delegate) {
      this.element = element;
      this.schema = schema;
      this.delegate = delegate;
      this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
      this.scopesByIdentifierByElement = /* @__PURE__ */ new WeakMap();
      this.scopeReferenceCounts = /* @__PURE__ */ new WeakMap();
    }
    start() {
      this.valueListObserver.start();
    }
    stop() {
      this.valueListObserver.stop();
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    parseValueForToken(token2) {
      const { element, content: identifier } = token2;
      return this.parseValueForElementAndIdentifier(element, identifier);
    }
    parseValueForElementAndIdentifier(element, identifier) {
      const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
      let scope = scopesByIdentifier.get(identifier);
      if (!scope) {
        scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
        scopesByIdentifier.set(identifier, scope);
      }
      return scope;
    }
    elementMatchedValue(element, value2) {
      const referenceCount = (this.scopeReferenceCounts.get(value2) || 0) + 1;
      this.scopeReferenceCounts.set(value2, referenceCount);
      if (referenceCount == 1) {
        this.delegate.scopeConnected(value2);
      }
    }
    elementUnmatchedValue(element, value2) {
      const referenceCount = this.scopeReferenceCounts.get(value2);
      if (referenceCount) {
        this.scopeReferenceCounts.set(value2, referenceCount - 1);
        if (referenceCount == 1) {
          this.delegate.scopeDisconnected(value2);
        }
      }
    }
    fetchScopesByIdentifierForElement(element) {
      let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
      if (!scopesByIdentifier) {
        scopesByIdentifier = /* @__PURE__ */ new Map();
        this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
      }
      return scopesByIdentifier;
    }
  };
  var Router = class {
    constructor(application2) {
      this.application = application2;
      this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
      this.scopesByIdentifier = new Multimap();
      this.modulesByIdentifier = /* @__PURE__ */ new Map();
    }
    get element() {
      return this.application.element;
    }
    get schema() {
      return this.application.schema;
    }
    get logger() {
      return this.application.logger;
    }
    get controllerAttribute() {
      return this.schema.controllerAttribute;
    }
    get modules() {
      return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
      return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
      this.scopeObserver.start();
    }
    stop() {
      this.scopeObserver.stop();
    }
    loadDefinition(definition) {
      this.unloadIdentifier(definition.identifier);
      const module = new Module(this.application, definition);
      this.connectModule(module);
      const afterLoad = definition.controllerConstructor.afterLoad;
      if (afterLoad) {
        afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
      }
    }
    unloadIdentifier(identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        this.disconnectModule(module);
      }
    }
    getContextForElementAndIdentifier(element, identifier) {
      const module = this.modulesByIdentifier.get(identifier);
      if (module) {
        return module.contexts.find((context) => context.element == element);
      }
    }
    proposeToConnectScopeForElementAndIdentifier(element, identifier) {
      const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
      if (scope) {
        this.scopeObserver.elementMatchedValue(scope.element, scope);
      } else {
        console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
      }
    }
    handleError(error4, message, detail) {
      this.application.handleError(error4, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
      return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
      this.scopesByIdentifier.add(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.connectContextForScope(scope);
      }
    }
    scopeDisconnected(scope) {
      this.scopesByIdentifier.delete(scope.identifier, scope);
      const module = this.modulesByIdentifier.get(scope.identifier);
      if (module) {
        module.disconnectContextForScope(scope);
      }
    }
    connectModule(module) {
      this.modulesByIdentifier.set(module.identifier, module);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
      this.modulesByIdentifier.delete(module.identifier);
      const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
      scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
  };
  var defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c5) => [c5, c5]))), objectFromEntries("0123456789".split("").map((n2) => [n2, n2])))
  };
  function objectFromEntries(array2) {
    return array2.reduce((memo, [k, v]) => Object.assign(Object.assign({}, memo), { [k]: v }), {});
  }
  var Application = class {
    constructor(element = document.documentElement, schema = defaultSchema) {
      this.logger = console;
      this.debug = false;
      this.logDebugActivity = (identifier, functionName, detail = {}) => {
        if (this.debug) {
          this.logFormattedMessage(identifier, functionName, detail);
        }
      };
      this.element = element;
      this.schema = schema;
      this.dispatcher = new Dispatcher(this);
      this.router = new Router(this);
      this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
      const application2 = new this(element, schema);
      application2.start();
      return application2;
    }
    async start() {
      await domReady();
      this.logDebugActivity("application", "starting");
      this.dispatcher.start();
      this.router.start();
      this.logDebugActivity("application", "start");
    }
    stop() {
      this.logDebugActivity("application", "stopping");
      this.dispatcher.stop();
      this.router.stop();
      this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
      this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name2, filter2) {
      this.actionDescriptorFilters[name2] = filter2;
    }
    load(head, ...rest) {
      const definitions = Array.isArray(head) ? head : [head, ...rest];
      definitions.forEach((definition) => {
        if (definition.controllerConstructor.shouldLoad) {
          this.router.loadDefinition(definition);
        }
      });
    }
    unload(head, ...rest) {
      const identifiers = Array.isArray(head) ? head : [head, ...rest];
      identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
      return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
      const context = this.router.getContextForElementAndIdentifier(element, identifier);
      return context ? context.controller : null;
    }
    handleError(error4, message, detail) {
      var _a;
      this.logger.error(`%s

%o

%o`, message, error4, detail);
      (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error4);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
      detail = Object.assign({ application: this }, detail);
      this.logger.groupCollapsed(`${identifier} #${functionName}`);
      this.logger.log("details:", Object.assign({}, detail));
      this.logger.groupEnd();
    }
  };
  function domReady() {
    return new Promise((resolve) => {
      if (document.readyState == "loading") {
        document.addEventListener("DOMContentLoaded", () => resolve());
      } else {
        resolve();
      }
    });
  }
  function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
      return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
  }
  function propertiesForClassDefinition(key) {
    return {
      [`${key}Class`]: {
        get() {
          const { classes } = this;
          if (classes.has(key)) {
            return classes.get(key);
          } else {
            const attribute = classes.getAttributeName(key);
            throw new Error(`Missing attribute "${attribute}"`);
          }
        }
      },
      [`${key}Classes`]: {
        get() {
          return this.classes.getAll(key);
        }
      },
      [`has${capitalize(key)}Class`]: {
        get() {
          return this.classes.has(key);
        }
      }
    };
  }
  function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
      return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
  }
  function getOutletController(controller, element, identifier) {
    return controller.application.getControllerForElementAndIdentifier(element, identifier);
  }
  function getControllerAndEnsureConnectedScope(controller, element, outletName) {
    let outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
    controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
    outletController = getOutletController(controller, element, outletName);
    if (outletController)
      return outletController;
  }
  function propertiesForOutletDefinition(name2) {
    const camelizedName = namespaceCamelize(name2);
    return {
      [`${camelizedName}Outlet`]: {
        get() {
          const outletElement = this.outlets.find(name2);
          const selector = this.outlets.getSelectorForOutletName(name2);
          if (outletElement) {
            const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name2);
            if (outletController)
              return outletController;
            throw new Error(`The provided outlet element is missing an outlet controller "${name2}" instance for host controller "${this.identifier}"`);
          }
          throw new Error(`Missing outlet element "${name2}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
        }
      },
      [`${camelizedName}Outlets`]: {
        get() {
          const outlets = this.outlets.findAll(name2);
          if (outlets.length > 0) {
            return outlets.map((outletElement) => {
              const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name2);
              if (outletController)
                return outletController;
              console.warn(`The provided outlet element is missing an outlet controller "${name2}" instance for host controller "${this.identifier}"`, outletElement);
            }).filter((controller) => controller);
          }
          return [];
        }
      },
      [`${camelizedName}OutletElement`]: {
        get() {
          const outletElement = this.outlets.find(name2);
          const selector = this.outlets.getSelectorForOutletName(name2);
          if (outletElement) {
            return outletElement;
          } else {
            throw new Error(`Missing outlet element "${name2}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
          }
        }
      },
      [`${camelizedName}OutletElements`]: {
        get() {
          return this.outlets.findAll(name2);
        }
      },
      [`has${capitalize(camelizedName)}Outlet`]: {
        get() {
          return this.outlets.has(name2);
        }
      }
    };
  }
  function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
      return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
  }
  function propertiesForTargetDefinition(name2) {
    return {
      [`${name2}Target`]: {
        get() {
          const target = this.targets.find(name2);
          if (target) {
            return target;
          } else {
            throw new Error(`Missing target element "${name2}" for "${this.identifier}" controller`);
          }
        }
      },
      [`${name2}Targets`]: {
        get() {
          return this.targets.findAll(name2);
        }
      },
      [`has${capitalize(name2)}Target`]: {
        get() {
          return this.targets.has(name2);
        }
      }
    };
  }
  function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
      valueDescriptorMap: {
        get() {
          return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
            const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
            const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
            return Object.assign(result, { [attributeName]: valueDescriptor });
          }, {});
        }
      }
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
      return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
  }
  function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name: name2, reader: read, writer: write } = definition;
    return {
      [name2]: {
        get() {
          const value2 = this.data.get(key);
          if (value2 !== null) {
            return read(value2);
          } else {
            return definition.defaultValue;
          }
        },
        set(value2) {
          if (value2 === void 0) {
            this.data.delete(key);
          } else {
            this.data.set(key, write(value2));
          }
        }
      },
      [`has${capitalize(name2)}`]: {
        get() {
          return this.data.has(key) || definition.hasCustomDefaultValue;
        }
      }
    };
  }
  function parseValueDefinitionPair([token2, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
      controller,
      token: token2,
      typeDefinition
    });
  }
  function parseValueTypeConstant(constant4) {
    switch (constant4) {
      case Array:
        return "array";
      case Boolean:
        return "boolean";
      case Number:
        return "number";
      case Object:
        return "object";
      case String:
        return "string";
    }
  }
  function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
      case "boolean":
        return "boolean";
      case "number":
        return "number";
      case "string":
        return "string";
    }
    if (Array.isArray(defaultValue))
      return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
      return "object";
  }
  function parseValueTypeObject(payload) {
    const { controller, token: token2, typeObject } = payload;
    const hasType = isSomething(typeObject.type);
    const hasDefault = isSomething(typeObject.default);
    const fullObject = hasType && hasDefault;
    const onlyType = hasType && !hasDefault;
    const onlyDefault = !hasType && hasDefault;
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
    if (onlyType)
      return typeFromObject;
    if (onlyDefault)
      return typeFromDefaultValue;
    if (typeFromObject !== typeFromDefaultValue) {
      const propertyPath = controller ? `${controller}.${token2}` : token2;
      throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
    }
    if (fullObject)
      return typeFromObject;
  }
  function parseValueTypeDefinition(payload) {
    const { controller, token: token2, typeDefinition } = payload;
    const typeObject = { controller, token: token2, typeObject: typeDefinition };
    const typeFromObject = parseValueTypeObject(typeObject);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
      return type;
    const propertyPath = controller ? `${controller}.${typeDefinition}` : token2;
    throw new Error(`Unknown value type "${propertyPath}" for "${token2}" value`);
  }
  function defaultValueForDefinition(typeDefinition) {
    const constant4 = parseValueTypeConstant(typeDefinition);
    if (constant4)
      return defaultValuesByType[constant4];
    const hasDefault = hasProperty(typeDefinition, "default");
    const hasType = hasProperty(typeDefinition, "type");
    const typeObject = typeDefinition;
    if (hasDefault)
      return typeObject.default;
    if (hasType) {
      const { type } = typeObject;
      const constantFromType = parseValueTypeConstant(type);
      if (constantFromType)
        return defaultValuesByType[constantFromType];
    }
    return typeDefinition;
  }
  function valueDescriptorForTokenAndTypeDefinition(payload) {
    const { token: token2, typeDefinition } = payload;
    const key = `${dasherize(token2)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
      type,
      key,
      name: camelize(key),
      get defaultValue() {
        return defaultValueForDefinition(typeDefinition);
      },
      get hasCustomDefaultValue() {
        return parseValueTypeDefault(typeDefinition) !== void 0;
      },
      reader: readers[type],
      writer: writers[type] || writers.default
    };
  }
  var defaultValuesByType = {
    get array() {
      return [];
    },
    boolean: false,
    number: 0,
    get object() {
      return {};
    },
    string: ""
  };
  var readers = {
    array(value2) {
      const array2 = JSON.parse(value2);
      if (!Array.isArray(array2)) {
        throw new TypeError(`expected value of type "array" but instead got value "${value2}" of type "${parseValueTypeDefault(array2)}"`);
      }
      return array2;
    },
    boolean(value2) {
      return !(value2 == "0" || String(value2).toLowerCase() == "false");
    },
    number(value2) {
      return Number(value2.replace(/_/g, ""));
    },
    object(value2) {
      const object = JSON.parse(value2);
      if (object === null || typeof object != "object" || Array.isArray(object)) {
        throw new TypeError(`expected value of type "object" but instead got value "${value2}" of type "${parseValueTypeDefault(object)}"`);
      }
      return object;
    },
    string(value2) {
      return value2;
    }
  };
  var writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON
  };
  function writeJSON(value2) {
    return JSON.stringify(value2);
  }
  function writeString(value2) {
    return `${value2}`;
  }
  var Controller = class {
    constructor(context) {
      this.context = context;
    }
    static get shouldLoad() {
      return true;
    }
    static afterLoad(_identifier, _application) {
      return;
    }
    get application() {
      return this.context.application;
    }
    get scope() {
      return this.context.scope;
    }
    get element() {
      return this.scope.element;
    }
    get identifier() {
      return this.scope.identifier;
    }
    get targets() {
      return this.scope.targets;
    }
    get outlets() {
      return this.scope.outlets;
    }
    get classes() {
      return this.scope.classes;
    }
    get data() {
      return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true } = {}) {
      const type = prefix ? `${prefix}:${eventName}` : eventName;
      const event = new CustomEvent(type, { detail, bubbles, cancelable });
      target.dispatchEvent(event);
      return event;
    }
  };
  Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing
  ];
  Controller.targets = [];
  Controller.outlets = [];
  Controller.values = {};

  // ../../engine/rails_design/app/javascripts/stimulus_base/index.js
  window.application = Application.start();
  HTMLElement.prototype.getController = function(identifier) {
    return application.getControllerForElementAndIdentifier(this, identifier);
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/alert.js
  var alert_default = class extends Controller {
    static values = {
      content: String
    };
    alert() {
      alert(this.contentValue);
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/animate-typer.js
  var animate_typer_default = class extends Controller {
    static targets = ["src", "item"];
    connect() {
      const ele = this.element;
      ele.classList.remove("invisible");
      ele.style.animationDuration = `${ele.innerText.length * 200}ms`;
      ele.classList.add("has-animate-typer");
      ele.addEventListener("animationend", this.typeNext, { once: true });
    }
    typeNext(event) {
      const ele = event.currentTarget;
      let nextEle = ele.nextElementSibling;
      while (nextEle) {
        if (nextEle.innerHTML) {
          nextEle.dataset.add("controller", "animate-typer");
          break;
        } else {
          nextEle = nextEle.nextElementSibling;
        }
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/audio-player.js
  var audio_player_default = class extends Controller {
    static values = {
      auto: String,
      url: String,
      link: String,
      loop: { type: Boolean, default: false },
      next: { type: Boolean, default: true }
    };
    initialize() {
      window.audioContext ||= new AudioContext();
    }
    connect() {
      if (this.hasAutoValue) {
        this.doPlay(this.autoValue);
      } else if (this.hasUrlValue) {
        this.doFetch(this.urlValue);
      }
      if (window.__wxjs_environment === "miniprogram") {
        WeixinJSBridge.on("onPageStateChange", (res) => {
          if (res.active === "true" || res.active === true) {
            this.stop();
          }
        });
      }
    }
    disconnect() {
      this.disconnected = true;
      this.source?.stop();
    }
    stop() {
      this.source.stop();
    }
    play(event) {
      if (this.hasAutoValue) {
        this.doPlay(this.autoValue);
      } else if (this.hasUrlValue) {
        this.doPlay(this.urlValue);
      }
    }
    autoPlay() {
      this.element.querySelector(":scope > video:first-child")?.play();
    }
    async doPlay(url) {
      await this.doFetch(url, this.doStart);
    }
    async doFetch(url, callback) {
      const response = await fetch(url);
      audioContext.decodeAudioData(await response.arrayBuffer(), (decodeData) => {
        this.source = audioContext.createBufferSource();
        this.source.buffer = decodeData;
        this.source.connect(audioContext.destination);
        this.source.loop = this.loopValue;
        console.log(this.source);
        callback(this);
      });
    }
    doStart(that = this) {
      console.debug("---------------", that);
      if (!that.disconnected) {
        that.source.start();
      }
      if (that.linkValue) {
        that.source.addEventListener("ended", (e3) => {
          Turbo.visit(that.linkValue);
        });
      } else if (that.nextValue) {
        that.source.that = that;
        that.source.addEventListener("ended", that.goPlayNext);
      }
    }
    playNext(event) {
      let ele = event.currentTarget;
      const controller = event.target.closest("[data-controller~=audio-player]").getController("audio-player");
      controller.playAnd(ele);
    }
    playAnd(ele) {
      if (ele.dataset.hidden) {
        const hiddenEles = document.querySelectorAll(ele.dataset.hidden);
        hiddenEles.forEach((el) => {
          el.style.display = "none";
          if (["VIDEO", "AUDIO"].includes(el.tagName)) {
            el.pause();
          } else {
            el.querySelectorAll("video, audio").forEach((hideVideo) => {
              hideVideo.pause();
            });
          }
        });
      }
      if (ele.dataset.next) {
        const nextEles = document.querySelectorAll(ele.dataset.next);
        nextEles.forEach((nextEle) => {
          nextEle.style.removeProperty("display");
          if (["VIDEO", "AUDIO"].includes(nextEle.tagName)) {
            nextEle.play();
          } else if (nextEle.getController("audio-player")) {
            nextEle.getController("audio-player").doStart();
          } else {
            nextEle.querySelectorAll("video, audio").forEach((nextVideo) => {
              nextVideo.play();
            });
          }
        });
      }
    }
    goPlayNext(event) {
      const tar = event.currentTarget;
      tar.that.playAnd(tar.that.element);
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/cable.js
  var cable_default = class extends Controller {
    connect() {
      consumer.connection.reopen();
    }
  };

  // ../../engine/rails_design/app/javascripts/base_controller.js
  var base_controller_default = class extends Controller {
    static values = {
      url: String,
      input: String,
      params: Object
    };
    csrfToken() {
      const meta = document.querySelector("meta[name=csrf-token]");
      return meta && meta.content;
    }
    get(url) {
      this.request(url, "GET");
    }
    post(url, body, headers) {
      this.request(
        url,
        "POST",
        body,
        { "Content-Type": "application/json", "X-CSRF-Token": this.csrfToken(), ...headers }
      );
    }
    patch(url, body, headers) {
      this.request(
        url,
        "PATCH",
        body,
        { "Content-Type": "application/json", "X-CSRF-Token": this.csrfToken(), ...headers }
      );
    }
    formPost(form) {
      this.request(
        this.urlValue,
        "POST",
        new FormData(form),
        { "X-CSRF-Token": this.csrfToken() }
      );
    }
    inputPost(input) {
      const body = new FormData();
      if (this.hasInputValue) {
        body.append(this.inputValue, input.value);
      } else {
        body.append(input.name, input.value);
      }
      if (this.hasParamsValue) {
        Object.keys(this.paramsValue).forEach((k) => {
          body.append(k, this.paramsValue[k]);
        });
      }
      this.request(
        this.urlValue,
        "POST",
        body,
        { "X-CSRF-Token": this.csrfToken() }
      );
    }
    inputGet(input) {
      let url;
      if (input.dataset.url) {
        url = new URL(input.dataset.url, location.origin);
      } else {
        url = new URL(this.urlValue, location.origin);
      }
      if (this.hasInputValue) {
        url.searchParams.set(this.inputValue, input.value);
      } else {
        url.searchParams.set(input.name, input.value);
      }
      if (this.hasParamsValue) {
        Object.keys(this.paramsValue).forEach((k) => {
          url.searchParams.set(k, this.paramsValue[k]);
        });
      }
      this.get(url);
    }
    request(url, method, body, headers) {
      fetch(url, {
        credentials: "include",
        method: method.toUpperCase(),
        headers: {
          Accept: "text/vnd.turbo-stream.html",
          ...headers
        },
        body
      }).then((response) => {
        return response.text();
      }).then((body2) => {
        Turbo.renderStreamMessage(body2);
      });
    }
    get locale() {
      return document.querySelector("html").lang;
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/common.js
  var common_default = class extends base_controller_default {
    static values = {
      body: String
    };
    cancel(event) {
      event.preventDefault();
      Turbo.visit(location.href, { action: "replace" });
    }
    link() {
      this.post(this.urlValue, this.bodyValue);
    }
    streamPost() {
      this.post(this.urlValue, this.bodyValue);
    }
    stream(event) {
      const ele = event.currentTarget;
      this.inputGet(ele);
    }
    postInput(event) {
      const ele = event.currentTarget;
      this.inputPost(ele);
    }
    // turbo:submit-start@window->common#submit
    submit(event) {
      const form = event.detail.formSubmission;
      form.mustRedirect = false;
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/clipboard.js
  var clipboard_default = class extends Controller {
    static targets = ["source", "toast"];
    copyInput() {
      navigator.clipboard.writeText(this.sourceTarget.value);
    }
    copyInner() {
      navigator.clipboard.writeText(this.sourceTarget.innerText);
    }
    copy() {
      navigator.clipboard?.writeText(this.sourceTarget.textContent);
      if (this.hasToastTarget) {
        this.toastTarget.style.animationDuration = "2s";
        this.toastTarget.classList.remove("display-none");
        this.toastTarget.classList.add("has-animate-fade-in-out");
        this.toastTarget.addEventListener("animationend", (event) => {
          event.currentTarget.classList.add("display-none");
          event.currentTarget.classList.remove("has-animate-fade-in-out");
        }, { once: true });
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/count-down.js
  var count_down_default = class extends Controller {
    static values = {
      time: { type: Number, default: 60 },
      get: { type: String, default: "\u83B7\u53D6\u9A8C\u8BC1\u7801" }
    };
    static targets = ["count", "hidden", "disabled"];
    connect() {
      this.countDown();
    }
    countDown() {
      let countdown = this.timeValue;
      this.countTarget.innerText = countdown;
      let timer2 = setInterval(() => {
        countdown--;
        if (countdown <= 0) {
          if (this.hasDisabledTarget) {
            this.disabledTarget.removeAttribute("disabled");
          }
          this.countTarget.innerText = this.getValue;
          this.hiddenTargets.forEach((el) => {
            el.remove();
          });
          clearInterval(timer2);
        } else {
          this.countTarget.innerText = countdown;
        }
      }, 1e3, countdown);
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/custom.js
  var custom_default = class extends Controller {
    static classes = ["remove", "add"];
    static values = {
      order: Array,
      only: Boolean
    };
    toggle(event) {
      const checkbox = event.currentTarget;
      if (checkbox.checked) {
        this.toggleOn(checkbox);
      } else if (!checkbox.checked) {
        this.toggleOffCss(checkbox);
      }
      checkbox.form.requestSubmit();
    }
    toggleOn(checkbox) {
      const cl = checkbox.parentElement.classList;
      cl.remove("weui-btn_default");
      cl.add("weui-btn_primary");
      if (this.onlyValue) {
        this.toggleOffOther(checkbox);
      }
    }
    toggleOff(checkbox) {
      checkbox.checked = false;
      this.toggleOffCss(checkbox);
    }
    toggleOffCss(checkbox) {
      checkbox.labels.forEach((i) => {
        i.classList.remove("weui-btn_primary");
        i.classList.add("weui-btn_default");
      });
    }
    toggleOnDisable(input) {
      input.disabled = true;
      input.labels.forEach((i) => {
        i.classList.add("weui-cell_disabled");
      });
    }
    toggleOffDisable(input) {
      if (input.disabled) {
        input.disabled = false;
        input.labels.forEach((i) => {
          i.classList.remove("weui-cell_disabled");
        });
      }
    }
    toggleOffOther(checkbox) {
      const items = checkbox.form.elements[checkbox.name];
      let toRemove;
      for (let i of items) {
        if (i.dataset.partTaxonId === checkbox.dataset.partTaxonId && i !== checkbox) {
          if (i.type === "checkbox") {
            this.toggleOff(i);
            this.toggleOffDisable(i);
          } else if (i.type === "hidden") {
            toRemove = i;
          }
        }
      }
      if (toRemove) {
        toRemove.remove();
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/dispatch.js
  var dispatch_default = class extends Controller {
    static values = {
      id: String,
      controller: String,
      action: String,
      click: String
    };
    static outlets = ["modal"];
    stop() {
      this.outlet["stop"]();
    }
    doClick() {
      this.modalOutlet[this.clickValue]();
    }
    get outlet() {
      return document.getElementById(this.idValue).getController(this.controllerValue);
    }
  };

  // ../../engine/rails_design/app/javascripts/channels/cable.js
  init_src();
  var cable_default2 = createConsumer();

  // ../../engine/rails_design/app/javascripts/stimulus_com/done.js
  var done_default = class extends Controller {
    static values = {
      content: String
    };
    connect() {
      this.subscription = cable_default2.subscriptions.create({ channel: "Datum::DoneChannel" }, {
        received(data2) {
          Turbo.renderStreamMessage(data2);
        },
        connected() {
          console.log("connected:", this.identifier);
        },
        disconnected() {
          console.debug("disconnected:", this.identifier);
        }
      });
    }
    disconnect() {
      this.subscription.unsubscribe();
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/draw-line.js
  var draw_line_default = class extends Controller {
    link() {
      this.element.querySelectorAll("[data-id]").forEach((el) => {
        const src = document.getElementById(el.dataset.id);
        this.drawLine(src, el);
      });
    }
    drawLine(src, dest) {
      const src_x = src.getBoundingClientRect().right;
      const src_y = src.getBoundingClientRect().top + src.clientHeight / 2;
      const dest_x = dest.getBoundingClientRect().left;
      const dest_y = dest.getBoundingClientRect().top + dest.clientHeight / 2;
      const length5 = Math.sqrt(Math.pow(dest_x - src_x, 2), Math.pow(dest_y - src_y, 2));
      const rad = Math.atan2(dest_y - src_y, dest_x - src_x);
      const top = (src_y + dest_y) / 2;
      const left2 = (src_x + dest_x) / 2 - length5 / 2;
      const line4 = document.createElement("div");
      line4.classList.add("draw-line");
      line4.style.top = `${top}px`;
      line4.style.left = `${left2}px`;
      line4.style.width = `${length5}px`;
      line4.style.transform = `rotate(${rad}rad)`;
      document.body.appendChild(line4);
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/empty.js
  var empty_default = class extends Controller {
    static targets = ["content", "text"];
    connect() {
      if (this.hasContentTarget && this.contentTarget.childElementCount < 1) {
        this.element.remove();
      } else if (this.hasTextTarget && this.textTarget.innerText.length < 1) {
        this.element.remove();
      } else if (this.element.childElementCount < 1) {
        this.element.remove();
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/enter-section.js
  var enter_section_default = class extends Controller {
    static targets = ["order", "children"];
    static values = {
      threshold: { type: Number, default: 0.35 },
      delay: { type: Number, default: 0.2 }
    };
    connect() {
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((el) => {
            if (el.isIntersecting) {
              if (this.hasChildrenTarget) {
                Array.from(this.childrenTarget.children).forEach((child, index4) => {
                  child.style.transitionDelay = `${index4 * this.delayValue}s`;
                  this.zz(child);
                  child.addEventListener("transitionend", this.endXx, { once: true });
                  child.addEventListener("transitioncancel", this.cancelXx, { once: true });
                });
              } else {
                this.zz(el.target);
              }
            } else if (!el.isIntersecting && el.boundingClientRect.top > 0) {
              if (this.hasChildrenTarget) {
                Array.from(this.childrenTarget.children).forEach((child, index4) => {
                  child.style.transitionDelay = `${index4 * this.delayValue}s`;
                  this.zzz(child);
                  child.addEventListener("transitionend", this.endXx, { once: true });
                  child.addEventListener("transitioncancel", this.cancelXx, { once: true });
                });
              } else {
                this.zzz(el.target);
              }
            }
          });
        },
        {
          threshold: this.thresholdValue
        }
      );
      this.observer.observe(this.element);
    }
    zz(ele) {
      ele.classList.add("has-fade-animate");
      ele.classList.replace("has-fade-start", "has-fade-end");
    }
    zzz(ele) {
      ele.classList.add("has-fade-animate");
      ele.classList.replace("has-fade-end", "has-fade-start");
    }
    endXx(event) {
      const controller = event.target.closest("[data-controller~=enter-section]").getController("enter-section");
      controller.xx(event.target);
      event.target.removeEventListener("transitioncancel", controller.cancelXx);
    }
    cancelXx(event) {
      const controller = event.target.closest("[data-controller~=enter-section]").getController("enter-section");
      controller.xx(event.target);
      event.target.removeEventListener("transitionend", controller.endXx);
    }
    xx(target) {
      target.classList.remove("has-fade-animate");
      target.style.removeProperty("transition-delay");
    }
    disconnect() {
      this.observer.disconnect();
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/fixed-width.js
  var fixed_width_default = class extends Controller {
    connect() {
      this.element.style.width = `${this.element.getBoundingClientRect().width}px`;
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/hover.js
  var hover_default = class extends Controller {
    static targets = ["card"];
    static values = {
      url: String
    };
    show(event) {
      let ele = event.currentTarget;
      if (this.hasCardTarget) {
        this.cardTarget.classList.remove("display-none");
      } else if (this.urlValue) {
        fetch(this.urlValue, {
          method: "GET",
          dataType: "text/html",
          success: function(html) {
            ele.insertAdjacentHTML("beforebegin", html.body.innerHTML);
          },
          error: function(data2) {
            console.debug("error", data2);
          }
        });
      }
    }
    hide() {
      if (this.hasCardTarget) {
        this.cardTarget.classList.add("display-none");
      }
    }
    disconnect() {
      if (this.hasCardTarget) {
        this.cardTarget.remove();
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/gif.js
  var gif_default = class extends Controller {
    static values = {
      duration: Number
    };
    connect() {
      if (this.hasDurationValue) {
        setTimeout(() => {
          this.innerShowNext(this.element, this.identifier);
        }, this.durationValue);
      }
    }
    showNext(event) {
      const ele = event.currentTarget;
      this.innerShowNext(ele, this.identifier);
    }
    innerShowNext(ele, identifier) {
      if (ele.dataset.hidden) {
        const hiddenEles = document.querySelectorAll(ele.dataset.hidden);
        hiddenEles.forEach((el) => {
          el.style.display = "none";
        });
      }
      let nextEles = [ele.nextElementSibling];
      if (ele.dataset.next) {
        nextEles = document.querySelectorAll(ele.dataset.next);
      }
      let nextCon = identifier;
      if (ele.dataset.nextController) {
        nextCon = ele.dataset.nextController;
      }
      nextEles.forEach((el) => {
        el.style.removeProperty("display");
        el.dataset.add("controller", nextCon);
      });
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/notice.js
  var notice_default = class extends Controller {
    static targets = ["progress"];
    static values = {
      duration: { type: Number, default: 5 }
    };
    connect() {
      this.element.style.animationDuration = `${this.durationValue}s`;
      if (this.hasProgressTarget) {
        let count4 = 100;
        const rate = this.durationValue * 1e3 / count4;
        this.timer = setInterval(() => {
          count4--;
          this.progressTarget.value = count4;
          if (count4 <= 0) {
            clearInterval(this.timer);
          }
        }, rate);
      }
    }
    close() {
      this.element.remove();
    }
    disconnect() {
      if (this.timer) {
        clearInterval(this.timer);
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/touch.js
  var touch_default = class extends Controller {
    static values = {
      debug: Boolean
    };
    // data-action="touchstart->slide#start:passive"
    initStatus(event) {
      const touch = event.targetTouches[0];
      this.startPos = {
        x: touch.pageX,
        y: touch.pageY
      };
      this.startTime = (/* @__PURE__ */ new Date()).getTime();
    }
    // scale && scale !== 表示缩放了
    zoomed(event) {
      const result = event.changedTouches.length > 1 || event.scale && event.scale !== 1;
      if (result) {
        console.error("\u662F\u5426\u7F29\u653E\uFF1A", result);
      }
      return result;
    }
    // 是否达到触发条件
    effective(pad3, x3 = true) {
      const endTime = (/* @__PURE__ */ new Date()).getTime();
      let isMore;
      if (x3) {
        isMore = pad3 > this.element.clientWidth / 2;
      } else {
        isMore = pad3 > this.element.clientHeight / 2;
      }
      console.debug("\u662F\u5426\u8D85\u8FC7\u4E00\u534A\uFF1A", isMore);
      const speed = pad3 / (endTime - this.startTime);
      const isFast = speed > 0.1;
      console.debug("\u624B\u52BF\u901F\u5EA6\uFF1A", isFast);
      return isMore || isFast;
    }
    isHorizontal(pad3, offset3) {
      const isHorizontal3 = pad3 > Math.abs(offset3.y);
      if (this.hasDebugValue && this.debugValue) {
        console.debug("\u662F\u5426\u5DE6\u53F3\u6ED1\u52A8\uFF1A", isHorizontal3);
      }
      return isHorizontal3;
    }
    offset(event) {
      const touch = event.changedTouches[0];
      const offset3 = {
        x: touch.pageX - this.startPos.x,
        y: touch.pageY - this.startPos.y
      };
      if (this.hasDebugValue && this.debugValue) {
        console.debug(event.type, "offset:", offset3);
      }
      return offset3;
    }
    removeStyle(ele, styles) {
      styles.forEach((rule) => {
        ele.style.removeProperty(rule);
      });
    }
    get startPos() {
      let r = this.data.get("startPos").split(",");
      return {
        x: parseFloat(r[0]),
        y: parseFloat(r[1])
      };
    }
    set startPos(pos) {
      this.data.set("startPos", [pos.x, pos.y].join(","));
    }
    get startTime() {
      return this.data.get("startTime");
    }
    set startTime(time) {
      this.data.set("startTime", time);
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/page.js
  var page_default = class extends touch_default {
    static targets = ["paging", "loading", "tip"];
    connect() {
      this.element.addEventListener("touchstart", (event) => {
        this.start(event);
      }, { passive: true });
    }
    start(event) {
      this.initStatus(event);
    }
    move(event) {
      const offset3 = this.offset(event);
      if (offset3.y < 0 && this.arriveBottom() && this.currentPage < this.totalPage) {
        this.loadingTarget.style.display = "flex";
        this.appendPage();
      } else {
        console.log("\u672A\u89E6\u53D1\u7FFB\u9875");
      }
    }
    arriveBottom() {
      const wrap = this.element.parentNode.parentNode;
      const toBottom = wrap.scrollHeight - (wrap.clientHeight + wrap.scrollTop);
      console.debug("to bottom", toBottom);
      if (this.hasTipTarget) {
        return toBottom < this.tipTarget.clientHeight;
      } else {
        return false;
      }
    }
    appendPage() {
      const url = new URL(location.href);
      this.currentPage = this.currentPage + 1;
      url.searchParams.set("page", this.currentPage);
      fetch(url, {
        headers: {
          Accept: "text/vnd.turbo-stream.html"
        }
      }).then((response) => {
        return response.text();
      }).then((body) => {
        Turbo.renderStreamMessage(body);
      });
    }
    get currentPage() {
      return Number(this.pagingTarget.dataset.page) || 1;
    }
    set currentPage(value2) {
      this.pagingTarget.dataset.page = value2;
    }
    get totalPage() {
      return Number(this.pagingTarget.dataset.total) || 1;
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/player.js
  var player_default = class extends audio_player_default {
    static targets = [
      "media",
      "progress",
      "cover",
      "hide"
    ];
    static values = {
      show: String
    };
    connect() {
      if (this.hasMediaTarget && this.mediaTarget.duration && this.hasProgressTarget) {
        this.progressTarget.setAttribute("max", this.mediaTarget.duration);
      } else if (this.hasMediaTarget && this.hasProgressTarget) {
        this.mediaTarget.addEventListener("loadedmetadata", (e3) => {
          this.progressTarget.setAttribute("max", e3.currentTarget.duration);
        });
      }
      if (this.hasProgressTarget) {
        this.mediaTarget.addEventListener("timeupdate", () => {
          if (!this.progressTarget.getAttribute("max")) {
            this.progressTarget.setAttribute("max", this.mediaTarget.duration);
          }
          this.progressTarget.value = this.mediaTarget.currentTime;
        });
      }
    }
    toggle(e3) {
      const ele = e3.currentTarget;
      if (this.mediaTarget.played.length === 0 || this.mediaTarget.paused) {
        this.mediaTarget.play();
        ele.children[0].classList.replace("fa-play", "fa-pause");
        this.coverTarget.style.animationPlayState = "running";
      } else {
        this.mediaTarget.pause();
        ele.children[0].classList.replace("fa-pause", "fa-play");
        this.coverTarget.style.animationPlayState = "paused";
      }
    }
    play() {
      if (this.hasMediaTarget && (this.mediaTarget.played.length === 0 || this.mediaTarget.paused)) {
        this.mediaTarget.play();
      }
    }
    cutTo() {
      if (this.hasHideTarget) {
        this.hideTarget.style.display = "none";
      }
      if (this.hasShowValue) {
        const show3 = document.getElementById(this.showValue);
        show3.style.removeProperty("display");
        if (["VIDEO", "AUDIO"].includes(show3.tagName)) {
          show3.play();
        } else {
          show3.querySelector("video, audio")?.play();
        }
      }
    }
    disconnect() {
      this.source?.stop();
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/print.js
  var print_default = class extends Controller {
    static values = {
      url: String,
      name: String,
      hidden: Boolean
    };
    doPrint() {
      const present_frame = document.getElementById("pdf_iframe");
      if (present_frame) {
        present_frame.src = this.urlValue;
      } else {
        const iframe = document.createElement("iframe");
        iframe.src = this.urlValue;
        iframe.name = "pdf";
        iframe.id = "pdf_iframe";
        iframe.hidden = true;
        iframe.onload = () => {
          const pdfFrame = window.frames["pdf"];
          pdfFrame.focus();
          pdfFrame.print();
        };
        document.body.appendChild(iframe);
      }
    }
    batchPrint() {
      this.batchUrl();
      this.doPrint();
    }
    batchUrl() {
      const ids = [];
      this.checkboxes.forEach((item) => {
        if (item.checked && !item.disabled) {
          ids.push(item.value);
        }
      });
      if (ids.length > 0) {
        const url = new URL(this.urlValue);
        url.searchParams.set("ids", ids.join(","));
        this.urlValue = url;
      } else {
        alert("no need commit");
      }
    }
    // checkbox data-action="check#toggleAll"
    toggleAll(event) {
      const element = event.currentTarget;
      for (let checkbox of this.checkboxes) {
        if (!checkbox.disabled) {
          checkbox.checked = element.checked;
        }
      }
    }
    get checkboxes() {
      return document.querySelectorAll(`input[type=checkbox][name='${this.nameValue}']`);
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/qy-login.js
  var qy_login_default = class extends Controller {
    static values = {
      options: Object
    };
    connect() {
      const r = {
        lang: "zh",
        id: "wx_reg",
        ...this.optionsValue
      };
      console.debug("options is", r);
      this.wwLogin = new WwLogin(r);
    }
    disconnect() {
      this.wwLogin.destroyed();
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/scroll.js
  var scroll_default = class extends Controller {
    preserve(event) {
      let scrollTop;
      let oldContainer = event.target.parentElement;
      while (oldContainer) {
        if (oldContainer.scrollTop > 0) {
          scrollTop = oldContainer.scrollTop;
          break;
        }
        oldContainer = oldContainer.parentElement;
      }
      window.addEventListener("turbo:render", (ev) => {
        const newContainer = document.getElementById(oldContainer.id) || document.scrollingElement;
        console.debug("old container scroll top", oldContainer, scrollTop);
        newContainer.scrollTo(0, scrollTop);
      }, { once: true });
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/scroll-next.js
  var scroll_next_default = class extends Controller {
    static values = {
      content: String
    };
    next() {
      if (this.element.nextElementSibling) {
        this.element.nextElementSibling.scrollIntoView();
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/show.js
  var show_default = class extends Controller {
    static targets = ["src", "item", "check", "hidden"];
    show() {
      this.itemTargets.forEach((el) => {
        el.classList.remove("visibility-hidden");
      });
    }
    hide() {
      this.itemTargets.forEach((el) => {
        el.classList.add("visibility-hidden");
      });
    }
    toggle(event) {
      const ele = event.currentTarget;
      if (ele.checked) {
        this.checkTargets.forEach((el) => {
          el.classList.remove("display-none");
        });
        this.hiddenTargets.forEach((el) => {
          el.classList.add("display-none");
        });
        document.querySelectorAll(`[name^="${ele.name.replace(/\[\w+]$/, "")}"]:not([name="${ele.name}"], [name="${ele.name.replace(/\[\w+]$/, "[id]")}"])`).forEach((ele2) => {
          ele2.disabled = false;
        });
      } else {
        this.checkTargets.forEach((el) => {
          el.classList.add("display-none");
        });
        this.hiddenTargets.forEach((el) => {
          el.classList.remove("display-none");
        });
        document.querySelectorAll(`[name^="${ele.name.replace(/\[\w+]$/, "")}"]:not([name="${ele.name}"], [name="${ele.name.replace(/\[\w+]$/, "[id]")}"])`).forEach((ele2) => {
          ele2.disabled = true;
        });
      }
    }
    queryShow(event) {
      const ele = event.currentTarget;
      if (ele.dataset.hidden) {
        const hiddenEles = document.querySelectorAll(ele.dataset.hidden);
        hiddenEles.forEach((el) => {
          el.style.display = "none";
        });
      }
      if (ele.dataset.next) {
        const nextEles = document.querySelectorAll(ele.dataset.next);
        nextEles.forEach((el) => {
          el.style.removeProperty("display");
        });
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/showcase.js
  var showcase_default = class extends Controller {
    static targets = [
      "window"
    ];
    static classes = [
      "hover"
    ];
    // data-action="mouseover->showcase#show"
    show(event) {
      const ele = event.currentTarget;
      ele.classList.add(this.hoverClass);
      for (const el of ele.parentElement.children) {
        if (el !== ele) {
          el.classList.remove(this.hoverClass);
        }
      }
      const target = this.windowTarget.querySelector(`[data-index="${ele.dataset.index}"`);
      target.style.zIndex = 1;
      for (const el of this.windowTarget.children) {
        if (el.dataset.index !== ele.dataset.index) {
          el.style.zIndex = 0;
        }
      }
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/errors.js
  var LuxonError = class extends Error {
  };
  var InvalidDateTimeError = class extends LuxonError {
    constructor(reason) {
      super(`Invalid DateTime: ${reason.toMessage()}`);
    }
  };
  var InvalidIntervalError = class extends LuxonError {
    constructor(reason) {
      super(`Invalid Interval: ${reason.toMessage()}`);
    }
  };
  var InvalidDurationError = class extends LuxonError {
    constructor(reason) {
      super(`Invalid Duration: ${reason.toMessage()}`);
    }
  };
  var ConflictingSpecificationError = class extends LuxonError {
  };
  var InvalidUnitError = class extends LuxonError {
    constructor(unit) {
      super(`Invalid unit ${unit}`);
    }
  };
  var InvalidArgumentError = class extends LuxonError {
  };
  var ZoneIsAbstractError = class extends LuxonError {
    constructor() {
      super("Zone is an abstract class");
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/impl/formats.js
  var n = "numeric";
  var s = "short";
  var l = "long";
  var DATE_SHORT = {
    year: n,
    month: n,
    day: n
  };
  var DATE_MED = {
    year: n,
    month: s,
    day: n
  };
  var DATE_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s
  };
  var DATE_FULL = {
    year: n,
    month: l,
    day: n
  };
  var DATE_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l
  };
  var TIME_SIMPLE = {
    hour: n,
    minute: n
  };
  var TIME_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n
  };
  var TIME_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
  };
  var TIME_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
  };
  var TIME_24_SIMPLE = {
    hour: n,
    minute: n,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SECONDS = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23"
  };
  var TIME_24_WITH_SHORT_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: s
  };
  var TIME_24_WITH_LONG_OFFSET = {
    hour: n,
    minute: n,
    second: n,
    hourCycle: "h23",
    timeZoneName: l
  };
  var DATETIME_SHORT = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n
  };
  var DATETIME_SHORT_WITH_SECONDS = {
    year: n,
    month: n,
    day: n,
    hour: n,
    minute: n,
    second: n
  };
  var DATETIME_MED = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n
  };
  var DATETIME_MED_WITH_SECONDS = {
    year: n,
    month: s,
    day: n,
    hour: n,
    minute: n,
    second: n
  };
  var DATETIME_MED_WITH_WEEKDAY = {
    year: n,
    month: s,
    day: n,
    weekday: s,
    hour: n,
    minute: n
  };
  var DATETIME_FULL = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    timeZoneName: s
  };
  var DATETIME_FULL_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: s
  };
  var DATETIME_HUGE = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    timeZoneName: l
  };
  var DATETIME_HUGE_WITH_SECONDS = {
    year: n,
    month: l,
    day: n,
    weekday: l,
    hour: n,
    minute: n,
    second: n,
    timeZoneName: l
  };

  // ../../engine/rails_design/node_modules/luxon/src/zone.js
  var Zone = class {
    /**
     * The type of zone
     * @abstract
     * @type {string}
     */
    get type() {
      throw new ZoneIsAbstractError();
    }
    /**
     * The name of this zone.
     * @abstract
     * @type {string}
     */
    get name() {
      throw new ZoneIsAbstractError();
    }
    /**
     * The IANA name of this zone.
     * Defaults to `name` if not overwritten by a subclass.
     * @abstract
     * @type {string}
     */
    get ianaName() {
      return this.name;
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year.
     * @abstract
     * @type {boolean}
     */
    get isUniversal() {
      throw new ZoneIsAbstractError();
    }
    /**
     * Returns the offset's common name (such as EST) at the specified timestamp
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to get the name
     * @param {Object} opts - Options to affect the format
     * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
     * @param {string} opts.locale - What locale to return the offset name in.
     * @return {string}
     */
    offsetName(ts, opts) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Returns the offset's value as a string
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(ts, format3) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     * @abstract
     * @param {number} ts - Epoch milliseconds for which to compute the offset
     * @return {number}
     */
    offset(ts) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Return whether this Zone is equal to another zone
     * @abstract
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(otherZone) {
      throw new ZoneIsAbstractError();
    }
    /**
     * Return whether this Zone is valid.
     * @abstract
     * @type {boolean}
     */
    get isValid() {
      throw new ZoneIsAbstractError();
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/zones/systemZone.js
  var singleton = null;
  var SystemZone = class _SystemZone extends Zone {
    /**
     * Get a singleton instance of the local zone
     * @return {SystemZone}
     */
    static get instance() {
      if (singleton === null) {
        singleton = new _SystemZone();
      }
      return singleton;
    }
    /** @override **/
    get type() {
      return "system";
    }
    /** @override **/
    get name() {
      return new Intl.DateTimeFormat().resolvedOptions().timeZone;
    }
    /** @override **/
    get isUniversal() {
      return false;
    }
    /** @override **/
    offsetName(ts, { format: format3, locale: locale2 }) {
      return parseZoneInfo(ts, format3, locale2);
    }
    /** @override **/
    formatOffset(ts, format3) {
      return formatOffset(this.offset(ts), format3);
    }
    /** @override **/
    offset(ts) {
      return -new Date(ts).getTimezoneOffset();
    }
    /** @override **/
    equals(otherZone) {
      return otherZone.type === "system";
    }
    /** @override **/
    get isValid() {
      return true;
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/zones/IANAZone.js
  var dtfCache = {};
  function makeDTF(zone) {
    if (!dtfCache[zone]) {
      dtfCache[zone] = new Intl.DateTimeFormat("en-US", {
        hour12: false,
        timeZone: zone,
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit",
        era: "short"
      });
    }
    return dtfCache[zone];
  }
  var typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    era: 3,
    hour: 4,
    minute: 5,
    second: 6
  };
  function hackyOffset(dtf, date) {
    const formatted = dtf.format(date).replace(/\u200E/g, ""), parsed = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(formatted), [, fMonth, fDay, fYear, fadOrBc, fHour, fMinute, fSecond] = parsed;
    return [fYear, fMonth, fDay, fadOrBc, fHour, fMinute, fSecond];
  }
  function partsOffset(dtf, date) {
    const formatted = dtf.formatToParts(date);
    const filled = [];
    for (let i = 0; i < formatted.length; i++) {
      const { type, value: value2 } = formatted[i];
      const pos = typeToPos[type];
      if (type === "era") {
        filled[pos] = value2;
      } else if (!isUndefined(pos)) {
        filled[pos] = parseInt(value2, 10);
      }
    }
    return filled;
  }
  var ianaZoneCache = {};
  var IANAZone = class _IANAZone extends Zone {
    /**
     * @param {string} name - Zone name
     * @return {IANAZone}
     */
    static create(name2) {
      if (!ianaZoneCache[name2]) {
        ianaZoneCache[name2] = new _IANAZone(name2);
      }
      return ianaZoneCache[name2];
    }
    /**
     * Reset local caches. Should only be necessary in testing scenarios.
     * @return {void}
     */
    static resetCache() {
      ianaZoneCache = {};
      dtfCache = {};
    }
    /**
     * Returns whether the provided string is a valid specifier. This only checks the string's format, not that the specifier identifies a known zone; see isValidZone for that.
     * @param {string} s - The string to check validity on
     * @example IANAZone.isValidSpecifier("America/New_York") //=> true
     * @example IANAZone.isValidSpecifier("Sport~~blorp") //=> false
     * @deprecated For backward compatibility, this forwards to isValidZone, better use `isValidZone()` directly instead.
     * @return {boolean}
     */
    static isValidSpecifier(s2) {
      return this.isValidZone(s2);
    }
    /**
     * Returns whether the provided string identifies a real zone
     * @param {string} zone - The string to check
     * @example IANAZone.isValidZone("America/New_York") //=> true
     * @example IANAZone.isValidZone("Fantasia/Castle") //=> false
     * @example IANAZone.isValidZone("Sport~~blorp") //=> false
     * @return {boolean}
     */
    static isValidZone(zone) {
      if (!zone) {
        return false;
      }
      try {
        new Intl.DateTimeFormat("en-US", { timeZone: zone }).format();
        return true;
      } catch (e3) {
        return false;
      }
    }
    constructor(name2) {
      super();
      this.zoneName = name2;
      this.valid = _IANAZone.isValidZone(name2);
    }
    /**
     * The type of zone. `iana` for all instances of `IANAZone`.
     * @override
     * @type {string}
     */
    get type() {
      return "iana";
    }
    /**
     * The name of this zone (i.e. the IANA zone name).
     * @override
     * @type {string}
     */
    get name() {
      return this.zoneName;
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year:
     * Always returns false for all IANA zones.
     * @override
     * @type {boolean}
     */
    get isUniversal() {
      return false;
    }
    /**
     * Returns the offset's common name (such as EST) at the specified timestamp
     * @override
     * @param {number} ts - Epoch milliseconds for which to get the name
     * @param {Object} opts - Options to affect the format
     * @param {string} opts.format - What style of offset to return. Accepts 'long' or 'short'.
     * @param {string} opts.locale - What locale to return the offset name in.
     * @return {string}
     */
    offsetName(ts, { format: format3, locale: locale2 }) {
      return parseZoneInfo(ts, format3, locale2, this.name);
    }
    /**
     * Returns the offset's value as a string
     * @override
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(ts, format3) {
      return formatOffset(this.offset(ts), format3);
    }
    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     * @override
     * @param {number} ts - Epoch milliseconds for which to compute the offset
     * @return {number}
     */
    offset(ts) {
      const date = new Date(ts);
      if (isNaN(date)) return NaN;
      const dtf = makeDTF(this.name);
      let [year2, month2, day2, adOrBc, hour2, minute2, second2] = dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date);
      if (adOrBc === "BC") {
        year2 = -Math.abs(year2) + 1;
      }
      const adjustedHour = hour2 === 24 ? 0 : hour2;
      const asUTC = objToLocalTS({
        year: year2,
        month: month2,
        day: day2,
        hour: adjustedHour,
        minute: minute2,
        second: second2,
        millisecond: 0
      });
      let asTS = +date;
      const over = asTS % 1e3;
      asTS -= over >= 0 ? over : 1e3 + over;
      return (asUTC - asTS) / (60 * 1e3);
    }
    /**
     * Return whether this Zone is equal to another zone
     * @override
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(otherZone) {
      return otherZone.type === "iana" && otherZone.name === this.name;
    }
    /**
     * Return whether this Zone is valid.
     * @override
     * @type {boolean}
     */
    get isValid() {
      return this.valid;
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/impl/locale.js
  var intlLFCache = {};
  function getCachedLF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlLFCache[key];
    if (!dtf) {
      dtf = new Intl.ListFormat(locString, opts);
      intlLFCache[key] = dtf;
    }
    return dtf;
  }
  var intlDTCache = {};
  function getCachedDTF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let dtf = intlDTCache[key];
    if (!dtf) {
      dtf = new Intl.DateTimeFormat(locString, opts);
      intlDTCache[key] = dtf;
    }
    return dtf;
  }
  var intlNumCache = {};
  function getCachedINF(locString, opts = {}) {
    const key = JSON.stringify([locString, opts]);
    let inf = intlNumCache[key];
    if (!inf) {
      inf = new Intl.NumberFormat(locString, opts);
      intlNumCache[key] = inf;
    }
    return inf;
  }
  var intlRelCache = {};
  function getCachedRTF(locString, opts = {}) {
    const { base, ...cacheKeyOpts } = opts;
    const key = JSON.stringify([locString, cacheKeyOpts]);
    let inf = intlRelCache[key];
    if (!inf) {
      inf = new Intl.RelativeTimeFormat(locString, opts);
      intlRelCache[key] = inf;
    }
    return inf;
  }
  var sysLocaleCache = null;
  function systemLocale() {
    if (sysLocaleCache) {
      return sysLocaleCache;
    } else {
      sysLocaleCache = new Intl.DateTimeFormat().resolvedOptions().locale;
      return sysLocaleCache;
    }
  }
  var weekInfoCache = {};
  function getCachedWeekInfo(locString) {
    let data2 = weekInfoCache[locString];
    if (!data2) {
      const locale2 = new Intl.Locale(locString);
      data2 = "getWeekInfo" in locale2 ? locale2.getWeekInfo() : locale2.weekInfo;
      weekInfoCache[locString] = data2;
    }
    return data2;
  }
  function parseLocaleString(localeStr) {
    const xIndex = localeStr.indexOf("-x-");
    if (xIndex !== -1) {
      localeStr = localeStr.substring(0, xIndex);
    }
    const uIndex = localeStr.indexOf("-u-");
    if (uIndex === -1) {
      return [localeStr];
    } else {
      let options;
      let selectedStr;
      try {
        options = getCachedDTF(localeStr).resolvedOptions();
        selectedStr = localeStr;
      } catch (e3) {
        const smaller = localeStr.substring(0, uIndex);
        options = getCachedDTF(smaller).resolvedOptions();
        selectedStr = smaller;
      }
      const { numberingSystem, calendar } = options;
      return [selectedStr, numberingSystem, calendar];
    }
  }
  function intlConfigString(localeStr, numberingSystem, outputCalendar) {
    if (outputCalendar || numberingSystem) {
      if (!localeStr.includes("-u-")) {
        localeStr += "-u";
      }
      if (outputCalendar) {
        localeStr += `-ca-${outputCalendar}`;
      }
      if (numberingSystem) {
        localeStr += `-nu-${numberingSystem}`;
      }
      return localeStr;
    } else {
      return localeStr;
    }
  }
  function mapMonths(f) {
    const ms = [];
    for (let i = 1; i <= 12; i++) {
      const dt = DateTime.utc(2009, i, 1);
      ms.push(f(dt));
    }
    return ms;
  }
  function mapWeekdays(f) {
    const ms = [];
    for (let i = 1; i <= 7; i++) {
      const dt = DateTime.utc(2016, 11, 13 + i);
      ms.push(f(dt));
    }
    return ms;
  }
  function listStuff(loc, length5, englishFn, intlFn) {
    const mode = loc.listingMode();
    if (mode === "error") {
      return null;
    } else if (mode === "en") {
      return englishFn(length5);
    } else {
      return intlFn(length5);
    }
  }
  function supportsFastNumbers(loc) {
    if (loc.numberingSystem && loc.numberingSystem !== "latn") {
      return false;
    } else {
      return loc.numberingSystem === "latn" || !loc.locale || loc.locale.startsWith("en") || new Intl.DateTimeFormat(loc.intl).resolvedOptions().numberingSystem === "latn";
    }
  }
  var PolyNumberFormatter = class {
    constructor(intl, forceSimple, opts) {
      this.padTo = opts.padTo || 0;
      this.floor = opts.floor || false;
      const { padTo, floor: floor4, ...otherOpts } = opts;
      if (!forceSimple || Object.keys(otherOpts).length > 0) {
        const intlOpts = { useGrouping: false, ...opts };
        if (opts.padTo > 0) intlOpts.minimumIntegerDigits = opts.padTo;
        this.inf = getCachedINF(intl, intlOpts);
      }
    }
    format(i) {
      if (this.inf) {
        const fixed = this.floor ? Math.floor(i) : i;
        return this.inf.format(fixed);
      } else {
        const fixed = this.floor ? Math.floor(i) : roundTo(i, 3);
        return padStart(fixed, this.padTo);
      }
    }
  };
  var PolyDateFormatter = class {
    constructor(dt, intl, opts) {
      this.opts = opts;
      this.originalZone = void 0;
      let z = void 0;
      if (this.opts.timeZone) {
        this.dt = dt;
      } else if (dt.zone.type === "fixed") {
        const gmtOffset = -1 * (dt.offset / 60);
        const offsetZ = gmtOffset >= 0 ? `Etc/GMT+${gmtOffset}` : `Etc/GMT${gmtOffset}`;
        if (dt.offset !== 0 && IANAZone.create(offsetZ).valid) {
          z = offsetZ;
          this.dt = dt;
        } else {
          z = "UTC";
          this.dt = dt.offset === 0 ? dt : dt.setZone("UTC").plus({ minutes: dt.offset });
          this.originalZone = dt.zone;
        }
      } else if (dt.zone.type === "system") {
        this.dt = dt;
      } else if (dt.zone.type === "iana") {
        this.dt = dt;
        z = dt.zone.name;
      } else {
        z = "UTC";
        this.dt = dt.setZone("UTC").plus({ minutes: dt.offset });
        this.originalZone = dt.zone;
      }
      const intlOpts = { ...this.opts };
      intlOpts.timeZone = intlOpts.timeZone || z;
      this.dtf = getCachedDTF(intl, intlOpts);
    }
    format() {
      if (this.originalZone) {
        return this.formatToParts().map(({ value: value2 }) => value2).join("");
      }
      return this.dtf.format(this.dt.toJSDate());
    }
    formatToParts() {
      const parts = this.dtf.formatToParts(this.dt.toJSDate());
      if (this.originalZone) {
        return parts.map((part) => {
          if (part.type === "timeZoneName") {
            const offsetName = this.originalZone.offsetName(this.dt.ts, {
              locale: this.dt.locale,
              format: this.opts.timeZoneName
            });
            return {
              ...part,
              value: offsetName
            };
          } else {
            return part;
          }
        });
      }
      return parts;
    }
    resolvedOptions() {
      return this.dtf.resolvedOptions();
    }
  };
  var PolyRelFormatter = class {
    constructor(intl, isEnglish, opts) {
      this.opts = { style: "long", ...opts };
      if (!isEnglish && hasRelative()) {
        this.rtf = getCachedRTF(intl, opts);
      }
    }
    format(count4, unit) {
      if (this.rtf) {
        return this.rtf.format(count4, unit);
      } else {
        return formatRelativeTime(unit, count4, this.opts.numeric, this.opts.style !== "long");
      }
    }
    formatToParts(count4, unit) {
      if (this.rtf) {
        return this.rtf.formatToParts(count4, unit);
      } else {
        return [];
      }
    }
  };
  var fallbackWeekSettings = {
    firstDay: 1,
    minimalDays: 4,
    weekend: [6, 7]
  };
  var Locale = class _Locale {
    static fromOpts(opts) {
      return _Locale.create(
        opts.locale,
        opts.numberingSystem,
        opts.outputCalendar,
        opts.weekSettings,
        opts.defaultToEN
      );
    }
    static create(locale2, numberingSystem, outputCalendar, weekSettings, defaultToEN = false) {
      const specifiedLocale = locale2 || Settings.defaultLocale;
      const localeR = specifiedLocale || (defaultToEN ? "en-US" : systemLocale());
      const numberingSystemR = numberingSystem || Settings.defaultNumberingSystem;
      const outputCalendarR = outputCalendar || Settings.defaultOutputCalendar;
      const weekSettingsR = validateWeekSettings(weekSettings) || Settings.defaultWeekSettings;
      return new _Locale(localeR, numberingSystemR, outputCalendarR, weekSettingsR, specifiedLocale);
    }
    static resetCache() {
      sysLocaleCache = null;
      intlDTCache = {};
      intlNumCache = {};
      intlRelCache = {};
    }
    static fromObject({ locale: locale2, numberingSystem, outputCalendar, weekSettings } = {}) {
      return _Locale.create(locale2, numberingSystem, outputCalendar, weekSettings);
    }
    constructor(locale2, numbering, outputCalendar, weekSettings, specifiedLocale) {
      const [parsedLocale, parsedNumberingSystem, parsedOutputCalendar] = parseLocaleString(locale2);
      this.locale = parsedLocale;
      this.numberingSystem = numbering || parsedNumberingSystem || null;
      this.outputCalendar = outputCalendar || parsedOutputCalendar || null;
      this.weekSettings = weekSettings;
      this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
      this.weekdaysCache = { format: {}, standalone: {} };
      this.monthsCache = { format: {}, standalone: {} };
      this.meridiemCache = null;
      this.eraCache = {};
      this.specifiedLocale = specifiedLocale;
      this.fastNumbersCached = null;
    }
    get fastNumbers() {
      if (this.fastNumbersCached == null) {
        this.fastNumbersCached = supportsFastNumbers(this);
      }
      return this.fastNumbersCached;
    }
    listingMode() {
      const isActuallyEn = this.isEnglish();
      const hasNoWeirdness = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
      return isActuallyEn && hasNoWeirdness ? "en" : "intl";
    }
    clone(alts) {
      if (!alts || Object.getOwnPropertyNames(alts).length === 0) {
        return this;
      } else {
        return _Locale.create(
          alts.locale || this.specifiedLocale,
          alts.numberingSystem || this.numberingSystem,
          alts.outputCalendar || this.outputCalendar,
          validateWeekSettings(alts.weekSettings) || this.weekSettings,
          alts.defaultToEN || false
        );
      }
    }
    redefaultToEN(alts = {}) {
      return this.clone({ ...alts, defaultToEN: true });
    }
    redefaultToSystem(alts = {}) {
      return this.clone({ ...alts, defaultToEN: false });
    }
    months(length5, format3 = false) {
      return listStuff(this, length5, months, () => {
        const intl = format3 ? { month: length5, day: "numeric" } : { month: length5 }, formatStr = format3 ? "format" : "standalone";
        if (!this.monthsCache[formatStr][length5]) {
          this.monthsCache[formatStr][length5] = mapMonths((dt) => this.extract(dt, intl, "month"));
        }
        return this.monthsCache[formatStr][length5];
      });
    }
    weekdays(length5, format3 = false) {
      return listStuff(this, length5, weekdays, () => {
        const intl = format3 ? { weekday: length5, year: "numeric", month: "long", day: "numeric" } : { weekday: length5 }, formatStr = format3 ? "format" : "standalone";
        if (!this.weekdaysCache[formatStr][length5]) {
          this.weekdaysCache[formatStr][length5] = mapWeekdays(
            (dt) => this.extract(dt, intl, "weekday")
          );
        }
        return this.weekdaysCache[formatStr][length5];
      });
    }
    meridiems() {
      return listStuff(
        this,
        void 0,
        () => meridiems,
        () => {
          if (!this.meridiemCache) {
            const intl = { hour: "numeric", hourCycle: "h12" };
            this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map(
              (dt) => this.extract(dt, intl, "dayperiod")
            );
          }
          return this.meridiemCache;
        }
      );
    }
    eras(length5) {
      return listStuff(this, length5, eras, () => {
        const intl = { era: length5 };
        if (!this.eraCache[length5]) {
          this.eraCache[length5] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map(
            (dt) => this.extract(dt, intl, "era")
          );
        }
        return this.eraCache[length5];
      });
    }
    extract(dt, intlOpts, field3) {
      const df = this.dtFormatter(dt, intlOpts), results = df.formatToParts(), matching = results.find((m3) => m3.type.toLowerCase() === field3);
      return matching ? matching.value : null;
    }
    numberFormatter(opts = {}) {
      return new PolyNumberFormatter(this.intl, opts.forceSimple || this.fastNumbers, opts);
    }
    dtFormatter(dt, intlOpts = {}) {
      return new PolyDateFormatter(dt, this.intl, intlOpts);
    }
    relFormatter(opts = {}) {
      return new PolyRelFormatter(this.intl, this.isEnglish(), opts);
    }
    listFormatter(opts = {}) {
      return getCachedLF(this.intl, opts);
    }
    isEnglish() {
      return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
    }
    getWeekSettings() {
      if (this.weekSettings) {
        return this.weekSettings;
      } else if (!hasLocaleWeekInfo()) {
        return fallbackWeekSettings;
      } else {
        return getCachedWeekInfo(this.locale);
      }
    }
    getStartOfWeek() {
      return this.getWeekSettings().firstDay;
    }
    getMinDaysInFirstWeek() {
      return this.getWeekSettings().minimalDays;
    }
    getWeekendDays() {
      return this.getWeekSettings().weekend;
    }
    equals(other) {
      return this.locale === other.locale && this.numberingSystem === other.numberingSystem && this.outputCalendar === other.outputCalendar;
    }
    toString() {
      return `Locale(${this.locale}, ${this.numberingSystem}, ${this.outputCalendar})`;
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/zones/fixedOffsetZone.js
  var singleton2 = null;
  var FixedOffsetZone = class _FixedOffsetZone extends Zone {
    /**
     * Get a singleton instance of UTC
     * @return {FixedOffsetZone}
     */
    static get utcInstance() {
      if (singleton2 === null) {
        singleton2 = new _FixedOffsetZone(0);
      }
      return singleton2;
    }
    /**
     * Get an instance with a specified offset
     * @param {number} offset - The offset in minutes
     * @return {FixedOffsetZone}
     */
    static instance(offset3) {
      return offset3 === 0 ? _FixedOffsetZone.utcInstance : new _FixedOffsetZone(offset3);
    }
    /**
     * Get an instance of FixedOffsetZone from a UTC offset string, like "UTC+6"
     * @param {string} s - The offset string to parse
     * @example FixedOffsetZone.parseSpecifier("UTC+6")
     * @example FixedOffsetZone.parseSpecifier("UTC+06")
     * @example FixedOffsetZone.parseSpecifier("UTC-6:00")
     * @return {FixedOffsetZone}
     */
    static parseSpecifier(s2) {
      if (s2) {
        const r = s2.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
        if (r) {
          return new _FixedOffsetZone(signedOffset(r[1], r[2]));
        }
      }
      return null;
    }
    constructor(offset3) {
      super();
      this.fixed = offset3;
    }
    /**
     * The type of zone. `fixed` for all instances of `FixedOffsetZone`.
     * @override
     * @type {string}
     */
    get type() {
      return "fixed";
    }
    /**
     * The name of this zone.
     * All fixed zones' names always start with "UTC" (plus optional offset)
     * @override
     * @type {string}
     */
    get name() {
      return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
    }
    /**
     * The IANA name of this zone, i.e. `Etc/UTC` or `Etc/GMT+/-nn`
     *
     * @override
     * @type {string}
     */
    get ianaName() {
      if (this.fixed === 0) {
        return "Etc/UTC";
      } else {
        return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
      }
    }
    /**
     * Returns the offset's common name at the specified timestamp.
     *
     * For fixed offset zones this equals to the zone name.
     * @override
     */
    offsetName() {
      return this.name;
    }
    /**
     * Returns the offset's value as a string
     * @override
     * @param {number} ts - Epoch milliseconds for which to get the offset
     * @param {string} format - What style of offset to return.
     *                          Accepts 'narrow', 'short', or 'techie'. Returning '+6', '+06:00', or '+0600' respectively
     * @return {string}
     */
    formatOffset(ts, format3) {
      return formatOffset(this.fixed, format3);
    }
    /**
     * Returns whether the offset is known to be fixed for the whole year:
     * Always returns true for all fixed offset zones.
     * @override
     * @type {boolean}
     */
    get isUniversal() {
      return true;
    }
    /**
     * Return the offset in minutes for this zone at the specified timestamp.
     *
     * For fixed offset zones, this is constant and does not depend on a timestamp.
     * @override
     * @return {number}
     */
    offset() {
      return this.fixed;
    }
    /**
     * Return whether this Zone is equal to another zone (i.e. also fixed and same offset)
     * @override
     * @param {Zone} otherZone - the zone to compare
     * @return {boolean}
     */
    equals(otherZone) {
      return otherZone.type === "fixed" && otherZone.fixed === this.fixed;
    }
    /**
     * Return whether this Zone is valid:
     * All fixed offset zones are valid.
     * @override
     * @type {boolean}
     */
    get isValid() {
      return true;
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/zones/invalidZone.js
  var InvalidZone = class extends Zone {
    constructor(zoneName) {
      super();
      this.zoneName = zoneName;
    }
    /** @override **/
    get type() {
      return "invalid";
    }
    /** @override **/
    get name() {
      return this.zoneName;
    }
    /** @override **/
    get isUniversal() {
      return false;
    }
    /** @override **/
    offsetName() {
      return null;
    }
    /** @override **/
    formatOffset() {
      return "";
    }
    /** @override **/
    offset() {
      return NaN;
    }
    /** @override **/
    equals() {
      return false;
    }
    /** @override **/
    get isValid() {
      return false;
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/impl/zoneUtil.js
  function normalizeZone(input, defaultZone2) {
    let offset3;
    if (isUndefined(input) || input === null) {
      return defaultZone2;
    } else if (input instanceof Zone) {
      return input;
    } else if (isString(input)) {
      const lowered = input.toLowerCase();
      if (lowered === "default") return defaultZone2;
      else if (lowered === "local" || lowered === "system") return SystemZone.instance;
      else if (lowered === "utc" || lowered === "gmt") return FixedOffsetZone.utcInstance;
      else return FixedOffsetZone.parseSpecifier(lowered) || IANAZone.create(input);
    } else if (isNumber(input)) {
      return FixedOffsetZone.instance(input);
    } else if (typeof input === "object" && "offset" in input && typeof input.offset === "function") {
      return input;
    } else {
      return new InvalidZone(input);
    }
  }

  // ../../engine/rails_design/node_modules/luxon/src/impl/digits.js
  var numberingSystems = {
    arab: "[\u0660-\u0669]",
    arabext: "[\u06F0-\u06F9]",
    bali: "[\u1B50-\u1B59]",
    beng: "[\u09E6-\u09EF]",
    deva: "[\u0966-\u096F]",
    fullwide: "[\uFF10-\uFF19]",
    gujr: "[\u0AE6-\u0AEF]",
    hanidec: "[\u3007|\u4E00|\u4E8C|\u4E09|\u56DB|\u4E94|\u516D|\u4E03|\u516B|\u4E5D]",
    khmr: "[\u17E0-\u17E9]",
    knda: "[\u0CE6-\u0CEF]",
    laoo: "[\u0ED0-\u0ED9]",
    limb: "[\u1946-\u194F]",
    mlym: "[\u0D66-\u0D6F]",
    mong: "[\u1810-\u1819]",
    mymr: "[\u1040-\u1049]",
    orya: "[\u0B66-\u0B6F]",
    tamldec: "[\u0BE6-\u0BEF]",
    telu: "[\u0C66-\u0C6F]",
    thai: "[\u0E50-\u0E59]",
    tibt: "[\u0F20-\u0F29]",
    latn: "\\d"
  };
  var numberingSystemsUTF16 = {
    arab: [1632, 1641],
    arabext: [1776, 1785],
    bali: [6992, 7001],
    beng: [2534, 2543],
    deva: [2406, 2415],
    fullwide: [65296, 65303],
    gujr: [2790, 2799],
    khmr: [6112, 6121],
    knda: [3302, 3311],
    laoo: [3792, 3801],
    limb: [6470, 6479],
    mlym: [3430, 3439],
    mong: [6160, 6169],
    mymr: [4160, 4169],
    orya: [2918, 2927],
    tamldec: [3046, 3055],
    telu: [3174, 3183],
    thai: [3664, 3673],
    tibt: [3872, 3881]
  };
  var hanidecChars = numberingSystems.hanidec.replace(/[\[|\]]/g, "").split("");
  function parseDigits(str7) {
    let value2 = parseInt(str7, 10);
    if (isNaN(value2)) {
      value2 = "";
      for (let i = 0; i < str7.length; i++) {
        const code = str7.charCodeAt(i);
        if (str7[i].search(numberingSystems.hanidec) !== -1) {
          value2 += hanidecChars.indexOf(str7[i]);
        } else {
          for (const key in numberingSystemsUTF16) {
            const [min10, max10] = numberingSystemsUTF16[key];
            if (code >= min10 && code <= max10) {
              value2 += code - min10;
            }
          }
        }
      }
      return parseInt(value2, 10);
    } else {
      return value2;
    }
  }
  var digitRegexCache = {};
  function resetDigitRegexCache() {
    digitRegexCache = {};
  }
  function digitRegex({ numberingSystem }, append3 = "") {
    const ns = numberingSystem || "latn";
    if (!digitRegexCache[ns]) {
      digitRegexCache[ns] = {};
    }
    if (!digitRegexCache[ns][append3]) {
      digitRegexCache[ns][append3] = new RegExp(`${numberingSystems[ns]}${append3}`);
    }
    return digitRegexCache[ns][append3];
  }

  // ../../engine/rails_design/node_modules/luxon/src/settings.js
  var now2 = () => Date.now();
  var defaultZone = "system";
  var defaultLocale = null;
  var defaultNumberingSystem = null;
  var defaultOutputCalendar = null;
  var twoDigitCutoffYear = 60;
  var throwOnInvalid;
  var defaultWeekSettings = null;
  var Settings = class {
    /**
     * Get the callback for returning the current timestamp.
     * @type {function}
     */
    static get now() {
      return now2;
    }
    /**
     * Set the callback for returning the current timestamp.
     * The function should return a number, which will be interpreted as an Epoch millisecond count
     * @type {function}
     * @example Settings.now = () => Date.now() + 3000 // pretend it is 3 seconds in the future
     * @example Settings.now = () => 0 // always pretend it's Jan 1, 1970 at midnight in UTC time
     */
    static set now(n2) {
      now2 = n2;
    }
    /**
     * Set the default time zone to create DateTimes in. Does not affect existing instances.
     * Use the value "system" to reset this value to the system's time zone.
     * @type {string}
     */
    static set defaultZone(zone) {
      defaultZone = zone;
    }
    /**
     * Get the default time zone object currently used to create DateTimes. Does not affect existing instances.
     * The default value is the system's time zone (the one set on the machine that runs this code).
     * @type {Zone}
     */
    static get defaultZone() {
      return normalizeZone(defaultZone, SystemZone.instance);
    }
    /**
     * Get the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultLocale() {
      return defaultLocale;
    }
    /**
     * Set the default locale to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultLocale(locale2) {
      defaultLocale = locale2;
    }
    /**
     * Get the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultNumberingSystem() {
      return defaultNumberingSystem;
    }
    /**
     * Set the default numbering system to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultNumberingSystem(numberingSystem) {
      defaultNumberingSystem = numberingSystem;
    }
    /**
     * Get the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static get defaultOutputCalendar() {
      return defaultOutputCalendar;
    }
    /**
     * Set the default output calendar to create DateTimes with. Does not affect existing instances.
     * @type {string}
     */
    static set defaultOutputCalendar(outputCalendar) {
      defaultOutputCalendar = outputCalendar;
    }
    /**
     * @typedef {Object} WeekSettings
     * @property {number} firstDay
     * @property {number} minimalDays
     * @property {number[]} weekend
     */
    /**
     * @return {WeekSettings|null}
     */
    static get defaultWeekSettings() {
      return defaultWeekSettings;
    }
    /**
     * Allows overriding the default locale week settings, i.e. the start of the week, the weekend and
     * how many days are required in the first week of a year.
     * Does not affect existing instances.
     *
     * @param {WeekSettings|null} weekSettings
     */
    static set defaultWeekSettings(weekSettings) {
      defaultWeekSettings = validateWeekSettings(weekSettings);
    }
    /**
     * Get the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
     * @type {number}
     */
    static get twoDigitCutoffYear() {
      return twoDigitCutoffYear;
    }
    /**
     * Set the cutoff year for whether a 2-digit year string is interpreted in the current or previous century. Numbers higher than the cutoff will be considered to mean 19xx and numbers lower or equal to the cutoff will be considered 20xx.
     * @type {number}
     * @example Settings.twoDigitCutoffYear = 0 // all 'yy' are interpreted as 20th century
     * @example Settings.twoDigitCutoffYear = 99 // all 'yy' are interpreted as 21st century
     * @example Settings.twoDigitCutoffYear = 50 // '49' -> 2049; '50' -> 1950
     * @example Settings.twoDigitCutoffYear = 1950 // interpreted as 50
     * @example Settings.twoDigitCutoffYear = 2050 // ALSO interpreted as 50
     */
    static set twoDigitCutoffYear(cutoffYear) {
      twoDigitCutoffYear = cutoffYear % 100;
    }
    /**
     * Get whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    static get throwOnInvalid() {
      return throwOnInvalid;
    }
    /**
     * Set whether Luxon will throw when it encounters invalid DateTimes, Durations, or Intervals
     * @type {boolean}
     */
    static set throwOnInvalid(t) {
      throwOnInvalid = t;
    }
    /**
     * Reset Luxon's global caches. Should only be necessary in testing scenarios.
     * @return {void}
     */
    static resetCaches() {
      Locale.resetCache();
      IANAZone.resetCache();
      DateTime.resetCache();
      resetDigitRegexCache();
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/impl/invalid.js
  var Invalid = class {
    constructor(reason, explanation) {
      this.reason = reason;
      this.explanation = explanation;
    }
    toMessage() {
      if (this.explanation) {
        return `${this.reason}: ${this.explanation}`;
      } else {
        return this.reason;
      }
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/impl/conversions.js
  var nonLeapLadder = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
  var leapLadder = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
  function unitOutOfRange(unit, value2) {
    return new Invalid(
      "unit out of range",
      `you specified ${value2} (of type ${typeof value2}) as a ${unit}, which is invalid`
    );
  }
  function dayOfWeek(year2, month2, day2) {
    const d2 = new Date(Date.UTC(year2, month2 - 1, day2));
    if (year2 < 100 && year2 >= 0) {
      d2.setUTCFullYear(d2.getUTCFullYear() - 1900);
    }
    const js = d2.getUTCDay();
    return js === 0 ? 7 : js;
  }
  function computeOrdinal(year2, month2, day2) {
    return day2 + (isLeapYear(year2) ? leapLadder : nonLeapLadder)[month2 - 1];
  }
  function uncomputeOrdinal(year2, ordinal) {
    const table = isLeapYear(year2) ? leapLadder : nonLeapLadder, month0 = table.findIndex((i) => i < ordinal), day2 = ordinal - table[month0];
    return { month: month0 + 1, day: day2 };
  }
  function isoWeekdayToLocal(isoWeekday, startOfWeek) {
    return (isoWeekday - startOfWeek + 7) % 7 + 1;
  }
  function gregorianToWeek(gregObj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const { year: year2, month: month2, day: day2 } = gregObj, ordinal = computeOrdinal(year2, month2, day2), weekday = isoWeekdayToLocal(dayOfWeek(year2, month2, day2), startOfWeek);
    let weekNumber = Math.floor((ordinal - weekday + 14 - minDaysInFirstWeek) / 7), weekYear;
    if (weekNumber < 1) {
      weekYear = year2 - 1;
      weekNumber = weeksInWeekYear(weekYear, minDaysInFirstWeek, startOfWeek);
    } else if (weekNumber > weeksInWeekYear(year2, minDaysInFirstWeek, startOfWeek)) {
      weekYear = year2 + 1;
      weekNumber = 1;
    } else {
      weekYear = year2;
    }
    return { weekYear, weekNumber, weekday, ...timeObject(gregObj) };
  }
  function weekToGregorian(weekData, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const { weekYear, weekNumber, weekday } = weekData, weekdayOfJan4 = isoWeekdayToLocal(dayOfWeek(weekYear, 1, minDaysInFirstWeek), startOfWeek), yearInDays = daysInYear(weekYear);
    let ordinal = weekNumber * 7 + weekday - weekdayOfJan4 - 7 + minDaysInFirstWeek, year2;
    if (ordinal < 1) {
      year2 = weekYear - 1;
      ordinal += daysInYear(year2);
    } else if (ordinal > yearInDays) {
      year2 = weekYear + 1;
      ordinal -= daysInYear(weekYear);
    } else {
      year2 = weekYear;
    }
    const { month: month2, day: day2 } = uncomputeOrdinal(year2, ordinal);
    return { year: year2, month: month2, day: day2, ...timeObject(weekData) };
  }
  function gregorianToOrdinal(gregData) {
    const { year: year2, month: month2, day: day2 } = gregData;
    const ordinal = computeOrdinal(year2, month2, day2);
    return { year: year2, ordinal, ...timeObject(gregData) };
  }
  function ordinalToGregorian(ordinalData) {
    const { year: year2, ordinal } = ordinalData;
    const { month: month2, day: day2 } = uncomputeOrdinal(year2, ordinal);
    return { year: year2, month: month2, day: day2, ...timeObject(ordinalData) };
  }
  function usesLocalWeekValues(obj, loc) {
    const hasLocaleWeekData = !isUndefined(obj.localWeekday) || !isUndefined(obj.localWeekNumber) || !isUndefined(obj.localWeekYear);
    if (hasLocaleWeekData) {
      const hasIsoWeekData = !isUndefined(obj.weekday) || !isUndefined(obj.weekNumber) || !isUndefined(obj.weekYear);
      if (hasIsoWeekData) {
        throw new ConflictingSpecificationError(
          "Cannot mix locale-based week fields with ISO-based week fields"
        );
      }
      if (!isUndefined(obj.localWeekday)) obj.weekday = obj.localWeekday;
      if (!isUndefined(obj.localWeekNumber)) obj.weekNumber = obj.localWeekNumber;
      if (!isUndefined(obj.localWeekYear)) obj.weekYear = obj.localWeekYear;
      delete obj.localWeekday;
      delete obj.localWeekNumber;
      delete obj.localWeekYear;
      return {
        minDaysInFirstWeek: loc.getMinDaysInFirstWeek(),
        startOfWeek: loc.getStartOfWeek()
      };
    } else {
      return { minDaysInFirstWeek: 4, startOfWeek: 1 };
    }
  }
  function hasInvalidWeekData(obj, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const validYear = isInteger(obj.weekYear), validWeek = integerBetween(
      obj.weekNumber,
      1,
      weeksInWeekYear(obj.weekYear, minDaysInFirstWeek, startOfWeek)
    ), validWeekday = integerBetween(obj.weekday, 1, 7);
    if (!validYear) {
      return unitOutOfRange("weekYear", obj.weekYear);
    } else if (!validWeek) {
      return unitOutOfRange("week", obj.weekNumber);
    } else if (!validWeekday) {
      return unitOutOfRange("weekday", obj.weekday);
    } else return false;
  }
  function hasInvalidOrdinalData(obj) {
    const validYear = isInteger(obj.year), validOrdinal = integerBetween(obj.ordinal, 1, daysInYear(obj.year));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validOrdinal) {
      return unitOutOfRange("ordinal", obj.ordinal);
    } else return false;
  }
  function hasInvalidGregorianData(obj) {
    const validYear = isInteger(obj.year), validMonth = integerBetween(obj.month, 1, 12), validDay = integerBetween(obj.day, 1, daysInMonth(obj.year, obj.month));
    if (!validYear) {
      return unitOutOfRange("year", obj.year);
    } else if (!validMonth) {
      return unitOutOfRange("month", obj.month);
    } else if (!validDay) {
      return unitOutOfRange("day", obj.day);
    } else return false;
  }
  function hasInvalidTimeData(obj) {
    const { hour: hour2, minute: minute2, second: second2, millisecond: millisecond2 } = obj;
    const validHour = integerBetween(hour2, 0, 23) || hour2 === 24 && minute2 === 0 && second2 === 0 && millisecond2 === 0, validMinute = integerBetween(minute2, 0, 59), validSecond = integerBetween(second2, 0, 59), validMillisecond = integerBetween(millisecond2, 0, 999);
    if (!validHour) {
      return unitOutOfRange("hour", hour2);
    } else if (!validMinute) {
      return unitOutOfRange("minute", minute2);
    } else if (!validSecond) {
      return unitOutOfRange("second", second2);
    } else if (!validMillisecond) {
      return unitOutOfRange("millisecond", millisecond2);
    } else return false;
  }

  // ../../engine/rails_design/node_modules/luxon/src/impl/util.js
  function isUndefined(o) {
    return typeof o === "undefined";
  }
  function isNumber(o) {
    return typeof o === "number";
  }
  function isInteger(o) {
    return typeof o === "number" && o % 1 === 0;
  }
  function isString(o) {
    return typeof o === "string";
  }
  function isDate(o) {
    return Object.prototype.toString.call(o) === "[object Date]";
  }
  function hasRelative() {
    try {
      return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
    } catch (e3) {
      return false;
    }
  }
  function hasLocaleWeekInfo() {
    try {
      return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
    } catch (e3) {
      return false;
    }
  }
  function maybeArray(thing) {
    return Array.isArray(thing) ? thing : [thing];
  }
  function bestBy(arr, by, compare) {
    if (arr.length === 0) {
      return void 0;
    }
    return arr.reduce((best, next) => {
      const pair = [by(next), next];
      if (!best) {
        return pair;
      } else if (compare(best[0], pair[0]) === best[0]) {
        return best;
      } else {
        return pair;
      }
    }, null)[1];
  }
  function pick(obj, keys2) {
    return keys2.reduce((a3, k) => {
      a3[k] = obj[k];
      return a3;
    }, {});
  }
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  function validateWeekSettings(settings) {
    if (settings == null) {
      return null;
    } else if (typeof settings !== "object") {
      throw new InvalidArgumentError("Week settings must be an object");
    } else {
      if (!integerBetween(settings.firstDay, 1, 7) || !integerBetween(settings.minimalDays, 1, 7) || !Array.isArray(settings.weekend) || settings.weekend.some((v) => !integerBetween(v, 1, 7))) {
        throw new InvalidArgumentError("Invalid week settings");
      }
      return {
        firstDay: settings.firstDay,
        minimalDays: settings.minimalDays,
        weekend: Array.from(settings.weekend)
      };
    }
  }
  function integerBetween(thing, bottom, top) {
    return isInteger(thing) && thing >= bottom && thing <= top;
  }
  function floorMod(x3, n2) {
    return x3 - n2 * Math.floor(x3 / n2);
  }
  function padStart(input, n2 = 2) {
    const isNeg = input < 0;
    let padded;
    if (isNeg) {
      padded = "-" + ("" + -input).padStart(n2, "0");
    } else {
      padded = ("" + input).padStart(n2, "0");
    }
    return padded;
  }
  function parseInteger(string) {
    if (isUndefined(string) || string === null || string === "") {
      return void 0;
    } else {
      return parseInt(string, 10);
    }
  }
  function parseFloating(string) {
    if (isUndefined(string) || string === null || string === "") {
      return void 0;
    } else {
      return parseFloat(string);
    }
  }
  function parseMillis(fraction) {
    if (isUndefined(fraction) || fraction === null || fraction === "") {
      return void 0;
    } else {
      const f = parseFloat("0." + fraction) * 1e3;
      return Math.floor(f);
    }
  }
  function roundTo(number2, digits, towardZero = false) {
    const factor = 10 ** digits, rounder = towardZero ? Math.trunc : Math.round;
    return rounder(number2 * factor) / factor;
  }
  function isLeapYear(year2) {
    return year2 % 4 === 0 && (year2 % 100 !== 0 || year2 % 400 === 0);
  }
  function daysInYear(year2) {
    return isLeapYear(year2) ? 366 : 365;
  }
  function daysInMonth(year2, month2) {
    const modMonth = floorMod(month2 - 1, 12) + 1, modYear = year2 + (month2 - modMonth) / 12;
    if (modMonth === 2) {
      return isLeapYear(modYear) ? 29 : 28;
    } else {
      return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][modMonth - 1];
    }
  }
  function objToLocalTS(obj) {
    let d2 = Date.UTC(
      obj.year,
      obj.month - 1,
      obj.day,
      obj.hour,
      obj.minute,
      obj.second,
      obj.millisecond
    );
    if (obj.year < 100 && obj.year >= 0) {
      d2 = new Date(d2);
      d2.setUTCFullYear(obj.year, obj.month - 1, obj.day);
    }
    return +d2;
  }
  function firstWeekOffset(year2, minDaysInFirstWeek, startOfWeek) {
    const fwdlw = isoWeekdayToLocal(dayOfWeek(year2, 1, minDaysInFirstWeek), startOfWeek);
    return -fwdlw + minDaysInFirstWeek - 1;
  }
  function weeksInWeekYear(weekYear, minDaysInFirstWeek = 4, startOfWeek = 1) {
    const weekOffset = firstWeekOffset(weekYear, minDaysInFirstWeek, startOfWeek);
    const weekOffsetNext = firstWeekOffset(weekYear + 1, minDaysInFirstWeek, startOfWeek);
    return (daysInYear(weekYear) - weekOffset + weekOffsetNext) / 7;
  }
  function untruncateYear(year2) {
    if (year2 > 99) {
      return year2;
    } else return year2 > Settings.twoDigitCutoffYear ? 1900 + year2 : 2e3 + year2;
  }
  function parseZoneInfo(ts, offsetFormat, locale2, timeZone = null) {
    const date = new Date(ts), intlOpts = {
      hourCycle: "h23",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit"
    };
    if (timeZone) {
      intlOpts.timeZone = timeZone;
    }
    const modified = { timeZoneName: offsetFormat, ...intlOpts };
    const parsed = new Intl.DateTimeFormat(locale2, modified).formatToParts(date).find((m3) => m3.type.toLowerCase() === "timezonename");
    return parsed ? parsed.value : null;
  }
  function signedOffset(offHourStr, offMinuteStr) {
    let offHour = parseInt(offHourStr, 10);
    if (Number.isNaN(offHour)) {
      offHour = 0;
    }
    const offMin = parseInt(offMinuteStr, 10) || 0, offMinSigned = offHour < 0 || Object.is(offHour, -0) ? -offMin : offMin;
    return offHour * 60 + offMinSigned;
  }
  function asNumber(value2) {
    const numericValue = Number(value2);
    if (typeof value2 === "boolean" || value2 === "" || Number.isNaN(numericValue))
      throw new InvalidArgumentError(`Invalid unit value ${value2}`);
    return numericValue;
  }
  function normalizeObject(obj, normalizer) {
    const normalized = {};
    for (const u in obj) {
      if (hasOwnProperty(obj, u)) {
        const v = obj[u];
        if (v === void 0 || v === null) continue;
        normalized[normalizer(u)] = asNumber(v);
      }
    }
    return normalized;
  }
  function formatOffset(offset3, format3) {
    const hours = Math.trunc(Math.abs(offset3 / 60)), minutes = Math.trunc(Math.abs(offset3 % 60)), sign3 = offset3 >= 0 ? "+" : "-";
    switch (format3) {
      case "short":
        return `${sign3}${padStart(hours, 2)}:${padStart(minutes, 2)}`;
      case "narrow":
        return `${sign3}${hours}${minutes > 0 ? `:${minutes}` : ""}`;
      case "techie":
        return `${sign3}${padStart(hours, 2)}${padStart(minutes, 2)}`;
      default:
        throw new RangeError(`Value format ${format3} is out of range for property format`);
    }
  }
  function timeObject(obj) {
    return pick(obj, ["hour", "minute", "second", "millisecond"]);
  }

  // ../../engine/rails_design/node_modules/luxon/src/impl/english.js
  var monthsLong = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  var monthsShort = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  var monthsNarrow = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
  function months(length5) {
    switch (length5) {
      case "narrow":
        return [...monthsNarrow];
      case "short":
        return [...monthsShort];
      case "long":
        return [...monthsLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
      case "2-digit":
        return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
      default:
        return null;
    }
  }
  var weekdaysLong = [
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday",
    "Sunday"
  ];
  var weekdaysShort = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
  var weekdaysNarrow = ["M", "T", "W", "T", "F", "S", "S"];
  function weekdays(length5) {
    switch (length5) {
      case "narrow":
        return [...weekdaysNarrow];
      case "short":
        return [...weekdaysShort];
      case "long":
        return [...weekdaysLong];
      case "numeric":
        return ["1", "2", "3", "4", "5", "6", "7"];
      default:
        return null;
    }
  }
  var meridiems = ["AM", "PM"];
  var erasLong = ["Before Christ", "Anno Domini"];
  var erasShort = ["BC", "AD"];
  var erasNarrow = ["B", "A"];
  function eras(length5) {
    switch (length5) {
      case "narrow":
        return [...erasNarrow];
      case "short":
        return [...erasShort];
      case "long":
        return [...erasLong];
      default:
        return null;
    }
  }
  function meridiemForDateTime(dt) {
    return meridiems[dt.hour < 12 ? 0 : 1];
  }
  function weekdayForDateTime(dt, length5) {
    return weekdays(length5)[dt.weekday - 1];
  }
  function monthForDateTime(dt, length5) {
    return months(length5)[dt.month - 1];
  }
  function eraForDateTime(dt, length5) {
    return eras(length5)[dt.year < 0 ? 0 : 1];
  }
  function formatRelativeTime(unit, count4, numeric = "always", narrow = false) {
    const units = {
      years: ["year", "yr."],
      quarters: ["quarter", "qtr."],
      months: ["month", "mo."],
      weeks: ["week", "wk."],
      days: ["day", "day", "days"],
      hours: ["hour", "hr."],
      minutes: ["minute", "min."],
      seconds: ["second", "sec."]
    };
    const lastable = ["hours", "minutes", "seconds"].indexOf(unit) === -1;
    if (numeric === "auto" && lastable) {
      const isDay = unit === "days";
      switch (count4) {
        case 1:
          return isDay ? "tomorrow" : `next ${units[unit][0]}`;
        case -1:
          return isDay ? "yesterday" : `last ${units[unit][0]}`;
        case 0:
          return isDay ? "today" : `this ${units[unit][0]}`;
        default:
      }
    }
    const isInPast = Object.is(count4, -0) || count4 < 0, fmtValue = Math.abs(count4), singular = fmtValue === 1, lilUnits = units[unit], fmtUnit = narrow ? singular ? lilUnits[1] : lilUnits[2] || lilUnits[1] : singular ? units[unit][0] : unit;
    return isInPast ? `${fmtValue} ${fmtUnit} ago` : `in ${fmtValue} ${fmtUnit}`;
  }

  // ../../engine/rails_design/node_modules/luxon/src/impl/formatter.js
  function stringifyTokens(splits, tokenToString) {
    let s2 = "";
    for (const token2 of splits) {
      if (token2.literal) {
        s2 += token2.val;
      } else {
        s2 += tokenToString(token2.val);
      }
    }
    return s2;
  }
  var macroTokenToFormatOpts = {
    D: DATE_SHORT,
    DD: DATE_MED,
    DDD: DATE_FULL,
    DDDD: DATE_HUGE,
    t: TIME_SIMPLE,
    tt: TIME_WITH_SECONDS,
    ttt: TIME_WITH_SHORT_OFFSET,
    tttt: TIME_WITH_LONG_OFFSET,
    T: TIME_24_SIMPLE,
    TT: TIME_24_WITH_SECONDS,
    TTT: TIME_24_WITH_SHORT_OFFSET,
    TTTT: TIME_24_WITH_LONG_OFFSET,
    f: DATETIME_SHORT,
    ff: DATETIME_MED,
    fff: DATETIME_FULL,
    ffff: DATETIME_HUGE,
    F: DATETIME_SHORT_WITH_SECONDS,
    FF: DATETIME_MED_WITH_SECONDS,
    FFF: DATETIME_FULL_WITH_SECONDS,
    FFFF: DATETIME_HUGE_WITH_SECONDS
  };
  var Formatter = class _Formatter {
    static create(locale2, opts = {}) {
      return new _Formatter(locale2, opts);
    }
    static parseFormat(fmt) {
      let current = null, currentFull = "", bracketed = false;
      const splits = [];
      for (let i = 0; i < fmt.length; i++) {
        const c5 = fmt.charAt(i);
        if (c5 === "'") {
          if (currentFull.length > 0) {
            splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
          }
          current = null;
          currentFull = "";
          bracketed = !bracketed;
        } else if (bracketed) {
          currentFull += c5;
        } else if (c5 === current) {
          currentFull += c5;
        } else {
          if (currentFull.length > 0) {
            splits.push({ literal: /^\s+$/.test(currentFull), val: currentFull });
          }
          currentFull = c5;
          current = c5;
        }
      }
      if (currentFull.length > 0) {
        splits.push({ literal: bracketed || /^\s+$/.test(currentFull), val: currentFull });
      }
      return splits;
    }
    static macroTokenToFormatOpts(token2) {
      return macroTokenToFormatOpts[token2];
    }
    constructor(locale2, formatOpts) {
      this.opts = formatOpts;
      this.loc = locale2;
      this.systemLoc = null;
    }
    formatWithSystemDefault(dt, opts) {
      if (this.systemLoc === null) {
        this.systemLoc = this.loc.redefaultToSystem();
      }
      const df = this.systemLoc.dtFormatter(dt, { ...this.opts, ...opts });
      return df.format();
    }
    dtFormatter(dt, opts = {}) {
      return this.loc.dtFormatter(dt, { ...this.opts, ...opts });
    }
    formatDateTime(dt, opts) {
      return this.dtFormatter(dt, opts).format();
    }
    formatDateTimeParts(dt, opts) {
      return this.dtFormatter(dt, opts).formatToParts();
    }
    formatInterval(interval2, opts) {
      const df = this.dtFormatter(interval2.start, opts);
      return df.dtf.formatRange(interval2.start.toJSDate(), interval2.end.toJSDate());
    }
    resolvedOptions(dt, opts) {
      return this.dtFormatter(dt, opts).resolvedOptions();
    }
    num(n2, p2 = 0) {
      if (this.opts.forceSimple) {
        return padStart(n2, p2);
      }
      const opts = { ...this.opts };
      if (p2 > 0) {
        opts.padTo = p2;
      }
      return this.loc.numberFormatter(opts).format(n2);
    }
    formatDateTimeFromString(dt, fmt) {
      const knownEnglish = this.loc.listingMode() === "en", useDateTimeFormatter = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory", string = (opts, extract) => this.loc.extract(dt, opts, extract), formatOffset2 = (opts) => {
        if (dt.isOffsetFixed && dt.offset === 0 && opts.allowZ) {
          return "Z";
        }
        return dt.isValid ? dt.zone.formatOffset(dt.ts, opts.format) : "";
      }, meridiem = () => knownEnglish ? meridiemForDateTime(dt) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod"), month2 = (length5, standalone) => knownEnglish ? monthForDateTime(dt, length5) : string(standalone ? { month: length5 } : { month: length5, day: "numeric" }, "month"), weekday = (length5, standalone) => knownEnglish ? weekdayForDateTime(dt, length5) : string(
        standalone ? { weekday: length5 } : { weekday: length5, month: "long", day: "numeric" },
        "weekday"
      ), maybeMacro = (token2) => {
        const formatOpts = _Formatter.macroTokenToFormatOpts(token2);
        if (formatOpts) {
          return this.formatWithSystemDefault(dt, formatOpts);
        } else {
          return token2;
        }
      }, era = (length5) => knownEnglish ? eraForDateTime(dt, length5) : string({ era: length5 }, "era"), tokenToString = (token2) => {
        switch (token2) {
          case "S":
            return this.num(dt.millisecond);
          case "u":
          case "SSS":
            return this.num(dt.millisecond, 3);
          case "s":
            return this.num(dt.second);
          case "ss":
            return this.num(dt.second, 2);
          case "uu":
            return this.num(Math.floor(dt.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(dt.millisecond / 100));
          case "m":
            return this.num(dt.minute);
          case "mm":
            return this.num(dt.minute, 2);
          case "h":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12);
          case "hh":
            return this.num(dt.hour % 12 === 0 ? 12 : dt.hour % 12, 2);
          case "H":
            return this.num(dt.hour);
          case "HH":
            return this.num(dt.hour, 2);
          case "Z":
            return formatOffset2({ format: "narrow", allowZ: this.opts.allowZ });
          case "ZZ":
            return formatOffset2({ format: "short", allowZ: this.opts.allowZ });
          case "ZZZ":
            return formatOffset2({ format: "techie", allowZ: this.opts.allowZ });
          case "ZZZZ":
            return dt.zone.offsetName(dt.ts, { format: "short", locale: this.loc.locale });
          case "ZZZZZ":
            return dt.zone.offsetName(dt.ts, { format: "long", locale: this.loc.locale });
          case "z":
            return dt.zoneName;
          case "a":
            return meridiem();
          case "d":
            return useDateTimeFormatter ? string({ day: "numeric" }, "day") : this.num(dt.day);
          case "dd":
            return useDateTimeFormatter ? string({ day: "2-digit" }, "day") : this.num(dt.day, 2);
          case "c":
            return this.num(dt.weekday);
          case "ccc":
            return weekday("short", true);
          case "cccc":
            return weekday("long", true);
          case "ccccc":
            return weekday("narrow", true);
          case "E":
            return this.num(dt.weekday);
          case "EEE":
            return weekday("short", false);
          case "EEEE":
            return weekday("long", false);
          case "EEEEE":
            return weekday("narrow", false);
          case "L":
            return useDateTimeFormatter ? string({ month: "numeric", day: "numeric" }, "month") : this.num(dt.month);
          case "LL":
            return useDateTimeFormatter ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(dt.month, 2);
          case "LLL":
            return month2("short", true);
          case "LLLL":
            return month2("long", true);
          case "LLLLL":
            return month2("narrow", true);
          case "M":
            return useDateTimeFormatter ? string({ month: "numeric" }, "month") : this.num(dt.month);
          case "MM":
            return useDateTimeFormatter ? string({ month: "2-digit" }, "month") : this.num(dt.month, 2);
          case "MMM":
            return month2("short", false);
          case "MMMM":
            return month2("long", false);
          case "MMMMM":
            return month2("narrow", false);
          case "y":
            return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year);
          case "yy":
            return useDateTimeFormatter ? string({ year: "2-digit" }, "year") : this.num(dt.year.toString().slice(-2), 2);
          case "yyyy":
            return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 4);
          case "yyyyyy":
            return useDateTimeFormatter ? string({ year: "numeric" }, "year") : this.num(dt.year, 6);
          case "G":
            return era("short");
          case "GG":
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(dt.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(dt.weekYear, 4);
          case "W":
            return this.num(dt.weekNumber);
          case "WW":
            return this.num(dt.weekNumber, 2);
          case "n":
            return this.num(dt.localWeekNumber);
          case "nn":
            return this.num(dt.localWeekNumber, 2);
          case "ii":
            return this.num(dt.localWeekYear.toString().slice(-2), 2);
          case "iiii":
            return this.num(dt.localWeekYear, 4);
          case "o":
            return this.num(dt.ordinal);
          case "ooo":
            return this.num(dt.ordinal, 3);
          case "q":
            return this.num(dt.quarter);
          case "qq":
            return this.num(dt.quarter, 2);
          case "X":
            return this.num(Math.floor(dt.ts / 1e3));
          case "x":
            return this.num(dt.ts);
          default:
            return maybeMacro(token2);
        }
      };
      return stringifyTokens(_Formatter.parseFormat(fmt), tokenToString);
    }
    formatDurationFromString(dur, fmt) {
      const tokenToField = (token2) => {
        switch (token2[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      }, tokenToString = (lildur) => (token2) => {
        const mapped = tokenToField(token2);
        if (mapped) {
          return this.num(lildur.get(mapped), token2.length);
        } else {
          return token2;
        }
      }, tokens4 = _Formatter.parseFormat(fmt), realTokens = tokens4.reduce(
        (found, { literal: literal2, val }) => literal2 ? found : found.concat(val),
        []
      ), collapsed = dur.shiftTo(...realTokens.map(tokenToField).filter((t) => t));
      return stringifyTokens(tokens4, tokenToString(collapsed));
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/impl/regexParser.js
  var ianaRegex = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
  function combineRegexes(...regexes) {
    const full = regexes.reduce((f, r) => f + r.source, "");
    return RegExp(`^${full}$`);
  }
  function combineExtractors(...extractors) {
    return (m3) => extractors.reduce(
      ([mergedVals, mergedZone, cursor], ex) => {
        const [val, zone, next] = ex(m3, cursor);
        return [{ ...mergedVals, ...val }, zone || mergedZone, next];
      },
      [{}, null, 1]
    ).slice(0, 2);
  }
  function parse(s2, ...patterns) {
    if (s2 == null) {
      return [null, null];
    }
    for (const [regex, extractor] of patterns) {
      const m3 = regex.exec(s2);
      if (m3) {
        return extractor(m3);
      }
    }
    return [null, null];
  }
  function simpleParse(...keys2) {
    return (match2, cursor) => {
      const ret = {};
      let i;
      for (i = 0; i < keys2.length; i++) {
        ret[keys2[i]] = parseInteger(match2[cursor + i]);
      }
      return [ret, null, cursor + i];
    };
  }
  var offsetRegex = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
  var isoExtendedZone = `(?:${offsetRegex.source}?(?:\\[(${ianaRegex.source})\\])?)?`;
  var isoTimeBaseRegex = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
  var isoTimeRegex = RegExp(`${isoTimeBaseRegex.source}${isoExtendedZone}`);
  var isoTimeExtensionRegex = RegExp(`(?:T${isoTimeRegex.source})?`);
  var isoYmdRegex = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
  var isoWeekRegex = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
  var isoOrdinalRegex = /(\d{4})-?(\d{3})/;
  var extractISOWeekData = simpleParse("weekYear", "weekNumber", "weekDay");
  var extractISOOrdinalData = simpleParse("year", "ordinal");
  var sqlYmdRegex = /(\d{4})-(\d\d)-(\d\d)/;
  var sqlTimeRegex = RegExp(
    `${isoTimeBaseRegex.source} ?(?:${offsetRegex.source}|(${ianaRegex.source}))?`
  );
  var sqlTimeExtensionRegex = RegExp(`(?: ${sqlTimeRegex.source})?`);
  function int(match2, pos, fallback) {
    const m3 = match2[pos];
    return isUndefined(m3) ? fallback : parseInteger(m3);
  }
  function extractISOYmd(match2, cursor) {
    const item = {
      year: int(match2, cursor),
      month: int(match2, cursor + 1, 1),
      day: int(match2, cursor + 2, 1)
    };
    return [item, null, cursor + 3];
  }
  function extractISOTime(match2, cursor) {
    const item = {
      hours: int(match2, cursor, 0),
      minutes: int(match2, cursor + 1, 0),
      seconds: int(match2, cursor + 2, 0),
      milliseconds: parseMillis(match2[cursor + 3])
    };
    return [item, null, cursor + 4];
  }
  function extractISOOffset(match2, cursor) {
    const local = !match2[cursor] && !match2[cursor + 1], fullOffset = signedOffset(match2[cursor + 1], match2[cursor + 2]), zone = local ? null : FixedOffsetZone.instance(fullOffset);
    return [{}, zone, cursor + 3];
  }
  function extractIANAZone(match2, cursor) {
    const zone = match2[cursor] ? IANAZone.create(match2[cursor]) : null;
    return [{}, zone, cursor + 1];
  }
  var isoTimeOnly = RegExp(`^T?${isoTimeBaseRegex.source}$`);
  var isoDuration = /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
  function extractISODuration(match2) {
    const [s2, yearStr, monthStr, weekStr, dayStr, hourStr, minuteStr, secondStr, millisecondsStr] = match2;
    const hasNegativePrefix = s2[0] === "-";
    const negativeSeconds = secondStr && secondStr[0] === "-";
    const maybeNegate = (num, force = false) => num !== void 0 && (force || num && hasNegativePrefix) ? -num : num;
    return [
      {
        years: maybeNegate(parseFloating(yearStr)),
        months: maybeNegate(parseFloating(monthStr)),
        weeks: maybeNegate(parseFloating(weekStr)),
        days: maybeNegate(parseFloating(dayStr)),
        hours: maybeNegate(parseFloating(hourStr)),
        minutes: maybeNegate(parseFloating(minuteStr)),
        seconds: maybeNegate(parseFloating(secondStr), secondStr === "-0"),
        milliseconds: maybeNegate(parseMillis(millisecondsStr), negativeSeconds)
      }
    ];
  }
  var obsOffsets = {
    GMT: 0,
    EDT: -4 * 60,
    EST: -5 * 60,
    CDT: -5 * 60,
    CST: -6 * 60,
    MDT: -6 * 60,
    MST: -7 * 60,
    PDT: -7 * 60,
    PST: -8 * 60
  };
  function fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
    const result = {
      year: yearStr.length === 2 ? untruncateYear(parseInteger(yearStr)) : parseInteger(yearStr),
      month: monthsShort.indexOf(monthStr) + 1,
      day: parseInteger(dayStr),
      hour: parseInteger(hourStr),
      minute: parseInteger(minuteStr)
    };
    if (secondStr) result.second = parseInteger(secondStr);
    if (weekdayStr) {
      result.weekday = weekdayStr.length > 3 ? weekdaysLong.indexOf(weekdayStr) + 1 : weekdaysShort.indexOf(weekdayStr) + 1;
    }
    return result;
  }
  var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
  function extractRFC2822(match2) {
    const [
      ,
      weekdayStr,
      dayStr,
      monthStr,
      yearStr,
      hourStr,
      minuteStr,
      secondStr,
      obsOffset,
      milOffset,
      offHourStr,
      offMinuteStr
    ] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    let offset3;
    if (obsOffset) {
      offset3 = obsOffsets[obsOffset];
    } else if (milOffset) {
      offset3 = 0;
    } else {
      offset3 = signedOffset(offHourStr, offMinuteStr);
    }
    return [result, new FixedOffsetZone(offset3)];
  }
  function preprocessRFC2822(s2) {
    return s2.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim();
  }
  var rfc1123 = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/;
  var rfc850 = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/;
  var ascii = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
  function extractRFC1123Or850(match2) {
    const [, weekdayStr, dayStr, monthStr, yearStr, hourStr, minuteStr, secondStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }
  function extractASCII(match2) {
    const [, weekdayStr, monthStr, dayStr, hourStr, minuteStr, secondStr, yearStr] = match2, result = fromStrings(weekdayStr, yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr);
    return [result, FixedOffsetZone.utcInstance];
  }
  var isoYmdWithTimeExtensionRegex = combineRegexes(isoYmdRegex, isoTimeExtensionRegex);
  var isoWeekWithTimeExtensionRegex = combineRegexes(isoWeekRegex, isoTimeExtensionRegex);
  var isoOrdinalWithTimeExtensionRegex = combineRegexes(isoOrdinalRegex, isoTimeExtensionRegex);
  var isoTimeCombinedRegex = combineRegexes(isoTimeRegex);
  var extractISOYmdTimeAndOffset = combineExtractors(
    extractISOYmd,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  var extractISOWeekTimeAndOffset = combineExtractors(
    extractISOWeekData,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  var extractISOOrdinalDateAndTime = combineExtractors(
    extractISOOrdinalData,
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  var extractISOTimeAndOffset = combineExtractors(
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  function parseISODate(s2) {
    return parse(
      s2,
      [isoYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
      [isoWeekWithTimeExtensionRegex, extractISOWeekTimeAndOffset],
      [isoOrdinalWithTimeExtensionRegex, extractISOOrdinalDateAndTime],
      [isoTimeCombinedRegex, extractISOTimeAndOffset]
    );
  }
  function parseRFC2822Date(s2) {
    return parse(preprocessRFC2822(s2), [rfc2822, extractRFC2822]);
  }
  function parseHTTPDate(s2) {
    return parse(
      s2,
      [rfc1123, extractRFC1123Or850],
      [rfc850, extractRFC1123Or850],
      [ascii, extractASCII]
    );
  }
  function parseISODuration(s2) {
    return parse(s2, [isoDuration, extractISODuration]);
  }
  var extractISOTimeOnly = combineExtractors(extractISOTime);
  function parseISOTimeOnly(s2) {
    return parse(s2, [isoTimeOnly, extractISOTimeOnly]);
  }
  var sqlYmdWithTimeExtensionRegex = combineRegexes(sqlYmdRegex, sqlTimeExtensionRegex);
  var sqlTimeCombinedRegex = combineRegexes(sqlTimeRegex);
  var extractISOTimeOffsetAndIANAZone = combineExtractors(
    extractISOTime,
    extractISOOffset,
    extractIANAZone
  );
  function parseSQL(s2) {
    return parse(
      s2,
      [sqlYmdWithTimeExtensionRegex, extractISOYmdTimeAndOffset],
      [sqlTimeCombinedRegex, extractISOTimeOffsetAndIANAZone]
    );
  }

  // ../../engine/rails_design/node_modules/luxon/src/duration.js
  var INVALID = "Invalid Duration";
  var lowOrderMatrix = {
    weeks: {
      days: 7,
      hours: 7 * 24,
      minutes: 7 * 24 * 60,
      seconds: 7 * 24 * 60 * 60,
      milliseconds: 7 * 24 * 60 * 60 * 1e3
    },
    days: {
      hours: 24,
      minutes: 24 * 60,
      seconds: 24 * 60 * 60,
      milliseconds: 24 * 60 * 60 * 1e3
    },
    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
    minutes: { seconds: 60, milliseconds: 60 * 1e3 },
    seconds: { milliseconds: 1e3 }
  };
  var casualMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1e3
    },
    quarters: {
      months: 3,
      weeks: 13,
      days: 91,
      hours: 91 * 24,
      minutes: 91 * 24 * 60,
      seconds: 91 * 24 * 60 * 60,
      milliseconds: 91 * 24 * 60 * 60 * 1e3
    },
    months: {
      weeks: 4,
      days: 30,
      hours: 30 * 24,
      minutes: 30 * 24 * 60,
      seconds: 30 * 24 * 60 * 60,
      milliseconds: 30 * 24 * 60 * 60 * 1e3
    },
    ...lowOrderMatrix
  };
  var daysInYearAccurate = 146097 / 400;
  var daysInMonthAccurate = 146097 / 4800;
  var accurateMatrix = {
    years: {
      quarters: 4,
      months: 12,
      weeks: daysInYearAccurate / 7,
      days: daysInYearAccurate,
      hours: daysInYearAccurate * 24,
      minutes: daysInYearAccurate * 24 * 60,
      seconds: daysInYearAccurate * 24 * 60 * 60,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3
    },
    quarters: {
      months: 3,
      weeks: daysInYearAccurate / 28,
      days: daysInYearAccurate / 4,
      hours: daysInYearAccurate * 24 / 4,
      minutes: daysInYearAccurate * 24 * 60 / 4,
      seconds: daysInYearAccurate * 24 * 60 * 60 / 4,
      milliseconds: daysInYearAccurate * 24 * 60 * 60 * 1e3 / 4
    },
    months: {
      weeks: daysInMonthAccurate / 7,
      days: daysInMonthAccurate,
      hours: daysInMonthAccurate * 24,
      minutes: daysInMonthAccurate * 24 * 60,
      seconds: daysInMonthAccurate * 24 * 60 * 60,
      milliseconds: daysInMonthAccurate * 24 * 60 * 60 * 1e3
    },
    ...lowOrderMatrix
  };
  var orderedUnits = [
    "years",
    "quarters",
    "months",
    "weeks",
    "days",
    "hours",
    "minutes",
    "seconds",
    "milliseconds"
  ];
  var reverseUnits = orderedUnits.slice(0).reverse();
  function clone(dur, alts, clear = false) {
    const conf = {
      values: clear ? alts.values : { ...dur.values, ...alts.values || {} },
      loc: dur.loc.clone(alts.loc),
      conversionAccuracy: alts.conversionAccuracy || dur.conversionAccuracy,
      matrix: alts.matrix || dur.matrix
    };
    return new Duration(conf);
  }
  function durationToMillis(matrix2, vals) {
    let sum3 = vals.milliseconds ?? 0;
    for (const unit of reverseUnits.slice(1)) {
      if (vals[unit]) {
        sum3 += vals[unit] * matrix2[unit]["milliseconds"];
      }
    }
    return sum3;
  }
  function normalizeValues(matrix2, vals) {
    const factor = durationToMillis(matrix2, vals) < 0 ? -1 : 1;
    orderedUnits.reduceRight((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const previousVal = vals[previous] * factor;
          const conv = matrix2[current][previous];
          const rollUp = Math.floor(previousVal / conv);
          vals[current] += rollUp * factor;
          vals[previous] -= rollUp * conv * factor;
        }
        return current;
      } else {
        return previous;
      }
    }, null);
    orderedUnits.reduce((previous, current) => {
      if (!isUndefined(vals[current])) {
        if (previous) {
          const fraction = vals[previous] % 1;
          vals[previous] -= fraction;
          vals[current] += fraction * matrix2[previous][current];
        }
        return current;
      } else {
        return previous;
      }
    }, null);
  }
  function removeZeroes(vals) {
    const newVals = {};
    for (const [key, value2] of Object.entries(vals)) {
      if (value2 !== 0) {
        newVals[key] = value2;
      }
    }
    return newVals;
  }
  var Duration = class _Duration {
    /**
     * @private
     */
    constructor(config2) {
      const accurate = config2.conversionAccuracy === "longterm" || false;
      let matrix2 = accurate ? accurateMatrix : casualMatrix;
      if (config2.matrix) {
        matrix2 = config2.matrix;
      }
      this.values = config2.values;
      this.loc = config2.loc || Locale.create();
      this.conversionAccuracy = accurate ? "longterm" : "casual";
      this.invalid = config2.invalid || null;
      this.matrix = matrix2;
      this.isLuxonDuration = true;
    }
    /**
     * Create Duration from a number of milliseconds.
     * @param {number} count of milliseconds
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @return {Duration}
     */
    static fromMillis(count4, opts) {
      return _Duration.fromObject({ milliseconds: count4 }, opts);
    }
    /**
     * Create a Duration from a JavaScript object with keys like 'years' and 'hours'.
     * If this object is empty then a zero milliseconds duration is returned.
     * @param {Object} obj - the object to create the DateTime from
     * @param {number} obj.years
     * @param {number} obj.quarters
     * @param {number} obj.months
     * @param {number} obj.weeks
     * @param {number} obj.days
     * @param {number} obj.hours
     * @param {number} obj.minutes
     * @param {number} obj.seconds
     * @param {number} obj.milliseconds
     * @param {Object} [opts=[]] - options for creating this Duration
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the custom conversion system to use
     * @return {Duration}
     */
    static fromObject(obj, opts = {}) {
      if (obj == null || typeof obj !== "object") {
        throw new InvalidArgumentError(
          `Duration.fromObject: argument expected to be an object, got ${obj === null ? "null" : typeof obj}`
        );
      }
      return new _Duration({
        values: normalizeObject(obj, _Duration.normalizeUnit),
        loc: Locale.fromObject(opts),
        conversionAccuracy: opts.conversionAccuracy,
        matrix: opts.matrix
      });
    }
    /**
     * Create a Duration from DurationLike.
     *
     * @param {Object | number | Duration} durationLike
     * One of:
     * - object with keys like 'years' and 'hours'.
     * - number representing milliseconds
     * - Duration instance
     * @return {Duration}
     */
    static fromDurationLike(durationLike) {
      if (isNumber(durationLike)) {
        return _Duration.fromMillis(durationLike);
      } else if (_Duration.isDuration(durationLike)) {
        return durationLike;
      } else if (typeof durationLike === "object") {
        return _Duration.fromObject(durationLike);
      } else {
        throw new InvalidArgumentError(
          `Unknown duration argument ${durationLike} of type ${typeof durationLike}`
        );
      }
    }
    /**
     * Create a Duration from an ISO 8601 duration string.
     * @param {string} text - text to parse
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the preset conversion system to use
     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @example Duration.fromISO('P3Y6M1W4DT12H30M5S').toObject() //=> { years: 3, months: 6, weeks: 1, days: 4, hours: 12, minutes: 30, seconds: 5 }
     * @example Duration.fromISO('PT23H').toObject() //=> { hours: 23 }
     * @example Duration.fromISO('P5Y3M').toObject() //=> { years: 5, months: 3 }
     * @return {Duration}
     */
    static fromISO(text, opts) {
      const [parsed] = parseISODuration(text);
      if (parsed) {
        return _Duration.fromObject(parsed, opts);
      } else {
        return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    /**
     * Create a Duration from an ISO 8601 time string.
     * @param {string} text - text to parse
     * @param {Object} opts - options for parsing
     * @param {string} [opts.locale='en-US'] - the locale to use
     * @param {string} opts.numberingSystem - the numbering system to use
     * @param {string} [opts.conversionAccuracy='casual'] - the preset conversion system to use
     * @param {string} [opts.matrix=Object] - the conversion system to use
     * @see https://en.wikipedia.org/wiki/ISO_8601#Times
     * @example Duration.fromISOTime('11:22:33.444').toObject() //=> { hours: 11, minutes: 22, seconds: 33, milliseconds: 444 }
     * @example Duration.fromISOTime('11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('T11:00').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @example Duration.fromISOTime('T1100').toObject() //=> { hours: 11, minutes: 0, seconds: 0 }
     * @return {Duration}
     */
    static fromISOTime(text, opts) {
      const [parsed] = parseISOTimeOnly(text);
      if (parsed) {
        return _Duration.fromObject(parsed, opts);
      } else {
        return _Duration.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
      }
    }
    /**
     * Create an invalid Duration.
     * @param {string} reason - simple string of why this datetime is invalid. Should not contain parameters or anything else data-dependent
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {Duration}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDurationError(invalid);
      } else {
        return new _Duration({ invalid });
      }
    }
    /**
     * @private
     */
    static normalizeUnit(unit) {
      const normalized = {
        year: "years",
        years: "years",
        quarter: "quarters",
        quarters: "quarters",
        month: "months",
        months: "months",
        week: "weeks",
        weeks: "weeks",
        day: "days",
        days: "days",
        hour: "hours",
        hours: "hours",
        minute: "minutes",
        minutes: "minutes",
        second: "seconds",
        seconds: "seconds",
        millisecond: "milliseconds",
        milliseconds: "milliseconds"
      }[unit ? unit.toLowerCase() : unit];
      if (!normalized) throw new InvalidUnitError(unit);
      return normalized;
    }
    /**
     * Check if an object is a Duration. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isDuration(o) {
      return o && o.isLuxonDuration || false;
    }
    /**
     * Get  the locale of a Duration, such 'en-GB'
     * @type {string}
     */
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a Duration, such 'beng'. The numbering system is used when formatting the Duration
     *
     * @type {string}
     */
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    /**
     * Returns a string representation of this Duration formatted according to the specified format string. You may use these tokens:
     * * `S` for milliseconds
     * * `s` for seconds
     * * `m` for minutes
     * * `h` for hours
     * * `d` for days
     * * `w` for weeks
     * * `M` for months
     * * `y` for years
     * Notes:
     * * Add padding by repeating the token, e.g. "yy" pads the years to two digits, "hhhh" pads the hours out to four digits
     * * Tokens can be escaped by wrapping with single quotes.
     * * The duration will be converted to the set of units in the format string using {@link Duration#shiftTo} and the Durations's conversion accuracy setting.
     * @param {string} fmt - the format string
     * @param {Object} opts - options
     * @param {boolean} [opts.floor=true] - floor numerical values
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("y d s") //=> "1 6 2"
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("yy dd sss") //=> "01 06 002"
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toFormat("M S") //=> "12 518402000"
     * @return {string}
     */
    toFormat(fmt, opts = {}) {
      const fmtOpts = {
        ...opts,
        floor: opts.round !== false && opts.floor !== false
      };
      return this.isValid ? Formatter.create(this.loc, fmtOpts).formatDurationFromString(this, fmt) : INVALID;
    }
    /**
     * Returns a string representation of a Duration with all units included.
     * To modify its behavior, use `listStyle` and any Intl.NumberFormat option, though `unitDisplay` is especially relevant.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat/NumberFormat#options
     * @param {Object} opts - Formatting options. Accepts the same keys as the options parameter of the native `Intl.NumberFormat` constructor, as well as `listStyle`.
     * @param {string} [opts.listStyle='narrow'] - How to format the merged list. Corresponds to the `style` property of the options parameter of the native `Intl.ListFormat` constructor.
     * @example
     * ```js
     * var dur = Duration.fromObject({ days: 1, hours: 5, minutes: 6 })
     * dur.toHuman() //=> '1 day, 5 hours, 6 minutes'
     * dur.toHuman({ listStyle: "long" }) //=> '1 day, 5 hours, and 6 minutes'
     * dur.toHuman({ unitDisplay: "short" }) //=> '1 day, 5 hr, 6 min'
     * ```
     */
    toHuman(opts = {}) {
      if (!this.isValid) return INVALID;
      const l2 = orderedUnits.map((unit) => {
        const val = this.values[unit];
        if (isUndefined(val)) {
          return null;
        }
        return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...opts, unit: unit.slice(0, -1) }).format(val);
      }).filter((n2) => n2);
      return this.loc.listFormatter({ type: "conjunction", style: opts.listStyle || "narrow", ...opts }).format(l2);
    }
    /**
     * Returns a JavaScript object with this Duration's values.
     * @example Duration.fromObject({ years: 1, days: 6, seconds: 2 }).toObject() //=> { years: 1, days: 6, seconds: 2 }
     * @return {Object}
     */
    toObject() {
      if (!this.isValid) return {};
      return { ...this.values };
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Duration.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Durations
     * @example Duration.fromObject({ years: 3, seconds: 45 }).toISO() //=> 'P3YT45S'
     * @example Duration.fromObject({ months: 4, seconds: 45 }).toISO() //=> 'P4MT45S'
     * @example Duration.fromObject({ months: 5 }).toISO() //=> 'P5M'
     * @example Duration.fromObject({ minutes: 5 }).toISO() //=> 'PT5M'
     * @example Duration.fromObject({ milliseconds: 6 }).toISO() //=> 'PT0.006S'
     * @return {string}
     */
    toISO() {
      if (!this.isValid) return null;
      let s2 = "P";
      if (this.years !== 0) s2 += this.years + "Y";
      if (this.months !== 0 || this.quarters !== 0) s2 += this.months + this.quarters * 3 + "M";
      if (this.weeks !== 0) s2 += this.weeks + "W";
      if (this.days !== 0) s2 += this.days + "D";
      if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0)
        s2 += "T";
      if (this.hours !== 0) s2 += this.hours + "H";
      if (this.minutes !== 0) s2 += this.minutes + "M";
      if (this.seconds !== 0 || this.milliseconds !== 0)
        s2 += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
      if (s2 === "P") s2 += "T0S";
      return s2;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Duration, formatted as a time of day.
     * Note that this will return null if the duration is invalid, negative, or equal to or greater than 24 hours.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Times
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example Duration.fromObject({ hours: 11 }).toISOTime() //=> '11:00:00.000'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressMilliseconds: true }) //=> '11:00:00'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ suppressSeconds: true }) //=> '11:00'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ includePrefix: true }) //=> 'T11:00:00.000'
     * @example Duration.fromObject({ hours: 11 }).toISOTime({ format: 'basic' }) //=> '110000.000'
     * @return {string}
     */
    toISOTime(opts = {}) {
      if (!this.isValid) return null;
      const millis = this.toMillis();
      if (millis < 0 || millis >= 864e5) return null;
      opts = {
        suppressMilliseconds: false,
        suppressSeconds: false,
        includePrefix: false,
        format: "extended",
        ...opts,
        includeOffset: false
      };
      const dateTime = DateTime.fromMillis(millis, { zone: "UTC" });
      return dateTime.toISOTime(opts);
    }
    /**
     * Returns an ISO 8601 representation of this Duration appropriate for use in JSON.
     * @return {string}
     */
    toJSON() {
      return this.toISO();
    }
    /**
     * Returns an ISO 8601 representation of this Duration appropriate for use in debugging.
     * @return {string}
     */
    toString() {
      return this.toISO();
    }
    /**
     * Returns a string representation of this Duration appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Duration { values: ${JSON.stringify(this.values)} }`;
      } else {
        return `Duration { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    /**
     * Returns an milliseconds value of this Duration.
     * @return {number}
     */
    toMillis() {
      if (!this.isValid) return NaN;
      return durationToMillis(this.matrix, this.values);
    }
    /**
     * Returns an milliseconds value of this Duration. Alias of {@link toMillis}
     * @return {number}
     */
    valueOf() {
      return this.toMillis();
    }
    /**
     * Make this Duration longer by the specified amount. Return a newly-constructed Duration.
     * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @return {Duration}
     */
    plus(duration) {
      if (!this.isValid) return this;
      const dur = _Duration.fromDurationLike(duration), result = {};
      for (const k of orderedUnits) {
        if (hasOwnProperty(dur.values, k) || hasOwnProperty(this.values, k)) {
          result[k] = dur.get(k) + this.get(k);
        }
      }
      return clone(this, { values: result }, true);
    }
    /**
     * Make this Duration shorter by the specified amount. Return a newly-constructed Duration.
     * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @return {Duration}
     */
    minus(duration) {
      if (!this.isValid) return this;
      const dur = _Duration.fromDurationLike(duration);
      return this.plus(dur.negate());
    }
    /**
     * Scale this Duration by the specified amount. Return a newly-constructed Duration.
     * @param {function} fn - The function to apply to each unit. Arity is 1 or 2: the value of the unit and, optionally, the unit name. Must return a number.
     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits(x => x * 2) //=> { hours: 2, minutes: 60 }
     * @example Duration.fromObject({ hours: 1, minutes: 30 }).mapUnits((x, u) => u === "hours" ? x * 2 : x) //=> { hours: 2, minutes: 30 }
     * @return {Duration}
     */
    mapUnits(fn) {
      if (!this.isValid) return this;
      const result = {};
      for (const k of Object.keys(this.values)) {
        result[k] = asNumber(fn(this.values[k], k));
      }
      return clone(this, { values: result }, true);
    }
    /**
     * Get the value of unit.
     * @param {string} unit - a unit such as 'minute' or 'day'
     * @example Duration.fromObject({years: 2, days: 3}).get('years') //=> 2
     * @example Duration.fromObject({years: 2, days: 3}).get('months') //=> 0
     * @example Duration.fromObject({years: 2, days: 3}).get('days') //=> 3
     * @return {number}
     */
    get(unit) {
      return this[_Duration.normalizeUnit(unit)];
    }
    /**
     * "Set" the values of specified units. Return a newly-constructed Duration.
     * @param {Object} values - a mapping of units to numbers
     * @example dur.set({ years: 2017 })
     * @example dur.set({ hours: 8, minutes: 30 })
     * @return {Duration}
     */
    set(values) {
      if (!this.isValid) return this;
      const mixed = { ...this.values, ...normalizeObject(values, _Duration.normalizeUnit) };
      return clone(this, { values: mixed });
    }
    /**
     * "Set" the locale and/or numberingSystem.  Returns a newly-constructed Duration.
     * @example dur.reconfigure({ locale: 'en-GB' })
     * @return {Duration}
     */
    reconfigure({ locale: locale2, numberingSystem, conversionAccuracy, matrix: matrix2 } = {}) {
      const loc = this.loc.clone({ locale: locale2, numberingSystem });
      const opts = { loc, matrix: matrix2, conversionAccuracy };
      return clone(this, opts);
    }
    /**
     * Return the length of the duration in the specified unit.
     * @param {string} unit - a unit such as 'minutes' or 'days'
     * @example Duration.fromObject({years: 1}).as('days') //=> 365
     * @example Duration.fromObject({years: 1}).as('months') //=> 12
     * @example Duration.fromObject({hours: 60}).as('days') //=> 2.5
     * @return {number}
     */
    as(unit) {
      return this.isValid ? this.shiftTo(unit).get(unit) : NaN;
    }
    /**
     * Reduce this Duration to its canonical representation in its current units.
     * Assuming the overall value of the Duration is positive, this means:
     * - excessive values for lower-order units are converted to higher-order units (if possible, see first and second example)
     * - negative lower-order units are converted to higher order units (there must be such a higher order unit, otherwise
     *   the overall value would be negative, see third example)
     * - fractional values for higher-order units are converted to lower-order units (if possible, see fourth example)
     *
     * If the overall value is negative, the result of this method is equivalent to `this.negate().normalize().negate()`.
     * @example Duration.fromObject({ years: 2, days: 5000 }).normalize().toObject() //=> { years: 15, days: 255 }
     * @example Duration.fromObject({ days: 5000 }).normalize().toObject() //=> { days: 5000 }
     * @example Duration.fromObject({ hours: 12, minutes: -45 }).normalize().toObject() //=> { hours: 11, minutes: 15 }
     * @example Duration.fromObject({ years: 2.5, days: 0, hours: 0 }).normalize().toObject() //=> { years: 2, days: 182, hours: 12 }
     * @return {Duration}
     */
    normalize() {
      if (!this.isValid) return this;
      const vals = this.toObject();
      normalizeValues(this.matrix, vals);
      return clone(this, { values: vals }, true);
    }
    /**
     * Rescale units to its largest representation
     * @example Duration.fromObject({ milliseconds: 90000 }).rescale().toObject() //=> { minutes: 1, seconds: 30 }
     * @return {Duration}
     */
    rescale() {
      if (!this.isValid) return this;
      const vals = removeZeroes(this.normalize().shiftToAll().toObject());
      return clone(this, { values: vals }, true);
    }
    /**
     * Convert this Duration into its representation in a different set of units.
     * @example Duration.fromObject({ hours: 1, seconds: 30 }).shiftTo('minutes', 'milliseconds').toObject() //=> { minutes: 60, milliseconds: 30000 }
     * @return {Duration}
     */
    shiftTo(...units) {
      if (!this.isValid) return this;
      if (units.length === 0) {
        return this;
      }
      units = units.map((u) => _Duration.normalizeUnit(u));
      const built = {}, accumulated = {}, vals = this.toObject();
      let lastUnit;
      for (const k of orderedUnits) {
        if (units.indexOf(k) >= 0) {
          lastUnit = k;
          let own = 0;
          for (const ak in accumulated) {
            own += this.matrix[ak][k] * accumulated[ak];
            accumulated[ak] = 0;
          }
          if (isNumber(vals[k])) {
            own += vals[k];
          }
          const i = Math.trunc(own);
          built[k] = i;
          accumulated[k] = (own * 1e3 - i * 1e3) / 1e3;
        } else if (isNumber(vals[k])) {
          accumulated[k] = vals[k];
        }
      }
      for (const key in accumulated) {
        if (accumulated[key] !== 0) {
          built[lastUnit] += key === lastUnit ? accumulated[key] : accumulated[key] / this.matrix[lastUnit][key];
        }
      }
      normalizeValues(this.matrix, built);
      return clone(this, { values: built }, true);
    }
    /**
     * Shift this Duration to all available units.
     * Same as shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds")
     * @return {Duration}
     */
    shiftToAll() {
      if (!this.isValid) return this;
      return this.shiftTo(
        "years",
        "months",
        "weeks",
        "days",
        "hours",
        "minutes",
        "seconds",
        "milliseconds"
      );
    }
    /**
     * Return the negative of this Duration.
     * @example Duration.fromObject({ hours: 1, seconds: 30 }).negate().toObject() //=> { hours: -1, seconds: -30 }
     * @return {Duration}
     */
    negate() {
      if (!this.isValid) return this;
      const negated = {};
      for (const k of Object.keys(this.values)) {
        negated[k] = this.values[k] === 0 ? 0 : -this.values[k];
      }
      return clone(this, { values: negated }, true);
    }
    /**
     * Get the years.
     * @type {number}
     */
    get years() {
      return this.isValid ? this.values.years || 0 : NaN;
    }
    /**
     * Get the quarters.
     * @type {number}
     */
    get quarters() {
      return this.isValid ? this.values.quarters || 0 : NaN;
    }
    /**
     * Get the months.
     * @type {number}
     */
    get months() {
      return this.isValid ? this.values.months || 0 : NaN;
    }
    /**
     * Get the weeks
     * @type {number}
     */
    get weeks() {
      return this.isValid ? this.values.weeks || 0 : NaN;
    }
    /**
     * Get the days.
     * @type {number}
     */
    get days() {
      return this.isValid ? this.values.days || 0 : NaN;
    }
    /**
     * Get the hours.
     * @type {number}
     */
    get hours() {
      return this.isValid ? this.values.hours || 0 : NaN;
    }
    /**
     * Get the minutes.
     * @type {number}
     */
    get minutes() {
      return this.isValid ? this.values.minutes || 0 : NaN;
    }
    /**
     * Get the seconds.
     * @return {number}
     */
    get seconds() {
      return this.isValid ? this.values.seconds || 0 : NaN;
    }
    /**
     * Get the milliseconds.
     * @return {number}
     */
    get milliseconds() {
      return this.isValid ? this.values.milliseconds || 0 : NaN;
    }
    /**
     * Returns whether the Duration is invalid. Invalid durations are returned by diff operations
     * on invalid DateTimes or Intervals.
     * @return {boolean}
     */
    get isValid() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this Duration became invalid, or null if the Duration is valid
     * @return {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Duration became invalid, or null if the Duration is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Equality check
     * Two Durations are equal iff they have the same units and the same values for each unit.
     * @param {Duration} other
     * @return {boolean}
     */
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      if (!this.loc.equals(other.loc)) {
        return false;
      }
      function eq(v1, v2) {
        if (v1 === void 0 || v1 === 0) return v2 === void 0 || v2 === 0;
        return v1 === v2;
      }
      for (const u of orderedUnits) {
        if (!eq(this.values[u], other.values[u])) {
          return false;
        }
      }
      return true;
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/interval.js
  var INVALID2 = "Invalid Interval";
  function validateStartEnd(start2, end) {
    if (!start2 || !start2.isValid) {
      return Interval.invalid("missing or invalid start");
    } else if (!end || !end.isValid) {
      return Interval.invalid("missing or invalid end");
    } else if (end < start2) {
      return Interval.invalid(
        "end before start",
        `The end of an interval must be after its start, but you had start=${start2.toISO()} and end=${end.toISO()}`
      );
    } else {
      return null;
    }
  }
  var Interval = class _Interval {
    /**
     * @private
     */
    constructor(config2) {
      this.s = config2.start;
      this.e = config2.end;
      this.invalid = config2.invalid || null;
      this.isLuxonInterval = true;
    }
    /**
     * Create an invalid Interval.
     * @param {string} reason - simple string of why this Interval is invalid. Should not contain parameters or anything else data-dependent
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {Interval}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidIntervalError(invalid);
      } else {
        return new _Interval({ invalid });
      }
    }
    /**
     * Create an Interval from a start DateTime and an end DateTime. Inclusive of the start but not the end.
     * @param {DateTime|Date|Object} start
     * @param {DateTime|Date|Object} end
     * @return {Interval}
     */
    static fromDateTimes(start2, end) {
      const builtStart = friendlyDateTime(start2), builtEnd = friendlyDateTime(end);
      const validateError = validateStartEnd(builtStart, builtEnd);
      if (validateError == null) {
        return new _Interval({
          start: builtStart,
          end: builtEnd
        });
      } else {
        return validateError;
      }
    }
    /**
     * Create an Interval from a start DateTime and a Duration to extend to.
     * @param {DateTime|Date|Object} start
     * @param {Duration|Object|number} duration - the length of the Interval.
     * @return {Interval}
     */
    static after(start2, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(start2);
      return _Interval.fromDateTimes(dt, dt.plus(dur));
    }
    /**
     * Create an Interval from an end DateTime and a Duration to extend backwards to.
     * @param {DateTime|Date|Object} end
     * @param {Duration|Object|number} duration - the length of the Interval.
     * @return {Interval}
     */
    static before(end, duration) {
      const dur = Duration.fromDurationLike(duration), dt = friendlyDateTime(end);
      return _Interval.fromDateTimes(dt.minus(dur), dt);
    }
    /**
     * Create an Interval from an ISO 8601 string.
     * Accepts `<start>/<end>`, `<start>/<duration>`, and `<duration>/<end>` formats.
     * @param {string} text - the ISO string to parse
     * @param {Object} [opts] - options to pass {@link DateTime#fromISO} and optionally {@link Duration#fromISO}
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @return {Interval}
     */
    static fromISO(text, opts) {
      const [s2, e3] = (text || "").split("/", 2);
      if (s2 && e3) {
        let start2, startIsValid;
        try {
          start2 = DateTime.fromISO(s2, opts);
          startIsValid = start2.isValid;
        } catch (e4) {
          startIsValid = false;
        }
        let end, endIsValid;
        try {
          end = DateTime.fromISO(e3, opts);
          endIsValid = end.isValid;
        } catch (e4) {
          endIsValid = false;
        }
        if (startIsValid && endIsValid) {
          return _Interval.fromDateTimes(start2, end);
        }
        if (startIsValid) {
          const dur = Duration.fromISO(e3, opts);
          if (dur.isValid) {
            return _Interval.after(start2, dur);
          }
        } else if (endIsValid) {
          const dur = Duration.fromISO(s2, opts);
          if (dur.isValid) {
            return _Interval.before(end, dur);
          }
        }
      }
      return _Interval.invalid("unparsable", `the input "${text}" can't be parsed as ISO 8601`);
    }
    /**
     * Check if an object is an Interval. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isInterval(o) {
      return o && o.isLuxonInterval || false;
    }
    /**
     * Returns the start of the Interval
     * @type {DateTime}
     */
    get start() {
      return this.isValid ? this.s : null;
    }
    /**
     * Returns the end of the Interval
     * @type {DateTime}
     */
    get end() {
      return this.isValid ? this.e : null;
    }
    /**
     * Returns whether this Interval's end is at least its start, meaning that the Interval isn't 'backwards'.
     * @type {boolean}
     */
    get isValid() {
      return this.invalidReason === null;
    }
    /**
     * Returns an error code if this Interval is invalid, or null if the Interval is valid
     * @type {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this Interval became invalid, or null if the Interval is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Returns the length of the Interval in the specified unit.
     * @param {string} unit - the unit (such as 'hours' or 'days') to return the length in.
     * @return {number}
     */
    length(unit = "milliseconds") {
      return this.isValid ? this.toDuration(...[unit]).get(unit) : NaN;
    }
    /**
     * Returns the count of minutes, hours, days, months, or years included in the Interval, even in part.
     * Unlike {@link Interval#length} this counts sections of the calendar, not periods of time, e.g. specifying 'day'
     * asks 'what dates are included in this interval?', not 'how many days long is this interval?'
     * @param {string} [unit='milliseconds'] - the unit of time to count.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; this operation will always use the locale of the start DateTime
     * @return {number}
     */
    count(unit = "milliseconds", opts) {
      if (!this.isValid) return NaN;
      const start2 = this.start.startOf(unit, opts);
      let end;
      if (opts?.useLocaleWeeks) {
        end = this.end.reconfigure({ locale: start2.locale });
      } else {
        end = this.end;
      }
      end = end.startOf(unit, opts);
      return Math.floor(end.diff(start2, unit).get(unit)) + (end.valueOf() !== this.end.valueOf());
    }
    /**
     * Returns whether this Interval's start and end are both in the same unit of time
     * @param {string} unit - the unit of time to check sameness on
     * @return {boolean}
     */
    hasSame(unit) {
      return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, unit) : false;
    }
    /**
     * Return whether this Interval has the same start and end DateTimes.
     * @return {boolean}
     */
    isEmpty() {
      return this.s.valueOf() === this.e.valueOf();
    }
    /**
     * Return whether this Interval's start is after the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    isAfter(dateTime) {
      if (!this.isValid) return false;
      return this.s > dateTime;
    }
    /**
     * Return whether this Interval's end is before the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    isBefore(dateTime) {
      if (!this.isValid) return false;
      return this.e <= dateTime;
    }
    /**
     * Return whether this Interval contains the specified DateTime.
     * @param {DateTime} dateTime
     * @return {boolean}
     */
    contains(dateTime) {
      if (!this.isValid) return false;
      return this.s <= dateTime && this.e > dateTime;
    }
    /**
     * "Sets" the start and/or end dates. Returns a newly-constructed Interval.
     * @param {Object} values - the values to set
     * @param {DateTime} values.start - the starting DateTime
     * @param {DateTime} values.end - the ending DateTime
     * @return {Interval}
     */
    set({ start: start2, end } = {}) {
      if (!this.isValid) return this;
      return _Interval.fromDateTimes(start2 || this.s, end || this.e);
    }
    /**
     * Split this Interval at each of the specified DateTimes
     * @param {...DateTime} dateTimes - the unit of time to count.
     * @return {Array}
     */
    splitAt(...dateTimes) {
      if (!this.isValid) return [];
      const sorted = dateTimes.map(friendlyDateTime).filter((d2) => this.contains(d2)).sort((a3, b) => a3.toMillis() - b.toMillis()), results = [];
      let { s: s2 } = this, i = 0;
      while (s2 < this.e) {
        const added = sorted[i] || this.e, next = +added > +this.e ? this.e : added;
        results.push(_Interval.fromDateTimes(s2, next));
        s2 = next;
        i += 1;
      }
      return results;
    }
    /**
     * Split this Interval into smaller Intervals, each of the specified length.
     * Left over time is grouped into a smaller interval
     * @param {Duration|Object|number} duration - The length of each resulting interval.
     * @return {Array}
     */
    splitBy(duration) {
      const dur = Duration.fromDurationLike(duration);
      if (!this.isValid || !dur.isValid || dur.as("milliseconds") === 0) {
        return [];
      }
      let { s: s2 } = this, idx = 1, next;
      const results = [];
      while (s2 < this.e) {
        const added = this.start.plus(dur.mapUnits((x3) => x3 * idx));
        next = +added > +this.e ? this.e : added;
        results.push(_Interval.fromDateTimes(s2, next));
        s2 = next;
        idx += 1;
      }
      return results;
    }
    /**
     * Split this Interval into the specified number of smaller intervals.
     * @param {number} numberOfParts - The number of Intervals to divide the Interval into.
     * @return {Array}
     */
    divideEqually(numberOfParts) {
      if (!this.isValid) return [];
      return this.splitBy(this.length() / numberOfParts).slice(0, numberOfParts);
    }
    /**
     * Return whether this Interval overlaps with the specified Interval
     * @param {Interval} other
     * @return {boolean}
     */
    overlaps(other) {
      return this.e > other.s && this.s < other.e;
    }
    /**
     * Return whether this Interval's end is adjacent to the specified Interval's start.
     * @param {Interval} other
     * @return {boolean}
     */
    abutsStart(other) {
      if (!this.isValid) return false;
      return +this.e === +other.s;
    }
    /**
     * Return whether this Interval's start is adjacent to the specified Interval's end.
     * @param {Interval} other
     * @return {boolean}
     */
    abutsEnd(other) {
      if (!this.isValid) return false;
      return +other.e === +this.s;
    }
    /**
     * Returns true if this Interval fully contains the specified Interval, specifically if the intersect (of this Interval and the other Interval) is equal to the other Interval; false otherwise.
     * @param {Interval} other
     * @return {boolean}
     */
    engulfs(other) {
      if (!this.isValid) return false;
      return this.s <= other.s && this.e >= other.e;
    }
    /**
     * Return whether this Interval has the same start and end as the specified Interval.
     * @param {Interval} other
     * @return {boolean}
     */
    equals(other) {
      if (!this.isValid || !other.isValid) {
        return false;
      }
      return this.s.equals(other.s) && this.e.equals(other.e);
    }
    /**
     * Return an Interval representing the intersection of this Interval and the specified Interval.
     * Specifically, the resulting Interval has the maximum start time and the minimum end time of the two Intervals.
     * Returns null if the intersection is empty, meaning, the intervals don't intersect.
     * @param {Interval} other
     * @return {Interval}
     */
    intersection(other) {
      if (!this.isValid) return this;
      const s2 = this.s > other.s ? this.s : other.s, e3 = this.e < other.e ? this.e : other.e;
      if (s2 >= e3) {
        return null;
      } else {
        return _Interval.fromDateTimes(s2, e3);
      }
    }
    /**
     * Return an Interval representing the union of this Interval and the specified Interval.
     * Specifically, the resulting Interval has the minimum start time and the maximum end time of the two Intervals.
     * @param {Interval} other
     * @return {Interval}
     */
    union(other) {
      if (!this.isValid) return this;
      const s2 = this.s < other.s ? this.s : other.s, e3 = this.e > other.e ? this.e : other.e;
      return _Interval.fromDateTimes(s2, e3);
    }
    /**
     * Merge an array of Intervals into a equivalent minimal set of Intervals.
     * Combines overlapping and adjacent Intervals.
     * @param {Array} intervals
     * @return {Array}
     */
    static merge(intervals) {
      const [found, final] = intervals.sort((a3, b) => a3.s - b.s).reduce(
        ([sofar, current], item) => {
          if (!current) {
            return [sofar, item];
          } else if (current.overlaps(item) || current.abutsStart(item)) {
            return [sofar, current.union(item)];
          } else {
            return [sofar.concat([current]), item];
          }
        },
        [[], null]
      );
      if (final) {
        found.push(final);
      }
      return found;
    }
    /**
     * Return an array of Intervals representing the spans of time that only appear in one of the specified Intervals.
     * @param {Array} intervals
     * @return {Array}
     */
    static xor(intervals) {
      let start2 = null, currentCount = 0;
      const results = [], ends = intervals.map((i) => [
        { time: i.s, type: "s" },
        { time: i.e, type: "e" }
      ]), flattened = Array.prototype.concat(...ends), arr = flattened.sort((a3, b) => a3.time - b.time);
      for (const i of arr) {
        currentCount += i.type === "s" ? 1 : -1;
        if (currentCount === 1) {
          start2 = i.time;
        } else {
          if (start2 && +start2 !== +i.time) {
            results.push(_Interval.fromDateTimes(start2, i.time));
          }
          start2 = null;
        }
      }
      return _Interval.merge(results);
    }
    /**
     * Return an Interval representing the span of time in this Interval that doesn't overlap with any of the specified Intervals.
     * @param {...Interval} intervals
     * @return {Array}
     */
    difference(...intervals) {
      return _Interval.xor([this].concat(intervals)).map((i) => this.intersection(i)).filter((i) => i && !i.isEmpty());
    }
    /**
     * Returns a string representation of this Interval appropriate for debugging.
     * @return {string}
     */
    toString() {
      if (!this.isValid) return INVALID2;
      return `[${this.s.toISO()} \u2013 ${this.e.toISO()})`;
    }
    /**
     * Returns a string representation of this Interval appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
      } else {
        return `Interval { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    /**
     * Returns a localized string representing this Interval. Accepts the same options as the
     * Intl.DateTimeFormat constructor and any presets defined by Luxon, such as
     * {@link DateTime.DATE_FULL} or {@link DateTime.TIME_SIMPLE}. The exact behavior of this method
     * is browser-specific, but in general it will return an appropriate representation of the
     * Interval in the assigned locale. Defaults to the system's locale if no locale has been
     * specified.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {Object} [formatOpts=DateTime.DATE_SHORT] - Either a DateTime preset or
     * Intl.DateTimeFormat constructor options.
     * @param {Object} opts - Options to override the configuration of the start DateTime.
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(); //=> 11/7/2022 – 11/8/2022
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL); //=> November 7 – 8, 2022
     * @example Interval.fromISO('2022-11-07T09:00Z/2022-11-08T09:00Z').toLocaleString(DateTime.DATE_FULL, { locale: 'fr-FR' }); //=> 7–8 novembre 2022
     * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString(DateTime.TIME_SIMPLE); //=> 6:00 – 8:00 PM
     * @example Interval.fromISO('2022-11-07T17:00Z/2022-11-07T19:00Z').toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> Mon, Nov 07, 6:00 – 8:00 p
     * @return {string}
     */
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.s.loc.clone(opts), formatOpts).formatInterval(this) : INVALID2;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this Interval.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @param {Object} opts - The same options as {@link DateTime#toISO}
     * @return {string}
     */
    toISO(opts) {
      if (!this.isValid) return INVALID2;
      return `${this.s.toISO(opts)}/${this.e.toISO(opts)}`;
    }
    /**
     * Returns an ISO 8601-compliant string representation of date of this Interval.
     * The time components are ignored.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @return {string}
     */
    toISODate() {
      if (!this.isValid) return INVALID2;
      return `${this.s.toISODate()}/${this.e.toISODate()}`;
    }
    /**
     * Returns an ISO 8601-compliant string representation of time of this Interval.
     * The date components are ignored.
     * @see https://en.wikipedia.org/wiki/ISO_8601#Time_intervals
     * @param {Object} opts - The same options as {@link DateTime#toISO}
     * @return {string}
     */
    toISOTime(opts) {
      if (!this.isValid) return INVALID2;
      return `${this.s.toISOTime(opts)}/${this.e.toISOTime(opts)}`;
    }
    /**
     * Returns a string representation of this Interval formatted according to the specified format
     * string. **You may not want this.** See {@link Interval#toLocaleString} for a more flexible
     * formatting tool.
     * @param {string} dateFormat - The format string. This string formats the start and end time.
     * See {@link DateTime#toFormat} for details.
     * @param {Object} opts - Options.
     * @param {string} [opts.separator =  ' – '] - A separator to place between the start and end
     * representations.
     * @return {string}
     */
    toFormat(dateFormat, { separator = " \u2013 " } = {}) {
      if (!this.isValid) return INVALID2;
      return `${this.s.toFormat(dateFormat)}${separator}${this.e.toFormat(dateFormat)}`;
    }
    /**
     * Return a Duration representing the time spanned by this interval.
     * @param {string|string[]} [unit=['milliseconds']] - the unit or units (such as 'hours' or 'days') to include in the duration.
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @example Interval.fromDateTimes(dt1, dt2).toDuration().toObject() //=> { milliseconds: 88489257 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration('days').toObject() //=> { days: 1.0241812152777778 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes']).toObject() //=> { hours: 24, minutes: 34.82095 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration(['hours', 'minutes', 'seconds']).toObject() //=> { hours: 24, minutes: 34, seconds: 49.257 }
     * @example Interval.fromDateTimes(dt1, dt2).toDuration('seconds').toObject() //=> { seconds: 88489.257 }
     * @return {Duration}
     */
    toDuration(unit, opts) {
      if (!this.isValid) {
        return Duration.invalid(this.invalidReason);
      }
      return this.e.diff(this.s, unit, opts);
    }
    /**
     * Run mapFn on the interval start and end, returning a new Interval from the resulting DateTimes
     * @param {function} mapFn
     * @return {Interval}
     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.toUTC())
     * @example Interval.fromDateTimes(dt1, dt2).mapEndpoints(endpoint => endpoint.plus({ hours: 2 }))
     */
    mapEndpoints(mapFn) {
      return _Interval.fromDateTimes(mapFn(this.s), mapFn(this.e));
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/info.js
  var Info = class {
    /**
     * Return whether the specified zone contains a DST.
     * @param {string|Zone} [zone='local'] - Zone to check. Defaults to the environment's local zone.
     * @return {boolean}
     */
    static hasDST(zone = Settings.defaultZone) {
      const proto = DateTime.now().setZone(zone).set({ month: 12 });
      return !zone.isUniversal && proto.offset !== proto.set({ month: 6 }).offset;
    }
    /**
     * Return whether the specified zone is a valid IANA specifier.
     * @param {string} zone - Zone to check
     * @return {boolean}
     */
    static isValidIANAZone(zone) {
      return IANAZone.isValidZone(zone);
    }
    /**
     * Converts the input into a {@link Zone} instance.
     *
     * * If `input` is already a Zone instance, it is returned unchanged.
     * * If `input` is a string containing a valid time zone name, a Zone instance
     *   with that name is returned.
     * * If `input` is a string that doesn't refer to a known time zone, a Zone
     *   instance with {@link Zone#isValid} == false is returned.
     * * If `input is a number, a Zone instance with the specified fixed offset
     *   in minutes is returned.
     * * If `input` is `null` or `undefined`, the default zone is returned.
     * @param {string|Zone|number} [input] - the value to be converted
     * @return {Zone}
     */
    static normalizeZone(input) {
      return normalizeZone(input, Settings.defaultZone);
    }
    /**
     * Get the weekday on which the week starts according to the given locale.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number} the start of the week, 1 for Monday through 7 for Sunday
     */
    static getStartOfWeek({ locale: locale2 = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale2)).getStartOfWeek();
    }
    /**
     * Get the minimum number of days necessary in a week before it is considered part of the next year according
     * to the given locale.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number}
     */
    static getMinimumDaysInFirstWeek({ locale: locale2 = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale2)).getMinDaysInFirstWeek();
    }
    /**
     * Get the weekdays, which are considered the weekend according to the given locale
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @returns {number[]} an array of weekdays, 1 for Monday through 7 for Sunday
     */
    static getWeekendWeekdays({ locale: locale2 = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale2)).getWeekendDays().slice();
    }
    /**
     * Return an array of standalone month names.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @param {string} [opts.outputCalendar='gregory'] - the calendar
     * @example Info.months()[0] //=> 'January'
     * @example Info.months('short')[0] //=> 'Jan'
     * @example Info.months('numeric')[0] //=> '1'
     * @example Info.months('short', { locale: 'fr-CA' } )[0] //=> 'janv.'
     * @example Info.months('numeric', { locale: 'ar' })[0] //=> '١'
     * @example Info.months('long', { outputCalendar: 'islamic' })[0] //=> 'Rabiʻ I'
     * @return {Array}
     */
    static months(length5 = "long", { locale: locale2 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
      return (locObj || Locale.create(locale2, numberingSystem, outputCalendar)).months(length5);
    }
    /**
     * Return an array of format month names.
     * Format months differ from standalone months in that they're meant to appear next to the day of the month. In some languages, that
     * changes the string.
     * See {@link Info#months}
     * @param {string} [length='long'] - the length of the month representation, such as "numeric", "2-digit", "narrow", "short", "long"
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @param {string} [opts.outputCalendar='gregory'] - the calendar
     * @return {Array}
     */
    static monthsFormat(length5 = "long", { locale: locale2 = null, numberingSystem = null, locObj = null, outputCalendar = "gregory" } = {}) {
      return (locObj || Locale.create(locale2, numberingSystem, outputCalendar)).months(length5, true);
    }
    /**
     * Return an array of standalone week names.
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param {string} [length='long'] - the length of the weekday representation, such as "narrow", "short", "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @example Info.weekdays()[0] //=> 'Monday'
     * @example Info.weekdays('short')[0] //=> 'Mon'
     * @example Info.weekdays('short', { locale: 'fr-CA' })[0] //=> 'lun.'
     * @example Info.weekdays('short', { locale: 'ar' })[0] //=> 'الاثنين'
     * @return {Array}
     */
    static weekdays(length5 = "long", { locale: locale2 = null, numberingSystem = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale2, numberingSystem, null)).weekdays(length5);
    }
    /**
     * Return an array of format week names.
     * Format weekdays differ from standalone weekdays in that they're meant to appear next to more date information. In some languages, that
     * changes the string.
     * See {@link Info#weekdays}
     * @param {string} [length='long'] - the length of the month representation, such as "narrow", "short", "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale=null] - the locale code
     * @param {string} [opts.numberingSystem=null] - the numbering system
     * @param {string} [opts.locObj=null] - an existing locale object to use
     * @return {Array}
     */
    static weekdaysFormat(length5 = "long", { locale: locale2 = null, numberingSystem = null, locObj = null } = {}) {
      return (locObj || Locale.create(locale2, numberingSystem, null)).weekdays(length5, true);
    }
    /**
     * Return an array of meridiems.
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @example Info.meridiems() //=> [ 'AM', 'PM' ]
     * @example Info.meridiems({ locale: 'my' }) //=> [ 'နံနက်', 'ညနေ' ]
     * @return {Array}
     */
    static meridiems({ locale: locale2 = null } = {}) {
      return Locale.create(locale2).meridiems();
    }
    /**
     * Return an array of eras, such as ['BC', 'AD']. The locale can be specified, but the calendar system is always Gregorian.
     * @param {string} [length='short'] - the length of the era representation, such as "short" or "long".
     * @param {Object} opts - options
     * @param {string} [opts.locale] - the locale code
     * @example Info.eras() //=> [ 'BC', 'AD' ]
     * @example Info.eras('long') //=> [ 'Before Christ', 'Anno Domini' ]
     * @example Info.eras('long', { locale: 'fr' }) //=> [ 'avant Jésus-Christ', 'après Jésus-Christ' ]
     * @return {Array}
     */
    static eras(length5 = "short", { locale: locale2 = null } = {}) {
      return Locale.create(locale2, null, "gregory").eras(length5);
    }
    /**
     * Return the set of available features in this environment.
     * Some features of Luxon are not available in all environments. For example, on older browsers, relative time formatting support is not available. Use this function to figure out if that's the case.
     * Keys:
     * * `relative`: whether this environment supports relative time formatting
     * * `localeWeek`: whether this environment supports different weekdays for the start of the week based on the locale
     * @example Info.features() //=> { relative: false, localeWeek: true }
     * @return {Object}
     */
    static features() {
      return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
    }
  };

  // ../../engine/rails_design/node_modules/luxon/src/impl/diff.js
  function dayDiff(earlier, later) {
    const utcDayStart = (dt) => dt.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(), ms = utcDayStart(later) - utcDayStart(earlier);
    return Math.floor(Duration.fromMillis(ms).as("days"));
  }
  function highOrderDiffs(cursor, later, units) {
    const differs = [
      ["years", (a3, b) => b.year - a3.year],
      ["quarters", (a3, b) => b.quarter - a3.quarter + (b.year - a3.year) * 4],
      ["months", (a3, b) => b.month - a3.month + (b.year - a3.year) * 12],
      [
        "weeks",
        (a3, b) => {
          const days = dayDiff(a3, b);
          return (days - days % 7) / 7;
        }
      ],
      ["days", dayDiff]
    ];
    const results = {};
    const earlier = cursor;
    let lowestOrder, highWater;
    for (const [unit, differ] of differs) {
      if (units.indexOf(unit) >= 0) {
        lowestOrder = unit;
        results[unit] = differ(cursor, later);
        highWater = earlier.plus(results);
        if (highWater > later) {
          results[unit]--;
          cursor = earlier.plus(results);
          if (cursor > later) {
            highWater = cursor;
            results[unit]--;
            cursor = earlier.plus(results);
          }
        } else {
          cursor = highWater;
        }
      }
    }
    return [cursor, results, highWater, lowestOrder];
  }
  function diff_default(earlier, later, units, opts) {
    let [cursor, results, highWater, lowestOrder] = highOrderDiffs(earlier, later, units);
    const remainingMillis = later - cursor;
    const lowerOrderUnits = units.filter(
      (u) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(u) >= 0
    );
    if (lowerOrderUnits.length === 0) {
      if (highWater < later) {
        highWater = cursor.plus({ [lowestOrder]: 1 });
      }
      if (highWater !== cursor) {
        results[lowestOrder] = (results[lowestOrder] || 0) + remainingMillis / (highWater - cursor);
      }
    }
    const duration = Duration.fromObject(results, opts);
    if (lowerOrderUnits.length > 0) {
      return Duration.fromMillis(remainingMillis, opts).shiftTo(...lowerOrderUnits).plus(duration);
    } else {
      return duration;
    }
  }

  // ../../engine/rails_design/node_modules/luxon/src/impl/tokenParser.js
  var MISSING_FTP = "missing Intl.DateTimeFormat.formatToParts support";
  function intUnit(regex, post = (i) => i) {
    return { regex, deser: ([s2]) => post(parseDigits(s2)) };
  }
  var NBSP = String.fromCharCode(160);
  var spaceOrNBSP = `[ ${NBSP}]`;
  var spaceOrNBSPRegExp = new RegExp(spaceOrNBSP, "g");
  function fixListRegex(s2) {
    return s2.replace(/\./g, "\\.?").replace(spaceOrNBSPRegExp, spaceOrNBSP);
  }
  function stripInsensitivities(s2) {
    return s2.replace(/\./g, "").replace(spaceOrNBSPRegExp, " ").toLowerCase();
  }
  function oneOf(strings, startIndex) {
    if (strings === null) {
      return null;
    } else {
      return {
        regex: RegExp(strings.map(fixListRegex).join("|")),
        deser: ([s2]) => strings.findIndex((i) => stripInsensitivities(s2) === stripInsensitivities(i)) + startIndex
      };
    }
  }
  function offset(regex, groups2) {
    return { regex, deser: ([, h, m3]) => signedOffset(h, m3), groups: groups2 };
  }
  function simple(regex) {
    return { regex, deser: ([s2]) => s2 };
  }
  function escapeToken(value2) {
    return value2.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }
  function unitForToken(token2, loc) {
    const one = digitRegex(loc), two = digitRegex(loc, "{2}"), three = digitRegex(loc, "{3}"), four = digitRegex(loc, "{4}"), six = digitRegex(loc, "{6}"), oneOrTwo = digitRegex(loc, "{1,2}"), oneToThree = digitRegex(loc, "{1,3}"), oneToSix = digitRegex(loc, "{1,6}"), oneToNine = digitRegex(loc, "{1,9}"), twoToFour = digitRegex(loc, "{2,4}"), fourToSix = digitRegex(loc, "{4,6}"), literal2 = (t) => ({ regex: RegExp(escapeToken(t.val)), deser: ([s2]) => s2, literal: true }), unitate = (t) => {
      if (token2.literal) {
        return literal2(t);
      }
      switch (t.val) {
        case "G":
          return oneOf(loc.eras("short"), 0);
        case "GG":
          return oneOf(loc.eras("long"), 0);
        case "y":
          return intUnit(oneToSix);
        case "yy":
          return intUnit(twoToFour, untruncateYear);
        case "yyyy":
          return intUnit(four);
        case "yyyyy":
          return intUnit(fourToSix);
        case "yyyyyy":
          return intUnit(six);
        case "M":
          return intUnit(oneOrTwo);
        case "MM":
          return intUnit(two);
        case "MMM":
          return oneOf(loc.months("short", true), 1);
        case "MMMM":
          return oneOf(loc.months("long", true), 1);
        case "L":
          return intUnit(oneOrTwo);
        case "LL":
          return intUnit(two);
        case "LLL":
          return oneOf(loc.months("short", false), 1);
        case "LLLL":
          return oneOf(loc.months("long", false), 1);
        case "d":
          return intUnit(oneOrTwo);
        case "dd":
          return intUnit(two);
        case "o":
          return intUnit(oneToThree);
        case "ooo":
          return intUnit(three);
        case "HH":
          return intUnit(two);
        case "H":
          return intUnit(oneOrTwo);
        case "hh":
          return intUnit(two);
        case "h":
          return intUnit(oneOrTwo);
        case "mm":
          return intUnit(two);
        case "m":
          return intUnit(oneOrTwo);
        case "q":
          return intUnit(oneOrTwo);
        case "qq":
          return intUnit(two);
        case "s":
          return intUnit(oneOrTwo);
        case "ss":
          return intUnit(two);
        case "S":
          return intUnit(oneToThree);
        case "SSS":
          return intUnit(three);
        case "u":
          return simple(oneToNine);
        case "uu":
          return simple(oneOrTwo);
        case "uuu":
          return intUnit(one);
        case "a":
          return oneOf(loc.meridiems(), 0);
        case "kkkk":
          return intUnit(four);
        case "kk":
          return intUnit(twoToFour, untruncateYear);
        case "W":
          return intUnit(oneOrTwo);
        case "WW":
          return intUnit(two);
        case "E":
        case "c":
          return intUnit(one);
        case "EEE":
          return oneOf(loc.weekdays("short", false), 1);
        case "EEEE":
          return oneOf(loc.weekdays("long", false), 1);
        case "ccc":
          return oneOf(loc.weekdays("short", true), 1);
        case "cccc":
          return oneOf(loc.weekdays("long", true), 1);
        case "Z":
        case "ZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(?::(${two.source}))?`), 2);
        case "ZZZ":
          return offset(new RegExp(`([+-]${oneOrTwo.source})(${two.source})?`), 2);
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        case " ":
          return simple(/[^\S\n\r]/);
        default:
          return literal2(t);
      }
    };
    const unit = unitate(token2) || {
      invalidReason: MISSING_FTP
    };
    unit.token = token2;
    return unit;
  }
  var partTypeStyleToTokenVal = {
    year: {
      "2-digit": "yy",
      numeric: "yyyyy"
    },
    month: {
      numeric: "M",
      "2-digit": "MM",
      short: "MMM",
      long: "MMMM"
    },
    day: {
      numeric: "d",
      "2-digit": "dd"
    },
    weekday: {
      short: "EEE",
      long: "EEEE"
    },
    dayperiod: "a",
    dayPeriod: "a",
    hour12: {
      numeric: "h",
      "2-digit": "hh"
    },
    hour24: {
      numeric: "H",
      "2-digit": "HH"
    },
    minute: {
      numeric: "m",
      "2-digit": "mm"
    },
    second: {
      numeric: "s",
      "2-digit": "ss"
    },
    timeZoneName: {
      long: "ZZZZZ",
      short: "ZZZ"
    }
  };
  function tokenForPart(part, formatOpts, resolvedOpts) {
    const { type, value: value2 } = part;
    if (type === "literal") {
      const isSpace2 = /^\s+$/.test(value2);
      return {
        literal: !isSpace2,
        val: isSpace2 ? " " : value2
      };
    }
    const style = formatOpts[type];
    let actualType = type;
    if (type === "hour") {
      if (formatOpts.hour12 != null) {
        actualType = formatOpts.hour12 ? "hour12" : "hour24";
      } else if (formatOpts.hourCycle != null) {
        if (formatOpts.hourCycle === "h11" || formatOpts.hourCycle === "h12") {
          actualType = "hour12";
        } else {
          actualType = "hour24";
        }
      } else {
        actualType = resolvedOpts.hour12 ? "hour12" : "hour24";
      }
    }
    let val = partTypeStyleToTokenVal[actualType];
    if (typeof val === "object") {
      val = val[style];
    }
    if (val) {
      return {
        literal: false,
        val
      };
    }
    return void 0;
  }
  function buildRegex(units) {
    const re2 = units.map((u) => u.regex).reduce((f, r) => `${f}(${r.source})`, "");
    return [`^${re2}$`, units];
  }
  function match(input, regex, handlers) {
    const matches2 = input.match(regex);
    if (matches2) {
      const all = {};
      let matchIndex = 1;
      for (const i in handlers) {
        if (hasOwnProperty(handlers, i)) {
          const h = handlers[i], groups2 = h.groups ? h.groups + 1 : 1;
          if (!h.literal && h.token) {
            all[h.token.val[0]] = h.deser(matches2.slice(matchIndex, matchIndex + groups2));
          }
          matchIndex += groups2;
        }
      }
      return [matches2, all];
    } else {
      return [matches2, {}];
    }
  }
  function dateTimeFromMatches(matches2) {
    const toField = (token2) => {
      switch (token2) {
        case "S":
          return "millisecond";
        case "s":
          return "second";
        case "m":
          return "minute";
        case "h":
        case "H":
          return "hour";
        case "d":
          return "day";
        case "o":
          return "ordinal";
        case "L":
        case "M":
          return "month";
        case "y":
          return "year";
        case "E":
        case "c":
          return "weekday";
        case "W":
          return "weekNumber";
        case "k":
          return "weekYear";
        case "q":
          return "quarter";
        default:
          return null;
      }
    };
    let zone = null;
    let specificOffset;
    if (!isUndefined(matches2.z)) {
      zone = IANAZone.create(matches2.z);
    }
    if (!isUndefined(matches2.Z)) {
      if (!zone) {
        zone = new FixedOffsetZone(matches2.Z);
      }
      specificOffset = matches2.Z;
    }
    if (!isUndefined(matches2.q)) {
      matches2.M = (matches2.q - 1) * 3 + 1;
    }
    if (!isUndefined(matches2.h)) {
      if (matches2.h < 12 && matches2.a === 1) {
        matches2.h += 12;
      } else if (matches2.h === 12 && matches2.a === 0) {
        matches2.h = 0;
      }
    }
    if (matches2.G === 0 && matches2.y) {
      matches2.y = -matches2.y;
    }
    if (!isUndefined(matches2.u)) {
      matches2.S = parseMillis(matches2.u);
    }
    const vals = Object.keys(matches2).reduce((r, k) => {
      const f = toField(k);
      if (f) {
        r[f] = matches2[k];
      }
      return r;
    }, {});
    return [vals, zone, specificOffset];
  }
  var dummyDateTimeCache = null;
  function getDummyDateTime() {
    if (!dummyDateTimeCache) {
      dummyDateTimeCache = DateTime.fromMillis(1555555555555);
    }
    return dummyDateTimeCache;
  }
  function maybeExpandMacroToken(token2, locale2) {
    if (token2.literal) {
      return token2;
    }
    const formatOpts = Formatter.macroTokenToFormatOpts(token2.val);
    const tokens4 = formatOptsToTokens(formatOpts, locale2);
    if (tokens4 == null || tokens4.includes(void 0)) {
      return token2;
    }
    return tokens4;
  }
  function expandMacroTokens(tokens4, locale2) {
    return Array.prototype.concat(...tokens4.map((t) => maybeExpandMacroToken(t, locale2)));
  }
  var TokenParser = class {
    constructor(locale2, format3) {
      this.locale = locale2;
      this.format = format3;
      this.tokens = expandMacroTokens(Formatter.parseFormat(format3), locale2);
      this.units = this.tokens.map((t) => unitForToken(t, locale2));
      this.disqualifyingUnit = this.units.find((t) => t.invalidReason);
      if (!this.disqualifyingUnit) {
        const [regexString, handlers] = buildRegex(this.units);
        this.regex = RegExp(regexString, "i");
        this.handlers = handlers;
      }
    }
    explainFromTokens(input) {
      if (!this.isValid) {
        return { input, tokens: this.tokens, invalidReason: this.invalidReason };
      } else {
        const [rawMatches, matches2] = match(input, this.regex, this.handlers), [result, zone, specificOffset] = matches2 ? dateTimeFromMatches(matches2) : [null, null, void 0];
        if (hasOwnProperty(matches2, "a") && hasOwnProperty(matches2, "H")) {
          throw new ConflictingSpecificationError(
            "Can't include meridiem when specifying 24-hour format"
          );
        }
        return {
          input,
          tokens: this.tokens,
          regex: this.regex,
          rawMatches,
          matches: matches2,
          result,
          zone,
          specificOffset
        };
      }
    }
    get isValid() {
      return !this.disqualifyingUnit;
    }
    get invalidReason() {
      return this.disqualifyingUnit ? this.disqualifyingUnit.invalidReason : null;
    }
  };
  function explainFromTokens(locale2, input, format3) {
    const parser = new TokenParser(locale2, format3);
    return parser.explainFromTokens(input);
  }
  function parseFromTokens(locale2, input, format3) {
    const { result, zone, specificOffset, invalidReason } = explainFromTokens(locale2, input, format3);
    return [result, zone, specificOffset, invalidReason];
  }
  function formatOptsToTokens(formatOpts, locale2) {
    if (!formatOpts) {
      return null;
    }
    const formatter2 = Formatter.create(locale2, formatOpts);
    const df = formatter2.dtFormatter(getDummyDateTime());
    const parts = df.formatToParts();
    const resolvedOpts = df.resolvedOptions();
    return parts.map((p2) => tokenForPart(p2, formatOpts, resolvedOpts));
  }

  // ../../engine/rails_design/node_modules/luxon/src/datetime.js
  var INVALID3 = "Invalid DateTime";
  var MAX_DATE = 864e13;
  function unsupportedZone(zone) {
    return new Invalid("unsupported zone", `the zone "${zone.name}" is not supported`);
  }
  function possiblyCachedWeekData(dt) {
    if (dt.weekData === null) {
      dt.weekData = gregorianToWeek(dt.c);
    }
    return dt.weekData;
  }
  function possiblyCachedLocalWeekData(dt) {
    if (dt.localWeekData === null) {
      dt.localWeekData = gregorianToWeek(
        dt.c,
        dt.loc.getMinDaysInFirstWeek(),
        dt.loc.getStartOfWeek()
      );
    }
    return dt.localWeekData;
  }
  function clone2(inst, alts) {
    const current = {
      ts: inst.ts,
      zone: inst.zone,
      c: inst.c,
      o: inst.o,
      loc: inst.loc,
      invalid: inst.invalid
    };
    return new DateTime({ ...current, ...alts, old: current });
  }
  function fixOffset(localTS, o, tz) {
    let utcGuess = localTS - o * 60 * 1e3;
    const o2 = tz.offset(utcGuess);
    if (o === o2) {
      return [utcGuess, o];
    }
    utcGuess -= (o2 - o) * 60 * 1e3;
    const o3 = tz.offset(utcGuess);
    if (o2 === o3) {
      return [utcGuess, o2];
    }
    return [localTS - Math.min(o2, o3) * 60 * 1e3, Math.max(o2, o3)];
  }
  function tsToObj(ts, offset3) {
    ts += offset3 * 60 * 1e3;
    const d2 = new Date(ts);
    return {
      year: d2.getUTCFullYear(),
      month: d2.getUTCMonth() + 1,
      day: d2.getUTCDate(),
      hour: d2.getUTCHours(),
      minute: d2.getUTCMinutes(),
      second: d2.getUTCSeconds(),
      millisecond: d2.getUTCMilliseconds()
    };
  }
  function objToTS(obj, offset3, zone) {
    return fixOffset(objToLocalTS(obj), offset3, zone);
  }
  function adjustTime(inst, dur) {
    const oPre = inst.o, year2 = inst.c.year + Math.trunc(dur.years), month2 = inst.c.month + Math.trunc(dur.months) + Math.trunc(dur.quarters) * 3, c5 = {
      ...inst.c,
      year: year2,
      month: month2,
      day: Math.min(inst.c.day, daysInMonth(year2, month2)) + Math.trunc(dur.days) + Math.trunc(dur.weeks) * 7
    }, millisToAdd = Duration.fromObject({
      years: dur.years - Math.trunc(dur.years),
      quarters: dur.quarters - Math.trunc(dur.quarters),
      months: dur.months - Math.trunc(dur.months),
      weeks: dur.weeks - Math.trunc(dur.weeks),
      days: dur.days - Math.trunc(dur.days),
      hours: dur.hours,
      minutes: dur.minutes,
      seconds: dur.seconds,
      milliseconds: dur.milliseconds
    }).as("milliseconds"), localTS = objToLocalTS(c5);
    let [ts, o] = fixOffset(localTS, oPre, inst.zone);
    if (millisToAdd !== 0) {
      ts += millisToAdd;
      o = inst.zone.offset(ts);
    }
    return { ts, o };
  }
  function parseDataToDateTime(parsed, parsedZone, opts, format3, text, specificOffset) {
    const { setZone, zone } = opts;
    if (parsed && Object.keys(parsed).length !== 0 || parsedZone) {
      const interpretationZone = parsedZone || zone, inst = DateTime.fromObject(parsed, {
        ...opts,
        zone: interpretationZone,
        specificOffset
      });
      return setZone ? inst : inst.setZone(zone);
    } else {
      return DateTime.invalid(
        new Invalid("unparsable", `the input "${text}" can't be parsed as ${format3}`)
      );
    }
  }
  function toTechFormat(dt, format3, allowZ = true) {
    return dt.isValid ? Formatter.create(Locale.create("en-US"), {
      allowZ,
      forceSimple: true
    }).formatDateTimeFromString(dt, format3) : null;
  }
  function toISODate(o, extended) {
    const longFormat = o.c.year > 9999 || o.c.year < 0;
    let c5 = "";
    if (longFormat && o.c.year >= 0) c5 += "+";
    c5 += padStart(o.c.year, longFormat ? 6 : 4);
    if (extended) {
      c5 += "-";
      c5 += padStart(o.c.month);
      c5 += "-";
      c5 += padStart(o.c.day);
    } else {
      c5 += padStart(o.c.month);
      c5 += padStart(o.c.day);
    }
    return c5;
  }
  function toISOTime(o, extended, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone) {
    let c5 = padStart(o.c.hour);
    if (extended) {
      c5 += ":";
      c5 += padStart(o.c.minute);
      if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
        c5 += ":";
      }
    } else {
      c5 += padStart(o.c.minute);
    }
    if (o.c.millisecond !== 0 || o.c.second !== 0 || !suppressSeconds) {
      c5 += padStart(o.c.second);
      if (o.c.millisecond !== 0 || !suppressMilliseconds) {
        c5 += ".";
        c5 += padStart(o.c.millisecond, 3);
      }
    }
    if (includeOffset) {
      if (o.isOffsetFixed && o.offset === 0 && !extendedZone) {
        c5 += "Z";
      } else if (o.o < 0) {
        c5 += "-";
        c5 += padStart(Math.trunc(-o.o / 60));
        c5 += ":";
        c5 += padStart(Math.trunc(-o.o % 60));
      } else {
        c5 += "+";
        c5 += padStart(Math.trunc(o.o / 60));
        c5 += ":";
        c5 += padStart(Math.trunc(o.o % 60));
      }
    }
    if (extendedZone) {
      c5 += "[" + o.zone.ianaName + "]";
    }
    return c5;
  }
  var defaultUnitValues = {
    month: 1,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultWeekUnitValues = {
    weekNumber: 1,
    weekday: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var defaultOrdinalUnitValues = {
    ordinal: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0
  };
  var orderedUnits2 = ["year", "month", "day", "hour", "minute", "second", "millisecond"];
  var orderedWeekUnits = [
    "weekYear",
    "weekNumber",
    "weekday",
    "hour",
    "minute",
    "second",
    "millisecond"
  ];
  var orderedOrdinalUnits = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
  function normalizeUnit(unit) {
    const normalized = {
      year: "year",
      years: "year",
      month: "month",
      months: "month",
      day: "day",
      days: "day",
      hour: "hour",
      hours: "hour",
      minute: "minute",
      minutes: "minute",
      quarter: "quarter",
      quarters: "quarter",
      second: "second",
      seconds: "second",
      millisecond: "millisecond",
      milliseconds: "millisecond",
      weekday: "weekday",
      weekdays: "weekday",
      weeknumber: "weekNumber",
      weeksnumber: "weekNumber",
      weeknumbers: "weekNumber",
      weekyear: "weekYear",
      weekyears: "weekYear",
      ordinal: "ordinal"
    }[unit.toLowerCase()];
    if (!normalized) throw new InvalidUnitError(unit);
    return normalized;
  }
  function normalizeUnitWithLocalWeeks(unit) {
    switch (unit.toLowerCase()) {
      case "localweekday":
      case "localweekdays":
        return "localWeekday";
      case "localweeknumber":
      case "localweeknumbers":
        return "localWeekNumber";
      case "localweekyear":
      case "localweekyears":
        return "localWeekYear";
      default:
        return normalizeUnit(unit);
    }
  }
  function guessOffsetForZone(zone) {
    if (!zoneOffsetGuessCache[zone]) {
      if (zoneOffsetTs === void 0) {
        zoneOffsetTs = Settings.now();
      }
      zoneOffsetGuessCache[zone] = zone.offset(zoneOffsetTs);
    }
    return zoneOffsetGuessCache[zone];
  }
  function quickDT(obj, opts) {
    const zone = normalizeZone(opts.zone, Settings.defaultZone);
    if (!zone.isValid) {
      return DateTime.invalid(unsupportedZone(zone));
    }
    const loc = Locale.fromObject(opts);
    let ts, o;
    if (!isUndefined(obj.year)) {
      for (const u of orderedUnits2) {
        if (isUndefined(obj[u])) {
          obj[u] = defaultUnitValues[u];
        }
      }
      const invalid = hasInvalidGregorianData(obj) || hasInvalidTimeData(obj);
      if (invalid) {
        return DateTime.invalid(invalid);
      }
      const offsetProvis = guessOffsetForZone(zone);
      [ts, o] = objToTS(obj, offsetProvis, zone);
    } else {
      ts = Settings.now();
    }
    return new DateTime({ ts, zone, loc, o });
  }
  function diffRelative(start2, end, opts) {
    const round5 = isUndefined(opts.round) ? true : opts.round, format3 = (c5, unit) => {
      c5 = roundTo(c5, round5 || opts.calendary ? 0 : 2, true);
      const formatter2 = end.loc.clone(opts).relFormatter(opts);
      return formatter2.format(c5, unit);
    }, differ = (unit) => {
      if (opts.calendary) {
        if (!end.hasSame(start2, unit)) {
          return end.startOf(unit).diff(start2.startOf(unit), unit).get(unit);
        } else return 0;
      } else {
        return end.diff(start2, unit).get(unit);
      }
    };
    if (opts.unit) {
      return format3(differ(opts.unit), opts.unit);
    }
    for (const unit of opts.units) {
      const count4 = differ(unit);
      if (Math.abs(count4) >= 1) {
        return format3(count4, unit);
      }
    }
    return format3(start2 > end ? -0 : 0, opts.units[opts.units.length - 1]);
  }
  function lastOpts(argList) {
    let opts = {}, args;
    if (argList.length > 0 && typeof argList[argList.length - 1] === "object") {
      opts = argList[argList.length - 1];
      args = Array.from(argList).slice(0, argList.length - 1);
    } else {
      args = Array.from(argList);
    }
    return [opts, args];
  }
  var zoneOffsetTs;
  var zoneOffsetGuessCache = {};
  var DateTime = class _DateTime {
    /**
     * @access private
     */
    constructor(config2) {
      const zone = config2.zone || Settings.defaultZone;
      let invalid = config2.invalid || (Number.isNaN(config2.ts) ? new Invalid("invalid input") : null) || (!zone.isValid ? unsupportedZone(zone) : null);
      this.ts = isUndefined(config2.ts) ? Settings.now() : config2.ts;
      let c5 = null, o = null;
      if (!invalid) {
        const unchanged = config2.old && config2.old.ts === this.ts && config2.old.zone.equals(zone);
        if (unchanged) {
          [c5, o] = [config2.old.c, config2.old.o];
        } else {
          const ot = isNumber(config2.o) && !config2.old ? config2.o : zone.offset(this.ts);
          c5 = tsToObj(this.ts, ot);
          invalid = Number.isNaN(c5.year) ? new Invalid("invalid input") : null;
          c5 = invalid ? null : c5;
          o = invalid ? null : ot;
        }
      }
      this._zone = zone;
      this.loc = config2.loc || Locale.create();
      this.invalid = invalid;
      this.weekData = null;
      this.localWeekData = null;
      this.c = c5;
      this.o = o;
      this.isLuxonDateTime = true;
    }
    // CONSTRUCT
    /**
     * Create a DateTime for the current instant, in the system's time zone.
     *
     * Use Settings to override these default values if needed.
     * @example DateTime.now().toISO() //~> now in the ISO format
     * @return {DateTime}
     */
    static now() {
      return new _DateTime({});
    }
    /**
     * Create a local DateTime
     * @param {number} [year] - The calendar year. If omitted (as in, call `local()` with no arguments), the current time will be used
     * @param {number} [month=1] - The month, 1-indexed
     * @param {number} [day=1] - The day of the month, 1-indexed
     * @param {number} [hour=0] - The hour of the day, in 24-hour time
     * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
     * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
     * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
     * @example DateTime.local()                                  //~> now
     * @example DateTime.local({ zone: "America/New_York" })      //~> now, in US east coast time
     * @example DateTime.local(2017)                              //~> 2017-01-01T00:00:00
     * @example DateTime.local(2017, 3)                           //~> 2017-03-01T00:00:00
     * @example DateTime.local(2017, 3, 12, { locale: "fr" })     //~> 2017-03-12T00:00:00, with a French locale
     * @example DateTime.local(2017, 3, 12, 5)                    //~> 2017-03-12T05:00:00
     * @example DateTime.local(2017, 3, 12, 5, { zone: "utc" })   //~> 2017-03-12T05:00:00, in UTC
     * @example DateTime.local(2017, 3, 12, 5, 45)                //~> 2017-03-12T05:45:00
     * @example DateTime.local(2017, 3, 12, 5, 45, 10)            //~> 2017-03-12T05:45:10
     * @example DateTime.local(2017, 3, 12, 5, 45, 10, 765)       //~> 2017-03-12T05:45:10.765
     * @return {DateTime}
     */
    static local() {
      const [opts, args] = lastOpts(arguments), [year2, month2, day2, hour2, minute2, second2, millisecond2] = args;
      return quickDT({ year: year2, month: month2, day: day2, hour: hour2, minute: minute2, second: second2, millisecond: millisecond2 }, opts);
    }
    /**
     * Create a DateTime in UTC
     * @param {number} [year] - The calendar year. If omitted (as in, call `utc()` with no arguments), the current time will be used
     * @param {number} [month=1] - The month, 1-indexed
     * @param {number} [day=1] - The day of the month
     * @param {number} [hour=0] - The hour of the day, in 24-hour time
     * @param {number} [minute=0] - The minute of the hour, meaning a number between 0 and 59
     * @param {number} [second=0] - The second of the minute, meaning a number between 0 and 59
     * @param {number} [millisecond=0] - The millisecond of the second, meaning a number between 0 and 999
     * @param {Object} options - configuration options for the DateTime
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} [options.outputCalendar] - the output calendar to set on the resulting DateTime instance
     * @param {string} [options.numberingSystem] - the numbering system to set on the resulting DateTime instance
     * @param {string} [options.weekSettings] - the week settings to set on the resulting DateTime instance
     * @example DateTime.utc()                                              //~> now
     * @example DateTime.utc(2017)                                          //~> 2017-01-01T00:00:00Z
     * @example DateTime.utc(2017, 3)                                       //~> 2017-03-01T00:00:00Z
     * @example DateTime.utc(2017, 3, 12)                                   //~> 2017-03-12T00:00:00Z
     * @example DateTime.utc(2017, 3, 12, 5)                                //~> 2017-03-12T05:00:00Z
     * @example DateTime.utc(2017, 3, 12, 5, 45)                            //~> 2017-03-12T05:45:00Z
     * @example DateTime.utc(2017, 3, 12, 5, 45, { locale: "fr" })          //~> 2017-03-12T05:45:00Z with a French locale
     * @example DateTime.utc(2017, 3, 12, 5, 45, 10)                        //~> 2017-03-12T05:45:10Z
     * @example DateTime.utc(2017, 3, 12, 5, 45, 10, 765, { locale: "fr" }) //~> 2017-03-12T05:45:10.765Z with a French locale
     * @return {DateTime}
     */
    static utc() {
      const [opts, args] = lastOpts(arguments), [year2, month2, day2, hour2, minute2, second2, millisecond2] = args;
      opts.zone = FixedOffsetZone.utcInstance;
      return quickDT({ year: year2, month: month2, day: day2, hour: hour2, minute: minute2, second: second2, millisecond: millisecond2 }, opts);
    }
    /**
     * Create a DateTime from a JavaScript Date object. Uses the default zone.
     * @param {Date} date - a JavaScript Date object
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @return {DateTime}
     */
    static fromJSDate(date, options = {}) {
      const ts = isDate(date) ? date.valueOf() : NaN;
      if (Number.isNaN(ts)) {
        return _DateTime.invalid("invalid input");
      }
      const zoneToUse = normalizeZone(options.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return _DateTime.invalid(unsupportedZone(zoneToUse));
      }
      return new _DateTime({
        ts,
        zone: zoneToUse,
        loc: Locale.fromObject(options)
      });
    }
    /**
     * Create a DateTime from a number of milliseconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     * @param {number} milliseconds - a number of milliseconds since 1970 UTC
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromMillis(milliseconds, options = {}) {
      if (!isNumber(milliseconds)) {
        throw new InvalidArgumentError(
          `fromMillis requires a numerical input, but received a ${typeof milliseconds} with value ${milliseconds}`
        );
      } else if (milliseconds < -MAX_DATE || milliseconds > MAX_DATE) {
        return _DateTime.invalid("Timestamp out of range");
      } else {
        return new _DateTime({
          ts: milliseconds,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    /**
     * Create a DateTime from a number of seconds since the epoch (meaning since 1 January 1970 00:00:00 UTC). Uses the default zone.
     * @param {number} seconds - a number of seconds since 1970 UTC
     * @param {Object} options - configuration options for the DateTime
     * @param {string|Zone} [options.zone='local'] - the zone to place the DateTime into
     * @param {string} [options.locale] - a locale to set on the resulting DateTime instance
     * @param {string} options.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} options.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} options.weekSettings - the week settings to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromSeconds(seconds, options = {}) {
      if (!isNumber(seconds)) {
        throw new InvalidArgumentError("fromSeconds requires a numerical input");
      } else {
        return new _DateTime({
          ts: seconds * 1e3,
          zone: normalizeZone(options.zone, Settings.defaultZone),
          loc: Locale.fromObject(options)
        });
      }
    }
    /**
     * Create a DateTime from a JavaScript object with keys like 'year' and 'hour' with reasonable defaults.
     * @param {Object} obj - the object to create the DateTime from
     * @param {number} obj.year - a year, such as 1987
     * @param {number} obj.month - a month, 1-12
     * @param {number} obj.day - a day of the month, 1-31, depending on the month
     * @param {number} obj.ordinal - day of the year, 1-365 or 366
     * @param {number} obj.weekYear - an ISO week year
     * @param {number} obj.weekNumber - an ISO week number, between 1 and 52 or 53, depending on the year
     * @param {number} obj.weekday - an ISO weekday, 1-7, where 1 is Monday and 7 is Sunday
     * @param {number} obj.localWeekYear - a week year, according to the locale
     * @param {number} obj.localWeekNumber - a week number, between 1 and 52 or 53, depending on the year, according to the locale
     * @param {number} obj.localWeekday - a weekday, 1-7, where 1 is the first and 7 is the last day of the week, according to the locale
     * @param {number} obj.hour - hour of the day, 0-23
     * @param {number} obj.minute - minute of the hour, 0-59
     * @param {number} obj.second - second of the minute, 0-59
     * @param {number} obj.millisecond - millisecond of the second, 0-999
     * @param {Object} opts - options for creating this DateTime
     * @param {string|Zone} [opts.zone='local'] - interpret the numbers in the context of a particular zone. Can take any value taken as the first argument to setZone()
     * @param {string} [opts.locale='system\'s locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromObject({ year: 1982, month: 5, day: 25}).toISODate() //=> '1982-05-25'
     * @example DateTime.fromObject({ year: 1982 }).toISODate() //=> '1982-01-01'
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }) //~> today at 10:26:06
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'utc' }),
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'local' })
     * @example DateTime.fromObject({ hour: 10, minute: 26, second: 6 }, { zone: 'America/New_York' })
     * @example DateTime.fromObject({ weekYear: 2016, weekNumber: 2, weekday: 3 }).toISODate() //=> '2016-01-13'
     * @example DateTime.fromObject({ localWeekYear: 2022, localWeekNumber: 1, localWeekday: 1 }, { locale: "en-US" }).toISODate() //=> '2021-12-26'
     * @return {DateTime}
     */
    static fromObject(obj, opts = {}) {
      obj = obj || {};
      const zoneToUse = normalizeZone(opts.zone, Settings.defaultZone);
      if (!zoneToUse.isValid) {
        return _DateTime.invalid(unsupportedZone(zoneToUse));
      }
      const loc = Locale.fromObject(opts);
      const normalized = normalizeObject(obj, normalizeUnitWithLocalWeeks);
      const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, loc);
      const tsNow = Settings.now(), offsetProvis = !isUndefined(opts.specificOffset) ? opts.specificOffset : zoneToUse.offset(tsNow), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError(
          "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
        );
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      const useWeekData = definiteWeekDef || normalized.weekday && !containsGregor;
      let units, defaultValues, objNow = tsToObj(tsNow, offsetProvis);
      if (useWeekData) {
        units = orderedWeekUnits;
        defaultValues = defaultWeekUnitValues;
        objNow = gregorianToWeek(objNow, minDaysInFirstWeek, startOfWeek);
      } else if (containsOrdinal) {
        units = orderedOrdinalUnits;
        defaultValues = defaultOrdinalUnitValues;
        objNow = gregorianToOrdinal(objNow);
      } else {
        units = orderedUnits2;
        defaultValues = defaultUnitValues;
      }
      let foundFirst = false;
      for (const u of units) {
        const v = normalized[u];
        if (!isUndefined(v)) {
          foundFirst = true;
        } else if (foundFirst) {
          normalized[u] = defaultValues[u];
        } else {
          normalized[u] = objNow[u];
        }
      }
      const higherOrderInvalid = useWeekData ? hasInvalidWeekData(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? hasInvalidOrdinalData(normalized) : hasInvalidGregorianData(normalized), invalid = higherOrderInvalid || hasInvalidTimeData(normalized);
      if (invalid) {
        return _DateTime.invalid(invalid);
      }
      const gregorian = useWeekData ? weekToGregorian(normalized, minDaysInFirstWeek, startOfWeek) : containsOrdinal ? ordinalToGregorian(normalized) : normalized, [tsFinal, offsetFinal] = objToTS(gregorian, offsetProvis, zoneToUse), inst = new _DateTime({
        ts: tsFinal,
        zone: zoneToUse,
        o: offsetFinal,
        loc
      });
      if (normalized.weekday && containsGregor && obj.weekday !== inst.weekday) {
        return _DateTime.invalid(
          "mismatched weekday",
          `you can't specify both a weekday of ${normalized.weekday} and a date of ${inst.toISO()}`
        );
      }
      if (!inst.isValid) {
        return _DateTime.invalid(inst.invalid);
      }
      return inst;
    }
    /**
     * Create a DateTime from an ISO 8601 string
     * @param {string} text - the ISO string
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the time to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} [opts.outputCalendar] - the output calendar to set on the resulting DateTime instance
     * @param {string} [opts.numberingSystem] - the numbering system to set on the resulting DateTime instance
     * @param {string} [opts.weekSettings] - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromISO('2016-05-25T09:08:34.123')
     * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00')
     * @example DateTime.fromISO('2016-05-25T09:08:34.123+06:00', {setZone: true})
     * @example DateTime.fromISO('2016-05-25T09:08:34.123', {zone: 'utc'})
     * @example DateTime.fromISO('2016-W05-4')
     * @return {DateTime}
     */
    static fromISO(text, opts = {}) {
      const [vals, parsedZone] = parseISODate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "ISO 8601", text);
    }
    /**
     * Create a DateTime from an RFC 2822 string
     * @param {string} text - the RFC 2822 string
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since the offset is always specified in the string itself, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
     * @param {boolean} [opts.setZone=false] - override the zone with a fixed-offset zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromRFC2822('25 Nov 2016 13:23:12 GMT')
     * @example DateTime.fromRFC2822('Fri, 25 Nov 2016 13:23:12 +0600')
     * @example DateTime.fromRFC2822('25 Nov 2016 13:23 Z')
     * @return {DateTime}
     */
    static fromRFC2822(text, opts = {}) {
      const [vals, parsedZone] = parseRFC2822Date(text);
      return parseDataToDateTime(vals, parsedZone, opts, "RFC 2822", text);
    }
    /**
     * Create a DateTime from an HTTP header date
     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
     * @param {string} text - the HTTP header date
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - convert the time to this zone. Since HTTP dates are always in UTC, this has no effect on the interpretation of string, merely the zone the resulting DateTime is expressed in.
     * @param {boolean} [opts.setZone=false] - override the zone with the fixed-offset zone specified in the string. For HTTP dates, this is always UTC, so this option is equivalent to setting the `zone` option to 'utc', but this option is included for consistency with similar methods.
     * @param {string} [opts.locale='system's locale'] - a locale to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @param {string} opts.numberingSystem - the numbering system to set on the resulting DateTime instance
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @example DateTime.fromHTTP('Sun, 06 Nov 1994 08:49:37 GMT')
     * @example DateTime.fromHTTP('Sunday, 06-Nov-94 08:49:37 GMT')
     * @example DateTime.fromHTTP('Sun Nov  6 08:49:37 1994')
     * @return {DateTime}
     */
    static fromHTTP(text, opts = {}) {
      const [vals, parsedZone] = parseHTTPDate(text);
      return parseDataToDateTime(vals, parsedZone, opts, "HTTP", opts);
    }
    /**
     * Create a DateTime from an input string and format string.
     * Defaults to en-US if no locale has been specified, regardless of the system's locale. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/parsing?id=table-of-tokens).
     * @param {string} text - the string to parse
     * @param {string} fmt - the format the string is expected to be in (see the link below for the formats)
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
     * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @return {DateTime}
     */
    static fromFormat(text, fmt, opts = {}) {
      if (isUndefined(text) || isUndefined(fmt)) {
        throw new InvalidArgumentError("fromFormat requires an input string and a format");
      }
      const { locale: locale2 = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
        locale: locale2,
        numberingSystem,
        defaultToEN: true
      }), [vals, parsedZone, specificOffset, invalid] = parseFromTokens(localeToUse, text, fmt);
      if (invalid) {
        return _DateTime.invalid(invalid);
      } else {
        return parseDataToDateTime(vals, parsedZone, opts, `format ${fmt}`, text, specificOffset);
      }
    }
    /**
     * @deprecated use fromFormat instead
     */
    static fromString(text, fmt, opts = {}) {
      return _DateTime.fromFormat(text, fmt, opts);
    }
    /**
     * Create a DateTime from a SQL date, time, or datetime
     * Defaults to en-US if no locale has been specified, regardless of the system's locale
     * @param {string} text - the string to parse
     * @param {Object} opts - options to affect the creation
     * @param {string|Zone} [opts.zone='local'] - use this zone if no offset is specified in the input string itself. Will also convert the DateTime to this zone
     * @param {boolean} [opts.setZone=false] - override the zone with a zone specified in the string itself, if it specifies one
     * @param {string} [opts.locale='en-US'] - a locale string to use when parsing. Will also set the DateTime to this locale
     * @param {string} opts.numberingSystem - the numbering system to use when parsing. Will also set the resulting DateTime to this numbering system
     * @param {string} opts.weekSettings - the week settings to set on the resulting DateTime instance
     * @param {string} opts.outputCalendar - the output calendar to set on the resulting DateTime instance
     * @example DateTime.fromSQL('2017-05-15')
     * @example DateTime.fromSQL('2017-05-15 09:12:34')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342+06:00')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles')
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342 America/Los_Angeles', { setZone: true })
     * @example DateTime.fromSQL('2017-05-15 09:12:34.342', { zone: 'America/Los_Angeles' })
     * @example DateTime.fromSQL('09:12:34.342')
     * @return {DateTime}
     */
    static fromSQL(text, opts = {}) {
      const [vals, parsedZone] = parseSQL(text);
      return parseDataToDateTime(vals, parsedZone, opts, "SQL", text);
    }
    /**
     * Create an invalid DateTime.
     * @param {string} reason - simple string of why this DateTime is invalid. Should not contain parameters or anything else data-dependent.
     * @param {string} [explanation=null] - longer explanation, may include parameters and other useful debugging information
     * @return {DateTime}
     */
    static invalid(reason, explanation = null) {
      if (!reason) {
        throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
      }
      const invalid = reason instanceof Invalid ? reason : new Invalid(reason, explanation);
      if (Settings.throwOnInvalid) {
        throw new InvalidDateTimeError(invalid);
      } else {
        return new _DateTime({ invalid });
      }
    }
    /**
     * Check if an object is an instance of DateTime. Works across context boundaries
     * @param {object} o
     * @return {boolean}
     */
    static isDateTime(o) {
      return o && o.isLuxonDateTime || false;
    }
    /**
     * Produce the format string for a set of options
     * @param formatOpts
     * @param localeOpts
     * @returns {string}
     */
    static parseFormatForOpts(formatOpts, localeOpts = {}) {
      const tokenList = formatOptsToTokens(formatOpts, Locale.fromObject(localeOpts));
      return !tokenList ? null : tokenList.map((t) => t ? t.val : null).join("");
    }
    /**
     * Produce the the fully expanded format token for the locale
     * Does NOT quote characters, so quoted tokens will not round trip correctly
     * @param fmt
     * @param localeOpts
     * @returns {string}
     */
    static expandFormat(fmt, localeOpts = {}) {
      const expanded = expandMacroTokens(Formatter.parseFormat(fmt), Locale.fromObject(localeOpts));
      return expanded.map((t) => t.val).join("");
    }
    static resetCache() {
      zoneOffsetTs = void 0;
      zoneOffsetGuessCache = {};
    }
    // INFO
    /**
     * Get the value of unit.
     * @param {string} unit - a unit such as 'minute' or 'day'
     * @example DateTime.local(2017, 7, 4).get('month'); //=> 7
     * @example DateTime.local(2017, 7, 4).get('day'); //=> 4
     * @return {number}
     */
    get(unit) {
      return this[unit];
    }
    /**
     * Returns whether the DateTime is valid. Invalid DateTimes occur when:
     * * The DateTime was created from invalid calendar information, such as the 13th month or February 30
     * * The DateTime was created by an operation on another invalid date
     * @type {boolean}
     */
    get isValid() {
      return this.invalid === null;
    }
    /**
     * Returns an error code if this DateTime is invalid, or null if the DateTime is valid
     * @type {string}
     */
    get invalidReason() {
      return this.invalid ? this.invalid.reason : null;
    }
    /**
     * Returns an explanation of why this DateTime became invalid, or null if the DateTime is valid
     * @type {string}
     */
    get invalidExplanation() {
      return this.invalid ? this.invalid.explanation : null;
    }
    /**
     * Get the locale of a DateTime, such 'en-GB'. The locale is used when formatting the DateTime
     *
     * @type {string}
     */
    get locale() {
      return this.isValid ? this.loc.locale : null;
    }
    /**
     * Get the numbering system of a DateTime, such 'beng'. The numbering system is used when formatting the DateTime
     *
     * @type {string}
     */
    get numberingSystem() {
      return this.isValid ? this.loc.numberingSystem : null;
    }
    /**
     * Get the output calendar of a DateTime, such 'islamic'. The output calendar is used when formatting the DateTime
     *
     * @type {string}
     */
    get outputCalendar() {
      return this.isValid ? this.loc.outputCalendar : null;
    }
    /**
     * Get the time zone associated with this DateTime.
     * @type {Zone}
     */
    get zone() {
      return this._zone;
    }
    /**
     * Get the name of the time zone.
     * @type {string}
     */
    get zoneName() {
      return this.isValid ? this.zone.name : null;
    }
    /**
     * Get the year
     * @example DateTime.local(2017, 5, 25).year //=> 2017
     * @type {number}
     */
    get year() {
      return this.isValid ? this.c.year : NaN;
    }
    /**
     * Get the quarter
     * @example DateTime.local(2017, 5, 25).quarter //=> 2
     * @type {number}
     */
    get quarter() {
      return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
    }
    /**
     * Get the month (1-12).
     * @example DateTime.local(2017, 5, 25).month //=> 5
     * @type {number}
     */
    get month() {
      return this.isValid ? this.c.month : NaN;
    }
    /**
     * Get the day of the month (1-30ish).
     * @example DateTime.local(2017, 5, 25).day //=> 25
     * @type {number}
     */
    get day() {
      return this.isValid ? this.c.day : NaN;
    }
    /**
     * Get the hour of the day (0-23).
     * @example DateTime.local(2017, 5, 25, 9).hour //=> 9
     * @type {number}
     */
    get hour() {
      return this.isValid ? this.c.hour : NaN;
    }
    /**
     * Get the minute of the hour (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30).minute //=> 30
     * @type {number}
     */
    get minute() {
      return this.isValid ? this.c.minute : NaN;
    }
    /**
     * Get the second of the minute (0-59).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52).second //=> 52
     * @type {number}
     */
    get second() {
      return this.isValid ? this.c.second : NaN;
    }
    /**
     * Get the millisecond of the second (0-999).
     * @example DateTime.local(2017, 5, 25, 9, 30, 52, 654).millisecond //=> 654
     * @type {number}
     */
    get millisecond() {
      return this.isValid ? this.c.millisecond : NaN;
    }
    /**
     * Get the week year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 12, 31).weekYear //=> 2015
     * @type {number}
     */
    get weekYear() {
      return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
    }
    /**
     * Get the week number of the week year (1-52ish).
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2017, 5, 25).weekNumber //=> 21
     * @type {number}
     */
    get weekNumber() {
      return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
    }
    /**
     * Get the day of the week.
     * 1 is Monday and 7 is Sunday
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2014, 11, 31).weekday //=> 4
     * @type {number}
     */
    get weekday() {
      return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
    }
    /**
     * Returns true if this date is on a weekend according to the locale, false otherwise
     * @returns {boolean}
     */
    get isWeekend() {
      return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
    }
    /**
     * Get the day of the week according to the locale.
     * 1 is the first day of the week and 7 is the last day of the week.
     * If the locale assigns Sunday as the first day of the week, then a date which is a Sunday will return 1,
     * @returns {number}
     */
    get localWeekday() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
    }
    /**
     * Get the week number of the week year according to the locale. Different locales assign week numbers differently,
     * because the week can start on different days of the week (see localWeekday) and because a different number of days
     * is required for a week to count as the first week of a year.
     * @returns {number}
     */
    get localWeekNumber() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
    }
    /**
     * Get the week year according to the locale. Different locales assign week numbers (and therefor week years)
     * differently, see localWeekNumber.
     * @returns {number}
     */
    get localWeekYear() {
      return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
    }
    /**
     * Get the ordinal (meaning the day of the year)
     * @example DateTime.local(2017, 5, 25).ordinal //=> 145
     * @type {number|DateTime}
     */
    get ordinal() {
      return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
    }
    /**
     * Get the human readable short month name, such as 'Oct'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthShort //=> Oct
     * @type {string}
     */
    get monthShort() {
      return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
    }
    /**
     * Get the human readable long month name, such as 'October'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).monthLong //=> October
     * @type {string}
     */
    get monthLong() {
      return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
    }
    /**
     * Get the human readable short weekday, such as 'Mon'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayShort //=> Mon
     * @type {string}
     */
    get weekdayShort() {
      return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
    }
    /**
     * Get the human readable long weekday, such as 'Monday'.
     * Defaults to the system's locale if no locale has been specified
     * @example DateTime.local(2017, 10, 30).weekdayLong //=> Monday
     * @type {string}
     */
    get weekdayLong() {
      return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
    }
    /**
     * Get the UTC offset of this DateTime in minutes
     * @example DateTime.now().offset //=> -240
     * @example DateTime.utc().offset //=> 0
     * @type {number}
     */
    get offset() {
      return this.isValid ? +this.o : NaN;
    }
    /**
     * Get the short human name for the zone's current offset, for example "EST" or "EDT".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
    get offsetNameShort() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "short",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    /**
     * Get the long human name for the zone's current offset, for example "Eastern Standard Time" or "Eastern Daylight Time".
     * Defaults to the system's locale if no locale has been specified
     * @type {string}
     */
    get offsetNameLong() {
      if (this.isValid) {
        return this.zone.offsetName(this.ts, {
          format: "long",
          locale: this.locale
        });
      } else {
        return null;
      }
    }
    /**
     * Get whether this zone's offset ever changes, as in a DST.
     * @type {boolean}
     */
    get isOffsetFixed() {
      return this.isValid ? this.zone.isUniversal : null;
    }
    /**
     * Get whether the DateTime is in a DST.
     * @type {boolean}
     */
    get isInDST() {
      if (this.isOffsetFixed) {
        return false;
      } else {
        return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
      }
    }
    /**
     * Get those DateTimes which have the same local time as this DateTime, but a different offset from UTC
     * in this DateTime's zone. During DST changes local time can be ambiguous, for example
     * `2023-10-29T02:30:00` in `Europe/Berlin` can have offset `+01:00` or `+02:00`.
     * This method will return both possible DateTimes if this DateTime's local time is ambiguous.
     * @returns {DateTime[]}
     */
    getPossibleOffsets() {
      if (!this.isValid || this.isOffsetFixed) {
        return [this];
      }
      const dayMs = 864e5;
      const minuteMs = 6e4;
      const localTS = objToLocalTS(this.c);
      const oEarlier = this.zone.offset(localTS - dayMs);
      const oLater = this.zone.offset(localTS + dayMs);
      const o1 = this.zone.offset(localTS - oEarlier * minuteMs);
      const o2 = this.zone.offset(localTS - oLater * minuteMs);
      if (o1 === o2) {
        return [this];
      }
      const ts1 = localTS - o1 * minuteMs;
      const ts2 = localTS - o2 * minuteMs;
      const c1 = tsToObj(ts1, o1);
      const c22 = tsToObj(ts2, o2);
      if (c1.hour === c22.hour && c1.minute === c22.minute && c1.second === c22.second && c1.millisecond === c22.millisecond) {
        return [clone2(this, { ts: ts1 }), clone2(this, { ts: ts2 })];
      }
      return [this];
    }
    /**
     * Returns true if this DateTime is in a leap year, false otherwise
     * @example DateTime.local(2016).isInLeapYear //=> true
     * @example DateTime.local(2013).isInLeapYear //=> false
     * @type {boolean}
     */
    get isInLeapYear() {
      return isLeapYear(this.year);
    }
    /**
     * Returns the number of days in this DateTime's month
     * @example DateTime.local(2016, 2).daysInMonth //=> 29
     * @example DateTime.local(2016, 3).daysInMonth //=> 31
     * @type {number}
     */
    get daysInMonth() {
      return daysInMonth(this.year, this.month);
    }
    /**
     * Returns the number of days in this DateTime's year
     * @example DateTime.local(2016).daysInYear //=> 366
     * @example DateTime.local(2013).daysInYear //=> 365
     * @type {number}
     */
    get daysInYear() {
      return this.isValid ? daysInYear(this.year) : NaN;
    }
    /**
     * Returns the number of weeks in this DateTime's year
     * @see https://en.wikipedia.org/wiki/ISO_week_date
     * @example DateTime.local(2004).weeksInWeekYear //=> 53
     * @example DateTime.local(2013).weeksInWeekYear //=> 52
     * @type {number}
     */
    get weeksInWeekYear() {
      return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
    }
    /**
     * Returns the number of weeks in this DateTime's local week year
     * @example DateTime.local(2020, 6, {locale: 'en-US'}).weeksInLocalWeekYear //=> 52
     * @example DateTime.local(2020, 6, {locale: 'de-DE'}).weeksInLocalWeekYear //=> 53
     * @type {number}
     */
    get weeksInLocalWeekYear() {
      return this.isValid ? weeksInWeekYear(
        this.localWeekYear,
        this.loc.getMinDaysInFirstWeek(),
        this.loc.getStartOfWeek()
      ) : NaN;
    }
    /**
     * Returns the resolved Intl options for this DateTime.
     * This is useful in understanding the behavior of formatting methods
     * @param {Object} opts - the same options as toLocaleString
     * @return {Object}
     */
    resolvedLocaleOptions(opts = {}) {
      const { locale: locale2, numberingSystem, calendar } = Formatter.create(
        this.loc.clone(opts),
        opts
      ).resolvedOptions(this);
      return { locale: locale2, numberingSystem, outputCalendar: calendar };
    }
    // TRANSFORM
    /**
     * "Set" the DateTime's zone to UTC. Returns a newly-constructed DateTime.
     *
     * Equivalent to {@link DateTime#setZone}('utc')
     * @param {number} [offset=0] - optionally, an offset from UTC in minutes
     * @param {Object} [opts={}] - options to pass to `setZone()`
     * @return {DateTime}
     */
    toUTC(offset3 = 0, opts = {}) {
      return this.setZone(FixedOffsetZone.instance(offset3), opts);
    }
    /**
     * "Set" the DateTime's zone to the host's local zone. Returns a newly-constructed DateTime.
     *
     * Equivalent to `setZone('local')`
     * @return {DateTime}
     */
    toLocal() {
      return this.setZone(Settings.defaultZone);
    }
    /**
     * "Set" the DateTime's zone to specified zone. Returns a newly-constructed DateTime.
     *
     * By default, the setter keeps the underlying time the same (as in, the same timestamp), but the new instance will report different local times and consider DSTs when making computations, as with {@link DateTime#plus}. You may wish to use {@link DateTime#toLocal} and {@link DateTime#toUTC} which provide simple convenience wrappers for commonly used zones.
     * @param {string|Zone} [zone='local'] - a zone identifier. As a string, that can be any IANA zone supported by the host environment, or a fixed-offset name of the form 'UTC+3', or the strings 'local' or 'utc'. You may also supply an instance of a {@link DateTime#Zone} class.
     * @param {Object} opts - options
     * @param {boolean} [opts.keepLocalTime=false] - If true, adjust the underlying time so that the local time stays the same, but in the target zone. You should rarely need this.
     * @return {DateTime}
     */
    setZone(zone, { keepLocalTime = false, keepCalendarTime = false } = {}) {
      zone = normalizeZone(zone, Settings.defaultZone);
      if (zone.equals(this.zone)) {
        return this;
      } else if (!zone.isValid) {
        return _DateTime.invalid(unsupportedZone(zone));
      } else {
        let newTS = this.ts;
        if (keepLocalTime || keepCalendarTime) {
          const offsetGuess = zone.offset(this.ts);
          const asObj = this.toObject();
          [newTS] = objToTS(asObj, offsetGuess, zone);
        }
        return clone2(this, { ts: newTS, zone });
      }
    }
    /**
     * "Set" the locale, numberingSystem, or outputCalendar. Returns a newly-constructed DateTime.
     * @param {Object} properties - the properties to set
     * @example DateTime.local(2017, 5, 25).reconfigure({ locale: 'en-GB' })
     * @return {DateTime}
     */
    reconfigure({ locale: locale2, numberingSystem, outputCalendar } = {}) {
      const loc = this.loc.clone({ locale: locale2, numberingSystem, outputCalendar });
      return clone2(this, { loc });
    }
    /**
     * "Set" the locale. Returns a newly-constructed DateTime.
     * Just a convenient alias for reconfigure({ locale })
     * @example DateTime.local(2017, 5, 25).setLocale('en-GB')
     * @return {DateTime}
     */
    setLocale(locale2) {
      return this.reconfigure({ locale: locale2 });
    }
    /**
     * "Set" the values of specified units. Returns a newly-constructed DateTime.
     * You can only set units with this method; for "setting" metadata, see {@link DateTime#reconfigure} and {@link DateTime#setZone}.
     *
     * This method also supports setting locale-based week units, i.e. `localWeekday`, `localWeekNumber` and `localWeekYear`.
     * They cannot be mixed with ISO-week units like `weekday`.
     * @param {Object} values - a mapping of units to numbers
     * @example dt.set({ year: 2017 })
     * @example dt.set({ hour: 8, minute: 30 })
     * @example dt.set({ weekday: 5 })
     * @example dt.set({ year: 2005, ordinal: 234 })
     * @return {DateTime}
     */
    set(values) {
      if (!this.isValid) return this;
      const normalized = normalizeObject(values, normalizeUnitWithLocalWeeks);
      const { minDaysInFirstWeek, startOfWeek } = usesLocalWeekValues(normalized, this.loc);
      const settingWeekStuff = !isUndefined(normalized.weekYear) || !isUndefined(normalized.weekNumber) || !isUndefined(normalized.weekday), containsOrdinal = !isUndefined(normalized.ordinal), containsGregorYear = !isUndefined(normalized.year), containsGregorMD = !isUndefined(normalized.month) || !isUndefined(normalized.day), containsGregor = containsGregorYear || containsGregorMD, definiteWeekDef = normalized.weekYear || normalized.weekNumber;
      if ((containsGregor || containsOrdinal) && definiteWeekDef) {
        throw new ConflictingSpecificationError(
          "Can't mix weekYear/weekNumber units with year/month/day or ordinals"
        );
      }
      if (containsGregorMD && containsOrdinal) {
        throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
      }
      let mixed;
      if (settingWeekStuff) {
        mixed = weekToGregorian(
          { ...gregorianToWeek(this.c, minDaysInFirstWeek, startOfWeek), ...normalized },
          minDaysInFirstWeek,
          startOfWeek
        );
      } else if (!isUndefined(normalized.ordinal)) {
        mixed = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...normalized });
      } else {
        mixed = { ...this.toObject(), ...normalized };
        if (isUndefined(normalized.day)) {
          mixed.day = Math.min(daysInMonth(mixed.year, mixed.month), mixed.day);
        }
      }
      const [ts, o] = objToTS(mixed, this.o, this.zone);
      return clone2(this, { ts, o });
    }
    /**
     * Add a period of time to this DateTime and return the resulting DateTime
     *
     * Adding hours, minutes, seconds, or milliseconds increases the timestamp by the right number of milliseconds. Adding days, months, or years shifts the calendar, accounting for DSTs and leap years along the way. Thus, `dt.plus({ hours: 24 })` may result in a different time than `dt.plus({ days: 1 })` if there's a DST shift in between.
     * @param {Duration|Object|number} duration - The amount to add. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     * @example DateTime.now().plus(123) //~> in 123 milliseconds
     * @example DateTime.now().plus({ minutes: 15 }) //~> in 15 minutes
     * @example DateTime.now().plus({ days: 1 }) //~> this time tomorrow
     * @example DateTime.now().plus({ days: -1 }) //~> this time yesterday
     * @example DateTime.now().plus({ hours: 3, minutes: 13 }) //~> in 3 hr, 13 min
     * @example DateTime.now().plus(Duration.fromObject({ hours: 3, minutes: 13 })) //~> in 3 hr, 13 min
     * @return {DateTime}
     */
    plus(duration) {
      if (!this.isValid) return this;
      const dur = Duration.fromDurationLike(duration);
      return clone2(this, adjustTime(this, dur));
    }
    /**
     * Subtract a period of time to this DateTime and return the resulting DateTime
     * See {@link DateTime#plus}
     * @param {Duration|Object|number} duration - The amount to subtract. Either a Luxon Duration, a number of milliseconds, the object argument to Duration.fromObject()
     @return {DateTime}
     */
    minus(duration) {
      if (!this.isValid) return this;
      const dur = Duration.fromDurationLike(duration).negate();
      return clone2(this, adjustTime(this, dur));
    }
    /**
     * "Set" this DateTime to the beginning of a unit of time.
     * @param {string} unit - The unit to go to the beginning of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
     * @example DateTime.local(2014, 3, 3).startOf('month').toISODate(); //=> '2014-03-01'
     * @example DateTime.local(2014, 3, 3).startOf('year').toISODate(); //=> '2014-01-01'
     * @example DateTime.local(2014, 3, 3).startOf('week').toISODate(); //=> '2014-03-03', weeks always start on Mondays
     * @example DateTime.local(2014, 3, 3, 5, 30).startOf('day').toISOTime(); //=> '00:00.000-05:00'
     * @example DateTime.local(2014, 3, 3, 5, 30).startOf('hour').toISOTime(); //=> '05:00:00.000-05:00'
     * @return {DateTime}
     */
    startOf(unit, { useLocaleWeeks = false } = {}) {
      if (!this.isValid) return this;
      const o = {}, normalizedUnit = Duration.normalizeUnit(unit);
      switch (normalizedUnit) {
        case "years":
          o.month = 1;
        case "quarters":
        case "months":
          o.day = 1;
        case "weeks":
        case "days":
          o.hour = 0;
        case "hours":
          o.minute = 0;
        case "minutes":
          o.second = 0;
        case "seconds":
          o.millisecond = 0;
          break;
        case "milliseconds":
          break;
      }
      if (normalizedUnit === "weeks") {
        if (useLocaleWeeks) {
          const startOfWeek = this.loc.getStartOfWeek();
          const { weekday } = this;
          if (weekday < startOfWeek) {
            o.weekNumber = this.weekNumber - 1;
          }
          o.weekday = startOfWeek;
        } else {
          o.weekday = 1;
        }
      }
      if (normalizedUnit === "quarters") {
        const q = Math.ceil(this.month / 3);
        o.month = (q - 1) * 3 + 1;
      }
      return this.set(o);
    }
    /**
     * "Set" this DateTime to the end (meaning the last millisecond) of a unit of time
     * @param {string} unit - The unit to go to the end of. Can be 'year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', or 'millisecond'.
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week
     * @example DateTime.local(2014, 3, 3).endOf('month').toISO(); //=> '2014-03-31T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3).endOf('year').toISO(); //=> '2014-12-31T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3).endOf('week').toISO(); // => '2014-03-09T23:59:59.999-05:00', weeks start on Mondays
     * @example DateTime.local(2014, 3, 3, 5, 30).endOf('day').toISO(); //=> '2014-03-03T23:59:59.999-05:00'
     * @example DateTime.local(2014, 3, 3, 5, 30).endOf('hour').toISO(); //=> '2014-03-03T05:59:59.999-05:00'
     * @return {DateTime}
     */
    endOf(unit, opts) {
      return this.isValid ? this.plus({ [unit]: 1 }).startOf(unit, opts).minus(1) : this;
    }
    // OUTPUT
    /**
     * Returns a string representation of this DateTime formatted according to the specified format string.
     * **You may not want this.** See {@link DateTime#toLocaleString} for a more flexible formatting tool. For a table of tokens and their interpretations, see [here](https://moment.github.io/luxon/#/formatting?id=table-of-tokens).
     * Defaults to en-US if no locale has been specified, regardless of the system's locale.
     * @param {string} fmt - the format string
     * @param {Object} opts - opts to override the configuration options on this DateTime
     * @example DateTime.now().toFormat('yyyy LLL dd') //=> '2017 Apr 22'
     * @example DateTime.now().setLocale('fr').toFormat('yyyy LLL dd') //=> '2017 avr. 22'
     * @example DateTime.now().toFormat('yyyy LLL dd', { locale: "fr" }) //=> '2017 avr. 22'
     * @example DateTime.now().toFormat("HH 'hours and' mm 'minutes'") //=> '20 hours and 55 minutes'
     * @return {string}
     */
    toFormat(fmt, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.redefaultToEN(opts)).formatDateTimeFromString(this, fmt) : INVALID3;
    }
    /**
     * Returns a localized string representing this date. Accepts the same options as the Intl.DateTimeFormat constructor and any presets defined by Luxon, such as `DateTime.DATE_FULL` or `DateTime.TIME_SIMPLE`.
     * The exact behavior of this method is browser-specific, but in general it will return an appropriate representation
     * of the DateTime in the assigned locale.
     * Defaults to the system's locale if no locale has been specified
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
     * @param formatOpts {Object} - Intl.DateTimeFormat constructor options and configuration options
     * @param {Object} opts - opts to override the configuration options on this DateTime
     * @example DateTime.now().toLocaleString(); //=> 4/20/2017
     * @example DateTime.now().setLocale('en-gb').toLocaleString(); //=> '20/04/2017'
     * @example DateTime.now().toLocaleString(DateTime.DATE_FULL); //=> 'April 20, 2017'
     * @example DateTime.now().toLocaleString(DateTime.DATE_FULL, { locale: 'fr' }); //=> '28 août 2022'
     * @example DateTime.now().toLocaleString(DateTime.TIME_SIMPLE); //=> '11:32 AM'
     * @example DateTime.now().toLocaleString(DateTime.DATETIME_SHORT); //=> '4/20/2017, 11:32 AM'
     * @example DateTime.now().toLocaleString({ weekday: 'long', month: 'long', day: '2-digit' }); //=> 'Thursday, April 20'
     * @example DateTime.now().toLocaleString({ weekday: 'short', month: 'short', day: '2-digit', hour: '2-digit', minute: '2-digit' }); //=> 'Thu, Apr 20, 11:27 AM'
     * @example DateTime.now().toLocaleString({ hour: '2-digit', minute: '2-digit', hourCycle: 'h23' }); //=> '11:32'
     * @return {string}
     */
    toLocaleString(formatOpts = DATE_SHORT, opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), formatOpts).formatDateTime(this) : INVALID3;
    }
    /**
     * Returns an array of format "parts", meaning individual tokens along with metadata. This is allows callers to post-process individual sections of the formatted output.
     * Defaults to the system's locale if no locale has been specified
     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat/formatToParts
     * @param opts {Object} - Intl.DateTimeFormat constructor options, same as `toLocaleString`.
     * @example DateTime.now().toLocaleParts(); //=> [
     *                                   //=>   { type: 'day', value: '25' },
     *                                   //=>   { type: 'literal', value: '/' },
     *                                   //=>   { type: 'month', value: '05' },
     *                                   //=>   { type: 'literal', value: '/' },
     *                                   //=>   { type: 'year', value: '1982' }
     *                                   //=> ]
     */
    toLocaleParts(opts = {}) {
      return this.isValid ? Formatter.create(this.loc.clone(opts), opts).formatDateTimeParts(this) : [];
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.extendedZone=false] - add the time zone format extension
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc(1983, 5, 25).toISO() //=> '1982-05-25T00:00:00.000Z'
     * @example DateTime.now().toISO() //=> '2017-04-22T20:47:05.335-04:00'
     * @example DateTime.now().toISO({ includeOffset: false }) //=> '2017-04-22T20:47:05.335'
     * @example DateTime.now().toISO({ format: 'basic' }) //=> '20170422T204705.335-0400'
     * @return {string}
     */
    toISO({
      format: format3 = "extended",
      suppressSeconds = false,
      suppressMilliseconds = false,
      includeOffset = true,
      extendedZone = false
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      const ext = format3 === "extended";
      let c5 = toISODate(this, ext);
      c5 += "T";
      c5 += toISOTime(this, ext, suppressSeconds, suppressMilliseconds, includeOffset, extendedZone);
      return c5;
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's date component
     * @param {Object} opts - options
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc(1982, 5, 25).toISODate() //=> '1982-05-25'
     * @example DateTime.utc(1982, 5, 25).toISODate({ format: 'basic' }) //=> '19820525'
     * @return {string}
     */
    toISODate({ format: format3 = "extended" } = {}) {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, format3 === "extended");
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's week date
     * @example DateTime.utc(1982, 5, 25).toISOWeekDate() //=> '1982-W21-2'
     * @return {string}
     */
    toISOWeekDate() {
      return toTechFormat(this, "kkkk-'W'WW-c");
    }
    /**
     * Returns an ISO 8601-compliant string representation of this DateTime's time component
     * @param {Object} opts - options
     * @param {boolean} [opts.suppressMilliseconds=false] - exclude milliseconds from the format if they're 0
     * @param {boolean} [opts.suppressSeconds=false] - exclude seconds from the format if they're 0
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.extendedZone=true] - add the time zone format extension
     * @param {boolean} [opts.includePrefix=false] - include the `T` prefix
     * @param {string} [opts.format='extended'] - choose between the basic and extended format
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime() //=> '07:34:19.361Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34, seconds: 0, milliseconds: 0 }).toISOTime({ suppressSeconds: true }) //=> '07:34Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ format: 'basic' }) //=> '073419.361Z'
     * @example DateTime.utc().set({ hour: 7, minute: 34 }).toISOTime({ includePrefix: true }) //=> 'T07:34:19.361Z'
     * @return {string}
     */
    toISOTime({
      suppressMilliseconds = false,
      suppressSeconds = false,
      includeOffset = true,
      includePrefix = false,
      extendedZone = false,
      format: format3 = "extended"
    } = {}) {
      if (!this.isValid) {
        return null;
      }
      let c5 = includePrefix ? "T" : "";
      return c5 + toISOTime(
        this,
        format3 === "extended",
        suppressSeconds,
        suppressMilliseconds,
        includeOffset,
        extendedZone
      );
    }
    /**
     * Returns an RFC 2822-compatible string representation of this DateTime
     * @example DateTime.utc(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 +0000'
     * @example DateTime.local(2014, 7, 13).toRFC2822() //=> 'Sun, 13 Jul 2014 00:00:00 -0400'
     * @return {string}
     */
    toRFC2822() {
      return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in HTTP headers. The output is always expressed in GMT.
     * Specifically, the string conforms to RFC 1123.
     * @see https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.3.1
     * @example DateTime.utc(2014, 7, 13).toHTTP() //=> 'Sun, 13 Jul 2014 00:00:00 GMT'
     * @example DateTime.utc(2014, 7, 13, 19).toHTTP() //=> 'Sun, 13 Jul 2014 19:00:00 GMT'
     * @return {string}
     */
    toHTTP() {
      return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL Date
     * @example DateTime.utc(2014, 7, 13).toSQLDate() //=> '2014-07-13'
     * @return {string}
     */
    toSQLDate() {
      if (!this.isValid) {
        return null;
      }
      return toISODate(this, true);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL Time
     * @param {Object} opts - options
     * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
     * @example DateTime.utc().toSQL() //=> '05:15:16.345'
     * @example DateTime.now().toSQL() //=> '05:15:16.345 -04:00'
     * @example DateTime.now().toSQL({ includeOffset: false }) //=> '05:15:16.345'
     * @example DateTime.now().toSQL({ includeZone: false }) //=> '05:15:16.345 America/New_York'
     * @return {string}
     */
    toSQLTime({ includeOffset = true, includeZone = false, includeOffsetSpace = true } = {}) {
      let fmt = "HH:mm:ss.SSS";
      if (includeZone || includeOffset) {
        if (includeOffsetSpace) {
          fmt += " ";
        }
        if (includeZone) {
          fmt += "z";
        } else if (includeOffset) {
          fmt += "ZZ";
        }
      }
      return toTechFormat(this, fmt, true);
    }
    /**
     * Returns a string representation of this DateTime appropriate for use in SQL DateTime
     * @param {Object} opts - options
     * @param {boolean} [opts.includeZone=false] - include the zone, such as 'America/New_York'. Overrides includeOffset.
     * @param {boolean} [opts.includeOffset=true] - include the offset, such as 'Z' or '-04:00'
     * @param {boolean} [opts.includeOffsetSpace=true] - include the space between the time and the offset, such as '05:15:16.345 -04:00'
     * @example DateTime.utc(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 Z'
     * @example DateTime.local(2014, 7, 13).toSQL() //=> '2014-07-13 00:00:00.000 -04:00'
     * @example DateTime.local(2014, 7, 13).toSQL({ includeOffset: false }) //=> '2014-07-13 00:00:00.000'
     * @example DateTime.local(2014, 7, 13).toSQL({ includeZone: true }) //=> '2014-07-13 00:00:00.000 America/New_York'
     * @return {string}
     */
    toSQL(opts = {}) {
      if (!this.isValid) {
        return null;
      }
      return `${this.toSQLDate()} ${this.toSQLTime(opts)}`;
    }
    /**
     * Returns a string representation of this DateTime appropriate for debugging
     * @return {string}
     */
    toString() {
      return this.isValid ? this.toISO() : INVALID3;
    }
    /**
     * Returns a string representation of this DateTime appropriate for the REPL.
     * @return {string}
     */
    [Symbol.for("nodejs.util.inspect.custom")]() {
      if (this.isValid) {
        return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
      } else {
        return `DateTime { Invalid, reason: ${this.invalidReason} }`;
      }
    }
    /**
     * Returns the epoch milliseconds of this DateTime. Alias of {@link DateTime#toMillis}
     * @return {number}
     */
    valueOf() {
      return this.toMillis();
    }
    /**
     * Returns the epoch milliseconds of this DateTime.
     * @return {number}
     */
    toMillis() {
      return this.isValid ? this.ts : NaN;
    }
    /**
     * Returns the epoch seconds of this DateTime.
     * @return {number}
     */
    toSeconds() {
      return this.isValid ? this.ts / 1e3 : NaN;
    }
    /**
     * Returns the epoch seconds (as a whole number) of this DateTime.
     * @return {number}
     */
    toUnixInteger() {
      return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
    }
    /**
     * Returns an ISO 8601 representation of this DateTime appropriate for use in JSON.
     * @return {string}
     */
    toJSON() {
      return this.toISO();
    }
    /**
     * Returns a BSON serializable equivalent to this DateTime.
     * @return {Date}
     */
    toBSON() {
      return this.toJSDate();
    }
    /**
     * Returns a JavaScript object with this DateTime's year, month, day, and so on.
     * @param opts - options for generating the object
     * @param {boolean} [opts.includeConfig=false] - include configuration attributes in the output
     * @example DateTime.now().toObject() //=> { year: 2017, month: 4, day: 22, hour: 20, minute: 49, second: 42, millisecond: 268 }
     * @return {Object}
     */
    toObject(opts = {}) {
      if (!this.isValid) return {};
      const base = { ...this.c };
      if (opts.includeConfig) {
        base.outputCalendar = this.outputCalendar;
        base.numberingSystem = this.loc.numberingSystem;
        base.locale = this.loc.locale;
      }
      return base;
    }
    /**
     * Returns a JavaScript Date equivalent to this DateTime.
     * @return {Date}
     */
    toJSDate() {
      return new Date(this.isValid ? this.ts : NaN);
    }
    // COMPARE
    /**
     * Return the difference between two DateTimes as a Duration.
     * @param {DateTime} otherDateTime - the DateTime to compare this one to
     * @param {string|string[]} [unit=['milliseconds']] - the unit or array of units (such as 'hours' or 'days') to include in the duration.
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @example
     * var i1 = DateTime.fromISO('1982-05-25T09:45'),
     *     i2 = DateTime.fromISO('1983-10-14T10:30');
     * i2.diff(i1).toObject() //=> { milliseconds: 43807500000 }
     * i2.diff(i1, 'hours').toObject() //=> { hours: 12168.75 }
     * i2.diff(i1, ['months', 'days']).toObject() //=> { months: 16, days: 19.03125 }
     * i2.diff(i1, ['months', 'days', 'hours']).toObject() //=> { months: 16, days: 19, hours: 0.75 }
     * @return {Duration}
     */
    diff(otherDateTime, unit = "milliseconds", opts = {}) {
      if (!this.isValid || !otherDateTime.isValid) {
        return Duration.invalid("created by diffing an invalid DateTime");
      }
      const durOpts = { locale: this.locale, numberingSystem: this.numberingSystem, ...opts };
      const units = maybeArray(unit).map(Duration.normalizeUnit), otherIsLater = otherDateTime.valueOf() > this.valueOf(), earlier = otherIsLater ? this : otherDateTime, later = otherIsLater ? otherDateTime : this, diffed = diff_default(earlier, later, units, durOpts);
      return otherIsLater ? diffed.negate() : diffed;
    }
    /**
     * Return the difference between this DateTime and right now.
     * See {@link DateTime#diff}
     * @param {string|string[]} [unit=['milliseconds']] - the unit or units units (such as 'hours' or 'days') to include in the duration
     * @param {Object} opts - options that affect the creation of the Duration
     * @param {string} [opts.conversionAccuracy='casual'] - the conversion system to use
     * @return {Duration}
     */
    diffNow(unit = "milliseconds", opts = {}) {
      return this.diff(_DateTime.now(), unit, opts);
    }
    /**
     * Return an Interval spanning between this DateTime and another DateTime
     * @param {DateTime} otherDateTime - the other end point of the Interval
     * @return {Interval}
     */
    until(otherDateTime) {
      return this.isValid ? Interval.fromDateTimes(this, otherDateTime) : this;
    }
    /**
     * Return whether this DateTime is in the same unit of time as another DateTime.
     * Higher-order units must also be identical for this function to return `true`.
     * Note that time zones are **ignored** in this comparison, which compares the **local** calendar time. Use {@link DateTime#setZone} to convert one of the dates if needed.
     * @param {DateTime} otherDateTime - the other DateTime
     * @param {string} unit - the unit of time to check sameness on
     * @param {Object} opts - options
     * @param {boolean} [opts.useLocaleWeeks=false] - If true, use weeks based on the locale, i.e. use the locale-dependent start of the week; only the locale of this DateTime is used
     * @example DateTime.now().hasSame(otherDT, 'day'); //~> true if otherDT is in the same current calendar day
     * @return {boolean}
     */
    hasSame(otherDateTime, unit, opts) {
      if (!this.isValid) return false;
      const inputMs = otherDateTime.valueOf();
      const adjustedToZone = this.setZone(otherDateTime.zone, { keepLocalTime: true });
      return adjustedToZone.startOf(unit, opts) <= inputMs && inputMs <= adjustedToZone.endOf(unit, opts);
    }
    /**
     * Equality check
     * Two DateTimes are equal if and only if they represent the same millisecond, have the same zone and location, and are both valid.
     * To compare just the millisecond values, use `+dt1 === +dt2`.
     * @param {DateTime} other - the other DateTime
     * @return {boolean}
     */
    equals(other) {
      return this.isValid && other.isValid && this.valueOf() === other.valueOf() && this.zone.equals(other.zone) && this.loc.equals(other.loc);
    }
    /**
     * Returns a string representation of a this time relative to now, such as "in two days". Can only internationalize if your
     * platform supports Intl.RelativeTimeFormat. Rounds down by default.
     * @param {Object} options - options that affect the output
     * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
     * @param {string} [options.style="long"] - the style of units, must be "long", "short", or "narrow"
     * @param {string|string[]} options.unit - use a specific unit or array of units; if omitted, or an array, the method will pick the best unit. Use an array or one of "years", "quarters", "months", "weeks", "days", "hours", "minutes", or "seconds"
     * @param {boolean} [options.round=true] - whether to round the numbers in the output.
     * @param {number} [options.padding=0] - padding in milliseconds. This allows you to round up the result if it fits inside the threshold. Don't use in combination with {round: false} because the decimal output will include the padding.
     * @param {string} options.locale - override the locale of this DateTime
     * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
     * @example DateTime.now().plus({ days: 1 }).toRelative() //=> "in 1 day"
     * @example DateTime.now().setLocale("es").toRelative({ days: 1 }) //=> "dentro de 1 día"
     * @example DateTime.now().plus({ days: 1 }).toRelative({ locale: "fr" }) //=> "dans 23 heures"
     * @example DateTime.now().minus({ days: 2 }).toRelative() //=> "2 days ago"
     * @example DateTime.now().minus({ days: 2 }).toRelative({ unit: "hours" }) //=> "48 hours ago"
     * @example DateTime.now().minus({ hours: 36 }).toRelative({ round: false }) //=> "1.5 days ago"
     */
    toRelative(options = {}) {
      if (!this.isValid) return null;
      const base = options.base || _DateTime.fromObject({}, { zone: this.zone }), padding = options.padding ? this < base ? -options.padding : options.padding : 0;
      let units = ["years", "months", "days", "hours", "minutes", "seconds"];
      let unit = options.unit;
      if (Array.isArray(options.unit)) {
        units = options.unit;
        unit = void 0;
      }
      return diffRelative(base, this.plus(padding), {
        ...options,
        numeric: "always",
        units,
        unit
      });
    }
    /**
     * Returns a string representation of this date relative to today, such as "yesterday" or "next month".
     * Only internationalizes on platforms that supports Intl.RelativeTimeFormat.
     * @param {Object} options - options that affect the output
     * @param {DateTime} [options.base=DateTime.now()] - the DateTime to use as the basis to which this time is compared. Defaults to now.
     * @param {string} options.locale - override the locale of this DateTime
     * @param {string} options.unit - use a specific unit; if omitted, the method will pick the unit. Use one of "years", "quarters", "months", "weeks", or "days"
     * @param {string} options.numberingSystem - override the numberingSystem of this DateTime. The Intl system may choose not to honor this
     * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar() //=> "tomorrow"
     * @example DateTime.now().setLocale("es").plus({ days: 1 }).toRelative() //=> ""mañana"
     * @example DateTime.now().plus({ days: 1 }).toRelativeCalendar({ locale: "fr" }) //=> "demain"
     * @example DateTime.now().minus({ days: 2 }).toRelativeCalendar() //=> "2 days ago"
     */
    toRelativeCalendar(options = {}) {
      if (!this.isValid) return null;
      return diffRelative(options.base || _DateTime.fromObject({}, { zone: this.zone }), this, {
        ...options,
        numeric: "auto",
        units: ["years", "months", "days"],
        calendary: true
      });
    }
    /**
     * Return the min of several date times
     * @param {...DateTime} dateTimes - the DateTimes from which to choose the minimum
     * @return {DateTime} the min DateTime, or undefined if called with no argument
     */
    static min(...dateTimes) {
      if (!dateTimes.every(_DateTime.isDateTime)) {
        throw new InvalidArgumentError("min requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.min);
    }
    /**
     * Return the max of several date times
     * @param {...DateTime} dateTimes - the DateTimes from which to choose the maximum
     * @return {DateTime} the max DateTime, or undefined if called with no argument
     */
    static max(...dateTimes) {
      if (!dateTimes.every(_DateTime.isDateTime)) {
        throw new InvalidArgumentError("max requires all arguments be DateTimes");
      }
      return bestBy(dateTimes, (i) => i.valueOf(), Math.max);
    }
    // MISC
    /**
     * Explain how a string would be parsed by fromFormat()
     * @param {string} text - the string to parse
     * @param {string} fmt - the format the string is expected to be in (see description)
     * @param {Object} options - options taken by fromFormat()
     * @return {Object}
     */
    static fromFormatExplain(text, fmt, options = {}) {
      const { locale: locale2 = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
        locale: locale2,
        numberingSystem,
        defaultToEN: true
      });
      return explainFromTokens(localeToUse, text, fmt);
    }
    /**
     * @deprecated use fromFormatExplain instead
     */
    static fromStringExplain(text, fmt, options = {}) {
      return _DateTime.fromFormatExplain(text, fmt, options);
    }
    /**
     * Build a parser for `fmt` using the given locale. This parser can be passed
     * to {@link DateTime.fromFormatParser} to a parse a date in this format. This
     * can be used to optimize cases where many dates need to be parsed in a
     * specific format.
     *
     * @param {String} fmt - the format the string is expected to be in (see
     * description)
     * @param {Object} options - options used to set locale and numberingSystem
     * for parser
     * @returns {TokenParser} - opaque object to be used
     */
    static buildFormatParser(fmt, options = {}) {
      const { locale: locale2 = null, numberingSystem = null } = options, localeToUse = Locale.fromOpts({
        locale: locale2,
        numberingSystem,
        defaultToEN: true
      });
      return new TokenParser(localeToUse, fmt);
    }
    /**
     * Create a DateTime from an input string and format parser.
     *
     * The format parser must have been created with the same locale as this call.
     *
     * @param {String} text - the string to parse
     * @param {TokenParser} formatParser - parser from {@link DateTime.buildFormatParser}
     * @param {Object} opts - options taken by fromFormat()
     * @returns {DateTime}
     */
    static fromFormatParser(text, formatParser, opts = {}) {
      if (isUndefined(text) || isUndefined(formatParser)) {
        throw new InvalidArgumentError(
          "fromFormatParser requires an input string and a format parser"
        );
      }
      const { locale: locale2 = null, numberingSystem = null } = opts, localeToUse = Locale.fromOpts({
        locale: locale2,
        numberingSystem,
        defaultToEN: true
      });
      if (!localeToUse.equals(formatParser.locale)) {
        throw new InvalidArgumentError(
          `fromFormatParser called with a locale of ${localeToUse}, but the format parser was created for ${formatParser.locale}`
        );
      }
      const { result, zone, specificOffset, invalidReason } = formatParser.explainFromTokens(text);
      if (invalidReason) {
        return _DateTime.invalid(invalidReason);
      } else {
        return parseDataToDateTime(
          result,
          zone,
          opts,
          `format ${formatParser.format}`,
          text,
          specificOffset
        );
      }
    }
    // FORMAT PRESETS
    /**
     * {@link DateTime#toLocaleString} format like 10/14/1983
     * @type {Object}
     */
    static get DATE_SHORT() {
      return DATE_SHORT;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983'
     * @type {Object}
     */
    static get DATE_MED() {
      return DATE_MED;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Fri, Oct 14, 1983'
     * @type {Object}
     */
    static get DATE_MED_WITH_WEEKDAY() {
      return DATE_MED_WITH_WEEKDAY;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983'
     * @type {Object}
     */
    static get DATE_FULL() {
      return DATE_FULL;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Tuesday, October 14, 1983'
     * @type {Object}
     */
    static get DATE_HUGE() {
      return DATE_HUGE;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_SIMPLE() {
      return TIME_SIMPLE;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_SECONDS() {
      return TIME_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_SHORT_OFFSET() {
      return TIME_WITH_SHORT_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get TIME_WITH_LONG_OFFSET() {
      return TIME_WITH_LONG_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_SIMPLE() {
      return TIME_24_SIMPLE;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_SECONDS() {
      return TIME_24_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 EDT', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_SHORT_OFFSET() {
      return TIME_24_WITH_SHORT_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '09:30:23 Eastern Daylight Time', always 24-hour.
     * @type {Object}
     */
    static get TIME_24_WITH_LONG_OFFSET() {
      return TIME_24_WITH_LONG_OFFSET;
    }
    /**
     * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_SHORT() {
      return DATETIME_SHORT;
    }
    /**
     * {@link DateTime#toLocaleString} format like '10/14/1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_SHORT_WITH_SECONDS() {
      return DATETIME_SHORT_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED() {
      return DATETIME_MED;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Oct 14, 1983, 9:30:33 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED_WITH_SECONDS() {
      return DATETIME_MED_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Fri, 14 Oct 1983, 9:30 AM'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_MED_WITH_WEEKDAY() {
      return DATETIME_MED_WITH_WEEKDAY;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_FULL() {
      return DATETIME_FULL;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'October 14, 1983, 9:30:33 AM EDT'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_FULL_WITH_SECONDS() {
      return DATETIME_FULL_WITH_SECONDS;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_HUGE() {
      return DATETIME_HUGE;
    }
    /**
     * {@link DateTime#toLocaleString} format like 'Friday, October 14, 1983, 9:30:33 AM Eastern Daylight Time'. Only 12-hour if the locale is.
     * @type {Object}
     */
    static get DATETIME_HUGE_WITH_SECONDS() {
      return DATETIME_HUGE_WITH_SECONDS;
    }
  };
  function friendlyDateTime(dateTimeish) {
    if (DateTime.isDateTime(dateTimeish)) {
      return dateTimeish;
    } else if (dateTimeish && dateTimeish.valueOf && isNumber(dateTimeish.valueOf())) {
      return DateTime.fromJSDate(dateTimeish);
    } else if (dateTimeish && typeof dateTimeish === "object") {
      return DateTime.fromObject(dateTimeish);
    } else {
      throw new InvalidArgumentError(
        `Unknown datetime argument: ${dateTimeish}, of type ${typeof dateTimeish}`
      );
    }
  }

  // ../../engine/rails_design/app/javascripts/stimulus_com/slide.js
  var slide_default = class extends touch_default {
    static values = {
      delay: { type: Number, default: 0 }
      // 是否循环播放，延迟时间，单位为秒
    };
    static targets = ["container", "dot"];
    connect() {
      this.element.addEventListener("touchstart", (event) => {
        this.start(event);
      }, { passive: true });
      this.element.addEventListener("dragstart", (event) => {
        this.start(event);
      });
      const ele = this.containerTarget.firstElementChild;
      ele.classList.add("is-active");
      if (this.containerTarget.childElementCount > 1 && this.hasDelayValue && this.delayValue > 0) {
        ele.style.left = 0;
        this.mode(ele);
      }
    }
    mode(ele) {
      const next = this.next(ele);
      next.style.left = this.containerTarget.clientWidth + "px";
      this.timerId = setTimeout(() => {
        this.direction = "left";
        this.shiftLeft(ele);
        console.debug("Time:", DateTime.now().toFormat("TT"), "Timer Id:", this.timerId);
      }, this.delayValue * 1e3, ele);
    }
    start(event) {
      if (this.containerTarget.childElementCount <= 1) {
        return;
      }
      this.initStatus(event);
      if (this.timerId) {
        clearTimeout(this.timerId);
      }
      const ele = event.target.closest("[data-index]");
      this.left = ele.offsetLeft;
      ele.style.left = this.left + "px";
      ele.classList.remove("transition");
      if (this.direction === "left") {
        const next = this.next(ele);
        if (next) {
          next.style.left = this.containerTarget.clientWidth + this.left + "px";
          next.classList.remove("transition");
        }
      } else if (this.direction === "right") {
        const prev = this.prev(ele);
        if (prev) {
          prev.style.left = this.left - this.containerTarget.clientWidth + "px";
          prev.classList.remove("transition");
        }
      }
      ele.removeEventListener("transitioncancel", this.beenCurrentAfter);
      ele.removeEventListener("transitionend", this.beenCurrentAfter);
    }
    // data-action="touchmove->slide#move:passive"
    // data-action="onmousemove->slide"
    move(event) {
      event.stopPropagation();
      const ele = event.currentTarget;
      console.debug("moved by element:", ele.dataset.index);
      if (this.zoomed(event) || this.containerTarget.childElementCount <= 1) {
        return;
      }
      const offset3 = this.offset(event);
      const pad3 = Math.abs(offset3.x);
      if (!this.isHorizontal(pad3, offset3)) {
        return;
      }
      ele.style.left = this.left + offset3.x + "px";
      let along;
      if (offset3.x < 0) {
        along = this.next(ele);
        if (along) {
          if (this.direction === "left") {
            along.style.left = this.containerTarget.clientWidth + this.left + offset3.x + "px";
          } else if (this.direction === "right") {
            along.style.left = this.containerTarget.clientWidth + this.left + offset3.x + "px";
          } else {
            along.style.left = this.containerTarget.clientWidth + this.left + offset3.x + "px";
          }
        }
      } else if (offset3.x > 0) {
        along = this.prev(ele);
        if (along) {
          if (this.direction === "left") {
            along.style.left = this.containerTarget.clientWidth + this.left + offset3.x + "px";
          } else if (this.direction === "right") {
            along.style.left = -this.containerTarget.clientWidth + this.left + offset3.x + "px";
          } else {
            along.style.left = -this.containerTarget.clientWidth + this.left + offset3.x + "px";
          }
        }
      }
      if (along) {
        along.classList.add("is-active");
      }
    }
    // data-action="touchend->slide#end:passive"
    end(event) {
      if (this.zoomed(event) || this.containerTarget.childElementCount <= 1) {
        return;
      }
      const ele = event.currentTarget;
      const offset3 = this.offset(event);
      const pad3 = Math.abs(offset3.x);
      if (!this.isHorizontal(pad3, offset3)) {
        console.debug("not scrolling", offset3);
        this.rollback(offset3, ele);
      } else {
        if (this.effective(pad3)) {
          this.going(offset3, ele);
        } else {
          if (this.direction === "left") {
            this.shiftLeft(ele);
          } else if (this.direction === "right") {
            this.shiftRight(ele);
          } else {
            this.rollback(offset3, ele);
          }
        }
      }
    }
    // 执行翻页
    going(offset3, ele) {
      if (offset3.x < 0) {
        this.direction = "left";
        this.shiftLeft(ele);
      }
      if (offset3.x > 0) {
        if (this.direction === "left") {
          this.direction = "right";
          this.shiftRight(this.next(ele), ele);
        } else {
          this.direction = "right";
          this.shiftRight(ele);
        }
      }
    }
    // 回退到之前的状态
    rollback(offset3, ele) {
      const next = this.next(ele);
      if (offset3.x < 0 && next) {
        this.shiftRight(next);
      }
      const prev = this.prev(ele);
      if (offset3.x > 0 && prev) {
        this.shiftLeft(prev);
      }
    }
    // ele 向左滑出
    shiftLeft(left2, right2 = this.next(left2)) {
      if (right2) {
        left2.classList.add("transition");
        this.beenCurrent(left2);
        right2.classList.add("transition");
        this.toCurrent(right2);
      } else {
        left2.classList.add("transition");
        this.toCurrent(left2);
      }
    }
    // ele 向右滑出
    shiftRight(right2, left2 = this.prev(right2)) {
      if (left2) {
        left2.classList.add("transition");
        this.toCurrent(left2);
        right2.classList.add("transition");
        this.beenCurrent(right2, this.containerTarget.clientWidth + "px");
      } else {
        right2.classList.add("transition");
        this.toCurrent(right2);
      }
    }
    // 不再展示
    beenCurrent(ele, left2 = -this.containerTarget.clientWidth + "px") {
      console.debug("add transition event beenCurrentAfter for been", ele.dataset.index);
      ele.style.left = left2;
      if (this.hasDotTarget) {
        const dot8 = this.dotTarget.children[ele.dataset.index];
        dot8.classList.replace("has-text-white", "has-text-black");
      }
      ele.addEventListener("transitionend", this.beenCurrentAfter, { once: true });
      ele.addEventListener("transitioncancel", this.beenCurrentAfter, { once: true });
    }
    // this become event.target
    beenCurrentAfter(event) {
      const ele = event.currentTarget;
      console.debug(ele.dataset.index, "been Current After", event.type);
      ele.classList.remove("is-active");
      const controller = ele.closest("[data-controller~=slide]").getController("slide");
      controller.direction = null;
      if (!controller) {
        return;
      }
      if (event.type === "transitionend") {
        ele.classList.remove("transition");
        ele.removeEventListener("transitioncancel", controller.beenCurrentAfter);
      } else if (event.type === "transitioncancel") {
        ele.removeEventListener("transitionend", controller.beenCurrentAfter);
      }
    }
    // 即将展示
    toCurrent(ele) {
      ele.classList.add("is-active");
      ele.style.left = 0;
      if (this.hasDotTarget) {
        const dot8 = this.dotTarget.children[ele.dataset.index];
        dot8.classList.replace("has-text-black", "has-text-white");
      }
      console.debug("add transition event toCurrentAfter for to", ele.dataset.index);
      ele.addEventListener("transitionend", this.toCurrentAfter, { once: true });
      ele.addEventListener("transitioncancel", this.toCurrentAfter, { once: true });
    }
    toCurrentAfter(event) {
      const ele = event.currentTarget;
      console.debug(ele.dataset.index, "to Current after", event.type);
      const controller = ele.closest("[data-controller~=slide]").getController("slide");
      controller.direction = null;
      if (!controller) {
        return;
      }
      if (event.type === "transitionend") {
        ele.classList.remove("transition");
        if (controller.hasDelayValue && controller.delayValue > 0) {
          controller.mode(ele);
        }
        ele.removeEventListener("transitioncancel", controller.toCurrentAfter);
      } else if (event.type === "transitioncancel") {
        ele.removeEventListener("transitionend", controller.toCurrentAfter);
      }
    }
    next(ele) {
      if (this.hasDelayValue) {
        return ele.nextElementSibling || this.containerTarget.firstElementChild;
      } else {
        return ele.nextElementSibling;
      }
    }
    prev(ele) {
      if (this.hasDelayValue) {
        return ele.previousElementSibling || this.containerTarget.lastElementChild;
      } else {
        return ele.previousElementSibling;
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/slide_y.js
  var slide_y_default = class extends slide_default {
    connect() {
      super.connect();
    }
    // data-action="touchmove->slide-y#move:passive"
    move(event) {
      const ele = event.currentTarget;
      console.debug("touch moved by:", ele.dataset.index);
      if (this.zoomed(event)) {
        console.error("scale");
        return;
      }
      let offset3 = this.offset(event);
      let pad_y = Math.abs(offset3.y);
      let isScrolling = pad_y > Math.abs(offset3.x) ? 1 : 0;
      if (isScrolling === 0) {
        return;
      }
      if (offset3.y < 0) {
        let next = ele.nextElementSibling;
        if (next) {
          this.slidingToTop(ele, next, pad_y);
        }
      } else if (offset3.y > 0) {
        let prev = ele.previousElementSibling;
        if (prev) {
          this.slidingToBottom(ele, prev, pad_y);
        }
      }
    }
    // data-action="touchend->slide-y#end:passive"
    end(event) {
      if (this.zoomed(event)) {
        return;
      }
      let ele = event.currentTarget;
      let offset3 = this.offset(event);
      let pad_y = Math.abs(offset3.y);
      let isScrolling = pad_y > Math.abs(offset3.x) ? 1 : 0;
      if (isScrolling === 0) {
        console.debug("not scrolling");
        this.rollback(offset3, ele);
      }
      if (this.effective(pad_y, false)) {
        this.going(offset3, ele);
      } else {
        this.rollback(offset3, ele);
      }
    }
    // 执行翻页
    going(offset3, ele) {
      const next = ele.nextElementSibling;
      const prev = ele.previousElementSibling;
      if (offset3.y < 0 && next) {
        this.closeToTop(next);
        next.style.zIndex = 0;
        this.toCurrent(next);
        this.awayFromBottom(ele);
        ele.style.zIndex = -1;
        this.beenCurrent(ele);
      }
      if (offset3.y > 0 && prev) {
        this.closeToBottom(prev);
        prev.style.zIndex = 0;
        this.toCurrent(prev);
        this.awayFromTop(ele);
        ele.style.zIndex = -1;
        this.beenCurrent(ele);
      }
    }
    // 回退到之前的状态
    rollback(offset3, ele) {
      const next = ele.nextElementSibling;
      const prev = ele.previousElementSibling;
      if (offset3.y < 0 && next) {
        this.closeToBottom(ele);
        this.toCurrent(ele);
        this.awayFromTop(next);
        this.beenCurrent(next);
      }
      if (offset3.y > 0 && prev) {
        this.closeToTop(ele);
        this.toCurrent(ele);
        this.awayFromBottom(prev);
        this.beenCurrent(prev);
      }
    }
    // 上滑
    slidingToTop(ele, next, pad3) {
      ele.style.bottom = pad3 + "px";
      next.style.zIndex = -1;
      next.style.top = this.element.clientHeight - pad3 + "px";
    }
    // 下滑
    slidingToBottom(ele, prev, pad3) {
      ele.style.top = pad3 + "px";
      prev.style.zIndex = -1;
      prev.style.bottom = this.element.clientHeight - pad3 + "px";
    }
    // xx
    resetIndex(event) {
      ["top", "bottom", "transition-property", "transition-duration"].forEach((rule) => {
        event.currentTarget.style.removeProperty(rule);
      });
      event.currentTarget.style.zIndex = -2;
    }
    // 不再展示
    beenCurrent(ele) {
      console.debug("add transition event listener for been", ele.dataset.index);
      ele.addEventListener("transitionend", this.resetIndex, { once: true });
      ele.addEventListener("transitioncancel", (event) => {
        this.resetIndex(event);
        ele.removeEventListener("transitionend", this.resetIndex);
      }, { once: true });
    }
    // 即将展示
    toCurrent(ele) {
      console.debug("add transition event listener for to", ele.dataset.index);
      ele.addEventListener("transitionend", (event) => {
        this.clearStyle(event.currentTarget);
      }, { once: true });
      ele.addEventListener("transitioncancel", (event) => {
        this.clearStyle(event.currentTarget);
      }, { once: true });
    }
    // 接近上侧
    closeToTop(ele) {
      ele.style.top = 0;
      ele.style.transitionProperty = "top";
      ele.style.transitionDuration = this.duration;
    }
    // 接近下侧
    closeToBottom(ele) {
      ele.style.bottom = 0;
      ele.style.transitionProperty = "bottom";
      ele.style.transitionDuration = this.duration;
    }
    // 远离下侧
    awayFromBottom(ele) {
      ele.style.bottom = this.element.clientHeight + "px";
      ele.style.transitionProperty = "bottom";
      ele.style.transitionDuration = this.duration;
    }
    // 远离上侧
    awayFromTop(ele) {
      ele.style.top = this.element.clientHeight + "px";
      ele.style.transitionProperty = "top";
      ele.style.transitionDuration = this.duration;
    }
    clearStyle(ele) {
      ["top", "bottom", "transition-property", "transition-duration"].forEach((rule) => {
        ele.style.removeProperty(rule);
      });
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/sticky-bottom.js
  var sticky_bottom_default = class extends Controller {
    static targets = ["order", "children"];
    static values = {
      threshold: { type: Number, default: 0.35 },
      delay: { type: Number, default: 0.2 }
    };
    connect() {
      this.observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((el) => {
            console.debug("--------", el.intersectionRatio);
            el.target.classList.toggle("is-active", el.intersectionRatio < 1);
          });
        },
        {
          threshold: 1,
          root: this.element.parentNode
        }
      );
      this.observer.observe(this.element);
    }
    disconnect() {
      this.observer.disconnect();
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/swipe.js
  var swipe_default = class extends touch_default {
    static targets = ["open"];
    // data-action="touchstart->swipe#start:passive"
    start(event) {
      this.initStatus(event);
      this.barWidth = this.element.clientWidth;
      this.swiperWidth = this.openTarget.clientWidth;
    }
    // data-action="touchmove->swipe#move touchstart->swipe#move"
    move(event) {
      if (this.zoomed(event)) {
        return;
      }
      const offset3 = this.offset(event);
      const pad3 = Math.abs(offset3.x);
      const isScrolling = pad3 > Math.abs(offset3.y) ? 1 : 0;
      if (isScrolling === 0) {
        return;
      }
      if (offset3.x < 0) {
        this.openTarget.style.width = `${this.swiperWidth + pad3}px`;
        let styles = {
          width: `${this.barWidth - this.swiperWidth + this.openTarget.clientWidth}px`,
          left: `-${this.openTarget.clientWidth}px`
        };
        Object.assign(this.element.style, styles);
      } else if (offset3.x > 0) {
        let x3 = pad3 < this.swiperWidth ? this.swiperWidth - pad3 : 0;
        this.openTarget.style.width = `${x3}px`;
        let styles = {
          width: `${this.barWidth - (pad3 < this.swiperWidth ? pad3 : this.swiperWidth)}px`,
          left: `-${x3}px`
        };
        Object.assign(this.element.style, styles);
      }
    }
    end(event) {
      this.openTarget.style.width = `${this.openTarget.clientWidth}px`;
    }
    get leftPos() {
      let left2 = this.element.style.left.replace(/px$/, "");
      return parseFloat(left2);
    }
    get barWidth() {
      return parseFloat(this.data.get("barWidth"));
    }
    set barWidth(value2) {
      this.data.set("barWidth", value2);
    }
    get swiperWidth() {
      return parseFloat(this.data.get("swiperWidth"));
    }
    set swiperWidth(value2) {
      this.data.set("swiperWidth", value2);
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/switch.js
  var switch_default = class extends Controller {
    static targets = ["src"];
    toggle(event) {
      this.srcTargets.forEach((el) => {
        el.classList.toggle("display-none");
      });
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/time.js
  window.DateTime = DateTime;
  var time_default = class extends Controller {
    static values = {
      localized: Boolean
    };
    connect() {
      this.parse();
    }
    parse() {
      if (this.localizedValue) {
        return;
      }
      if (this.str) {
        const time = DateTime.fromISO(this.str);
        this.element.innerText = time.toFormat(this.format);
        this.localizedValue = true;
      }
    }
    get str() {
      const value2 = this.element.dataset["value"];
      if (value2) {
        return value2;
      } else if (this.element.innerText.length > 0) {
        return this.element.innerText;
      }
    }
    // xx => 'yyyy-MM-dd HH:mm:ss'
    get format() {
      let fmt = this.element.dataset["format"];
      if (fmt === "human") {
        return "yyyy-MM-dd HH:mm:ss";
      } else {
        return fmt || "yyyy-MM-dd HH:mm";
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/time-count.js
  window.Duration = Duration;
  var time_count_default = class extends Controller {
    static values = {
      time: String,
      diff: { type: Array, default: ["years", "months", "days", "hours", "minutes", "seconds"] }
    };
    connect() {
      this.count();
    }
    count() {
      const time = DateTime.fromISO(this.timeValue);
      const now4 = DateTime.now();
      let result;
      if (time > now4) {
        result = time.diff(now4, this.diffValue);
      } else {
        result = now4.diff(time, this.diffValue);
      }
      let format3 = ["y\u5E74", "M\u6708", "d\u5929", "h\u65F6", "mm\u5206", "ss\u79D2"];
      let result_format;
      const timer2 = setInterval(() => {
        let step2;
        if (result > 0) {
          step2 = 1;
        } else {
          step2 = -1;
        }
        result = result.plus({ seconds: step2 });
        for (const [index4, value2] of Object.values(result.values).entries()) {
          if (value2 > 0) {
            result_format = format3.slice(index4);
            break;
          }
        }
        if (result <= 0) {
          this.element.textContent = result.toFormat(result_format.join(""));
          clearInterval(timer2);
        } else {
          this.element.textContent = result.toFormat(result_format.join(""));
        }
      }, 1e3, result);
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/tree.js
  var tree_default = class extends Controller {
    static targets = ["item"];
    collapse(event) {
      const ele = event.currentTarget;
      const par = this.itemTarget;
      let el = par.nextElementSibling;
      while (el && el.dataset["depth"] !== par.dataset["depth"] && par.dataset["depth"].endsWith(el.dataset["depth"])) {
        el.style.display = "none";
        el = el.nextElementSibling;
      }
      ele.classList.replace("fa-caret-down", "fa-caret-right");
      ele.dataset["action"] = "click->tree#expand";
    }
    expand(event) {
      const ele = event.currentTarget;
      const par = this.itemTarget;
      let el = par.nextElementSibling;
      while (el && el.dataset["depth"] !== par.dataset["depth"] && par.dataset["depth"].endsWith(el.dataset["depth"])) {
        el.style.display = "table-row";
        el = el.nextElementSibling;
      }
      ele.classList.replace("fa-caret-right", "fa-caret-down");
      ele.dataset["action"] = "click->tree#collapse";
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/tree_remote.js
  var tree_remote_default = class extends Controller {
    static targets = ["item", "checkbox"];
    static values = {
      hide: Boolean
    };
    connect() {
      if (this.hideValue) {
        this.collapseDirect();
      }
    }
    collapseDirect() {
      let el = this.element.nextElementSibling;
      while (el && el.id.startsWith(this.element.id)) {
        let to_remove = el;
        el = el.nextElementSibling;
        to_remove.remove();
      }
    }
    collapseCheckbox() {
      this.checkboxTargets.forEach((el) => {
        if (el.elements["expand"]) {
          el.elements["expand"].value = null;
        }
      });
    }
    collapse(event) {
      const ele = event.currentTarget;
      const par = this.itemTarget;
      ele.parentNode.addEventListener("click", this.disableLink);
      let el = par.nextElementSibling;
      while (el && el.id.startsWith(par.id)) {
        let to_remove = el;
        el = el.nextElementSibling;
        to_remove.remove();
      }
      this.collapseCheckbox();
      ele.classList.replace("fa-caret-down", "fa-caret-right");
      ele.dataset["action"] = "click->tree-remote#expand";
    }
    expand(event) {
      const ele = event.currentTarget;
      ele.parentNode.removeEventListener("click", this.disableLink);
      ele.classList.replace("fa-caret-right", "fa-caret-down");
      ele.dataset["action"] = "click->tree-remote#collapse";
    }
    disableLink(event) {
      event.stopPropagation();
      event.preventDefault();
      return false;
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/video.js
  var video_default = class extends audio_player_default {
    connect() {
      if (["VIDEO", "AUDIO"].includes(this.element.tagName) && this.element.autoplay) {
        if (this.element.played.length === 0) {
          this.element.play();
        }
      } else {
        this.element.querySelectorAll("audio[autoplay=autoplay], video[autoplay=autoplay]").forEach((el) => {
          if (el.played.length === 0) {
            el.play();
          }
        });
      }
    }
    disconnect() {
      super.disconnect();
      if (["VIDEO", "AUDIO"].includes(this.element.tagName)) {
        this.element.remove();
      } else {
        this.element.querySelectorAll("audio, video").forEach((el) => el.remove());
      }
    }
    enableLink(event) {
      const ele = event.currentTarget.closest("a[disabled=disabled]");
      if (ele) {
        ele.removeAttribute("disabled");
      }
    }
    playNext(event) {
      let ele = event.currentTarget;
      console.debug(ele);
      const controller = ele.closest("[data-controller~=video]").getController("video");
      controller.playAnd(ele);
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/visit.js
  var visit_default = class extends base_controller_default {
    static values = {
      url: String,
      frame: String,
      reload: Boolean,
      method: String,
      params: Object,
      headers: { type: Object, default: {} }
    };
    connect() {
      if (this.hasFrameValue) {
        this.visit();
      } else if (this.hasMethodValue && this.methodValue && this.methodValue.toUpperCase() !== "GET") {
        this.request(
          this.urlValue,
          this.methodValue,
          JSON.stringify(this.paramsValue),
          { "Content-Type": "application/json", "X-CSRF-Token": this.csrfToken(), ...this.headersValue }
        );
      } else {
        this.addEvent(this.headersValue);
        this.topVisit();
      }
      if (this.hasReloadValue && this.reloadValue) {
        this.replaceAction();
      }
      document.documentElement.classList.remove("is-clipped");
      this.element.remove();
    }
    addEvent(headers) {
      document.addEventListener("turbo:before-fetch-request", (event) => {
        const xhr = event.detail.fetchOptions;
        Object.assign(xhr.headers, headers);
      }, { once: true });
    }
    topVisit() {
      if (this.hasUrlValue) {
        Turbo.visit(this.urlValue, { action: "replace" });
      } else {
        Turbo.visit(location.href, { action: "replace" });
      }
    }
    visit() {
      this.modal.visit(this.urlValue);
    }
    replaceAction() {
      this.modalWrapper.querySelectorAll('[data-action$="modal#close"]').forEach((ele) => {
        ele.dataset.replace("action", "modal#close", "modal#reloadClose");
      });
    }
    get modal() {
      return document.getElementById(this.frameValue).delegate;
    }
    get modalWrapper() {
      return document.getElementById("modal_wrapper");
    }
  };

  // ../../engine/rails_design/node_modules/sortablejs/modular/sortable.esm.js
  function ownKeys(object, enumerableOnly) {
    var keys2 = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _defineProperty(obj, key, value2) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value2,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value2;
    }
    return obj;
  }
  function _extends() {
    _extends = Object.assign || function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  var version = "1.15.2";
  function userAgent(pattern) {
    if (typeof window !== "undefined" && window.navigator) {
      return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
    }
  }
  var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
  var Edge = userAgent(/Edge/i);
  var FireFox = userAgent(/firefox/i);
  var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
  var IOS = userAgent(/iP(ad|od|hone)/i);
  var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
  var captureMode = {
    capture: false,
    passive: false
  };
  function on(el, event, fn) {
    el.addEventListener(event, fn, !IE11OrLess && captureMode);
  }
  function off(el, event, fn) {
    el.removeEventListener(event, fn, !IE11OrLess && captureMode);
  }
  function matches(el, selector) {
    if (!selector) return;
    selector[0] === ">" && (selector = selector.substring(1));
    if (el) {
      try {
        if (el.matches) {
          return el.matches(selector);
        } else if (el.msMatchesSelector) {
          return el.msMatchesSelector(selector);
        } else if (el.webkitMatchesSelector) {
          return el.webkitMatchesSelector(selector);
        }
      } catch (_2) {
        return false;
      }
    }
    return false;
  }
  function getParentOrHost(el) {
    return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
  }
  function closest(el, selector, ctx2, includeCTX) {
    if (el) {
      ctx2 = ctx2 || document;
      do {
        if (selector != null && (selector[0] === ">" ? el.parentNode === ctx2 && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx2) {
          return el;
        }
        if (el === ctx2) break;
      } while (el = getParentOrHost(el));
    }
    return null;
  }
  var R_SPACE = /\s+/g;
  function toggleClass(el, name2, state) {
    if (el && name2) {
      if (el.classList) {
        el.classList[state ? "add" : "remove"](name2);
      } else {
        var className2 = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name2 + " ", " ");
        el.className = (className2 + (state ? " " + name2 : "")).replace(R_SPACE, " ");
      }
    }
  }
  function css(el, prop, val) {
    var style = el && el.style;
    if (style) {
      if (val === void 0) {
        if (document.defaultView && document.defaultView.getComputedStyle) {
          val = document.defaultView.getComputedStyle(el, "");
        } else if (el.currentStyle) {
          val = el.currentStyle;
        }
        return prop === void 0 ? val : val[prop];
      } else {
        if (!(prop in style) && prop.indexOf("webkit") === -1) {
          prop = "-webkit-" + prop;
        }
        style[prop] = val + (typeof val === "string" ? "" : "px");
      }
    }
  }
  function matrix(el, selfOnly) {
    var appliedTransforms = "";
    if (typeof el === "string") {
      appliedTransforms = el;
    } else {
      do {
        var transform = css(el, "transform");
        if (transform && transform !== "none") {
          appliedTransforms = transform + " " + appliedTransforms;
        }
      } while (!selfOnly && (el = el.parentNode));
    }
    var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
    return matrixFn && new matrixFn(appliedTransforms);
  }
  function find(ctx2, tagName, iterator) {
    if (ctx2) {
      var list = ctx2.getElementsByTagName(tagName), i = 0, n2 = list.length;
      if (iterator) {
        for (; i < n2; i++) {
          iterator(list[i], i);
        }
      }
      return list;
    }
    return [];
  }
  function getWindowScrollingElement() {
    var scrollingElement = document.scrollingElement;
    if (scrollingElement) {
      return scrollingElement;
    } else {
      return document.documentElement;
    }
  }
  function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
    if (!el.getBoundingClientRect && el !== window) return;
    var elRect, top, left2, bottom, right2, height, width;
    if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
      elRect = el.getBoundingClientRect();
      top = elRect.top;
      left2 = elRect.left;
      bottom = elRect.bottom;
      right2 = elRect.right;
      height = elRect.height;
      width = elRect.width;
    } else {
      top = 0;
      left2 = 0;
      bottom = window.innerHeight;
      right2 = window.innerWidth;
      height = window.innerHeight;
      width = window.innerWidth;
    }
    if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
      container = container || el.parentNode;
      if (!IE11OrLess) {
        do {
          if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
            var containerRect = container.getBoundingClientRect();
            top -= containerRect.top + parseInt(css(container, "border-top-width"));
            left2 -= containerRect.left + parseInt(css(container, "border-left-width"));
            bottom = top + elRect.height;
            right2 = left2 + elRect.width;
            break;
          }
        } while (container = container.parentNode);
      }
    }
    if (undoScale && el !== window) {
      var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
      if (elMatrix) {
        top /= scaleY;
        left2 /= scaleX;
        width /= scaleX;
        height /= scaleY;
        bottom = top + height;
        right2 = left2 + width;
      }
    }
    return {
      top,
      left: left2,
      bottom,
      right: right2,
      width,
      height
    };
  }
  function isScrolledPast(el, elSide, parentSide) {
    var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
    while (parent) {
      var parentSideVal = getRect(parent)[parentSide], visible = void 0;
      if (parentSide === "top" || parentSide === "left") {
        visible = elSideVal >= parentSideVal;
      } else {
        visible = elSideVal <= parentSideVal;
      }
      if (!visible) return parent;
      if (parent === getWindowScrollingElement()) break;
      parent = getParentAutoScrollElement(parent, false);
    }
    return false;
  }
  function getChild(el, childNum, options, includeDragEl) {
    var currentChild = 0, i = 0, children = el.children;
    while (i < children.length) {
      if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
        if (currentChild === childNum) {
          return children[i];
        }
        currentChild++;
      }
      i++;
    }
    return null;
  }
  function lastChild(el, selector) {
    var last4 = el.lastElementChild;
    while (last4 && (last4 === Sortable.ghost || css(last4, "display") === "none" || selector && !matches(last4, selector))) {
      last4 = last4.previousElementSibling;
    }
    return last4 || null;
  }
  function index(el, selector) {
    var index4 = 0;
    if (!el || !el.parentNode) {
      return -1;
    }
    while (el = el.previousElementSibling) {
      if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
        index4++;
      }
    }
    return index4;
  }
  function getRelativeScrollOffset(el) {
    var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
    if (el) {
      do {
        var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
        offsetLeft += el.scrollLeft * scaleX;
        offsetTop += el.scrollTop * scaleY;
      } while (el !== winScroller && (el = el.parentNode));
    }
    return [offsetLeft, offsetTop];
  }
  function indexOfObject(arr, obj) {
    for (var i in arr) {
      if (!arr.hasOwnProperty(i)) continue;
      for (var key in obj) {
        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
      }
    }
    return -1;
  }
  function getParentAutoScrollElement(el, includeSelf) {
    if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
    var elem = el;
    var gotSelf = false;
    do {
      if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
        var elemCSS = css(elem);
        if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
          if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
          if (gotSelf || includeSelf) return elem;
          gotSelf = true;
        }
      }
    } while (elem = elem.parentNode);
    return getWindowScrollingElement();
  }
  function extend3(dst, src) {
    if (dst && src) {
      for (var key in src) {
        if (src.hasOwnProperty(key)) {
          dst[key] = src[key];
        }
      }
    }
    return dst;
  }
  function isRectEqual(rect1, rect22) {
    return Math.round(rect1.top) === Math.round(rect22.top) && Math.round(rect1.left) === Math.round(rect22.left) && Math.round(rect1.height) === Math.round(rect22.height) && Math.round(rect1.width) === Math.round(rect22.width);
  }
  var _throttleTimeout;
  function throttle(callback, ms) {
    return function() {
      if (!_throttleTimeout) {
        var args = arguments, _this = this;
        if (args.length === 1) {
          callback.call(_this, args[0]);
        } else {
          callback.apply(_this, args);
        }
        _throttleTimeout = setTimeout(function() {
          _throttleTimeout = void 0;
        }, ms);
      }
    };
  }
  function cancelThrottle() {
    clearTimeout(_throttleTimeout);
    _throttleTimeout = void 0;
  }
  function scrollBy(el, x3, y3) {
    el.scrollLeft += x3;
    el.scrollTop += y3;
  }
  function clone3(el) {
    var Polymer = window.Polymer;
    var $ = window.jQuery || window.Zepto;
    if (Polymer && Polymer.dom) {
      return Polymer.dom(el).cloneNode(true);
    } else if ($) {
      return $(el).clone(true)[0];
    } else {
      return el.cloneNode(true);
    }
  }
  function getChildContainingRectFromElement(container, options, ghostEl2) {
    var rect4 = {};
    Array.from(container.children).forEach(function(child) {
      var _rect$left, _rect$top, _rect$right, _rect$bottom;
      if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl2) return;
      var childRect = getRect(child);
      rect4.left = Math.min((_rect$left = rect4.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
      rect4.top = Math.min((_rect$top = rect4.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
      rect4.right = Math.max((_rect$right = rect4.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
      rect4.bottom = Math.max((_rect$bottom = rect4.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
    });
    rect4.width = rect4.right - rect4.left;
    rect4.height = rect4.bottom - rect4.top;
    rect4.x = rect4.left;
    rect4.y = rect4.top;
    return rect4;
  }
  var expando = "Sortable" + (/* @__PURE__ */ new Date()).getTime();
  function AnimationStateManager() {
    var animationStates = [], animationCallbackId;
    return {
      captureAnimationState: function captureAnimationState() {
        animationStates = [];
        if (!this.options.animation) return;
        var children = [].slice.call(this.el.children);
        children.forEach(function(child) {
          if (css(child, "display") === "none" || child === Sortable.ghost) return;
          animationStates.push({
            target: child,
            rect: getRect(child)
          });
          var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
          if (child.thisAnimationDuration) {
            var childMatrix = matrix(child, true);
            if (childMatrix) {
              fromRect.top -= childMatrix.f;
              fromRect.left -= childMatrix.e;
            }
          }
          child.fromRect = fromRect;
        });
      },
      addAnimationState: function addAnimationState(state) {
        animationStates.push(state);
      },
      removeAnimationState: function removeAnimationState(target) {
        animationStates.splice(indexOfObject(animationStates, {
          target
        }), 1);
      },
      animateAll: function animateAll(callback) {
        var _this = this;
        if (!this.options.animation) {
          clearTimeout(animationCallbackId);
          if (typeof callback === "function") callback();
          return;
        }
        var animating = false, animationTime = 0;
        animationStates.forEach(function(state) {
          var time = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
          if (targetMatrix) {
            toRect.top -= targetMatrix.f;
            toRect.left -= targetMatrix.e;
          }
          target.toRect = toRect;
          if (target.thisAnimationDuration) {
            if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && // Make sure animatingRect is on line between toRect & fromRect
            (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
              time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
            }
          }
          if (!isRectEqual(toRect, fromRect)) {
            target.prevFromRect = fromRect;
            target.prevToRect = toRect;
            if (!time) {
              time = _this.options.animation;
            }
            _this.animate(target, animatingRect, toRect, time);
          }
          if (time) {
            animating = true;
            animationTime = Math.max(animationTime, time);
            clearTimeout(target.animationResetTimer);
            target.animationResetTimer = setTimeout(function() {
              target.animationTime = 0;
              target.prevFromRect = null;
              target.fromRect = null;
              target.prevToRect = null;
              target.thisAnimationDuration = null;
            }, time);
            target.thisAnimationDuration = time;
          }
        });
        clearTimeout(animationCallbackId);
        if (!animating) {
          if (typeof callback === "function") callback();
        } else {
          animationCallbackId = setTimeout(function() {
            if (typeof callback === "function") callback();
          }, animationTime);
        }
        animationStates = [];
      },
      animate: function animate2(target, currentRect, toRect, duration) {
        if (duration) {
          css(target, "transition", "");
          css(target, "transform", "");
          var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
          target.animatingX = !!translateX;
          target.animatingY = !!translateY;
          css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
          this.forRepaintDummy = repaint(target);
          css(target, "transition", "transform " + duration + "ms" + (this.options.easing ? " " + this.options.easing : ""));
          css(target, "transform", "translate3d(0,0,0)");
          typeof target.animated === "number" && clearTimeout(target.animated);
          target.animated = setTimeout(function() {
            css(target, "transition", "");
            css(target, "transform", "");
            target.animated = false;
            target.animatingX = false;
            target.animatingY = false;
          }, duration);
        }
      }
    };
  }
  function repaint(target) {
    return target.offsetWidth;
  }
  function calculateRealTime(animatingRect, fromRect, toRect, options) {
    return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
  }
  var plugins = [];
  var defaults = {
    initializeByDefault: true
  };
  var PluginManager = {
    mount: function mount(plugin) {
      for (var option2 in defaults) {
        if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
          plugin[option2] = defaults[option2];
        }
      }
      plugins.forEach(function(p2) {
        if (p2.pluginName === plugin.pluginName) {
          throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
        }
      });
      plugins.push(plugin);
    },
    pluginEvent: function pluginEvent(eventName, sortable, evt) {
      var _this = this;
      this.eventCanceled = false;
      evt.cancel = function() {
        _this.eventCanceled = true;
      };
      var eventNameGlobal = eventName + "Global";
      plugins.forEach(function(plugin) {
        if (!sortable[plugin.pluginName]) return;
        if (sortable[plugin.pluginName][eventNameGlobal]) {
          sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
            sortable
          }, evt));
        }
        if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
          sortable[plugin.pluginName][eventName](_objectSpread2({
            sortable
          }, evt));
        }
      });
    },
    initializePlugins: function initializePlugins(sortable, el, defaults5, options) {
      plugins.forEach(function(plugin) {
        var pluginName = plugin.pluginName;
        if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
        var initialized = new plugin(sortable, el, sortable.options);
        initialized.sortable = sortable;
        initialized.options = sortable.options;
        sortable[pluginName] = initialized;
        _extends(defaults5, initialized.defaults);
      });
      for (var option2 in sortable.options) {
        if (!sortable.options.hasOwnProperty(option2)) continue;
        var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
        if (typeof modified !== "undefined") {
          sortable.options[option2] = modified;
        }
      }
    },
    getEventProperties: function getEventProperties(name2, sortable) {
      var eventProperties = {};
      plugins.forEach(function(plugin) {
        if (typeof plugin.eventProperties !== "function") return;
        _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name2));
      });
      return eventProperties;
    },
    modifyOption: function modifyOption(sortable, name2, value2) {
      var modifiedValue;
      plugins.forEach(function(plugin) {
        if (!sortable[plugin.pluginName]) return;
        if (plugin.optionListeners && typeof plugin.optionListeners[name2] === "function") {
          modifiedValue = plugin.optionListeners[name2].call(sortable[plugin.pluginName], value2);
        }
      });
      return modifiedValue;
    }
  };
  function dispatchEvent2(_ref) {
    var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name2 = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
    sortable = sortable || rootEl2 && rootEl2[expando];
    if (!sortable) return;
    var evt, options = sortable.options, onName = "on" + name2.charAt(0).toUpperCase() + name2.substr(1);
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent(name2, {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent(name2, true, true);
    }
    evt.to = toEl || rootEl2;
    evt.from = fromEl || rootEl2;
    evt.item = targetEl || rootEl2;
    evt.clone = cloneEl2;
    evt.oldIndex = oldIndex2;
    evt.newIndex = newIndex2;
    evt.oldDraggableIndex = oldDraggableIndex2;
    evt.newDraggableIndex = newDraggableIndex2;
    evt.originalEvent = originalEvent;
    evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
    var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name2, sortable));
    for (var option2 in allEventProperties) {
      evt[option2] = allEventProperties[option2];
    }
    if (rootEl2) {
      rootEl2.dispatchEvent(evt);
    }
    if (options[onName]) {
      options[onName].call(sortable, evt);
    }
  }
  var _excluded = ["evt"];
  var pluginEvent2 = function pluginEvent3(eventName, sortable) {
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data2 = _objectWithoutProperties(_ref, _excluded);
    PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
      dragEl,
      parentEl,
      ghostEl,
      rootEl,
      nextEl,
      lastDownEl,
      cloneEl,
      cloneHidden,
      dragStarted: moved,
      putSortable,
      activeSortable: Sortable.active,
      originalEvent,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex,
      hideGhostForTarget: _hideGhostForTarget,
      unhideGhostForTarget: _unhideGhostForTarget,
      cloneNowHidden: function cloneNowHidden() {
        cloneHidden = true;
      },
      cloneNowShown: function cloneNowShown() {
        cloneHidden = false;
      },
      dispatchSortableEvent: function dispatchSortableEvent(name2) {
        _dispatchEvent({
          sortable,
          name: name2,
          originalEvent
        });
      }
    }, data2));
  };
  function _dispatchEvent(info) {
    dispatchEvent2(_objectSpread2({
      putSortable,
      cloneEl,
      targetEl: dragEl,
      rootEl,
      oldIndex,
      oldDraggableIndex,
      newIndex,
      newDraggableIndex
    }, info));
  }
  var dragEl;
  var parentEl;
  var ghostEl;
  var rootEl;
  var nextEl;
  var lastDownEl;
  var cloneEl;
  var cloneHidden;
  var oldIndex;
  var newIndex;
  var oldDraggableIndex;
  var newDraggableIndex;
  var activeGroup;
  var putSortable;
  var awaitingDragStarted = false;
  var ignoreNextClick = false;
  var sortables = [];
  var tapEvt;
  var touchEvt;
  var lastDx;
  var lastDy;
  var tapDistanceLeft;
  var tapDistanceTop;
  var moved;
  var lastTarget;
  var lastDirection;
  var pastFirstInvertThresh = false;
  var isCircumstantialInvert = false;
  var targetMoveDistance;
  var ghostRelativeParent;
  var ghostRelativeParentInitialScroll = [];
  var _silent = false;
  var savedInputChecked = [];
  var documentExists = typeof document !== "undefined";
  var PositionGhostAbsolutely = IOS;
  var CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float";
  var supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div");
  var supportCssPointerEvents = function() {
    if (!documentExists) return;
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement("x");
    el.style.cssText = "pointer-events:auto";
    return el.style.pointerEvents === "auto";
  }();
  var _detectDirection = function _detectDirection2(el, options) {
    var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === "flex") {
      return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
    }
    if (elCSS.display === "grid") {
      return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
      var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
      return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
    }
    return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
  };
  var _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical2) {
    var dragElS1Opp = vertical2 ? dragRect.left : dragRect.top, dragElS2Opp = vertical2 ? dragRect.right : dragRect.bottom, dragElOppLength = vertical2 ? dragRect.width : dragRect.height, targetS1Opp = vertical2 ? targetRect.left : targetRect.top, targetS2Opp = vertical2 ? targetRect.right : targetRect.bottom, targetOppLength = vertical2 ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  };
  var _detectNearestEmptySortable = function _detectNearestEmptySortable2(x3, y3) {
    var ret;
    sortables.some(function(sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect4 = getRect(sortable), insideHorizontally = x3 >= rect4.left - threshold && x3 <= rect4.right + threshold, insideVertically = y3 >= rect4.top - threshold && y3 <= rect4.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  };
  var _prepareGroup = function _prepareGroup2(options) {
    function toFn(value2, pull) {
      return function(to, from, dragEl2, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value2 == null && (pull || sameGroup)) {
          return true;
        } else if (value2 == null || value2 === false) {
          return false;
        } else if (pull && value2 === "clone") {
          return value2;
        } else if (typeof value2 === "function") {
          return toFn(value2(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value2 === true || typeof value2 === "string" && value2 === otherGroup || value2.join && value2.indexOf(otherGroup) > -1;
        }
      };
    }
    var group3 = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != "object") {
      originalGroup = {
        name: originalGroup
      };
    }
    group3.name = originalGroup.name;
    group3.checkPull = toFn(originalGroup.pull, true);
    group3.checkPut = toFn(originalGroup.put);
    group3.revertClone = originalGroup.revertClone;
    options.group = group3;
  };
  var _hideGhostForTarget = function _hideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "none");
    }
  };
  var _unhideGhostForTarget = function _unhideGhostForTarget2() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, "display", "");
    }
  };
  if (documentExists && !ChromeForAndroid) {
    document.addEventListener("click", function(evt) {
      if (ignoreNextClick) {
        evt.preventDefault();
        evt.stopPropagation && evt.stopPropagation();
        evt.stopImmediatePropagation && evt.stopImmediatePropagation();
        ignoreNextClick = false;
        return false;
      }
    }, true);
  }
  var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
    if (dragEl) {
      evt = evt.touches ? evt.touches[0] : evt;
      var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
      if (nearest) {
        var event = {};
        for (var i in evt) {
          if (evt.hasOwnProperty(i)) {
            event[i] = evt[i];
          }
        }
        event.target = event.rootEl = nearest;
        event.preventDefault = void 0;
        event.stopPropagation = void 0;
        nearest[expando]._onDragOver(event);
      }
    }
  };
  var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
    if (dragEl) {
      dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
    }
  };
  function Sortable(el, options) {
    if (!(el && el.nodeType && el.nodeType === 1)) {
      throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
    }
    this.el = el;
    this.options = options = _extends({}, options);
    el[expando] = this;
    var defaults5 = {
      group: null,
      sort: true,
      disabled: false,
      store: null,
      handle: null,
      draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
      swapThreshold: 1,
      // percentage; 0 <= x <= 1
      invertSwap: false,
      // invert always
      invertedSwapThreshold: null,
      // will be set to same as swapThreshold if default
      removeCloneOnHide: true,
      direction: function direction2() {
        return _detectDirection(el, this.options);
      },
      ghostClass: "sortable-ghost",
      chosenClass: "sortable-chosen",
      dragClass: "sortable-drag",
      ignore: "a, img",
      filter: null,
      preventOnFilter: true,
      animation: 0,
      easing: null,
      setData: function setData3(dataTransfer, dragEl2) {
        dataTransfer.setData("Text", dragEl2.textContent);
      },
      dropBubble: false,
      dragoverBubble: false,
      dataIdAttr: "data-id",
      delay: 0,
      delayOnTouchOnly: false,
      touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
      forceFallback: false,
      fallbackClass: "sortable-fallback",
      fallbackOnBody: false,
      fallbackTolerance: 0,
      fallbackOffset: {
        x: 0,
        y: 0
      },
      supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
      emptyInsertThreshold: 5
    };
    PluginManager.initializePlugins(this, el, defaults5);
    for (var name2 in defaults5) {
      !(name2 in options) && (options[name2] = defaults5[name2]);
    }
    _prepareGroup(options);
    for (var fn in this) {
      if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
        this[fn] = this[fn].bind(this);
      }
    }
    this.nativeDraggable = options.forceFallback ? false : supportDraggable;
    if (this.nativeDraggable) {
      this.options.touchStartThreshold = 1;
    }
    if (options.supportPointer) {
      on(el, "pointerdown", this._onTapStart);
    } else {
      on(el, "mousedown", this._onTapStart);
      on(el, "touchstart", this._onTapStart);
    }
    if (this.nativeDraggable) {
      on(el, "dragover", this);
      on(el, "dragenter", this);
    }
    sortables.push(this.el);
    options.store && options.store.get && this.sort(options.store.get(this) || []);
    _extends(this, AnimationStateManager());
  }
  Sortable.prototype = /** @lends Sortable.prototype */
  {
    constructor: Sortable,
    _isOutsideThisEl: function _isOutsideThisEl(target) {
      if (!this.el.contains(target) && target !== this.el) {
        lastTarget = null;
      }
    },
    _getDirection: function _getDirection(evt, target) {
      return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
    },
    _onTapStart: function _onTapStart(evt) {
      if (!evt.cancelable) return;
      var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter2 = options.filter;
      _saveInputCheckedState(el);
      if (dragEl) {
        return;
      }
      if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
        return;
      }
      if (originalTarget.isContentEditable) {
        return;
      }
      if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
        return;
      }
      target = closest(target, options.draggable, el, false);
      if (target && target.animated) {
        return;
      }
      if (lastDownEl === target) {
        return;
      }
      oldIndex = index(target);
      oldDraggableIndex = index(target, options.draggable);
      if (typeof filter2 === "function") {
        if (filter2.call(this, evt, target, this)) {
          _dispatchEvent({
            sortable: _this,
            rootEl: originalTarget,
            name: "filter",
            targetEl: target,
            toEl: el,
            fromEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return;
        }
      } else if (filter2) {
        filter2 = filter2.split(",").some(function(criteria) {
          criteria = closest(originalTarget, criteria.trim(), el, false);
          if (criteria) {
            _dispatchEvent({
              sortable: _this,
              rootEl: criteria,
              name: "filter",
              targetEl: target,
              fromEl: el,
              toEl: el
            });
            pluginEvent2("filter", _this, {
              evt
            });
            return true;
          }
        });
        if (filter2) {
          preventOnFilter && evt.cancelable && evt.preventDefault();
          return;
        }
      }
      if (options.handle && !closest(originalTarget, options.handle, el, false)) {
        return;
      }
      this._prepareDragStart(evt, touch, target);
    },
    _prepareDragStart: function _prepareDragStart(evt, touch, target) {
      var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
      if (target && !dragEl && target.parentNode === el) {
        var dragRect = getRect(target);
        rootEl = el;
        dragEl = target;
        parentEl = dragEl.parentNode;
        nextEl = dragEl.nextSibling;
        lastDownEl = target;
        activeGroup = options.group;
        Sortable.dragged = dragEl;
        tapEvt = {
          target: dragEl,
          clientX: (touch || evt).clientX,
          clientY: (touch || evt).clientY
        };
        tapDistanceLeft = tapEvt.clientX - dragRect.left;
        tapDistanceTop = tapEvt.clientY - dragRect.top;
        this._lastX = (touch || evt).clientX;
        this._lastY = (touch || evt).clientY;
        dragEl.style["will-change"] = "all";
        dragStartFn = function dragStartFn2() {
          pluginEvent2("delayEnded", _this, {
            evt
          });
          if (Sortable.eventCanceled) {
            _this._onDrop();
            return;
          }
          _this._disableDelayedDragEvents();
          if (!FireFox && _this.nativeDraggable) {
            dragEl.draggable = true;
          }
          _this._triggerDragStart(evt, touch);
          _dispatchEvent({
            sortable: _this,
            name: "choose",
            originalEvent: evt
          });
          toggleClass(dragEl, options.chosenClass, true);
        };
        options.ignore.split(",").forEach(function(criteria) {
          find(dragEl, criteria.trim(), _disableDraggable);
        });
        on(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
        on(ownerDocument, "mouseup", _this._onDrop);
        on(ownerDocument, "touchend", _this._onDrop);
        on(ownerDocument, "touchcancel", _this._onDrop);
        if (FireFox && this.nativeDraggable) {
          this.options.touchStartThreshold = 4;
          dragEl.draggable = true;
        }
        pluginEvent2("delayStart", this, {
          evt
        });
        if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
          if (Sortable.eventCanceled) {
            this._onDrop();
            return;
          }
          on(ownerDocument, "mouseup", _this._disableDelayedDrag);
          on(ownerDocument, "touchend", _this._disableDelayedDrag);
          on(ownerDocument, "touchcancel", _this._disableDelayedDrag);
          on(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
          on(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
          options.supportPointer && on(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
          _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
        } else {
          dragStartFn();
        }
      }
    },
    _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e3) {
      var touch = e3.touches ? e3.touches[0] : e3;
      if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
        this._disableDelayedDrag();
      }
    },
    _disableDelayedDrag: function _disableDelayedDrag() {
      dragEl && _disableDraggable(dragEl);
      clearTimeout(this._dragStartTimer);
      this._disableDelayedDragEvents();
    },
    _disableDelayedDragEvents: function _disableDelayedDragEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._disableDelayedDrag);
      off(ownerDocument, "touchend", this._disableDelayedDrag);
      off(ownerDocument, "touchcancel", this._disableDelayedDrag);
      off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
      off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
    },
    _triggerDragStart: function _triggerDragStart(evt, touch) {
      touch = touch || evt.pointerType == "touch" && evt;
      if (!this.nativeDraggable || touch) {
        if (this.options.supportPointer) {
          on(document, "pointermove", this._onTouchMove);
        } else if (touch) {
          on(document, "touchmove", this._onTouchMove);
        } else {
          on(document, "mousemove", this._onTouchMove);
        }
      } else {
        on(dragEl, "dragend", this);
        on(rootEl, "dragstart", this._onDragStart);
      }
      try {
        if (document.selection) {
          _nextTick(function() {
            document.selection.empty();
          });
        } else {
          window.getSelection().removeAllRanges();
        }
      } catch (err) {
      }
    },
    _dragStarted: function _dragStarted(fallback, evt) {
      awaitingDragStarted = false;
      if (rootEl && dragEl) {
        pluginEvent2("dragStarted", this, {
          evt
        });
        if (this.nativeDraggable) {
          on(document, "dragover", _checkOutsideTargetEl);
        }
        var options = this.options;
        !fallback && toggleClass(dragEl, options.dragClass, false);
        toggleClass(dragEl, options.ghostClass, true);
        Sortable.active = this;
        fallback && this._appendGhost();
        _dispatchEvent({
          sortable: this,
          name: "start",
          originalEvent: evt
        });
      } else {
        this._nulling();
      }
    },
    _emulateDragOver: function _emulateDragOver() {
      if (touchEvt) {
        this._lastX = touchEvt.clientX;
        this._lastY = touchEvt.clientY;
        _hideGhostForTarget();
        var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        var parent = target;
        while (target && target.shadowRoot) {
          target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
          if (target === parent) break;
          parent = target;
        }
        dragEl.parentNode[expando]._isOutsideThisEl(target);
        if (parent) {
          do {
            if (parent[expando]) {
              var inserted = void 0;
              inserted = parent[expando]._onDragOver({
                clientX: touchEvt.clientX,
                clientY: touchEvt.clientY,
                target,
                rootEl: parent
              });
              if (inserted && !this.options.dragoverBubble) {
                break;
              }
            }
            target = parent;
          } while (parent = parent.parentNode);
        }
        _unhideGhostForTarget();
      }
    },
    _onTouchMove: function _onTouchMove(evt) {
      if (tapEvt) {
        var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
        if (!Sortable.active && !awaitingDragStarted) {
          if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
            return;
          }
          this._onDragStart(evt, true);
        }
        if (ghostEl) {
          if (ghostMatrix) {
            ghostMatrix.e += dx - (lastDx || 0);
            ghostMatrix.f += dy - (lastDy || 0);
          } else {
            ghostMatrix = {
              a: 1,
              b: 0,
              c: 0,
              d: 1,
              e: dx,
              f: dy
            };
          }
          var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
          css(ghostEl, "webkitTransform", cssMatrix);
          css(ghostEl, "mozTransform", cssMatrix);
          css(ghostEl, "msTransform", cssMatrix);
          css(ghostEl, "transform", cssMatrix);
          lastDx = dx;
          lastDy = dy;
          touchEvt = touch;
        }
        evt.cancelable && evt.preventDefault();
      }
    },
    _appendGhost: function _appendGhost() {
      if (!ghostEl) {
        var container = this.options.fallbackOnBody ? document.body : rootEl, rect4 = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
        if (PositionGhostAbsolutely) {
          ghostRelativeParent = container;
          while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
            ghostRelativeParent = ghostRelativeParent.parentNode;
          }
          if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
            if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
            rect4.top += ghostRelativeParent.scrollTop;
            rect4.left += ghostRelativeParent.scrollLeft;
          } else {
            ghostRelativeParent = getWindowScrollingElement();
          }
          ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
        }
        ghostEl = dragEl.cloneNode(true);
        toggleClass(ghostEl, options.ghostClass, false);
        toggleClass(ghostEl, options.fallbackClass, true);
        toggleClass(ghostEl, options.dragClass, true);
        css(ghostEl, "transition", "");
        css(ghostEl, "transform", "");
        css(ghostEl, "box-sizing", "border-box");
        css(ghostEl, "margin", 0);
        css(ghostEl, "top", rect4.top);
        css(ghostEl, "left", rect4.left);
        css(ghostEl, "width", rect4.width);
        css(ghostEl, "height", rect4.height);
        css(ghostEl, "opacity", "0.8");
        css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
        css(ghostEl, "zIndex", "100000");
        css(ghostEl, "pointerEvents", "none");
        Sortable.ghost = ghostEl;
        container.appendChild(ghostEl);
        css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
      }
    },
    _onDragStart: function _onDragStart(evt, fallback) {
      var _this = this;
      var dataTransfer = evt.dataTransfer;
      var options = _this.options;
      pluginEvent2("dragStart", this, {
        evt
      });
      if (Sortable.eventCanceled) {
        this._onDrop();
        return;
      }
      pluginEvent2("setupClone", this);
      if (!Sortable.eventCanceled) {
        cloneEl = clone3(dragEl);
        cloneEl.removeAttribute("id");
        cloneEl.draggable = false;
        cloneEl.style["will-change"] = "";
        this._hideClone();
        toggleClass(cloneEl, this.options.chosenClass, false);
        Sortable.clone = cloneEl;
      }
      _this.cloneId = _nextTick(function() {
        pluginEvent2("clone", _this);
        if (Sortable.eventCanceled) return;
        if (!_this.options.removeCloneOnHide) {
          rootEl.insertBefore(cloneEl, dragEl);
        }
        _this._hideClone();
        _dispatchEvent({
          sortable: _this,
          name: "clone"
        });
      });
      !fallback && toggleClass(dragEl, options.dragClass, true);
      if (fallback) {
        ignoreNextClick = true;
        _this._loopId = setInterval(_this._emulateDragOver, 50);
      } else {
        off(document, "mouseup", _this._onDrop);
        off(document, "touchend", _this._onDrop);
        off(document, "touchcancel", _this._onDrop);
        if (dataTransfer) {
          dataTransfer.effectAllowed = "move";
          options.setData && options.setData.call(_this, dataTransfer, dragEl);
        }
        on(document, "drop", _this);
        css(dragEl, "transform", "translateZ(0)");
      }
      awaitingDragStarted = true;
      _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
      on(document, "selectstart", _this);
      moved = true;
      if (Safari) {
        css(document.body, "user-select", "none");
      }
    },
    // Returns true - if no further action is needed (either inserted or another condition)
    _onDragOver: function _onDragOver(evt) {
      var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group3 = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group3, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical2, _this = this, completedFired = false;
      if (_silent) return;
      function dragOverEvent(name2, extra) {
        pluginEvent2(name2, _this, _objectSpread2({
          evt,
          isOwner,
          axis: vertical2 ? "vertical" : "horizontal",
          revert,
          dragRect,
          targetRect,
          canSort,
          fromSortable,
          target,
          completed,
          onMove: function onMove(target2, after2) {
            return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
          },
          changed
        }, extra));
      }
      function capture() {
        dragOverEvent("dragOverAnimationCapture");
        _this.captureAnimationState();
        if (_this !== fromSortable) {
          fromSortable.captureAnimationState();
        }
      }
      function completed(insertion) {
        dragOverEvent("dragOverCompleted", {
          insertion
        });
        if (insertion) {
          if (isOwner) {
            activeSortable._hideClone();
          } else {
            activeSortable._showClone(_this);
          }
          if (_this !== fromSortable) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
            toggleClass(dragEl, options.ghostClass, true);
          }
          if (putSortable !== _this && _this !== Sortable.active) {
            putSortable = _this;
          } else if (_this === Sortable.active && putSortable) {
            putSortable = null;
          }
          if (fromSortable === _this) {
            _this._ignoreWhileAnimating = target;
          }
          _this.animateAll(function() {
            dragOverEvent("dragOverAnimationComplete");
            _this._ignoreWhileAnimating = null;
          });
          if (_this !== fromSortable) {
            fromSortable.animateAll();
            fromSortable._ignoreWhileAnimating = null;
          }
        }
        if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
          lastTarget = null;
        }
        if (!options.dragoverBubble && !evt.rootEl && target !== document) {
          dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
          !insertion && nearestEmptyInsertDetectEvent(evt);
        }
        !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
        return completedFired = true;
      }
      function changed() {
        newIndex = index(dragEl);
        newDraggableIndex = index(dragEl, options.draggable);
        _dispatchEvent({
          sortable: _this,
          name: "change",
          toEl: el,
          newIndex,
          newDraggableIndex,
          originalEvent: evt
        });
      }
      if (evt.preventDefault !== void 0) {
        evt.cancelable && evt.preventDefault();
      }
      target = closest(target, options.draggable, el, true);
      dragOverEvent("dragOver");
      if (Sortable.eventCanceled) return completedFired;
      if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
        return completed(false);
      }
      ignoreNextClick = false;
      if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group3.checkPut(this, activeSortable, dragEl, evt))) {
        vertical2 = this._getDirection(evt, target) === "vertical";
        dragRect = getRect(dragEl);
        dragOverEvent("dragOverValid");
        if (Sortable.eventCanceled) return completedFired;
        if (revert) {
          parentEl = rootEl;
          capture();
          this._hideClone();
          dragOverEvent("revert");
          if (!Sortable.eventCanceled) {
            if (nextEl) {
              rootEl.insertBefore(dragEl, nextEl);
            } else {
              rootEl.appendChild(dragEl);
            }
          }
          return completed(true);
        }
        var elLastChild = lastChild(el, options.draggable);
        if (!elLastChild || _ghostIsLast(evt, vertical2, this) && !elLastChild.animated) {
          if (elLastChild === dragEl) {
            return completed(false);
          }
          if (elLastChild && el === evt.target) {
            target = elLastChild;
          }
          if (target) {
            targetRect = getRect(target);
          }
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
            capture();
            if (elLastChild && elLastChild.nextSibling) {
              el.insertBefore(dragEl, elLastChild.nextSibling);
            } else {
              el.appendChild(dragEl);
            }
            parentEl = el;
            changed();
            return completed(true);
          }
        } else if (elLastChild && _ghostIsFirst(evt, vertical2, this)) {
          var firstChild = getChild(el, 0, options, true);
          if (firstChild === dragEl) {
            return completed(false);
          }
          target = firstChild;
          targetRect = getRect(target);
          if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
            capture();
            el.insertBefore(dragEl, firstChild);
            parentEl = el;
            changed();
            return completed(true);
          }
        } else if (target.parentNode === el) {
          targetRect = getRect(target);
          var direction2 = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical2), side1 = vertical2 ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
          if (lastTarget !== target) {
            targetBeforeFirstSwap = targetRect[side1];
            pastFirstInvertThresh = false;
            isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
          }
          direction2 = _getSwapDirection(evt, target, targetRect, vertical2, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
          var sibling;
          if (direction2 !== 0) {
            var dragIndex = index(dragEl);
            do {
              dragIndex -= direction2;
              sibling = parentEl.children[dragIndex];
            } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
          }
          if (direction2 === 0 || sibling === target) {
            return completed(false);
          }
          lastTarget = target;
          lastDirection = direction2;
          var nextSibling = target.nextElementSibling, after = false;
          after = direction2 === 1;
          var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
          if (moveVector !== false) {
            if (moveVector === 1 || moveVector === -1) {
              after = moveVector === 1;
            }
            _silent = true;
            setTimeout(_unsilent, 30);
            capture();
            if (after && !nextSibling) {
              el.appendChild(dragEl);
            } else {
              target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
            }
            if (scrolledPastTop) {
              scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
            }
            parentEl = dragEl.parentNode;
            if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
              targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
            }
            changed();
            return completed(true);
          }
        }
        if (el.contains(dragEl)) {
          return completed(false);
        }
      }
      return false;
    },
    _ignoreWhileAnimating: null,
    _offMoveEvents: function _offMoveEvents() {
      off(document, "mousemove", this._onTouchMove);
      off(document, "touchmove", this._onTouchMove);
      off(document, "pointermove", this._onTouchMove);
      off(document, "dragover", nearestEmptyInsertDetectEvent);
      off(document, "mousemove", nearestEmptyInsertDetectEvent);
      off(document, "touchmove", nearestEmptyInsertDetectEvent);
    },
    _offUpEvents: function _offUpEvents() {
      var ownerDocument = this.el.ownerDocument;
      off(ownerDocument, "mouseup", this._onDrop);
      off(ownerDocument, "touchend", this._onDrop);
      off(ownerDocument, "pointerup", this._onDrop);
      off(ownerDocument, "touchcancel", this._onDrop);
      off(document, "selectstart", this);
    },
    _onDrop: function _onDrop(evt) {
      var el = this.el, options = this.options;
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      pluginEvent2("drop", this, {
        evt
      });
      parentEl = dragEl && dragEl.parentNode;
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      if (Sortable.eventCanceled) {
        this._nulling();
        return;
      }
      awaitingDragStarted = false;
      isCircumstantialInvert = false;
      pastFirstInvertThresh = false;
      clearInterval(this._loopId);
      clearTimeout(this._dragStartTimer);
      _cancelNextTick(this.cloneId);
      _cancelNextTick(this._dragStartId);
      if (this.nativeDraggable) {
        off(document, "drop", this);
        off(el, "dragstart", this._onDragStart);
      }
      this._offMoveEvents();
      this._offUpEvents();
      if (Safari) {
        css(document.body, "user-select", "");
      }
      css(dragEl, "transform", "");
      if (evt) {
        if (moved) {
          evt.cancelable && evt.preventDefault();
          !options.dropBubble && evt.stopPropagation();
        }
        ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
        if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
          cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
        }
        if (dragEl) {
          if (this.nativeDraggable) {
            off(dragEl, "dragend", this);
          }
          _disableDraggable(dragEl);
          dragEl.style["will-change"] = "";
          if (moved && !awaitingDragStarted) {
            toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
          }
          toggleClass(dragEl, this.options.chosenClass, false);
          _dispatchEvent({
            sortable: this,
            name: "unchoose",
            toEl: parentEl,
            newIndex: null,
            newDraggableIndex: null,
            originalEvent: evt
          });
          if (rootEl !== parentEl) {
            if (newIndex >= 0) {
              _dispatchEvent({
                rootEl: parentEl,
                name: "add",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "remove",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                rootEl: parentEl,
                name: "sort",
                toEl: parentEl,
                fromEl: rootEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
            putSortable && putSortable.save();
          } else {
            if (newIndex !== oldIndex) {
              if (newIndex >= 0) {
                _dispatchEvent({
                  sortable: this,
                  name: "update",
                  toEl: parentEl,
                  originalEvent: evt
                });
                _dispatchEvent({
                  sortable: this,
                  name: "sort",
                  toEl: parentEl,
                  originalEvent: evt
                });
              }
            }
          }
          if (Sortable.active) {
            if (newIndex == null || newIndex === -1) {
              newIndex = oldIndex;
              newDraggableIndex = oldDraggableIndex;
            }
            _dispatchEvent({
              sortable: this,
              name: "end",
              toEl: parentEl,
              originalEvent: evt
            });
            this.save();
          }
        }
      }
      this._nulling();
    },
    _nulling: function _nulling() {
      pluginEvent2("nulling", this);
      rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
      savedInputChecked.forEach(function(el) {
        el.checked = true;
      });
      savedInputChecked.length = lastDx = lastDy = 0;
    },
    handleEvent: function handleEvent(evt) {
      switch (evt.type) {
        case "drop":
        case "dragend":
          this._onDrop(evt);
          break;
        case "dragenter":
        case "dragover":
          if (dragEl) {
            this._onDragOver(evt);
            _globalDragOver(evt);
          }
          break;
        case "selectstart":
          evt.preventDefault();
          break;
      }
    },
    /**
     * Serializes the item into an array of string.
     * @returns {String[]}
     */
    toArray: function toArray() {
      var order = [], el, children = this.el.children, i = 0, n2 = children.length, options = this.options;
      for (; i < n2; i++) {
        el = children[i];
        if (closest(el, options.draggable, this.el, false)) {
          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
        }
      }
      return order;
    },
    /**
     * Sorts the elements according to the array.
     * @param  {String[]}  order  order of the items
     */
    sort: function sort(order, useAnimation) {
      var items = {}, rootEl2 = this.el;
      this.toArray().forEach(function(id4, i) {
        var el = rootEl2.children[i];
        if (closest(el, this.options.draggable, rootEl2, false)) {
          items[id4] = el;
        }
      }, this);
      useAnimation && this.captureAnimationState();
      order.forEach(function(id4) {
        if (items[id4]) {
          rootEl2.removeChild(items[id4]);
          rootEl2.appendChild(items[id4]);
        }
      });
      useAnimation && this.animateAll();
    },
    /**
     * Save the current sorting
     */
    save: function save() {
      var store = this.options.store;
      store && store.set && store.set(this);
    },
    /**
     * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @param   {HTMLElement}  el
     * @param   {String}       [selector]  default: `options.draggable`
     * @returns {HTMLElement|null}
     */
    closest: function closest$1(el, selector) {
      return closest(el, selector || this.options.draggable, this.el, false);
    },
    /**
     * Set/get option
     * @param   {string} name
     * @param   {*}      [value]
     * @returns {*}
     */
    option: function option(name2, value2) {
      var options = this.options;
      if (value2 === void 0) {
        return options[name2];
      } else {
        var modifiedValue = PluginManager.modifyOption(this, name2, value2);
        if (typeof modifiedValue !== "undefined") {
          options[name2] = modifiedValue;
        } else {
          options[name2] = value2;
        }
        if (name2 === "group") {
          _prepareGroup(options);
        }
      }
    },
    /**
     * Destroy
     */
    destroy: function destroy() {
      pluginEvent2("destroy", this);
      var el = this.el;
      el[expando] = null;
      off(el, "mousedown", this._onTapStart);
      off(el, "touchstart", this._onTapStart);
      off(el, "pointerdown", this._onTapStart);
      if (this.nativeDraggable) {
        off(el, "dragover", this);
        off(el, "dragenter", this);
      }
      Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
        el2.removeAttribute("draggable");
      });
      this._onDrop();
      this._disableDelayedDragEvents();
      sortables.splice(sortables.indexOf(this.el), 1);
      this.el = el = null;
    },
    _hideClone: function _hideClone() {
      if (!cloneHidden) {
        pluginEvent2("hideClone", this);
        if (Sortable.eventCanceled) return;
        css(cloneEl, "display", "none");
        if (this.options.removeCloneOnHide && cloneEl.parentNode) {
          cloneEl.parentNode.removeChild(cloneEl);
        }
        cloneHidden = true;
      }
    },
    _showClone: function _showClone(putSortable2) {
      if (putSortable2.lastPutMode !== "clone") {
        this._hideClone();
        return;
      }
      if (cloneHidden) {
        pluginEvent2("showClone", this);
        if (Sortable.eventCanceled) return;
        if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
          rootEl.insertBefore(cloneEl, dragEl);
        } else if (nextEl) {
          rootEl.insertBefore(cloneEl, nextEl);
        } else {
          rootEl.appendChild(cloneEl);
        }
        if (this.options.group.revertClone) {
          this.animate(dragEl, cloneEl);
        }
        css(cloneEl, "display", "");
        cloneHidden = false;
      }
    }
  };
  function _globalDragOver(evt) {
    if (evt.dataTransfer) {
      evt.dataTransfer.dropEffect = "move";
    }
    evt.cancelable && evt.preventDefault();
  }
  function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
    var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
    if (window.CustomEvent && !IE11OrLess && !Edge) {
      evt = new CustomEvent("move", {
        bubbles: true,
        cancelable: true
      });
    } else {
      evt = document.createEvent("Event");
      evt.initEvent("move", true, true);
    }
    evt.to = toEl;
    evt.from = fromEl;
    evt.dragged = dragEl2;
    evt.draggedRect = dragRect;
    evt.related = targetEl || toEl;
    evt.relatedRect = targetRect || getRect(toEl);
    evt.willInsertAfter = willInsertAfter;
    evt.originalEvent = originalEvent;
    fromEl.dispatchEvent(evt);
    if (onMoveFn) {
      retVal = onMoveFn.call(sortable, evt, originalEvent);
    }
    return retVal;
  }
  function _disableDraggable(el) {
    el.draggable = false;
  }
  function _unsilent() {
    _silent = false;
  }
  function _ghostIsFirst(evt, vertical2, sortable) {
    var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical2 ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
  }
  function _ghostIsLast(evt, vertical2, sortable) {
    var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
    var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
    var spacer = 10;
    return vertical2 ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
  }
  function _getSwapDirection(evt, target, targetRect, vertical2, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
    var mouseOnAxis = vertical2 ? evt.clientY : evt.clientX, targetLength = vertical2 ? targetRect.height : targetRect.width, targetS1 = vertical2 ? targetRect.top : targetRect.left, targetS2 = vertical2 ? targetRect.bottom : targetRect.right, invert5 = false;
    if (!invertSwap) {
      if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
        if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
          pastFirstInvertThresh = true;
        }
        if (!pastFirstInvertThresh) {
          if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
            return -lastDirection;
          }
        } else {
          invert5 = true;
        }
      } else {
        if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
          return _getInsertDirection(target);
        }
      }
    }
    invert5 = invert5 || invertSwap;
    if (invert5) {
      if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
        return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
      }
    }
    return 0;
  }
  function _getInsertDirection(target) {
    if (index(dragEl) < index(target)) {
      return 1;
    } else {
      return -1;
    }
  }
  function _generateId(el) {
    var str7 = el.tagName + el.className + el.src + el.href + el.textContent, i = str7.length, sum3 = 0;
    while (i--) {
      sum3 += str7.charCodeAt(i);
    }
    return sum3.toString(36);
  }
  function _saveInputCheckedState(root2) {
    savedInputChecked.length = 0;
    var inputs = root2.getElementsByTagName("input");
    var idx = inputs.length;
    while (idx--) {
      var el = inputs[idx];
      el.checked && savedInputChecked.push(el);
    }
  }
  function _nextTick(fn) {
    return setTimeout(fn, 0);
  }
  function _cancelNextTick(id4) {
    return clearTimeout(id4);
  }
  if (documentExists) {
    on(document, "touchmove", function(evt) {
      if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
        evt.preventDefault();
      }
    });
  }
  Sortable.utils = {
    on,
    off,
    css,
    find,
    is: function is(el, selector) {
      return !!closest(el, selector, el, false);
    },
    extend: extend3,
    throttle,
    closest,
    toggleClass,
    clone: clone3,
    index,
    nextTick: _nextTick,
    cancelNextTick: _cancelNextTick,
    detectDirection: _detectDirection,
    getChild
  };
  Sortable.get = function(element) {
    return element[expando];
  };
  Sortable.mount = function() {
    for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
      plugins2[_key] = arguments[_key];
    }
    if (plugins2[0].constructor === Array) plugins2 = plugins2[0];
    plugins2.forEach(function(plugin) {
      if (!plugin.prototype || !plugin.prototype.constructor) {
        throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
      }
      if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
      PluginManager.mount(plugin);
    });
  };
  Sortable.create = function(el, options) {
    return new Sortable(el, options);
  };
  Sortable.version = version;
  var autoScrolls = [];
  var scrollEl;
  var scrollRootEl;
  var scrolling = false;
  var lastAutoScrollX;
  var lastAutoScrollY;
  var touchEvt$1;
  var pointerElemChangedInterval;
  function AutoScrollPlugin() {
    function AutoScroll() {
      this.defaults = {
        scroll: true,
        forceAutoScrollFallback: false,
        scrollSensitivity: 30,
        scrollSpeed: 10,
        bubbleScroll: true
      };
      for (var fn in this) {
        if (fn.charAt(0) === "_" && typeof this[fn] === "function") {
          this[fn] = this[fn].bind(this);
        }
      }
    }
    AutoScroll.prototype = {
      dragStarted: function dragStarted(_ref) {
        var originalEvent = _ref.originalEvent;
        if (this.sortable.nativeDraggable) {
          on(document, "dragover", this._handleAutoScroll);
        } else {
          if (this.options.supportPointer) {
            on(document, "pointermove", this._handleFallbackAutoScroll);
          } else if (originalEvent.touches) {
            on(document, "touchmove", this._handleFallbackAutoScroll);
          } else {
            on(document, "mousemove", this._handleFallbackAutoScroll);
          }
        }
      },
      dragOverCompleted: function dragOverCompleted(_ref2) {
        var originalEvent = _ref2.originalEvent;
        if (!this.options.dragOverBubble && !originalEvent.rootEl) {
          this._handleAutoScroll(originalEvent);
        }
      },
      drop: function drop3() {
        if (this.sortable.nativeDraggable) {
          off(document, "dragover", this._handleAutoScroll);
        } else {
          off(document, "pointermove", this._handleFallbackAutoScroll);
          off(document, "touchmove", this._handleFallbackAutoScroll);
          off(document, "mousemove", this._handleFallbackAutoScroll);
        }
        clearPointerElemChangedInterval();
        clearAutoScrolls();
        cancelThrottle();
      },
      nulling: function nulling() {
        touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
        autoScrolls.length = 0;
      },
      _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
        this._handleAutoScroll(evt, true);
      },
      _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
        var _this = this;
        var x3 = (evt.touches ? evt.touches[0] : evt).clientX, y3 = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x3, y3);
        touchEvt$1 = evt;
        if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
          autoScroll(evt, this.options, elem, fallback);
          var ogElemScroller = getParentAutoScrollElement(elem, true);
          if (scrolling && (!pointerElemChangedInterval || x3 !== lastAutoScrollX || y3 !== lastAutoScrollY)) {
            pointerElemChangedInterval && clearPointerElemChangedInterval();
            pointerElemChangedInterval = setInterval(function() {
              var newElem = getParentAutoScrollElement(document.elementFromPoint(x3, y3), true);
              if (newElem !== ogElemScroller) {
                ogElemScroller = newElem;
                clearAutoScrolls();
              }
              autoScroll(evt, _this.options, newElem, fallback);
            }, 10);
            lastAutoScrollX = x3;
            lastAutoScrollY = y3;
          }
        } else {
          if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
            clearAutoScrolls();
            return;
          }
          autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
        }
      }
    };
    return _extends(AutoScroll, {
      pluginName: "scroll",
      initializeByDefault: true
    });
  }
  function clearAutoScrolls() {
    autoScrolls.forEach(function(autoScroll2) {
      clearInterval(autoScroll2.pid);
    });
    autoScrolls = [];
  }
  function clearPointerElemChangedInterval() {
    clearInterval(pointerElemChangedInterval);
  }
  var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
    if (!options.scroll) return;
    var x3 = (evt.touches ? evt.touches[0] : evt).clientX, y3 = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
    var scrollThisInstance = false, scrollCustomFn;
    if (scrollRootEl !== rootEl2) {
      scrollRootEl = rootEl2;
      clearAutoScrolls();
      scrollEl = options.scroll;
      scrollCustomFn = options.scrollFn;
      if (scrollEl === true) {
        scrollEl = getParentAutoScrollElement(rootEl2, true);
      }
    }
    var layersOut = 0;
    var currentParent = scrollEl;
    do {
      var el = currentParent, rect4 = getRect(el), top = rect4.top, bottom = rect4.bottom, left2 = rect4.left, right2 = rect4.right, width = rect4.width, height = rect4.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
      if (el === winScroller) {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
      } else {
        canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
        canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
      }
      var vx = canScrollX && (Math.abs(right2 - x3) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left2 - x3) <= sens && !!scrollPosX);
      var vy = canScrollY && (Math.abs(bottom - y3) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y3) <= sens && !!scrollPosY);
      if (!autoScrolls[layersOut]) {
        for (var i = 0; i <= layersOut; i++) {
          if (!autoScrolls[i]) {
            autoScrolls[i] = {};
          }
        }
      }
      if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
        autoScrolls[layersOut].el = el;
        autoScrolls[layersOut].vx = vx;
        autoScrolls[layersOut].vy = vy;
        clearInterval(autoScrolls[layersOut].pid);
        if (vx != 0 || vy != 0) {
          scrollThisInstance = true;
          autoScrolls[layersOut].pid = setInterval(function() {
            if (isFallback && this.layer === 0) {
              Sortable.active._onTouchMove(touchEvt$1);
            }
            var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
            var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
            if (typeof scrollCustomFn === "function") {
              if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
                return;
              }
            }
            scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
          }.bind({
            layer: layersOut
          }), 24);
        }
      }
      layersOut++;
    } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
    scrolling = scrollThisInstance;
  }, 30);
  var drop = function drop2(_ref) {
    var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
    if (!originalEvent) return;
    var toSortable = putSortable2 || activeSortable;
    hideGhostForTarget();
    var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
    var target = document.elementFromPoint(touch.clientX, touch.clientY);
    unhideGhostForTarget();
    if (toSortable && !toSortable.el.contains(target)) {
      dispatchSortableEvent("spill");
      this.onSpill({
        dragEl: dragEl2,
        putSortable: putSortable2
      });
    }
  };
  function Revert() {
  }
  Revert.prototype = {
    startIndex: null,
    dragStart: function dragStart(_ref2) {
      var oldDraggableIndex2 = _ref2.oldDraggableIndex;
      this.startIndex = oldDraggableIndex2;
    },
    onSpill: function onSpill(_ref3) {
      var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
      this.sortable.captureAnimationState();
      if (putSortable2) {
        putSortable2.captureAnimationState();
      }
      var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
      if (nextSibling) {
        this.sortable.el.insertBefore(dragEl2, nextSibling);
      } else {
        this.sortable.el.appendChild(dragEl2);
      }
      this.sortable.animateAll();
      if (putSortable2) {
        putSortable2.animateAll();
      }
    },
    drop
  };
  _extends(Revert, {
    pluginName: "revertOnSpill"
  });
  function Remove() {
  }
  Remove.prototype = {
    onSpill: function onSpill2(_ref4) {
      var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
      var parentSortable = putSortable2 || this.sortable;
      parentSortable.captureAnimationState();
      dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
      parentSortable.animateAll();
    },
    drop
  };
  _extends(Remove, {
    pluginName: "removeOnSpill"
  });
  Sortable.mount(new AutoScrollPlugin());
  Sortable.mount(Remove, Revert);
  var sortable_esm_default = Sortable;

  // ../../engine/rails_design/app/javascripts/stimulus_com/sortable.js
  var sortable_default = class extends base_controller_default {
    static values = {
      handle: { type: String, default: ".is-drawable" }
    };
    connect() {
      sortable_esm_default.create(this.element, {
        handle: this.handleValue,
        onEnd: (evt) => {
          const body = {
            old_index: evt.oldIndex,
            new_index: evt.newIndex
          };
          if (evt.newIndex === evt.oldIndex) {
            return;
          } else if (evt.newIndex > evt.oldIndex) {
            body.prior_id = evt.item.previousElementSibling.dataset.id;
          } else {
            body.subsequent_id = evt.item.nextElementSibling.dataset.id;
          }
          const url = evt.item.dataset["url"];
          this.patch(url, JSON.stringify(body));
        }
      });
    }
    disconnect() {
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/choice.js
  var import_choices = __toESM(require_choices());
  var choice_default = class extends Controller {
    connect() {
      this.reload(this.element);
    }
    reload(element) {
      new import_choices.default(element, {
        noChoicesText: "\u65E0\u53EF\u9009\u9879",
        itemSelectText: "\u70B9\u51FB\u9009\u62E9",
        removeItemButton: true
      });
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_com/index.js
  application.register("alert", alert_default);
  application.register("animate-typer", animate_typer_default);
  application.register("audio-player", audio_player_default);
  application.register("cable", cable_default);
  application.register("common", common_default);
  application.register("clipboard", clipboard_default);
  application.register("count-down", count_down_default);
  application.register("custom", custom_default);
  application.register("dispatch", dispatch_default);
  application.register("done", done_default);
  application.register("draw-line", draw_line_default);
  application.register("empty", empty_default);
  application.register("enter-section", enter_section_default);
  application.register("fixed-width", fixed_width_default);
  application.register("hover", hover_default);
  application.register("gif", gif_default);
  application.register("notice", notice_default);
  application.register("page", page_default);
  application.register("player", player_default);
  application.register("print", print_default);
  application.register("qy-login", qy_login_default);
  application.register("scroll", scroll_default);
  application.register("scroll-next", scroll_next_default);
  application.register("show", show_default);
  application.register("showcase", showcase_default);
  application.register("slide", slide_default);
  application.register("slide-y", slide_y_default);
  application.register("sticky-bottom", sticky_bottom_default);
  application.register("swipe", swipe_default);
  application.register("switch", switch_default);
  application.register("time", time_default);
  application.register("time-count", time_count_default);
  application.register("tree", tree_default);
  application.register("tree-remote", tree_remote_default);
  application.register("video", video_default);
  application.register("visit", visit_default);
  application.register("sortable", sortable_default);
  application.register("sort", sortable_default);
  application.register("choice", choice_default);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/coordinate/cartesian.js
  var Cartesian = () => [["cartesian"]];
  Cartesian.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/angle.js
  function convertAngles(startAngle, endAngle) {
    startAngle = startAngle % (2 * Math.PI);
    endAngle = endAngle % (2 * Math.PI);
    if (startAngle < 0) {
      startAngle = 2 * Math.PI + startAngle;
    }
    if (endAngle < 0) {
      endAngle = 2 * Math.PI + endAngle;
    }
    if (startAngle >= endAngle) {
      endAngle = endAngle + 2 * Math.PI;
    }
    return {
      startAngle,
      endAngle
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/coordinate/polar.js
  var getPolarOptions = (options = {}) => {
    const defaultOptions2 = {
      startAngle: -Math.PI / 2,
      endAngle: Math.PI * 3 / 2,
      innerRadius: 0,
      outerRadius: 1
    };
    const polarOption = Object.assign(Object.assign({}, defaultOptions2), options);
    return Object.assign(Object.assign({}, polarOption), convertAngles(polarOption.startAngle, polarOption.endAngle));
  };
  var Polar = (options) => {
    const { startAngle, endAngle, innerRadius, outerRadius } = getPolarOptions(options);
    return [
      ["translate", 0, 0.5],
      ["reflect.y"],
      ["translate", 0, -0.5],
      ["polar", startAngle, endAngle, innerRadius, outerRadius]
    ];
  };
  Polar.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/coordinate/transpose.js
  var Transpose = () => [
    ["transpose"],
    ["translate", 0.5, 0.5],
    ["reflect.x"],
    ["translate", -0.5, -0.5]
  ];
  Transpose.props = { transform: true };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/coordinate/theta.js
  var getThetaOptions = (options = {}) => {
    const defaultOptions2 = {
      startAngle: -Math.PI / 2,
      endAngle: Math.PI * 3 / 2,
      innerRadius: 0,
      outerRadius: 1
    };
    return Object.assign(Object.assign({}, defaultOptions2), options);
  };
  var Theta = (options) => {
    const { startAngle, endAngle, innerRadius, outerRadius } = getThetaOptions(options);
    return [
      ...Transpose(),
      ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
    ];
  };
  Theta.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/coordinate/radial.js
  var getRadialOptions = (options = {}) => {
    const defaultOptions2 = {
      startAngle: -Math.PI / 2,
      endAngle: Math.PI * 3 / 2,
      innerRadius: 0,
      outerRadius: 1
    };
    return Object.assign(Object.assign({}, defaultOptions2), options);
  };
  var Radial = (options) => {
    const { startAngle, endAngle, innerRadius, outerRadius } = getRadialOptions(options);
    return [
      ["transpose"],
      ["translate", 0.5, 0.5],
      ["reflect"],
      ["translate", -0.5, -0.5],
      ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
    ];
  };
  Radial.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/coordinate/parallel.js
  var Parallel = () => [["parallel", 0, 1, 0, 1]];
  Parallel.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/coordinate/fisheye.js
  var Fisheye = ({ focusX = 0, focusY = 0, distortionX = 2, distortionY = 2, visual = false }) => [["fisheye", focusX, focusY, distortionX, distortionY, visual]];
  Fisheye.props = { transform: true };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/coordinate/radar.js
  var Radar = (options) => {
    const { startAngle = -Math.PI / 2, endAngle = Math.PI * 3 / 2, innerRadius = 0, outerRadius = 1 } = options;
    return [
      ...Parallel(),
      ...Polar({ startAngle, endAngle, innerRadius, outerRadius })
    ];
  };
  Radar.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/encode/constant.js
  var Constant = ({ value: value2 }) => {
    return (data2) => data2.map(() => value2);
  };
  Constant.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/encode/transform.js
  var Transform = ({ value: value2 }) => {
    return (data2) => data2.map(value2);
  };
  Transform.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/encode/field.js
  var Field = ({ value: value2 }) => {
    return (data2) => data2.map((d2) => d2[value2]);
  };
  Field.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/encode/column.js
  var Column = ({ value: value2 }) => {
    return () => value2;
  };
  Column.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-array-like.js
  var isArrayLike = function(value2) {
    return value2 !== null && typeof value2 !== "function" && isFinite(value2.length);
  };
  var is_array_like_default = isArrayLike;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/filter.js
  var filter = function(arr, func) {
    if (!is_array_like_default(arr)) {
      return arr;
    }
    var result = [];
    for (var index4 = 0; index4 < arr.length; index4++) {
      var value2 = arr[index4];
      if (func(value2, index4)) {
        result.push(value2);
      }
    }
    return result;
  };
  var filter_default = filter;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-function.js
  var is_function_default = function(value2) {
    return typeof value2 === "function";
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-nil.js
  var isNil = function(value2) {
    return value2 === null || value2 === void 0;
  };
  var is_nil_default = isNil;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-type.js
  var toString = {}.toString;
  var isType = function(value2, type) {
    return toString.call(value2) === "[object " + type + "]";
  };
  var is_type_default = isType;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-array.js
  var is_array_default = function(value2) {
    return Array.isArray ? Array.isArray(value2) : is_type_default(value2, "Array");
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-object.js
  var is_object_default = function(value2) {
    var type = typeof value2;
    return value2 !== null && type === "object" || type === "function";
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/each.js
  function each(elements, func) {
    if (!elements) {
      return;
    }
    var rst;
    if (is_array_default(elements)) {
      for (var i = 0, len5 = elements.length; i < len5; i++) {
        rst = func(elements[i], i);
        if (rst === false) {
          break;
        }
      }
    } else if (is_object_default(elements)) {
      for (var k in elements) {
        if (elements.hasOwnProperty(k)) {
          rst = func(elements[k], k);
          if (rst === false) {
            break;
          }
        }
      }
    }
  }
  var each_default = each;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/keys.js
  var keys = Object.keys ? function(obj) {
    return Object.keys(obj);
  } : function(obj) {
    var result = [];
    each_default(obj, function(value2, key) {
      if (!(is_function_default(obj) && key === "prototype")) {
        result.push(key);
      }
    });
    return result;
  };
  var keys_default = keys;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-match.js
  function isMatch(obj, attrs) {
    var _keys = keys_default(attrs);
    var length5 = _keys.length;
    if (is_nil_default(obj))
      return !length5;
    for (var i = 0; i < length5; i += 1) {
      var key = _keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) {
        return false;
      }
    }
    return true;
  }
  var is_match_default = isMatch;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-object-like.js
  var isObjectLike = function(value2) {
    return typeof value2 === "object" && value2 !== null;
  };
  var is_object_like_default = isObjectLike;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-plain-object.js
  var isPlainObject = function(value2) {
    if (!is_object_like_default(value2) || !is_type_default(value2, "Object")) {
      return false;
    }
    if (Object.getPrototypeOf(value2) === null) {
      return true;
    }
    var proto = value2;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value2) === proto;
  };
  var is_plain_object_default = isPlainObject;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/find.js
  function find2(arr, predicate) {
    if (!is_array_default(arr))
      return null;
    var _predicate;
    if (is_function_default(predicate)) {
      _predicate = predicate;
    }
    if (is_plain_object_default(predicate)) {
      _predicate = function(a3) {
        return is_match_default(a3, predicate);
      };
    }
    if (_predicate) {
      for (var i = 0; i < arr.length; i += 1) {
        if (_predicate(arr[i])) {
          return arr[i];
        }
      }
    }
    return null;
  }
  var find_default = find2;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/reduce.js
  var reduce = function(arr, fn, init) {
    if (!is_array_default(arr) && !is_plain_object_default(arr)) {
      return arr;
    }
    var result = init;
    each_default(arr, function(data2, i) {
      result = fn(result, data2, i);
    });
    return result;
  };
  var reduce_default = reduce;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-string.js
  var is_string_default = function(str7) {
    return is_type_default(str7, "String");
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/last.js
  function last(o) {
    if (is_array_like_default(o)) {
      var arr = o;
      return arr[arr.length - 1];
    }
    return void 0;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-number.js
  var isNumber2 = function(value2) {
    return is_type_default(value2, "Number");
  };
  var is_number_default = isNumber2;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/to-string.js
  var to_string_default = function(value2) {
    if (is_nil_default(value2))
      return "";
    return value2.toString();
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/lower-first.js
  var lowerFirst = function(value2) {
    var str7 = to_string_default(value2);
    return str7.charAt(0).toLowerCase() + str7.substring(1);
  };
  var lower_first_default = lowerFirst;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/upper-first.js
  var upperFirst = function(value2) {
    var str7 = to_string_default(value2);
    return str7.charAt(0).toUpperCase() + str7.substring(1);
  };
  var upper_first_default = upperFirst;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-null.js
  var isNull = function(value2) {
    return value2 === null;
  };
  var is_null_default = isNull;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-undefined.js
  var isUndefined2 = function(value2) {
    return value2 === void 0;
  };
  var is_undefined_default = isUndefined2;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/debounce.js
  function debounce2(func, wait, immediate) {
    var timeout2;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout2 = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout2;
      clearTimeout(timeout2);
      timeout2 = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
  }
  var debounce_default = debounce2;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/deep-mix.js
  var MAX_MIX_LEVEL = 5;
  function hasOwn(object, property) {
    if (Object.hasOwn) {
      return Object.hasOwn(object, property);
    }
    if (object == null) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    return Object.prototype.hasOwnProperty.call(Object(object), property);
  }
  function _deepMix(dist5, src, level, maxLevel) {
    level = level || 0;
    maxLevel = maxLevel || MAX_MIX_LEVEL;
    for (var key in src) {
      if (hasOwn(src, key)) {
        var value2 = src[key];
        if (value2 !== null && is_plain_object_default(value2)) {
          if (!is_plain_object_default(dist5[key])) {
            dist5[key] = {};
          }
          if (level < maxLevel) {
            _deepMix(dist5[key], value2, level + 1, maxLevel);
          } else {
            dist5[key] = src[key];
          }
        } else if (is_array_default(value2)) {
          dist5[key] = [];
          dist5[key] = dist5[key].concat(value2);
        } else if (value2 !== void 0) {
          dist5[key] = value2;
        }
      }
    }
  }
  var deepMix = function(rst) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i += 1) {
      _deepMix(rst, args[i]);
    }
    return rst;
  };
  var deep_mix_default = deepMix;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/index-of.js
  var indexOf2 = function(arr, obj) {
    if (!is_array_like_default(arr)) {
      return -1;
    }
    var m3 = Array.prototype.indexOf;
    if (m3) {
      return m3.call(arr, obj);
    }
    var index4 = -1;
    for (var i = 0; i < arr.length; i++) {
      if (arr[i] === obj) {
        index4 = i;
        break;
      }
    }
    return index4;
  };
  var index_of_default = indexOf2;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/is-equal.js
  var isEqual = function(value2, other) {
    if (value2 === other) {
      return true;
    }
    if (!value2 || !other) {
      return false;
    }
    if (is_string_default(value2) || is_string_default(other)) {
      return false;
    }
    if (is_array_like_default(value2) || is_array_like_default(other)) {
      if (value2.length !== other.length) {
        return false;
      }
      var rst = true;
      for (var i = 0; i < value2.length; i++) {
        rst = isEqual(value2[i], other[i]);
        if (!rst) {
          break;
        }
      }
      return rst;
    }
    if (is_object_like_default(value2) || is_object_like_default(other)) {
      var valueKeys = Object.keys(value2);
      var otherKeys = Object.keys(other);
      if (valueKeys.length !== otherKeys.length) {
        return false;
      }
      var rst = true;
      for (var i = 0; i < valueKeys.length; i++) {
        rst = isEqual(value2[valueKeys[i]], other[valueKeys[i]]);
        if (!rst) {
          break;
        }
      }
      return rst;
    }
    return false;
  };
  var is_equal_default = isEqual;

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/get.js
  var get_default = function(obj, key, defaultValue) {
    var p2 = 0;
    var keyArr = is_string_default(key) ? key.split(".") : key;
    while (obj && p2 < keyArr.length) {
      obj = obj[keyArr[p2++]];
    }
    return obj === void 0 || p2 < keyArr.length ? defaultValue : obj;
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/pick.js
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var pick_default = function(object, keys2) {
    if (object === null || !is_plain_object_default(object)) {
      return {};
    }
    var result = {};
    each_default(keys2, function(key) {
      if (hasOwnProperty2.call(object, key)) {
        result[key] = object[key];
      }
    });
    return result;
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/omit.js
  var omit_default = function(obj, keys2) {
    return reduce_default(obj, function(r, curr, key) {
      if (!keys2.includes(key)) {
        r[key] = curr;
      }
      return r;
    }, {});
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/throttle.js
  var throttle_default = function(func, wait, options) {
    var timeout2, context, args, result;
    var previous = 0;
    if (!options)
      options = {};
    var later = function() {
      previous = options.leading === false ? 0 : Date.now();
      timeout2 = null;
      result = func.apply(context, args);
      if (!timeout2)
        context = args = null;
    };
    var throttled = function() {
      var now4 = Date.now();
      if (!previous && options.leading === false)
        previous = now4;
      var remaining = wait - (now4 - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout2) {
          clearTimeout(timeout2);
          timeout2 = null;
        }
        previous = now4;
        result = func.apply(context, args);
        if (!timeout2)
          context = args = null;
      } else if (!timeout2 && options.trailing !== false) {
        timeout2 = setTimeout(later, remaining);
      }
      return result;
    };
    throttled.cancel = function() {
      clearTimeout(timeout2);
      previous = 0;
      timeout2 = context = args = null;
    };
    return throttled;
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/identity.js
  var identity_default = function(v) {
    return v;
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/util/esm/lodash/size.js
  function size(o) {
    if (is_nil_default(o)) {
      return 0;
    }
    if (is_array_like_default(o)) {
      return o.length;
    }
    return Object.keys(o).length;
  }

  // ../../engine/rails_design/node_modules/gl-matrix/esm/common.js
  var EPSILON = 1e-6;
  var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
  var RANDOM = Math.random;
  var degree = Math.PI / 180;
  if (!Math.hypot) Math.hypot = function() {
    var y3 = 0, i = arguments.length;
    while (i--) {
      y3 += arguments[i] * arguments[i];
    }
    return Math.sqrt(y3);
  };

  // ../../engine/rails_design/node_modules/gl-matrix/esm/mat3.js
  var mat3_exports = {};
  __export(mat3_exports, {
    add: () => add2,
    adjoint: () => adjoint,
    clone: () => clone4,
    copy: () => copy,
    create: () => create,
    determinant: () => determinant,
    equals: () => equals,
    exactEquals: () => exactEquals,
    frob: () => frob,
    fromMat2d: () => fromMat2d,
    fromMat4: () => fromMat4,
    fromQuat: () => fromQuat,
    fromRotation: () => fromRotation,
    fromScaling: () => fromScaling,
    fromTranslation: () => fromTranslation,
    fromValues: () => fromValues,
    identity: () => identity,
    invert: () => invert,
    mul: () => mul,
    multiply: () => multiply,
    multiplyScalar: () => multiplyScalar,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd,
    normalFromMat4: () => normalFromMat4,
    projection: () => projection,
    rotate: () => rotate,
    scale: () => scale,
    set: () => set,
    str: () => str,
    sub: () => sub,
    subtract: () => subtract,
    translate: () => translate,
    transpose: () => transpose
  });
  function create() {
    var out = new ARRAY_TYPE(9);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[5] = 0;
      out[6] = 0;
      out[7] = 0;
    }
    out[0] = 1;
    out[4] = 1;
    out[8] = 1;
    return out;
  }
  function fromMat4(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[4];
    out[4] = a3[5];
    out[5] = a3[6];
    out[6] = a3[8];
    out[7] = a3[9];
    out[8] = a3[10];
    return out;
  }
  function clone4(a3) {
    var out = new ARRAY_TYPE(9);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    return out;
  }
  function copy(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    return out;
  }
  function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
  }
  function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function transpose(out, a3) {
    if (out === a3) {
      var a01 = a3[1], a02 = a3[2], a12 = a3[5];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a01;
      out[5] = a3[7];
      out[6] = a02;
      out[7] = a12;
    } else {
      out[0] = a3[0];
      out[1] = a3[3];
      out[2] = a3[6];
      out[3] = a3[1];
      out[4] = a3[4];
      out[5] = a3[7];
      out[6] = a3[2];
      out[7] = a3[5];
      out[8] = a3[8];
    }
    return out;
  }
  function invert(out, a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2];
    var a10 = a3[3], a11 = a3[4], a12 = a3[5];
    var a20 = a3[6], a21 = a3[7], a22 = a3[8];
    var b01 = a22 * a11 - a12 * a21;
    var b11 = -a22 * a10 + a12 * a20;
    var b21 = a21 * a10 - a11 * a20;
    var det = a00 * b01 + a01 * b11 + a02 * b21;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
  }
  function adjoint(out, a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2];
    var a10 = a3[3], a11 = a3[4], a12 = a3[5];
    var a20 = a3[6], a21 = a3[7], a22 = a3[8];
    out[0] = a11 * a22 - a12 * a21;
    out[1] = a02 * a21 - a01 * a22;
    out[2] = a01 * a12 - a02 * a11;
    out[3] = a12 * a20 - a10 * a22;
    out[4] = a00 * a22 - a02 * a20;
    out[5] = a02 * a10 - a00 * a12;
    out[6] = a10 * a21 - a11 * a20;
    out[7] = a01 * a20 - a00 * a21;
    out[8] = a00 * a11 - a01 * a10;
    return out;
  }
  function determinant(a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2];
    var a10 = a3[3], a11 = a3[4], a12 = a3[5];
    var a20 = a3[6], a21 = a3[7], a22 = a3[8];
    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
  }
  function multiply(out, a3, b) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2];
    var a10 = a3[3], a11 = a3[4], a12 = a3[5];
    var a20 = a3[6], a21 = a3[7], a22 = a3[8];
    var b00 = b[0], b01 = b[1], b02 = b[2];
    var b10 = b[3], b11 = b[4], b12 = b[5];
    var b20 = b[6], b21 = b[7], b22 = b[8];
    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;
    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;
    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
  }
  function translate(out, a3, v) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a10 = a3[3], a11 = a3[4], a12 = a3[5], a20 = a3[6], a21 = a3[7], a22 = a3[8], x3 = v[0], y3 = v[1];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a10;
    out[4] = a11;
    out[5] = a12;
    out[6] = x3 * a00 + y3 * a10 + a20;
    out[7] = x3 * a01 + y3 * a11 + a21;
    out[8] = x3 * a02 + y3 * a12 + a22;
    return out;
  }
  function rotate(out, a3, rad) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a10 = a3[3], a11 = a3[4], a12 = a3[5], a20 = a3[6], a21 = a3[7], a22 = a3[8], s2 = Math.sin(rad), c5 = Math.cos(rad);
    out[0] = c5 * a00 + s2 * a10;
    out[1] = c5 * a01 + s2 * a11;
    out[2] = c5 * a02 + s2 * a12;
    out[3] = c5 * a10 - s2 * a00;
    out[4] = c5 * a11 - s2 * a01;
    out[5] = c5 * a12 - s2 * a02;
    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
  }
  function scale(out, a3, v) {
    var x3 = v[0], y3 = v[1];
    out[0] = x3 * a3[0];
    out[1] = x3 * a3[1];
    out[2] = x3 * a3[2];
    out[3] = y3 * a3[3];
    out[4] = y3 * a3[4];
    out[5] = y3 * a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    return out;
  }
  function fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
  }
  function fromRotation(out, rad) {
    var s2 = Math.sin(rad), c5 = Math.cos(rad);
    out[0] = c5;
    out[1] = s2;
    out[2] = 0;
    out[3] = -s2;
    out[4] = c5;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
  }
  function fromMat2d(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = 0;
    out[3] = a3[2];
    out[4] = a3[3];
    out[5] = 0;
    out[6] = a3[4];
    out[7] = a3[5];
    out[8] = 1;
    return out;
  }
  function fromQuat(out, q) {
    var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
    var x22 = x3 + x3;
    var y22 = y3 + y3;
    var z2 = z + z;
    var xx = x3 * x22;
    var yx = y3 * x22;
    var yy = y3 * y22;
    var zx = z * x22;
    var zy = z * y22;
    var zz = z * z2;
    var wx2 = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;
    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx2;
    out[2] = zx - wy;
    out[5] = zy + wx2;
    out[8] = 1 - xx - yy;
    return out;
  }
  function normalFromMat4(out, a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
    var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
    var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
    var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    return out;
  }
  function projection(out, width, height) {
    out[0] = 2 / width;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = -2 / height;
    out[5] = 0;
    out[6] = -1;
    out[7] = 1;
    out[8] = 1;
    return out;
  }
  function str(a3) {
    return "mat3(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ", " + a3[4] + ", " + a3[5] + ", " + a3[6] + ", " + a3[7] + ", " + a3[8] + ")";
  }
  function frob(a3) {
    return Math.hypot(a3[0], a3[1], a3[2], a3[3], a3[4], a3[5], a3[6], a3[7], a3[8]);
  }
  function add2(out, a3, b) {
    out[0] = a3[0] + b[0];
    out[1] = a3[1] + b[1];
    out[2] = a3[2] + b[2];
    out[3] = a3[3] + b[3];
    out[4] = a3[4] + b[4];
    out[5] = a3[5] + b[5];
    out[6] = a3[6] + b[6];
    out[7] = a3[7] + b[7];
    out[8] = a3[8] + b[8];
    return out;
  }
  function subtract(out, a3, b) {
    out[0] = a3[0] - b[0];
    out[1] = a3[1] - b[1];
    out[2] = a3[2] - b[2];
    out[3] = a3[3] - b[3];
    out[4] = a3[4] - b[4];
    out[5] = a3[5] - b[5];
    out[6] = a3[6] - b[6];
    out[7] = a3[7] - b[7];
    out[8] = a3[8] - b[8];
    return out;
  }
  function multiplyScalar(out, a3, b) {
    out[0] = a3[0] * b;
    out[1] = a3[1] * b;
    out[2] = a3[2] * b;
    out[3] = a3[3] * b;
    out[4] = a3[4] * b;
    out[5] = a3[5] * b;
    out[6] = a3[6] * b;
    out[7] = a3[7] * b;
    out[8] = a3[8] * b;
    return out;
  }
  function multiplyScalarAndAdd(out, a3, b, scale9) {
    out[0] = a3[0] + b[0] * scale9;
    out[1] = a3[1] + b[1] * scale9;
    out[2] = a3[2] + b[2] * scale9;
    out[3] = a3[3] + b[3] * scale9;
    out[4] = a3[4] + b[4] * scale9;
    out[5] = a3[5] + b[5] * scale9;
    out[6] = a3[6] + b[6] * scale9;
    out[7] = a3[7] + b[7] * scale9;
    out[8] = a3[8] + b[8] * scale9;
    return out;
  }
  function exactEquals(a3, b) {
    return a3[0] === b[0] && a3[1] === b[1] && a3[2] === b[2] && a3[3] === b[3] && a3[4] === b[4] && a3[5] === b[5] && a3[6] === b[6] && a3[7] === b[7] && a3[8] === b[8];
  }
  function equals(a3, b) {
    var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3], a4 = a3[4], a5 = a3[5], a6 = a3[6], a7 = a3[7], a8 = a3[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8));
  }
  var mul = multiply;
  var sub = subtract;

  // ../../engine/rails_design/node_modules/gl-matrix/esm/mat4.js
  var mat4_exports = {};
  __export(mat4_exports, {
    add: () => add3,
    adjoint: () => adjoint2,
    clone: () => clone5,
    copy: () => copy2,
    create: () => create2,
    determinant: () => determinant2,
    equals: () => equals2,
    exactEquals: () => exactEquals2,
    frob: () => frob2,
    fromQuat: () => fromQuat3,
    fromQuat2: () => fromQuat2,
    fromRotation: () => fromRotation2,
    fromRotationTranslation: () => fromRotationTranslation,
    fromRotationTranslationScale: () => fromRotationTranslationScale,
    fromRotationTranslationScaleOrigin: () => fromRotationTranslationScaleOrigin,
    fromScaling: () => fromScaling2,
    fromTranslation: () => fromTranslation2,
    fromValues: () => fromValues2,
    fromXRotation: () => fromXRotation,
    fromYRotation: () => fromYRotation,
    fromZRotation: () => fromZRotation,
    frustum: () => frustum,
    getRotation: () => getRotation,
    getScaling: () => getScaling,
    getTranslation: () => getTranslation,
    identity: () => identity2,
    invert: () => invert2,
    lookAt: () => lookAt,
    mul: () => mul2,
    multiply: () => multiply2,
    multiplyScalar: () => multiplyScalar2,
    multiplyScalarAndAdd: () => multiplyScalarAndAdd2,
    ortho: () => ortho,
    orthoNO: () => orthoNO,
    orthoZO: () => orthoZO,
    perspective: () => perspective,
    perspectiveFromFieldOfView: () => perspectiveFromFieldOfView,
    perspectiveNO: () => perspectiveNO,
    perspectiveZO: () => perspectiveZO,
    rotate: () => rotate2,
    rotateX: () => rotateX,
    rotateY: () => rotateY,
    rotateZ: () => rotateZ,
    scale: () => scale2,
    set: () => set2,
    str: () => str2,
    sub: () => sub2,
    subtract: () => subtract2,
    targetTo: () => targetTo,
    translate: () => translate2,
    transpose: () => transpose2
  });
  function create2() {
    var out = new ARRAY_TYPE(16);
    if (ARRAY_TYPE != Float32Array) {
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
      out[4] = 0;
      out[6] = 0;
      out[7] = 0;
      out[8] = 0;
      out[9] = 0;
      out[11] = 0;
      out[12] = 0;
      out[13] = 0;
      out[14] = 0;
    }
    out[0] = 1;
    out[5] = 1;
    out[10] = 1;
    out[15] = 1;
    return out;
  }
  function clone5(a3) {
    var out = new ARRAY_TYPE(16);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    out[9] = a3[9];
    out[10] = a3[10];
    out[11] = a3[11];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function copy2(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    out[4] = a3[4];
    out[5] = a3[5];
    out[6] = a3[6];
    out[7] = a3[7];
    out[8] = a3[8];
    out[9] = a3[9];
    out[10] = a3[10];
    out[11] = a3[11];
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function fromValues2(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function set2(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
  }
  function identity2(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function transpose2(out, a3) {
    if (out === a3) {
      var a01 = a3[1], a02 = a3[2], a03 = a3[3];
      var a12 = a3[6], a13 = a3[7];
      var a23 = a3[11];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a01;
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a3[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a3[0];
      out[1] = a3[4];
      out[2] = a3[8];
      out[3] = a3[12];
      out[4] = a3[1];
      out[5] = a3[5];
      out[6] = a3[9];
      out[7] = a3[13];
      out[8] = a3[2];
      out[9] = a3[6];
      out[10] = a3[10];
      out[11] = a3[14];
      out[12] = a3[3];
      out[13] = a3[7];
      out[14] = a3[11];
      out[15] = a3[15];
    }
    return out;
  }
  function invert2(out, a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
    var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
    var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
    var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det) {
      return null;
    }
    det = 1 / det;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
    return out;
  }
  function adjoint2(out, a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
    var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
    var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
    var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
    out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
    out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
    return out;
  }
  function determinant2(a3) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
    var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
    var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
    var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
    var b00 = a00 * a11 - a01 * a10;
    var b01 = a00 * a12 - a02 * a10;
    var b02 = a00 * a13 - a03 * a10;
    var b03 = a01 * a12 - a02 * a11;
    var b04 = a01 * a13 - a03 * a11;
    var b05 = a02 * a13 - a03 * a12;
    var b06 = a20 * a31 - a21 * a30;
    var b07 = a20 * a32 - a22 * a30;
    var b08 = a20 * a33 - a23 * a30;
    var b09 = a21 * a32 - a22 * a31;
    var b10 = a21 * a33 - a23 * a31;
    var b11 = a22 * a33 - a23 * a32;
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  }
  function multiply2(out, a3, b) {
    var a00 = a3[0], a01 = a3[1], a02 = a3[2], a03 = a3[3];
    var a10 = a3[4], a11 = a3[5], a12 = a3[6], a13 = a3[7];
    var a20 = a3[8], a21 = a3[9], a22 = a3[10], a23 = a3[11];
    var a30 = a3[12], a31 = a3[13], a32 = a3[14], a33 = a3[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  function translate2(out, a3, v) {
    var x3 = v[0], y3 = v[1], z = v[2];
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    if (a3 === out) {
      out[12] = a3[0] * x3 + a3[4] * y3 + a3[8] * z + a3[12];
      out[13] = a3[1] * x3 + a3[5] * y3 + a3[9] * z + a3[13];
      out[14] = a3[2] * x3 + a3[6] * y3 + a3[10] * z + a3[14];
      out[15] = a3[3] * x3 + a3[7] * y3 + a3[11] * z + a3[15];
    } else {
      a00 = a3[0];
      a01 = a3[1];
      a02 = a3[2];
      a03 = a3[3];
      a10 = a3[4];
      a11 = a3[5];
      a12 = a3[6];
      a13 = a3[7];
      a20 = a3[8];
      a21 = a3[9];
      a22 = a3[10];
      a23 = a3[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x3 + a10 * y3 + a20 * z + a3[12];
      out[13] = a01 * x3 + a11 * y3 + a21 * z + a3[13];
      out[14] = a02 * x3 + a12 * y3 + a22 * z + a3[14];
      out[15] = a03 * x3 + a13 * y3 + a23 * z + a3[15];
    }
    return out;
  }
  function scale2(out, a3, v) {
    var x3 = v[0], y3 = v[1], z = v[2];
    out[0] = a3[0] * x3;
    out[1] = a3[1] * x3;
    out[2] = a3[2] * x3;
    out[3] = a3[3] * x3;
    out[4] = a3[4] * y3;
    out[5] = a3[5] * y3;
    out[6] = a3[6] * y3;
    out[7] = a3[7] * y3;
    out[8] = a3[8] * z;
    out[9] = a3[9] * z;
    out[10] = a3[10] * z;
    out[11] = a3[11] * z;
    out[12] = a3[12];
    out[13] = a3[13];
    out[14] = a3[14];
    out[15] = a3[15];
    return out;
  }
  function rotate2(out, a3, rad, axis) {
    var x3 = axis[0], y3 = axis[1], z = axis[2];
    var len5 = Math.hypot(x3, y3, z);
    var s2, c5, t;
    var a00, a01, a02, a03;
    var a10, a11, a12, a13;
    var a20, a21, a22, a23;
    var b00, b01, b02;
    var b10, b11, b12;
    var b20, b21, b22;
    if (len5 < EPSILON) {
      return null;
    }
    len5 = 1 / len5;
    x3 *= len5;
    y3 *= len5;
    z *= len5;
    s2 = Math.sin(rad);
    c5 = Math.cos(rad);
    t = 1 - c5;
    a00 = a3[0];
    a01 = a3[1];
    a02 = a3[2];
    a03 = a3[3];
    a10 = a3[4];
    a11 = a3[5];
    a12 = a3[6];
    a13 = a3[7];
    a20 = a3[8];
    a21 = a3[9];
    a22 = a3[10];
    a23 = a3[11];
    b00 = x3 * x3 * t + c5;
    b01 = y3 * x3 * t + z * s2;
    b02 = z * x3 * t - y3 * s2;
    b10 = x3 * y3 * t - z * s2;
    b11 = y3 * y3 * t + c5;
    b12 = z * y3 * t + x3 * s2;
    b20 = x3 * z * t + y3 * s2;
    b21 = y3 * z * t - x3 * s2;
    b22 = z * z * t + c5;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a3 !== out) {
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    return out;
  }
  function rotateX(out, a3, rad) {
    var s2 = Math.sin(rad);
    var c5 = Math.cos(rad);
    var a10 = a3[4];
    var a11 = a3[5];
    var a12 = a3[6];
    var a13 = a3[7];
    var a20 = a3[8];
    var a21 = a3[9];
    var a22 = a3[10];
    var a23 = a3[11];
    if (a3 !== out) {
      out[0] = a3[0];
      out[1] = a3[1];
      out[2] = a3[2];
      out[3] = a3[3];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[4] = a10 * c5 + a20 * s2;
    out[5] = a11 * c5 + a21 * s2;
    out[6] = a12 * c5 + a22 * s2;
    out[7] = a13 * c5 + a23 * s2;
    out[8] = a20 * c5 - a10 * s2;
    out[9] = a21 * c5 - a11 * s2;
    out[10] = a22 * c5 - a12 * s2;
    out[11] = a23 * c5 - a13 * s2;
    return out;
  }
  function rotateY(out, a3, rad) {
    var s2 = Math.sin(rad);
    var c5 = Math.cos(rad);
    var a00 = a3[0];
    var a01 = a3[1];
    var a02 = a3[2];
    var a03 = a3[3];
    var a20 = a3[8];
    var a21 = a3[9];
    var a22 = a3[10];
    var a23 = a3[11];
    if (a3 !== out) {
      out[4] = a3[4];
      out[5] = a3[5];
      out[6] = a3[6];
      out[7] = a3[7];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c5 - a20 * s2;
    out[1] = a01 * c5 - a21 * s2;
    out[2] = a02 * c5 - a22 * s2;
    out[3] = a03 * c5 - a23 * s2;
    out[8] = a00 * s2 + a20 * c5;
    out[9] = a01 * s2 + a21 * c5;
    out[10] = a02 * s2 + a22 * c5;
    out[11] = a03 * s2 + a23 * c5;
    return out;
  }
  function rotateZ(out, a3, rad) {
    var s2 = Math.sin(rad);
    var c5 = Math.cos(rad);
    var a00 = a3[0];
    var a01 = a3[1];
    var a02 = a3[2];
    var a03 = a3[3];
    var a10 = a3[4];
    var a11 = a3[5];
    var a12 = a3[6];
    var a13 = a3[7];
    if (a3 !== out) {
      out[8] = a3[8];
      out[9] = a3[9];
      out[10] = a3[10];
      out[11] = a3[11];
      out[12] = a3[12];
      out[13] = a3[13];
      out[14] = a3[14];
      out[15] = a3[15];
    }
    out[0] = a00 * c5 + a10 * s2;
    out[1] = a01 * c5 + a11 * s2;
    out[2] = a02 * c5 + a12 * s2;
    out[3] = a03 * c5 + a13 * s2;
    out[4] = a10 * c5 - a00 * s2;
    out[5] = a11 * c5 - a01 * s2;
    out[6] = a12 * c5 - a02 * s2;
    out[7] = a13 * c5 - a03 * s2;
    return out;
  }
  function fromTranslation2(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromScaling2(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotation2(out, rad, axis) {
    var x3 = axis[0], y3 = axis[1], z = axis[2];
    var len5 = Math.hypot(x3, y3, z);
    var s2, c5, t;
    if (len5 < EPSILON) {
      return null;
    }
    len5 = 1 / len5;
    x3 *= len5;
    y3 *= len5;
    z *= len5;
    s2 = Math.sin(rad);
    c5 = Math.cos(rad);
    t = 1 - c5;
    out[0] = x3 * x3 * t + c5;
    out[1] = y3 * x3 * t + z * s2;
    out[2] = z * x3 * t - y3 * s2;
    out[3] = 0;
    out[4] = x3 * y3 * t - z * s2;
    out[5] = y3 * y3 * t + c5;
    out[6] = z * y3 * t + x3 * s2;
    out[7] = 0;
    out[8] = x3 * z * t + y3 * s2;
    out[9] = y3 * z * t - x3 * s2;
    out[10] = z * z * t + c5;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromXRotation(out, rad) {
    var s2 = Math.sin(rad);
    var c5 = Math.cos(rad);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c5;
    out[6] = s2;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s2;
    out[10] = c5;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromYRotation(out, rad) {
    var s2 = Math.sin(rad);
    var c5 = Math.cos(rad);
    out[0] = c5;
    out[1] = 0;
    out[2] = -s2;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s2;
    out[9] = 0;
    out[10] = c5;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromZRotation(out, rad) {
    var s2 = Math.sin(rad);
    var c5 = Math.cos(rad);
    out[0] = c5;
    out[1] = s2;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s2;
    out[5] = c5;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function fromRotationTranslation(out, q, v) {
    var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
    var x22 = x3 + x3;
    var y22 = y3 + y3;
    var z2 = z + z;
    var xx = x3 * x22;
    var xy = x3 * y22;
    var xz = x3 * z2;
    var yy = y3 * y22;
    var yz = y3 * z2;
    var zz = z * z2;
    var wx2 = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx2;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx2;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromQuat2(out, a3) {
    var translation = new ARRAY_TYPE(3);
    var bx = -a3[0], by = -a3[1], bz = -a3[2], bw = a3[3], ax = a3[4], ay = a3[5], az = a3[6], aw = a3[7];
    var magnitude = bx * bx + by * by + bz * bz + bw * bw;
    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    fromRotationTranslation(out, a3, translation);
    return out;
  }
  function getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  function getScaling(out, mat) {
    var m11 = mat[0];
    var m12 = mat[1];
    var m13 = mat[2];
    var m21 = mat[4];
    var m22 = mat[5];
    var m23 = mat[6];
    var m31 = mat[8];
    var m32 = mat[9];
    var m33 = mat[10];
    out[0] = Math.hypot(m11, m12, m13);
    out[1] = Math.hypot(m21, m22, m23);
    out[2] = Math.hypot(m31, m32, m33);
    return out;
  }
  function getRotation(out, mat) {
    var scaling = new ARRAY_TYPE(3);
    getScaling(scaling, mat);
    var is1 = 1 / scaling[0];
    var is2 = 1 / scaling[1];
    var is3 = 1 / scaling[2];
    var sm11 = mat[0] * is1;
    var sm12 = mat[1] * is2;
    var sm13 = mat[2] * is3;
    var sm21 = mat[4] * is1;
    var sm22 = mat[5] * is2;
    var sm23 = mat[6] * is3;
    var sm31 = mat[8] * is1;
    var sm32 = mat[9] * is2;
    var sm33 = mat[10] * is3;
    var trace = sm11 + sm22 + sm33;
    var S = 0;
    if (trace > 0) {
      S = Math.sqrt(trace + 1) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }
    return out;
  }
  function fromRotationTranslationScale(out, q, v, s2) {
    var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
    var x22 = x3 + x3;
    var y22 = y3 + y3;
    var z2 = z + z;
    var xx = x3 * x22;
    var xy = x3 * y22;
    var xz = x3 * z2;
    var yy = y3 * y22;
    var yz = y3 * z2;
    var zz = z * z2;
    var wx2 = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    var sx = s2[0];
    var sy = s2[1];
    var sz = s2[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx2) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx2) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  function fromRotationTranslationScaleOrigin(out, q, v, s2, o) {
    var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
    var x22 = x3 + x3;
    var y22 = y3 + y3;
    var z2 = z + z;
    var xx = x3 * x22;
    var xy = x3 * y22;
    var xz = x3 * z2;
    var yy = y3 * y22;
    var yz = y3 * z2;
    var zz = z * z2;
    var wx2 = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    var sx = s2[0];
    var sy = s2[1];
    var sz = s2[2];
    var ox = o[0];
    var oy = o[1];
    var oz = o[2];
    var out0 = (1 - (yy + zz)) * sx;
    var out1 = (xy + wz) * sx;
    var out2 = (xz - wy) * sx;
    var out4 = (xy - wz) * sy;
    var out5 = (1 - (xx + zz)) * sy;
    var out6 = (yz + wx2) * sy;
    var out8 = (xz + wy) * sz;
    var out9 = (yz - wx2) * sz;
    var out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  function fromQuat3(out, q) {
    var x3 = q[0], y3 = q[1], z = q[2], w = q[3];
    var x22 = x3 + x3;
    var y22 = y3 + y3;
    var z2 = z + z;
    var xx = x3 * x22;
    var yx = y3 * x22;
    var yy = y3 * y22;
    var zx = z * x22;
    var zy = z * y22;
    var zz = z * z2;
    var wx2 = w * x22;
    var wy = w * y22;
    var wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx2;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx2;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  function frustum(out, left2, right2, bottom, top, near, far) {
    var rl = 1 / (right2 - left2);
    var tb = 1 / (top - bottom);
    var nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right2 + left2) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  function perspectiveNO(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  var perspective = perspectiveNO;
  function perspectiveZO(out, fovy, aspect, near, far) {
    var f = 1 / Math.tan(fovy / 2), nf;
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      nf = 1 / (near - far);
      out[10] = far * nf;
      out[14] = far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -near;
    }
    return out;
  }
  function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    var downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    var xScale = 2 / (leftTan + rightTan);
    var yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
  }
  function orthoNO(out, left2, right2, bottom, top, near, far) {
    var lr = 1 / (left2 - right2);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left2 + right2) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  var ortho = orthoNO;
  function orthoZO(out, left2, right2, bottom, top, near, far) {
    var lr = 1 / (left2 - right2);
    var bt = 1 / (bottom - top);
    var nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left2 + right2) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
  }
  function lookAt(out, eye, center2, up) {
    var x05, x12, x22, y05, y12, y22, z0, z1, z2, len5;
    var eyex = eye[0];
    var eyey = eye[1];
    var eyez = eye[2];
    var upx = up[0];
    var upy = up[1];
    var upz = up[2];
    var centerx = center2[0];
    var centery = center2[1];
    var centerz = center2[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return identity2(out);
    }
    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;
    len5 = 1 / Math.hypot(z0, z1, z2);
    z0 *= len5;
    z1 *= len5;
    z2 *= len5;
    x05 = upy * z2 - upz * z1;
    x12 = upz * z0 - upx * z2;
    x22 = upx * z1 - upy * z0;
    len5 = Math.hypot(x05, x12, x22);
    if (!len5) {
      x05 = 0;
      x12 = 0;
      x22 = 0;
    } else {
      len5 = 1 / len5;
      x05 *= len5;
      x12 *= len5;
      x22 *= len5;
    }
    y05 = z1 * x22 - z2 * x12;
    y12 = z2 * x05 - z0 * x22;
    y22 = z0 * x12 - z1 * x05;
    len5 = Math.hypot(y05, y12, y22);
    if (!len5) {
      y05 = 0;
      y12 = 0;
      y22 = 0;
    } else {
      len5 = 1 / len5;
      y05 *= len5;
      y12 *= len5;
      y22 *= len5;
    }
    out[0] = x05;
    out[1] = y05;
    out[2] = z0;
    out[3] = 0;
    out[4] = x12;
    out[5] = y12;
    out[6] = z1;
    out[7] = 0;
    out[8] = x22;
    out[9] = y22;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x05 * eyex + x12 * eyey + x22 * eyez);
    out[13] = -(y05 * eyex + y12 * eyey + y22 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  function targetTo(out, eye, target, up) {
    var eyex = eye[0], eyey = eye[1], eyez = eye[2], upx = up[0], upy = up[1], upz = up[2];
    var z0 = eyex - target[0], z1 = eyey - target[1], z2 = eyez - target[2];
    var len5 = z0 * z0 + z1 * z1 + z2 * z2;
    if (len5 > 0) {
      len5 = 1 / Math.sqrt(len5);
      z0 *= len5;
      z1 *= len5;
      z2 *= len5;
    }
    var x05 = upy * z2 - upz * z1, x12 = upz * z0 - upx * z2, x22 = upx * z1 - upy * z0;
    len5 = x05 * x05 + x12 * x12 + x22 * x22;
    if (len5 > 0) {
      len5 = 1 / Math.sqrt(len5);
      x05 *= len5;
      x12 *= len5;
      x22 *= len5;
    }
    out[0] = x05;
    out[1] = x12;
    out[2] = x22;
    out[3] = 0;
    out[4] = z1 * x22 - z2 * x12;
    out[5] = z2 * x05 - z0 * x22;
    out[6] = z0 * x12 - z1 * x05;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  function str2(a3) {
    return "mat4(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ", " + a3[4] + ", " + a3[5] + ", " + a3[6] + ", " + a3[7] + ", " + a3[8] + ", " + a3[9] + ", " + a3[10] + ", " + a3[11] + ", " + a3[12] + ", " + a3[13] + ", " + a3[14] + ", " + a3[15] + ")";
  }
  function frob2(a3) {
    return Math.hypot(a3[0], a3[1], a3[2], a3[3], a3[4], a3[5], a3[6], a3[7], a3[8], a3[9], a3[10], a3[11], a3[12], a3[13], a3[14], a3[15]);
  }
  function add3(out, a3, b) {
    out[0] = a3[0] + b[0];
    out[1] = a3[1] + b[1];
    out[2] = a3[2] + b[2];
    out[3] = a3[3] + b[3];
    out[4] = a3[4] + b[4];
    out[5] = a3[5] + b[5];
    out[6] = a3[6] + b[6];
    out[7] = a3[7] + b[7];
    out[8] = a3[8] + b[8];
    out[9] = a3[9] + b[9];
    out[10] = a3[10] + b[10];
    out[11] = a3[11] + b[11];
    out[12] = a3[12] + b[12];
    out[13] = a3[13] + b[13];
    out[14] = a3[14] + b[14];
    out[15] = a3[15] + b[15];
    return out;
  }
  function subtract2(out, a3, b) {
    out[0] = a3[0] - b[0];
    out[1] = a3[1] - b[1];
    out[2] = a3[2] - b[2];
    out[3] = a3[3] - b[3];
    out[4] = a3[4] - b[4];
    out[5] = a3[5] - b[5];
    out[6] = a3[6] - b[6];
    out[7] = a3[7] - b[7];
    out[8] = a3[8] - b[8];
    out[9] = a3[9] - b[9];
    out[10] = a3[10] - b[10];
    out[11] = a3[11] - b[11];
    out[12] = a3[12] - b[12];
    out[13] = a3[13] - b[13];
    out[14] = a3[14] - b[14];
    out[15] = a3[15] - b[15];
    return out;
  }
  function multiplyScalar2(out, a3, b) {
    out[0] = a3[0] * b;
    out[1] = a3[1] * b;
    out[2] = a3[2] * b;
    out[3] = a3[3] * b;
    out[4] = a3[4] * b;
    out[5] = a3[5] * b;
    out[6] = a3[6] * b;
    out[7] = a3[7] * b;
    out[8] = a3[8] * b;
    out[9] = a3[9] * b;
    out[10] = a3[10] * b;
    out[11] = a3[11] * b;
    out[12] = a3[12] * b;
    out[13] = a3[13] * b;
    out[14] = a3[14] * b;
    out[15] = a3[15] * b;
    return out;
  }
  function multiplyScalarAndAdd2(out, a3, b, scale9) {
    out[0] = a3[0] + b[0] * scale9;
    out[1] = a3[1] + b[1] * scale9;
    out[2] = a3[2] + b[2] * scale9;
    out[3] = a3[3] + b[3] * scale9;
    out[4] = a3[4] + b[4] * scale9;
    out[5] = a3[5] + b[5] * scale9;
    out[6] = a3[6] + b[6] * scale9;
    out[7] = a3[7] + b[7] * scale9;
    out[8] = a3[8] + b[8] * scale9;
    out[9] = a3[9] + b[9] * scale9;
    out[10] = a3[10] + b[10] * scale9;
    out[11] = a3[11] + b[11] * scale9;
    out[12] = a3[12] + b[12] * scale9;
    out[13] = a3[13] + b[13] * scale9;
    out[14] = a3[14] + b[14] * scale9;
    out[15] = a3[15] + b[15] * scale9;
    return out;
  }
  function exactEquals2(a3, b) {
    return a3[0] === b[0] && a3[1] === b[1] && a3[2] === b[2] && a3[3] === b[3] && a3[4] === b[4] && a3[5] === b[5] && a3[6] === b[6] && a3[7] === b[7] && a3[8] === b[8] && a3[9] === b[9] && a3[10] === b[10] && a3[11] === b[11] && a3[12] === b[12] && a3[13] === b[13] && a3[14] === b[14] && a3[15] === b[15];
  }
  function equals2(a3, b) {
    var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
    var a4 = a3[4], a5 = a3[5], a6 = a3[6], a7 = a3[7];
    var a8 = a3[8], a9 = a3[9], a10 = a3[10], a11 = a3[11];
    var a12 = a3[12], a13 = a3[13], a14 = a3[14], a15 = a3[15];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    var b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7];
    var b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11];
    var b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
  }
  var mul2 = multiply2;
  var sub2 = subtract2;

  // ../../engine/rails_design/node_modules/gl-matrix/esm/quat.js
  var quat_exports = {};
  __export(quat_exports, {
    add: () => add6,
    calculateW: () => calculateW,
    clone: () => clone8,
    conjugate: () => conjugate,
    copy: () => copy5,
    create: () => create5,
    dot: () => dot3,
    equals: () => equals5,
    exactEquals: () => exactEquals5,
    exp: () => exp,
    fromEuler: () => fromEuler,
    fromMat3: () => fromMat3,
    fromValues: () => fromValues5,
    getAngle: () => getAngle,
    getAxisAngle: () => getAxisAngle,
    identity: () => identity3,
    invert: () => invert3,
    len: () => len3,
    length: () => length3,
    lerp: () => lerp3,
    ln: () => ln,
    mul: () => mul5,
    multiply: () => multiply5,
    normalize: () => normalize3,
    pow: () => pow,
    random: () => random3,
    rotateX: () => rotateX3,
    rotateY: () => rotateY3,
    rotateZ: () => rotateZ3,
    rotationTo: () => rotationTo,
    scale: () => scale5,
    set: () => set5,
    setAxes: () => setAxes,
    setAxisAngle: () => setAxisAngle,
    slerp: () => slerp,
    sqlerp: () => sqlerp,
    sqrLen: () => sqrLen3,
    squaredLength: () => squaredLength3,
    str: () => str5
  });

  // ../../engine/rails_design/node_modules/gl-matrix/esm/vec3.js
  var vec3_exports = {};
  __export(vec3_exports, {
    add: () => add4,
    angle: () => angle,
    bezier: () => bezier,
    ceil: () => ceil,
    clone: () => clone6,
    copy: () => copy3,
    create: () => create3,
    cross: () => cross,
    dist: () => dist,
    distance: () => distance,
    div: () => div,
    divide: () => divide,
    dot: () => dot,
    equals: () => equals3,
    exactEquals: () => exactEquals3,
    floor: () => floor,
    forEach: () => forEach,
    fromValues: () => fromValues3,
    hermite: () => hermite,
    inverse: () => inverse,
    len: () => len,
    length: () => length,
    lerp: () => lerp,
    max: () => max,
    min: () => min,
    mul: () => mul3,
    multiply: () => multiply3,
    negate: () => negate,
    normalize: () => normalize,
    random: () => random,
    rotateX: () => rotateX2,
    rotateY: () => rotateY2,
    rotateZ: () => rotateZ2,
    round: () => round,
    scale: () => scale3,
    scaleAndAdd: () => scaleAndAdd,
    set: () => set3,
    sqrDist: () => sqrDist,
    sqrLen: () => sqrLen,
    squaredDistance: () => squaredDistance,
    squaredLength: () => squaredLength,
    str: () => str3,
    sub: () => sub3,
    subtract: () => subtract3,
    transformMat3: () => transformMat3,
    transformMat4: () => transformMat4,
    transformQuat: () => transformQuat,
    zero: () => zero
  });
  function create3() {
    var out = new ARRAY_TYPE(3);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    return out;
  }
  function clone6(a3) {
    var out = new ARRAY_TYPE(3);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    return out;
  }
  function length(a3) {
    var x3 = a3[0];
    var y3 = a3[1];
    var z = a3[2];
    return Math.hypot(x3, y3, z);
  }
  function fromValues3(x3, y3, z) {
    var out = new ARRAY_TYPE(3);
    out[0] = x3;
    out[1] = y3;
    out[2] = z;
    return out;
  }
  function copy3(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    return out;
  }
  function set3(out, x3, y3, z) {
    out[0] = x3;
    out[1] = y3;
    out[2] = z;
    return out;
  }
  function add4(out, a3, b) {
    out[0] = a3[0] + b[0];
    out[1] = a3[1] + b[1];
    out[2] = a3[2] + b[2];
    return out;
  }
  function subtract3(out, a3, b) {
    out[0] = a3[0] - b[0];
    out[1] = a3[1] - b[1];
    out[2] = a3[2] - b[2];
    return out;
  }
  function multiply3(out, a3, b) {
    out[0] = a3[0] * b[0];
    out[1] = a3[1] * b[1];
    out[2] = a3[2] * b[2];
    return out;
  }
  function divide(out, a3, b) {
    out[0] = a3[0] / b[0];
    out[1] = a3[1] / b[1];
    out[2] = a3[2] / b[2];
    return out;
  }
  function ceil(out, a3) {
    out[0] = Math.ceil(a3[0]);
    out[1] = Math.ceil(a3[1]);
    out[2] = Math.ceil(a3[2]);
    return out;
  }
  function floor(out, a3) {
    out[0] = Math.floor(a3[0]);
    out[1] = Math.floor(a3[1]);
    out[2] = Math.floor(a3[2]);
    return out;
  }
  function min(out, a3, b) {
    out[0] = Math.min(a3[0], b[0]);
    out[1] = Math.min(a3[1], b[1]);
    out[2] = Math.min(a3[2], b[2]);
    return out;
  }
  function max(out, a3, b) {
    out[0] = Math.max(a3[0], b[0]);
    out[1] = Math.max(a3[1], b[1]);
    out[2] = Math.max(a3[2], b[2]);
    return out;
  }
  function round(out, a3) {
    out[0] = Math.round(a3[0]);
    out[1] = Math.round(a3[1]);
    out[2] = Math.round(a3[2]);
    return out;
  }
  function scale3(out, a3, b) {
    out[0] = a3[0] * b;
    out[1] = a3[1] * b;
    out[2] = a3[2] * b;
    return out;
  }
  function scaleAndAdd(out, a3, b, scale9) {
    out[0] = a3[0] + b[0] * scale9;
    out[1] = a3[1] + b[1] * scale9;
    out[2] = a3[2] + b[2] * scale9;
    return out;
  }
  function distance(a3, b) {
    var x3 = b[0] - a3[0];
    var y3 = b[1] - a3[1];
    var z = b[2] - a3[2];
    return Math.hypot(x3, y3, z);
  }
  function squaredDistance(a3, b) {
    var x3 = b[0] - a3[0];
    var y3 = b[1] - a3[1];
    var z = b[2] - a3[2];
    return x3 * x3 + y3 * y3 + z * z;
  }
  function squaredLength(a3) {
    var x3 = a3[0];
    var y3 = a3[1];
    var z = a3[2];
    return x3 * x3 + y3 * y3 + z * z;
  }
  function negate(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    return out;
  }
  function inverse(out, a3) {
    out[0] = 1 / a3[0];
    out[1] = 1 / a3[1];
    out[2] = 1 / a3[2];
    return out;
  }
  function normalize(out, a3) {
    var x3 = a3[0];
    var y3 = a3[1];
    var z = a3[2];
    var len5 = x3 * x3 + y3 * y3 + z * z;
    if (len5 > 0) {
      len5 = 1 / Math.sqrt(len5);
    }
    out[0] = a3[0] * len5;
    out[1] = a3[1] * len5;
    out[2] = a3[2] * len5;
    return out;
  }
  function dot(a3, b) {
    return a3[0] * b[0] + a3[1] * b[1] + a3[2] * b[2];
  }
  function cross(out, a3, b) {
    var ax = a3[0], ay = a3[1], az = a3[2];
    var bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  function lerp(out, a3, b, t) {
    var ax = a3[0];
    var ay = a3[1];
    var az = a3[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  function hermite(out, a3, b, c5, d2, t) {
    var factorTimes2 = t * t;
    var factor1 = factorTimes2 * (2 * t - 3) + 1;
    var factor2 = factorTimes2 * (t - 2) + t;
    var factor3 = factorTimes2 * (t - 1);
    var factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a3[0] * factor1 + b[0] * factor2 + c5[0] * factor3 + d2[0] * factor4;
    out[1] = a3[1] * factor1 + b[1] * factor2 + c5[1] * factor3 + d2[1] * factor4;
    out[2] = a3[2] * factor1 + b[2] * factor2 + c5[2] * factor3 + d2[2] * factor4;
    return out;
  }
  function bezier(out, a3, b, c5, d2, t) {
    var inverseFactor = 1 - t;
    var inverseFactorTimesTwo = inverseFactor * inverseFactor;
    var factorTimes2 = t * t;
    var factor1 = inverseFactorTimesTwo * inverseFactor;
    var factor2 = 3 * t * inverseFactorTimesTwo;
    var factor3 = 3 * factorTimes2 * inverseFactor;
    var factor4 = factorTimes2 * t;
    out[0] = a3[0] * factor1 + b[0] * factor2 + c5[0] * factor3 + d2[0] * factor4;
    out[1] = a3[1] * factor1 + b[1] * factor2 + c5[1] * factor3 + d2[1] * factor4;
    out[2] = a3[2] * factor1 + b[2] * factor2 + c5[2] * factor3 + d2[2] * factor4;
    return out;
  }
  function random(out, scale9) {
    scale9 = scale9 || 1;
    var r = RANDOM() * 2 * Math.PI;
    var z = RANDOM() * 2 - 1;
    var zScale = Math.sqrt(1 - z * z) * scale9;
    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale9;
    return out;
  }
  function transformMat4(out, a3, m3) {
    var x3 = a3[0], y3 = a3[1], z = a3[2];
    var w = m3[3] * x3 + m3[7] * y3 + m3[11] * z + m3[15];
    w = w || 1;
    out[0] = (m3[0] * x3 + m3[4] * y3 + m3[8] * z + m3[12]) / w;
    out[1] = (m3[1] * x3 + m3[5] * y3 + m3[9] * z + m3[13]) / w;
    out[2] = (m3[2] * x3 + m3[6] * y3 + m3[10] * z + m3[14]) / w;
    return out;
  }
  function transformMat3(out, a3, m3) {
    var x3 = a3[0], y3 = a3[1], z = a3[2];
    out[0] = x3 * m3[0] + y3 * m3[3] + z * m3[6];
    out[1] = x3 * m3[1] + y3 * m3[4] + z * m3[7];
    out[2] = x3 * m3[2] + y3 * m3[5] + z * m3[8];
    return out;
  }
  function transformQuat(out, a3, q) {
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var x3 = a3[0], y3 = a3[1], z = a3[2];
    var uvx = qy * z - qz * y3, uvy = qz * x3 - qx * z, uvz = qx * y3 - qy * x3;
    var uuvx = qy * uvz - qz * uvy, uuvy = qz * uvx - qx * uvz, uuvz = qx * uvy - qy * uvx;
    var w2 = qw * 2;
    uvx *= w2;
    uvy *= w2;
    uvz *= w2;
    uuvx *= 2;
    uuvy *= 2;
    uuvz *= 2;
    out[0] = x3 + uvx + uuvx;
    out[1] = y3 + uvy + uuvy;
    out[2] = z + uvz + uuvz;
    return out;
  }
  function rotateX2(out, a3, b, rad) {
    var p2 = [], r = [];
    p2[0] = a3[0] - b[0];
    p2[1] = a3[1] - b[1];
    p2[2] = a3[2] - b[2];
    r[0] = p2[0];
    r[1] = p2[1] * Math.cos(rad) - p2[2] * Math.sin(rad);
    r[2] = p2[1] * Math.sin(rad) + p2[2] * Math.cos(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateY2(out, a3, b, rad) {
    var p2 = [], r = [];
    p2[0] = a3[0] - b[0];
    p2[1] = a3[1] - b[1];
    p2[2] = a3[2] - b[2];
    r[0] = p2[2] * Math.sin(rad) + p2[0] * Math.cos(rad);
    r[1] = p2[1];
    r[2] = p2[2] * Math.cos(rad) - p2[0] * Math.sin(rad);
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function rotateZ2(out, a3, b, rad) {
    var p2 = [], r = [];
    p2[0] = a3[0] - b[0];
    p2[1] = a3[1] - b[1];
    p2[2] = a3[2] - b[2];
    r[0] = p2[0] * Math.cos(rad) - p2[1] * Math.sin(rad);
    r[1] = p2[0] * Math.sin(rad) + p2[1] * Math.cos(rad);
    r[2] = p2[2];
    out[0] = r[0] + b[0];
    out[1] = r[1] + b[1];
    out[2] = r[2] + b[2];
    return out;
  }
  function angle(a3, b) {
    var ax = a3[0], ay = a3[1], az = a3[2], bx = b[0], by = b[1], bz = b[2], mag1 = Math.sqrt(ax * ax + ay * ay + az * az), mag2 = Math.sqrt(bx * bx + by * by + bz * bz), mag = mag1 * mag2, cosine = mag && dot(a3, b) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  function str3(a3) {
    return "vec3(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ")";
  }
  function exactEquals3(a3, b) {
    return a3[0] === b[0] && a3[1] === b[1] && a3[2] === b[2];
  }
  function equals3(a3, b) {
    var a0 = a3[0], a1 = a3[1], a22 = a3[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2));
  }
  var sub3 = subtract3;
  var mul3 = multiply3;
  var div = divide;
  var dist = distance;
  var sqrDist = squaredDistance;
  var len = length;
  var sqrLen = squaredLength;
  var forEach = function() {
    var vec = create3();
    return function(a3, stride, offset3, count4, fn, arg) {
      var i, l2;
      if (!stride) {
        stride = 3;
      }
      if (!offset3) {
        offset3 = 0;
      }
      if (count4) {
        l2 = Math.min(count4 * stride + offset3, a3.length);
      } else {
        l2 = a3.length;
      }
      for (i = offset3; i < l2; i += stride) {
        vec[0] = a3[i];
        vec[1] = a3[i + 1];
        vec[2] = a3[i + 2];
        fn(vec, vec, arg);
        a3[i] = vec[0];
        a3[i + 1] = vec[1];
        a3[i + 2] = vec[2];
      }
      return a3;
    };
  }();

  // ../../engine/rails_design/node_modules/gl-matrix/esm/vec4.js
  var vec4_exports = {};
  __export(vec4_exports, {
    add: () => add5,
    ceil: () => ceil2,
    clone: () => clone7,
    copy: () => copy4,
    create: () => create4,
    cross: () => cross2,
    dist: () => dist2,
    distance: () => distance2,
    div: () => div2,
    divide: () => divide2,
    dot: () => dot2,
    equals: () => equals4,
    exactEquals: () => exactEquals4,
    floor: () => floor2,
    forEach: () => forEach2,
    fromValues: () => fromValues4,
    inverse: () => inverse2,
    len: () => len2,
    length: () => length2,
    lerp: () => lerp2,
    max: () => max2,
    min: () => min2,
    mul: () => mul4,
    multiply: () => multiply4,
    negate: () => negate2,
    normalize: () => normalize2,
    random: () => random2,
    round: () => round2,
    scale: () => scale4,
    scaleAndAdd: () => scaleAndAdd2,
    set: () => set4,
    sqrDist: () => sqrDist2,
    sqrLen: () => sqrLen2,
    squaredDistance: () => squaredDistance2,
    squaredLength: () => squaredLength2,
    str: () => str4,
    sub: () => sub4,
    subtract: () => subtract4,
    transformMat4: () => transformMat42,
    transformQuat: () => transformQuat2,
    zero: () => zero2
  });
  function create4() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 0;
    }
    return out;
  }
  function clone7(a3) {
    var out = new ARRAY_TYPE(4);
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    return out;
  }
  function fromValues4(x3, y3, z, w) {
    var out = new ARRAY_TYPE(4);
    out[0] = x3;
    out[1] = y3;
    out[2] = z;
    out[3] = w;
    return out;
  }
  function copy4(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    out[2] = a3[2];
    out[3] = a3[3];
    return out;
  }
  function set4(out, x3, y3, z, w) {
    out[0] = x3;
    out[1] = y3;
    out[2] = z;
    out[3] = w;
    return out;
  }
  function add5(out, a3, b) {
    out[0] = a3[0] + b[0];
    out[1] = a3[1] + b[1];
    out[2] = a3[2] + b[2];
    out[3] = a3[3] + b[3];
    return out;
  }
  function subtract4(out, a3, b) {
    out[0] = a3[0] - b[0];
    out[1] = a3[1] - b[1];
    out[2] = a3[2] - b[2];
    out[3] = a3[3] - b[3];
    return out;
  }
  function multiply4(out, a3, b) {
    out[0] = a3[0] * b[0];
    out[1] = a3[1] * b[1];
    out[2] = a3[2] * b[2];
    out[3] = a3[3] * b[3];
    return out;
  }
  function divide2(out, a3, b) {
    out[0] = a3[0] / b[0];
    out[1] = a3[1] / b[1];
    out[2] = a3[2] / b[2];
    out[3] = a3[3] / b[3];
    return out;
  }
  function ceil2(out, a3) {
    out[0] = Math.ceil(a3[0]);
    out[1] = Math.ceil(a3[1]);
    out[2] = Math.ceil(a3[2]);
    out[3] = Math.ceil(a3[3]);
    return out;
  }
  function floor2(out, a3) {
    out[0] = Math.floor(a3[0]);
    out[1] = Math.floor(a3[1]);
    out[2] = Math.floor(a3[2]);
    out[3] = Math.floor(a3[3]);
    return out;
  }
  function min2(out, a3, b) {
    out[0] = Math.min(a3[0], b[0]);
    out[1] = Math.min(a3[1], b[1]);
    out[2] = Math.min(a3[2], b[2]);
    out[3] = Math.min(a3[3], b[3]);
    return out;
  }
  function max2(out, a3, b) {
    out[0] = Math.max(a3[0], b[0]);
    out[1] = Math.max(a3[1], b[1]);
    out[2] = Math.max(a3[2], b[2]);
    out[3] = Math.max(a3[3], b[3]);
    return out;
  }
  function round2(out, a3) {
    out[0] = Math.round(a3[0]);
    out[1] = Math.round(a3[1]);
    out[2] = Math.round(a3[2]);
    out[3] = Math.round(a3[3]);
    return out;
  }
  function scale4(out, a3, b) {
    out[0] = a3[0] * b;
    out[1] = a3[1] * b;
    out[2] = a3[2] * b;
    out[3] = a3[3] * b;
    return out;
  }
  function scaleAndAdd2(out, a3, b, scale9) {
    out[0] = a3[0] + b[0] * scale9;
    out[1] = a3[1] + b[1] * scale9;
    out[2] = a3[2] + b[2] * scale9;
    out[3] = a3[3] + b[3] * scale9;
    return out;
  }
  function distance2(a3, b) {
    var x3 = b[0] - a3[0];
    var y3 = b[1] - a3[1];
    var z = b[2] - a3[2];
    var w = b[3] - a3[3];
    return Math.hypot(x3, y3, z, w);
  }
  function squaredDistance2(a3, b) {
    var x3 = b[0] - a3[0];
    var y3 = b[1] - a3[1];
    var z = b[2] - a3[2];
    var w = b[3] - a3[3];
    return x3 * x3 + y3 * y3 + z * z + w * w;
  }
  function length2(a3) {
    var x3 = a3[0];
    var y3 = a3[1];
    var z = a3[2];
    var w = a3[3];
    return Math.hypot(x3, y3, z, w);
  }
  function squaredLength2(a3) {
    var x3 = a3[0];
    var y3 = a3[1];
    var z = a3[2];
    var w = a3[3];
    return x3 * x3 + y3 * y3 + z * z + w * w;
  }
  function negate2(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    out[3] = -a3[3];
    return out;
  }
  function inverse2(out, a3) {
    out[0] = 1 / a3[0];
    out[1] = 1 / a3[1];
    out[2] = 1 / a3[2];
    out[3] = 1 / a3[3];
    return out;
  }
  function normalize2(out, a3) {
    var x3 = a3[0];
    var y3 = a3[1];
    var z = a3[2];
    var w = a3[3];
    var len5 = x3 * x3 + y3 * y3 + z * z + w * w;
    if (len5 > 0) {
      len5 = 1 / Math.sqrt(len5);
    }
    out[0] = x3 * len5;
    out[1] = y3 * len5;
    out[2] = z * len5;
    out[3] = w * len5;
    return out;
  }
  function dot2(a3, b) {
    return a3[0] * b[0] + a3[1] * b[1] + a3[2] * b[2] + a3[3] * b[3];
  }
  function cross2(out, u, v, w) {
    var A5 = v[0] * w[1] - v[1] * w[0], B3 = v[0] * w[2] - v[2] * w[0], C3 = v[0] * w[3] - v[3] * w[0], D2 = v[1] * w[2] - v[2] * w[1], E2 = v[1] * w[3] - v[3] * w[1], F = v[2] * w[3] - v[3] * w[2];
    var G = u[0];
    var H = u[1];
    var I = u[2];
    var J = u[3];
    out[0] = H * F - I * E2 + J * D2;
    out[1] = -(G * F) + I * C3 - J * B3;
    out[2] = G * E2 - H * C3 + J * A5;
    out[3] = -(G * D2) + H * B3 - I * A5;
    return out;
  }
  function lerp2(out, a3, b, t) {
    var ax = a3[0];
    var ay = a3[1];
    var az = a3[2];
    var aw = a3[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
  }
  function random2(out, scale9) {
    scale9 = scale9 || 1;
    var v1, v2, v3, v4;
    var s1, s2;
    do {
      v1 = RANDOM() * 2 - 1;
      v2 = RANDOM() * 2 - 1;
      s1 = v1 * v1 + v2 * v2;
    } while (s1 >= 1);
    do {
      v3 = RANDOM() * 2 - 1;
      v4 = RANDOM() * 2 - 1;
      s2 = v3 * v3 + v4 * v4;
    } while (s2 >= 1);
    var d2 = Math.sqrt((1 - s1) / s2);
    out[0] = scale9 * v1;
    out[1] = scale9 * v2;
    out[2] = scale9 * v3 * d2;
    out[3] = scale9 * v4 * d2;
    return out;
  }
  function transformMat42(out, a3, m3) {
    var x3 = a3[0], y3 = a3[1], z = a3[2], w = a3[3];
    out[0] = m3[0] * x3 + m3[4] * y3 + m3[8] * z + m3[12] * w;
    out[1] = m3[1] * x3 + m3[5] * y3 + m3[9] * z + m3[13] * w;
    out[2] = m3[2] * x3 + m3[6] * y3 + m3[10] * z + m3[14] * w;
    out[3] = m3[3] * x3 + m3[7] * y3 + m3[11] * z + m3[15] * w;
    return out;
  }
  function transformQuat2(out, a3, q) {
    var x3 = a3[0], y3 = a3[1], z = a3[2];
    var qx = q[0], qy = q[1], qz = q[2], qw = q[3];
    var ix = qw * x3 + qy * z - qz * y3;
    var iy = qw * y3 + qz * x3 - qx * z;
    var iz = qw * z + qx * y3 - qy * x3;
    var iw = -qx * x3 - qy * y3 - qz * z;
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a3[3];
    return out;
  }
  function zero2(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
  }
  function str4(a3) {
    return "vec4(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ")";
  }
  function exactEquals4(a3, b) {
    return a3[0] === b[0] && a3[1] === b[1] && a3[2] === b[2] && a3[3] === b[3];
  }
  function equals4(a3, b) {
    var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a22 - b2) <= EPSILON * Math.max(1, Math.abs(a22), Math.abs(b2)) && Math.abs(a32 - b3) <= EPSILON * Math.max(1, Math.abs(a32), Math.abs(b3));
  }
  var sub4 = subtract4;
  var mul4 = multiply4;
  var div2 = divide2;
  var dist2 = distance2;
  var sqrDist2 = squaredDistance2;
  var len2 = length2;
  var sqrLen2 = squaredLength2;
  var forEach2 = function() {
    var vec = create4();
    return function(a3, stride, offset3, count4, fn, arg) {
      var i, l2;
      if (!stride) {
        stride = 4;
      }
      if (!offset3) {
        offset3 = 0;
      }
      if (count4) {
        l2 = Math.min(count4 * stride + offset3, a3.length);
      } else {
        l2 = a3.length;
      }
      for (i = offset3; i < l2; i += stride) {
        vec[0] = a3[i];
        vec[1] = a3[i + 1];
        vec[2] = a3[i + 2];
        vec[3] = a3[i + 3];
        fn(vec, vec, arg);
        a3[i] = vec[0];
        a3[i + 1] = vec[1];
        a3[i + 2] = vec[2];
        a3[i + 3] = vec[3];
      }
      return a3;
    };
  }();

  // ../../engine/rails_design/node_modules/gl-matrix/esm/quat.js
  function create5() {
    var out = new ARRAY_TYPE(4);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
    }
    out[3] = 1;
    return out;
  }
  function identity3(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
  }
  function setAxisAngle(out, axis, rad) {
    rad = rad * 0.5;
    var s2 = Math.sin(rad);
    out[0] = s2 * axis[0];
    out[1] = s2 * axis[1];
    out[2] = s2 * axis[2];
    out[3] = Math.cos(rad);
    return out;
  }
  function getAxisAngle(out_axis, q) {
    var rad = Math.acos(q[3]) * 2;
    var s2 = Math.sin(rad / 2);
    if (s2 > EPSILON) {
      out_axis[0] = q[0] / s2;
      out_axis[1] = q[1] / s2;
      out_axis[2] = q[2] / s2;
    } else {
      out_axis[0] = 1;
      out_axis[1] = 0;
      out_axis[2] = 0;
    }
    return rad;
  }
  function getAngle(a3, b) {
    var dotproduct = dot3(a3, b);
    return Math.acos(2 * dotproduct * dotproduct - 1);
  }
  function multiply5(out, a3, b) {
    var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
  }
  function rotateX3(out, a3, rad) {
    rad *= 0.5;
    var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
    var bx = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
  }
  function rotateY3(out, a3, rad) {
    rad *= 0.5;
    var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
    var by = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
  }
  function rotateZ3(out, a3, rad) {
    rad *= 0.5;
    var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
    var bz = Math.sin(rad), bw = Math.cos(rad);
    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
  }
  function calculateW(out, a3) {
    var x3 = a3[0], y3 = a3[1], z = a3[2];
    out[0] = x3;
    out[1] = y3;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1 - x3 * x3 - y3 * y3 - z * z));
    return out;
  }
  function exp(out, a3) {
    var x3 = a3[0], y3 = a3[1], z = a3[2], w = a3[3];
    var r = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
    var et = Math.exp(w);
    var s2 = r > 0 ? et * Math.sin(r) / r : 0;
    out[0] = x3 * s2;
    out[1] = y3 * s2;
    out[2] = z * s2;
    out[3] = et * Math.cos(r);
    return out;
  }
  function ln(out, a3) {
    var x3 = a3[0], y3 = a3[1], z = a3[2], w = a3[3];
    var r = Math.sqrt(x3 * x3 + y3 * y3 + z * z);
    var t = r > 0 ? Math.atan2(r, w) / r : 0;
    out[0] = x3 * t;
    out[1] = y3 * t;
    out[2] = z * t;
    out[3] = 0.5 * Math.log(x3 * x3 + y3 * y3 + z * z + w * w);
    return out;
  }
  function pow(out, a3, b) {
    ln(out, a3);
    scale5(out, out, b);
    exp(out, out);
    return out;
  }
  function slerp(out, a3, b, t) {
    var ax = a3[0], ay = a3[1], az = a3[2], aw = a3[3];
    var bx = b[0], by = b[1], bz = b[2], bw = b[3];
    var omega, cosom, sinom, scale0, scale1;
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    if (cosom < 0) {
      cosom = -cosom;
      bx = -bx;
      by = -by;
      bz = -bz;
      bw = -bw;
    }
    if (1 - cosom > EPSILON) {
      omega = Math.acos(cosom);
      sinom = Math.sin(omega);
      scale0 = Math.sin((1 - t) * omega) / sinom;
      scale1 = Math.sin(t * omega) / sinom;
    } else {
      scale0 = 1 - t;
      scale1 = t;
    }
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    return out;
  }
  function random3(out) {
    var u1 = RANDOM();
    var u2 = RANDOM();
    var u3 = RANDOM();
    var sqrt1MinusU1 = Math.sqrt(1 - u1);
    var sqrtU1 = Math.sqrt(u1);
    out[0] = sqrt1MinusU1 * Math.sin(2 * Math.PI * u2);
    out[1] = sqrt1MinusU1 * Math.cos(2 * Math.PI * u2);
    out[2] = sqrtU1 * Math.sin(2 * Math.PI * u3);
    out[3] = sqrtU1 * Math.cos(2 * Math.PI * u3);
    return out;
  }
  function invert3(out, a3) {
    var a0 = a3[0], a1 = a3[1], a22 = a3[2], a32 = a3[3];
    var dot8 = a0 * a0 + a1 * a1 + a22 * a22 + a32 * a32;
    var invDot = dot8 ? 1 / dot8 : 0;
    out[0] = -a0 * invDot;
    out[1] = -a1 * invDot;
    out[2] = -a22 * invDot;
    out[3] = a32 * invDot;
    return out;
  }
  function conjugate(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    out[2] = -a3[2];
    out[3] = a3[3];
    return out;
  }
  function fromMat3(out, m3) {
    var fTrace = m3[0] + m3[4] + m3[8];
    var fRoot;
    if (fTrace > 0) {
      fRoot = Math.sqrt(fTrace + 1);
      out[3] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[0] = (m3[5] - m3[7]) * fRoot;
      out[1] = (m3[6] - m3[2]) * fRoot;
      out[2] = (m3[1] - m3[3]) * fRoot;
    } else {
      var i = 0;
      if (m3[4] > m3[0]) i = 1;
      if (m3[8] > m3[i * 3 + i]) i = 2;
      var j = (i + 1) % 3;
      var k = (i + 2) % 3;
      fRoot = Math.sqrt(m3[i * 3 + i] - m3[j * 3 + j] - m3[k * 3 + k] + 1);
      out[i] = 0.5 * fRoot;
      fRoot = 0.5 / fRoot;
      out[3] = (m3[j * 3 + k] - m3[k * 3 + j]) * fRoot;
      out[j] = (m3[j * 3 + i] + m3[i * 3 + j]) * fRoot;
      out[k] = (m3[k * 3 + i] + m3[i * 3 + k]) * fRoot;
    }
    return out;
  }
  function fromEuler(out, x3, y3, z) {
    var halfToRad = 0.5 * Math.PI / 180;
    x3 *= halfToRad;
    y3 *= halfToRad;
    z *= halfToRad;
    var sx = Math.sin(x3);
    var cx = Math.cos(x3);
    var sy = Math.sin(y3);
    var cy = Math.cos(y3);
    var sz = Math.sin(z);
    var cz = Math.cos(z);
    out[0] = sx * cy * cz - cx * sy * sz;
    out[1] = cx * sy * cz + sx * cy * sz;
    out[2] = cx * cy * sz - sx * sy * cz;
    out[3] = cx * cy * cz + sx * sy * sz;
    return out;
  }
  function str5(a3) {
    return "quat(" + a3[0] + ", " + a3[1] + ", " + a3[2] + ", " + a3[3] + ")";
  }
  var clone8 = clone7;
  var fromValues5 = fromValues4;
  var copy5 = copy4;
  var set5 = set4;
  var add6 = add5;
  var mul5 = multiply5;
  var scale5 = scale4;
  var dot3 = dot2;
  var lerp3 = lerp2;
  var length3 = length2;
  var len3 = length3;
  var squaredLength3 = squaredLength2;
  var sqrLen3 = squaredLength3;
  var normalize3 = normalize2;
  var exactEquals5 = exactEquals4;
  var equals5 = equals4;
  var rotationTo = function() {
    var tmpvec3 = create3();
    var xUnitVec3 = fromValues3(1, 0, 0);
    var yUnitVec3 = fromValues3(0, 1, 0);
    return function(out, a3, b) {
      var dot8 = dot(a3, b);
      if (dot8 < -0.999999) {
        cross(tmpvec3, xUnitVec3, a3);
        if (len(tmpvec3) < 1e-6) cross(tmpvec3, yUnitVec3, a3);
        normalize(tmpvec3, tmpvec3);
        setAxisAngle(out, tmpvec3, Math.PI);
        return out;
      } else if (dot8 > 0.999999) {
        out[0] = 0;
        out[1] = 0;
        out[2] = 0;
        out[3] = 1;
        return out;
      } else {
        cross(tmpvec3, a3, b);
        out[0] = tmpvec3[0];
        out[1] = tmpvec3[1];
        out[2] = tmpvec3[2];
        out[3] = 1 + dot8;
        return normalize3(out, out);
      }
    };
  }();
  var sqlerp = function() {
    var temp1 = create5();
    var temp2 = create5();
    return function(out, a3, b, c5, d2, t) {
      slerp(temp1, a3, d2, t);
      slerp(temp2, b, c5, t);
      slerp(out, temp1, temp2, 2 * t * (1 - t));
      return out;
    };
  }();
  var setAxes = function() {
    var matr = create();
    return function(out, view, right2, up) {
      matr[0] = right2[0];
      matr[3] = right2[1];
      matr[6] = right2[2];
      matr[1] = up[0];
      matr[4] = up[1];
      matr[7] = up[2];
      matr[2] = -view[0];
      matr[5] = -view[1];
      matr[8] = -view[2];
      return normalize3(out, fromMat3(out, matr));
    };
  }();

  // ../../engine/rails_design/node_modules/gl-matrix/esm/vec2.js
  var vec2_exports = {};
  __export(vec2_exports, {
    add: () => add7,
    angle: () => angle2,
    ceil: () => ceil3,
    clone: () => clone9,
    copy: () => copy6,
    create: () => create6,
    cross: () => cross3,
    dist: () => dist3,
    distance: () => distance3,
    div: () => div3,
    divide: () => divide3,
    dot: () => dot4,
    equals: () => equals6,
    exactEquals: () => exactEquals6,
    floor: () => floor3,
    forEach: () => forEach3,
    fromValues: () => fromValues6,
    inverse: () => inverse3,
    len: () => len4,
    length: () => length4,
    lerp: () => lerp4,
    max: () => max3,
    min: () => min3,
    mul: () => mul6,
    multiply: () => multiply6,
    negate: () => negate3,
    normalize: () => normalize4,
    random: () => random4,
    rotate: () => rotate3,
    round: () => round3,
    scale: () => scale6,
    scaleAndAdd: () => scaleAndAdd3,
    set: () => set6,
    sqrDist: () => sqrDist3,
    sqrLen: () => sqrLen4,
    squaredDistance: () => squaredDistance3,
    squaredLength: () => squaredLength4,
    str: () => str6,
    sub: () => sub5,
    subtract: () => subtract5,
    transformMat2: () => transformMat2,
    transformMat2d: () => transformMat2d,
    transformMat3: () => transformMat32,
    transformMat4: () => transformMat43,
    zero: () => zero3
  });
  function create6() {
    var out = new ARRAY_TYPE(2);
    if (ARRAY_TYPE != Float32Array) {
      out[0] = 0;
      out[1] = 0;
    }
    return out;
  }
  function clone9(a3) {
    var out = new ARRAY_TYPE(2);
    out[0] = a3[0];
    out[1] = a3[1];
    return out;
  }
  function fromValues6(x3, y3) {
    var out = new ARRAY_TYPE(2);
    out[0] = x3;
    out[1] = y3;
    return out;
  }
  function copy6(out, a3) {
    out[0] = a3[0];
    out[1] = a3[1];
    return out;
  }
  function set6(out, x3, y3) {
    out[0] = x3;
    out[1] = y3;
    return out;
  }
  function add7(out, a3, b) {
    out[0] = a3[0] + b[0];
    out[1] = a3[1] + b[1];
    return out;
  }
  function subtract5(out, a3, b) {
    out[0] = a3[0] - b[0];
    out[1] = a3[1] - b[1];
    return out;
  }
  function multiply6(out, a3, b) {
    out[0] = a3[0] * b[0];
    out[1] = a3[1] * b[1];
    return out;
  }
  function divide3(out, a3, b) {
    out[0] = a3[0] / b[0];
    out[1] = a3[1] / b[1];
    return out;
  }
  function ceil3(out, a3) {
    out[0] = Math.ceil(a3[0]);
    out[1] = Math.ceil(a3[1]);
    return out;
  }
  function floor3(out, a3) {
    out[0] = Math.floor(a3[0]);
    out[1] = Math.floor(a3[1]);
    return out;
  }
  function min3(out, a3, b) {
    out[0] = Math.min(a3[0], b[0]);
    out[1] = Math.min(a3[1], b[1]);
    return out;
  }
  function max3(out, a3, b) {
    out[0] = Math.max(a3[0], b[0]);
    out[1] = Math.max(a3[1], b[1]);
    return out;
  }
  function round3(out, a3) {
    out[0] = Math.round(a3[0]);
    out[1] = Math.round(a3[1]);
    return out;
  }
  function scale6(out, a3, b) {
    out[0] = a3[0] * b;
    out[1] = a3[1] * b;
    return out;
  }
  function scaleAndAdd3(out, a3, b, scale9) {
    out[0] = a3[0] + b[0] * scale9;
    out[1] = a3[1] + b[1] * scale9;
    return out;
  }
  function distance3(a3, b) {
    var x3 = b[0] - a3[0], y3 = b[1] - a3[1];
    return Math.hypot(x3, y3);
  }
  function squaredDistance3(a3, b) {
    var x3 = b[0] - a3[0], y3 = b[1] - a3[1];
    return x3 * x3 + y3 * y3;
  }
  function length4(a3) {
    var x3 = a3[0], y3 = a3[1];
    return Math.hypot(x3, y3);
  }
  function squaredLength4(a3) {
    var x3 = a3[0], y3 = a3[1];
    return x3 * x3 + y3 * y3;
  }
  function negate3(out, a3) {
    out[0] = -a3[0];
    out[1] = -a3[1];
    return out;
  }
  function inverse3(out, a3) {
    out[0] = 1 / a3[0];
    out[1] = 1 / a3[1];
    return out;
  }
  function normalize4(out, a3) {
    var x3 = a3[0], y3 = a3[1];
    var len5 = x3 * x3 + y3 * y3;
    if (len5 > 0) {
      len5 = 1 / Math.sqrt(len5);
    }
    out[0] = a3[0] * len5;
    out[1] = a3[1] * len5;
    return out;
  }
  function dot4(a3, b) {
    return a3[0] * b[0] + a3[1] * b[1];
  }
  function cross3(out, a3, b) {
    var z = a3[0] * b[1] - a3[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
  }
  function lerp4(out, a3, b, t) {
    var ax = a3[0], ay = a3[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
  }
  function random4(out, scale9) {
    scale9 = scale9 || 1;
    var r = RANDOM() * 2 * Math.PI;
    out[0] = Math.cos(r) * scale9;
    out[1] = Math.sin(r) * scale9;
    return out;
  }
  function transformMat2(out, a3, m3) {
    var x3 = a3[0], y3 = a3[1];
    out[0] = m3[0] * x3 + m3[2] * y3;
    out[1] = m3[1] * x3 + m3[3] * y3;
    return out;
  }
  function transformMat2d(out, a3, m3) {
    var x3 = a3[0], y3 = a3[1];
    out[0] = m3[0] * x3 + m3[2] * y3 + m3[4];
    out[1] = m3[1] * x3 + m3[3] * y3 + m3[5];
    return out;
  }
  function transformMat32(out, a3, m3) {
    var x3 = a3[0], y3 = a3[1];
    out[0] = m3[0] * x3 + m3[3] * y3 + m3[6];
    out[1] = m3[1] * x3 + m3[4] * y3 + m3[7];
    return out;
  }
  function transformMat43(out, a3, m3) {
    var x3 = a3[0];
    var y3 = a3[1];
    out[0] = m3[0] * x3 + m3[4] * y3 + m3[12];
    out[1] = m3[1] * x3 + m3[5] * y3 + m3[13];
    return out;
  }
  function rotate3(out, a3, b, rad) {
    var p0 = a3[0] - b[0], p1 = a3[1] - b[1], sinC = Math.sin(rad), cosC = Math.cos(rad);
    out[0] = p0 * cosC - p1 * sinC + b[0];
    out[1] = p0 * sinC + p1 * cosC + b[1];
    return out;
  }
  function angle2(a3, b) {
    var x12 = a3[0], y12 = a3[1], x22 = b[0], y22 = b[1], mag = Math.sqrt(x12 * x12 + y12 * y12) * Math.sqrt(x22 * x22 + y22 * y22), cosine = mag && (x12 * x22 + y12 * y22) / mag;
    return Math.acos(Math.min(Math.max(cosine, -1), 1));
  }
  function zero3(out) {
    out[0] = 0;
    out[1] = 0;
    return out;
  }
  function str6(a3) {
    return "vec2(" + a3[0] + ", " + a3[1] + ")";
  }
  function exactEquals6(a3, b) {
    return a3[0] === b[0] && a3[1] === b[1];
  }
  function equals6(a3, b) {
    var a0 = a3[0], a1 = a3[1];
    var b0 = b[0], b1 = b[1];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1));
  }
  var len4 = length4;
  var sub5 = subtract5;
  var mul6 = multiply6;
  var div3 = divide3;
  var dist3 = distance3;
  var sqrDist3 = squaredDistance3;
  var sqrLen4 = squaredLength4;
  var forEach3 = function() {
    var vec = create6();
    return function(a3, stride, offset3, count4, fn, arg) {
      var i, l2;
      if (!stride) {
        stride = 2;
      }
      if (!offset3) {
        offset3 = 0;
      }
      if (count4) {
        l2 = Math.min(count4 * stride + offset3, a3.length);
      } else {
        l2 = a3.length;
      }
      for (i = offset3; i < l2; i += stride) {
        vec[0] = a3[i];
        vec[1] = a3[i + 1];
        fn(vec, vec, arg);
        a3[i] = vec[0];
        a3[i + 1] = vec[1];
      }
      return a3;
    };
  }();

  // ../../engine/rails_design/node_modules/tslib/tslib.es6.mjs
  var extendStatics = function(d2, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
      d3.__proto__ = b2;
    } || function(d3, b2) {
      for (var p2 in b2) if (Object.prototype.hasOwnProperty.call(b2, p2)) d3[p2] = b2[p2];
    };
    return extendStatics(d2, b);
  };
  function __extends(d2, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d2, b);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }
  var __assign = function() {
    __assign = Object.assign || function __assign2(t) {
      for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
        s2 = arguments[i];
        for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t[p2] = s2[p2];
      }
      return t;
    };
    return __assign.apply(this, arguments);
  };
  function __rest(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t[0] & 1) throw t[1];
      return t[1];
    }, trys: [], ops: [] }, f, y3, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
      return this;
    }), g;
    function verb(n2) {
      return function(v) {
        return step2([n2, v]);
      };
    }
    function step2(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_2 = 0)), _2) try {
        if (f = 1, y3 && (t = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t = y3["return"]) && t.call(y3), 0) : y3.next) && !(t = t.call(y3, op[1])).done) return t;
        if (y3 = 0, t) op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t = _2.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t[1]) {
              _2.label = t[1];
              t = op;
              break;
            }
            if (t && _2.label < t[2]) {
              _2.label = t[2];
              _2.ops.push(op);
              break;
            }
            if (t[2]) _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __values(o) {
    var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o[s2], i = 0;
    if (m3) return m3.call(o);
    if (o && typeof o.length === "number") return {
      next: function() {
        if (o && i >= o.length) o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
    throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
  }
  function __read(o, n2) {
    var m3 = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m3) return o;
    var i = m3.call(o), r, ar = [], e3;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error4) {
      e3 = { error: error4 };
    } finally {
      try {
        if (r && !r.done && (m3 = i["return"])) m3.call(i);
      } finally {
        if (e3) throw e3.error;
      }
    }
    return ar;
  }
  function __spreadArray(to, from, pack3) {
    if (pack3 || arguments.length === 2) for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  }
  function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/utils/helper.js
  function column(value2, field3) {
    if (value2 === null)
      return void 0;
    return { type: "column", value: value2, field: field3 };
  }
  function inferredColumn(value2, field3) {
    const c5 = column(value2, field3);
    return Object.assign(Object.assign({}, c5), { inferred: true });
  }
  function visualColumn(value2, field3) {
    if (value2 === null)
      return void 0;
    return { type: "column", value: value2, field: field3, visual: true };
  }
  function nonConstantColumn(value2, field3) {
    const c5 = column(value2, field3);
    return Object.assign(Object.assign({}, c5), { constant: false });
  }
  function constant(I, value2) {
    const array2 = [];
    for (const i of I)
      array2[i] = value2;
    return array2;
  }
  function columnOf(encode, key) {
    const channel = encode[key];
    if (!channel)
      return [null, null];
    const { value: value2, field: field3 = null } = channel;
    return [value2, field3];
  }
  function maybeColumnOf(encode, ...K) {
    for (const key of K) {
      if (typeof key === "string") {
        const [KV, fv] = columnOf(encode, key);
        if (KV !== null)
          return [KV, fv];
      } else {
        return [key, null];
      }
    }
    return [null, null];
  }
  function isObject(d2) {
    if (d2 instanceof Date)
      return false;
    return typeof d2 === "object";
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeZeroY1.js
  var MaybeZeroY1 = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { y1: y12 } = encode;
      if (y12 !== void 0)
        return [I, mark];
      return [
        I,
        deep_mix_default({}, mark, {
          encode: { y1: inferredColumn(constant(I, 0)) }
        })
      ];
    };
  };
  MaybeZeroY1.props = {};

  // ../../engine/rails_design/node_modules/d3-array/src/ascending.js
  function ascending(a3, b) {
    return a3 == null || b == null ? NaN : a3 < b ? -1 : a3 > b ? 1 : a3 >= b ? 0 : NaN;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/descending.js
  function descending(a3, b) {
    return a3 == null || b == null ? NaN : b < a3 ? -1 : b > a3 ? 1 : b >= a3 ? 0 : NaN;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/bisector.js
  function bisector(f) {
    let compare1, compare2, delta;
    if (f.length !== 2) {
      compare1 = ascending;
      compare2 = (d2, x3) => ascending(f(d2), x3);
      delta = (d2, x3) => f(d2) - x3;
    } else {
      compare1 = f === ascending || f === descending ? f : zero4;
      compare2 = f;
      delta = f;
    }
    function left2(a3, x3, lo = 0, hi = a3.length) {
      if (lo < hi) {
        if (compare1(x3, x3) !== 0) return hi;
        do {
          const mid2 = lo + hi >>> 1;
          if (compare2(a3[mid2], x3) < 0) lo = mid2 + 1;
          else hi = mid2;
        } while (lo < hi);
      }
      return lo;
    }
    function right2(a3, x3, lo = 0, hi = a3.length) {
      if (lo < hi) {
        if (compare1(x3, x3) !== 0) return hi;
        do {
          const mid2 = lo + hi >>> 1;
          if (compare2(a3[mid2], x3) <= 0) lo = mid2 + 1;
          else hi = mid2;
        } while (lo < hi);
      }
      return lo;
    }
    function center2(a3, x3, lo = 0, hi = a3.length) {
      const i = left2(a3, x3, lo, hi - 1);
      return i > lo && delta(a3[i - 1], x3) > -delta(a3[i], x3) ? i - 1 : i;
    }
    return { left: left2, center: center2, right: right2 };
  }
  function zero4() {
    return 0;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/number.js
  function number(x3) {
    return x3 === null ? NaN : +x3;
  }
  function* numbers(values, valueof2) {
    if (valueof2 === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          yield value2;
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (value2 = +value2) >= value2) {
          yield value2;
        }
      }
    }
  }

  // ../../engine/rails_design/node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;
  var bisectCenter = bisector(number).center;
  var bisect_default = bisectRight;

  // ../../engine/rails_design/node_modules/d3-array/src/count.js
  function count(values, valueof2) {
    let count4 = 0;
    if (valueof2 === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          ++count4;
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (value2 = +value2) >= value2) {
          ++count4;
        }
      }
    }
    return count4;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/variance.js
  function variance(values, valueof2) {
    let count4 = 0;
    let delta;
    let mean3 = 0;
    let sum3 = 0;
    if (valueof2 === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          delta = value2 - mean3;
          mean3 += delta / ++count4;
          sum3 += delta * (value2 - mean3);
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (value2 = +value2) >= value2) {
          delta = value2 - mean3;
          mean3 += delta / ++count4;
          sum3 += delta * (value2 - mean3);
        }
      }
    }
    if (count4 > 1) return sum3 / (count4 - 1);
  }

  // ../../engine/rails_design/node_modules/d3-array/src/deviation.js
  function deviation(values, valueof2) {
    const v = variance(values, valueof2);
    return v ? Math.sqrt(v) : v;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/extent.js
  function extent(values, valueof2) {
    let min10;
    let max10;
    if (valueof2 === void 0) {
      for (const value2 of values) {
        if (value2 != null) {
          if (min10 === void 0) {
            if (value2 >= value2) min10 = max10 = value2;
          } else {
            if (min10 > value2) min10 = value2;
            if (max10 < value2) max10 = value2;
          }
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null) {
          if (min10 === void 0) {
            if (value2 >= value2) min10 = max10 = value2;
          } else {
            if (min10 > value2) min10 = value2;
            if (max10 < value2) max10 = value2;
          }
        }
      }
    }
    return [min10, max10];
  }

  // ../../engine/rails_design/node_modules/d3-array/src/fsum.js
  var Adder = class {
    constructor() {
      this._partials = new Float64Array(32);
      this._n = 0;
    }
    add(x3) {
      const p2 = this._partials;
      let i = 0;
      for (let j = 0; j < this._n && j < 32; j++) {
        const y3 = p2[j], hi = x3 + y3, lo = Math.abs(x3) < Math.abs(y3) ? x3 - (hi - y3) : y3 - (hi - x3);
        if (lo) p2[i++] = lo;
        x3 = hi;
      }
      p2[i] = x3;
      this._n = i + 1;
      return this;
    }
    valueOf() {
      const p2 = this._partials;
      let n2 = this._n, x3, y3, lo, hi = 0;
      if (n2 > 0) {
        hi = p2[--n2];
        while (n2 > 0) {
          x3 = hi;
          y3 = p2[--n2];
          hi = x3 + y3;
          lo = y3 - (hi - x3);
          if (lo) break;
        }
        if (n2 > 0 && (lo < 0 && p2[n2 - 1] < 0 || lo > 0 && p2[n2 - 1] > 0)) {
          y3 = lo * 2;
          x3 = hi + y3;
          if (y3 == x3 - hi) hi = x3;
        }
      }
      return hi;
    }
  };

  // ../../engine/rails_design/node_modules/internmap/src/index.js
  var InternMap = class extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null) for (const [key2, value2] of entries) this.set(key2, value2);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value2) {
      return super.set(intern_set(this, key), value2);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  };
  function intern_get({ _intern, _key }, value2) {
    const key = _key(value2);
    return _intern.has(key) ? _intern.get(key) : value2;
  }
  function intern_set({ _intern, _key }, value2) {
    const key = _key(value2);
    if (_intern.has(key)) return _intern.get(key);
    _intern.set(key, value2);
    return value2;
  }
  function intern_delete({ _intern, _key }, value2) {
    const key = _key(value2);
    if (_intern.has(key)) {
      value2 = _intern.get(key);
      _intern.delete(key);
    }
    return value2;
  }
  function keyof(value2) {
    return value2 !== null && typeof value2 === "object" ? value2.valueOf() : value2;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/identity.js
  function identity4(x3) {
    return x3;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/group.js
  function group(values, ...keys2) {
    return nest(values, identity4, identity4, keys2);
  }
  function groups(values, ...keys2) {
    return nest(values, Array.from, identity4, keys2);
  }
  function rollup(values, reduce2, ...keys2) {
    return nest(values, identity4, reduce2, keys2);
  }
  function rollups(values, reduce2, ...keys2) {
    return nest(values, Array.from, reduce2, keys2);
  }
  function nest(values, map3, reduce2, keys2) {
    return function regroup(values2, i) {
      if (i >= keys2.length) return reduce2(values2);
      const groups2 = new InternMap();
      const keyof4 = keys2[i++];
      let index4 = -1;
      for (const value2 of values2) {
        const key = keyof4(value2, ++index4, values2);
        const group3 = groups2.get(key);
        if (group3) group3.push(value2);
        else groups2.set(key, [value2]);
      }
      for (const [key, values3] of groups2) {
        groups2.set(key, regroup(values3, i));
      }
      return map3(groups2);
    }(values, 0);
  }

  // ../../engine/rails_design/node_modules/d3-array/src/permute.js
  function permute(source, keys2) {
    return Array.from(keys2, (key) => source[key]);
  }

  // ../../engine/rails_design/node_modules/d3-array/src/sort.js
  function sort2(values, ...F) {
    if (typeof values[Symbol.iterator] !== "function") throw new TypeError("values is not iterable");
    values = Array.from(values);
    let [f] = F;
    if (f && f.length !== 2 || F.length > 1) {
      const index4 = Uint32Array.from(values, (d2, i) => i);
      if (F.length > 1) {
        F = F.map((f2) => values.map(f2));
        index4.sort((i, j) => {
          for (const f2 of F) {
            const c5 = ascendingDefined(f2[i], f2[j]);
            if (c5) return c5;
          }
        });
      } else {
        f = values.map(f);
        index4.sort((i, j) => ascendingDefined(f[i], f[j]));
      }
      return permute(values, index4);
    }
    return values.sort(compareDefined(f));
  }
  function compareDefined(compare = ascending) {
    if (compare === ascending) return ascendingDefined;
    if (typeof compare !== "function") throw new TypeError("compare is not a function");
    return (a3, b) => {
      const x3 = compare(a3, b);
      if (x3 || x3 === 0) return x3;
      return (compare(b, b) === 0) - (compare(a3, a3) === 0);
    };
  }
  function ascendingDefined(a3, b) {
    return (a3 == null || !(a3 >= a3)) - (b == null || !(b >= b)) || (a3 < b ? -1 : a3 > b ? 1 : 0);
  }

  // ../../engine/rails_design/node_modules/d3-array/src/groupSort.js
  function groupSort(values, reduce2, key) {
    return (reduce2.length !== 2 ? sort2(rollup(values, reduce2, key), ([ak, av], [bk, bv]) => ascending(av, bv) || ascending(ak, bk)) : sort2(group(values, key), ([ak, av], [bk, bv]) => reduce2(av, bv) || ascending(ak, bk))).map(([key2]) => key2);
  }

  // ../../engine/rails_design/node_modules/d3-array/src/array.js
  var array = Array.prototype;
  var slice = array.slice;
  var map = array.map;

  // ../../engine/rails_design/node_modules/d3-array/src/constant.js
  function constant2(x3) {
    return () => x3;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function tickSpec(start2, stop, count4) {
    const step2 = (stop - start2) / Math.max(0, count4), power = Math.floor(Math.log10(step2)), error4 = step2 / Math.pow(10, power), factor = error4 >= e10 ? 10 : error4 >= e5 ? 5 : error4 >= e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
      inc = Math.pow(10, -power) / factor;
      i1 = Math.round(start2 * inc);
      i2 = Math.round(stop * inc);
      if (i1 / inc < start2) ++i1;
      if (i2 / inc > stop) --i2;
      inc = -inc;
    } else {
      inc = Math.pow(10, power) * factor;
      i1 = Math.round(start2 / inc);
      i2 = Math.round(stop / inc);
      if (i1 * inc < start2) ++i1;
      if (i2 * inc > stop) --i2;
    }
    if (i2 < i1 && 0.5 <= count4 && count4 < 2) return tickSpec(start2, stop, count4 * 2);
    return [i1, i2, inc];
  }
  function ticks(start2, stop, count4) {
    stop = +stop, start2 = +start2, count4 = +count4;
    if (!(count4 > 0)) return [];
    if (start2 === stop) return [start2];
    const reverse = stop < start2, [i1, i2, inc] = reverse ? tickSpec(stop, start2, count4) : tickSpec(start2, stop, count4);
    if (!(i2 >= i1)) return [];
    const n2 = i2 - i1 + 1, ticks2 = new Array(n2);
    if (reverse) {
      if (inc < 0) for (let i = 0; i < n2; ++i) ticks2[i] = (i2 - i) / -inc;
      else for (let i = 0; i < n2; ++i) ticks2[i] = (i2 - i) * inc;
    } else {
      if (inc < 0) for (let i = 0; i < n2; ++i) ticks2[i] = (i1 + i) / -inc;
      else for (let i = 0; i < n2; ++i) ticks2[i] = (i1 + i) * inc;
    }
    return ticks2;
  }
  function tickIncrement(start2, stop, count4) {
    stop = +stop, start2 = +start2, count4 = +count4;
    return tickSpec(start2, stop, count4)[2];
  }

  // ../../engine/rails_design/node_modules/d3-array/src/nice.js
  function nice(start2, stop, count4) {
    let prestep;
    while (true) {
      const step2 = tickIncrement(start2, stop, count4);
      if (step2 === prestep || step2 === 0 || !isFinite(step2)) {
        return [start2, stop];
      } else if (step2 > 0) {
        start2 = Math.floor(start2 / step2) * step2;
        stop = Math.ceil(stop / step2) * step2;
      } else if (step2 < 0) {
        start2 = Math.ceil(start2 * step2) / step2;
        stop = Math.floor(stop * step2) / step2;
      }
      prestep = step2;
    }
  }

  // ../../engine/rails_design/node_modules/d3-array/src/threshold/sturges.js
  function thresholdSturges(values) {
    return Math.max(1, Math.ceil(Math.log(count(values)) / Math.LN2) + 1);
  }

  // ../../engine/rails_design/node_modules/d3-array/src/bin.js
  function bin() {
    var value2 = identity4, domain = extent, threshold = thresholdSturges;
    function histogram(data2) {
      if (!Array.isArray(data2)) data2 = Array.from(data2);
      var i, n2 = data2.length, x3, step2, values = new Array(n2);
      for (i = 0; i < n2; ++i) {
        values[i] = value2(data2[i], i, data2);
      }
      var xz = domain(values), x05 = xz[0], x12 = xz[1], tz = threshold(values, x05, x12);
      if (!Array.isArray(tz)) {
        const max10 = x12, tn = +tz;
        if (domain === extent) [x05, x12] = nice(x05, x12, tn);
        tz = ticks(x05, x12, tn);
        if (tz[0] <= x05) step2 = tickIncrement(x05, x12, tn);
        if (tz[tz.length - 1] >= x12) {
          if (max10 >= x12 && domain === extent) {
            const step3 = tickIncrement(x05, x12, tn);
            if (isFinite(step3)) {
              if (step3 > 0) {
                x12 = (Math.floor(x12 / step3) + 1) * step3;
              } else if (step3 < 0) {
                x12 = (Math.ceil(x12 * -step3) + 1) / -step3;
              }
            }
          } else {
            tz.pop();
          }
        }
      }
      var m3 = tz.length, a3 = 0, b = m3;
      while (tz[a3] <= x05) ++a3;
      while (tz[b - 1] > x12) --b;
      if (a3 || b < m3) tz = tz.slice(a3, b), m3 = b - a3;
      var bins = new Array(m3 + 1), bin2;
      for (i = 0; i <= m3; ++i) {
        bin2 = bins[i] = [];
        bin2.x0 = i > 0 ? tz[i - 1] : x05;
        bin2.x1 = i < m3 ? tz[i] : x12;
      }
      if (isFinite(step2)) {
        if (step2 > 0) {
          for (i = 0; i < n2; ++i) {
            if ((x3 = values[i]) != null && x05 <= x3 && x3 <= x12) {
              bins[Math.min(m3, Math.floor((x3 - x05) / step2))].push(data2[i]);
            }
          }
        } else if (step2 < 0) {
          for (i = 0; i < n2; ++i) {
            if ((x3 = values[i]) != null && x05 <= x3 && x3 <= x12) {
              const j = Math.floor((x05 - x3) * step2);
              bins[Math.min(m3, j + (tz[j] <= x3))].push(data2[i]);
            }
          }
        }
      } else {
        for (i = 0; i < n2; ++i) {
          if ((x3 = values[i]) != null && x05 <= x3 && x3 <= x12) {
            bins[bisect_default(tz, x3, 0, m3)].push(data2[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(_2) {
      return arguments.length ? (value2 = typeof _2 === "function" ? _2 : constant2(_2), histogram) : value2;
    };
    histogram.domain = function(_2) {
      return arguments.length ? (domain = typeof _2 === "function" ? _2 : constant2([_2[0], _2[1]]), histogram) : domain;
    };
    histogram.thresholds = function(_2) {
      return arguments.length ? (threshold = typeof _2 === "function" ? _2 : constant2(Array.isArray(_2) ? slice.call(_2) : _2), histogram) : threshold;
    };
    return histogram;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/max.js
  function max4(values, valueof2) {
    let max10;
    if (valueof2 === void 0) {
      for (const value2 of values) {
        if (value2 != null && (max10 < value2 || max10 === void 0 && value2 >= value2)) {
          max10 = value2;
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (max10 < value2 || max10 === void 0 && value2 >= value2)) {
          max10 = value2;
        }
      }
    }
    return max10;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/maxIndex.js
  function maxIndex(values, valueof2) {
    let max10;
    let maxIndex2 = -1;
    let index4 = -1;
    if (valueof2 === void 0) {
      for (const value2 of values) {
        ++index4;
        if (value2 != null && (max10 < value2 || max10 === void 0 && value2 >= value2)) {
          max10 = value2, maxIndex2 = index4;
        }
      }
    } else {
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (max10 < value2 || max10 === void 0 && value2 >= value2)) {
          max10 = value2, maxIndex2 = index4;
        }
      }
    }
    return maxIndex2;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/min.js
  function min4(values, valueof2) {
    let min10;
    if (valueof2 === void 0) {
      for (const value2 of values) {
        if (value2 != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
          min10 = value2;
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
          min10 = value2;
        }
      }
    }
    return min10;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/minIndex.js
  function minIndex(values, valueof2) {
    let min10;
    let minIndex2 = -1;
    let index4 = -1;
    if (valueof2 === void 0) {
      for (const value2 of values) {
        ++index4;
        if (value2 != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
          min10 = value2, minIndex2 = index4;
        }
      }
    } else {
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (min10 > value2 || min10 === void 0 && value2 >= value2)) {
          min10 = value2, minIndex2 = index4;
        }
      }
    }
    return minIndex2;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/quickselect.js
  function quickselect(array2, k, left2 = 0, right2 = Infinity, compare) {
    k = Math.floor(k);
    left2 = Math.floor(Math.max(0, left2));
    right2 = Math.floor(Math.min(array2.length - 1, right2));
    if (!(left2 <= k && k <= right2)) return array2;
    compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
    while (right2 > left2) {
      if (right2 - left2 > 600) {
        const n2 = right2 - left2 + 1;
        const m3 = k - left2 + 1;
        const z = Math.log(n2);
        const s2 = 0.5 * Math.exp(2 * z / 3);
        const sd = 0.5 * Math.sqrt(z * s2 * (n2 - s2) / n2) * (m3 - n2 / 2 < 0 ? -1 : 1);
        const newLeft = Math.max(left2, Math.floor(k - m3 * s2 / n2 + sd));
        const newRight = Math.min(right2, Math.floor(k + (n2 - m3) * s2 / n2 + sd));
        quickselect(array2, k, newLeft, newRight, compare);
      }
      const t = array2[k];
      let i = left2;
      let j = right2;
      swap(array2, left2, k);
      if (compare(array2[right2], t) > 0) swap(array2, left2, right2);
      while (i < j) {
        swap(array2, i, j), ++i, --j;
        while (compare(array2[i], t) < 0) ++i;
        while (compare(array2[j], t) > 0) --j;
      }
      if (compare(array2[left2], t) === 0) swap(array2, left2, j);
      else ++j, swap(array2, j, right2);
      if (j <= k) left2 = j + 1;
      if (k <= j) right2 = j - 1;
    }
    return array2;
  }
  function swap(array2, i, j) {
    const t = array2[i];
    array2[i] = array2[j];
    array2[j] = t;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/greatest.js
  function greatest(values, compare = ascending) {
    let max10;
    let defined4 = false;
    if (compare.length === 1) {
      let maxValue;
      for (const element of values) {
        const value2 = compare(element);
        if (defined4 ? ascending(value2, maxValue) > 0 : ascending(value2, value2) === 0) {
          max10 = element;
          maxValue = value2;
          defined4 = true;
        }
      }
    } else {
      for (const value2 of values) {
        if (defined4 ? compare(value2, max10) > 0 : compare(value2, value2) === 0) {
          max10 = value2;
          defined4 = true;
        }
      }
    }
    return max10;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/quantile.js
  function quantile(values, p2, valueof2) {
    values = Float64Array.from(numbers(values, valueof2));
    if (!(n2 = values.length) || isNaN(p2 = +p2)) return;
    if (p2 <= 0 || n2 < 2) return min4(values);
    if (p2 >= 1) return max4(values);
    var n2, i = (n2 - 1) * p2, i0 = Math.floor(i), value0 = max4(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min4(values.subarray(i0 + 1));
    return value0 + (value1 - value0) * (i - i0);
  }
  function quantileIndex(values, p2, valueof2 = number) {
    if (isNaN(p2 = +p2)) return;
    numbers2 = Float64Array.from(values, (_2, i2) => number(valueof2(values[i2], i2, values)));
    if (p2 <= 0) return minIndex(numbers2);
    if (p2 >= 1) return maxIndex(numbers2);
    var numbers2, index4 = Uint32Array.from(values, (_2, i2) => i2), j = numbers2.length - 1, i = Math.floor(j * p2);
    quickselect(index4, i, 0, j, (i2, j2) => ascendingDefined(numbers2[i2], numbers2[j2]));
    i = greatest(index4.subarray(0, i + 1), (i2) => numbers2[i2]);
    return i >= 0 ? i : -1;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/threshold/scott.js
  function thresholdScott(values, min10, max10) {
    const c5 = count(values), d2 = deviation(values);
    return c5 && d2 ? Math.ceil((max10 - min10) * Math.cbrt(c5) / (3.49 * d2)) : 1;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/mean.js
  function mean(values, valueof2) {
    let count4 = 0;
    let sum3 = 0;
    if (valueof2 === void 0) {
      for (let value2 of values) {
        if (value2 != null && (value2 = +value2) >= value2) {
          ++count4, sum3 += value2;
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if ((value2 = valueof2(value2, ++index4, values)) != null && (value2 = +value2) >= value2) {
          ++count4, sum3 += value2;
        }
      }
    }
    if (count4) return sum3 / count4;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/median.js
  function median(values, valueof2) {
    return quantile(values, 0.5, valueof2);
  }
  function medianIndex(values, valueof2) {
    return quantileIndex(values, 0.5, valueof2);
  }

  // ../../engine/rails_design/node_modules/d3-array/src/merge.js
  function* flatten(arrays) {
    for (const array2 of arrays) {
      yield* array2;
    }
  }
  function merge(arrays) {
    return Array.from(flatten(arrays));
  }

  // ../../engine/rails_design/node_modules/d3-array/src/range.js
  function range(start2, stop, step2) {
    start2 = +start2, stop = +stop, step2 = (n2 = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n2 < 3 ? 1 : +step2;
    var i = -1, n2 = Math.max(0, Math.ceil((stop - start2) / step2)) | 0, range3 = new Array(n2);
    while (++i < n2) {
      range3[i] = start2 + i * step2;
    }
    return range3;
  }

  // ../../engine/rails_design/node_modules/d3-array/src/sum.js
  function sum(values, valueof2) {
    let sum3 = 0;
    if (valueof2 === void 0) {
      for (let value2 of values) {
        if (value2 = +value2) {
          sum3 += value2;
        }
      }
    } else {
      let index4 = -1;
      for (let value2 of values) {
        if (value2 = +valueof2(value2, ++index4, values)) {
          sum3 += value2;
        }
      }
    }
    return sum3;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/helper.js
  var __awaiter2 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function identity5(x3) {
    return x3;
  }
  function compose(fns) {
    return fns.reduce((composed, fn) => (x3, ...args) => fn(composed(x3, ...args), ...args), identity5);
  }
  function composeAsync(fns) {
    return fns.reduce((composed, fn) => (x3) => __awaiter2(this, void 0, void 0, function* () {
      const value2 = yield composed(x3);
      return fn(value2);
    }), identity5);
  }
  function capitalizeFirst(str7) {
    return str7.replace(/( |^)[a-z]/g, (L) => L.toUpperCase());
  }
  function error2(message = "") {
    throw new Error(message);
  }
  function copyAttributes(target, source) {
    const { attributes } = source;
    const exclude = /* @__PURE__ */ new Set(["id", "className"]);
    for (const [key, value2] of Object.entries(attributes)) {
      if (!exclude.has(key)) {
        target.attr(key, value2);
      }
    }
  }
  function defined(x3) {
    return x3 !== void 0 && x3 !== null && !Number.isNaN(x3);
  }
  function useMemo(compute2) {
    const map3 = /* @__PURE__ */ new Map();
    return (key) => {
      if (map3.has(key))
        return map3.get(key);
      const value2 = compute2(key);
      map3.set(key, value2);
      return value2;
    };
  }
  function appendTransform(node, transform) {
    const { transform: preTransform } = node.style;
    const unset = (d2) => d2 === "none" || d2 === void 0;
    const prefix = unset(preTransform) ? "" : preTransform;
    node.style.transform = `${prefix} ${transform}`.trimStart();
  }
  function subObject(obj, prefix) {
    return maybeSubObject(obj, prefix) || {};
  }
  function maybeSubObject(obj, prefix) {
    const entries = Object.entries(obj || {}).filter(([key]) => key.startsWith(prefix)).map(([key, value2]) => [lower_first_default(key.replace(prefix, "").trim()), value2]).filter(([key]) => !!key);
    return entries.length === 0 ? null : Object.fromEntries(entries);
  }
  function filterPrefixObject(obj, prefix) {
    return Object.fromEntries(Object.entries(obj).filter(([key]) => prefix.find((p2) => key.startsWith(p2))));
  }
  function omitPrefixObject(obj, ...prefixes2) {
    return Object.fromEntries(Object.entries(obj).filter(([key]) => prefixes2.every((prefix) => !key.startsWith(prefix))));
  }
  function maybePercentage(x3, size2) {
    if (x3 === void 0)
      return null;
    if (typeof x3 === "number")
      return x3;
    const px = +x3.replace("%", "");
    return Number.isNaN(px) ? null : px / 100 * size2;
  }
  function isStrictObject(d2) {
    return typeof d2 === "object" && !(d2 instanceof Date) && d2 !== null && !Array.isArray(d2);
  }
  function isUnset(value2) {
    return value2 === null || value2 === false;
  }
  function deepAssign(dist5, src, maxLevel = 5, level = 0) {
    if (level >= maxLevel)
      return;
    for (const key of Object.keys(src)) {
      const value2 = src[key];
      if (!is_plain_object_default(value2) || !is_plain_object_default(dist5[key])) {
        dist5[key] = value2;
      } else {
        deepAssign(dist5[key], value2, maxLevel, level + 1);
      }
    }
    return dist5;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/array.js
  function mapObject(object, callbackfn) {
    return Object.entries(object).reduce((obj, [key, value2]) => {
      obj[key] = callbackfn(value2, key, object);
      return obj;
    }, {});
  }
  function indexOf3(array2) {
    return array2.map((_2, i) => i);
  }
  function firstOf(array2) {
    return array2[0];
  }
  function lastOf(array2) {
    return array2[array2.length - 1];
  }
  function unique(array2) {
    return Array.from(new Set(array2));
  }
  function divide4(array2, callbackfn) {
    const result = [[], []];
    array2.forEach((item) => {
      result[callbackfn(item) ? 0 : 1].push(item);
    });
    return result;
  }
  function comb(array2, len5 = array2.length) {
    if (len5 === 1)
      return array2.map((item) => [item]);
    const result = [];
    for (let i = 0; i < array2.length; i++) {
      const rest = array2.slice(i + 1);
      const restComb = comb(rest, len5 - 1);
      restComb.forEach((comb2) => {
        result.push([array2[i], ...comb2]);
      });
    }
    return result;
  }
  function combine(array2) {
    if (array2.length === 1)
      return [array2];
    const result = [];
    for (let i = 1; i <= array2.length; i++) {
      result.push(...comb(array2, i));
    }
    return result;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/utils/order.js
  function createGroups(groupBy2, I, mark) {
    const { encode } = mark;
    if (groupBy2 === null)
      return [I];
    const G = normalizeGroupBy(groupBy2).map((k) => {
      var _a;
      return [k, (_a = columnOf(encode, k)) === null || _a === void 0 ? void 0 : _a[0]];
    }).filter(([, column2]) => defined(column2));
    const key = (i) => G.map(([, V]) => V[i]).join("-");
    return Array.from(group(I, key).values());
  }
  function normalizeComparator(order) {
    if (Array.isArray(order))
      return createFieldsOrder(order);
    if (typeof order === "function")
      return createFunctionOrder(order);
    if (order === "series")
      return createSeriesOrder;
    if (order === "value")
      return createValueOrder;
    if (order === "sum")
      return createSumOrder;
    if (order === "maxIndex")
      return createMaxIndexOrder;
    return null;
  }
  function applyOrder(groups2, comparator) {
    for (const group3 of groups2) {
      group3.sort(comparator);
    }
  }
  function domainOf(value2, scale9) {
    return (scale9 === null || scale9 === void 0 ? void 0 : scale9.domain) || Array.from(new Set(value2));
  }
  function normalizeGroupBy(groupBy2) {
    if (Array.isArray(groupBy2))
      return groupBy2;
    return [groupBy2];
  }
  function createSeriesOrder(data2, Y, S) {
    return ascendingComparator((i) => S[i]);
  }
  function createFunctionOrder(order) {
    return (data2, Y, S) => {
      return ascendingComparator((i) => order(data2[i]));
    };
  }
  function createFieldsOrder(order) {
    return (data2, Y, S) => {
      return (i, j) => order.reduce((eq, f) => eq !== 0 ? eq : ascending(data2[i][f], data2[j][f]), 0);
    };
  }
  function createValueOrder(data2, Y, S) {
    return ascendingComparator((i) => Y[i]);
  }
  function createSumOrder(data2, Y, S) {
    const I = indexOf3(data2);
    const groups2 = Array.from(group(I, (i) => S[+i]).entries());
    const seriesSum = new Map(groups2.map(([k, GI]) => [k, GI.reduce((s2, i) => s2 + +Y[i])]));
    return ascendingComparator((i) => seriesSum.get(S[i]));
  }
  function createMaxIndexOrder(data2, Y, S) {
    const I = indexOf3(data2);
    const groups2 = Array.from(group(I, (i) => S[+i]).entries());
    const seriesMaxIndex = new Map(groups2.map(([k, GI]) => [k, maxIndex(GI, (i) => Y[i])]));
    return ascendingComparator((i) => seriesMaxIndex.get(S[i]));
  }
  function ascendingComparator(order) {
    return (i, j) => ascending(order(i), order(j));
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/stackY.js
  var StackY = (options = {}) => {
    const { groupBy: groupBy2 = "x", orderBy = null, reverse = false, y: fromY = "y", y1: fromY1 = "y1", series = true } = options;
    return (I, mark) => {
      var _a;
      const { data: data2, encode, style = {} } = mark;
      const [Y, fy] = columnOf(encode, "y");
      const [Y12, fy1] = columnOf(encode, "y1");
      const [S] = series ? maybeColumnOf(encode, "series", "color") : columnOf(encode, "color");
      const groups2 = createGroups(groupBy2, I, mark);
      const createComparator = (_a = normalizeComparator(orderBy)) !== null && _a !== void 0 ? _a : () => null;
      const comparator = createComparator(data2, Y, S);
      if (comparator)
        applyOrder(groups2, comparator);
      const newY = new Array(I.length);
      const newY1 = new Array(I.length);
      const TY = new Array(I.length);
      const F = [];
      const L = [];
      for (const G of groups2) {
        if (reverse)
          G.reverse();
        const start2 = Y12 ? +Y12[G[0]] : 0;
        const PG = [];
        const NG = [];
        for (const i2 of G) {
          const y3 = TY[i2] = +Y[i2] - start2;
          if (y3 < 0)
            NG.push(i2);
          else if (y3 >= 0)
            PG.push(i2);
        }
        const FG = PG.length > 0 ? PG : NG;
        const LG = NG.length > 0 ? NG : PG;
        let i = PG.length - 1;
        let j = 0;
        while (i > 0 && Y[FG[i]] === 0)
          i--;
        while (j < LG.length - 1 && Y[LG[j]] === 0)
          j++;
        F.push(FG[i]);
        L.push(LG[j]);
        let ny = start2;
        for (const i2 of NG.reverse()) {
          const y3 = TY[i2];
          ny = newY[i2] = (newY1[i2] = ny) + y3;
        }
        let py = start2;
        for (const i2 of PG) {
          const y3 = TY[i2];
          if (y3 > 0)
            py = newY[i2] = (newY1[i2] = py) + y3;
          else
            newY[i2] = newY1[i2] = py;
        }
      }
      const FS = new Set(F);
      const LS = new Set(L);
      const V = fromY === "y" ? newY : newY1;
      const V1 = fromY1 === "y" ? newY : newY1;
      return [
        I,
        deep_mix_default({}, mark, {
          encode: {
            y0: inferredColumn(Y, fy),
            y: column(V, fy),
            y1: column(V1, fy1)
          },
          style: Object.assign({ first: (_2, i) => FS.has(i), last: (_2, i) => LS.has(i) }, style)
        })
      ];
    };
  };
  StackY.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/dateFormat.js
  function fillZero(digit) {
    if (Math.abs(digit) > 10)
      return String(digit);
    return digit.toString().padStart(2, "0");
  }
  function dynamicFormatDateTime(date) {
    const year2 = date.getFullYear();
    const month2 = fillZero(date.getMonth() + 1);
    const day2 = fillZero(date.getDate());
    const yyyyMMDD = `${year2}-${month2}-${day2}`;
    const hour2 = date.getHours();
    const minutes = date.getMinutes();
    const seconds = date.getSeconds();
    if (hour2 || minutes || seconds)
      return `${yyyyMMDD} ${fillZero(hour2)}:${fillZero(minutes)}:${fillZero(seconds)}`;
    return yyyyMMDD;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeTitle.js
  var MaybeTitle = (options = {}) => {
    const { channel = "x" } = options;
    return (I, mark) => {
      const { encode } = mark;
      const { tooltip: tooltip2 } = mark;
      if (isUnset(tooltip2))
        return [I, mark];
      const { title } = tooltip2;
      if (title !== void 0)
        return [I, mark];
      const titles = Object.keys(encode).filter((key) => key.startsWith(channel)).filter((key) => !encode[key].inferred).map((key) => columnOf(encode, key)).filter(([T2]) => T2).map((d2) => d2[0]);
      if (titles.length === 0)
        return [I, mark];
      const T = [];
      for (const i of I) {
        T[i] = {
          value: titles.map((t) => t[i] instanceof Date ? dynamicFormatDateTime(t[i]) : t[i]).join(", ")
        };
      }
      return [
        I,
        deep_mix_default({}, mark, {
          tooltip: {
            title: T
          }
        })
      ];
    };
  };
  MaybeTitle.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeZeroX.js
  var MaybeZeroX = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { x: x3 } = encode;
      if (x3 !== void 0)
        return [I, mark];
      return [
        I,
        deep_mix_default({}, mark, {
          encode: { x: inferredColumn(constant(I, 0)) },
          scale: { x: { guide: null } }
        })
      ];
    };
  };
  MaybeZeroX.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeZeroY.js
  var MaybeZeroY = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { y: y3 } = encode;
      if (y3 !== void 0)
        return [I, mark];
      return [
        I,
        deep_mix_default({}, mark, {
          encode: { y: inferredColumn(constant(I, 0)) },
          scale: { y: { guide: null } }
        })
      ];
    };
  };
  MaybeZeroY.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeSize.js
  var MaybeSize = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { size: size2 } = encode;
      if (size2 !== void 0)
        return [I, mark];
      return [
        I,
        deep_mix_default({}, mark, { encode: { size: visualColumn(constant(I, 3)) } })
      ];
    };
  };
  MaybeSize.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeKey.js
  var __rest2 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var MaybeKey = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { key } = encode, rest = __rest2(encode, ["key"]);
      if (key !== void 0)
        return [I, mark];
      const values = Object.values(rest).map(({ value: value2 }) => value2);
      const K = I.map((i) => values.filter(Array.isArray).map((V) => V[i]).join("-"));
      return [I, deep_mix_default({}, mark, { encode: { key: column(K) } })];
    };
  };
  MaybeKey.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeSeries.js
  var MaybeSeries = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { series, color: color2 } = encode;
      if (series !== void 0 || color2 === void 0)
        return [I, mark];
      const [C3, fc] = columnOf(encode, "color");
      return [I, deep_mix_default({}, mark, { encode: { series: column(C3, fc) } })];
    };
  };
  MaybeSeries.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeTupleY.js
  var MaybeTupleY = () => {
    return (I, mark) => {
      const { data: data2 } = mark;
      if (!Array.isArray(data2) || data2.some(isObject))
        return [I, mark];
      return [I, deep_mix_default({}, mark, { encode: { y: column(data2) } })];
    };
  };
  MaybeTupleY.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeTupleX.js
  var MaybeTupleX = () => {
    return (I, mark) => {
      const { data: data2 } = mark;
      if (!Array.isArray(data2) || data2.some(isObject))
        return [I, mark];
      return [I, deep_mix_default({}, mark, { encode: { x: column(data2) } })];
    };
  };
  MaybeTupleX.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeIdentityY.js
  var MaybeIdentityY = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { y1: y12 } = encode;
      if (y12)
        return [I, mark];
      const [Y] = columnOf(encode, "y");
      return [I, deep_mix_default({}, mark, { encode: { y1: column([...Y]) } })];
    };
  };
  MaybeIdentityY.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeIdentityX.js
  var MaybeIdentityX = () => {
    return (I, mark) => {
      const { encode } = mark;
      const { x1: x12 } = encode;
      if (x12)
        return [I, mark];
      const [X] = columnOf(encode, "x");
      return [I, deep_mix_default({}, mark, { encode: { x1: column([...X]) } })];
    };
  };
  MaybeIdentityX.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeDefaultX.js
  var MaybeDefaultX = () => {
    return (I, mark) => {
      const { data: data2 } = mark;
      if (Array.isArray(data2) && (data2.every(Array.isArray) || !data2.some(isObject))) {
        const extractX = (data3, index4) => Array.isArray(data3[0]) ? data3.map((item) => item[index4]) : [data3[index4]];
        return [
          I,
          deep_mix_default({}, mark, {
            encode: {
              x: column(extractX(data2, 0)),
              x1: column(extractX(data2, 1))
            }
          })
        ];
      }
      return [I, mark];
    };
  };
  MaybeDefaultX.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeDefaultY.js
  var MaybeDefaultY = () => {
    return (I, mark) => {
      const { data: data2 } = mark;
      if (Array.isArray(data2) && (data2.every(Array.isArray) || !data2.some(isObject))) {
        const extractY = (data3, index4) => Array.isArray(data3[0]) ? data3.map((item) => item[index4]) : [data3[index4]];
        return [
          I,
          deep_mix_default({}, mark, {
            encode: {
              y: column(extractY(data2, 0)),
              y1: column(extractY(data2, 1))
            }
          })
        ];
      }
      return [I, mark];
    };
  };
  MaybeDefaultY.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeTooltip.js
  var MaybeTooltip = (options) => {
    const { channel } = options;
    return (I, mark) => {
      const { encode, tooltip: tooltip2 } = mark;
      if (isUnset(tooltip2))
        return [I, mark];
      const { items = [] } = tooltip2;
      if (!items || items.length > 0)
        return [I, mark];
      const channels = Array.isArray(channel) ? channel : [channel];
      const newItems = channels.flatMap((channel2) => Object.keys(encode).filter((key) => key.startsWith(channel2)).map((key) => {
        const { field: field3, value: value2, inferred = false, aggregate } = encode[key];
        if (inferred)
          return null;
        if (aggregate && value2)
          return { channel: key };
        if (field3)
          return { field: field3 };
        if (value2)
          return { channel: key };
        return null;
      }).filter((d2) => d2 !== null));
      return [I, deep_mix_default({}, mark, { tooltip: { items: newItems } })];
    };
  };
  MaybeTooltip.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeZeroPadding.js
  var MaybeZeroPadding = () => {
    return (I, mark) => {
      return [
        I,
        deep_mix_default({ scale: { x: { padding: 0 }, y: { padding: 0 } } }, mark)
      ];
    };
  };
  MaybeZeroPadding.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeVisualPosition.js
  var __rest3 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var MaybeVisualPosition = () => {
    return (I, mark) => {
      const { data: data2, style = {} } = mark, restMark = __rest3(mark, ["data", "style"]);
      const { x: x05, y: y05 } = style, rest = __rest3(style, ["x", "y"]);
      if (x05 == void 0 || y05 == void 0)
        return [I, mark];
      const x3 = x05 || 0;
      const y3 = y05 || 0;
      return [
        [0],
        deep_mix_default({}, restMark, {
          data: [0],
          cartesian: true,
          encode: {
            x: column([x3]),
            y: column([y3])
          },
          scale: {
            x: { type: "identity", independent: true, guide: null },
            y: { type: "identity", independent: true, guide: null }
            // hide axis
          },
          style: rest
        })
      ];
    };
  };
  MaybeVisualPosition.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeFunctionAttribute.js
  var MaybeFunctionAttribute = () => {
    return (I, mark) => {
      const { style = {} } = mark;
      return [
        I,
        deep_mix_default({}, mark, {
          style: Object.assign(Object.assign({}, style), Object.fromEntries(Object.entries(style).filter(([, v]) => typeof v === "function").map(([k, v]) => [k, () => v])))
        })
      ];
    };
  };
  MaybeFunctionAttribute.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeTuple.js
  var MaybeTuple = () => {
    return (I, mark) => {
      const { data: data2 } = mark;
      if (!Array.isArray(data2) || data2.some(isObject))
        return [I, mark];
      const position = Array.isArray(data2[0]) ? data2 : [data2];
      const X = position.map((d2) => d2[0]);
      const Y = position.map((d2) => d2[1]);
      return [I, deep_mix_default({}, mark, { encode: { x: column(X), y: column(Y) } })];
    };
  };
  MaybeTuple.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/maybeGradient.js
  var MaybeGradient = () => {
    return (I, mark) => {
      const { style = {}, encode } = mark;
      const { series } = encode;
      const { gradient } = style;
      if (!gradient || series)
        return [I, mark];
      return [
        I,
        deep_mix_default({}, mark, {
          encode: {
            series: visualColumn(constant(I, void 0))
          }
        })
      ];
    };
  };
  MaybeGradient.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/dodgeX.js
  var __rest4 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var DodgeX = (options = {}) => {
    const { groupBy: groupBy2 = "x", reverse = false, orderBy, padding } = options, rest = __rest4(options, ["groupBy", "reverse", "orderBy", "padding"]);
    return (I, mark) => {
      const { data: data2, encode, scale: scale9 } = mark;
      const { series: scaleSeries } = scale9;
      const [Y] = columnOf(encode, "y");
      const [S] = maybeColumnOf(encode, "series", "color");
      const domainSeries = domainOf(S, scaleSeries);
      const newMark = deep_mix_default({}, mark, {
        scale: {
          series: {
            domain: domainSeries,
            paddingInner: padding
          }
        }
      });
      const groups2 = createGroups(groupBy2, I, mark);
      const createComparator = normalizeComparator(orderBy);
      if (!createComparator) {
        return [I, deep_mix_default(newMark, { encode: { series: column(S) } })];
      }
      const comparator = createComparator(data2, Y, S);
      if (comparator)
        applyOrder(groups2, comparator);
      const newS = new Array(I.length);
      for (const G of groups2) {
        if (reverse)
          G.reverse();
        for (let i = 0; i < G.length; i++) {
          newS[G[i]] = domainSeries[i];
        }
      }
      return [
        I,
        deep_mix_default(newMark, {
          encode: {
            series: column(orderBy ? newS : S)
          }
        })
      ];
    };
  };
  DodgeX.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/stackEnter.js
  var StackEnter = (options) => {
    const { groupBy: groupBy2 = ["x"], reducer = (I, V) => V[I[0]], orderBy = null, reverse = false, duration } = options;
    return (I, mark) => {
      const { encode } = mark;
      const by = Array.isArray(groupBy2) ? groupBy2 : [groupBy2];
      const groupEntries = by.map((k) => [k, columnOf(encode, k)[0]]);
      if (groupEntries.length === 0)
        return [I, mark];
      let groups2 = [I];
      for (const [, V] of groupEntries) {
        const newGroups = [];
        for (const I2 of groups2) {
          const G = Array.from(group(I2, (i) => V[i]).values());
          newGroups.push(...G);
        }
        groups2 = newGroups;
      }
      if (orderBy) {
        const [V] = columnOf(encode, orderBy);
        if (V)
          groups2.sort((I2, J) => reducer(I2, V) - reducer(J, V));
        if (reverse)
          groups2.reverse();
      }
      const t = (duration || 3e3) / groups2.length;
      const [ED2] = duration ? [constant(I, t)] : maybeColumnOf(encode, "enterDuration", constant(I, t));
      const [EDL] = maybeColumnOf(encode, "enterDelay", constant(I, 0));
      const newEnterDelay = new Array(I.length);
      for (let i = 0, pd = 0; i < groups2.length; i++) {
        const I2 = groups2[i];
        const maxDuration = max4(I2, (i2) => +ED2[i2]);
        for (const j of I2)
          newEnterDelay[j] = +EDL[j] + pd;
        pd += maxDuration;
      }
      return [
        I,
        deep_mix_default({}, mark, {
          encode: {
            enterDuration: visualColumn(ED2),
            enterDelay: visualColumn(newEnterDelay)
          }
        })
      ];
    };
  };
  StackEnter.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/normalizeY.js
  var __rest5 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function normalizeBasis(basis2) {
    if (typeof basis2 === "function")
      return basis2;
    const registry = {
      min: (I, Y) => min4(I, (i) => Y[+i]),
      max: (I, Y) => max4(I, (i) => Y[+i]),
      first: (I, Y) => Y[I[0]],
      last: (I, Y) => Y[I[I.length - 1]],
      mean: (I, Y) => mean(I, (i) => Y[+i]),
      median: (I, Y) => median(I, (i) => Y[+i]),
      sum: (I, Y) => sum(I, (i) => Y[+i]),
      deviation: (I, Y) => deviation(I, (i) => Y[+i])
    };
    return registry[basis2] || max4;
  }
  var NormalizeY = (options = {}) => {
    const { groupBy: groupBy2 = "x", basis: basis2 = "max" } = options;
    return (I, mark) => {
      const { encode, tooltip: tooltip2 } = mark;
      const { x: x3 } = encode, rest = __rest5(encode, ["x"]);
      const Yn = Object.entries(rest).filter(([k]) => k.startsWith("y")).map(([k]) => [k, columnOf(encode, k)[0]]);
      const [, Y] = Yn.find(([k]) => k === "y");
      const newYn = Yn.map(([k]) => [k, new Array(I.length)]);
      const groups2 = createGroups(groupBy2, I, mark);
      const basisFunction = normalizeBasis(basis2);
      for (const I2 of groups2) {
        const basisValue = basisFunction(I2, Y);
        for (const i of I2) {
          for (let j = 0; j < Yn.length; j++) {
            const [, V] = Yn[j];
            const [, newV] = newYn[j];
            newV[i] = +V[i] / basisValue;
          }
        }
      }
      const specifiedTooltip = isUnset(tooltip2) || (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items) && (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.items.length) !== 0;
      return [
        I,
        deep_mix_default({}, mark, Object.assign({ encode: Object.fromEntries(newYn.map(([k, v]) => [k, column(v, columnOf(encode, k)[1])])) }, !specifiedTooltip && encode.y0 && {
          tooltip: { items: [{ channel: "y0" }] }
        }))
      ];
    };
  };
  NormalizeY.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/compose.js
  function compose2(fn, ...rest) {
    return rest.reduce((pre, cur) => (x3) => pre(cur(x3)), fn);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/normalize.js
  function createNormalize(a3, b) {
    return b - a3 ? (t) => (t - a3) / (b - a3) : (_2) => 0.5;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/clamp.js
  function createClamp(a3, b) {
    const lo = b < a3 ? b : a3;
    const hi = a3 > b ? a3 : b;
    return (x3) => Math.min(Math.max(lo, x3), hi);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/bisect.js
  function bisect(array2, x3, lo, hi, getter) {
    let i = lo || 0;
    let j = hi || array2.length;
    const get2 = getter || ((x4) => x4);
    while (i < j) {
      const mid2 = Math.floor((i + j) / 2);
      if (get2(array2[mid2]) > x3) {
        j = mid2;
      } else {
        i = mid2 + 1;
      }
    }
    return i;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/ticks.js
  var e102 = Math.sqrt(50);
  var e52 = Math.sqrt(10);
  var e22 = Math.sqrt(2);
  function tickIncrement2(start2, stop, count4) {
    const step2 = (stop - start2) / Math.max(0, count4);
    const power = Math.floor(Math.log(step2) / Math.LN10);
    const error4 = step2 / 10 ** power;
    if (power >= 0) {
      return (error4 >= e102 ? 10 : error4 >= e52 ? 5 : error4 >= e22 ? 2 : 1) * 10 ** power;
    }
    return -(10 ** -power) / (error4 >= e102 ? 10 : error4 >= e52 ? 5 : error4 >= e22 ? 2 : 1);
  }
  function tickStep(start2, stop, count4) {
    const step0 = Math.abs(stop - start2) / Math.max(0, count4);
    let step1 = 10 ** Math.floor(Math.log(step0) / Math.LN10);
    const error4 = step0 / step1;
    if (error4 >= e102)
      step1 *= 10;
    else if (error4 >= e52)
      step1 *= 5;
    else if (error4 >= e22)
      step1 *= 2;
    return stop < start2 ? -step1 : step1;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/d3-linear-nice.js
  var d3LinearNice = (min10, max10, count4 = 5) => {
    const d2 = [min10, max10];
    let i0 = 0;
    let i1 = d2.length - 1;
    let start2 = d2[i0];
    let stop = d2[i1];
    let step2;
    if (stop < start2) {
      [start2, stop] = [stop, start2];
      [i0, i1] = [i1, i0];
    }
    step2 = tickIncrement2(start2, stop, count4);
    if (step2 > 0) {
      start2 = Math.floor(start2 / step2) * step2;
      stop = Math.ceil(stop / step2) * step2;
      step2 = tickIncrement2(start2, stop, count4);
    } else if (step2 < 0) {
      start2 = Math.ceil(start2 * step2) / step2;
      stop = Math.floor(stop * step2) / step2;
      step2 = tickIncrement2(start2, stop, count4);
    }
    if (step2 > 0) {
      d2[i0] = Math.floor(start2 / step2) * step2;
      d2[i1] = Math.ceil(stop / step2) * step2;
    } else if (step2 < 0) {
      d2[i0] = Math.ceil(start2 * step2) / step2;
      d2[i1] = Math.floor(stop * step2) / step2;
    }
    return d2;
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/time-interval.js
  var DURATION_SECOND = 1e3;
  var DURATION_MINUTE = DURATION_SECOND * 60;
  var DURATION_HOUR = DURATION_MINUTE * 60;
  var DURATION_DAY = DURATION_HOUR * 24;
  var DURATION_WEEK = DURATION_DAY * 7;
  var DURATION_MONTH = DURATION_DAY * 30;
  var DURATION_YEAR = DURATION_DAY * 365;
  function createInterval(duration, floorish, offseti, field3) {
    const adjust = (date, step2) => {
      const test = (date2) => field3(date2) % step2 === 0;
      let i = step2;
      while (i && !test(date)) {
        offseti(date, -1);
        i -= 1;
      }
      return date;
    };
    const floori = (date, step2) => {
      if (step2)
        adjust(date, step2);
      floorish(date);
    };
    const floor4 = (date, step2) => {
      const d2 = /* @__PURE__ */ new Date(+date);
      floori(d2, step2);
      return d2;
    };
    const ceil5 = (date, step2) => {
      const d2 = new Date(+date - 1);
      floori(d2, step2);
      offseti(d2, step2);
      floori(d2);
      return d2;
    };
    const range3 = (start2, stop, step2, shouldAdjust) => {
      const ticks2 = [];
      const roundStep = Math.floor(step2);
      const t = shouldAdjust ? ceil5(start2, step2) : ceil5(start2);
      for (let i = t; i < stop; offseti(i, roundStep), floori(i)) {
        ticks2.push(/* @__PURE__ */ new Date(+i));
      }
      return ticks2;
    };
    return {
      ceil: ceil5,
      floor: floor4,
      range: range3,
      duration
    };
  }
  var millisecond = createInterval(1, (date) => date, (date, step2 = 1) => {
    date.setTime(+date + step2);
  }, (date) => date.getTime());
  var second = createInterval(DURATION_SECOND, (date) => {
    date.setMilliseconds(0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_SECOND * step2);
  }, (date) => date.getSeconds());
  var minute = createInterval(DURATION_MINUTE, (date) => {
    date.setSeconds(0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_MINUTE * step2);
  }, (date) => date.getMinutes());
  var hour = createInterval(DURATION_HOUR, (date) => {
    date.setMinutes(0, 0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_HOUR * step2);
  }, (date) => date.getHours());
  var day = createInterval(DURATION_DAY, (date) => {
    date.setHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_DAY * step2);
  }, (date) => date.getDate() - 1);
  var month = createInterval(DURATION_MONTH, (date) => {
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    const month2 = date.getMonth();
    date.setMonth(month2 + step2);
  }, (date) => date.getMonth());
  var week = createInterval(DURATION_WEEK, (date) => {
    date.setDate(date.getDate() - date.getDay() % 7);
    date.setHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    date.setDate(date.getDate() + 7 * step2);
  }, (date) => {
    const start2 = month.floor(date);
    const end = /* @__PURE__ */ new Date(+date);
    return Math.floor((+end - +start2) / DURATION_WEEK);
  });
  var year = createInterval(DURATION_YEAR, (date) => {
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    const year2 = date.getFullYear();
    date.setFullYear(year2 + step2);
  }, (date) => date.getFullYear());
  var localIntervalMap = {
    millisecond,
    second,
    minute,
    hour,
    day,
    week,
    month,
    year
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/utc-interval.js
  var utcMillisecond = createInterval(1, (date) => date, (date, step2 = 1) => {
    date.setTime(+date + step2);
  }, (date) => date.getTime());
  var utcSecond = createInterval(DURATION_SECOND, (date) => {
    date.setUTCMilliseconds(0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_SECOND * step2);
  }, (date) => date.getUTCSeconds());
  var utcMinute = createInterval(DURATION_MINUTE, (date) => {
    date.setUTCSeconds(0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_MINUTE * step2);
  }, (date) => date.getUTCMinutes());
  var utcHour = createInterval(DURATION_HOUR, (date) => {
    date.setUTCMinutes(0, 0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_HOUR * step2);
  }, (date) => date.getUTCHours());
  var utcDay = createInterval(DURATION_DAY, (date) => {
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_DAY * step2);
  }, (date) => date.getUTCDate() - 1);
  var utcMonth = createInterval(DURATION_MONTH, (date) => {
    date.setUTCDate(1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    const month2 = date.getUTCMonth();
    date.setUTCMonth(month2 + step2);
  }, (date) => date.getUTCMonth());
  var utcWeek = createInterval(DURATION_WEEK, (date) => {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    date.setTime(+date + DURATION_WEEK * step2);
  }, (date) => {
    const start2 = utcMonth.floor(date);
    const end = /* @__PURE__ */ new Date(+date);
    return Math.floor((+end - +start2) / DURATION_WEEK);
  });
  var utcYear = createInterval(DURATION_YEAR, (date) => {
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step2 = 1) => {
    const year2 = date.getUTCFullYear();
    date.setUTCFullYear(year2 + step2);
  }, (date) => date.getUTCFullYear());
  var utcIntervalMap = {
    millisecond: utcMillisecond,
    second: utcSecond,
    minute: utcMinute,
    hour: utcHour,
    day: utcDay,
    week: utcWeek,
    month: utcMonth,
    year: utcYear
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/find-tick-interval.js
  function chooseTickIntervals(utc) {
    const intervalMap = utc ? utcIntervalMap : localIntervalMap;
    const { year: year2, month: month2, week: week2, day: day2, hour: hour2, minute: minute2, second: second2, millisecond: millisecond2 } = intervalMap;
    const tickIntervals = [
      [second2, 1],
      [second2, 5],
      [second2, 15],
      [second2, 30],
      [minute2, 1],
      [minute2, 5],
      [minute2, 15],
      [minute2, 30],
      [hour2, 1],
      [hour2, 3],
      [hour2, 6],
      [hour2, 12],
      [day2, 1],
      [day2, 2],
      [week2, 1],
      [month2, 1],
      [month2, 3],
      [year2, 1]
    ];
    return {
      tickIntervals,
      year: year2,
      millisecond: millisecond2
    };
  }
  function findTickInterval(start2, stop, count4, interval2, utc) {
    const lo = +start2;
    const hi = +stop;
    const { tickIntervals, year: year2, millisecond: millisecond2 } = chooseTickIntervals(utc);
    const getter = ([interval3, count5]) => interval3.duration * count5;
    const targetCount = interval2 ? (hi - lo) / interval2 : count4 || 5;
    const targetInterval = interval2 || (hi - lo) / targetCount;
    const len5 = tickIntervals.length;
    const i = bisect(tickIntervals, targetInterval, 0, len5, getter);
    let matchInterval;
    if (i === len5) {
      const step2 = tickStep(lo / year2.duration, hi / year2.duration, targetCount);
      matchInterval = [year2, step2];
    } else if (i) {
      const closeToLow = targetInterval / getter(tickIntervals[i - 1]) < getter(tickIntervals[i]) / targetInterval;
      const [timeInterval, targetStep] = closeToLow ? tickIntervals[i - 1] : tickIntervals[i];
      const step2 = interval2 ? Math.ceil(interval2 / timeInterval.duration) : targetStep;
      matchInterval = [timeInterval, step2];
    } else {
      const step2 = Math.max(tickStep(lo, hi, targetCount), 1);
      matchInterval = [millisecond2, step2];
    }
    return matchInterval;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/d3-time-nice.js
  var d3TimeNice = (min10, max10, count4, interval2, utc) => {
    const r = min10 > max10;
    const lo = r ? max10 : min10;
    const hi = r ? min10 : max10;
    const [tickInterval, step2] = findTickInterval(lo, hi, count4, interval2, utc);
    const domain = [tickInterval.floor(lo, step2), tickInterval.ceil(hi, step2)];
    return r ? domain.reverse() : domain;
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/is-valid.js
  function isValid(x3) {
    return !is_undefined_default(x3) && !is_null_default(x3) && !Number.isNaN(x3);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/log.js
  var reflect = (f) => {
    return (x3) => -f(-x3);
  };
  var logs = (base, shouldReflect) => {
    const baseCache = Math.log(base);
    const log2 = base === Math.E ? Math.log : base === 10 ? Math.log10 : base === 2 ? Math.log2 : (x3) => Math.log(x3) / baseCache;
    return shouldReflect ? reflect(log2) : log2;
  };
  var pows = (base, shouldReflect) => {
    const pow3 = base === Math.E ? Math.exp : (x3) => base ** x3;
    return shouldReflect ? reflect(pow3) : pow3;
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/d3-log-nice.js
  var d3LogNice = (a3, b, _2, base) => {
    const shouldReflect = a3 < 0;
    const log2 = logs(base, shouldReflect);
    const pow3 = pows(base, shouldReflect);
    const r = a3 > b;
    const min10 = r ? b : a3;
    const max10 = r ? a3 : b;
    const niceDomain = [pow3(Math.floor(log2(min10))), pow3(Math.ceil(log2(max10)))];
    return r ? niceDomain.reverse() : niceDomain;
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/interpolatize.js
  var createInterpolatorRound = (interpolator) => {
    return (t) => {
      const res = interpolator(t);
      return is_number_default(res) ? Math.round(res) : res;
    };
  };
  function interpolatize(rangeOf4, normalizeDomain2) {
    return (Scale) => {
      Scale.prototype.rescale = function() {
        this.initRange();
        this.nice();
        const [transform] = this.chooseTransforms();
        this.composeOutput(transform, this.chooseClamp(transform));
      };
      Scale.prototype.initRange = function() {
        const { interpolator } = this.options;
        this.options.range = rangeOf4(interpolator);
      };
      Scale.prototype.composeOutput = function(transform, clamp7) {
        const { domain, interpolator, round: round5 } = this.getOptions();
        const normalize10 = normalizeDomain2(domain.map(transform));
        const interpolate5 = round5 ? createInterpolatorRound(interpolator) : interpolator;
        this.output = compose2(interpolate5, normalize10, clamp7, transform);
      };
      Scale.prototype.invert = void 0;
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/color.js
  var import_color_string = __toESM(require_color_string());
  function hue2rgb(p2, q, m3) {
    let t = m3;
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p2 + (q - p2) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p2 + (q - p2) * (2 / 3 - t) * 6;
    return p2;
  }
  function hsl2rbg(hsl2) {
    const h = hsl2[0] / 360;
    const s2 = hsl2[1] / 100;
    const l2 = hsl2[2] / 100;
    const a3 = hsl2[3];
    if (s2 === 0)
      return [l2 * 255, l2 * 255, l2 * 255, a3];
    const q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    const p2 = 2 * l2 - q;
    const r = hue2rgb(p2, q, h + 1 / 3);
    const g = hue2rgb(p2, q, h);
    const b = hue2rgb(p2, q, h - 1 / 3);
    return [r * 255, g * 255, b * 255, a3];
  }
  function string2rbg(s2) {
    const color2 = import_color_string.default.get(s2);
    if (!color2)
      return null;
    const { model, value: value2 } = color2;
    if (model === "rgb")
      return value2;
    if (model === "hsl")
      return hsl2rbg(value2);
    return null;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/interpolate.js
  var createInterpolateNumber = (a3, b) => {
    return (t) => a3 * (1 - t) + b * t;
  };
  var createInterpolateColor = (a3, b) => {
    const c1 = string2rbg(a3);
    const c22 = string2rbg(b);
    if (c1 === null || c22 === null)
      return c1 ? () => a3 : () => b;
    return (t) => {
      const values = new Array(4);
      for (let i = 0; i < 4; i += 1) {
        const from = c1[i];
        const to = c22[i];
        values[i] = from * (1 - t) + to * t;
      }
      const [r, g, b2, a4] = values;
      return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b2)}, ${a4})`;
    };
  };
  var createInterpolateValue = (a3, b) => {
    if (typeof a3 === "number" && typeof b === "number")
      return createInterpolateNumber(a3, b);
    if (typeof a3 === "string" && typeof b === "string")
      return createInterpolateColor(a3, b);
    return () => a3;
  };
  var createInterpolateRound = (a3, b) => {
    const interpolateNumber = createInterpolateNumber(a3, b);
    return (t) => Math.round(interpolateNumber(t));
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/choose-mask.js
  function chooseNiceTimeMask(date, intervalMap) {
    const { second: second2, minute: minute2, hour: hour2, day: day2, week: week2, month: month2, year: year2 } = intervalMap;
    if (second2.floor(date) < date)
      return ".SSS";
    if (minute2.floor(date) < date)
      return ":ss";
    if (hour2.floor(date) < date)
      return "hh:mm";
    if (day2.floor(date) < date)
      return "hh A";
    if (month2.floor(date) < date) {
      if (week2.floor(date) < date)
        return "MMM DD";
      return "ddd DD";
    }
    if (year2.floor(date) < date)
      return "MMMM";
    return "YYYY";
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/internMap.js
  function internGet({ map: map3, initKey }, value2) {
    const key = initKey(value2);
    return map3.has(key) ? map3.get(key) : value2;
  }
  function internSet({ map: map3, initKey }, value2) {
    const key = initKey(value2);
    if (map3.has(key))
      return map3.get(key);
    map3.set(key, value2);
    return value2;
  }
  function internDelete({ map: map3, initKey }, value2) {
    const key = initKey(value2);
    if (map3.has(key)) {
      value2 = map3.get(key);
      map3.delete(key);
    }
    return value2;
  }
  function keyof2(value2) {
    return typeof value2 === "object" ? value2.valueOf() : value2;
  }
  var InternMap2 = class extends Map {
    constructor(entries) {
      super();
      this.map = /* @__PURE__ */ new Map();
      this.initKey = keyof2;
      if (entries !== null) {
        for (const [key, value2] of entries) {
          this.set(key, value2);
        }
      }
    }
    get(key) {
      return super.get(internGet({ map: this.map, initKey: this.initKey }, key));
    }
    has(key) {
      return super.has(internGet({ map: this.map, initKey: this.initKey }, key));
    }
    set(key, value2) {
      return super.set(internSet({ map: this.map, initKey: this.initKey }, key), value2);
    }
    delete(key) {
      return super.delete(internDelete({ map: this.map, initKey: this.initKey }, key));
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/base.js
  var Base = class {
    /**
     * 构造函数，根据自定义的选项和默认选项生成当前选项
     * @param options 需要自定义配置的选项
     */
    constructor(options) {
      this.options = deep_mix_default({}, this.getDefaultOptions());
      this.update(options);
    }
    /**
     * 返回当前的所有选项
     * @returns 当前的所有选项
     */
    getOptions() {
      return this.options;
    }
    /**
     * 更新选项和比例尺的内部状态
     * @param updateOptions 需要更新的选项
     */
    update(updateOptions = {}) {
      this.options = deep_mix_default({}, this.options, updateOptions);
      this.rescale(updateOptions);
    }
    /**
     * 根据需要更新 options 和更新后的 options 更新 scale 的内部状态，
     * 在函数内部可以用 this.options 获得更新后的 options
     * @param options 需要更新的 options
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    rescale(options) {
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/ordinal.js
  var defaultUnknown = Symbol("defaultUnknown");
  function updateIndexMap(target, arr, key) {
    for (let i = 0; i < arr.length; i += 1) {
      if (!target.has(arr[i])) {
        target.set(key(arr[i]), i);
      }
    }
  }
  function mapBetweenArrByMapIndex(options) {
    const { value: value2, from, to, mapper, notFoundReturn } = options;
    let mappedIndex = mapper.get(value2);
    if (mappedIndex === void 0) {
      if (notFoundReturn !== defaultUnknown) {
        return notFoundReturn;
      }
      mappedIndex = from.push(value2) - 1;
      mapper.set(value2, mappedIndex);
    }
    return to[mappedIndex % to.length];
  }
  function createKey(d2) {
    if (d2 instanceof Date)
      return (d3) => `${d3}`;
    if (typeof d2 === "object")
      return (d3) => JSON.stringify(d3);
    return (d3) => d3;
  }
  var Ordinal = class _Ordinal extends Base {
    // 覆盖默认配置
    getDefaultOptions() {
      return {
        domain: [],
        range: [],
        unknown: defaultUnknown
      };
    }
    // 显示指定 options 的类型为 OrdinalOptions，从而推断出 O 的类型
    constructor(options) {
      super(options);
    }
    map(x3) {
      if (this.domainIndexMap.size === 0) {
        updateIndexMap(this.domainIndexMap, this.getDomain(), this.domainKey);
      }
      return mapBetweenArrByMapIndex({
        value: this.domainKey(x3),
        mapper: this.domainIndexMap,
        from: this.getDomain(),
        to: this.getRange(),
        notFoundReturn: this.options.unknown
      });
    }
    invert(y3) {
      if (this.rangeIndexMap.size === 0) {
        updateIndexMap(this.rangeIndexMap, this.getRange(), this.rangeKey);
      }
      return mapBetweenArrByMapIndex({
        value: this.rangeKey(y3),
        mapper: this.rangeIndexMap,
        from: this.getRange(),
        to: this.getDomain(),
        notFoundReturn: this.options.unknown
      });
    }
    // 因为 ordinal 比例尺更新内部状态的开销较大，所以按需更新
    rescale(options) {
      const [d2] = this.options.domain;
      const [r] = this.options.range;
      this.domainKey = createKey(d2);
      this.rangeKey = createKey(r);
      if (!this.rangeIndexMap) {
        this.rangeIndexMap = /* @__PURE__ */ new Map();
        this.domainIndexMap = /* @__PURE__ */ new Map();
        return;
      }
      if (!options || options.range) {
        this.rangeIndexMap.clear();
      }
      if (!options || options.domain || options.compare) {
        this.domainIndexMap.clear();
        this.sortedDomain = void 0;
      }
    }
    clone() {
      return new _Ordinal(this.options);
    }
    getRange() {
      return this.options.range;
    }
    getDomain() {
      if (this.sortedDomain)
        return this.sortedDomain;
      const { domain, compare } = this.options;
      this.sortedDomain = compare ? [...domain].sort(compare) : domain;
      return this.sortedDomain;
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/band.js
  function normalize5(array2) {
    const min10 = Math.min(...array2);
    return array2.map((d2) => d2 / min10);
  }
  function splice(array2, n2) {
    const sn = array2.length;
    const diff = n2 - sn;
    return diff > 0 ? [...array2, ...new Array(diff).fill(1)] : diff < 0 ? array2.slice(0, n2) : array2;
  }
  function pretty(n2) {
    return Math.round(n2 * 1e12) / 1e12;
  }
  function computeFlexBandState(options) {
    const { domain, range: range3, paddingOuter, paddingInner, flex: F, round: round5, align } = options;
    const n2 = domain.length;
    const flex2 = splice(F, n2);
    const [start2, end] = range3;
    const width = end - start2;
    const ratio = 2 / n2 * paddingOuter + 1 - 1 / n2 * paddingInner;
    const stepSum = width / ratio;
    const PI = stepSum * paddingInner / n2;
    const bandWidthSum = stepSum - n2 * PI;
    const normalizedFlex = normalize5(flex2);
    const flexSum = normalizedFlex.reduce((sum3, value2) => sum3 + value2);
    const minBandWidth = bandWidthSum / flexSum;
    const valueBandWidth = new InternMap2(domain.map((d2, i) => {
      const bandWidth3 = normalizedFlex[i] * minBandWidth;
      return [d2, round5 ? Math.floor(bandWidth3) : bandWidth3];
    }));
    const valueStep = new InternMap2(domain.map((d2, i) => {
      const bandWidth3 = normalizedFlex[i] * minBandWidth;
      const step2 = bandWidth3 + PI;
      return [d2, round5 ? Math.floor(step2) : step2];
    }));
    const finalStepSum = Array.from(valueStep.values()).reduce((sum3, value2) => sum3 + value2);
    const outerPaddingSum = width - (finalStepSum - finalStepSum / n2 * paddingInner);
    const offset3 = outerPaddingSum * align;
    const bandStart = start2 + offset3;
    let prev = round5 ? Math.round(bandStart) : bandStart;
    const adjustedRange = new Array(n2);
    for (let i = 0; i < n2; i += 1) {
      adjustedRange[i] = pretty(prev);
      const value2 = domain[i];
      prev += valueStep.get(value2);
    }
    return {
      valueBandWidth,
      valueStep,
      adjustedRange
    };
  }
  function computeBandState(options) {
    var _a;
    const { domain } = options;
    const n2 = domain.length;
    if (n2 === 0) {
      return {
        valueBandWidth: void 0,
        valueStep: void 0,
        adjustedRange: []
      };
    }
    const hasFlex = !!((_a = options.flex) === null || _a === void 0 ? void 0 : _a.length);
    if (hasFlex) {
      return computeFlexBandState(options);
    }
    const { range: range3, paddingOuter, paddingInner, round: round5, align } = options;
    let step2;
    let bandWidth3;
    let rangeStart = range3[0];
    const rangeEnd = range3[1];
    const deltaRange = rangeEnd - rangeStart;
    const outerTotal = paddingOuter * 2;
    const innerTotal = n2 - paddingInner;
    step2 = deltaRange / Math.max(1, outerTotal + innerTotal);
    if (round5) {
      step2 = Math.floor(step2);
    }
    rangeStart += (deltaRange - step2 * (n2 - paddingInner)) * align;
    bandWidth3 = step2 * (1 - paddingInner);
    if (round5) {
      rangeStart = Math.round(rangeStart);
      bandWidth3 = Math.round(bandWidth3);
    }
    const adjustedRange = new Array(n2).fill(0).map((_2, i) => rangeStart + i * step2);
    return {
      valueStep: step2,
      valueBandWidth: bandWidth3,
      adjustedRange
    };
  }
  var Band = class _Band extends Ordinal {
    // 覆盖默认配置
    getDefaultOptions() {
      return {
        domain: [],
        range: [0, 1],
        align: 0.5,
        round: false,
        paddingInner: 0,
        paddingOuter: 0,
        padding: 0,
        unknown: defaultUnknown,
        flex: []
      };
    }
    // 显示指定 options 的类型为 OrdinalOptions，从而推断出 O 的类型
    constructor(options) {
      super(options);
    }
    clone() {
      return new _Band(this.options);
    }
    getStep(x3) {
      if (this.valueStep === void 0)
        return 1;
      if (typeof this.valueStep === "number") {
        return this.valueStep;
      }
      if (x3 === void 0)
        return Array.from(this.valueStep.values())[0];
      return this.valueStep.get(x3);
    }
    getBandWidth(x3) {
      if (this.valueBandWidth === void 0)
        return 1;
      if (typeof this.valueBandWidth === "number") {
        return this.valueBandWidth;
      }
      if (x3 === void 0)
        return Array.from(this.valueBandWidth.values())[0];
      return this.valueBandWidth.get(x3);
    }
    getRange() {
      return this.adjustedRange;
    }
    getPaddingInner() {
      const { padding, paddingInner } = this.options;
      return padding > 0 ? padding : paddingInner;
    }
    getPaddingOuter() {
      const { padding, paddingOuter } = this.options;
      return padding > 0 ? padding : paddingOuter;
    }
    rescale() {
      super.rescale();
      const { align, domain, range: range3, round: round5, flex: flex2 } = this.options;
      const { adjustedRange, valueBandWidth, valueStep } = computeBandState({
        align,
        range: range3,
        round: round5,
        flex: flex2,
        paddingInner: this.getPaddingInner(),
        paddingOuter: this.getPaddingOuter(),
        domain
      });
      this.valueStep = valueStep;
      this.valueBandWidth = valueBandWidth;
      this.adjustedRange = adjustedRange;
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/tick-methods/d3-ticks.js
  var d3Ticks = (begin, end, count4) => {
    let n2;
    let ticks2;
    let start2 = begin;
    let stop = end;
    if (start2 === stop && count4 > 0) {
      return [start2];
    }
    let step2 = tickIncrement2(start2, stop, count4);
    if (step2 === 0 || !Number.isFinite(step2)) {
      return [];
    }
    if (step2 > 0) {
      start2 = Math.ceil(start2 / step2);
      stop = Math.floor(stop / step2);
      ticks2 = new Array(n2 = Math.ceil(stop - start2 + 1));
      for (let i = 0; i < n2; i += 1) {
        ticks2[i] = (start2 + i) * step2;
      }
    } else {
      step2 = -step2;
      start2 = Math.ceil(start2 * step2);
      stop = Math.floor(stop * step2);
      ticks2 = new Array(n2 = Math.ceil(stop - start2 + 1));
      for (let i = 0; i < n2; i += 1) {
        ticks2[i] = (start2 + i) / step2;
      }
    }
    return ticks2;
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/constant.js
  var Constant2 = class _Constant extends Base {
    /**
     * 返回需要覆盖的默认选项
     * @returns 需要覆盖的默认选项
     */
    getDefaultOptions() {
      return {
        range: [0],
        domain: [0, 1],
        unknown: void 0,
        tickCount: 5,
        tickMethod: d3Ticks
      };
    }
    /**
     * 输入和输出满足：y = b，其中 b 是一个常量，是 options.range 的第一个元素
     * @param _ 输入值
     * @returns 输出值（常量）
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    map(_2) {
      const [v] = this.options.range;
      return v !== void 0 ? v : this.options.unknown;
    }
    /**
     * 如果 x 是该比例尺的常量（x === b），返回输入值的范围（即定义域），否者返回 []
     * @param x 输出值 (常量）
     * @returns 定义域
     */
    invert(x3) {
      const [v] = this.options.range;
      return x3 === v && v !== void 0 ? this.options.domain : [];
    }
    getTicks() {
      const { tickMethod, domain, tickCount } = this.options;
      const [a3, b] = domain;
      if (!is_number_default(a3) || !is_number_default(b))
        return [];
      return tickMethod(a3, b, tickCount);
    }
    /**
     * 克隆 Constant Scale
     * @returns 拥有相同选项且独立的 Constant Scale
     */
    clone() {
      return new _Constant(this.options);
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/pretty-number.js
  function prettyNumber(n2) {
    return Math.abs(n2) < 1e-14 ? n2 : parseFloat(n2.toFixed(14));
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/tick-methods/wilkinson-extended.js
  var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
  var eps = Number.EPSILON * 100;
  function mod(n2, m3) {
    return (n2 % m3 + m3) % m3;
  }
  function round4(n2) {
    return Math.round(n2 * 1e12) / 1e12;
  }
  function simplicity(q, Q, j, lmin, lmax, lstep) {
    const n2 = size(Q);
    const i = index_of_default(Q, q);
    let v = 0;
    const m3 = mod(lmin, lstep);
    if ((m3 < eps || lstep - m3 < eps) && lmin <= 0 && lmax >= 0) {
      v = 1;
    }
    return 1 - i / (n2 - 1) - j + v;
  }
  function simplicityMax(q, Q, j) {
    const n2 = size(Q);
    const i = index_of_default(Q, q);
    const v = 1;
    return 1 - i / (n2 - 1) - j + v;
  }
  function density(k, m3, dMin, dMax, lMin, lMax) {
    const r = (k - 1) / (lMax - lMin);
    const rt = (m3 - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
    return 2 - Math.max(r / rt, rt / r);
  }
  function densityMax(k, m3) {
    if (k >= m3) {
      return 2 - (k - 1) / (m3 - 1);
    }
    return 1;
  }
  function coverage(dMin, dMax, lMin, lMax) {
    const range3 = dMax - dMin;
    return 1 - 0.5 * ((dMax - lMax) ** 2 + (dMin - lMin) ** 2) / (0.1 * range3) ** 2;
  }
  function coverageMax(dMin, dMax, span) {
    const range3 = dMax - dMin;
    if (span > range3) {
      const half = (span - range3) / 2;
      return 1 - half ** 2 / (0.1 * range3) ** 2;
    }
    return 1;
  }
  function legibility() {
    return 1;
  }
  var wilkinsonExtended = (dMin, dMax, n2 = 5, onlyLoose = true, Q = DEFAULT_Q, w = [0.25, 0.2, 0.5, 0.05]) => {
    const m3 = n2 < 0 ? 0 : Math.round(n2);
    if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m3) {
      return [];
    }
    if (dMax - dMin < 1e-15 || m3 === 1) {
      return [dMin];
    }
    const best = {
      score: -2,
      lmin: 0,
      lmax: 0,
      lstep: 0
    };
    let j = 1;
    while (j < Infinity) {
      for (let i = 0; i < Q.length; i += 1) {
        const q = Q[i];
        const sm = simplicityMax(q, Q, j);
        if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
          j = Infinity;
          break;
        }
        let k = 2;
        while (k < Infinity) {
          const dm = densityMax(k, m3);
          if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {
            break;
          }
          const delta = (dMax - dMin) / (k + 1) / j / q;
          let z = Math.ceil(Math.log10(delta));
          while (z < Infinity) {
            const step2 = j * q * 10 ** z;
            const cm = coverageMax(dMin, dMax, step2 * (k - 1));
            if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {
              break;
            }
            const minStart = Math.floor(dMax / step2) * j - (k - 1) * j;
            const maxStart = Math.ceil(dMin / step2) * j;
            if (minStart <= maxStart) {
              const count4 = maxStart - minStart;
              for (let i2 = 0; i2 <= count4; i2 += 1) {
                const start2 = minStart + i2;
                const lMin = start2 * (step2 / j);
                const lMax = lMin + step2 * (k - 1);
                const lStep = step2;
                const s2 = simplicity(q, Q, j, lMin, lMax, lStep);
                const c5 = coverage(dMin, dMax, lMin, lMax);
                const g = density(k, m3, dMin, dMax, lMin, lMax);
                const l2 = legibility();
                const score2 = w[0] * s2 + w[1] * c5 + w[2] * g + w[3] * l2;
                if (score2 > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                  best.lmin = lMin;
                  best.lmax = lMax;
                  best.lstep = lStep;
                  best.score = score2;
                }
              }
            }
            z += 1;
          }
          k += 1;
        }
      }
      j += 1;
    }
    const lmax = prettyNumber(best.lmax);
    const lmin = prettyNumber(best.lmin);
    const lstep = prettyNumber(best.lstep);
    const tickCount = Math.floor(round4((lmax - lmin) / lstep)) + 1;
    const ticks2 = new Array(tickCount);
    ticks2[0] = prettyNumber(lmin);
    for (let i = 1; i < tickCount; i += 1) {
      ticks2[i] = prettyNumber(ticks2[i - 1] + lstep);
    }
    return ticks2;
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/identity.js
  var Identity = class _Identity extends Base {
    /**
     * 返回需要覆盖的默认选项
     * @returns 需要覆盖的默认选项
     */
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        tickCount: 5,
        unknown: void 0,
        tickMethod: wilkinsonExtended
      };
    }
    /**
     * 输入和输出满足：y = x
     * @param x 输入值
     * @returns 输出值
     */
    map(x3) {
      return isValid(x3) ? x3 : this.options.unknown;
    }
    /**
     * map 的逆运算：x = y，在这里和 map 是相同方法
     * @param x 输出值
     * @returns 输入值
     */
    invert(x3) {
      return this.map(x3);
    }
    /**
     * 克隆 Identity Scale
     * @returns 拥有相同选项且独立的 Identity Scale
     */
    clone() {
      return new _Identity(this.options);
    }
    /**
     * 根据比例尺的配置去生成 ticks，该 ticks 主要用于生成坐标轴
     * @returns 返回一个 ticks 的数组
     */
    getTicks() {
      const { domain, tickCount, tickMethod } = this.options;
      const [min10, max10] = domain;
      if (!is_number_default(min10) || !is_number_default(max10))
        return [];
      return tickMethod(min10, max10, tickCount);
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/continuous.js
  var createBiMap = (domain, range3, createInterpolate) => {
    const [d0, d1] = domain;
    const [r0, r1] = range3;
    let normalize10;
    let interpolate5;
    if (d0 < d1) {
      normalize10 = createNormalize(d0, d1);
      interpolate5 = createInterpolate(r0, r1);
    } else {
      normalize10 = createNormalize(d1, d0);
      interpolate5 = createInterpolate(r1, r0);
    }
    return compose2(interpolate5, normalize10);
  };
  var createPolyMap = (domain, range3, createInterpolate) => {
    const len5 = Math.min(domain.length, range3.length) - 1;
    const normalizeList = new Array(len5);
    const interpolateList = new Array(len5);
    const reverse = domain[0] > domain[len5];
    const ascendingDomain = reverse ? [...domain].reverse() : domain;
    const ascendingRange = reverse ? [...range3].reverse() : range3;
    for (let i = 0; i < len5; i += 1) {
      normalizeList[i] = createNormalize(ascendingDomain[i], ascendingDomain[i + 1]);
      interpolateList[i] = createInterpolate(ascendingRange[i], ascendingRange[i + 1]);
    }
    return (x3) => {
      const i = bisect(domain, x3, 1, len5) - 1;
      const normalize10 = normalizeList[i];
      const interpolate5 = interpolateList[i];
      return compose2(interpolate5, normalize10)(x3);
    };
  };
  var choosePiecewise = (domain, range3, interpolate5, shouldRound) => {
    const n2 = Math.min(domain.length, range3.length);
    const createPiecewise = n2 > 2 ? createPolyMap : createBiMap;
    const createInterpolate = shouldRound ? createInterpolateRound : interpolate5;
    return createPiecewise(domain, range3, createInterpolate);
  };
  var Continuous = class extends Base {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        nice: false,
        clamp: false,
        round: false,
        interpolate: createInterpolateNumber,
        tickCount: 5
      };
    }
    /**
     * y = interpolate(normalize(clamp(transform(x))))
     */
    map(x3) {
      if (!isValid(x3))
        return this.options.unknown;
      return this.output(x3);
    }
    /**
     * x = transform(clamp(interpolate(normalize(y))))
     */
    invert(x3) {
      if (!isValid(x3))
        return this.options.unknown;
      return this.input(x3);
    }
    nice() {
      if (!this.options.nice)
        return;
      const [min10, max10, tickCount, ...rest] = this.getTickMethodOptions();
      this.options.domain = this.chooseNice()(min10, max10, tickCount, ...rest);
    }
    getTicks() {
      const { tickMethod } = this.options;
      const [min10, max10, tickCount, ...rest] = this.getTickMethodOptions();
      return tickMethod(min10, max10, tickCount, ...rest);
    }
    getTickMethodOptions() {
      const { domain, tickCount } = this.options;
      const min10 = domain[0];
      const max10 = domain[domain.length - 1];
      return [min10, max10, tickCount];
    }
    chooseNice() {
      return d3LinearNice;
    }
    rescale() {
      this.nice();
      const [transform, untransform] = this.chooseTransforms();
      this.composeOutput(transform, this.chooseClamp(transform));
      this.composeInput(transform, untransform, this.chooseClamp(untransform));
    }
    chooseClamp(transform) {
      const { clamp: shouldClamp, range: range3 } = this.options;
      const domain = this.options.domain.map(transform);
      const n2 = Math.min(domain.length, range3.length);
      return shouldClamp ? createClamp(domain[0], domain[n2 - 1]) : identity_default;
    }
    composeOutput(transform, clamp7) {
      const { domain, range: range3, round: round5, interpolate: interpolate5 } = this.options;
      const piecewise = choosePiecewise(domain.map(transform), range3, interpolate5, round5);
      this.output = compose2(piecewise, clamp7, transform);
    }
    composeInput(transform, untransform, clamp7) {
      const { domain, range: range3 } = this.options;
      const piecewise = choosePiecewise(range3, domain.map(transform), createInterpolateNumber);
      this.input = compose2(untransform, clamp7, piecewise);
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/linear.js
  var Linear = class _Linear extends Continuous {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        unknown: void 0,
        nice: false,
        clamp: false,
        round: false,
        interpolate: createInterpolateValue,
        tickMethod: d3Ticks,
        tickCount: 5
      };
    }
    chooseTransforms() {
      return [identity_default, identity_default];
    }
    clone() {
      return new _Linear(this.options);
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/point.js
  var Point = class _Point extends Band {
    // 覆盖默认配置
    getDefaultOptions() {
      return {
        domain: [],
        range: [0, 1],
        align: 0.5,
        round: false,
        padding: 0,
        unknown: defaultUnknown,
        paddingInner: 1,
        paddingOuter: 0
      };
    }
    // 能接受的参数只是 PointOptions，不能有 paddingInner 这些属性
    constructor(options) {
      super(options);
    }
    // Point 的 paddingInner 只能是1，不能被覆盖
    getPaddingInner() {
      return 1;
    }
    clone() {
      return new _Point(this.options);
    }
    update(options) {
      super.update(options);
    }
    getPaddingOuter() {
      return this.options.padding;
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/pow.js
  var transformPow = (exponent) => {
    return (x3) => {
      return x3 < 0 ? -((-x3) ** exponent) : x3 ** exponent;
    };
  };
  var transformPowInvert = (exponent) => {
    return (x3) => {
      return x3 < 0 ? -((-x3) ** (1 / exponent)) : x3 ** (1 / exponent);
    };
  };
  var transformSqrt = (x3) => {
    return x3 < 0 ? -Math.sqrt(-x3) : Math.sqrt(x3);
  };
  var Pow = class _Pow extends Continuous {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        nice: false,
        clamp: false,
        round: false,
        exponent: 2,
        interpolate: createInterpolateValue,
        tickMethod: d3Ticks,
        tickCount: 5
      };
    }
    // 显示指定 options 的类型为 PowOptions O 的类型
    constructor(options) {
      super(options);
    }
    chooseTransforms() {
      const { exponent } = this.options;
      if (exponent === 1)
        return [identity_default, identity_default];
      const transform = exponent === 0.5 ? transformSqrt : transformPow(exponent);
      const untransform = transformPowInvert(exponent);
      return [transform, untransform];
    }
    clone() {
      return new _Pow(this.options);
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/sqrt.js
  var Sqrt = class _Sqrt extends Pow {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        nice: false,
        clamp: false,
        round: false,
        interpolate: createInterpolateValue,
        tickMethod: d3Ticks,
        tickCount: 5,
        exponent: 0.5
      };
    }
    constructor(options) {
      super(options);
    }
    update(options) {
      super.update(options);
    }
    clone() {
      return new _Sqrt(this.options);
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/threshold.js
  var Threshold = class _Threshold extends Base {
    getDefaultOptions() {
      return {
        domain: [0.5],
        range: [0, 1]
      };
    }
    constructor(options) {
      super(options);
    }
    /**
     * 二分查找到输入值在哪一段，返回对应的值域中的值
     */
    map(x3) {
      if (!isValid(x3))
        return this.options.unknown;
      const index4 = bisect(this.thresholds, x3, 0, this.n);
      return this.options.range[index4];
    }
    /**
     * 在值域中找到对应的值，并返回在定义域中属于哪一段
     */
    invert(y3) {
      const { range: range3 } = this.options;
      const index4 = range3.indexOf(y3);
      const domain = this.thresholds;
      return [domain[index4 - 1], domain[index4]];
    }
    clone() {
      return new _Threshold(this.options);
    }
    rescale() {
      const { domain, range: range3 } = this.options;
      this.n = Math.min(domain.length, range3.length - 1);
      this.thresholds = domain;
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/tick-methods/d3-log.js
  var d3Log = (a3, b, n2, base = 10) => {
    const shouldReflect = a3 < 0;
    const pow3 = pows(base, shouldReflect);
    const log2 = logs(base, shouldReflect);
    const r = b < a3;
    const min10 = r ? b : a3;
    const max10 = r ? a3 : b;
    let i = log2(min10);
    let j = log2(max10);
    let ticks2 = [];
    if (!(base % 1) && j - i < n2) {
      i = Math.floor(i);
      j = Math.ceil(j);
      if (shouldReflect) {
        for (; i <= j; i += 1) {
          const p2 = pow3(i);
          for (let k = base - 1; k >= 1; k -= 1) {
            const t = p2 * k;
            if (t > max10)
              break;
            if (t >= min10)
              ticks2.push(t);
          }
        }
      } else {
        for (; i <= j; i += 1) {
          const p2 = pow3(i);
          for (let k = 1; k < base; k += 1) {
            const t = p2 * k;
            if (t > max10)
              break;
            if (t >= min10)
              ticks2.push(t);
          }
        }
      }
      if (ticks2.length * 2 < n2)
        ticks2 = d3Ticks(min10, max10, n2);
    } else {
      const count4 = n2 === -1 ? j - i : Math.min(j - i, n2);
      ticks2 = d3Ticks(i, j, count4).map(pow3);
    }
    return r ? ticks2.reverse() : ticks2;
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/log.js
  var Log = class _Log extends Continuous {
    getDefaultOptions() {
      return {
        domain: [1, 10],
        range: [0, 1],
        base: 10,
        interpolate: createInterpolateValue,
        tickMethod: d3Log,
        tickCount: 5
      };
    }
    chooseNice() {
      return d3LogNice;
    }
    getTickMethodOptions() {
      const { domain, tickCount, base } = this.options;
      const min10 = domain[0];
      const max10 = domain[domain.length - 1];
      return [min10, max10, tickCount, base];
    }
    chooseTransforms() {
      const { base, domain } = this.options;
      const shouldReflect = domain[0] < 0;
      return [logs(base, shouldReflect), pows(base, shouldReflect)];
    }
    clone() {
      return new _Log(this.options);
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/quantize.js
  var Quantize = class _Quantize extends Threshold {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0.5],
        nice: false,
        tickCount: 5,
        tickMethod: wilkinsonExtended
      };
    }
    constructor(options) {
      super(options);
    }
    nice() {
      const { nice: nice2 } = this.options;
      if (nice2) {
        const [min10, max10, tickCount] = this.getTickMethodOptions();
        this.options.domain = d3LinearNice(min10, max10, tickCount);
      }
    }
    getTicks() {
      const { tickMethod } = this.options;
      const [min10, max10, tickCount] = this.getTickMethodOptions();
      return tickMethod(min10, max10, tickCount);
    }
    getTickMethodOptions() {
      const { domain, tickCount } = this.options;
      const min10 = domain[0];
      const max10 = domain[domain.length - 1];
      return [min10, max10, tickCount];
    }
    rescale() {
      this.nice();
      const { range: range3, domain } = this.options;
      const [x05, x12] = domain;
      this.n = range3.length - 1;
      this.thresholds = new Array(this.n);
      for (let i = 0; i < this.n; i += 1) {
        this.thresholds[i] = ((i + 1) * x12 - (i - this.n) * x05) / (this.n + 1);
      }
    }
    /**
     * 如果是在第一段后或者最后一段就把两端的值添加上
     */
    invert(y3) {
      const [a3, b] = super.invert(y3);
      const [x05, x12] = this.options.domain;
      return a3 === void 0 && b === void 0 ? [a3, b] : [a3 || x05, b || x12];
    }
    getThresholds() {
      return this.thresholds;
    }
    clone() {
      return new _Quantize(this.options);
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/utils/create-quartile.js
  function quantileSorted2(arr, percentage) {
    const len5 = arr.length;
    if (!len5) {
      return void 0;
    }
    if (len5 < 2) {
      return arr[len5 - 1];
    }
    const i = (len5 - 1) * percentage;
    const i0 = Math.floor(i);
    const v0 = arr[i0];
    const v1 = arr[i0 + 1];
    return v0 + (v1 - v0) * (i - i0);
  }
  function createQuartile(arr, n2, isSorted = false) {
    const numberArr = arr;
    if (!isSorted) {
      numberArr.sort((a3, b) => a3 - b);
    }
    const tmp2 = [];
    for (let i = 1; i < n2; i += 1) {
      tmp2.push(quantileSorted2(numberArr, i / n2));
    }
    return tmp2;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/quantile.js
  var Quantile = class _Quantile extends Threshold {
    getDefaultOptions() {
      return {
        domain: [],
        range: [],
        tickCount: 5,
        unknown: void 0,
        tickMethod: wilkinsonExtended
      };
    }
    constructor(options) {
      super(options);
    }
    rescale() {
      const { domain, range: range3 } = this.options;
      this.n = range3.length - 1;
      this.thresholds = createQuartile(domain, this.n + 1, false);
    }
    /**
     * 如果是在第一段后或者最后一段就把两端的值添加上
     */
    invert(y3) {
      const [a3, b] = super.invert(y3);
      const { domain } = this.options;
      const dMin = domain[0];
      const dMax = domain[domain.length - 1];
      return a3 === void 0 && b === void 0 ? [a3, b] : [a3 || dMin, b || dMax];
    }
    getThresholds() {
      return this.thresholds;
    }
    clone() {
      return new _Quantile(this.options);
    }
    getTicks() {
      const { tickCount, domain, tickMethod } = this.options;
      const lastIndex = domain.length - 1;
      const min10 = domain[0];
      const max10 = domain[lastIndex];
      return tickMethod(min10, max10, tickCount);
    }
  };

  // ../../engine/rails_design/node_modules/fecha/lib/fecha.js
  var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigitsOptional = "\\d\\d?";
  var twoDigits = "\\d\\d";
  var threeDigits = "\\d{3}";
  var fourDigits = "\\d{4}";
  var word = "[^\\s]+";
  var literal = /\[([^]*?)\]/gm;
  function shorten(arr, sLen) {
    var newArr = [];
    for (var i = 0, len5 = arr.length; i < len5; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }
    return newArr;
  }
  var monthUpdate = function(arrName) {
    return function(v, i18n) {
      var lowerCaseArr = i18n[arrName].map(function(v2) {
        return v2.toLowerCase();
      });
      var index4 = lowerCaseArr.indexOf(v.toLowerCase());
      if (index4 > -1) {
        return index4;
      }
      return null;
    };
  };
  function assign(origObj) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
      var obj = args_1[_a];
      for (var key in obj) {
        origObj[key] = obj[key];
      }
    }
    return origObj;
  }
  var dayNames = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ];
  var monthNames = [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  var defaultI18n = {
    dayNamesShort,
    dayNames,
    monthNamesShort,
    monthNames,
    amPm: ["am", "pm"],
    DoFn: function(dayOfMonth) {
      return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
    }
  };
  var globalI18n = assign({}, defaultI18n);
  var pad = function(val, len5) {
    if (len5 === void 0) {
      len5 = 2;
    }
    val = String(val);
    while (val.length < len5) {
      val = "0" + val;
    }
    return val;
  };
  var formatFlags = {
    D: function(dateObj) {
      return String(dateObj.getDate());
    },
    DD: function(dateObj) {
      return pad(dateObj.getDate());
    },
    Do: function(dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function(dateObj) {
      return String(dateObj.getDay());
    },
    dd: function(dateObj) {
      return pad(dateObj.getDay());
    },
    ddd: function(dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function(dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function(dateObj) {
      return String(dateObj.getMonth() + 1);
    },
    MM: function(dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function(dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function(dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    YY: function(dateObj) {
      return pad(String(dateObj.getFullYear()), 4).substr(2);
    },
    YYYY: function(dateObj) {
      return pad(dateObj.getFullYear(), 4);
    },
    h: function(dateObj) {
      return String(dateObj.getHours() % 12 || 12);
    },
    hh: function(dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function(dateObj) {
      return String(dateObj.getHours());
    },
    HH: function(dateObj) {
      return pad(dateObj.getHours());
    },
    m: function(dateObj) {
      return String(dateObj.getMinutes());
    },
    mm: function(dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function(dateObj) {
      return String(dateObj.getSeconds());
    },
    ss: function(dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function(dateObj) {
      return String(Math.round(dateObj.getMilliseconds() / 100));
    },
    SS: function(dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function(dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function(dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function(dateObj) {
      var offset3 = dateObj.getTimezoneOffset();
      return (offset3 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset3) / 60) * 100 + Math.abs(offset3) % 60, 4);
    },
    Z: function(dateObj) {
      var offset3 = dateObj.getTimezoneOffset();
      return (offset3 > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset3) / 60), 2) + ":" + pad(Math.abs(offset3) % 60, 2);
    }
  };
  var monthParse = function(v) {
    return +v - 1;
  };
  var emptyDigits = [null, twoDigitsOptional];
  var emptyWord = [null, word];
  var amPm = [
    "isPm",
    word,
    function(v, i18n) {
      var val = v.toLowerCase();
      if (val === i18n.amPm[0]) {
        return 0;
      } else if (val === i18n.amPm[1]) {
        return 1;
      }
      return null;
    }
  ];
  var timezoneOffset = [
    "timezoneOffset",
    "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
    function(v) {
      var parts = (v + "").match(/([+-]|\d\d)/gi);
      if (parts) {
        var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
        return parts[0] === "+" ? minutes : -minutes;
      }
      return 0;
    }
  ];
  var parseFlags = {
    D: ["day", twoDigitsOptional],
    DD: ["day", twoDigits],
    Do: ["day", twoDigitsOptional + word, function(v) {
      return parseInt(v, 10);
    }],
    M: ["month", twoDigitsOptional, monthParse],
    MM: ["month", twoDigits, monthParse],
    YY: [
      "year",
      twoDigits,
      function(v) {
        var now4 = /* @__PURE__ */ new Date();
        var cent = +("" + now4.getFullYear()).substr(0, 2);
        return +("" + (+v > 68 ? cent - 1 : cent) + v);
      }
    ],
    h: ["hour", twoDigitsOptional, void 0, "isPm"],
    hh: ["hour", twoDigits, void 0, "isPm"],
    H: ["hour", twoDigitsOptional],
    HH: ["hour", twoDigits],
    m: ["minute", twoDigitsOptional],
    mm: ["minute", twoDigits],
    s: ["second", twoDigitsOptional],
    ss: ["second", twoDigits],
    YYYY: ["year", fourDigits],
    S: ["millisecond", "\\d", function(v) {
      return +v * 100;
    }],
    SS: ["millisecond", twoDigits, function(v) {
      return +v * 10;
    }],
    SSS: ["millisecond", threeDigits],
    d: emptyDigits,
    dd: emptyDigits,
    ddd: emptyWord,
    dddd: emptyWord,
    MMM: ["month", word, monthUpdate("monthNamesShort")],
    MMMM: ["month", word, monthUpdate("monthNames")],
    a: amPm,
    A: amPm,
    ZZ: timezoneOffset,
    Z: timezoneOffset
  };
  var globalMasks = {
    default: "ddd MMM DD YYYY HH:mm:ss",
    shortDate: "M/D/YY",
    mediumDate: "MMM D, YYYY",
    longDate: "MMMM D, YYYY",
    fullDate: "dddd, MMMM D, YYYY",
    isoDate: "YYYY-MM-DD",
    isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
    shortTime: "HH:mm",
    mediumTime: "HH:mm:ss",
    longTime: "HH:mm:ss.SSS"
  };
  var format = function(dateObj, mask, i18n) {
    if (mask === void 0) {
      mask = globalMasks["default"];
    }
    if (i18n === void 0) {
      i18n = {};
    }
    if (typeof dateObj === "number") {
      dateObj = new Date(dateObj);
    }
    if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
      throw new Error("Invalid Date pass to format");
    }
    mask = globalMasks[mask] || mask;
    var literals = [];
    mask = mask.replace(literal, function($0, $1) {
      literals.push($1);
      return "@@@";
    });
    var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
    mask = mask.replace(token, function($0) {
      return formatFlags[$0](dateObj, combinedI18nSettings);
    });
    return mask.replace(/@@@/g, function() {
      return literals.shift();
    });
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/tick-methods/d3-time.js
  var d3Time = (min10, max10, count4, interval2, utc) => {
    const r = min10 > max10;
    const lo = r ? max10 : min10;
    const hi = r ? min10 : max10;
    const [tickInterval, step2] = findTickInterval(lo, hi, count4, interval2, utc);
    const ticks2 = tickInterval.range(lo, /* @__PURE__ */ new Date(+hi + 1), step2, true);
    return r ? ticks2.reverse() : ticks2;
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/time.js
  function offset2(date) {
    const minuteOffset = date.getTimezoneOffset();
    const d2 = new Date(date);
    d2.setMinutes(d2.getMinutes() + minuteOffset, d2.getSeconds(), d2.getMilliseconds());
    return d2;
  }
  var Time = class _Time extends Continuous {
    getDefaultOptions() {
      return {
        domain: [new Date(2e3, 0, 1), new Date(2e3, 0, 2)],
        range: [0, 1],
        nice: false,
        tickCount: 5,
        tickInterval: void 0,
        unknown: void 0,
        clamp: false,
        tickMethod: d3Time,
        interpolate: createInterpolateNumber,
        mask: void 0,
        utc: false
      };
    }
    chooseTransforms() {
      const transform = (x3) => +x3;
      const untransform = (x3) => new Date(x3);
      return [transform, untransform];
    }
    chooseNice() {
      return d3TimeNice;
    }
    getTickMethodOptions() {
      const { domain, tickCount, tickInterval, utc } = this.options;
      const min10 = domain[0];
      const max10 = domain[domain.length - 1];
      return [min10, max10, tickCount, tickInterval, utc];
    }
    getFormatter() {
      const { mask, utc } = this.options;
      const maskMap = utc ? utcIntervalMap : localIntervalMap;
      const time = utc ? offset2 : identity_default;
      return (d2) => format(time(d2), mask || chooseNiceTimeMask(d2, maskMap));
    }
    clone() {
      return new _Time(this.options);
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/@antv/scale/esm/scales/sequential.js
  var __decorate = function(decorators, target, key, desc) {
    var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r = (c5 < 3 ? d2(r) : c5 > 3 ? d2(target, key, r) : d2(target, key)) || r;
    return c5 > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var Sequential_1;
  function rangeOf(interpolator) {
    return [interpolator(0), interpolator(1)];
  }
  var normalizeDomain = (domain) => {
    const [d0, d1] = domain;
    const normalize10 = compose2(createInterpolateNumber(0, 1), createNormalize(d0, d1));
    return normalize10;
  };
  var Sequential = Sequential_1 = class Sequential2 extends Linear {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        unknown: void 0,
        nice: false,
        clamp: false,
        round: false,
        interpolator: identity_default,
        tickMethod: d3Ticks,
        tickCount: 5
      };
    }
    constructor(options) {
      super(options);
    }
    clone() {
      return new Sequential_1(this.options);
    }
  };
  Sequential = Sequential_1 = __decorate([
    interpolatize(rangeOf, normalizeDomain)
  ], Sequential);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/jitter.js
  function rangeOf2(value2, scaleOptions, padding) {
    if (value2 === null)
      return [-0.5, 0.5];
    const domain = domainOf(value2, scaleOptions);
    const scale9 = new Band({ domain, range: [0, 1], padding });
    const step2 = scale9.getBandWidth();
    return [-step2 / 2, step2 / 2];
  }
  function interpolate2(t, a3, b) {
    return a3 * (1 - t) + b * t;
  }
  var Jitter = (options = {}) => {
    const { padding = 0, paddingX = padding, paddingY = padding, random: random5 = Math.random } = options;
    return (I, mark) => {
      const { encode, scale: scale9 } = mark;
      const { x: scaleX, y: scaleY } = scale9;
      const [X] = columnOf(encode, "x");
      const [Y] = columnOf(encode, "y");
      const rangeX = rangeOf2(X, scaleX, paddingX);
      const rangeY = rangeOf2(Y, scaleY, paddingY);
      const DY = I.map(() => interpolate2(random5(), ...rangeY));
      const DX = I.map(() => interpolate2(random5(), ...rangeX));
      return [
        I,
        deep_mix_default({
          scale: {
            x: { padding: 0.5 },
            y: { padding: 0.5 }
          }
        }, mark, {
          encode: { dy: column(DY), dx: column(DX) }
        })
      ];
    };
  };
  Jitter.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/jitterX.js
  var JitterX = (options = {}) => {
    const { padding = 0, random: random5 = Math.random } = options;
    return (I, mark) => {
      const { encode, scale: scale9 } = mark;
      const { x: scaleX } = scale9;
      const [X] = columnOf(encode, "x");
      const rangeX = rangeOf2(X, scaleX, padding);
      const DX = I.map(() => interpolate2(random5(), ...rangeX));
      return [
        I,
        deep_mix_default({ scale: { x: { padding: 0.5 } } }, mark, {
          encode: { dx: column(DX) }
        })
      ];
    };
  };
  JitterX.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/jitterY.js
  var JitterY = (options = {}) => {
    const { padding = 0, random: random5 = Math.random } = options;
    return (I, mark) => {
      const { encode, scale: scale9 } = mark;
      const { y: scaleY } = scale9;
      const [Y] = columnOf(encode, "y");
      const rangeY = rangeOf2(Y, scaleY, padding);
      const DY = I.map(() => interpolate2(random5(), ...rangeY));
      return [
        I,
        deep_mix_default({ scale: { y: { padding: 0.5 } } }, mark, {
          encode: { dy: column(DY) }
        })
      ];
    };
  };
  JitterY.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/symmetryY.js
  var __rest6 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var SymmetryY = (options = {}) => {
    const { groupBy: groupBy2 = "x" } = options;
    return (I, mark) => {
      const { encode } = mark;
      const { x: x3 } = encode, rest = __rest6(encode, ["x"]);
      const Yn = Object.entries(rest).filter(([k]) => k.startsWith("y")).map(([k]) => [k, columnOf(encode, k)[0]]);
      const newYn = Yn.map(([k]) => [k, new Array(I.length)]);
      const groups2 = createGroups(groupBy2, I, mark);
      const MY = new Array(groups2.length);
      for (let i = 0; i < groups2.length; i++) {
        const I2 = groups2[i];
        const Y = I2.flatMap((i2) => Yn.map(([, V]) => +V[i2]));
        const [minY, maxY2] = extent(Y);
        MY[i] = (minY + maxY2) / 2;
      }
      const maxMiddleY = Math.max(...MY);
      for (let m3 = 0; m3 < groups2.length; m3++) {
        const offset3 = maxMiddleY - MY[m3];
        const I2 = groups2[m3];
        for (const i of I2) {
          for (let j = 0; j < Yn.length; j++) {
            const [, V] = Yn[j];
            const [, newV] = newYn[j];
            newV[i] = +V[i] + offset3;
          }
        }
      }
      return [
        I,
        deep_mix_default({}, mark, {
          encode: Object.fromEntries(newYn.map(([k, v]) => [k, column(v, columnOf(encode, k)[1])]))
        })
      ];
    };
  };
  SymmetryY.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/diffY.js
  var DiffY = (options = {}) => {
    const { groupBy: groupBy2 = "x", series = true } = options;
    return (I, mark) => {
      const { encode } = mark;
      const [Y] = columnOf(encode, "y");
      const [_2, fy1] = columnOf(encode, "y1");
      const [S] = series ? maybeColumnOf(encode, "series", "color") : columnOf(encode, "color");
      const groups2 = createGroups(groupBy2, I, mark);
      const newY1 = new Array(I.length);
      for (const G of groups2) {
        const YG = G.map((i) => +Y[i]);
        for (let idx = 0; idx < G.length; idx++) {
          const i = G[idx];
          const max10 = Math.max(...YG.filter((_3, _i) => _i !== idx));
          newY1[i] = +Y[i] > max10 ? max10 : Y[i];
        }
      }
      return [
        I,
        deep_mix_default({}, mark, {
          encode: {
            y1: column(newY1, fy1)
          }
        })
      ];
    };
  };
  DiffY.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/select.js
  function first(I, V) {
    return [I[0]];
  }
  function last2(I, V) {
    const i = I.length - 1;
    return [I[i]];
  }
  function max5(I, V) {
    const i = maxIndex(I, (i2) => V[i2]);
    return [I[i]];
  }
  function min5(I, V) {
    const i = minIndex(I, (i2) => V[i2]);
    return [I[i]];
  }
  function normalizeSelector(selector) {
    if (typeof selector === "function")
      return selector;
    const registry = { first, last: last2, max: max5, min: min5 };
    return registry[selector] || first;
  }
  var Select = (options = {}) => {
    const { groupBy: groupBy2 = "series", channel, selector } = options;
    return (I, mark) => {
      const { encode } = mark;
      const groups2 = createGroups(groupBy2, I, mark);
      const [V] = columnOf(encode, channel);
      const selectFunction = normalizeSelector(selector);
      return [groups2.flatMap((GI) => selectFunction(GI, V)), mark];
    };
  };
  Select.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/selectX.js
  var __rest7 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var SelectX = (options = {}) => {
    const { selector } = options, rest = __rest7(options, ["selector"]);
    return Select(Object.assign({ channel: "x", selector }, rest));
  };
  SelectX.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/selectY.js
  var __rest8 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var SelectY = (options = {}) => {
    const { selector } = options, rest = __rest8(options, ["selector"]);
    return Select(Object.assign({ channel: "y", selector }, rest));
  };
  SelectY.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/groupN.js
  var __rest9 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function builtinFormatter(summary) {
    return (d2) => d2 === null ? summary : `${summary} of ${d2}`;
  }
  function normalizeReducer(reducer) {
    if (typeof reducer === "function")
      return [reducer, null];
    const registry = { mean: mean2, max: max6, count: count2, first: first2, last: last3, sum: sum2, min: min6, median: median2 };
    const reducerFunction = registry[reducer];
    if (!reducerFunction)
      throw new Error(`Unknown reducer: ${reducer}.`);
    return reducerFunction();
  }
  function mean2() {
    const reducer = (I, V) => mean(I, (i) => +V[i]);
    const formatter2 = builtinFormatter("mean");
    return [reducer, formatter2];
  }
  function median2() {
    const reducer = (I, V) => median(I, (i) => +V[i]);
    const formatter2 = builtinFormatter("median");
    return [reducer, formatter2];
  }
  function max6() {
    const reducer = (I, V) => max4(I, (i) => +V[i]);
    const formatter2 = builtinFormatter("max");
    return [reducer, formatter2];
  }
  function min6() {
    const reducer = (I, V) => min4(I, (i) => +V[i]);
    const formatter2 = builtinFormatter("min");
    return [reducer, formatter2];
  }
  function count2() {
    const reducer = (I, V) => I.length;
    const formatter2 = builtinFormatter("count");
    return [reducer, formatter2];
  }
  function sum2() {
    const reducer = (I, V) => sum(I, (i) => +V[i]);
    const formatter2 = builtinFormatter("sum");
    return [reducer, formatter2];
  }
  function first2() {
    const reducer = (I, V) => V[I[0]];
    const formatter2 = builtinFormatter("first");
    return [reducer, formatter2];
  }
  function last3() {
    const reducer = (I, V) => V[I[I.length - 1]];
    const formatter2 = builtinFormatter("last");
    return [reducer, formatter2];
  }
  var GroupN = (options = {}) => {
    const { groupBy: groupBy2 } = options, rest = __rest9(options, ["groupBy"]);
    return (I, mark) => {
      const { data: data2, encode } = mark;
      const groups2 = groupBy2(I, mark);
      if (!groups2)
        return [I, mark];
      const maybeFrom = (field3, reducer) => {
        if (field3)
          return field3;
        const { from } = reducer;
        if (!from)
          return field3;
        const [, field1] = columnOf(encode, from);
        return field1;
      };
      const outputs = Object.entries(rest).map(([channel, reducer]) => {
        const [reducerFunction, formatter2] = normalizeReducer(reducer);
        const [V, field3] = columnOf(encode, channel);
        const field1 = maybeFrom(field3, reducer);
        const RV = groups2.map((I2) => reducerFunction(I2, V !== null && V !== void 0 ? V : data2));
        return [
          channel,
          Object.assign(Object.assign({}, nonConstantColumn(RV, (formatter2 === null || formatter2 === void 0 ? void 0 : formatter2(field1)) || field1)), { aggregate: true })
        ];
      });
      const reducedColumns = Object.keys(encode).map((key) => {
        const [V, fv] = columnOf(encode, key);
        const GV = groups2.map((I2) => V[I2[0]]);
        return [key, column(GV, fv)];
      });
      const GD = groups2.map((I2) => data2[I2[0]]);
      const GI = indexOf3(groups2);
      return [
        GI,
        deep_mix_default({}, mark, {
          data: GD,
          encode: Object.fromEntries([...reducedColumns, ...outputs])
        })
      ];
    };
  };
  GroupN.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/group.js
  var __rest10 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var Group = (options = {}) => {
    const { channels = ["x", "y"] } = options, rest = __rest10(options, ["channels"]);
    const groupBy2 = (I, mark) => createGroups(channels, I, mark);
    return GroupN(Object.assign(Object.assign({}, rest), { groupBy: groupBy2 }));
  };
  Group.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/groupX.js
  var GroupX = (options = {}) => {
    return Group(Object.assign(Object.assign({}, options), { channels: ["x", "color", "series"] }));
  };
  GroupX.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/groupY.js
  var GroupY = (options = {}) => {
    return Group(Object.assign(Object.assign({}, options), { channels: ["y", "color", "series"] }));
  };
  GroupY.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/groupColor.js
  var GroupColor = (options = {}) => {
    return Group(Object.assign(Object.assign({}, options), { channels: ["color"] }));
  };
  GroupColor.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/sort.js
  var __rest11 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function createReducer(channel, options, encode) {
    const { by = channel, reducer = "max" } = options;
    const [V] = columnOf(encode, by);
    if (typeof reducer === "function")
      return (GI) => reducer(GI, V);
    if (reducer === "max")
      return (GI) => max4(GI, (i) => +V[i]);
    if (reducer === "min")
      return (GI) => min4(GI, (i) => +V[i]);
    if (reducer === "sum")
      return (GI) => sum(GI, (i) => +V[i]);
    if (reducer === "median")
      return (GI) => median(GI, (i) => +V[i]);
    if (reducer === "mean")
      return (GI) => mean(GI, (i) => +V[i]);
    if (reducer === "first")
      return (GI) => V[GI[0]];
    if (reducer === "last")
      return (GI) => V[GI[GI.length - 1]];
    throw new Error(`Unknown reducer: ${reducer}`);
  }
  function sortQuantitative(I, mark, options) {
    const { reverse, channel } = options;
    const { encode } = mark;
    const [V] = columnOf(encode, channel);
    const sortedI = sort2(I, (i) => V[i]);
    if (reverse)
      sortedI.reverse();
    return [sortedI, mark];
  }
  function filterIndex(I, values, specifiedDomain) {
    if (!Array.isArray(specifiedDomain))
      return I;
    const domain = new Set(specifiedDomain);
    return I.filter((i) => domain.has(values[i]));
  }
  function sortOrdinal(I, mark, options) {
    var _a;
    const { reverse, slice: slice3, channel } = options, rest = __rest11(options, ["reverse", "slice", "channel"]);
    const { encode, scale: scale9 = {} } = mark;
    const domain = (_a = scale9[channel]) === null || _a === void 0 ? void 0 : _a.domain;
    const [T] = columnOf(encode, channel);
    const normalizeReducer2 = createReducer(channel, rest, encode);
    const SI = filterIndex(I, T, domain);
    const sortedDomain = groupSort(SI, normalizeReducer2, (i) => T[i]);
    if (reverse)
      sortedDomain.reverse();
    const s2 = typeof slice3 === "number" ? [0, slice3] : slice3;
    const slicedDomain = slice3 ? sortedDomain.slice(...s2) : sortedDomain;
    return [
      I,
      deep_mix_default(mark, {
        scale: {
          [channel]: {
            domain: slicedDomain
          }
        }
      })
    ];
  }
  var Sort = (options = {}) => {
    const { reverse = false, slice: slice3, channel, ordinal = true } = options, rest = __rest11(options, ["reverse", "slice", "channel", "ordinal"]);
    return (I, mark) => {
      if (!ordinal) {
        return sortQuantitative(I, mark, Object.assign({
          reverse,
          slice: slice3,
          channel
        }, rest));
      }
      return sortOrdinal(I, mark, Object.assign({ reverse, slice: slice3, channel }, rest));
    };
  };
  Sort.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/sortX.js
  var SortX = (options = {}) => {
    return Sort(Object.assign(Object.assign({}, options), { channel: "x" }));
  };
  SortX.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/sortColor.js
  var SortColor = (options = {}) => {
    return Sort(Object.assign(Object.assign({}, options), { channel: "color" }));
  };
  SortColor.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/sortY.js
  var SortY = (options = {}) => {
    return Sort(Object.assign(Object.assign({}, options), { channel: "y" }));
  };
  SortY.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/flexX.js
  function valueOf(data2, field3) {
    if (typeof field3 === "string")
      return data2.map((d2) => d2[field3]);
    return data2.map(field3);
  }
  function createReducer2(reducer, V) {
    if (typeof reducer === "function")
      return (GI) => reducer(GI, V);
    if (reducer === "sum")
      return (GI) => sum(GI, (i) => +V[i]);
    throw new Error(`Unknown reducer: ${reducer}`);
  }
  var FlexX = (options = {}) => {
    const { field: field3, channel = "y", reducer = "sum" } = options;
    return (I, mark) => {
      const { data: data2, encode } = mark;
      const [x3] = columnOf(encode, "x");
      const V = field3 ? valueOf(data2, field3) : columnOf(encode, channel)[0];
      const reducerFunction = createReducer2(reducer, V);
      const flex2 = rollups(I, reducerFunction, (i) => x3[i]).map((d2) => d2[1]);
      return [I, deep_mix_default({}, mark, { scale: { x: { flex: flex2 } } })];
    };
  };
  FlexX.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/vector.js
  function sub6([x12, y12], [x22, y22]) {
    return [x12 - x22, y12 - y22];
  }
  function add8([x12, y12], [x22, y22]) {
    return [x12 + x22, y12 + y22];
  }
  function dist4([x05, y05], [x12, y12]) {
    return Math.sqrt(Math.pow(x05 - x12, 2) + Math.pow(y05 - y12, 2));
  }
  function angle3([x3, y3]) {
    return Math.atan2(y3, x3);
  }
  function angleWithQuadrant([x3, y3]) {
    return angle3([x3, y3]) + Math.PI / 2;
  }
  function angleBetween(v0, v1) {
    const a0 = angle3(v0);
    const a1 = angle3(v1);
    if (a0 < a1)
      return a1 - a0;
    return Math.PI * 2 - (a0 - a1);
  }
  function calcBBox(points) {
    let minX = Infinity;
    let maxX = -Infinity;
    let minY = Infinity;
    let maxY2 = -Infinity;
    for (const [x3, y3] of points) {
      minX = Math.min(x3, minX);
      maxX = Math.max(x3, maxX);
      minY = Math.min(y3, minY);
      maxY2 = Math.max(y3, maxY2);
    }
    const width = maxX - minX;
    const height = maxY2 - minY;
    return [minX, minY, width, height];
  }
  function mid([x12, y12], [x22, y22]) {
    return [(x12 + x22) / 2, (y12 + y22) / 2];
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/pack.js
  function pack(options) {
    const { padding = 0, direction: direction2 = "col" } = options;
    return (P, count4, layout) => {
      const pcount = P.length;
      if (pcount === 0)
        return [];
      const { innerWidth, innerHeight } = layout;
      const aspect = innerHeight / innerWidth;
      let col = Math.ceil(Math.sqrt(count4 / aspect));
      let size2 = innerWidth / col;
      let row2 = Math.ceil(count4 / col);
      let h0 = row2 * size2;
      while (h0 > innerHeight) {
        col = col + 1;
        size2 = innerWidth / col;
        row2 = Math.ceil(count4 / col);
        h0 = row2 * size2;
      }
      const space = innerHeight - row2 * size2;
      const intervalY = row2 <= 1 ? 0 : space / (row2 - 1);
      const [offsetX, offsetY] = row2 <= 1 ? [
        (innerWidth - pcount * size2) / (pcount - 1),
        (innerHeight - size2) / 2
      ] : [0, 0];
      return P.map((points, m3) => {
        const [x3, y3, width, height] = calcBBox(points);
        const i = direction2 === "col" ? m3 % col : Math.floor(m3 / row2);
        const j = direction2 === "col" ? Math.floor(m3 / col) : m3 % row2;
        const newX = i * size2;
        const newY = (row2 - j - 1) * size2 + space;
        const sx = (size2 - padding) / width;
        const sy = (size2 - padding) / height;
        const tx = newX - x3 + offsetX * i + 1 / 2 * padding;
        const ty = newY - y3 - intervalY * j - offsetY + 1 / 2 * padding;
        return `translate(${tx}, ${ty}) scale(${sx}, ${sy})`;
      });
    };
  }
  var Pack = (options) => {
    return (I, mark) => {
      return [I, deep_mix_default({}, mark, { modifier: pack(options), axis: false })];
    };
  };
  Pack.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/bin.js
  var __rest12 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var THRESHOLD = "thresholds";
  function thresholdAuto(values) {
    const [min10, max10] = extent(values);
    return Math.min(200, thresholdScott(values, min10, max10));
  }
  var Bin = (options = {}) => {
    const { groupChannels = ["color"], binChannels = ["x", "y"] } = options, rest = __rest12(options, ["groupChannels", "binChannels"]);
    const channelIndexKey = {};
    const groupBy2 = (I, mark) => {
      const { encode } = mark;
      const binValues = binChannels.map((channel) => {
        const [V] = columnOf(encode, channel);
        return V;
      });
      const thresholds = subObject(rest, THRESHOLD);
      const DI = I.filter((i) => binValues.every((V) => defined(V[i])));
      const groupKeys = [
        // For discrete channels, use value as group key.
        ...groupChannels.map((d2) => {
          const [V] = columnOf(encode, d2);
          return V;
        }).filter(defined).map((V) => (i) => V[i]),
        // For quantitative channels, use extent of bin as group key.
        ...binChannels.map((d2, i) => {
          const V = binValues[i];
          const t = thresholds[d2] || thresholdAuto(V);
          const bins = bin().thresholds(t).value((i2) => +V[i2])(DI);
          const indexKey = new Map(bins.flatMap((bin2) => {
            const { x0: x05, x1: x12 } = bin2;
            const key2 = `${x05},${x12}`;
            return bin2.map((i2) => [i2, key2]);
          }));
          channelIndexKey[d2] = indexKey;
          return (i2) => indexKey.get(i2);
        })
      ];
      const key = (i) => groupKeys.map((key2) => key2(i)).join("-");
      return Array.from(group(DI, key).values());
    };
    return GroupN(Object.assign(Object.assign(Object.assign({}, Object.fromEntries(Object.entries(rest).filter(([k]) => !k.startsWith(THRESHOLD)))), Object.fromEntries(binChannels.flatMap((channel) => {
      const start2 = ([i]) => +channelIndexKey[channel].get(i).split(",")[0];
      const end = ([i]) => +channelIndexKey[channel].get(i).split(",")[1];
      end.from = channel;
      return [
        [channel, start2],
        [`${channel}1`, end]
      ];
    }))), { groupBy: groupBy2 }));
  };
  Bin.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/binX.js
  var BinX = (options = {}) => {
    const { thresholds } = options;
    return Bin(Object.assign(Object.assign({}, options), { thresholdsX: thresholds, groupChannels: ["color"], binChannels: ["x"] }));
  };
  BinX.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/utils/lttb.js
  function lttb(I, X, Y, thresholds) {
    const length5 = I.length;
    if (thresholds >= length5 || thresholds === 0) {
      return I;
    }
    const x3 = (i) => X[I[i]] * 1;
    const y3 = (i) => Y[I[i]] * 1;
    const sampled = [];
    const every = (length5 - 2) / (thresholds - 2);
    let a3 = 0;
    let maxArea;
    let area2;
    let nextA;
    sampled.push(a3);
    for (let i = 0; i < thresholds - 2; i++) {
      let avgX = 0;
      let avgY = 0;
      let start2 = Math.floor((i + 1) * every) + 1;
      let end = Math.floor((i + 2) * every) + 1;
      end = Math.min(end, length5);
      const size2 = end - start2;
      for (; start2 < end; start2++) {
        avgX += x3(start2);
        avgY += y3(start2);
      }
      avgX /= size2;
      avgY /= size2;
      let frameStart = Math.floor((i + 0) * every) + 1;
      const frameEnd = Math.floor((i + 1) * every) + 1;
      const pointA = [x3(a3), y3(a3)];
      maxArea = area2 = -1;
      for (; frameStart < frameEnd; frameStart++) {
        area2 = Math.abs((pointA[0] - avgX) * (x3(frameStart) - pointA[1]) - (pointA[0] - y3(frameStart)) * (avgY - pointA[0])) * 0.5;
        if (area2 > maxArea) {
          maxArea = area2;
          nextA = frameStart;
        }
      }
      sampled.push(nextA);
      a3 = nextA;
    }
    sampled.push(length5 - 1);
    return sampled.map((a4) => I[a4]);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/sample.js
  function normalizeSample(strategy) {
    if (typeof strategy === "function")
      return strategy;
    if (strategy === "lttb")
      return lttb;
    const strategies = {
      first: (f) => [f[0]],
      last: (f) => [f[f.length - 1]],
      min: (f, X, Y) => [
        f[minIndex(f, (i) => Y[i])]
      ],
      max: (f, X, Y) => [
        f[maxIndex(f, (i) => Y[i])]
      ],
      median: (f, X, Y) => [
        f[medianIndex(f, (i) => Y[i])]
      ]
    };
    const sampleFunction = strategies[strategy] || strategies.median;
    return (I, X, Y, thresholds) => {
      const frameSize = Math.max(1, Math.floor(I.length / thresholds));
      const frames = getFrames(I, frameSize);
      return frames.flatMap((frame2) => sampleFunction(frame2, X, Y));
    };
  }
  function getFrames(I, frameSize) {
    const size2 = I.length;
    const frames = [];
    let i = 0;
    while (i < size2) {
      frames.push(I.slice(i, i += frameSize));
    }
    return frames;
  }
  var Sample = (options = {}) => {
    const { strategy = "median", thresholds = 2e3, groupBy: groupBy2 = ["series", "color"] } = options;
    const sampleFunction = normalizeSample(strategy);
    return (I, mark) => {
      const { encode } = mark;
      const groups2 = createGroups(groupBy2, I, mark);
      const [X] = columnOf(encode, "x");
      const [Y] = columnOf(encode, "y");
      return [
        groups2.flatMap((g) => sampleFunction(g, X, Y, thresholds)),
        mark
      ];
    };
  };
  Sample.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/transform/filter.js
  function normalizeValue(value2) {
    if (typeof value2 === "object")
      return [value2.value, value2.ordinal];
    else
      return [value2, true];
  }
  function filterWhenNoElements(mark) {
    var _a;
    const { encode } = mark;
    const noElementMark = Object.assign(Object.assign({}, mark), { encode: Object.assign(Object.assign({}, mark.encode), { y: Object.assign(Object.assign({}, mark.encode.y), { value: [] }) }) });
    const targetField = (_a = encode === null || encode === void 0 ? void 0 : encode.color) === null || _a === void 0 ? void 0 : _a.field;
    if (!encode || !targetField) {
      return noElementMark;
    }
    let filterObject;
    for (const [key, v] of Object.entries(encode)) {
      if ((key === "x" || key === "y") && v.field === targetField) {
        filterObject = Object.assign(Object.assign({}, filterObject), { [key]: Object.assign(Object.assign({}, v), { value: [] }) });
      }
    }
    if (!filterObject) {
      return noElementMark;
    }
    return Object.assign(Object.assign({}, mark), { encode: Object.assign(Object.assign({}, mark.encode), filterObject) });
  }
  var Filter = (options = {}) => {
    return (I, mark) => {
      const { encode, data: data2 } = mark;
      const filters = Object.entries(options).map(([key, v]) => {
        const [V] = columnOf(encode, key);
        if (!V)
          return null;
        const [value2, ordinal = true] = normalizeValue(v);
        if (typeof value2 === "function")
          return (i) => value2(V[i]);
        if (ordinal) {
          const expectedValues = Array.isArray(value2) ? value2 : [value2];
          if (expectedValues.length === 0)
            return null;
          return (i) => expectedValues.includes(V[i]);
        } else {
          const [start2, end] = value2;
          return (i) => V[i] >= start2 && V[i] <= end;
        }
      }).filter(defined);
      const totalFilter = (i) => filters.every((f) => f(i));
      const FI = I.filter(totalFilter);
      const newIndex2 = FI.map((_2, i) => i);
      if (filters.length === 0) {
        const targetMark = filterWhenNoElements(mark);
        return [I, targetMark];
      }
      const newEncodes = Object.entries(encode).map(([key, encode2]) => {
        return [
          key,
          Object.assign(Object.assign({}, encode2), { value: newIndex2.map((i) => encode2.value[FI[i]]).filter((v) => v !== void 0) })
        ];
      });
      return [
        newIndex2,
        deep_mix_default({}, mark, {
          encode: Object.fromEntries(newEncodes),
          // Filter data for tooltip item.
          data: FI.map((i) => data2[i])
        })
      ];
    };
  };
  Filter.props = {};

  // ../../engine/rails_design/node_modules/d3-shape/src/constant.js
  function constant_default(x3) {
    return function constant4() {
      return x3;
    };
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/math.js
  var abs = Math.abs;
  var atan2 = Math.atan2;
  var cos = Math.cos;
  var max7 = Math.max;
  var min7 = Math.min;
  var sin = Math.sin;
  var sqrt = Math.sqrt;
  var epsilon = 1e-12;
  var pi = Math.PI;
  var halfPi = pi / 2;
  var tau = 2 * pi;
  function acos(x3) {
    return x3 > 1 ? 0 : x3 < -1 ? pi : Math.acos(x3);
  }
  function asin(x3) {
    return x3 >= 1 ? halfPi : x3 <= -1 ? -halfPi : Math.asin(x3);
  }

  // ../../engine/rails_design/node_modules/d3-path/src/path.js
  var pi2 = Math.PI;
  var tau2 = 2 * pi2;
  var epsilon2 = 1e-6;
  var tauEpsilon = tau2 - epsilon2;
  function append(strings) {
    this._ += strings[0];
    for (let i = 1, n2 = strings.length; i < n2; ++i) {
      this._ += arguments[i] + strings[i];
    }
  }
  function appendRound(digits) {
    let d2 = Math.floor(digits);
    if (!(d2 >= 0)) throw new Error(`invalid digits: ${digits}`);
    if (d2 > 15) return append;
    const k = 10 ** d2;
    return function(strings) {
      this._ += strings[0];
      for (let i = 1, n2 = strings.length; i < n2; ++i) {
        this._ += Math.round(arguments[i] * k) / k + strings[i];
      }
    };
  }
  var Path = class {
    constructor(digits) {
      this._x0 = this._y0 = // start of current subpath
      this._x1 = this._y1 = null;
      this._ = "";
      this._append = digits == null ? append : appendRound(digits);
    }
    moveTo(x3, y3) {
      this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}`;
    }
    closePath() {
      if (this._x1 !== null) {
        this._x1 = this._x0, this._y1 = this._y0;
        this._append`Z`;
      }
    }
    lineTo(x3, y3) {
      this._append`L${this._x1 = +x3},${this._y1 = +y3}`;
    }
    quadraticCurveTo(x12, y12, x3, y3) {
      this._append`Q${+x12},${+y12},${this._x1 = +x3},${this._y1 = +y3}`;
    }
    bezierCurveTo(x12, y12, x22, y22, x3, y3) {
      this._append`C${+x12},${+y12},${+x22},${+y22},${this._x1 = +x3},${this._y1 = +y3}`;
    }
    arcTo(x12, y12, x22, y22, r) {
      x12 = +x12, y12 = +y12, x22 = +x22, y22 = +y22, r = +r;
      if (r < 0) throw new Error(`negative radius: ${r}`);
      let x05 = this._x1, y05 = this._y1, x21 = x22 - x12, y21 = y22 - y12, x01 = x05 - x12, y01 = y05 - y12, l01_2 = x01 * x01 + y01 * y01;
      if (this._x1 === null) {
        this._append`M${this._x1 = x12},${this._y1 = y12}`;
      } else if (!(l01_2 > epsilon2)) ;
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon2) || !r) {
        this._append`L${this._x1 = x12},${this._y1 = y12}`;
      } else {
        let x20 = x22 - x05, y20 = y22 - y05, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r * Math.tan((pi2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
        if (Math.abs(t01 - 1) > epsilon2) {
          this._append`L${x12 + t01 * x01},${y12 + t01 * y01}`;
        }
        this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x12 + t21 * x21},${this._y1 = y12 + t21 * y21}`;
      }
    }
    arc(x3, y3, r, a0, a1, ccw) {
      x3 = +x3, y3 = +y3, r = +r, ccw = !!ccw;
      if (r < 0) throw new Error(`negative radius: ${r}`);
      let dx = r * Math.cos(a0), dy = r * Math.sin(a0), x05 = x3 + dx, y05 = y3 + dy, cw2 = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
      if (this._x1 === null) {
        this._append`M${x05},${y05}`;
      } else if (Math.abs(this._x1 - x05) > epsilon2 || Math.abs(this._y1 - y05) > epsilon2) {
        this._append`L${x05},${y05}`;
      }
      if (!r) return;
      if (da < 0) da = da % tau2 + tau2;
      if (da > tauEpsilon) {
        this._append`A${r},${r},0,1,${cw2},${x3 - dx},${y3 - dy}A${r},${r},0,1,${cw2},${this._x1 = x05},${this._y1 = y05}`;
      } else if (da > epsilon2) {
        this._append`A${r},${r},0,${+(da >= pi2)},${cw2},${this._x1 = x3 + r * Math.cos(a1)},${this._y1 = y3 + r * Math.sin(a1)}`;
      }
    }
    rect(x3, y3, w, h) {
      this._append`M${this._x0 = this._x1 = +x3},${this._y0 = this._y1 = +y3}h${w = +w}v${+h}h${-w}Z`;
    }
    toString() {
      return this._;
    }
  };
  function path() {
    return new Path();
  }
  path.prototype = Path.prototype;

  // ../../engine/rails_design/node_modules/d3-shape/src/path.js
  function withPath(shape23) {
    let digits = 3;
    shape23.digits = function(_2) {
      if (!arguments.length) return digits;
      if (_2 == null) {
        digits = null;
      } else {
        const d2 = Math.floor(_2);
        if (!(d2 >= 0)) throw new RangeError(`invalid digits: ${_2}`);
        digits = d2;
      }
      return shape23;
    };
    return () => new Path(digits);
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/arc.js
  function arcInnerRadius(d2) {
    return d2.innerRadius;
  }
  function arcOuterRadius(d2) {
    return d2.outerRadius;
  }
  function arcStartAngle(d2) {
    return d2.startAngle;
  }
  function arcEndAngle(d2) {
    return d2.endAngle;
  }
  function arcPadAngle(d2) {
    return d2 && d2.padAngle;
  }
  function intersect(x05, y05, x12, y12, x22, y22, x3, y3) {
    var x10 = x12 - x05, y10 = y12 - y05, x32 = x3 - x22, y32 = y3 - y22, t = y32 * x10 - x32 * y10;
    if (t * t < epsilon) return;
    t = (x32 * (y05 - y22) - y32 * (x05 - x22)) / t;
    return [x05 + t * x10, y05 + t * y10];
  }
  function cornerTangents(x05, y05, x12, y12, r1, rc, cw2) {
    var x01 = x05 - x12, y01 = y05 - y12, lo = (cw2 ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x05 + ox, y11 = y05 + oy, x10 = x12 + ox, y10 = y12 + oy, x004 = (x11 + x10) / 2, y004 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d3 = (dy < 0 ? -1 : 1) * sqrt(max7(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d3) / d2, cy0 = (-D2 * dx - dy * d3) / d2, cx1 = (D2 * dy + dx * d3) / d2, cy1 = (-D2 * dx + dy * d3) / d2, dx0 = cx0 - x004, dy0 = cy0 - y004, dx1 = cx1 - x004, dy1 = cy1 - y004;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return {
      cx: cx0,
      cy: cy0,
      x01: -ox,
      y01: -oy,
      x11: cx0 * (r1 / r - 1),
      y11: cy0 * (r1 / r - 1)
    };
  }
  function arc_default() {
    var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant_default(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null, path2 = withPath(arc);
    function arc() {
      var buffer, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw2 = a1 > a0;
      if (!context) context = buffer = path2();
      if (r1 < r0) r = r1, r1 = r0, r0 = r;
      if (!(r1 > epsilon)) context.moveTo(0, 0);
      else if (da > tau - epsilon) {
        context.moveTo(r1 * cos(a0), r1 * sin(a0));
        context.arc(0, 0, r1, a0, a1, !cw2);
        if (r0 > epsilon) {
          context.moveTo(r0 * cos(a1), r0 * sin(a1));
          context.arc(0, 0, r0, a1, a0, cw2);
        }
      } else {
        var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min7(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t0, t1;
        if (rp > epsilon) {
          var p0 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
          if ((da0 -= p0 * 2) > epsilon) p0 *= cw2 ? 1 : -1, a00 += p0, a10 -= p0;
          else da0 = 0, a00 = a10 = (a0 + a1) / 2;
          if ((da1 -= p1 * 2) > epsilon) p1 *= cw2 ? 1 : -1, a01 += p1, a11 -= p1;
          else da1 = 0, a01 = a11 = (a0 + a1) / 2;
        }
        var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
        if (rc > epsilon) {
          var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x004 = r0 * cos(a00), y004 = r0 * sin(a00), oc;
          if (da < pi) {
            if (oc = intersect(x01, y01, x004, y004, x11, y11, x10, y10)) {
              var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = min7(rc, (r0 - lc) / (kc - 1));
              rc1 = min7(rc, (r1 - lc) / (kc + 1));
            } else {
              rc0 = rc1 = 0;
            }
          }
        }
        if (!(da1 > epsilon)) context.moveTo(x01, y01);
        else if (rc1 > epsilon) {
          t0 = cornerTangents(x004, y004, x01, y01, r1, rc1, cw2);
          t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw2);
          context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01);
          if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw2);
          else {
            context.arc(t0.cx, t0.cy, rc1, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw2);
            context.arc(0, 0, r1, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !cw2);
            context.arc(t1.cx, t1.cy, rc1, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw2);
          }
        } else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw2);
        if (!(r0 > epsilon) || !(da0 > epsilon)) context.lineTo(x10, y10);
        else if (rc0 > epsilon) {
          t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw2);
          t1 = cornerTangents(x01, y01, x004, y004, r0, -rc0, cw2);
          context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01);
          if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !cw2);
          else {
            context.arc(t0.cx, t0.cy, rc0, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !cw2);
            context.arc(0, 0, r0, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), cw2);
            context.arc(t1.cx, t1.cy, rc0, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !cw2);
          }
        } else context.arc(0, 0, r0, a10, a00, cw2);
      }
      context.closePath();
      if (buffer) return context = null, buffer + "" || null;
    }
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a3 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
      return [cos(a3) * r, sin(a3) * r];
    };
    arc.innerRadius = function(_2) {
      return arguments.length ? (innerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : innerRadius;
    };
    arc.outerRadius = function(_2) {
      return arguments.length ? (outerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : outerRadius;
    };
    arc.cornerRadius = function(_2) {
      return arguments.length ? (cornerRadius = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : cornerRadius;
    };
    arc.padRadius = function(_2) {
      return arguments.length ? (padRadius = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), arc) : padRadius;
    };
    arc.startAngle = function(_2) {
      return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : startAngle;
    };
    arc.endAngle = function(_2) {
      return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : endAngle;
    };
    arc.padAngle = function(_2) {
      return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant_default(+_2), arc) : padAngle;
    };
    arc.context = function(_2) {
      return arguments.length ? (context = _2 == null ? null : _2, arc) : context;
    };
    return arc;
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/array.js
  var slice2 = Array.prototype.slice;
  function array_default(x3) {
    return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/curve/linear.js
  function Linear2(context) {
    this._context = context;
  }
  Linear2.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
        default:
          this._context.lineTo(x3, y3);
          break;
      }
    }
  };
  function linear_default(context) {
    return new Linear2(context);
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/point.js
  function x(p2) {
    return p2[0];
  }
  function y(p2) {
    return p2[1];
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/line.js
  function line_default(x3, y3) {
    var defined4 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(line4);
    x3 = typeof x3 === "function" ? x3 : x3 === void 0 ? x : constant_default(x3);
    y3 = typeof y3 === "function" ? y3 : y3 === void 0 ? y : constant_default(y3);
    function line4(data2) {
      var i, n2 = (data2 = array_default(data2)).length, d2, defined0 = false, buffer;
      if (context == null) output = curve(buffer = path2());
      for (i = 0; i <= n2; ++i) {
        if (!(i < n2 && defined4(d2 = data2[i], i, data2)) === defined0) {
          if (defined0 = !defined0) output.lineStart();
          else output.lineEnd();
        }
        if (defined0) output.point(+x3(d2, i, data2), +y3(d2, i, data2));
      }
      if (buffer) return output = null, buffer + "" || null;
    }
    line4.x = function(_2) {
      return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default(+_2), line4) : x3;
    };
    line4.y = function(_2) {
      return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default(+_2), line4) : y3;
    };
    line4.defined = function(_2) {
      return arguments.length ? (defined4 = typeof _2 === "function" ? _2 : constant_default(!!_2), line4) : defined4;
    };
    line4.curve = function(_2) {
      return arguments.length ? (curve = _2, context != null && (output = curve(context)), line4) : curve;
    };
    line4.context = function(_2) {
      return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line4) : context;
    };
    return line4;
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/area.js
  function area_default(x05, y05, y12) {
    var x12 = null, defined4 = constant_default(true), context = null, curve = linear_default, output = null, path2 = withPath(area2);
    x05 = typeof x05 === "function" ? x05 : x05 === void 0 ? x : constant_default(+x05);
    y05 = typeof y05 === "function" ? y05 : y05 === void 0 ? constant_default(0) : constant_default(+y05);
    y12 = typeof y12 === "function" ? y12 : y12 === void 0 ? y : constant_default(+y12);
    function area2(data2) {
      var i, j, k, n2 = (data2 = array_default(data2)).length, d2, defined0 = false, buffer, x0z = new Array(n2), y0z = new Array(n2);
      if (context == null) output = curve(buffer = path2());
      for (i = 0; i <= n2; ++i) {
        if (!(i < n2 && defined4(d2 = data2[i], i, data2)) === defined0) {
          if (defined0 = !defined0) {
            j = i;
            output.areaStart();
            output.lineStart();
          } else {
            output.lineEnd();
            output.lineStart();
            for (k = i - 1; k >= j; --k) {
              output.point(x0z[k], y0z[k]);
            }
            output.lineEnd();
            output.areaEnd();
          }
        }
        if (defined0) {
          x0z[i] = +x05(d2, i, data2), y0z[i] = +y05(d2, i, data2);
          output.point(x12 ? +x12(d2, i, data2) : x0z[i], y12 ? +y12(d2, i, data2) : y0z[i]);
        }
      }
      if (buffer) return output = null, buffer + "" || null;
    }
    function arealine() {
      return line_default().defined(defined4).curve(curve).context(context);
    }
    area2.x = function(_2) {
      return arguments.length ? (x05 = typeof _2 === "function" ? _2 : constant_default(+_2), x12 = null, area2) : x05;
    };
    area2.x0 = function(_2) {
      return arguments.length ? (x05 = typeof _2 === "function" ? _2 : constant_default(+_2), area2) : x05;
    };
    area2.x1 = function(_2) {
      return arguments.length ? (x12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), area2) : x12;
    };
    area2.y = function(_2) {
      return arguments.length ? (y05 = typeof _2 === "function" ? _2 : constant_default(+_2), y12 = null, area2) : y05;
    };
    area2.y0 = function(_2) {
      return arguments.length ? (y05 = typeof _2 === "function" ? _2 : constant_default(+_2), area2) : y05;
    };
    area2.y1 = function(_2) {
      return arguments.length ? (y12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant_default(+_2), area2) : y12;
    };
    area2.lineX0 = area2.lineY0 = function() {
      return arealine().x(x05).y(y05);
    };
    area2.lineY1 = function() {
      return arealine().x(x05).y(y12);
    };
    area2.lineX1 = function() {
      return arealine().x(x12).y(y05);
    };
    area2.defined = function(_2) {
      return arguments.length ? (defined4 = typeof _2 === "function" ? _2 : constant_default(!!_2), area2) : defined4;
    };
    area2.curve = function(_2) {
      return arguments.length ? (curve = _2, context != null && (output = curve(context)), area2) : curve;
    };
    area2.context = function(_2) {
      return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), area2) : context;
    };
    return area2;
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/curve/radial.js
  var curveRadialLinear = curveRadial(linear_default);
  function Radial2(curve) {
    this._curve = curve;
  }
  Radial2.prototype = {
    areaStart: function() {
      this._curve.areaStart();
    },
    areaEnd: function() {
      this._curve.areaEnd();
    },
    lineStart: function() {
      this._curve.lineStart();
    },
    lineEnd: function() {
      this._curve.lineEnd();
    },
    point: function(a3, r) {
      this._curve.point(r * Math.sin(a3), r * -Math.cos(a3));
    }
  };
  function curveRadial(curve) {
    function radial(context) {
      return new Radial2(curve(context));
    }
    radial._curve = curve;
    return radial;
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/lineRadial.js
  function lineRadial(l2) {
    var c5 = l2.curve;
    l2.angle = l2.x, delete l2.x;
    l2.radius = l2.y, delete l2.y;
    l2.curve = function(_2) {
      return arguments.length ? c5(curveRadial(_2)) : c5()._curve;
    };
    return l2;
  }
  function lineRadial_default() {
    return lineRadial(line_default().curve(curveRadialLinear));
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/areaRadial.js
  function areaRadial_default() {
    var a3 = area_default().curve(curveRadialLinear), c5 = a3.curve, x05 = a3.lineX0, x12 = a3.lineX1, y05 = a3.lineY0, y12 = a3.lineY1;
    a3.angle = a3.x, delete a3.x;
    a3.startAngle = a3.x0, delete a3.x0;
    a3.endAngle = a3.x1, delete a3.x1;
    a3.radius = a3.y, delete a3.y;
    a3.innerRadius = a3.y0, delete a3.y0;
    a3.outerRadius = a3.y1, delete a3.y1;
    a3.lineStartAngle = function() {
      return lineRadial(x05());
    }, delete a3.lineX0;
    a3.lineEndAngle = function() {
      return lineRadial(x12());
    }, delete a3.lineX1;
    a3.lineInnerRadius = function() {
      return lineRadial(y05());
    }, delete a3.lineY0;
    a3.lineOuterRadius = function() {
      return lineRadial(y12());
    }, delete a3.lineY1;
    a3.curve = function(_2) {
      return arguments.length ? c5(curveRadial(_2)) : c5()._curve;
    };
    return a3;
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/noop.js
  function noop_default() {
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/curve/cardinal.js
  function point(that, x3, y3) {
    that._context.bezierCurveTo(
      that._x1 + that._k * (that._x2 - that._x0),
      that._y1 + that._k * (that._y2 - that._y0),
      that._x2 + that._k * (that._x1 - x3),
      that._y2 + that._k * (that._y1 - y3),
      that._x2,
      that._y2
    );
  }
  function Cardinal(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  Cardinal.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          point(this, this._x1, this._y1);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
          this._x1 = x3, this._y1 = y3;
          break;
        case 2:
          this._point = 3;
        default:
          point(this, x3, y3);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var cardinal_default = function custom(tension) {
    function cardinal(context) {
      return new Cardinal(context, tension);
    }
    cardinal.tension = function(tension2) {
      return custom(+tension2);
    };
    return cardinal;
  }(0);

  // ../../engine/rails_design/node_modules/d3-shape/src/curve/cardinalClosed.js
  function CardinalClosed(context, tension) {
    this._context = context;
    this._k = (1 - tension) / 6;
  }
  CardinalClosed.prototype = {
    areaStart: noop_default,
    areaEnd: noop_default,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x3, this._y3 = y3;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x3, this._y4 = y3);
          break;
        case 2:
          this._point = 3;
          this._x5 = x3, this._y5 = y3;
          break;
        default:
          point(this, x3, y3);
          break;
      }
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var cardinalClosed_default = function custom2(tension) {
    function cardinal(context) {
      return new CardinalClosed(context, tension);
    }
    cardinal.tension = function(tension2) {
      return custom2(+tension2);
    };
    return cardinal;
  }(0);

  // ../../engine/rails_design/node_modules/d3-shape/src/curve/catmullRom.js
  function point2(that, x3, y3) {
    var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
    if (that._l01_a > epsilon) {
      var a3 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n2 = 3 * that._l01_a * (that._l01_a + that._l12_a);
      x12 = (x12 * a3 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n2;
      y12 = (y12 * a3 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n2;
    }
    if (that._l23_a > epsilon) {
      var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m3 = 3 * that._l23_a * (that._l23_a + that._l12_a);
      x22 = (x22 * b + that._x1 * that._l23_2a - x3 * that._l12_2a) / m3;
      y22 = (y22 * b + that._y1 * that._l23_2a - y3 * that._l12_2a) / m3;
    }
    that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
  }
  function CatmullRom(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRom.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x2, this._y2);
          break;
        case 3:
          this.point(this._x2, this._y2);
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      if (this._point) {
        var x23 = this._x2 - x3, y23 = this._y2 - y3;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
        default:
          point2(this, x3, y3);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var catmullRom_default = function custom3(alpha) {
    function catmullRom(context) {
      return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
    }
    catmullRom.alpha = function(alpha2) {
      return custom3(+alpha2);
    };
    return catmullRom;
  }(0.5);

  // ../../engine/rails_design/node_modules/d3-shape/src/curve/catmullRomClosed.js
  function CatmullRomClosed(context, alpha) {
    this._context = context;
    this._alpha = alpha;
  }
  CatmullRomClosed.prototype = {
    areaStart: noop_default,
    areaEnd: noop_default,
    lineStart: function() {
      this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
      this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 1: {
          this._context.moveTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 2: {
          this._context.lineTo(this._x3, this._y3);
          this._context.closePath();
          break;
        }
        case 3: {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
      }
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      if (this._point) {
        var x23 = this._x2 - x3, y23 = this._y2 - y3;
        this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
      }
      switch (this._point) {
        case 0:
          this._point = 1;
          this._x3 = x3, this._y3 = y3;
          break;
        case 1:
          this._point = 2;
          this._context.moveTo(this._x4 = x3, this._y4 = y3);
          break;
        case 2:
          this._point = 3;
          this._x5 = x3, this._y5 = y3;
          break;
        default:
          point2(this, x3, y3);
          break;
      }
      this._l01_a = this._l12_a, this._l12_a = this._l23_a;
      this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
      this._x0 = this._x1, this._x1 = this._x2, this._x2 = x3;
      this._y0 = this._y1, this._y1 = this._y2, this._y2 = y3;
    }
  };
  var catmullRomClosed_default = function custom4(alpha) {
    function catmullRom(context) {
      return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
    }
    catmullRom.alpha = function(alpha2) {
      return custom4(+alpha2);
    };
    return catmullRom;
  }(0.5);

  // ../../engine/rails_design/node_modules/d3-shape/src/curve/linearClosed.js
  function LinearClosed(context) {
    this._context = context;
  }
  LinearClosed.prototype = {
    areaStart: noop_default,
    areaEnd: noop_default,
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._point) this._context.closePath();
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      if (this._point) this._context.lineTo(x3, y3);
      else this._point = 1, this._context.moveTo(x3, y3);
    }
  };
  function linearClosed_default(context) {
    return new LinearClosed(context);
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/curve/monotone.js
  function sign(x3) {
    return x3 < 0 ? -1 : 1;
  }
  function slope3(that, x22, y22) {
    var h0 = that._x1 - that._x0, h1 = x22 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y22 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
    return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
  }
  function slope2(that, t) {
    var h = that._x1 - that._x0;
    return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
  }
  function point3(that, t0, t1) {
    var x05 = that._x0, y05 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x05) / 3;
    that._context.bezierCurveTo(x05 + dx, y05 + dx * t0, x12 - dx, y12 - dx * t1, x12, y12);
  }
  function MonotoneX(context) {
    this._context = context;
  }
  MonotoneX.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      switch (this._point) {
        case 2:
          this._context.lineTo(this._x1, this._y1);
          break;
        case 3:
          point3(this, this._t0, slope2(this, this._t0));
          break;
      }
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      var t1 = NaN;
      x3 = +x3, y3 = +y3;
      if (x3 === this._x1 && y3 === this._y1) return;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
          break;
        case 2:
          this._point = 3;
          point3(this, slope2(this, t1 = slope3(this, x3, y3)), t1);
          break;
        default:
          point3(this, this._t0, t1 = slope3(this, x3, y3));
          break;
      }
      this._x0 = this._x1, this._x1 = x3;
      this._y0 = this._y1, this._y1 = y3;
      this._t0 = t1;
    }
  };
  function MonotoneY(context) {
    this._context = new ReflectContext(context);
  }
  (MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x3, y3) {
    MonotoneX.prototype.point.call(this, y3, x3);
  };
  function ReflectContext(context) {
    this._context = context;
  }
  ReflectContext.prototype = {
    moveTo: function(x3, y3) {
      this._context.moveTo(y3, x3);
    },
    closePath: function() {
      this._context.closePath();
    },
    lineTo: function(x3, y3) {
      this._context.lineTo(y3, x3);
    },
    bezierCurveTo: function(x12, y12, x22, y22, x3, y3) {
      this._context.bezierCurveTo(y12, x12, y22, x22, y3, x3);
    }
  };
  function monotoneX(context) {
    return new MonotoneX(context);
  }
  function monotoneY(context) {
    return new MonotoneY(context);
  }

  // ../../engine/rails_design/node_modules/d3-shape/src/curve/step.js
  function Step(context, t) {
    this._context = context;
    this._t = t;
  }
  Step.prototype = {
    areaStart: function() {
      this._line = 0;
    },
    areaEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._x = this._y = NaN;
      this._point = 0;
    },
    lineEnd: function() {
      if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
      if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
      if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
    },
    point: function(x3, y3) {
      x3 = +x3, y3 = +y3;
      switch (this._point) {
        case 0:
          this._point = 1;
          this._line ? this._context.lineTo(x3, y3) : this._context.moveTo(x3, y3);
          break;
        case 1:
          this._point = 2;
        default: {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y3);
            this._context.lineTo(x3, y3);
          } else {
            var x12 = this._x * (1 - this._t) + x3 * this._t;
            this._context.lineTo(x12, this._y);
            this._context.lineTo(x12, y3);
          }
          break;
        }
      }
      this._x = x3, this._y = y3;
    }
  };
  function step_default(context) {
    return new Step(context, 0.5);
  }
  function stepBefore(context) {
    return new Step(context, 0);
  }
  function stepAfter(context) {
    return new Step(context, 1);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/coordinate.js
  function isTranspose(coordinate) {
    const { transformations } = coordinate.getOptions();
    const transposes = transformations.map(([type]) => type).filter((type) => type === "transpose");
    return transposes.length % 2 !== 0;
  }
  function isPolar(coordinate) {
    const { transformations } = coordinate.getOptions();
    return transformations.some(([type]) => type === "polar");
  }
  function isRadial(coordinate) {
    const { transformations } = coordinate.getOptions();
    return (
      // distinguish radial from theta.
      transformations.some(([type]) => type === "reflect") && transformations.some(([type]) => type.startsWith("transpose"))
    );
  }
  function isHelix(coordinate) {
    const { transformations } = coordinate.getOptions();
    return transformations.some(([type]) => type === "helix");
  }
  function isParallel(coordinate) {
    const { transformations } = coordinate.getOptions();
    return transformations.some(([type]) => type === "parallel");
  }
  function isFisheye(coordinate) {
    const { transformations } = coordinate.getOptions();
    return transformations.some(([type]) => type === "fisheye");
  }
  function isRadar(coordinate) {
    return isParallel(coordinate) && isPolar(coordinate);
  }
  function isCircular(coordinate) {
    return isHelix(coordinate) || isPolar(coordinate);
  }
  function isTheta(coordinate) {
    return isPolar(coordinate) && isTranspose(coordinate);
  }
  function getRadius(coordinate) {
    if (isCircular(coordinate)) {
      const [width, height] = coordinate.getSize();
      const polar = coordinate.getOptions().transformations.find((t) => t[0] === "polar");
      if (polar)
        return Math.max(width, height) / 2 * polar[4];
    }
    return 0;
  }
  function radiusOf(coordinate) {
    const { transformations } = coordinate.getOptions();
    const [, , , innerRadius, outerRadius] = transformations.find((d2) => d2[0] === "polar");
    return [+innerRadius, +outerRadius];
  }
  function angleOf(coordinate, isRadius = true) {
    const { transformations } = coordinate.getOptions();
    const [, startAngle, endAngle] = transformations.find((d2) => d2[0] === "polar");
    return isRadius ? [+startAngle * 180 / Math.PI, +endAngle * 180 / Math.PI] : [startAngle, endAngle];
  }
  function getTransformOptions(coordinate, type) {
    const { transformations } = coordinate.getOptions();
    const [, ...args] = transformations.find((d2) => d2[0] === type);
    return args;
  }

  // ../../engine/rails_design/node_modules/eventemitter3/index.mjs
  var import_index = __toESM(require_eventemitter3(), 1);
  var eventemitter3_default = import_index.default;

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/lodash/is-nil.js
  var isNil2 = function(value2) {
    return value2 === null || value2 === void 0;
  };
  var is_nil_default2 = isNil2;

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/lodash/is-type.js
  var toString2 = {}.toString;
  var isType2 = function(value2, type) {
    return toString2.call(value2) === "[object " + type + "]";
  };
  var is_type_default2 = isType2;

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/lodash/is-array.js
  var is_array_default2 = function(value2) {
    return Array.isArray ? Array.isArray(value2) : is_type_default2(value2, "Array");
  };

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/lodash/is-object.js
  var is_object_default2 = function(value2) {
    var type = typeof value2;
    return value2 !== null && type === "object" || type === "function";
  };

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/lodash/max.js
  var max_default = function(arr) {
    if (!is_array_default2(arr)) {
      return void 0;
    }
    return arr.reduce(function(prev, curr) {
      return Math.max(prev, curr);
    }, arr[0]);
  };

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/lodash/min.js
  var min_default = function(arr) {
    if (!is_array_default2(arr)) {
      return void 0;
    }
    return arr.reduce(function(prev, curr) {
      return Math.min(prev, curr);
    }, arr[0]);
  };

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/lodash/is-string.js
  var is_string_default2 = function(str7) {
    return is_type_default2(str7, "String");
  };

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/lodash/clamp.js
  var clamp = function(a3, min10, max10) {
    if (a3 < min10) {
      return min10;
    } else if (a3 > max10) {
      return max10;
    }
    return a3;
  };
  var clamp_default = clamp;

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/lodash/is-number.js
  var isNumber3 = function(value2) {
    return is_type_default2(value2, "Number");
  };
  var is_number_default2 = isNumber3;

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/lodash/is-number-equal.js
  var PRECISION = 1e-5;
  function isNumberEqual(a3, b, precision) {
    if (precision === void 0) {
      precision = PRECISION;
    }
    return Math.abs(a3 - b) < precision;
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/lodash/mod.js
  var mod2 = function(n2, m3) {
    return (n2 % m3 + m3) % m3;
  };
  var mod_default = mod2;

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/lodash/is-boolean.js
  var isBoolean = function(value2) {
    return is_type_default2(value2, "Boolean");
  };
  var is_boolean_default = isBoolean;

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/lodash/is-undefined.js
  var isUndefined3 = function(value2) {
    return value2 === void 0;
  };
  var is_undefined_default2 = isUndefined3;

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/parser/params-parser.js
  var paramsParser = {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
    x: 0,
    y: 0,
    qx: null,
    qy: null
  };

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/process/fix-arc.js
  function fixArc(pathArray, allPathCommands, i) {
    if (pathArray[i].length > 7) {
      pathArray[i].shift();
      var pi4 = pathArray[i];
      var ni = i;
      while (pi4.length) {
        allPathCommands[i] = "A";
        pathArray.splice(ni += 1, 0, ["C"].concat(pi4.splice(0, 6)));
      }
      pathArray.splice(i, 1);
    }
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/parser/params-count.js
  var paramsCount = {
    a: 7,
    c: 6,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    z: 0
  };

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/is-path-array.js
  function isPathArray(path2) {
    return Array.isArray(path2) && path2.every(function(seg) {
      var lk = seg[0].toLowerCase();
      return paramsCount[lk] === seg.length - 1 && "achlmqstvz".includes(lk);
    });
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/is-absolute-array.js
  function isAbsoluteArray(path2) {
    return isPathArray(path2) && // @ts-ignore -- `isPathArray` also checks if it's `Array`
    path2.every(function(_a) {
      var x3 = _a[0];
      return x3 === x3.toUpperCase();
    });
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/is-normalized-array.js
  function isNormalizedArray(path2) {
    return isAbsoluteArray(path2) && path2.every(function(_a) {
      var pc = _a[0];
      return "ACLMQZ".includes(pc);
    });
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/parser/finalize-segment.js
  function finalizeSegment(path2) {
    var pathCommand = path2.pathValue[path2.segmentStart];
    var LK = pathCommand.toLowerCase();
    var data2 = path2.data;
    while (data2.length >= paramsCount[LK]) {
      if (LK === "m" && data2.length > 2) {
        path2.segments.push([pathCommand].concat(data2.splice(0, 2)));
        LK = "l";
        pathCommand = pathCommand === "m" ? "l" : "L";
      } else {
        path2.segments.push([pathCommand].concat(data2.splice(0, paramsCount[LK])));
      }
      if (!paramsCount[LK]) {
        break;
      }
    }
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/parser/scan-flag.js
  function scanFlag(path2) {
    var index4 = path2.index, pathValue = path2.pathValue;
    var code = pathValue.charCodeAt(index4);
    if (code === 48) {
      path2.param = 0;
      path2.index += 1;
      return;
    }
    if (code === 49) {
      path2.param = 1;
      path2.index += 1;
      return;
    }
    path2.err = '[path-util]: invalid Arc flag "' + pathValue[index4] + '", expecting 0 or 1 at index ' + index4;
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/parser/is-digit-start.js
  function isDigitStart(code) {
    return code >= 48 && code <= 57 || code === 43 || code === 45 || code === 46;
  }
  function isDigit(code) {
    return code >= 48 && code <= 57;
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/parser/scan-param.js
  function scanParam(path2) {
    var max10 = path2.max, pathValue = path2.pathValue, start2 = path2.index;
    var index4 = start2;
    var zeroFirst = false;
    var hasCeiling = false;
    var hasDecimal = false;
    var hasDot = false;
    var ch2;
    if (index4 >= max10) {
      path2.err = "[path-util]: Invalid path value at index " + index4 + ', "pathValue" is missing param';
      return;
    }
    ch2 = pathValue.charCodeAt(index4);
    if (ch2 === 43 || ch2 === 45) {
      index4 += 1;
      ch2 = pathValue.charCodeAt(index4);
    }
    if (!isDigit(ch2) && ch2 !== 46) {
      path2.err = "[path-util]: Invalid path value at index " + index4 + ', "' + pathValue[index4] + '" is not a number';
      return;
    }
    if (ch2 !== 46) {
      zeroFirst = ch2 === 48;
      index4 += 1;
      ch2 = pathValue.charCodeAt(index4);
      if (zeroFirst && index4 < max10) {
        if (ch2 && isDigit(ch2)) {
          path2.err = "[path-util]: Invalid path value at index " + start2 + ', "' + pathValue[start2] + '" illegal number';
          return;
        }
      }
      while (index4 < max10 && isDigit(pathValue.charCodeAt(index4))) {
        index4 += 1;
        hasCeiling = true;
      }
      ch2 = pathValue.charCodeAt(index4);
    }
    if (ch2 === 46) {
      hasDot = true;
      index4 += 1;
      while (isDigit(pathValue.charCodeAt(index4))) {
        index4 += 1;
        hasDecimal = true;
      }
      ch2 = pathValue.charCodeAt(index4);
    }
    if (ch2 === 101 || ch2 === 69) {
      if (hasDot && !hasCeiling && !hasDecimal) {
        path2.err = "[path-util]: Invalid path value at index " + index4 + ', "' + pathValue[index4] + '" invalid float exponent';
        return;
      }
      index4 += 1;
      ch2 = pathValue.charCodeAt(index4);
      if (ch2 === 43 || ch2 === 45) {
        index4 += 1;
      }
      if (index4 < max10 && isDigit(pathValue.charCodeAt(index4))) {
        while (index4 < max10 && isDigit(pathValue.charCodeAt(index4))) {
          index4 += 1;
        }
      } else {
        path2.err = "[path-util]: Invalid path value at index " + index4 + ', "' + pathValue[index4] + '" invalid integer exponent';
        return;
      }
    }
    path2.index = index4;
    path2.param = +path2.pathValue.slice(start2, index4);
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/parser/is-space.js
  function isSpace(ch2) {
    var specialSpaces = [
      5760,
      6158,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ];
    return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233 || // Line terminators
    // White spaces
    ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && specialSpaces.includes(ch2);
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/parser/skip-spaces.js
  function skipSpaces(path2) {
    var pathValue = path2.pathValue, max10 = path2.max;
    while (path2.index < max10 && isSpace(pathValue.charCodeAt(path2.index))) {
      path2.index += 1;
    }
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/parser/is-path-command.js
  function isPathCommand(code) {
    switch (code | 32) {
      case 109:
      case 122:
      case 108:
      case 104:
      case 118:
      case 99:
      case 115:
      case 113:
      case 116:
      case 97:
        return true;
      default:
        return false;
    }
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/parser/is-arc-command.js
  function isArcCommand(code) {
    return (code | 32) === 97;
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/parser/scan-segment.js
  function scanSegment(path2) {
    var max10 = path2.max, pathValue = path2.pathValue, index4 = path2.index;
    var cmdCode = pathValue.charCodeAt(index4);
    var reqParams = paramsCount[pathValue[index4].toLowerCase()];
    path2.segmentStart = index4;
    if (!isPathCommand(cmdCode)) {
      path2.err = '[path-util]: Invalid path value "' + pathValue[index4] + '" is not a path command';
      return;
    }
    path2.index += 1;
    skipSpaces(path2);
    path2.data = [];
    if (!reqParams) {
      finalizeSegment(path2);
      return;
    }
    for (; ; ) {
      for (var i = reqParams; i > 0; i -= 1) {
        if (isArcCommand(cmdCode) && (i === 3 || i === 4))
          scanFlag(path2);
        else
          scanParam(path2);
        if (path2.err.length) {
          return;
        }
        path2.data.push(path2.param);
        skipSpaces(path2);
        if (path2.index < max10 && pathValue.charCodeAt(path2.index) === 44) {
          path2.index += 1;
          skipSpaces(path2);
        }
      }
      if (path2.index >= path2.max) {
        break;
      }
      if (!isDigitStart(pathValue.charCodeAt(path2.index))) {
        break;
      }
    }
    finalizeSegment(path2);
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/parser/path-parser.js
  var PathParser = (
    /** @class */
    /* @__PURE__ */ function() {
      function PathParser2(pathString) {
        this.pathValue = pathString;
        this.segments = [];
        this.max = pathString.length;
        this.index = 0;
        this.param = 0;
        this.segmentStart = 0;
        this.data = [];
        this.err = "";
      }
      return PathParser2;
    }()
  );

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/parser/parse-path-string.js
  function parsePathString(pathInput) {
    if (isPathArray(pathInput)) {
      return [].concat(pathInput);
    }
    var path2 = new PathParser(pathInput);
    skipSpaces(path2);
    while (path2.index < path2.max && !path2.err.length) {
      scanSegment(path2);
    }
    return path2.err ? path2.err : path2.segments;
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/convert/path-2-absolute.js
  function path2Absolute(pathInput) {
    if (isAbsoluteArray(pathInput)) {
      return [].concat(pathInput);
    }
    var path2 = parsePathString(pathInput);
    var x3 = 0;
    var y3 = 0;
    var mx = 0;
    var my = 0;
    return path2.map(function(segment) {
      var values = segment.slice(1).map(Number);
      var pathCommand = segment[0];
      var absCommand = pathCommand.toUpperCase();
      if (pathCommand === "M") {
        x3 = values[0], y3 = values[1];
        mx = x3;
        my = y3;
        return ["M", x3, y3];
      }
      var absoluteSegment;
      if (pathCommand !== absCommand) {
        switch (absCommand) {
          case "A":
            absoluteSegment = [
              absCommand,
              values[0],
              values[1],
              values[2],
              values[3],
              values[4],
              values[5] + x3,
              values[6] + y3
            ];
            break;
          case "V":
            absoluteSegment = [absCommand, values[0] + y3];
            break;
          case "H":
            absoluteSegment = [absCommand, values[0] + x3];
            break;
          default: {
            var absValues = values.map(function(n2, j) {
              return n2 + (j % 2 ? y3 : x3);
            });
            absoluteSegment = [absCommand].concat(absValues);
          }
        }
      } else {
        absoluteSegment = [absCommand].concat(values);
      }
      var segLength = absoluteSegment.length;
      switch (absCommand) {
        case "Z":
          x3 = mx;
          y3 = my;
          break;
        case "H":
          x3 = absoluteSegment[1];
          break;
        case "V":
          y3 = absoluteSegment[1];
          break;
        default:
          x3 = absoluteSegment[segLength - 2];
          y3 = absoluteSegment[segLength - 1];
          if (absCommand === "M") {
            mx = x3;
            my = y3;
          }
      }
      return absoluteSegment;
    });
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/process/normalize-segment.js
  function normalizeSegment(segment, params) {
    var pathCommand = segment[0];
    var px1 = params.x1, py1 = params.y1, px2 = params.x2, py2 = params.y2;
    var values = segment.slice(1).map(Number);
    var result = segment;
    if (!"TQ".includes(pathCommand)) {
      params.qx = null;
      params.qy = null;
    }
    if (pathCommand === "H") {
      result = ["L", segment[1], py1];
    } else if (pathCommand === "V") {
      result = ["L", px1, segment[1]];
    } else if (pathCommand === "S") {
      var x12 = px1 * 2 - px2;
      var y12 = py1 * 2 - py2;
      params.x1 = x12;
      params.y1 = y12;
      result = ["C", x12, y12].concat(values);
    } else if (pathCommand === "T") {
      var qx = px1 * 2 - params.qx;
      var qy = py1 * 2 - params.qy;
      params.qx = qx;
      params.qy = qy;
      result = ["Q", qx, qy].concat(values);
    } else if (pathCommand === "Q") {
      var nqx = values[0], nqy = values[1];
      params.qx = nqx;
      params.qy = nqy;
    }
    return result;
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/process/normalize-path.js
  function normalizePath(pathInput) {
    if (isNormalizedArray(pathInput)) {
      return [].concat(pathInput);
    }
    var path2 = path2Absolute(pathInput);
    var params = __assign({}, paramsParser);
    for (var i = 0; i < path2.length; i += 1) {
      path2[i] = normalizeSegment(path2[i], params);
      var segment = path2[i];
      var seglen = segment.length;
      params.x1 = +segment[seglen - 2];
      params.y1 = +segment[seglen - 1];
      params.x2 = +segment[seglen - 4] || params.x1;
      params.y2 = +segment[seglen - 3] || params.y1;
    }
    return path2;
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/is-curve-array.js
  function isCurveArray(path2) {
    return isNormalizedArray(path2) && path2.every(function(_a) {
      var pc = _a[0];
      return "MC".includes(pc);
    });
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/rotate-vector.js
  function rotateVector(x3, y3, rad) {
    var X = x3 * Math.cos(rad) - y3 * Math.sin(rad);
    var Y = x3 * Math.sin(rad) + y3 * Math.cos(rad);
    return { x: X, y: Y };
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/process/arc-2-cubic.js
  function arcToCubic(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, recursive) {
    var x12 = X12;
    var y12 = Y12;
    var rx = RX;
    var ry = RY;
    var x22 = X22;
    var y22 = Y22;
    var d120 = Math.PI * 120 / 180;
    var rad = Math.PI / 180 * (+angle4 || 0);
    var res = [];
    var xy;
    var f1;
    var f2;
    var cx;
    var cy;
    if (!recursive) {
      xy = rotateVector(x12, y12, -rad);
      x12 = xy.x;
      y12 = xy.y;
      xy = rotateVector(x22, y22, -rad);
      x22 = xy.x;
      y22 = xy.y;
      var x3 = (x12 - x22) / 2;
      var y3 = (y12 - y22) / 2;
      var h = x3 * x3 / (rx * rx) + y3 * y3 / (ry * ry);
      if (h > 1) {
        h = Math.sqrt(h);
        rx *= h;
        ry *= h;
      }
      var rx2 = rx * rx;
      var ry2 = ry * ry;
      var k = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y3 * y3 - ry2 * x3 * x3) / (rx2 * y3 * y3 + ry2 * x3 * x3)));
      cx = k * rx * y3 / ry + (x12 + x22) / 2;
      cy = k * -ry * x3 / rx + (y12 + y22) / 2;
      f1 = Math.asin(((y12 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
      f2 = Math.asin(((y22 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
      f1 = x12 < cx ? Math.PI - f1 : f1;
      f2 = x22 < cx ? Math.PI - f2 : f2;
      if (f1 < 0)
        f1 = Math.PI * 2 + f1;
      if (f2 < 0)
        f2 = Math.PI * 2 + f2;
      if (SF && f1 > f2) {
        f1 -= Math.PI * 2;
      }
      if (!SF && f2 > f1) {
        f2 -= Math.PI * 2;
      }
    } else {
      f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
    }
    var df = f2 - f1;
    if (Math.abs(df) > d120) {
      var f2old = f2;
      var x2old = x22;
      var y2old = y22;
      f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
      x22 = cx + rx * Math.cos(f2);
      y22 = cy + ry * Math.sin(f2);
      res = arcToCubic(x22, y22, rx, ry, angle4, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
    }
    df = f2 - f1;
    var c1 = Math.cos(f1);
    var s1 = Math.sin(f1);
    var c22 = Math.cos(f2);
    var s2 = Math.sin(f2);
    var t = Math.tan(df / 4);
    var hx = 4 / 3 * rx * t;
    var hy = 4 / 3 * ry * t;
    var m1 = [x12, y12];
    var m22 = [x12 + hx * s1, y12 - hy * c1];
    var m3 = [x22 + hx * s2, y22 - hy * c22];
    var m4 = [x22, y22];
    m22[0] = 2 * m1[0] - m22[0];
    m22[1] = 2 * m1[1] - m22[1];
    if (recursive) {
      return m22.concat(m3, m4, res);
    }
    res = m22.concat(m3, m4, res);
    var newres = [];
    for (var i = 0, ii = res.length; i < ii; i += 1) {
      newres[i] = i % 2 ? rotateVector(res[i - 1], res[i], rad).y : rotateVector(res[i], res[i + 1], rad).x;
    }
    return newres;
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/process/quad-2-cubic.js
  function quadToCubic(x12, y12, qx, qy, x22, y22) {
    var r13 = 1 / 3;
    var r23 = 2 / 3;
    return [
      r13 * x12 + r23 * qx,
      r13 * y12 + r23 * qy,
      r13 * x22 + r23 * qx,
      r13 * y22 + r23 * qy,
      x22,
      y22
      // x,y
    ];
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/mid-point.js
  function midPoint(a3, b, t) {
    var ax = a3[0];
    var ay = a3[1];
    var bx = b[0];
    var by = b[1];
    return [ax + (bx - ax) * t, ay + (by - ay) * t];
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/process/line-2-cubic.js
  var lineToCubic = function(x12, y12, x22, y22) {
    var t = 0.5;
    var mid2 = midPoint([x12, y12], [x22, y22], t);
    return __spreadArray(__spreadArray([], mid2, true), [x22, y22, x22, y22], false);
  };

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/process/segment-2-cubic.js
  function segmentToCubic(segment, params) {
    var pathCommand = segment[0];
    var values = segment.slice(1).map(Number);
    var x3 = values[0], y3 = values[1];
    var args;
    var px1 = params.x1, py1 = params.y1, px = params.x, py = params.y;
    if (!"TQ".includes(pathCommand)) {
      params.qx = null;
      params.qy = null;
    }
    switch (pathCommand) {
      case "M":
        params.x = x3;
        params.y = y3;
        return segment;
      case "A":
        args = [px1, py1].concat(values);
        return ["C"].concat(arcToCubic(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]));
      case "Q":
        params.qx = x3;
        params.qy = y3;
        args = [px1, py1].concat(values);
        return ["C"].concat(quadToCubic(args[0], args[1], args[2], args[3], args[4], args[5]));
      case "L":
        return ["C"].concat(lineToCubic(px1, py1, x3, y3));
      case "Z":
        if (px1 === px && py1 === py) {
          return ["C", px1, py1, px, py, px, py];
        }
        return ["C"].concat(lineToCubic(px1, py1, px, py));
      default:
    }
    return segment;
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/convert/path-2-curve.js
  function path2Curve(pathInput, needZCommandIndexes) {
    if (needZCommandIndexes === void 0) {
      needZCommandIndexes = false;
    }
    if (isCurveArray(pathInput)) {
      var cloned = [].concat(pathInput);
      if (needZCommandIndexes) {
        return [cloned, []];
      } else {
        return cloned;
      }
    }
    var path2 = normalizePath(pathInput);
    var params = __assign({}, paramsParser);
    var allPathCommands = [];
    var pathCommand = "";
    var ii = path2.length;
    var segment;
    var seglen;
    var zCommandIndexes = [];
    for (var i = 0; i < ii; i += 1) {
      if (path2[i])
        pathCommand = path2[i][0];
      allPathCommands[i] = pathCommand;
      var curveSegment = segmentToCubic(path2[i], params);
      path2[i] = curveSegment;
      fixArc(path2, allPathCommands, i);
      ii = path2.length;
      if (pathCommand === "Z") {
        zCommandIndexes.push(i);
      }
      segment = path2[i];
      seglen = segment.length;
      params.x1 = +segment[seglen - 2];
      params.y1 = +segment[seglen - 1];
      params.x2 = +segment[seglen - 4] || params.x1;
      params.y2 = +segment[seglen - 3] || params.y1;
    }
    if (needZCommandIndexes) {
      return [path2, zCommandIndexes];
    } else {
      return path2;
    }
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/process/clone-path.js
  function clonePath(path2) {
    return path2.map(function(x3) {
      return Array.isArray(x3) ? [].concat(x3) : x3;
    });
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/process/reverse-curve.js
  function reverseCurve(pathArray) {
    var rotatedCurve = pathArray.slice(1).map(function(x3, i, curveOnly) {
      return !i ? pathArray[0].slice(1).concat(x3.slice(1)) : curveOnly[i - 1].slice(-2).concat(x3.slice(1));
    }).map(function(x3) {
      return x3.map(function(y3, i) {
        return x3[x3.length - i - 2 * (1 - i % 2)];
      });
    }).reverse();
    return [["M"].concat(rotatedCurve[0].slice(0, 2))].concat(rotatedCurve.map(function(x3) {
      return ["C"].concat(x3.slice(2));
    }));
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/distance-square-root.js
  function distanceSquareRoot(a3, b) {
    return Math.sqrt((a3[0] - b[0]) * (a3[0] - b[0]) + (a3[1] - b[1]) * (a3[1] - b[1]));
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/segment-line-factory.js
  function segmentLineFactory(x12, y12, x22, y22, distance8) {
    var length5 = distanceSquareRoot([x12, y12], [x22, y22]);
    var point6 = { x: 0, y: 0 };
    if (typeof distance8 === "number") {
      if (distance8 <= 0) {
        point6 = { x: x12, y: y12 };
      } else if (distance8 >= length5) {
        point6 = { x: x22, y: y22 };
      } else {
        var _a = midPoint([x12, y12], [x22, y22], distance8 / length5), x3 = _a[0], y3 = _a[1];
        point6 = { x: x3, y: y3 };
      }
    }
    return {
      length: length5,
      point: point6,
      min: {
        x: Math.min(x12, x22),
        y: Math.min(y12, y22)
      },
      max: {
        x: Math.max(x12, x22),
        y: Math.max(y12, y22)
      }
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/segment-arc-factory.js
  function angleBetween2(v0, v1) {
    var v0x = v0.x, v0y = v0.y;
    var v1x = v1.x, v1y = v1.y;
    var p2 = v0x * v1x + v0y * v1y;
    var n2 = Math.sqrt((Math.pow(v0x, 2) + Math.pow(v0y, 2)) * (Math.pow(v1x, 2) + Math.pow(v1y, 2)));
    var sign3 = v0x * v1y - v0y * v1x < 0 ? -1 : 1;
    var angle4 = sign3 * Math.acos(p2 / n2);
    return angle4;
  }
  function getPointAtArcSegmentLength(x12, y12, RX, RY, angle4, LAF, SF, x3, y3, t) {
    var abs3 = Math.abs, sin3 = Math.sin, cos3 = Math.cos, sqrt3 = Math.sqrt, PI = Math.PI;
    var rx = abs3(RX);
    var ry = abs3(RY);
    var xRot = (angle4 % 360 + 360) % 360;
    var xRotRad = xRot * (PI / 180);
    if (x12 === x3 && y12 === y3) {
      return { x: x12, y: y12 };
    }
    if (rx === 0 || ry === 0) {
      return segmentLineFactory(x12, y12, x3, y3, t).point;
    }
    var dx = (x12 - x3) / 2;
    var dy = (y12 - y3) / 2;
    var transformedPoint = {
      x: cos3(xRotRad) * dx + sin3(xRotRad) * dy,
      y: -sin3(xRotRad) * dx + cos3(xRotRad) * dy
    };
    var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
    if (radiiCheck > 1) {
      rx *= sqrt3(radiiCheck);
      ry *= sqrt3(radiiCheck);
    }
    var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
    var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
    var cRadicand = cSquareNumerator / cSquareRootDenom;
    cRadicand = cRadicand < 0 ? 0 : cRadicand;
    var cCoef = (LAF !== SF ? 1 : -1) * sqrt3(cRadicand);
    var transformedCenter = {
      x: cCoef * (rx * transformedPoint.y / ry),
      y: cCoef * (-(ry * transformedPoint.x) / rx)
    };
    var center2 = {
      x: cos3(xRotRad) * transformedCenter.x - sin3(xRotRad) * transformedCenter.y + (x12 + x3) / 2,
      y: sin3(xRotRad) * transformedCenter.x + cos3(xRotRad) * transformedCenter.y + (y12 + y3) / 2
    };
    var startVector = {
      x: (transformedPoint.x - transformedCenter.x) / rx,
      y: (transformedPoint.y - transformedCenter.y) / ry
    };
    var startAngle = angleBetween2({ x: 1, y: 0 }, startVector);
    var endVector = {
      x: (-transformedPoint.x - transformedCenter.x) / rx,
      y: (-transformedPoint.y - transformedCenter.y) / ry
    };
    var sweepAngle = angleBetween2(startVector, endVector);
    if (!SF && sweepAngle > 0) {
      sweepAngle -= 2 * PI;
    } else if (SF && sweepAngle < 0) {
      sweepAngle += 2 * PI;
    }
    sweepAngle %= 2 * PI;
    var alpha = startAngle + sweepAngle * t;
    var ellipseComponentX = rx * cos3(alpha);
    var ellipseComponentY = ry * sin3(alpha);
    var point6 = {
      x: cos3(xRotRad) * ellipseComponentX - sin3(xRotRad) * ellipseComponentY + center2.x,
      y: sin3(xRotRad) * ellipseComponentX + cos3(xRotRad) * ellipseComponentY + center2.y
    };
    return point6;
  }
  function segmentArcFactory(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, distance8, options) {
    var _a;
    var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 30 : _d;
    var distanceIsNumber = typeof distance8 === "number";
    var x3 = X12;
    var y3 = Y12;
    var LENGTH = 0;
    var prev = [x3, y3, LENGTH];
    var cur = [x3, y3];
    var t = 0;
    var POINT = { x: 0, y: 0 };
    var POINTS = [{ x: x3, y: y3 }];
    if (distanceIsNumber && distance8 <= 0) {
      POINT = { x: x3, y: y3 };
    }
    for (var j = 0; j <= sampleSize; j += 1) {
      t = j / sampleSize;
      _a = getPointAtArcSegmentLength(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, t), x3 = _a.x, y3 = _a.y;
      if (bbox) {
        POINTS.push({ x: x3, y: y3 });
      }
      if (length5) {
        LENGTH += distanceSquareRoot(cur, [x3, y3]);
      }
      cur = [x3, y3];
      if (distanceIsNumber && LENGTH >= distance8 && distance8 > prev[2]) {
        var dv = (LENGTH - distance8) / (LENGTH - prev[2]);
        POINT = {
          x: cur[0] * (1 - dv) + prev[0] * dv,
          y: cur[1] * (1 - dv) + prev[1] * dv
        };
      }
      prev = [x3, y3, LENGTH];
    }
    if (distanceIsNumber && distance8 >= LENGTH) {
      POINT = { x: X22, y: Y22 };
    }
    return {
      length: LENGTH,
      point: POINT,
      min: {
        x: Math.min.apply(null, POINTS.map(function(n2) {
          return n2.x;
        })),
        y: Math.min.apply(null, POINTS.map(function(n2) {
          return n2.y;
        }))
      },
      max: {
        x: Math.max.apply(null, POINTS.map(function(n2) {
          return n2.x;
        })),
        y: Math.max.apply(null, POINTS.map(function(n2) {
          return n2.y;
        }))
      }
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/segment-cubic-factory.js
  function getPointAtCubicSegmentLength(x12, y12, c1x, c1y, c2x, c2y, x22, y22, t) {
    var t1 = 1 - t;
    return {
      x: Math.pow(t1, 3) * x12 + 3 * Math.pow(t1, 2) * t * c1x + 3 * t1 * Math.pow(t, 2) * c2x + Math.pow(t, 3) * x22,
      y: Math.pow(t1, 3) * y12 + 3 * Math.pow(t1, 2) * t * c1y + 3 * t1 * Math.pow(t, 2) * c2y + Math.pow(t, 3) * y22
    };
  }
  function segmentCubicFactory(x12, y12, c1x, c1y, c2x, c2y, x22, y22, distance8, options) {
    var _a;
    var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
    var distanceIsNumber = typeof distance8 === "number";
    var x3 = x12;
    var y3 = y12;
    var LENGTH = 0;
    var prev = [x3, y3, LENGTH];
    var cur = [x3, y3];
    var t = 0;
    var POINT = { x: 0, y: 0 };
    var POINTS = [{ x: x3, y: y3 }];
    if (distanceIsNumber && distance8 <= 0) {
      POINT = { x: x3, y: y3 };
    }
    for (var j = 0; j <= sampleSize; j += 1) {
      t = j / sampleSize;
      _a = getPointAtCubicSegmentLength(x12, y12, c1x, c1y, c2x, c2y, x22, y22, t), x3 = _a.x, y3 = _a.y;
      if (bbox) {
        POINTS.push({ x: x3, y: y3 });
      }
      if (length5) {
        LENGTH += distanceSquareRoot(cur, [x3, y3]);
      }
      cur = [x3, y3];
      if (distanceIsNumber && LENGTH >= distance8 && distance8 > prev[2]) {
        var dv = (LENGTH - distance8) / (LENGTH - prev[2]);
        POINT = {
          x: cur[0] * (1 - dv) + prev[0] * dv,
          y: cur[1] * (1 - dv) + prev[1] * dv
        };
      }
      prev = [x3, y3, LENGTH];
    }
    if (distanceIsNumber && distance8 >= LENGTH) {
      POINT = { x: x22, y: y22 };
    }
    return {
      length: LENGTH,
      point: POINT,
      min: {
        x: Math.min.apply(null, POINTS.map(function(n2) {
          return n2.x;
        })),
        y: Math.min.apply(null, POINTS.map(function(n2) {
          return n2.y;
        }))
      },
      max: {
        x: Math.max.apply(null, POINTS.map(function(n2) {
          return n2.x;
        })),
        y: Math.max.apply(null, POINTS.map(function(n2) {
          return n2.y;
        }))
      }
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/segment-quad-factory.js
  function getPointAtQuadSegmentLength(x12, y12, cx, cy, x22, y22, t) {
    var t1 = 1 - t;
    return {
      x: Math.pow(t1, 2) * x12 + 2 * t1 * t * cx + Math.pow(t, 2) * x22,
      y: Math.pow(t1, 2) * y12 + 2 * t1 * t * cy + Math.pow(t, 2) * y22
    };
  }
  function segmentQuadFactory(x12, y12, qx, qy, x22, y22, distance8, options) {
    var _a;
    var _b = options.bbox, bbox = _b === void 0 ? true : _b, _c = options.length, length5 = _c === void 0 ? true : _c, _d = options.sampleSize, sampleSize = _d === void 0 ? 10 : _d;
    var distanceIsNumber = typeof distance8 === "number";
    var x3 = x12;
    var y3 = y12;
    var LENGTH = 0;
    var prev = [x3, y3, LENGTH];
    var cur = [x3, y3];
    var t = 0;
    var POINT = { x: 0, y: 0 };
    var POINTS = [{ x: x3, y: y3 }];
    if (distanceIsNumber && distance8 <= 0) {
      POINT = { x: x3, y: y3 };
    }
    for (var j = 0; j <= sampleSize; j += 1) {
      t = j / sampleSize;
      _a = getPointAtQuadSegmentLength(x12, y12, qx, qy, x22, y22, t), x3 = _a.x, y3 = _a.y;
      if (bbox) {
        POINTS.push({ x: x3, y: y3 });
      }
      if (length5) {
        LENGTH += distanceSquareRoot(cur, [x3, y3]);
      }
      cur = [x3, y3];
      if (distanceIsNumber && LENGTH >= distance8 && distance8 > prev[2]) {
        var dv = (LENGTH - distance8) / (LENGTH - prev[2]);
        POINT = {
          x: cur[0] * (1 - dv) + prev[0] * dv,
          y: cur[1] * (1 - dv) + prev[1] * dv
        };
      }
      prev = [x3, y3, LENGTH];
    }
    if (distanceIsNumber && distance8 >= LENGTH) {
      POINT = { x: x22, y: y22 };
    }
    return {
      length: LENGTH,
      point: POINT,
      min: {
        x: Math.min.apply(null, POINTS.map(function(n2) {
          return n2.x;
        })),
        y: Math.min.apply(null, POINTS.map(function(n2) {
          return n2.y;
        }))
      },
      max: {
        x: Math.max.apply(null, POINTS.map(function(n2) {
          return n2.x;
        })),
        y: Math.max.apply(null, POINTS.map(function(n2) {
          return n2.y;
        }))
      }
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/path-length-factory.js
  function pathLengthFactory(pathInput, distance8, options) {
    var _a, _b, _c, _d, _e, _f;
    var path2 = normalizePath(pathInput);
    var distanceIsNumber = typeof distance8 === "number";
    var isM;
    var data2 = [];
    var pathCommand;
    var x3 = 0;
    var y3 = 0;
    var mx = 0;
    var my = 0;
    var seg;
    var MIN = [];
    var MAX = [];
    var length5 = 0;
    var min10 = { x: 0, y: 0 };
    var max10 = min10;
    var point6 = min10;
    var POINT = min10;
    var LENGTH = 0;
    for (var i = 0, ll = path2.length; i < ll; i += 1) {
      seg = path2[i];
      pathCommand = seg[0];
      isM = pathCommand === "M";
      data2 = !isM ? [x3, y3].concat(seg.slice(1)) : data2;
      if (isM) {
        mx = seg[1], my = seg[2];
        min10 = { x: mx, y: my };
        max10 = min10;
        length5 = 0;
        if (distanceIsNumber && distance8 < 1e-3) {
          POINT = min10;
        }
      } else if (pathCommand === "L") {
        _a = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance8 || 0) - LENGTH), length5 = _a.length, min10 = _a.min, max10 = _a.max, point6 = _a.point;
      } else if (pathCommand === "A") {
        _b = segmentArcFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], data2[8], (distance8 || 0) - LENGTH, options || {}), length5 = _b.length, min10 = _b.min, max10 = _b.max, point6 = _b.point;
      } else if (pathCommand === "C") {
        _c = segmentCubicFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], data2[6], data2[7], (distance8 || 0) - LENGTH, options || {}), length5 = _c.length, min10 = _c.min, max10 = _c.max, point6 = _c.point;
      } else if (pathCommand === "Q") {
        _d = segmentQuadFactory(data2[0], data2[1], data2[2], data2[3], data2[4], data2[5], (distance8 || 0) - LENGTH, options || {}), length5 = _d.length, min10 = _d.min, max10 = _d.max, point6 = _d.point;
      } else if (pathCommand === "Z") {
        data2 = [x3, y3, mx, my];
        _e = segmentLineFactory(data2[0], data2[1], data2[2], data2[3], (distance8 || 0) - LENGTH), length5 = _e.length, min10 = _e.min, max10 = _e.max, point6 = _e.point;
      }
      if (distanceIsNumber && LENGTH < distance8 && LENGTH + length5 >= distance8) {
        POINT = point6;
      }
      MAX.push(max10);
      MIN.push(min10);
      LENGTH += length5;
      _f = pathCommand !== "Z" ? seg.slice(-2) : [mx, my], x3 = _f[0], y3 = _f[1];
    }
    if (distanceIsNumber && distance8 >= LENGTH) {
      POINT = { x: x3, y: y3 };
    }
    return {
      length: LENGTH,
      point: POINT,
      min: {
        x: Math.min.apply(null, MIN.map(function(n2) {
          return n2.x;
        })),
        y: Math.min.apply(null, MIN.map(function(n2) {
          return n2.y;
        }))
      },
      max: {
        x: Math.max.apply(null, MAX.map(function(n2) {
          return n2.x;
        })),
        y: Math.max.apply(null, MAX.map(function(n2) {
          return n2.y;
        }))
      }
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/get-total-length.js
  function getTotalLength(pathInput, options) {
    return pathLengthFactory(pathInput, void 0, __assign(__assign({}, options), { bbox: false, length: true })).length;
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/get-rotated-curve.js
  function getRotations(a3) {
    var segCount = a3.length;
    var pointCount = segCount - 1;
    return a3.map(function(f, idx) {
      return a3.map(function(p2, i) {
        var oldSegIdx = idx + i;
        var seg;
        if (i === 0 || a3[oldSegIdx] && a3[oldSegIdx][0] === "M") {
          seg = a3[oldSegIdx];
          return ["M"].concat(seg.slice(-2));
        }
        if (oldSegIdx >= segCount)
          oldSegIdx -= pointCount;
        return a3[oldSegIdx];
      });
    });
  }
  function getRotatedCurve(a3, b) {
    var segCount = a3.length - 1;
    var lineLengths = [];
    var computedIndex = 0;
    var sumLensSqrd = 0;
    var rotations = getRotations(a3);
    rotations.forEach(function(r, i) {
      a3.slice(1).forEach(function(s2, j) {
        sumLensSqrd += distanceSquareRoot(a3[(i + j) % segCount].slice(-2), b[j % segCount].slice(-2));
      });
      lineLengths[i] = sumLensSqrd;
      sumLensSqrd = 0;
    });
    computedIndex = lineLengths.indexOf(Math.min.apply(null, lineLengths));
    return rotations[computedIndex];
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/get-path-area.js
  function getCubicSegArea(x12, y12, c1x, c1y, c2x, c2y, x22, y22) {
    return 3 * ((y22 - y12) * (c1x + c2x) - (x22 - x12) * (c1y + c2y) + c1y * (x12 - c2x) - c1x * (y12 - c2y) + y22 * (c2x + x12 / 3) - x22 * (c2y + y12 / 3)) / 20;
  }
  function getPathArea(path2) {
    var x3 = 0;
    var y3 = 0;
    var len5 = 0;
    return path2Curve(path2).map(function(seg) {
      var _a;
      switch (seg[0]) {
        case "M":
          x3 = seg[1], y3 = seg[2];
          return 0;
        default:
          var _b = seg.slice(1), c1x = _b[0], c1y = _b[1], c2x = _b[2], c2y = _b[3], x22 = _b[4], y22 = _b[5];
          len5 = getCubicSegArea(x3, y3, c1x, c1y, c2x, c2y, x22, y22);
          _a = seg.slice(-2), x3 = _a[0], y3 = _a[1];
          return len5;
      }
    }).reduce(function(a3, b) {
      return a3 + b;
    }, 0);
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/get-draw-direction.js
  function getDrawDirection(pathArray) {
    return getPathArea(pathArray) >= 0;
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/get-point-at-length.js
  function getPointAtLength(pathInput, distance8, options) {
    return pathLengthFactory(pathInput, distance8, __assign(__assign({}, options), { bbox: false, length: true })).point;
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/util/esm/path/util/equalize-segments.js
  function splitCubic(pts, t) {
    if (t === void 0) {
      t = 0.5;
    }
    var p0 = pts.slice(0, 2);
    var p1 = pts.slice(2, 4);
    var p2 = pts.slice(4, 6);
    var p3 = pts.slice(6, 8);
    var p4 = midPoint(p0, p1, t);
    var p5 = midPoint(p1, p2, t);
    var p6 = midPoint(p2, p3, t);
    var p7 = midPoint(p4, p5, t);
    var p8 = midPoint(p5, p6, t);
    var p9 = midPoint(p7, p8, t);
    return [
      // @ts-ignore
      ["C"].concat(p4, p7, p9),
      // @ts-ignore
      ["C"].concat(p8, p6, p3)
    ];
  }
  function getCurveArray(segments) {
    return segments.map(function(segment, i, pathArray) {
      var segmentData = i && pathArray[i - 1].slice(-2).concat(segment.slice(1));
      var curveLength = i ? segmentCubicFactory(segmentData[0], segmentData[1], segmentData[2], segmentData[3], segmentData[4], segmentData[5], segmentData[6], segmentData[7], segmentData[8], { bbox: false }).length : 0;
      var subsegs;
      if (i) {
        subsegs = curveLength ? splitCubic(segmentData) : [segment, segment];
      } else {
        subsegs = [segment];
      }
      return {
        s: segment,
        ss: subsegs,
        l: curveLength
      };
    });
  }
  function equalizeSegments(path1, path2, TL) {
    var c1 = getCurveArray(path1);
    var c22 = getCurveArray(path2);
    var L1 = c1.length;
    var L2 = c22.length;
    var l1 = c1.filter(function(x3) {
      return x3.l;
    }).length;
    var l2 = c22.filter(function(x3) {
      return x3.l;
    }).length;
    var m1 = c1.filter(function(x3) {
      return x3.l;
    }).reduce(function(a3, _a) {
      var l3 = _a.l;
      return a3 + l3;
    }, 0) / l1 || 0;
    var m22 = c22.filter(function(x3) {
      return x3.l;
    }).reduce(function(a3, _a) {
      var l3 = _a.l;
      return a3 + l3;
    }, 0) / l2 || 0;
    var tl = TL || Math.max(L1, L2);
    var mm = [m1, m22];
    var dif = [tl - L1, tl - L2];
    var canSplit = 0;
    var result = [c1, c22].map(function(x3, i) {
      return x3.l === tl ? x3.map(function(y3) {
        return y3.s;
      }) : x3.map(function(y3, j) {
        canSplit = j && dif[i] && y3.l >= mm[i];
        dif[i] -= canSplit ? 1 : 0;
        return canSplit ? y3.ss : [y3.s];
      }).flat();
    });
    return result[0].length === result[1].length ? result : equalizeSegments(result[0], result[1], tl);
  }

  // ../../engine/rails_design/node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend4(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  // ../../engine/rails_design/node_modules/d3-color/src/color.js
  function Color() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color, color, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color(format3) {
    var m3, l2;
    format3 = (format3 + "").trim().toLowerCase();
    return (m3 = reHex.exec(format3)) ? (l2 = m3[1].length, m3 = parseInt(m3[1], 16), l2 === 6 ? rgbn(m3) : l2 === 3 ? new Rgb(m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, (m3 & 15) << 4 | m3 & 15, 1) : l2 === 8 ? rgba(m3 >> 24 & 255, m3 >> 16 & 255, m3 >> 8 & 255, (m3 & 255) / 255) : l2 === 4 ? rgba(m3 >> 12 & 15 | m3 >> 8 & 240, m3 >> 8 & 15 | m3 >> 4 & 240, m3 >> 4 & 15 | m3 & 240, ((m3 & 15) << 4 | m3 & 15) / 255) : null) : (m3 = reRgbInteger.exec(format3)) ? new Rgb(m3[1], m3[2], m3[3], 1) : (m3 = reRgbPercent.exec(format3)) ? new Rgb(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, 1) : (m3 = reRgbaInteger.exec(format3)) ? rgba(m3[1], m3[2], m3[3], m3[4]) : (m3 = reRgbaPercent.exec(format3)) ? rgba(m3[1] * 255 / 100, m3[2] * 255 / 100, m3[3] * 255 / 100, m3[4]) : (m3 = reHslPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, 1) : (m3 = reHslaPercent.exec(format3)) ? hsla(m3[1], m3[2] / 100, m3[3] / 100, m3[4]) : named.hasOwnProperty(format3) ? rgbn(named[format3]) : format3 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n2) {
    return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
  }
  function rgba(r, g, b, a3) {
    if (a3 <= 0) r = g = b = NaN;
    return new Rgb(r, g, b, a3);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb(r, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r, g, b, opacity) {
    this.r = +r;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb, extend4(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a3 = clampa(this.opacity);
    return `${a3 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a3 === 1 ? ")" : `, ${a3})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value2) {
    return Math.max(0, Math.min(255, Math.round(value2) || 0));
  }
  function hex(value2) {
    value2 = clampi(value2);
    return (value2 < 16 ? "0" : "") + value2.toString(16);
  }
  function hsla(h, s2, l2, a3) {
    if (a3 <= 0) h = s2 = l2 = NaN;
    else if (l2 <= 0 || l2 >= 1) h = s2 = NaN;
    else if (s2 <= 0) h = NaN;
    return new Hsl(h, s2, l2, a3);
  }
  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color)) o = color(o);
    if (!o) return new Hsl();
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, min10 = Math.min(r, g, b), max10 = Math.max(r, g, b), h = NaN, s2 = max10 - min10, l2 = (max10 + min10) / 2;
    if (s2) {
      if (r === max10) h = (g - b) / s2 + (g < b) * 6;
      else if (g === max10) h = (b - r) / s2 + 2;
      else h = (r - g) / s2 + 4;
      s2 /= l2 < 0.5 ? max10 + min10 : 2 - max10 - min10;
      h *= 60;
    } else {
      s2 = l2 > 0 && l2 < 1 ? 0 : h;
    }
    return new Hsl(h, s2, l2, o.opacity);
  }
  function hsl(h, s2, l2, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l2, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s2, l2, opacity) {
    this.h = +h;
    this.s = +s2;
    this.l = +l2;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl, extend4(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m22 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m22;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m22),
        hsl2rgb(h, m1, m22),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m22),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a3 = clampa(this.opacity);
      return `${a3 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a3 === 1 ? ")" : `, ${a3})`}`;
    }
  }));
  function clamph(value2) {
    value2 = (value2 || 0) % 360;
    return value2 < 0 ? value2 + 360 : value2;
  }
  function clampt(value2) {
    return Math.max(0, Math.min(1, value2 || 0));
  }
  function hsl2rgb(h, m1, m22) {
    return (h < 60 ? m1 + (m22 - m1) * h / 60 : h < 180 ? m22 : h < 240 ? m1 + (m22 - m1) * (240 - h) / 60 : m1) * 255;
  }

  // ../../engine/rails_design/node_modules/d3-color/src/math.js
  var radians = Math.PI / 180;
  var degrees = 180 / Math.PI;

  // ../../engine/rails_design/node_modules/d3-color/src/cubehelix.js
  var A = -0.14861;
  var B = 1.78277;
  var C = -0.29227;
  var D = -0.90649;
  var E = 1.97294;
  var ED = E * D;
  var EB = E * B;
  var BC_DA = B * C - D * A;
  function cubehelixConvert(o) {
    if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Rgb)) o = rgbConvert(o);
    var r = o.r / 255, g = o.g / 255, b = o.b / 255, l2 = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l2, k = (E * (g - l2) - C * bl) / D, s2 = Math.sqrt(k * k + bl * bl) / (E * l2 * (1 - l2)), h = s2 ? Math.atan2(k, bl) * degrees - 120 : NaN;
    return new Cubehelix(h < 0 ? h + 360 : h, s2, l2, o.opacity);
  }
  function cubehelix(h, s2, l2, opacity) {
    return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l2, opacity == null ? 1 : opacity);
  }
  function Cubehelix(h, s2, l2, opacity) {
    this.h = +h;
    this.s = +s2;
    this.l = +l2;
    this.opacity = +opacity;
  }
  define_default(Cubehelix, cubehelix, extend4(Color, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = isNaN(this.h) ? 0 : (this.h + 120) * radians, l2 = +this.l, a3 = isNaN(this.s) ? 0 : this.s * l2 * (1 - l2), cosh = Math.cos(h), sinh = Math.sin(h);
      return new Rgb(
        255 * (l2 + a3 * (A * cosh + B * sinh)),
        255 * (l2 + a3 * (C * cosh + D * sinh)),
        255 * (l2 + a3 * (E * cosh)),
        this.opacity
      );
    }
  }));

  // ../../engine/rails_design/node_modules/@antv/g-lite/node_modules/@antv/g-math/dist/index.esm.js
  function distance4(x12, y12, x22, y22) {
    var dx = x12 - x22;
    var dy = y12 - y22;
    return Math.sqrt(dx * dx + dy * dy);
  }
  function getBBoxByArray(xArr, yArr) {
    var minX = Math.min.apply(Math, __spreadArray([], __read(xArr), false));
    var minY = Math.min.apply(Math, __spreadArray([], __read(yArr), false));
    var maxX = Math.max.apply(Math, __spreadArray([], __read(xArr), false));
    var maxY2 = Math.max.apply(Math, __spreadArray([], __read(yArr), false));
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  }
  function xExtrema(rx, ry, xRotation) {
    return Math.atan(-ry / rx * Math.tan(xRotation));
  }
  function yExtrema(rx, ry, xRotation) {
    return Math.atan(ry / (rx * Math.tan(xRotation)));
  }
  function xAt(cx, cy, rx, ry, xRotation, angle4) {
    return rx * Math.cos(xRotation) * Math.cos(angle4) - ry * Math.sin(xRotation) * Math.sin(angle4) + cx;
  }
  function yAt(cx, cy, rx, ry, xRotation, angle4) {
    return rx * Math.sin(xRotation) * Math.cos(angle4) + ry * Math.cos(xRotation) * Math.sin(angle4) + cy;
  }
  function box$5(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var xAngle = xDim + i;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }
    for (var i = 0; i < xs.length; i++) {
      var x3 = xAt(cx, cy, rx, ry, xRotation, xs[i]);
      if (x3 < minX) {
        minX = x3;
      }
      if (x3 > maxX) {
        maxX = x3;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY2 = -Infinity;
    var ys = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var yAngle = yDim + i;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }
    for (var i = 0; i < ys.length; i++) {
      var y3 = yAt(cx, cy, rx, ry, xRotation, ys[i]);
      if (y3 < minY) {
        minY = y3;
      }
      if (y3 > maxY2) {
        maxY2 = y3;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  }
  function length$4(x12, y12, x22, y22) {
    return distance4(x12, y12, x22, y22);
  }
  function pointAt$3(x12, y12, x22, y22, t) {
    return {
      x: (1 - t) * x12 + t * x22,
      y: (1 - t) * y12 + t * y22
    };
  }
  function cubicAt(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
  }
  function extrema$1(p0, p1, p2, p3) {
    var a3 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
    var b = 6 * p0 - 12 * p1 + 6 * p2;
    var c5 = 3 * p1 - 3 * p0;
    var extremas = [];
    var t1;
    var t2;
    var discSqrt;
    if (isNumberEqual(a3, 0)) {
      if (!isNumberEqual(b, 0)) {
        t1 = -c5 / b;
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
      }
    } else {
      var disc = b * b - 4 * a3 * c5;
      if (isNumberEqual(disc, 0)) {
        extremas.push(-b / (2 * a3));
      } else if (disc > 0) {
        discSqrt = Math.sqrt(disc);
        t1 = (-b + discSqrt) / (2 * a3);
        t2 = (-b - discSqrt) / (2 * a3);
        if (t1 >= 0 && t1 <= 1) {
          extremas.push(t1);
        }
        if (t2 >= 0 && t2 <= 1) {
          extremas.push(t2);
        }
      }
    }
    return extremas;
  }
  function box$3(x12, y12, x22, y22, x3, y3, x4, y4) {
    var xArr = [x12, x4];
    var yArr = [y12, y4];
    var xExtrema2 = extrema$1(x12, x22, x3, x4);
    var yExtrema2 = extrema$1(y12, y22, y3, y4);
    for (var i = 0; i < xExtrema2.length; i++) {
      xArr.push(cubicAt(x12, x22, x3, x4, xExtrema2[i]));
    }
    for (var i = 0; i < yExtrema2.length; i++) {
      yArr.push(cubicAt(y12, y22, y3, y4, yExtrema2[i]));
    }
    return getBBoxByArray(xArr, yArr);
  }
  function lengthOfSegment(points) {
    if (points.length < 2) {
      return 0;
    }
    var totalLength = 0;
    for (var i = 0; i < points.length - 1; i++) {
      var from = points[i];
      var to = points[i + 1];
      totalLength += distance4(from[0], from[1], to[0], to[1]);
    }
    return totalLength;
  }
  function length$2(points) {
    return lengthOfSegment(points);
  }
  function quadraticAt(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
  }
  function extrema(p0, p1, p2) {
    var a3 = p0 + p2 - 2 * p1;
    if (isNumberEqual(a3, 0)) {
      return [0.5];
    }
    var rst = (p0 - p1) / a3;
    if (rst <= 1 && rst >= 0) {
      return [rst];
    }
    return [];
  }
  function box(x12, y12, x22, y22, x3, y3) {
    var xExtrema2 = extrema(x12, x22, x3)[0];
    var yExtrema2 = extrema(y12, y22, y3)[0];
    var xArr = [x12, x3];
    var yArr = [y12, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x12, x22, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y12, y22, y3, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  }

  // ../../engine/rails_design/node_modules/@antv/g-lite/dist/index.esm.js
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var rbush = { exports: {} };
  (function(module, exports) {
    (function(global2, factory) {
      module.exports = factory();
    })(commonjsGlobal, function() {
      function quickselect2(arr, k, left2, right2, compare) {
        quickselectStep(arr, k, left2 || 0, right2 || arr.length - 1, compare || defaultCompare);
      }
      function quickselectStep(arr, k, left2, right2, compare) {
        while (right2 > left2) {
          if (right2 - left2 > 600) {
            var n2 = right2 - left2 + 1;
            var m3 = k - left2 + 1;
            var z = Math.log(n2);
            var s2 = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s2 * (n2 - s2) / n2) * (m3 - n2 / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left2, Math.floor(k - m3 * s2 / n2 + sd));
            var newRight = Math.min(right2, Math.floor(k + (n2 - m3) * s2 / n2 + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
          }
          var t = arr[k];
          var i = left2;
          var j = right2;
          swap2(arr, left2, k);
          if (compare(arr[right2], t) > 0) {
            swap2(arr, left2, right2);
          }
          while (i < j) {
            swap2(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) {
              i++;
            }
            while (compare(arr[j], t) > 0) {
              j--;
            }
          }
          if (compare(arr[left2], t) === 0) {
            swap2(arr, left2, j);
          } else {
            j++;
            swap2(arr, j, right2);
          }
          if (j <= k) {
            left2 = j + 1;
          }
          if (k <= j) {
            right2 = j - 1;
          }
        }
      }
      function swap2(arr, i, j) {
        var tmp2 = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp2;
      }
      function defaultCompare(a3, b) {
        return a3 < b ? -1 : a3 > b ? 1 : 0;
      }
      var RBush2 = function RBush3(maxEntries) {
        if (maxEntries === void 0) maxEntries = 9;
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
      };
      RBush2.prototype.all = function all() {
        return this._all(this.data, []);
      };
      RBush2.prototype.search = function search2(bbox) {
        var node = this.data;
        var result = [];
        if (!intersects2(bbox, node)) {
          return result;
        }
        var toBBox = this.toBBox;
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? toBBox(child) : child;
            if (intersects2(bbox, childBBox)) {
              if (node.leaf) {
                result.push(child);
              } else if (contains(bbox, childBBox)) {
                this._all(child, result);
              } else {
                nodesToSearch.push(child);
              }
            }
          }
          node = nodesToSearch.pop();
        }
        return result;
      };
      RBush2.prototype.collides = function collides(bbox) {
        var node = this.data;
        if (!intersects2(bbox, node)) {
          return false;
        }
        var nodesToSearch = [];
        while (node) {
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var childBBox = node.leaf ? this.toBBox(child) : child;
            if (intersects2(bbox, childBBox)) {
              if (node.leaf || contains(bbox, childBBox)) {
                return true;
              }
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      };
      RBush2.prototype.load = function load(data2) {
        if (!(data2 && data2.length)) {
          return this;
        }
        if (data2.length < this._minEntries) {
          for (var i = 0; i < data2.length; i++) {
            this.insert(data2[i]);
          }
          return this;
        }
        var node = this._build(data2.slice(), 0, data2.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      };
      RBush2.prototype.insert = function insert(item) {
        if (item) {
          this._insert(item, this.data.height - 1);
        }
        return this;
      };
      RBush2.prototype.clear = function clear() {
        this.data = createNode2([]);
        return this;
      };
      RBush2.prototype.remove = function remove(item, equalsFn) {
        if (!item) {
          return this;
        }
        var node = this.data;
        var bbox = this.toBBox(item);
        var path2 = [];
        var indexes2 = [];
        var i, parent, goingUp;
        while (node || path2.length) {
          if (!node) {
            node = path2.pop();
            parent = path2[path2.length - 1];
            i = indexes2.pop();
            goingUp = true;
          }
          if (node.leaf) {
            var index4 = findItem(item, node.children, equalsFn);
            if (index4 !== -1) {
              node.children.splice(index4, 1);
              path2.push(node);
              this._condense(path2);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains(node, bbox)) {
            path2.push(node);
            indexes2.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else {
            node = null;
          }
        }
        return this;
      };
      RBush2.prototype.toBBox = function toBBox(item) {
        return item;
      };
      RBush2.prototype.compareMinX = function compareMinX(a3, b) {
        return a3.minX - b.minX;
      };
      RBush2.prototype.compareMinY = function compareMinY(a3, b) {
        return a3.minY - b.minY;
      };
      RBush2.prototype.toJSON = function toJSON() {
        return this.data;
      };
      RBush2.prototype.fromJSON = function fromJSON(data2) {
        this.data = data2;
        return this;
      };
      RBush2.prototype._all = function _all(node, result) {
        var nodesToSearch = [];
        while (node) {
          if (node.leaf) {
            result.push.apply(result, node.children);
          } else {
            nodesToSearch.push.apply(nodesToSearch, node.children);
          }
          node = nodesToSearch.pop();
        }
        return result;
      };
      RBush2.prototype._build = function _build(items, left2, right2, height) {
        var N = right2 - left2 + 1;
        var M2 = this._maxEntries;
        var node;
        if (N <= M2) {
          node = createNode2(items.slice(left2, right2 + 1));
          calcBBox2(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N) / Math.log(M2));
          M2 = Math.ceil(N / Math.pow(M2, height - 1));
        }
        node = createNode2([]);
        node.leaf = false;
        node.height = height;
        var N2 = Math.ceil(N / M2);
        var N1 = N2 * Math.ceil(Math.sqrt(M2));
        multiSelect(items, left2, right2, N1, this.compareMinX);
        for (var i = left2; i <= right2; i += N1) {
          var right22 = Math.min(i + N1 - 1, right2);
          multiSelect(items, i, right22, N2, this.compareMinY);
          for (var j = i; j <= right22; j += N2) {
            var right3 = Math.min(j + N2 - 1, right22);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        calcBBox2(node, this.toBBox);
        return node;
      };
      RBush2.prototype._chooseSubtree = function _chooseSubtree(bbox, node, level, path2) {
        while (true) {
          path2.push(node);
          if (node.leaf || path2.length - 1 === level) {
            break;
          }
          var minArea = Infinity;
          var minEnlargement = Infinity;
          var targetNode = void 0;
          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];
            var area2 = bboxArea(child);
            var enlargement = enlargedArea(bbox, child) - area2;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area2 < minArea ? area2 : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area2 < minArea) {
                minArea = area2;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      };
      RBush2.prototype._insert = function _insert(item, level, isNode) {
        var bbox = isNode ? item : this.toBBox(item);
        var insertPath = [];
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);
        node.children.push(item);
        extend7(node, bbox);
        while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
            this._split(insertPath, level);
            level--;
          } else {
            break;
          }
        }
        this._adjustParentBBoxes(bbox, insertPath, level);
      };
      RBush2.prototype._split = function _split(insertPath, level) {
        var node = insertPath[level];
        var M2 = node.children.length;
        var m3 = this._minEntries;
        this._chooseSplitAxis(node, m3, M2);
        var splitIndex = this._chooseSplitIndex(node, m3, M2);
        var newNode = createNode2(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox2(node, this.toBBox);
        calcBBox2(newNode, this.toBBox);
        if (level) {
          insertPath[level - 1].children.push(newNode);
        } else {
          this._splitRoot(node, newNode);
        }
      };
      RBush2.prototype._splitRoot = function _splitRoot(node, newNode) {
        this.data = createNode2([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox2(this.data, this.toBBox);
      };
      RBush2.prototype._chooseSplitIndex = function _chooseSplitIndex(node, m3, M2) {
        var index4;
        var minOverlap = Infinity;
        var minArea = Infinity;
        for (var i = m3; i <= M2 - m3; i++) {
          var bbox1 = distBBox(node, 0, i, this.toBBox);
          var bbox2 = distBBox(node, i, M2, this.toBBox);
          var overlap = intersectionArea2(bbox1, bbox2);
          var area2 = bboxArea(bbox1) + bboxArea(bbox2);
          if (overlap < minOverlap) {
            minOverlap = overlap;
            index4 = i;
            minArea = area2 < minArea ? area2 : minArea;
          } else if (overlap === minOverlap) {
            if (area2 < minArea) {
              minArea = area2;
              index4 = i;
            }
          }
        }
        return index4 || M2 - m3;
      };
      RBush2.prototype._chooseSplitAxis = function _chooseSplitAxis(node, m3, M2) {
        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        var xMargin = this._allDistMargin(node, m3, M2, compareMinX);
        var yMargin = this._allDistMargin(node, m3, M2, compareMinY);
        if (xMargin < yMargin) {
          node.children.sort(compareMinX);
        }
      };
      RBush2.prototype._allDistMargin = function _allDistMargin(node, m3, M2, compare) {
        node.children.sort(compare);
        var toBBox = this.toBBox;
        var leftBBox = distBBox(node, 0, m3, toBBox);
        var rightBBox = distBBox(node, M2 - m3, M2, toBBox);
        var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
        for (var i = m3; i < M2 - m3; i++) {
          var child = node.children[i];
          extend7(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (var i$1 = M2 - m3 - 1; i$1 >= m3; i$1--) {
          var child$1 = node.children[i$1];
          extend7(rightBBox, node.leaf ? toBBox(child$1) : child$1);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      };
      RBush2.prototype._adjustParentBBoxes = function _adjustParentBBoxes(bbox, path2, level) {
        for (var i = level; i >= 0; i--) {
          extend7(path2[i], bbox);
        }
      };
      RBush2.prototype._condense = function _condense(path2) {
        for (var i = path2.length - 1, siblings = void 0; i >= 0; i--) {
          if (path2[i].children.length === 0) {
            if (i > 0) {
              siblings = path2[i - 1].children;
              siblings.splice(siblings.indexOf(path2[i]), 1);
            } else {
              this.clear();
            }
          } else {
            calcBBox2(path2[i], this.toBBox);
          }
        }
      };
      function findItem(item, items, equalsFn) {
        if (!equalsFn) {
          return items.indexOf(item);
        }
        for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) {
            return i;
          }
        }
        return -1;
      }
      function calcBBox2(node, toBBox) {
        distBBox(node, 0, node.children.length, toBBox, node);
      }
      function distBBox(node, k, p2, toBBox, destNode) {
        if (!destNode) {
          destNode = createNode2(null);
        }
        destNode.minX = Infinity;
        destNode.minY = Infinity;
        destNode.maxX = -Infinity;
        destNode.maxY = -Infinity;
        for (var i = k; i < p2; i++) {
          var child = node.children[i];
          extend7(destNode, node.leaf ? toBBox(child) : child);
        }
        return destNode;
      }
      function extend7(a3, b) {
        a3.minX = Math.min(a3.minX, b.minX);
        a3.minY = Math.min(a3.minY, b.minY);
        a3.maxX = Math.max(a3.maxX, b.maxX);
        a3.maxY = Math.max(a3.maxY, b.maxY);
        return a3;
      }
      function compareNodeMinX(a3, b) {
        return a3.minX - b.minX;
      }
      function compareNodeMinY(a3, b) {
        return a3.minY - b.minY;
      }
      function bboxArea(a3) {
        return (a3.maxX - a3.minX) * (a3.maxY - a3.minY);
      }
      function bboxMargin(a3) {
        return a3.maxX - a3.minX + (a3.maxY - a3.minY);
      }
      function enlargedArea(a3, b) {
        return (Math.max(b.maxX, a3.maxX) - Math.min(b.minX, a3.minX)) * (Math.max(b.maxY, a3.maxY) - Math.min(b.minY, a3.minY));
      }
      function intersectionArea2(a3, b) {
        var minX = Math.max(a3.minX, b.minX);
        var minY = Math.max(a3.minY, b.minY);
        var maxX = Math.min(a3.maxX, b.maxX);
        var maxY2 = Math.min(a3.maxY, b.maxY);
        return Math.max(0, maxX - minX) * Math.max(0, maxY2 - minY);
      }
      function contains(a3, b) {
        return a3.minX <= b.minX && a3.minY <= b.minY && b.maxX <= a3.maxX && b.maxY <= a3.maxY;
      }
      function intersects2(a3, b) {
        return b.minX <= a3.maxX && b.minY <= a3.maxY && b.maxX >= a3.minX && b.maxY >= a3.minY;
      }
      function createNode2(children) {
        return {
          children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
        };
      }
      function multiSelect(arr, left2, right2, n2, compare) {
        var stack = [left2, right2];
        while (stack.length) {
          right2 = stack.pop();
          left2 = stack.pop();
          if (right2 - left2 <= n2) {
            continue;
          }
          var mid2 = left2 + Math.ceil((right2 - left2) / n2 / 2) * n2;
          quickselect2(arr, mid2, left2, right2, compare);
          stack.push(left2, mid2, mid2, right2);
        }
      }
      return RBush2;
    });
  })(rbush);
  var RBush = rbush.exports;
  var Shape;
  (function(Shape4) {
    Shape4["GROUP"] = "g";
    Shape4["CIRCLE"] = "circle";
    Shape4["ELLIPSE"] = "ellipse";
    Shape4["IMAGE"] = "image";
    Shape4["RECT"] = "rect";
    Shape4["LINE"] = "line";
    Shape4["POLYLINE"] = "polyline";
    Shape4["POLYGON"] = "polygon";
    Shape4["TEXT"] = "text";
    Shape4["PATH"] = "path";
    Shape4["HTML"] = "html";
    Shape4["MESH"] = "mesh";
  })(Shape || (Shape = {}));
  var ClipSpaceNearZ;
  (function(ClipSpaceNearZ2) {
    ClipSpaceNearZ2[ClipSpaceNearZ2["ZERO"] = 0] = "ZERO";
    ClipSpaceNearZ2[ClipSpaceNearZ2["NEGATIVE_ONE"] = 1] = "NEGATIVE_ONE";
  })(ClipSpaceNearZ || (ClipSpaceNearZ = {}));
  var AbstractRendererPlugin = (
    /** @class */
    function() {
      function AbstractRendererPlugin2() {
        this.plugins = [];
      }
      AbstractRendererPlugin2.prototype.addRenderingPlugin = function(plugin) {
        this.plugins.push(plugin);
        this.context.renderingPlugins.push(plugin);
      };
      AbstractRendererPlugin2.prototype.removeAllRenderingPlugins = function() {
        var _this = this;
        this.plugins.forEach(function(plugin) {
          var index4 = _this.context.renderingPlugins.indexOf(plugin);
          if (index4 >= 0) {
            _this.context.renderingPlugins.splice(index4, 1);
          }
        });
      };
      return AbstractRendererPlugin2;
    }()
  );
  var AbstractRenderer = (
    /** @class */
    function() {
      function AbstractRenderer2(config2) {
        this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
        this.plugins = [];
        this.config = __assign({
          /**
           * only dirty object will cause re-render
           */
          enableDirtyCheck: true,
          enableCulling: false,
          /**
           * enable auto rendering by default
           */
          enableAutoRendering: true,
          /**
           * enable dirty rectangle rendering by default
           */
          enableDirtyRectangleRendering: true,
          enableDirtyRectangleRenderingDebug: false,
          enableSizeAttenuation: true
        }, config2);
      }
      AbstractRenderer2.prototype.registerPlugin = function(plugin) {
        var index4 = this.plugins.findIndex(function(p2) {
          return p2 === plugin;
        });
        if (index4 === -1) {
          this.plugins.push(plugin);
        }
      };
      AbstractRenderer2.prototype.unregisterPlugin = function(plugin) {
        var index4 = this.plugins.findIndex(function(p2) {
          return p2 === plugin;
        });
        if (index4 > -1) {
          this.plugins.splice(index4, 1);
        }
      };
      AbstractRenderer2.prototype.getPlugins = function() {
        return this.plugins;
      };
      AbstractRenderer2.prototype.getPlugin = function(name2) {
        return this.plugins.find(function(plugin) {
          return plugin.name === name2;
        });
      };
      AbstractRenderer2.prototype.getConfig = function() {
        return this.config;
      };
      AbstractRenderer2.prototype.setConfig = function(config2) {
        Object.assign(this.config, config2);
      };
      return AbstractRenderer2;
    }()
  );
  function copyVec3(a3, b) {
    a3[0] = b[0];
    a3[1] = b[1];
    a3[2] = b[2];
    return a3;
  }
  function subVec3(o, a3, b) {
    o[0] = a3[0] - b[0];
    o[1] = a3[1] - b[1];
    o[2] = a3[2] - b[2];
    return o;
  }
  function addVec3(o, a3, b) {
    o[0] = a3[0] + b[0];
    o[1] = a3[1] + b[1];
    o[2] = a3[2] + b[2];
    return o;
  }
  function scaleVec3(o, a3, b) {
    o[0] = a3[0] * b;
    o[1] = a3[1] * b;
    o[2] = a3[2] * b;
    return o;
  }
  function maxVec3(o, a3, b) {
    o[0] = Math.max(a3[0], b[0]);
    o[1] = Math.max(a3[1], b[1]);
    o[2] = Math.max(a3[2], b[2]);
    return o;
  }
  function minVec3(o, a3, b) {
    o[0] = Math.min(a3[0], b[0]);
    o[1] = Math.min(a3[1], b[1]);
    o[2] = Math.min(a3[2], b[2]);
    return o;
  }
  function getAngle2(angle4) {
    if (angle4 === void 0) {
      return 0;
    } else if (angle4 > 360 || angle4 < -360) {
      return angle4 % 360;
    }
    return angle4;
  }
  function createVec3(x3, y3, z) {
    if (y3 === void 0) {
      y3 = 0;
    }
    if (z === void 0) {
      z = 0;
    }
    if (Array.isArray(x3) && x3.length === 3) {
      return vec3_exports.clone(x3);
    }
    if (is_number_default2(x3)) {
      return vec3_exports.fromValues(x3, y3, z);
    }
    return vec3_exports.fromValues(x3[0], x3[1] || y3, x3[2] || z);
  }
  function deg2rad(deg) {
    return deg * (Math.PI / 180);
  }
  function rad2deg(rad) {
    return rad * (180 / Math.PI);
  }
  function turn2deg(turn) {
    return 360 * turn;
  }
  function getEulerFromQuat(out, quat2) {
    var x3 = quat2[0];
    var y3 = quat2[1];
    var z = quat2[2];
    var w = quat2[3];
    var x22 = x3 * x3;
    var y22 = y3 * y3;
    var z2 = z * z;
    var w2 = w * w;
    var unit = x22 + y22 + z2 + w2;
    var test = x3 * w - y3 * z;
    if (test > 0.499995 * unit) {
      out[0] = Math.PI / 2;
      out[1] = 2 * Math.atan2(y3, x3);
      out[2] = 0;
    } else if (test < -0.499995 * unit) {
      out[0] = -Math.PI / 2;
      out[1] = 2 * Math.atan2(y3, x3);
      out[2] = 0;
    } else {
      out[0] = Math.asin(2 * (x3 * z - w * y3));
      out[1] = Math.atan2(2 * (x3 * w + y3 * z), 1 - 2 * (z2 + w2));
      out[2] = Math.atan2(2 * (x3 * y3 + z * w), 1 - 2 * (y22 + z2));
    }
    return out;
  }
  function getEulerFromMat4(out, m3) {
    var x3;
    var z;
    var halfPi3 = Math.PI * 0.5;
    var _a = __read(mat4_exports.getScaling(vec3_exports.create(), m3), 3), sx = _a[0], sy = _a[1], sz = _a[2];
    var y3 = Math.asin(-m3[2] / sx);
    if (y3 < halfPi3) {
      if (y3 > -halfPi3) {
        x3 = Math.atan2(m3[6] / sy, m3[10] / sz);
        z = Math.atan2(m3[1] / sx, m3[0] / sx);
      } else {
        z = 0;
        x3 = -Math.atan2(m3[4] / sy, m3[5] / sy);
      }
    } else {
      z = 0;
      x3 = Math.atan2(m3[4] / sy, m3[5] / sy);
    }
    out[0] = x3;
    out[1] = y3;
    out[2] = z;
    return out;
  }
  function getEuler(out, quat2) {
    if (quat2.length === 16) {
      return getEulerFromMat4(out, quat2);
    } else {
      return getEulerFromQuat(out, quat2);
    }
  }
  function fromRotationTranslationScale2(rotation, x3, y3, scaleX, scaleY) {
    var cos3 = Math.cos(rotation);
    var sin3 = Math.sin(rotation);
    return mat3_exports.fromValues(scaleX * cos3, scaleY * sin3, 0, -scaleX * sin3, scaleY * cos3, 0, x3, y3, 1);
  }
  function makePerspective(out, left2, right2, top, bottom, near, far, zero5) {
    if (zero5 === void 0) {
      zero5 = false;
    }
    var x3 = 2 * near / (right2 - left2);
    var y3 = 2 * near / (top - bottom);
    var a3 = (right2 + left2) / (right2 - left2);
    var b = (top + bottom) / (top - bottom);
    var c5;
    var d2;
    if (zero5) {
      c5 = -far / (far - near);
      d2 = -far * near / (far - near);
    } else {
      c5 = -(far + near) / (far - near);
      d2 = -2 * far * near / (far - near);
    }
    out[0] = x3;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = y3;
    out[6] = 0;
    out[7] = 0;
    out[8] = a3;
    out[9] = b;
    out[10] = c5;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = d2;
    out[15] = 0;
    return out;
  }
  function decompose(mat) {
    var row0x = mat[0];
    var row0y = mat[1];
    var row1x = mat[3];
    var row1y = mat[4];
    var scalingX = Math.sqrt(row0x * row0x + row0y * row0y);
    var scalingY = Math.sqrt(row1x * row1x + row1y * row1y);
    var determinant3 = row0x * row1y - row0y * row1x;
    if (determinant3 < 0) {
      if (row0x < row1y) {
        scalingX = -scalingX;
      } else {
        scalingY = -scalingY;
      }
    }
    if (scalingX) {
      row0x *= 1 / scalingX;
      row0y *= 1 / scalingX;
    }
    if (scalingY) {
      row1x *= 1 / scalingY;
      row1y *= 1 / scalingY;
    }
    var rotation = Math.atan2(row0y, row0x);
    var angle4 = rad2deg(rotation);
    return [mat[6], mat[7], scalingX, scalingY, angle4];
  }
  var tmp = mat4_exports.create();
  var perspectiveMatrix = mat4_exports.create();
  var tmpVec4 = vec4_exports.create();
  var row = [vec3_exports.create(), vec3_exports.create(), vec3_exports.create()];
  var pdum3 = vec3_exports.create();
  function decomposeMat4(matrix2, translation, scale9, skew, perspective2, quaternion) {
    if (!normalize6(tmp, matrix2))
      return false;
    mat4_exports.copy(perspectiveMatrix, tmp);
    perspectiveMatrix[3] = 0;
    perspectiveMatrix[7] = 0;
    perspectiveMatrix[11] = 0;
    perspectiveMatrix[15] = 1;
    if (Math.abs(mat4_exports.determinant(perspectiveMatrix)) < 1e-8)
      return false;
    var a03 = tmp[3], a13 = tmp[7], a23 = tmp[11], a30 = tmp[12], a31 = tmp[13], a32 = tmp[14], a33 = tmp[15];
    if (a03 !== 0 || a13 !== 0 || a23 !== 0) {
      tmpVec4[0] = a03;
      tmpVec4[1] = a13;
      tmpVec4[2] = a23;
      tmpVec4[3] = a33;
      var ret = mat4_exports.invert(perspectiveMatrix, perspectiveMatrix);
      if (!ret)
        return false;
      mat4_exports.transpose(perspectiveMatrix, perspectiveMatrix);
      vec4_exports.transformMat4(perspective2, tmpVec4, perspectiveMatrix);
    } else {
      perspective2[0] = perspective2[1] = perspective2[2] = 0;
      perspective2[3] = 1;
    }
    translation[0] = a30;
    translation[1] = a31;
    translation[2] = a32;
    mat3from4(row, tmp);
    scale9[0] = vec3_exports.length(row[0]);
    vec3_exports.normalize(row[0], row[0]);
    skew[0] = vec3_exports.dot(row[0], row[1]);
    combine2(row[1], row[1], row[0], 1, -skew[0]);
    scale9[1] = vec3_exports.length(row[1]);
    vec3_exports.normalize(row[1], row[1]);
    skew[0] /= scale9[1];
    skew[1] = vec3_exports.dot(row[0], row[2]);
    combine2(row[2], row[2], row[0], 1, -skew[1]);
    skew[2] = vec3_exports.dot(row[1], row[2]);
    combine2(row[2], row[2], row[1], 1, -skew[2]);
    scale9[2] = vec3_exports.length(row[2]);
    vec3_exports.normalize(row[2], row[2]);
    skew[1] /= scale9[2];
    skew[2] /= scale9[2];
    vec3_exports.cross(pdum3, row[1], row[2]);
    if (vec3_exports.dot(row[0], pdum3) < 0) {
      for (var i = 0; i < 3; i++) {
        scale9[i] *= -1;
        row[i][0] *= -1;
        row[i][1] *= -1;
        row[i][2] *= -1;
      }
    }
    quaternion[0] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] - row[1][1] - row[2][2], 0));
    quaternion[1] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] + row[1][1] - row[2][2], 0));
    quaternion[2] = 0.5 * Math.sqrt(Math.max(1 - row[0][0] - row[1][1] + row[2][2], 0));
    quaternion[3] = 0.5 * Math.sqrt(Math.max(1 + row[0][0] + row[1][1] + row[2][2], 0));
    if (row[2][1] > row[1][2])
      quaternion[0] = -quaternion[0];
    if (row[0][2] > row[2][0])
      quaternion[1] = -quaternion[1];
    if (row[1][0] > row[0][1])
      quaternion[2] = -quaternion[2];
    return true;
  }
  function normalize6(out, mat) {
    var m44 = mat[15];
    if (m44 === 0)
      return false;
    var scale9 = 1 / m44;
    for (var i = 0; i < 16; i++)
      out[i] = mat[i] * scale9;
    return true;
  }
  function mat3from4(out, mat4x4) {
    out[0][0] = mat4x4[0];
    out[0][1] = mat4x4[1];
    out[0][2] = mat4x4[2];
    out[1][0] = mat4x4[4];
    out[1][1] = mat4x4[5];
    out[1][2] = mat4x4[6];
    out[2][0] = mat4x4[8];
    out[2][1] = mat4x4[9];
    out[2][2] = mat4x4[10];
  }
  function combine2(out, a3, b, scale1, scale22) {
    out[0] = a3[0] * scale1 + b[0] * scale22;
    out[1] = a3[1] * scale1 + b[1] * scale22;
    out[2] = a3[2] * scale1 + b[2] * scale22;
  }
  var AABB = (
    /** @class */
    function() {
      function AABB2() {
        this.center = [0, 0, 0];
        this.halfExtents = [0, 0, 0];
        this.min = [0, 0, 0];
        this.max = [0, 0, 0];
      }
      AABB2.isEmpty = function(aabb) {
        return !aabb || aabb.halfExtents[0] === 0 && aabb.halfExtents[1] === 0 && aabb.halfExtents[2] === 0;
      };
      AABB2.prototype.update = function(center2, halfExtents) {
        copyVec3(this.center, center2);
        copyVec3(this.halfExtents, halfExtents);
        subVec3(this.min, this.center, this.halfExtents);
        addVec3(this.max, this.center, this.halfExtents);
      };
      AABB2.prototype.setMinMax = function(min10, max10) {
        addVec3(this.center, max10, min10);
        scaleVec3(this.center, this.center, 0.5);
        subVec3(this.halfExtents, max10, min10);
        scaleVec3(this.halfExtents, this.halfExtents, 0.5);
        copyVec3(this.min, min10);
        copyVec3(this.max, max10);
      };
      AABB2.prototype.getMin = function() {
        return this.min;
      };
      AABB2.prototype.getMax = function() {
        return this.max;
      };
      AABB2.prototype.add = function(aabb) {
        if (AABB2.isEmpty(aabb)) {
          return;
        }
        if (AABB2.isEmpty(this)) {
          this.setMinMax(aabb.getMin(), aabb.getMax());
          return;
        }
        var tc = this.center;
        var tcx = tc[0];
        var tcy = tc[1];
        var tcz = tc[2];
        var th = this.halfExtents;
        var thx = th[0];
        var thy = th[1];
        var thz = th[2];
        var tminx = tcx - thx;
        var tmaxx = tcx + thx;
        var tminy = tcy - thy;
        var tmaxy = tcy + thy;
        var tminz = tcz - thz;
        var tmaxz = tcz + thz;
        var oc = aabb.center;
        var ocx = oc[0];
        var ocy = oc[1];
        var ocz = oc[2];
        var oh = aabb.halfExtents;
        var ohx = oh[0];
        var ohy = oh[1];
        var ohz = oh[2];
        var ominx = ocx - ohx;
        var omaxx = ocx + ohx;
        var ominy = ocy - ohy;
        var omaxy = ocy + ohy;
        var ominz = ocz - ohz;
        var omaxz = ocz + ohz;
        if (ominx < tminx) {
          tminx = ominx;
        }
        if (omaxx > tmaxx) {
          tmaxx = omaxx;
        }
        if (ominy < tminy) {
          tminy = ominy;
        }
        if (omaxy > tmaxy) {
          tmaxy = omaxy;
        }
        if (ominz < tminz) {
          tminz = ominz;
        }
        if (omaxz > tmaxz) {
          tmaxz = omaxz;
        }
        tc[0] = (tminx + tmaxx) * 0.5;
        tc[1] = (tminy + tmaxy) * 0.5;
        tc[2] = (tminz + tmaxz) * 0.5;
        th[0] = (tmaxx - tminx) * 0.5;
        th[1] = (tmaxy - tminy) * 0.5;
        th[2] = (tmaxz - tminz) * 0.5;
        this.min[0] = tminx;
        this.min[1] = tminy;
        this.min[2] = tminz;
        this.max[0] = tmaxx;
        this.max[1] = tmaxy;
        this.max[2] = tmaxz;
      };
      AABB2.prototype.setFromTransformedAABB = function(aabb, m3) {
        var bc = this.center;
        var br = this.halfExtents;
        var ac = aabb.center;
        var ar = aabb.halfExtents;
        var mx0 = m3[0];
        var mx1 = m3[4];
        var mx2 = m3[8];
        var my0 = m3[1];
        var my1 = m3[5];
        var my2 = m3[9];
        var mz0 = m3[2];
        var mz1 = m3[6];
        var mz2 = m3[10];
        var mx0a = Math.abs(mx0);
        var mx1a = Math.abs(mx1);
        var mx2a = Math.abs(mx2);
        var my0a = Math.abs(my0);
        var my1a = Math.abs(my1);
        var my2a = Math.abs(my2);
        var mz0a = Math.abs(mz0);
        var mz1a = Math.abs(mz1);
        var mz2a = Math.abs(mz2);
        bc[0] = m3[12] + mx0 * ac[0] + mx1 * ac[1] + mx2 * ac[2];
        bc[1] = m3[13] + my0 * ac[0] + my1 * ac[1] + my2 * ac[2];
        bc[2] = m3[14] + mz0 * ac[0] + mz1 * ac[1] + mz2 * ac[2];
        br[0] = mx0a * ar[0] + mx1a * ar[1] + mx2a * ar[2];
        br[1] = my0a * ar[0] + my1a * ar[1] + my2a * ar[2];
        br[2] = mz0a * ar[0] + mz1a * ar[1] + mz2a * ar[2];
        subVec3(this.min, bc, br);
        addVec3(this.max, bc, br);
      };
      AABB2.prototype.intersects = function(aabb) {
        var aMax = this.getMax();
        var aMin = this.getMin();
        var bMax = aabb.getMax();
        var bMin = aabb.getMin();
        return aMin[0] <= bMax[0] && aMax[0] >= bMin[0] && aMin[1] <= bMax[1] && aMax[1] >= bMin[1] && aMin[2] <= bMax[2] && aMax[2] >= bMin[2];
      };
      AABB2.prototype.intersection = function(aabb) {
        if (!this.intersects(aabb)) {
          return null;
        }
        var intersection = new AABB2();
        var min10 = maxVec3([0, 0, 0], this.getMin(), aabb.getMin());
        var max10 = minVec3([0, 0, 0], this.getMax(), aabb.getMax());
        intersection.setMinMax(min10, max10);
        return intersection;
      };
      AABB2.prototype.getNegativeFarPoint = function(plane) {
        if (plane.pnVertexFlag === 273) {
          return copyVec3([0, 0, 0], this.min);
        } else if (plane.pnVertexFlag === 272) {
          return [this.min[0], this.min[1], this.max[2]];
        } else if (plane.pnVertexFlag === 257) {
          return [this.min[0], this.max[1], this.min[2]];
        } else if (plane.pnVertexFlag === 256) {
          return [this.min[0], this.max[1], this.max[2]];
        } else if (plane.pnVertexFlag === 17) {
          return [this.max[0], this.min[1], this.min[2]];
        } else if (plane.pnVertexFlag === 16) {
          return [this.max[0], this.min[1], this.max[2]];
        } else if (plane.pnVertexFlag === 1) {
          return [this.max[0], this.max[1], this.min[2]];
        } else {
          return [this.max[0], this.max[1], this.max[2]];
        }
      };
      AABB2.prototype.getPositiveFarPoint = function(plane) {
        if (plane.pnVertexFlag === 273) {
          return copyVec3([0, 0, 0], this.max);
        } else if (plane.pnVertexFlag === 272) {
          return [this.max[0], this.max[1], this.min[2]];
        } else if (plane.pnVertexFlag === 257) {
          return [this.max[0], this.min[1], this.max[2]];
        } else if (plane.pnVertexFlag === 256) {
          return [this.max[0], this.min[1], this.min[2]];
        } else if (plane.pnVertexFlag === 17) {
          return [this.min[0], this.max[1], this.max[2]];
        } else if (plane.pnVertexFlag === 16) {
          return [this.min[0], this.max[1], this.min[2]];
        } else if (plane.pnVertexFlag === 1) {
          return [this.min[0], this.min[1], this.max[2]];
        } else {
          return [this.min[0], this.min[1], this.min[2]];
        }
      };
      return AABB2;
    }()
  );
  var Plane = (
    /** @class */
    function() {
      function Plane2(distance8, normal) {
        this.distance = distance8 || 0;
        this.normal = normal || vec3_exports.fromValues(0, 1, 0);
        this.updatePNVertexFlag();
      }
      Plane2.prototype.updatePNVertexFlag = function() {
        this.pnVertexFlag = (Number(this.normal[0] >= 0) << 8) + (Number(this.normal[1] >= 0) << 4) + Number(this.normal[2] >= 0);
      };
      Plane2.prototype.distanceToPoint = function(point6) {
        return vec3_exports.dot(point6, this.normal) - this.distance;
      };
      Plane2.prototype.normalize = function() {
        var invLen = 1 / vec3_exports.len(this.normal);
        vec3_exports.scale(this.normal, this.normal, invLen);
        this.distance *= invLen;
      };
      Plane2.prototype.intersectsLine = function(start2, end, point6) {
        var d0 = this.distanceToPoint(start2);
        var d1 = this.distanceToPoint(end);
        var t = d0 / (d0 - d1);
        var intersects2 = t >= 0 && t <= 1;
        if (intersects2 && point6) {
          vec3_exports.lerp(point6, start2, end, t);
        }
        return intersects2;
      };
      return Plane2;
    }()
  );
  var Mask;
  (function(Mask2) {
    Mask2[Mask2["OUTSIDE"] = 4294967295] = "OUTSIDE";
    Mask2[Mask2["INSIDE"] = 0] = "INSIDE";
    Mask2[Mask2["INDETERMINATE"] = 2147483647] = "INDETERMINATE";
  })(Mask || (Mask = {}));
  var Frustum = (
    /** @class */
    function() {
      function Frustum2(planes) {
        this.planes = [];
        if (planes) {
          this.planes = planes;
        } else {
          for (var i = 0; i < 6; i++) {
            this.planes.push(new Plane());
          }
        }
      }
      Frustum2.prototype.extractFromVPMatrix = function(projectionMatrix) {
        var _a = __read(projectionMatrix, 16), m0 = _a[0], m1 = _a[1], m22 = _a[2], m3 = _a[3], m4 = _a[4], m5 = _a[5], m6 = _a[6], m7 = _a[7], m8 = _a[8], m9 = _a[9], m10 = _a[10], m11 = _a[11], m12 = _a[12], m13 = _a[13], m14 = _a[14], m15 = _a[15];
        vec3_exports.set(this.planes[0].normal, m3 - m0, m7 - m4, m11 - m8);
        this.planes[0].distance = m15 - m12;
        vec3_exports.set(this.planes[1].normal, m3 + m0, m7 + m4, m11 + m8);
        this.planes[1].distance = m15 + m12;
        vec3_exports.set(this.planes[2].normal, m3 + m1, m7 + m5, m11 + m9);
        this.planes[2].distance = m15 + m13;
        vec3_exports.set(this.planes[3].normal, m3 - m1, m7 - m5, m11 - m9);
        this.planes[3].distance = m15 - m13;
        vec3_exports.set(this.planes[4].normal, m3 - m22, m7 - m6, m11 - m10);
        this.planes[4].distance = m15 - m14;
        vec3_exports.set(this.planes[5].normal, m3 + m22, m7 + m6, m11 + m10);
        this.planes[5].distance = m15 + m14;
        this.planes.forEach(function(plane) {
          plane.normalize();
          plane.updatePNVertexFlag();
        });
      };
      return Frustum2;
    }()
  );
  var Point2 = (
    /** @class */
    function() {
      function Point6(x3, y3) {
        if (x3 === void 0) {
          x3 = 0;
        }
        if (y3 === void 0) {
          y3 = 0;
        }
        this.x = 0;
        this.y = 0;
        this.x = x3;
        this.y = y3;
      }
      Point6.prototype.clone = function() {
        return new Point6(this.x, this.y);
      };
      Point6.prototype.copyFrom = function(p2) {
        this.x = p2.x;
        this.y = p2.y;
      };
      return Point6;
    }()
  );
  var Rectangle = (
    /** @class */
    function() {
      function Rectangle2(x3, y3, width, height) {
        this.x = x3;
        this.y = y3;
        this.width = width;
        this.height = height;
        this.left = x3;
        this.right = x3 + width;
        this.top = y3;
        this.bottom = y3 + height;
      }
      Rectangle2.prototype.toJSON = function() {
      };
      return Rectangle2;
    }()
  );
  var ERROR_MSG_METHOD_NOT_IMPLEMENTED = "Method not implemented.";
  var ERROR_MSG_USE_DOCUMENT_ELEMENT = "Use document.documentElement instead.";
  var ERROR_MSG_APPEND_DESTROYED_ELEMENT = "Cannot append a destroyed element.";
  var CameraType;
  (function(CameraType2) {
    CameraType2[CameraType2["ORBITING"] = 0] = "ORBITING";
    CameraType2[CameraType2["EXPLORING"] = 1] = "EXPLORING";
    CameraType2[CameraType2["TRACKING"] = 2] = "TRACKING";
  })(CameraType || (CameraType = {}));
  var CameraTrackingMode;
  (function(CameraTrackingMode2) {
    CameraTrackingMode2[CameraTrackingMode2["DEFAULT"] = 0] = "DEFAULT";
    CameraTrackingMode2[CameraTrackingMode2["ROTATIONAL"] = 1] = "ROTATIONAL";
    CameraTrackingMode2[CameraTrackingMode2["TRANSLATIONAL"] = 2] = "TRANSLATIONAL";
    CameraTrackingMode2[CameraTrackingMode2["CINEMATIC"] = 3] = "CINEMATIC";
  })(CameraTrackingMode || (CameraTrackingMode = {}));
  var CameraProjectionMode;
  (function(CameraProjectionMode2) {
    CameraProjectionMode2[CameraProjectionMode2["ORTHOGRAPHIC"] = 0] = "ORTHOGRAPHIC";
    CameraProjectionMode2[CameraProjectionMode2["PERSPECTIVE"] = 1] = "PERSPECTIVE";
  })(CameraProjectionMode || (CameraProjectionMode = {}));
  var CameraEvent = {
    UPDATED: "updated"
  };
  var MIN_DISTANCE = 2e-4;
  var Camera = (
    /** @class */
    function() {
      function Camera2() {
        this.clipSpaceNearZ = ClipSpaceNearZ.NEGATIVE_ONE;
        this.eventEmitter = new eventemitter3_default();
        this.matrix = mat4_exports.create();
        this.right = vec3_exports.fromValues(1, 0, 0);
        this.up = vec3_exports.fromValues(0, 1, 0);
        this.forward = vec3_exports.fromValues(0, 0, 1);
        this.position = vec3_exports.fromValues(0, 0, 1);
        this.focalPoint = vec3_exports.fromValues(0, 0, 0);
        this.distanceVector = vec3_exports.fromValues(0, 0, -1);
        this.distance = 1;
        this.azimuth = 0;
        this.elevation = 0;
        this.roll = 0;
        this.relAzimuth = 0;
        this.relElevation = 0;
        this.relRoll = 0;
        this.dollyingStep = 0;
        this.maxDistance = Infinity;
        this.minDistance = -Infinity;
        this.zoom = 1;
        this.rotateWorld = false;
        this.fov = 30;
        this.near = 0.1;
        this.far = 1e3;
        this.aspect = 1;
        this.projectionMatrix = mat4_exports.create();
        this.projectionMatrixInverse = mat4_exports.create();
        this.jitteredProjectionMatrix = void 0;
        this.enableUpdate = true;
        this.type = CameraType.EXPLORING;
        this.trackingMode = CameraTrackingMode.DEFAULT;
        this.projectionMode = CameraProjectionMode.PERSPECTIVE;
        this.frustum = new Frustum();
        this.orthoMatrix = mat4_exports.create();
      }
      Camera2.prototype.isOrtho = function() {
        return this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC;
      };
      Camera2.prototype.getProjectionMode = function() {
        return this.projectionMode;
      };
      Camera2.prototype.getPerspective = function() {
        return this.jitteredProjectionMatrix || this.projectionMatrix;
      };
      Camera2.prototype.getPerspectiveInverse = function() {
        return this.projectionMatrixInverse;
      };
      Camera2.prototype.getFrustum = function() {
        return this.frustum;
      };
      Camera2.prototype.getPosition = function() {
        return this.position;
      };
      Camera2.prototype.getFocalPoint = function() {
        return this.focalPoint;
      };
      Camera2.prototype.getDollyingStep = function() {
        return this.dollyingStep;
      };
      Camera2.prototype.getNear = function() {
        return this.near;
      };
      Camera2.prototype.getFar = function() {
        return this.far;
      };
      Camera2.prototype.getZoom = function() {
        return this.zoom;
      };
      Camera2.prototype.getOrthoMatrix = function() {
        return this.orthoMatrix;
      };
      Camera2.prototype.getView = function() {
        return this.view;
      };
      Camera2.prototype.setEnableUpdate = function(enabled) {
        this.enableUpdate = enabled;
      };
      Camera2.prototype.setType = function(type, trackingMode) {
        this.type = type;
        if (this.type === CameraType.EXPLORING) {
          this.setWorldRotation(true);
        } else {
          this.setWorldRotation(false);
        }
        this._getAngles();
        if (this.type === CameraType.TRACKING && trackingMode !== void 0) {
          this.setTrackingMode(trackingMode);
        }
        return this;
      };
      Camera2.prototype.setProjectionMode = function(projectionMode) {
        this.projectionMode = projectionMode;
        return this;
      };
      Camera2.prototype.setTrackingMode = function(trackingMode) {
        if (this.type !== CameraType.TRACKING) {
          throw new Error("Impossible to set a tracking mode if the camera is not of tracking type");
        }
        this.trackingMode = trackingMode;
        return this;
      };
      Camera2.prototype.setWorldRotation = function(flag) {
        this.rotateWorld = flag;
        this._getAngles();
        return this;
      };
      Camera2.prototype.getViewTransform = function() {
        return mat4_exports.invert(mat4_exports.create(), this.matrix);
      };
      Camera2.prototype.getWorldTransform = function() {
        return this.matrix;
      };
      Camera2.prototype.jitterProjectionMatrix = function(x3, y3) {
        var translation = mat4_exports.fromTranslation(mat4_exports.create(), [x3, y3, 0]);
        this.jitteredProjectionMatrix = mat4_exports.multiply(mat4_exports.create(), translation, this.projectionMatrix);
      };
      Camera2.prototype.clearJitterProjectionMatrix = function() {
        this.jitteredProjectionMatrix = void 0;
      };
      Camera2.prototype.setMatrix = function(matrix2) {
        this.matrix = matrix2;
        this._update();
        return this;
      };
      Camera2.prototype.setProjectionMatrix = function(matrix2) {
        this.projectionMatrix = matrix2;
      };
      Camera2.prototype.setFov = function(fov) {
        this.setPerspective(this.near, this.far, fov, this.aspect);
        return this;
      };
      Camera2.prototype.setAspect = function(aspect) {
        this.setPerspective(this.near, this.far, this.fov, aspect);
        return this;
      };
      Camera2.prototype.setNear = function(near) {
        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(near, this.far, this.fov, this.aspect);
        } else {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, near, this.far);
        }
        return this;
      };
      Camera2.prototype.setFar = function(far) {
        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(this.near, far, this.fov, this.aspect);
        } else {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, far);
        }
        return this;
      };
      Camera2.prototype.setViewOffset = function(fullWidth, fullHeight, x3, y3, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === void 0) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x3;
        this.view.offsetY = y3;
        this.view.width = width;
        this.view.height = height;
        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(this.near, this.far, this.fov, this.aspect);
        } else {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
        }
        return this;
      };
      Camera2.prototype.clearViewOffset = function() {
        if (this.view !== void 0) {
          this.view.enabled = false;
        }
        if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(this.near, this.far, this.fov, this.aspect);
        } else {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
        }
        return this;
      };
      Camera2.prototype.setZoom = function(zoom) {
        this.zoom = zoom;
        if (this.projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
          this.setOrthographic(this.left, this.rright, this.top, this.bottom, this.near, this.far);
        } else if (this.projectionMode === CameraProjectionMode.PERSPECTIVE) {
          this.setPerspective(this.near, this.far, this.fov, this.aspect);
        }
        return this;
      };
      Camera2.prototype.setZoomByViewportPoint = function(zoom, viewportPoint) {
        var _a = this.canvas.viewport2Canvas({
          x: viewportPoint[0],
          y: viewportPoint[1]
        }), ox = _a.x, oy = _a.y;
        var roll = this.roll;
        this.rotate(0, 0, -roll);
        this.setPosition(ox, oy);
        this.setFocalPoint(ox, oy);
        this.setZoom(zoom);
        this.rotate(0, 0, roll);
        var _b = this.canvas.viewport2Canvas({
          x: viewportPoint[0],
          y: viewportPoint[1]
        }), cx = _b.x, cy = _b.y;
        var dvec = vec3_exports.fromValues(cx - ox, cy - oy, 0);
        var dx = vec3_exports.dot(dvec, this.right) / vec3_exports.length(this.right);
        var dy = vec3_exports.dot(dvec, this.up) / vec3_exports.length(this.up);
        var _c = __read(this.getPosition(), 2), px = _c[0], py = _c[1];
        var _d = __read(this.getFocalPoint(), 2), fx = _d[0], fy = _d[1];
        this.setPosition(px - dx, py - dy);
        this.setFocalPoint(fx - dx, fy - dy);
        return this;
      };
      Camera2.prototype.setPerspective = function(near, far, fov, aspect) {
        var _a;
        this.projectionMode = CameraProjectionMode.PERSPECTIVE;
        this.fov = fov;
        this.near = near;
        this.far = far;
        this.aspect = aspect;
        var top = this.near * Math.tan(deg2rad(0.5 * this.fov)) / this.zoom;
        var height = 2 * top;
        var width = this.aspect * height;
        var left2 = -0.5 * width;
        if ((_a = this.view) === null || _a === void 0 ? void 0 : _a.enabled) {
          var fullWidth = this.view.fullWidth;
          var fullHeight = this.view.fullHeight;
          left2 += this.view.offsetX * width / fullWidth;
          top -= this.view.offsetY * height / fullHeight;
          width *= this.view.width / fullWidth;
          height *= this.view.height / fullHeight;
        }
        makePerspective(this.projectionMatrix, left2, left2 + width, top - height, top, near, this.far, this.clipSpaceNearZ === ClipSpaceNearZ.ZERO);
        mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
        this.triggerUpdate();
        return this;
      };
      Camera2.prototype.setOrthographic = function(l2, r, t, b, near, far) {
        var _a;
        this.projectionMode = CameraProjectionMode.ORTHOGRAPHIC;
        this.rright = r;
        this.left = l2;
        this.top = t;
        this.bottom = b;
        this.near = near;
        this.far = far;
        var dx = (this.rright - this.left) / (2 * this.zoom);
        var dy = (this.top - this.bottom) / (2 * this.zoom);
        var cx = (this.rright + this.left) / 2;
        var cy = (this.top + this.bottom) / 2;
        var left2 = cx - dx;
        var right2 = cx + dx;
        var top = cy + dy;
        var bottom = cy - dy;
        if ((_a = this.view) === null || _a === void 0 ? void 0 : _a.enabled) {
          var scaleW = (this.rright - this.left) / this.view.fullWidth / this.zoom;
          var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          left2 += scaleW * this.view.offsetX;
          right2 = left2 + scaleW * this.view.width;
          top -= scaleH * this.view.offsetY;
          bottom = top - scaleH * this.view.height;
        }
        if (this.clipSpaceNearZ === ClipSpaceNearZ.NEGATIVE_ONE) {
          mat4_exports.ortho(this.projectionMatrix, left2, right2, top, bottom, near, far);
        } else {
          mat4_exports.orthoZO(this.projectionMatrix, left2, right2, top, bottom, near, far);
        }
        mat4_exports.invert(this.projectionMatrixInverse, this.projectionMatrix);
        this._getOrthoMatrix();
        this.triggerUpdate();
        return this;
      };
      Camera2.prototype.setPosition = function(x3, y3, z) {
        if (y3 === void 0) {
          y3 = this.position[1];
        }
        if (z === void 0) {
          z = this.position[2];
        }
        var position = createVec3(x3, y3, z);
        this._setPosition(position);
        this.setFocalPoint(this.focalPoint);
        this.triggerUpdate();
        return this;
      };
      Camera2.prototype.setFocalPoint = function(x3, y3, z) {
        if (y3 === void 0) {
          y3 = this.focalPoint[1];
        }
        if (z === void 0) {
          z = this.focalPoint[2];
        }
        var up = vec3_exports.fromValues(0, 1, 0);
        this.focalPoint = createVec3(x3, y3, z);
        if (this.trackingMode === CameraTrackingMode.CINEMATIC) {
          var d2 = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
          x3 = d2[0];
          y3 = d2[1];
          z = d2[2];
          var r = vec3_exports.length(d2);
          var el = rad2deg(Math.asin(y3 / r));
          var az = 90 + rad2deg(Math.atan2(z, x3));
          var m3 = mat4_exports.create();
          mat4_exports.rotateY(m3, m3, deg2rad(az));
          mat4_exports.rotateX(m3, m3, deg2rad(el));
          up = vec3_exports.transformMat4(vec3_exports.create(), [0, 1, 0], m3);
        }
        mat4_exports.invert(this.matrix, mat4_exports.lookAt(mat4_exports.create(), this.position, this.focalPoint, up));
        this._getAxes();
        this._getDistance();
        this._getAngles();
        this.triggerUpdate();
        return this;
      };
      Camera2.prototype.getDistance = function() {
        return this.distance;
      };
      Camera2.prototype.getDistanceVector = function() {
        return this.distanceVector;
      };
      Camera2.prototype.setDistance = function(d2) {
        if (this.distance === d2 || d2 < 0) {
          return this;
        }
        this.distance = d2;
        if (this.distance < MIN_DISTANCE) {
          this.distance = MIN_DISTANCE;
        }
        this.dollyingStep = this.distance / 100;
        var pos = vec3_exports.create();
        d2 = this.distance;
        var n2 = this.forward;
        var f = this.focalPoint;
        pos[0] = d2 * n2[0] + f[0];
        pos[1] = d2 * n2[1] + f[1];
        pos[2] = d2 * n2[2] + f[2];
        this._setPosition(pos);
        this.triggerUpdate();
        return this;
      };
      Camera2.prototype.setMaxDistance = function(d2) {
        this.maxDistance = d2;
        return this;
      };
      Camera2.prototype.setMinDistance = function(d2) {
        this.minDistance = d2;
        return this;
      };
      Camera2.prototype.setAzimuth = function(az) {
        this.azimuth = getAngle2(az);
        this.computeMatrix();
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this.triggerUpdate();
        return this;
      };
      Camera2.prototype.getAzimuth = function() {
        return this.azimuth;
      };
      Camera2.prototype.setElevation = function(el) {
        this.elevation = getAngle2(el);
        this.computeMatrix();
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this.triggerUpdate();
        return this;
      };
      Camera2.prototype.getElevation = function() {
        return this.elevation;
      };
      Camera2.prototype.setRoll = function(angle4) {
        this.roll = getAngle2(angle4);
        this.computeMatrix();
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this.triggerUpdate();
        return this;
      };
      Camera2.prototype.getRoll = function() {
        return this.roll;
      };
      Camera2.prototype._update = function() {
        this._getAxes();
        this._getPosition();
        this._getDistance();
        this._getAngles();
        this._getOrthoMatrix();
        this.triggerUpdate();
      };
      Camera2.prototype.computeMatrix = function() {
        var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad(this.roll));
        mat4_exports.identity(this.matrix);
        var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.elevation));
        var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad((this.rotateWorld && this.type !== CameraType.TRACKING || this.type === CameraType.TRACKING ? 1 : -1) * this.azimuth));
        var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
        rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
        var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          mat4_exports.translate(this.matrix, this.matrix, this.focalPoint);
          mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
          mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
        } else if (this.type === CameraType.TRACKING) {
          mat4_exports.translate(this.matrix, this.matrix, this.position);
          mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
        }
      };
      Camera2.prototype._setPosition = function(x3, y3, z) {
        this.position = createVec3(x3, y3, z);
        var m3 = this.matrix;
        m3[12] = this.position[0];
        m3[13] = this.position[1];
        m3[14] = this.position[2];
        m3[15] = 1;
        this._getOrthoMatrix();
      };
      Camera2.prototype._getAxes = function() {
        vec3_exports.copy(this.right, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [1, 0, 0, 0], this.matrix)));
        vec3_exports.copy(this.up, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 1, 0, 0], this.matrix)));
        vec3_exports.copy(this.forward, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 1, 0], this.matrix)));
        vec3_exports.normalize(this.right, this.right);
        vec3_exports.normalize(this.up, this.up);
        vec3_exports.normalize(this.forward, this.forward);
      };
      Camera2.prototype._getAngles = function() {
        var x3 = this.distanceVector[0];
        var y3 = this.distanceVector[1];
        var z = this.distanceVector[2];
        var r = vec3_exports.length(this.distanceVector);
        if (r === 0) {
          this.elevation = 0;
          this.azimuth = 0;
          return;
        }
        if (this.type === CameraType.TRACKING) {
          this.elevation = rad2deg(Math.asin(y3 / r));
          this.azimuth = rad2deg(Math.atan2(-x3, -z));
        } else {
          if (this.rotateWorld) {
            this.elevation = rad2deg(Math.asin(y3 / r));
            this.azimuth = rad2deg(Math.atan2(-x3, -z));
          } else {
            this.elevation = -rad2deg(Math.asin(y3 / r));
            this.azimuth = -rad2deg(Math.atan2(-x3, -z));
          }
        }
      };
      Camera2.prototype._getPosition = function() {
        vec3_exports.copy(this.position, createVec3(vec4_exports.transformMat4(vec4_exports.create(), [0, 0, 0, 1], this.matrix)));
        this._getDistance();
      };
      Camera2.prototype._getFocalPoint = function() {
        vec3_exports.transformMat3(this.distanceVector, [0, 0, -this.distance], mat3_exports.fromMat4(mat3_exports.create(), this.matrix));
        vec3_exports.add(this.focalPoint, this.position, this.distanceVector);
        this._getDistance();
      };
      Camera2.prototype._getDistance = function() {
        this.distanceVector = vec3_exports.subtract(vec3_exports.create(), this.focalPoint, this.position);
        this.distance = vec3_exports.length(this.distanceVector);
        this.dollyingStep = this.distance / 100;
      };
      Camera2.prototype._getOrthoMatrix = function() {
        if (this.projectionMode !== CameraProjectionMode.ORTHOGRAPHIC) {
          return;
        }
        var position = this.position;
        var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], -this.roll * Math.PI / 180);
        mat4_exports.fromRotationTranslationScaleOrigin(this.orthoMatrix, rotZ, vec3_exports.fromValues((this.rright - this.left) / 2 - position[0], (this.top - this.bottom) / 2 - position[1], 0), vec3_exports.fromValues(this.zoom, this.zoom, 1), position);
      };
      Camera2.prototype.triggerUpdate = function() {
        if (this.enableUpdate) {
          var viewMatrix = this.getViewTransform();
          var vpMatrix = mat4_exports.multiply(mat4_exports.create(), this.getPerspective(), viewMatrix);
          this.getFrustum().extractFromVPMatrix(vpMatrix);
          this.eventEmitter.emit(CameraEvent.UPDATED);
        }
      };
      Camera2.prototype.rotate = function(azimuth, elevation, roll) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Camera2.prototype.pan = function(tx, ty) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Camera2.prototype.dolly = function(value2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Camera2.prototype.createLandmark = function(name2, params) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Camera2.prototype.gotoLandmark = function(name2, options) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Camera2.prototype.cancelLandmarkAnimation = function() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      return Camera2;
    }()
  );
  function memoize(func, resolver) {
    if (typeof func !== "function" || resolver != null && typeof resolver !== "function") {
      throw new TypeError("Expected a function");
    }
    var memoized = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var key = resolver ? resolver.apply(this, args) : args[0];
      var cache3 = memoized.cache;
      if (cache3.has(key)) {
        return cache3.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache3.set(key, result) || cache3;
      return result;
    };
    memoized.cache = new (memoize.Cache || Map)();
    return memoized;
  }
  memoize.Cache = Map;
  var UnitType;
  (function(UnitType2) {
    UnitType2[UnitType2["kUnknown"] = 0] = "kUnknown";
    UnitType2[UnitType2["kNumber"] = 1] = "kNumber";
    UnitType2[UnitType2["kPercentage"] = 2] = "kPercentage";
    UnitType2[UnitType2["kEms"] = 3] = "kEms";
    UnitType2[UnitType2["kPixels"] = 4] = "kPixels";
    UnitType2[UnitType2["kRems"] = 5] = "kRems";
    UnitType2[UnitType2["kDegrees"] = 6] = "kDegrees";
    UnitType2[UnitType2["kRadians"] = 7] = "kRadians";
    UnitType2[UnitType2["kGradians"] = 8] = "kGradians";
    UnitType2[UnitType2["kTurns"] = 9] = "kTurns";
    UnitType2[UnitType2["kMilliseconds"] = 10] = "kMilliseconds";
    UnitType2[UnitType2["kSeconds"] = 11] = "kSeconds";
    UnitType2[UnitType2["kInteger"] = 12] = "kInteger";
  })(UnitType || (UnitType = {}));
  var UnitCategory;
  (function(UnitCategory2) {
    UnitCategory2[UnitCategory2["kUNumber"] = 0] = "kUNumber";
    UnitCategory2[UnitCategory2["kUPercent"] = 1] = "kUPercent";
    UnitCategory2[UnitCategory2["kULength"] = 2] = "kULength";
    UnitCategory2[UnitCategory2["kUAngle"] = 3] = "kUAngle";
    UnitCategory2[UnitCategory2["kUTime"] = 4] = "kUTime";
    UnitCategory2[UnitCategory2["kUOther"] = 5] = "kUOther";
  })(UnitCategory || (UnitCategory = {}));
  var ValueRange;
  (function(ValueRange2) {
    ValueRange2[ValueRange2["kAll"] = 0] = "kAll";
    ValueRange2[ValueRange2["kNonNegative"] = 1] = "kNonNegative";
    ValueRange2[ValueRange2["kInteger"] = 2] = "kInteger";
    ValueRange2[ValueRange2["kNonNegativeInteger"] = 3] = "kNonNegativeInteger";
    ValueRange2[ValueRange2["kPositiveInteger"] = 4] = "kPositiveInteger";
  })(ValueRange || (ValueRange = {}));
  var Nested;
  (function(Nested2) {
    Nested2[Nested2["kYes"] = 0] = "kYes";
    Nested2[Nested2["kNo"] = 1] = "kNo";
  })(Nested || (Nested = {}));
  var ParenLess;
  (function(ParenLess2) {
    ParenLess2[ParenLess2["kYes"] = 0] = "kYes";
    ParenLess2[ParenLess2["kNo"] = 1] = "kNo";
  })(ParenLess || (ParenLess = {}));
  var data = [
    {
      name: "em",
      unit_type: UnitType.kEms
    },
    // {
    //   name: 'ex',
    //   unit_type: UnitType.kExs,
    // },
    {
      name: "px",
      unit_type: UnitType.kPixels
    },
    // {
    //   name: "cm",
    //   unit_type: UnitType.kCentimeters,
    // },
    // {
    //   name: "mm",
    //   unit_type: UnitType.kMillimeters,
    // },
    // {
    //   name: "q",
    //   unit_type: UnitType.kQuarterMillimeters,
    // },
    // {
    //   name: "in",
    //   unit_type: UnitType.kInches,
    // },
    // {
    //   name: "pt",
    //   unit_type: UnitType.kPoints,
    // },
    // {
    //   name: "pc",
    //   unit_type: UnitType.kPicas,
    // },
    {
      name: "deg",
      unit_type: UnitType.kDegrees
    },
    {
      name: "rad",
      unit_type: UnitType.kRadians
    },
    {
      name: "grad",
      unit_type: UnitType.kGradians
    },
    {
      name: "ms",
      unit_type: UnitType.kMilliseconds
    },
    {
      name: "s",
      unit_type: UnitType.kSeconds
    },
    // {
    //   name: "hz",
    //   unit_type: UnitType.kHertz,
    // },
    // {
    //   name: "khz",
    //   unit_type: UnitType.kKilohertz,
    // },
    // {
    //   name: "dpi",
    //   unit_type: "kDotsPerInch",
    // },
    // {
    //   name: "dpcm",
    //   unit_type: "kDotsPerCentimeter",
    // },
    // {
    //   name: "dppx",
    //   unit_type: "kDotsPerPixel",
    // },
    // {
    //   name: "x",
    //   unit_type: "kDotsPerPixel",
    // },
    // {
    //   name: "vw",
    //   unit_type: "kViewportWidth",
    // },
    // {
    //   name: "vh",
    //   unit_type: "kViewportHeight",
    // },
    // {
    //   name: "vi",
    //   unit_type: "kViewportInlineSize",
    // },
    // {
    //   name: "vb",
    //   unit_type: "kViewportBlockSize",
    // },
    // {
    //   name: "vmin",
    //   unit_type: UnitType.kViewportMin,
    // },
    // {
    //   name: "vmax",
    //   unit_type: UnitType.kViewportMax,
    // },
    // {
    //   name: "svw",
    //   unit_type: "kSmallViewportWidth",
    // },
    // {
    //   name: "svh",
    //   unit_type: "kSmallViewportHeight",
    // },
    // {
    //   name: "svi",
    //   unit_type: "kSmallViewportInlineSize",
    // },
    // {
    //   name: "svb",
    //   unit_type: "kSmallViewportBlockSize",
    // },
    // {
    //   name: "svmin",
    //   unit_type: "kSmallViewportMin",
    // },
    // {
    //   name: "svmax",
    //   unit_type: "kSmallViewportMax",
    // },
    // {
    //   name: "lvw",
    //   unit_type: "kLargeViewportWidth",
    // },
    // {
    //   name: "lvh",
    //   unit_type: "kLargeViewportHeight",
    // },
    // {
    //   name: "lvi",
    //   unit_type: "kLargeViewportInlineSize",
    // },
    // {
    //   name: "lvb",
    //   unit_type: "kLargeViewportBlockSize",
    // },
    // {
    //   name: "lvmin",
    //   unit_type: UnitType.kLargeViewportMin,
    // },
    // {
    //   name: "lvmax",
    //   unit_type: UnitType.kLargeViewportMax,
    // },
    // {
    //   name: "dvw",
    //   unit_type: UnitType.kDynamicViewportWidth,
    // },
    // {
    //   name: "dvh",
    //   unit_type: UnitType.kDynamicViewportHeight,
    // },
    // {
    //   name: "dvi",
    //   unit_type: UnitType.kDynamicViewportInlineSize,
    // },
    // {
    //   name: "dvb",
    //   unit_type: UnitType.kDynamicViewportBlockSize,
    // },
    // {
    //   name: "dvmin",
    //   unit_type: UnitType.kDynamicViewportMin,
    // },
    // {
    //   name: "dvmax",
    //   unit_type: UnitType.kDynamicViewportMax,
    // },
    // {
    //   name: "cqw",
    //   unit_type: UnitType.kContainerWidth,
    // },
    // {
    //   name: "cqh",
    //   unit_type: UnitType.kContainerHeight,
    // },
    // {
    //   name: "cqi",
    //   unit_type: UnitType.kContainerInlineSize,
    // },
    // {
    //   name: "cqb",
    //   unit_type: UnitType.kContainerBlockSize,
    // },
    // {
    //   name: "cqmin",
    //   unit_type: UnitType.kContainerMin,
    // },
    // {
    //   name: "cqmax",
    //   unit_type: UnitType.kContainerMax,
    // },
    {
      name: "rem",
      unit_type: UnitType.kRems
    },
    // {
    //   name: 'fr',
    //   unit_type: UnitType.kFraction,
    // },
    {
      name: "turn",
      unit_type: UnitType.kTurns
    }
    // {
    //   name: 'ch',
    //   unit_type: UnitType.kChs,
    // },
    // {
    //   name: '__qem',
    //   unit_type: UnitType.kQuirkyEms,
    // },
  ];
  var CSSStyleValueType;
  (function(CSSStyleValueType2) {
    CSSStyleValueType2[CSSStyleValueType2["kUnknownType"] = 0] = "kUnknownType";
    CSSStyleValueType2[CSSStyleValueType2["kUnparsedType"] = 1] = "kUnparsedType";
    CSSStyleValueType2[CSSStyleValueType2["kKeywordType"] = 2] = "kKeywordType";
    CSSStyleValueType2[CSSStyleValueType2["kUnitType"] = 3] = "kUnitType";
    CSSStyleValueType2[CSSStyleValueType2["kSumType"] = 4] = "kSumType";
    CSSStyleValueType2[CSSStyleValueType2["kProductType"] = 5] = "kProductType";
    CSSStyleValueType2[CSSStyleValueType2["kNegateType"] = 6] = "kNegateType";
    CSSStyleValueType2[CSSStyleValueType2["kInvertType"] = 7] = "kInvertType";
    CSSStyleValueType2[CSSStyleValueType2["kMinType"] = 8] = "kMinType";
    CSSStyleValueType2[CSSStyleValueType2["kMaxType"] = 9] = "kMaxType";
    CSSStyleValueType2[CSSStyleValueType2["kClampType"] = 10] = "kClampType";
    CSSStyleValueType2[CSSStyleValueType2["kTransformType"] = 11] = "kTransformType";
    CSSStyleValueType2[CSSStyleValueType2["kPositionType"] = 12] = "kPositionType";
    CSSStyleValueType2[CSSStyleValueType2["kURLImageType"] = 13] = "kURLImageType";
    CSSStyleValueType2[CSSStyleValueType2["kColorType"] = 14] = "kColorType";
    CSSStyleValueType2[CSSStyleValueType2["kUnsupportedColorType"] = 15] = "kUnsupportedColorType";
  })(CSSStyleValueType || (CSSStyleValueType = {}));
  var stringToUnitType = function(name2) {
    return data.find(function(item) {
      return item.name === name2;
    }).unit_type;
  };
  var unitFromName = function(name2) {
    if (!name2) {
      return UnitType.kUnknown;
    }
    if (name2 === "number") {
      return UnitType.kNumber;
    }
    if (name2 === "percent" || name2 === "%") {
      return UnitType.kPercentage;
    }
    return stringToUnitType(name2);
  };
  var unitTypeToUnitCategory = function(type) {
    switch (type) {
      case UnitType.kNumber:
      case UnitType.kInteger:
        return UnitCategory.kUNumber;
      case UnitType.kPercentage:
        return UnitCategory.kUPercent;
      case UnitType.kPixels:
        return UnitCategory.kULength;
      case UnitType.kMilliseconds:
      case UnitType.kSeconds:
        return UnitCategory.kUTime;
      case UnitType.kDegrees:
      case UnitType.kRadians:
      case UnitType.kGradians:
      case UnitType.kTurns:
        return UnitCategory.kUAngle;
      default:
        return UnitCategory.kUOther;
    }
  };
  var canonicalUnitTypeForCategory = function(category) {
    switch (category) {
      case UnitCategory.kUNumber:
        return UnitType.kNumber;
      case UnitCategory.kULength:
        return UnitType.kPixels;
      case UnitCategory.kUPercent:
        return UnitType.kPercentage;
      case UnitCategory.kUTime:
        return UnitType.kSeconds;
      case UnitCategory.kUAngle:
        return UnitType.kDegrees;
      default:
        return UnitType.kUnknown;
    }
  };
  var conversionToCanonicalUnitsScaleFactor = function(unit_type) {
    var factor = 1;
    switch (unit_type) {
      case UnitType.kPixels:
      case UnitType.kDegrees:
      case UnitType.kSeconds:
        break;
      case UnitType.kMilliseconds:
        factor = 1e-3;
        break;
      case UnitType.kRadians:
        factor = 180 / Math.PI;
        break;
      case UnitType.kGradians:
        factor = 0.9;
        break;
      case UnitType.kTurns:
        factor = 360;
        break;
    }
    return factor;
  };
  var unitTypeToString = function(type) {
    switch (type) {
      case UnitType.kNumber:
      case UnitType.kInteger:
        return "";
      case UnitType.kPercentage:
        return "%";
      case UnitType.kEms:
        return "em";
      case UnitType.kRems:
        return "rem";
      case UnitType.kPixels:
        return "px";
      case UnitType.kDegrees:
        return "deg";
      case UnitType.kRadians:
        return "rad";
      case UnitType.kGradians:
        return "grad";
      case UnitType.kMilliseconds:
        return "ms";
      case UnitType.kSeconds:
        return "s";
      case UnitType.kTurns:
        return "turn";
    }
    return "";
  };
  var CSSStyleValue = (
    /** @class */
    function() {
      function CSSStyleValue2() {
      }
      CSSStyleValue2.isAngle = function(unit) {
        return unit === UnitType.kDegrees || unit === UnitType.kRadians || unit === UnitType.kGradians || unit === UnitType.kTurns;
      };
      CSSStyleValue2.isLength = function(type) {
        return type >= UnitType.kEms && type < UnitType.kDegrees;
      };
      CSSStyleValue2.isRelativeUnit = function(type) {
        return type === UnitType.kPercentage || type === UnitType.kEms || // type === UnitType.kExs ||
        type === UnitType.kRems;
      };
      CSSStyleValue2.isTime = function(unit) {
        return unit === UnitType.kSeconds || unit === UnitType.kMilliseconds;
      };
      CSSStyleValue2.prototype.toString = function() {
        return this.buildCSSText(Nested.kNo, ParenLess.kNo, "");
      };
      CSSStyleValue2.prototype.isNumericValue = function() {
        return this.getType() >= CSSStyleValueType.kUnitType && this.getType() <= CSSStyleValueType.kClampType;
      };
      return CSSStyleValue2;
    }()
  );
  var CSSColorValue = (
    /** @class */
    function(_super) {
      __extends(CSSColorValue2, _super);
      function CSSColorValue2(colorSpace) {
        var _this = _super.call(this) || this;
        _this.colorSpace = colorSpace;
        return _this;
      }
      CSSColorValue2.prototype.getType = function() {
        return CSSStyleValueType.kColorType;
      };
      CSSColorValue2.prototype.to = function(colorSpace) {
        return this;
      };
      return CSSColorValue2;
    }(CSSStyleValue)
  );
  var GradientType;
  (function(GradientType2) {
    GradientType2[GradientType2["Constant"] = 0] = "Constant";
    GradientType2[GradientType2["LinearGradient"] = 1] = "LinearGradient";
    GradientType2[GradientType2["RadialGradient"] = 2] = "RadialGradient";
  })(GradientType || (GradientType = {}));
  var CSSGradientValue = (
    /** @class */
    function(_super) {
      __extends(CSSGradientValue2, _super);
      function CSSGradientValue2(type, value2) {
        var _this = _super.call(this) || this;
        _this.type = type;
        _this.value = value2;
        return _this;
      }
      CSSGradientValue2.prototype.clone = function() {
        return new CSSGradientValue2(this.type, this.value);
      };
      CSSGradientValue2.prototype.buildCSSText = function(n2, p2, result) {
        return result;
      };
      CSSGradientValue2.prototype.getType = function() {
        return CSSStyleValueType.kColorType;
      };
      return CSSGradientValue2;
    }(CSSStyleValue)
  );
  var CSSKeywordValue = (
    /** @class */
    function(_super) {
      __extends(CSSKeywordValue2, _super);
      function CSSKeywordValue2(value2) {
        var _this = _super.call(this) || this;
        _this.value = value2;
        return _this;
      }
      CSSKeywordValue2.prototype.clone = function() {
        return new CSSKeywordValue2(this.value);
      };
      CSSKeywordValue2.prototype.getType = function() {
        return CSSStyleValueType.kKeywordType;
      };
      CSSKeywordValue2.prototype.buildCSSText = function(n2, p2, result) {
        return result + this.value;
      };
      return CSSKeywordValue2;
    }(CSSStyleValue)
  );
  var camelCase = memoize(function(str7) {
    if (str7 === void 0) {
      str7 = "";
    }
    return str7.replace(/-([a-z])/g, function(g) {
      return g[1].toUpperCase();
    });
  });
  var kebabize = function(str7) {
    return str7.split("").map(function(letter, idx) {
      return letter.toUpperCase() === letter ? "".concat(idx !== 0 ? "-" : "").concat(letter.toLowerCase()) : letter;
    }).join("");
  };
  function DCHECK(bool) {
    if (!bool) {
      throw new Error();
    }
  }
  function isFunction(func) {
    return typeof func === "function";
  }
  function isSymbol(value2) {
    return typeof value2 === "symbol";
  }
  var FORMAT_ATTR_MAP = {
    d: {
      alias: "path"
    },
    strokeDasharray: {
      alias: "lineDash"
    },
    strokeWidth: {
      alias: "lineWidth"
    },
    textAnchor: {
      alias: "textAlign"
    },
    src: {
      alias: "img"
    }
  };
  var formatAttributeName = memoize(function(name2) {
    var attributeName = camelCase(name2);
    var map3 = FORMAT_ATTR_MAP[attributeName];
    attributeName = (map3 === null || map3 === void 0 ? void 0 : map3.alias) || attributeName;
    return attributeName;
  });
  var formatInfinityOrNaN = function(number2, suffix) {
    if (suffix === void 0) {
      suffix = "";
    }
    var result = "";
    if (!Number.isFinite(number2)) {
      if (number2 > 0)
        result = "infinity";
      else
        result = "-infinity";
    } else {
      DCHECK(Number.isNaN(number2));
      result = "NaN";
    }
    return result += suffix;
  };
  var toCanonicalUnit = function(unit) {
    return canonicalUnitTypeForCategory(unitTypeToUnitCategory(unit));
  };
  var CSSUnitValue = (
    /** @class */
    function(_super) {
      __extends(CSSUnitValue2, _super);
      function CSSUnitValue2(value2, unitOrName) {
        if (unitOrName === void 0) {
          unitOrName = UnitType.kNumber;
        }
        var _this = _super.call(this) || this;
        var unit;
        if (typeof unitOrName === "string") {
          unit = unitFromName(unitOrName);
        } else {
          unit = unitOrName;
        }
        _this.unit = unit;
        _this.value = value2;
        return _this;
      }
      CSSUnitValue2.prototype.clone = function() {
        return new CSSUnitValue2(this.value, this.unit);
      };
      CSSUnitValue2.prototype.equals = function(other) {
        var other_unit_value = other;
        return this.value === other_unit_value.value && this.unit === other_unit_value.unit;
      };
      CSSUnitValue2.prototype.getType = function() {
        return CSSStyleValueType.kUnitType;
      };
      CSSUnitValue2.prototype.convertTo = function(target_unit) {
        if (this.unit === target_unit) {
          return new CSSUnitValue2(this.value, this.unit);
        }
        var canonical_unit = toCanonicalUnit(this.unit);
        if (canonical_unit !== toCanonicalUnit(target_unit) || canonical_unit === UnitType.kUnknown) {
          return null;
        }
        var scale_factor = conversionToCanonicalUnitsScaleFactor(this.unit) / conversionToCanonicalUnitsScaleFactor(target_unit);
        return new CSSUnitValue2(this.value * scale_factor, target_unit);
      };
      CSSUnitValue2.prototype.buildCSSText = function(n2, p2, result) {
        var text;
        switch (this.unit) {
          case UnitType.kUnknown:
            break;
          case UnitType.kInteger:
            text = Number(this.value).toFixed(0);
            break;
          case UnitType.kNumber:
          case UnitType.kPercentage:
          case UnitType.kEms:
          case UnitType.kRems:
          case UnitType.kPixels:
          case UnitType.kDegrees:
          case UnitType.kRadians:
          case UnitType.kGradians:
          case UnitType.kMilliseconds:
          case UnitType.kSeconds:
          case UnitType.kTurns: {
            var kMinInteger = -999999;
            var kMaxInteger = 999999;
            var value2 = this.value;
            var unit = unitTypeToString(this.unit);
            if (value2 < kMinInteger || value2 > kMaxInteger) {
              var unit_1 = unitTypeToString(this.unit);
              if (!Number.isFinite(value2) || Number.isNaN(value2)) {
                text = formatInfinityOrNaN(value2, unit_1);
              } else {
                text = value2 + (unit_1 || "");
              }
            } else {
              text = "".concat(value2).concat(unit);
            }
          }
        }
        result += text;
        return result;
      };
      return CSSUnitValue2;
    }(CSSStyleValue)
  );
  var Opx = new CSSUnitValue(0, "px");
  new CSSUnitValue(1, "px");
  var Odeg = new CSSUnitValue(0, "deg");
  var CSSRGB = (
    /** @class */
    function(_super) {
      __extends(CSSRGB2, _super);
      function CSSRGB2(r, g, b, alpha, isNone) {
        if (alpha === void 0) {
          alpha = 1;
        }
        if (isNone === void 0) {
          isNone = false;
        }
        var _this = _super.call(this, "rgb") || this;
        _this.r = r;
        _this.g = g;
        _this.b = b;
        _this.alpha = alpha;
        _this.isNone = isNone;
        return _this;
      }
      CSSRGB2.prototype.clone = function() {
        return new CSSRGB2(this.r, this.g, this.b, this.alpha);
      };
      CSSRGB2.prototype.buildCSSText = function(n2, p2, result) {
        return result + "rgba(".concat(this.r, ",").concat(this.g, ",").concat(this.b, ",").concat(this.alpha, ")");
      };
      return CSSRGB2;
    }(CSSColorValue)
  );
  var unsetKeywordValue = new CSSKeywordValue("unset");
  var initialKeywordValue = new CSSKeywordValue("initial");
  var inheritKeywordValue = new CSSKeywordValue("inherit");
  var keywordCache = {
    "": unsetKeywordValue,
    unset: unsetKeywordValue,
    initial: initialKeywordValue,
    inherit: inheritKeywordValue
  };
  var getOrCreateKeyword = function(name2) {
    if (!keywordCache[name2]) {
      keywordCache[name2] = new CSSKeywordValue(name2);
    }
    return keywordCache[name2];
  };
  var noneColor = new CSSRGB(0, 0, 0, 0, true);
  var transparentColor = new CSSRGB(0, 0, 0, 0);
  var getOrCreateRGBA = memoize(function(r, g, b, a3) {
    return new CSSRGB(r, g, b, a3);
  }, function(r, g, b, a3) {
    return "rgba(".concat(r, ",").concat(g, ",").concat(b, ",").concat(a3, ")");
  });
  var getOrCreateUnitValue = function(value2, unitOrName) {
    if (unitOrName === void 0) {
      unitOrName = UnitType.kNumber;
    }
    return new CSSUnitValue(value2, unitOrName);
  };
  new CSSUnitValue(50, "%");
  var Strategy;
  (function(Strategy2) {
    Strategy2[Strategy2["Standard"] = 0] = "Standard";
  })(Strategy || (Strategy = {}));
  var SortReason;
  (function(SortReason2) {
    SortReason2[SortReason2["ADDED"] = 0] = "ADDED";
    SortReason2[SortReason2["REMOVED"] = 1] = "REMOVED";
    SortReason2[SortReason2["Z_INDEX_CHANGED"] = 2] = "Z_INDEX_CHANGED";
  })(SortReason || (SortReason = {}));
  var EMPTY_PARSED_PATH = {
    absolutePath: [],
    hasArc: false,
    segments: [],
    polygons: [],
    polylines: [],
    curve: null,
    totalLength: 0,
    rect: new Rectangle(0, 0, 0, 0)
  };
  var PropertySyntax;
  (function(PropertySyntax2) {
    PropertySyntax2["COORDINATE"] = "<coordinate>";
    PropertySyntax2["COLOR"] = "<color>";
    PropertySyntax2["PAINT"] = "<paint>";
    PropertySyntax2["NUMBER"] = "<number>";
    PropertySyntax2["ANGLE"] = "<angle>";
    PropertySyntax2["OPACITY_VALUE"] = "<opacity-value>";
    PropertySyntax2["SHADOW_BLUR"] = "<shadow-blur>";
    PropertySyntax2["LENGTH"] = "<length>";
    PropertySyntax2["PERCENTAGE"] = "<percentage>";
    PropertySyntax2["LENGTH_PERCENTAGE"] = "<length> | <percentage>";
    PropertySyntax2["LENGTH_PERCENTAGE_12"] = "[<length> | <percentage>]{1,2}";
    PropertySyntax2["LENGTH_PERCENTAGE_14"] = "[<length> | <percentage>]{1,4}";
    PropertySyntax2["LIST_OF_POINTS"] = "<list-of-points>";
    PropertySyntax2["PATH"] = "<path>";
    PropertySyntax2["FILTER"] = "<filter>";
    PropertySyntax2["Z_INDEX"] = "<z-index>";
    PropertySyntax2["OFFSET_DISTANCE"] = "<offset-distance>";
    PropertySyntax2["DEFINED_PATH"] = "<defined-path>";
    PropertySyntax2["MARKER"] = "<marker>";
    PropertySyntax2["TRANSFORM"] = "<transform>";
    PropertySyntax2["TRANSFORM_ORIGIN"] = "<transform-origin>";
    PropertySyntax2["TEXT"] = "<text>";
    PropertySyntax2["TEXT_TRANSFORM"] = "<text-transform>";
  })(PropertySyntax || (PropertySyntax = {}));
  function colorStopToString(colorStop) {
    var type = colorStop.type, value2 = colorStop.value;
    if (type === "hex") {
      return "#".concat(value2);
    } else if (type === "literal") {
      return value2;
    } else if (type === "rgb") {
      return "rgb(".concat(value2.join(","), ")");
    } else {
      return "rgba(".concat(value2.join(","), ")");
    }
  }
  var parseGradient$1 = /* @__PURE__ */ function() {
    var tokens4 = {
      linearGradient: /^(linear\-gradient)/i,
      repeatingLinearGradient: /^(repeating\-linear\-gradient)/i,
      radialGradient: /^(radial\-gradient)/i,
      repeatingRadialGradient: /^(repeating\-radial\-gradient)/i,
      /**
       * @see https://projects.verou.me/conic-gradient/
       */
      conicGradient: /^(conic\-gradient)/i,
      sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
      extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
      positionKeywords: /^(left|center|right|top|bottom)/i,
      pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
      percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
      emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
      angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
      startCall: /^\(/,
      endCall: /^\)/,
      comma: /^,/,
      hexColor: /^\#([0-9a-fA-F]+)/,
      literalColor: /^([a-zA-Z]+)/,
      rgbColor: /^rgb/i,
      rgbaColor: /^rgba/i,
      number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
    };
    var input = "";
    function error4(msg) {
      throw new Error(input + ": " + msg);
    }
    function getAST() {
      var ast = matchListDefinitions();
      if (input.length > 0) {
        error4("Invalid input not EOF");
      }
      return ast;
    }
    function matchListDefinitions() {
      return matchListing(matchDefinition);
    }
    function matchDefinition() {
      return matchGradient("linear-gradient", tokens4.linearGradient, matchLinearOrientation) || matchGradient("repeating-linear-gradient", tokens4.repeatingLinearGradient, matchLinearOrientation) || matchGradient("radial-gradient", tokens4.radialGradient, matchListRadialOrientations) || matchGradient("repeating-radial-gradient", tokens4.repeatingRadialGradient, matchListRadialOrientations) || matchGradient("conic-gradient", tokens4.conicGradient, matchListRadialOrientations);
    }
    function matchGradient(gradientType, pattern, orientationMatcher) {
      return matchCall(pattern, function(captures) {
        var orientation = orientationMatcher();
        if (orientation) {
          if (!scan(tokens4.comma)) {
            error4("Missing comma before color stops");
          }
        }
        return {
          type: gradientType,
          orientation,
          colorStops: matchListing(matchColorStop)
        };
      });
    }
    function matchCall(pattern, callback) {
      var captures = scan(pattern);
      if (captures) {
        if (!scan(tokens4.startCall)) {
          error4("Missing (");
        }
        var result = callback(captures);
        if (!scan(tokens4.endCall)) {
          error4("Missing )");
        }
        return result;
      }
    }
    function matchLinearOrientation() {
      return matchSideOrCorner() || matchAngle();
    }
    function matchSideOrCorner() {
      return match2("directional", tokens4.sideOrCorner, 1);
    }
    function matchAngle() {
      return match2("angular", tokens4.angleValue, 1);
    }
    function matchListRadialOrientations() {
      var radialOrientations, radialOrientation = matchRadialOrientation(), lookaheadCache;
      if (radialOrientation) {
        radialOrientations = [];
        radialOrientations.push(radialOrientation);
        lookaheadCache = input;
        if (scan(tokens4.comma)) {
          radialOrientation = matchRadialOrientation();
          if (radialOrientation) {
            radialOrientations.push(radialOrientation);
          } else {
            input = lookaheadCache;
          }
        }
      }
      return radialOrientations;
    }
    function matchRadialOrientation() {
      var radialType = matchCircle() || matchEllipse();
      if (radialType) {
        radialType.at = matchAtPosition();
      } else {
        var extent2 = matchExtentKeyword();
        if (extent2) {
          radialType = extent2;
          var positionAt = matchAtPosition();
          if (positionAt) {
            radialType.at = positionAt;
          }
        } else {
          var defaultPosition = matchPositioning();
          if (defaultPosition) {
            radialType = {
              type: "default-radial",
              // @ts-ignore
              at: defaultPosition
            };
          }
        }
      }
      return radialType;
    }
    function matchCircle() {
      var circle3 = match2("shape", /^(circle)/i, 0);
      if (circle3) {
        circle3.style = matchLength() || matchExtentKeyword();
      }
      return circle3;
    }
    function matchEllipse() {
      var ellipse = match2("shape", /^(ellipse)/i, 0);
      if (ellipse) {
        ellipse.style = matchDistance() || matchExtentKeyword();
      }
      return ellipse;
    }
    function matchExtentKeyword() {
      return match2("extent-keyword", tokens4.extentKeywords, 1);
    }
    function matchAtPosition() {
      if (match2("position", /^at/, 0)) {
        var positioning = matchPositioning();
        if (!positioning) {
          error4("Missing positioning value");
        }
        return positioning;
      }
    }
    function matchPositioning() {
      var location2 = matchCoordinates();
      if (location2.x || location2.y) {
        return {
          type: "position",
          value: location2
        };
      }
    }
    function matchCoordinates() {
      return {
        x: matchDistance(),
        y: matchDistance()
      };
    }
    function matchListing(matcher) {
      var captures = matcher();
      var result = [];
      if (captures) {
        result.push(captures);
        while (scan(tokens4.comma)) {
          captures = matcher();
          if (captures) {
            result.push(captures);
          } else {
            error4("One extra comma");
          }
        }
      }
      return result;
    }
    function matchColorStop() {
      var color2 = matchColor();
      if (!color2) {
        error4("Expected color definition");
      }
      color2.length = matchDistance();
      return color2;
    }
    function matchColor() {
      return matchHexColor() || matchRGBAColor() || matchRGBColor() || matchLiteralColor();
    }
    function matchLiteralColor() {
      return match2("literal", tokens4.literalColor, 0);
    }
    function matchHexColor() {
      return match2("hex", tokens4.hexColor, 1);
    }
    function matchRGBColor() {
      return matchCall(tokens4.rgbColor, function() {
        return {
          type: "rgb",
          value: matchListing(matchNumber)
        };
      });
    }
    function matchRGBAColor() {
      return matchCall(tokens4.rgbaColor, function() {
        return {
          type: "rgba",
          value: matchListing(matchNumber)
        };
      });
    }
    function matchNumber() {
      return scan(tokens4.number)[1];
    }
    function matchDistance() {
      return match2("%", tokens4.percentageValue, 1) || matchPositionKeyword() || matchLength();
    }
    function matchPositionKeyword() {
      return match2("position-keyword", tokens4.positionKeywords, 1);
    }
    function matchLength() {
      return match2("px", tokens4.pixelValue, 1) || match2("em", tokens4.emValue, 1);
    }
    function match2(type, pattern, captureIndex) {
      var captures = scan(pattern);
      if (captures) {
        return {
          type,
          value: captures[captureIndex]
        };
      }
    }
    function scan(regexp) {
      var blankCaptures = /^[\n\r\t\s]+/.exec(input);
      if (blankCaptures) {
        consume(blankCaptures[0].length);
      }
      var captures = regexp.exec(input);
      if (captures) {
        consume(captures[0].length);
      }
      return captures;
    }
    function consume(size2) {
      input = input.substring(size2);
    }
    return function(code) {
      input = code;
      return getAST();
    };
  }();
  function computeLinearGradient(min10, width, height, angle4) {
    var rad = deg2rad(angle4.value);
    var rx = 0;
    var ry = 0;
    var rcx = rx + width / 2;
    var rcy = ry + height / 2;
    var length5 = Math.abs(width * Math.cos(rad)) + Math.abs(height * Math.sin(rad));
    var x12 = min10[0] + rcx - Math.cos(rad) * length5 / 2;
    var y12 = min10[1] + rcy - Math.sin(rad) * length5 / 2;
    var x22 = min10[0] + rcx + Math.cos(rad) * length5 / 2;
    var y22 = min10[1] + rcy + Math.sin(rad) * length5 / 2;
    return { x1: x12, y1: y12, x2: x22, y2: y22 };
  }
  function computeRadialGradient(min10, width, height, cx, cy, size2) {
    var x3 = cx.value;
    var y3 = cy.value;
    if (cx.unit === UnitType.kPercentage) {
      x3 = cx.value / 100 * width;
    }
    if (cy.unit === UnitType.kPercentage) {
      y3 = cy.value / 100 * height;
    }
    var r = Math.max(distanceSquareRoot([0, 0], [x3, y3]), distanceSquareRoot([0, height], [x3, y3]), distanceSquareRoot([width, height], [x3, y3]), distanceSquareRoot([width, 0], [x3, y3]));
    if (size2) {
      if (size2 instanceof CSSUnitValue) {
        r = size2.value;
      } else if (size2 instanceof CSSKeywordValue) {
        if (size2.value === "closest-side") {
          r = Math.min(x3, width - x3, y3, height - y3);
        } else if (size2.value === "farthest-side") {
          r = Math.max(x3, width - x3, y3, height - y3);
        } else if (size2.value === "closest-corner") {
          r = Math.min(distanceSquareRoot([0, 0], [x3, y3]), distanceSquareRoot([0, height], [x3, y3]), distanceSquareRoot([width, height], [x3, y3]), distanceSquareRoot([width, 0], [x3, y3]));
        }
      }
    }
    return { x: x3 + min10[0], y: y3 + min10[1], r };
  }
  var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
  var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
  var regexColorStop = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
  function spaceColorStops(colorStops) {
    var _a, _b, _c;
    var length5 = colorStops.length;
    colorStops[length5 - 1].length = (_a = colorStops[length5 - 1].length) !== null && _a !== void 0 ? _a : {
      type: "%",
      value: "100"
    };
    if (length5 > 1) {
      colorStops[0].length = (_b = colorStops[0].length) !== null && _b !== void 0 ? _b : {
        type: "%",
        value: "0"
      };
    }
    var previousIndex = 0;
    var previousOffset = Number(colorStops[0].length.value);
    for (var i = 1; i < length5; i++) {
      var offset3 = (_c = colorStops[i].length) === null || _c === void 0 ? void 0 : _c.value;
      if (!is_nil_default2(offset3) && !is_nil_default2(previousOffset)) {
        for (var j = 1; j < i - previousIndex; j++)
          colorStops[previousIndex + j].length = {
            type: "%",
            value: "".concat(previousOffset + (Number(offset3) - previousOffset) * j / (i - previousIndex))
          };
        previousIndex = i;
        previousOffset = Number(offset3);
      }
    }
  }
  var SideOrCornerToDegMap = {
    left: 270 - 90,
    top: 0 - 90,
    bottom: 180 - 90,
    right: 90 - 90,
    "left top": 315 - 90,
    "top left": 315 - 90,
    "left bottom": 225 - 90,
    "bottom left": 225 - 90,
    "right top": 45 - 90,
    "top right": 45 - 90,
    "right bottom": 135 - 90,
    "bottom right": 135 - 90
  };
  var angleToDeg = memoize(function(orientation) {
    var angle4;
    if (orientation.type === "angular") {
      angle4 = Number(orientation.value);
    } else {
      angle4 = SideOrCornerToDegMap[orientation.value] || 0;
    }
    return getOrCreateUnitValue(angle4, "deg");
  });
  var positonToCSSUnitValue = memoize(function(position) {
    var cx = 50;
    var cy = 50;
    var unitX = "%";
    var unitY = "%";
    if ((position === null || position === void 0 ? void 0 : position.type) === "position") {
      var _a = position.value, x3 = _a.x, y3 = _a.y;
      if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "position-keyword") {
        if (x3.value === "left") {
          cx = 0;
        } else if (x3.value === "center") {
          cx = 50;
        } else if (x3.value === "right") {
          cx = 100;
        } else if (x3.value === "top") {
          cy = 0;
        } else if (x3.value === "bottom") {
          cy = 100;
        }
      }
      if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "position-keyword") {
        if (y3.value === "left") {
          cx = 0;
        } else if (y3.value === "center") {
          cy = 50;
        } else if (y3.value === "right") {
          cx = 100;
        } else if (y3.value === "top") {
          cy = 0;
        } else if (y3.value === "bottom") {
          cy = 100;
        }
      }
      if ((x3 === null || x3 === void 0 ? void 0 : x3.type) === "px" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "%" || (x3 === null || x3 === void 0 ? void 0 : x3.type) === "em") {
        unitX = x3 === null || x3 === void 0 ? void 0 : x3.type;
        cx = Number(x3.value);
      }
      if ((y3 === null || y3 === void 0 ? void 0 : y3.type) === "px" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "%" || (y3 === null || y3 === void 0 ? void 0 : y3.type) === "em") {
        unitY = y3 === null || y3 === void 0 ? void 0 : y3.type;
        cy = Number(y3.value);
      }
    }
    return {
      cx: getOrCreateUnitValue(cx, unitX),
      cy: getOrCreateUnitValue(cy, unitY)
    };
  });
  var parseGradient = memoize(function(colorStr) {
    var _a;
    if (colorStr.indexOf("linear") > -1 || colorStr.indexOf("radial") > -1) {
      var ast = parseGradient$1(colorStr);
      return ast.map(function(_a2) {
        var type2 = _a2.type, orientation = _a2.orientation, colorStops = _a2.colorStops;
        spaceColorStops(colorStops);
        var steps2 = colorStops.map(function(colorStop) {
          return {
            offset: getOrCreateUnitValue(Number(colorStop.length.value), "%"),
            color: colorStopToString(colorStop)
          };
        });
        if (type2 === "linear-gradient") {
          return new CSSGradientValue(GradientType.LinearGradient, {
            angle: orientation ? angleToDeg(orientation) : Odeg,
            steps: steps2
          });
        } else if (type2 === "radial-gradient") {
          if (!orientation) {
            orientation = [
              {
                type: "shape",
                value: "circle"
              }
            ];
          }
          if (orientation[0].type === "shape" && orientation[0].value === "circle") {
            var _b = positonToCSSUnitValue(orientation[0].at), cx = _b.cx, cy = _b.cy;
            var size2 = void 0;
            if (orientation[0].style) {
              var _c = orientation[0].style, type_1 = _c.type, value2 = _c.value;
              if (type_1 === "extent-keyword") {
                size2 = getOrCreateKeyword(value2);
              } else {
                size2 = getOrCreateUnitValue(value2, type_1);
              }
            }
            return new CSSGradientValue(GradientType.RadialGradient, {
              cx,
              cy,
              size: size2,
              steps: steps2
            });
          }
        }
      });
    }
    var type = colorStr[0];
    if (colorStr[1] === "(" || colorStr[2] === "(") {
      if (type === "l") {
        var arr = regexLG.exec(colorStr);
        if (arr) {
          var steps = ((_a = arr[2].match(regexColorStop)) === null || _a === void 0 ? void 0 : _a.map(function(stop) {
            return stop.split(":");
          })) || [];
          return [
            new CSSGradientValue(GradientType.LinearGradient, {
              angle: getOrCreateUnitValue(parseFloat(arr[1]), "deg"),
              steps: steps.map(function(_a2) {
                var _b = __read(_a2, 2), offset3 = _b[0], color2 = _b[1];
                return {
                  offset: getOrCreateUnitValue(Number(offset3) * 100, "%"),
                  color: color2
                };
              })
            })
          ];
        }
      } else if (type === "r") {
        var parsedRadialGradient = parseRadialGradient(colorStr);
        if (parsedRadialGradient) {
          if (is_string_default2(parsedRadialGradient)) {
            colorStr = parsedRadialGradient;
          } else {
            return [
              new CSSGradientValue(GradientType.RadialGradient, parsedRadialGradient)
            ];
          }
        }
      } else if (type === "p") {
        return parsePattern(colorStr);
      }
    }
  });
  function parseRadialGradient(gradientStr) {
    var _a;
    var arr = regexRG.exec(gradientStr);
    if (arr) {
      var steps = ((_a = arr[4].match(regexColorStop)) === null || _a === void 0 ? void 0 : _a.map(function(stop) {
        return stop.split(":");
      })) || [];
      return {
        cx: getOrCreateUnitValue(50, "%"),
        cy: getOrCreateUnitValue(50, "%"),
        steps: steps.map(function(_a2) {
          var _b = __read(_a2, 2), offset3 = _b[0], color2 = _b[1];
          return {
            offset: getOrCreateUnitValue(Number(offset3) * 100, "%"),
            color: color2
          };
        })
      };
    }
    return null;
  }
  function parsePattern(patternStr) {
    var arr = regexPR.exec(patternStr);
    if (arr) {
      var repetition = arr[1];
      var src = arr[2];
      switch (repetition) {
        case "a":
          repetition = "repeat";
          break;
        case "x":
          repetition = "repeat-x";
          break;
        case "y":
          repetition = "repeat-y";
          break;
        case "n":
          repetition = "no-repeat";
          break;
        default:
          repetition = "no-repeat";
      }
      return {
        image: src,
        // @ts-ignore
        repetition
      };
    }
    return null;
  }
  function isPattern(object) {
    return object && !!object.image;
  }
  function isCSSRGB(object) {
    return object && !is_nil_default2(object.r) && !is_nil_default2(object.g) && !is_nil_default2(object.b);
  }
  var parseColor = memoize(function(colorStr) {
    if (isPattern(colorStr)) {
      return __assign({ repetition: "repeat" }, colorStr);
    }
    if (is_nil_default2(colorStr)) {
      colorStr = "";
    }
    if (colorStr === "transparent") {
      return transparentColor;
    } else if (colorStr === "currentColor") {
      colorStr = "black";
    } else if (colorStr === "none") {
      return noneColor;
    }
    var g = parseGradient(colorStr);
    if (g) {
      return g;
    }
    var color2 = color(colorStr);
    var rgba2 = [0, 0, 0, 0];
    if (color2 !== null) {
      rgba2[0] = color2.r || 0;
      rgba2[1] = color2.g || 0;
      rgba2[2] = color2.b || 0;
      rgba2[3] = color2.opacity;
    }
    return getOrCreateRGBA.apply(void 0, __spreadArray([], __read(rgba2), false));
  });
  function mergeColors(left2, right2) {
    if (!isCSSRGB(left2) || !isCSSRGB(right2)) {
      return;
    }
    return [
      [Number(left2.r), Number(left2.g), Number(left2.b), Number(left2.alpha)],
      [Number(right2.r), Number(right2.g), Number(right2.b), Number(right2.alpha)],
      function(color2) {
        var rgba2 = color2.slice();
        if (rgba2[3]) {
          for (var i = 0; i < 3; i++)
            rgba2[i] = Math.round(clamp_default(rgba2[i], 0, 255));
        }
        rgba2[3] = clamp_default(rgba2[3], 0, 1);
        return "rgba(".concat(rgba2.join(","), ")");
      }
    ];
  }
  function parseDimension(unitRegExp, string) {
    if (is_nil_default2(string)) {
      return getOrCreateUnitValue(0, "px");
    }
    string = "".concat(string).trim().toLowerCase();
    if (isFinite(Number(string))) {
      if ("px".search(unitRegExp) >= 0) {
        return getOrCreateUnitValue(Number(string), "px");
      } else if ("deg".search(unitRegExp) >= 0) {
        return getOrCreateUnitValue(Number(string), "deg");
      }
    }
    var matchedUnits = [];
    string = string.replace(unitRegExp, function(match2) {
      matchedUnits.push(match2);
      return "U" + match2;
    });
    var taggedUnitRegExp = "U(" + unitRegExp.source + ")";
    return matchedUnits.map(function(unit) {
      return getOrCreateUnitValue(Number(string.replace(new RegExp("U" + unit, "g"), "").replace(new RegExp(taggedUnitRegExp, "g"), "*0")), unit);
    })[0];
  }
  var parseLengthUnmemoize = function(css2) {
    return parseDimension(new RegExp("px", "g"), css2);
  };
  var parseLength = memoize(parseLengthUnmemoize);
  var parserPercentageUnmemoize = function(css2) {
    return parseDimension(new RegExp("%", "g"), css2);
  };
  memoize(parserPercentageUnmemoize);
  var parseLengthOrPercentageUnmemoize = function(css2) {
    if (is_number_default2(css2) || isFinite(Number(css2))) {
      return getOrCreateUnitValue(Number(css2) || 0, "px");
    }
    return parseDimension(new RegExp("px|%|em|rem", "g"), css2);
  };
  var parseLengthOrPercentage = memoize(parseLengthOrPercentageUnmemoize);
  var parseAngleUnmemoize = function(css2) {
    return parseDimension(new RegExp("deg|rad|grad|turn", "g"), css2);
  };
  var parseAngle = memoize(parseAngleUnmemoize);
  function mergeDimensions(left2, right2, target, nonNegative, index4) {
    if (index4 === void 0) {
      index4 = 0;
    }
    var unit = "";
    var leftValue = left2.value || 0;
    var rightValue = right2.value || 0;
    var canonicalUnit = toCanonicalUnit(left2.unit);
    var leftCanonicalUnitValue = left2.convertTo(canonicalUnit);
    var rightCanonicalUnitValue = right2.convertTo(canonicalUnit);
    if (leftCanonicalUnitValue && rightCanonicalUnitValue) {
      leftValue = leftCanonicalUnitValue.value;
      rightValue = rightCanonicalUnitValue.value;
      unit = unitTypeToString(left2.unit);
    } else {
      if (CSSUnitValue.isLength(left2.unit) || CSSUnitValue.isLength(right2.unit)) {
        leftValue = convertPercentUnit(left2, index4, target);
        rightValue = convertPercentUnit(right2, index4, target);
        unit = "px";
      }
    }
    return [
      leftValue,
      rightValue,
      function(value2) {
        if (nonNegative) {
          value2 = Math.max(value2, 0);
        }
        return value2 + unit;
      }
    ];
  }
  function convertAngleUnit(value2) {
    var deg = 0;
    if (value2.unit === UnitType.kDegrees) {
      deg = value2.value;
    } else if (value2.unit === UnitType.kRadians) {
      deg = rad2deg(Number(value2.value));
    } else if (value2.unit === UnitType.kTurns) {
      deg = turn2deg(Number(value2.value));
    }
    return deg;
  }
  function parseDimensionArrayFormat(string, size2) {
    var parsed;
    if (Array.isArray(string)) {
      parsed = string.map(function(segment) {
        return Number(segment);
      });
    } else if (is_string_default2(string)) {
      parsed = string.split(" ").map(function(segment) {
        return Number(segment);
      });
    } else if (is_number_default2(string)) {
      parsed = [string];
    }
    if (size2 === 2) {
      if (parsed.length === 1) {
        return [parsed[0], parsed[0]];
      } else {
        return [parsed[0], parsed[1]];
      }
    } else {
      if (parsed.length === 1) {
        return [parsed[0], parsed[0], parsed[0], parsed[0]];
      } else if (parsed.length === 2) {
        return [parsed[0], parsed[1], parsed[0], parsed[1]];
      } else if (parsed.length === 3) {
        return [parsed[0], parsed[1], parsed[2], parsed[1]];
      } else {
        return [parsed[0], parsed[1], parsed[2], parsed[3]];
      }
    }
  }
  function parseDimensionArray(string) {
    if (is_string_default2(string)) {
      return string.split(" ").map(function(segment) {
        return parseLengthOrPercentage(segment);
      });
    } else {
      return string.map(function(segment) {
        return parseLengthOrPercentage(segment.toString());
      });
    }
  }
  function convertPercentUnit(valueWithUnit, vec3Index, target, useMin) {
    if (useMin === void 0) {
      useMin = false;
    }
    if (valueWithUnit.unit === UnitType.kPixels) {
      return Number(valueWithUnit.value);
    } else if (valueWithUnit.unit === UnitType.kPercentage && target) {
      var bounds = target.nodeName === Shape.GROUP ? target.getLocalBounds() : target.getGeometryBounds();
      return (useMin ? bounds.min[vec3Index] : 0) + valueWithUnit.value / 100 * bounds.halfExtents[vec3Index] * 2;
    }
    return 0;
  }
  var parseParam = function(css2) {
    return parseDimension(/deg|rad|grad|turn|px|%/g, css2);
  };
  var supportedFilters = [
    "blur",
    "brightness",
    "drop-shadow",
    "contrast",
    "grayscale",
    "sepia",
    "saturate",
    "hue-rotate",
    "invert"
  ];
  function parseFilter(filterStr) {
    if (filterStr === void 0) {
      filterStr = "";
    }
    filterStr = filterStr.toLowerCase().trim();
    if (filterStr === "none") {
      return [];
    }
    var filterRegExp = /\s*([\w-]+)\(([^)]*)\)/g;
    var result = [];
    var match2;
    var prevLastIndex = 0;
    while (match2 = filterRegExp.exec(filterStr)) {
      if (match2.index !== prevLastIndex) {
        return [];
      }
      prevLastIndex = match2.index + match2[0].length;
      if (supportedFilters.indexOf(match2[1]) > -1) {
        result.push({
          name: match2[1],
          params: match2[2].split(" ").map(function(p2) {
            return parseParam(p2) || parseColor(p2);
          })
        });
      }
      if (filterRegExp.lastIndex === filterStr.length) {
        return result;
      }
    }
    return [];
  }
  function numberToString(x3) {
    return x3.toString();
  }
  var parseNumberUnmemoize = function(string) {
    if (typeof string === "number") {
      return getOrCreateUnitValue(string);
    }
    if (/^\s*[-+]?(\d*\.)?\d+\s*$/.test(string)) {
      return getOrCreateUnitValue(Number(string));
    } else {
      return getOrCreateUnitValue(0);
    }
  };
  var parseNumber = memoize(parseNumberUnmemoize);
  memoize(function(string) {
    if (is_string_default2(string)) {
      return string.split(" ").map(parseNumber);
    } else {
      return string.map(parseNumber);
    }
  });
  function mergeNumbers(left2, right2) {
    return [left2, right2, numberToString];
  }
  function clampedMergeNumbers(min10, max10) {
    return function(left2, right2) {
      return [
        left2,
        right2,
        function(x3) {
          return numberToString(clamp_default(x3, min10, max10));
        }
      ];
    };
  }
  function mergeNumberLists(left2, right2) {
    if (left2.length !== right2.length) {
      return;
    }
    return [
      left2,
      right2,
      function(numberList) {
        return numberList;
      }
    ];
  }
  function getOrCalculatePathTotalLength(path2) {
    if (path2.parsedStyle.d.totalLength === 0) {
      path2.parsedStyle.d.totalLength = getTotalLength(path2.parsedStyle.d.absolutePath);
    }
    return path2.parsedStyle.d.totalLength;
  }
  function getOrCalculatePolylineTotalLength(polyline) {
    if (polyline.parsedStyle.points.totalLength === 0) {
      polyline.parsedStyle.points.totalLength = length$2(polyline.parsedStyle.points.points);
    }
    return polyline.parsedStyle.points.totalLength;
  }
  function removeRedundantMCommand(path2) {
    for (var i = 0; i < path2.length; i++) {
      var prevSegment = path2[i - 1];
      var segment = path2[i];
      var cmd = segment[0];
      if (cmd === "M") {
        if (prevSegment) {
          var prevCmd = prevSegment[0];
          var srcPoint = [segment[1], segment[2]];
          var destPoint = void 0;
          if (prevCmd === "L" || prevCmd === "M") {
            destPoint = [prevSegment[1], prevSegment[2]];
          } else if (prevCmd === "C" || prevCmd === "A" || prevCmd === "Q") {
            destPoint = [
              prevSegment[prevSegment.length - 2],
              prevSegment[prevSegment.length - 1]
            ];
          }
          if (destPoint && isSamePoint(srcPoint, destPoint)) {
            path2.splice(i, 1);
            i--;
          }
        }
      }
    }
  }
  function hasArcOrBezier(path2) {
    var hasArc = false;
    var count4 = path2.length;
    for (var i = 0; i < count4; i++) {
      var params = path2[i];
      var cmd = params[0];
      if (cmd === "C" || cmd === "A" || cmd === "Q") {
        hasArc = true;
        break;
      }
    }
    return hasArc;
  }
  function extractPolygons(pathArray) {
    var polygons = [];
    var polylines = [];
    var points = [];
    for (var i = 0; i < pathArray.length; i++) {
      var params = pathArray[i];
      var cmd = params[0];
      if (cmd === "M") {
        if (points.length) {
          polylines.push(points);
          points = [];
        }
        points.push([params[1], params[2]]);
      } else if (cmd === "Z") {
        if (points.length) {
          polygons.push(points);
          points = [];
        }
      } else {
        points.push([params[1], params[2]]);
      }
    }
    if (points.length > 0) {
      polylines.push(points);
    }
    return {
      polygons,
      polylines
    };
  }
  function isSamePoint(point1, point22) {
    return point1[0] === point22[0] && point1[1] === point22[1];
  }
  function getPathBBox(segments, lineWidth) {
    var xArr = [];
    var yArr = [];
    var segmentsWithAngle = [];
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
      var box2 = void 0;
      switch (segment.command) {
        case "Q":
          box2 = box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
          break;
        case "C":
          box2 = box$3(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
          break;
        case "A":
          var arcParams = segment.arcParams;
          box2 = box$5(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
          break;
        default:
          xArr.push(currentPoint[0]);
          yArr.push(currentPoint[1]);
          break;
      }
      if (box2) {
        segment.box = box2;
        xArr.push(box2.x, box2.x + box2.width);
        yArr.push(box2.y, box2.y + box2.height);
      }
      if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
        segmentsWithAngle.push(segment);
      }
    }
    xArr = xArr.filter(function(item) {
      return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
    });
    yArr = yArr.filter(function(item) {
      return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
    });
    var minX = min_default(xArr);
    var minY = min_default(yArr);
    var maxX = max_default(xArr);
    var maxY2 = max_default(yArr);
    if (segmentsWithAngle.length === 0) {
      return {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY2 - minY
      };
    }
    for (var i = 0; i < segmentsWithAngle.length; i++) {
      var segment = segmentsWithAngle[i];
      var currentPoint = segment.currentPoint;
      var extra = void 0;
      if (currentPoint[0] === minX) {
        extra = getExtraFromSegmentWithAngle(segment, lineWidth);
        minX = minX - extra.xExtra;
      } else if (currentPoint[0] === maxX) {
        extra = getExtraFromSegmentWithAngle(segment, lineWidth);
        maxX = maxX + extra.xExtra;
      }
      if (currentPoint[1] === minY) {
        extra = getExtraFromSegmentWithAngle(segment, lineWidth);
        minY = minY - extra.yExtra;
      } else if (currentPoint[1] === maxY2) {
        extra = getExtraFromSegmentWithAngle(segment, lineWidth);
        maxY2 = maxY2 + extra.yExtra;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  }
  function getExtraFromSegmentWithAngle(segment, lineWidth) {
    var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
    var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
    var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
    var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
    var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
    if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual(currentAngle, 0)) {
      return {
        xExtra: 0,
        yExtra: 0
      };
    }
    var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
    var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
    xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
    yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
    var extra = {
      // 水平方向投影
      xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
      // 垂直方向投影
      yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
    };
    return extra;
  }
  function toSymmetry(point6, center2) {
    return [
      center2[0] + (center2[0] - point6[0]),
      center2[1] + (center2[1] - point6[1])
    ];
  }
  var angleBetween3 = function(v0, v1) {
    var p2 = v0.x * v1.x + v0.y * v1.y;
    var n2 = Math.sqrt((Math.pow(v0.x, 2) + Math.pow(v0.y, 2)) * (Math.pow(v1.x, 2) + Math.pow(v1.y, 2)));
    var sign3 = v0.x * v1.y - v0.y * v1.x < 0 ? -1 : 1;
    var angle4 = sign3 * Math.acos(p2 / n2);
    return angle4;
  };
  var pointOnEllipticalArc = function(p0, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, p1, t) {
    rx = Math.abs(rx);
    ry = Math.abs(ry);
    xAxisRotation = mod_default(xAxisRotation, 360);
    var xAxisRotationRadians = deg2rad(xAxisRotation);
    if (p0.x === p1.x && p0.y === p1.y) {
      return { x: p0.x, y: p0.y, ellipticalArcAngle: 0 };
    }
    if (rx === 0 || ry === 0) {
      return { x: 0, y: 0, ellipticalArcAngle: 0 };
    }
    var dx = (p0.x - p1.x) / 2;
    var dy = (p0.y - p1.y) / 2;
    var transformedPoint = {
      x: Math.cos(xAxisRotationRadians) * dx + Math.sin(xAxisRotationRadians) * dy,
      y: -Math.sin(xAxisRotationRadians) * dx + Math.cos(xAxisRotationRadians) * dy
    };
    var radiiCheck = Math.pow(transformedPoint.x, 2) / Math.pow(rx, 2) + Math.pow(transformedPoint.y, 2) / Math.pow(ry, 2);
    if (radiiCheck > 1) {
      rx = Math.sqrt(radiiCheck) * rx;
      ry = Math.sqrt(radiiCheck) * ry;
    }
    var cSquareNumerator = Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) - Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
    var cSquareRootDenom = Math.pow(rx, 2) * Math.pow(transformedPoint.y, 2) + Math.pow(ry, 2) * Math.pow(transformedPoint.x, 2);
    var cRadicand = cSquareNumerator / cSquareRootDenom;
    cRadicand = cRadicand < 0 ? 0 : cRadicand;
    var cCoef = (largeArcFlag !== sweepFlag ? 1 : -1) * Math.sqrt(cRadicand);
    var transformedCenter = {
      x: cCoef * (rx * transformedPoint.y / ry),
      y: cCoef * (-(ry * transformedPoint.x) / rx)
    };
    var center2 = {
      x: Math.cos(xAxisRotationRadians) * transformedCenter.x - Math.sin(xAxisRotationRadians) * transformedCenter.y + (p0.x + p1.x) / 2,
      y: Math.sin(xAxisRotationRadians) * transformedCenter.x + Math.cos(xAxisRotationRadians) * transformedCenter.y + (p0.y + p1.y) / 2
    };
    var startVector = {
      x: (transformedPoint.x - transformedCenter.x) / rx,
      y: (transformedPoint.y - transformedCenter.y) / ry
    };
    var startAngle = angleBetween3({
      x: 1,
      y: 0
    }, startVector);
    var endVector = {
      x: (-transformedPoint.x - transformedCenter.x) / rx,
      y: (-transformedPoint.y - transformedCenter.y) / ry
    };
    var sweepAngle = angleBetween3(startVector, endVector);
    if (!sweepFlag && sweepAngle > 0) {
      sweepAngle -= 2 * Math.PI;
    } else if (sweepFlag && sweepAngle < 0) {
      sweepAngle += 2 * Math.PI;
    }
    sweepAngle %= 2 * Math.PI;
    var angle4 = startAngle + sweepAngle * t;
    var ellipseComponentX = rx * Math.cos(angle4);
    var ellipseComponentY = ry * Math.sin(angle4);
    var point6 = {
      x: Math.cos(xAxisRotationRadians) * ellipseComponentX - Math.sin(xAxisRotationRadians) * ellipseComponentY + center2.x,
      y: Math.sin(xAxisRotationRadians) * ellipseComponentX + Math.cos(xAxisRotationRadians) * ellipseComponentY + center2.y,
      ellipticalArcStartAngle: startAngle,
      ellipticalArcEndAngle: startAngle + sweepAngle,
      ellipticalArcAngle: angle4,
      ellipticalArcCenter: center2,
      resultantRx: rx,
      resultantRy: ry
    };
    return point6;
  };
  function path2Segments(path2) {
    var segments = [];
    var currentPoint = null;
    var nextParams = null;
    var startMovePoint = null;
    var lastStartMovePointIndex = 0;
    var count4 = path2.length;
    for (var i = 0; i < count4; i++) {
      var params = path2[i];
      nextParams = path2[i + 1];
      var command = params[0];
      var segment = {
        command,
        prePoint: currentPoint,
        params,
        startTangent: null,
        endTangent: null,
        currentPoint: null,
        nextPoint: null,
        arcParams: null,
        box: null,
        cubicParams: null
      };
      switch (command) {
        case "M":
          startMovePoint = [params[1], params[2]];
          lastStartMovePointIndex = i;
          break;
        case "A":
          var arcParams = getArcParams(currentPoint, params);
          segment.arcParams = arcParams;
          break;
      }
      if (command === "Z") {
        currentPoint = startMovePoint;
        nextParams = path2[lastStartMovePointIndex + 1];
      } else {
        var len5 = params.length;
        currentPoint = [params[len5 - 2], params[len5 - 1]];
      }
      if (nextParams && nextParams[0] === "Z") {
        nextParams = path2[lastStartMovePointIndex];
        if (segments[lastStartMovePointIndex]) {
          segments[lastStartMovePointIndex].prePoint = currentPoint;
        }
      }
      segment.currentPoint = currentPoint;
      if (segments[lastStartMovePointIndex] && isSamePoint(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
        segments[lastStartMovePointIndex].prePoint = segment.prePoint;
      }
      var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
      segment.nextPoint = nextPoint;
      var prePoint = segment.prePoint;
      if (["L", "H", "V"].includes(command)) {
        segment.startTangent = [
          prePoint[0] - currentPoint[0],
          prePoint[1] - currentPoint[1]
        ];
        segment.endTangent = [
          currentPoint[0] - prePoint[0],
          currentPoint[1] - prePoint[1]
        ];
      } else if (command === "Q") {
        var cp = [params[1], params[2]];
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else if (command === "T") {
        var preSegment = segments[i - 1];
        var cp = toSymmetry(preSegment.currentPoint, prePoint);
        if (preSegment.command === "Q") {
          segment.command = "Q";
          segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
          segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
        } else {
          segment.command = "TL";
          segment.startTangent = [
            prePoint[0] - currentPoint[0],
            prePoint[1] - currentPoint[1]
          ];
          segment.endTangent = [
            currentPoint[0] - prePoint[0],
            currentPoint[1] - prePoint[1]
          ];
        }
      } else if (command === "C") {
        var cp1 = [params[1], params[2]];
        var cp2 = [params[3], params[4]];
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
        if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
          segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
        }
        if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
          segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
        }
      } else if (command === "S") {
        var preSegment = segments[i - 1];
        var cp1 = toSymmetry(preSegment.currentPoint, prePoint);
        var cp2 = [params[1], params[2]];
        if (preSegment.command === "C") {
          segment.command = "C";
          segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
          segment.endTangent = [
            currentPoint[0] - cp2[0],
            currentPoint[1] - cp2[1]
          ];
        } else {
          segment.command = "SQ";
          segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
          segment.endTangent = [
            currentPoint[0] - cp2[0],
            currentPoint[1] - cp2[1]
          ];
        }
      } else if (command === "A") {
        var _a = getTangentAtRatio(segment, 0), dx1 = _a.x, dy1 = _a.y;
        var _b = getTangentAtRatio(segment, 1, false), dx2 = _b.x, dy2 = _b.y;
        segment.startTangent = [dx1, dy1];
        segment.endTangent = [dx2, dy2];
      }
      segments.push(segment);
    }
    return segments;
  }
  function getTangentAtRatio(segment, ratio, sign3) {
    if (sign3 === void 0) {
      sign3 = true;
    }
    var _a = segment.arcParams, _b = _a.rx, rx = _b === void 0 ? 0 : _b, _c = _a.ry, ry = _c === void 0 ? 0 : _c, xRotation = _a.xRotation, arcFlag = _a.arcFlag, sweepFlag = _a.sweepFlag;
    var p1 = pointOnEllipticalArc({ x: segment.prePoint[0], y: segment.prePoint[1] }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, { x: segment.currentPoint[0], y: segment.currentPoint[1] }, ratio);
    var p2 = pointOnEllipticalArc({ x: segment.prePoint[0], y: segment.prePoint[1] }, rx, ry, xRotation, !!arcFlag, !!sweepFlag, { x: segment.currentPoint[0], y: segment.currentPoint[1] }, sign3 ? ratio + 5e-3 : ratio - 5e-3);
    var xDist = p2.x - p1.x;
    var yDist = p2.y - p1.y;
    var dist5 = Math.sqrt(xDist * xDist + yDist * yDist);
    return { x: -xDist / dist5, y: -yDist / dist5 };
  }
  function vMag(v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
  }
  function vRatio(u, v) {
    return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
  }
  function vAngle(u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
  }
  function getArcParams(startPoint, params) {
    var rx = params[1];
    var ry = params[2];
    var xRotation = mod_default(deg2rad(params[3]), Math.PI * 2);
    var arcFlag = params[4];
    var sweepFlag = params[5];
    var x12 = startPoint[0];
    var y12 = startPoint[1];
    var x22 = params[6];
    var y22 = params[7];
    var xp = Math.cos(xRotation) * (x12 - x22) / 2 + Math.sin(xRotation) * (y12 - y22) / 2;
    var yp = -1 * Math.sin(xRotation) * (x12 - x22) / 2 + Math.cos(xRotation) * (y12 - y22) / 2;
    var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
    if (lambda > 1) {
      rx *= Math.sqrt(lambda);
      ry *= Math.sqrt(lambda);
    }
    var diff = rx * rx * (yp * yp) + ry * ry * (xp * xp);
    var f = diff ? Math.sqrt((rx * rx * (ry * ry) - diff) / diff) : 1;
    if (arcFlag === sweepFlag) {
      f *= -1;
    }
    if (isNaN(f)) {
      f = 0;
    }
    var cxp = ry ? f * rx * yp / ry : 0;
    var cyp = rx ? f * -ry * xp / rx : 0;
    var cx = (x12 + x22) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
    var cy = (y12 + y22) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
    var u = [(xp - cxp) / rx, (yp - cyp) / ry];
    var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
    var theta = vAngle([1, 0], u);
    var dTheta = vAngle(u, v);
    if (vRatio(u, v) <= -1) {
      dTheta = Math.PI;
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0;
    }
    if (sweepFlag === 0 && dTheta > 0) {
      dTheta = dTheta - 2 * Math.PI;
    }
    if (sweepFlag === 1 && dTheta < 0) {
      dTheta = dTheta + 2 * Math.PI;
    }
    return {
      cx,
      cy,
      // 弧形的起点和终点相同时，长轴和短轴的长度按 0 处理
      rx: isSamePoint(startPoint, [x22, y22]) ? 0 : rx,
      ry: isSamePoint(startPoint, [x22, y22]) ? 0 : ry,
      startAngle: theta,
      endAngle: theta + dTheta,
      xRotation,
      arcFlag,
      sweepFlag
    };
  }
  function commandsToPathString(commands, object, transform) {
    return commands.reduce(function(prev, cur) {
      var path2 = "";
      if (cur[0] === "M" || cur[0] === "L") {
        var p2 = vec3_exports.fromValues(cur[1], cur[2], 0);
        if (transform) {
          vec3_exports.transformMat4(p2, p2, transform);
        }
        path2 = "".concat(cur[0]).concat(p2[0], ",").concat(p2[1]);
      } else if (cur[0] === "Z") {
        path2 = cur[0];
      } else if (cur[0] === "C") {
        var p1 = vec3_exports.fromValues(cur[1], cur[2], 0);
        var p22 = vec3_exports.fromValues(cur[3], cur[4], 0);
        var p3 = vec3_exports.fromValues(cur[5], cur[6], 0);
        if (transform) {
          vec3_exports.transformMat4(p1, p1, transform);
          vec3_exports.transformMat4(p22, p22, transform);
          vec3_exports.transformMat4(p3, p3, transform);
        }
        path2 = "".concat(cur[0]).concat(p1[0], ",").concat(p1[1], ",").concat(p22[0], ",").concat(p22[1], ",").concat(p3[0], ",").concat(p3[1]);
      } else if (cur[0] === "A") {
        var c5 = vec3_exports.fromValues(cur[6], cur[7], 0);
        if (transform) {
          vec3_exports.transformMat4(c5, c5, transform);
        }
        path2 = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], ",").concat(cur[5], ",").concat(c5[0], ",").concat(c5[1]);
      } else if (cur[0] === "Q") {
        var p1 = vec3_exports.fromValues(cur[1], cur[2], 0);
        var p22 = vec3_exports.fromValues(cur[3], cur[4], 0);
        if (transform) {
          vec3_exports.transformMat4(p1, p1, transform);
          vec3_exports.transformMat4(p22, p22, transform);
        }
        path2 = "".concat(cur[0]).concat(cur[1], ",").concat(cur[2], ",").concat(cur[3], ",").concat(cur[4], "}");
      }
      return prev += path2;
    }, "");
  }
  function lineToCommands(x12, y12, x22, y22) {
    return [
      ["M", x12, y12],
      ["L", x22, y22]
    ];
  }
  function ellipseToCommands(rx, ry, cx, cy) {
    var factor = (-1 + Math.sqrt(2)) / 3 * 4;
    var dx = rx * factor;
    var dy = ry * factor;
    var left2 = cx - rx;
    var right2 = cx + rx;
    var top = cy - ry;
    var bottom = cy + ry;
    return [
      ["M", left2, cy],
      ["C", left2, cy - dy, cx - dx, top, cx, top],
      ["C", cx + dx, top, right2, cy - dy, right2, cy],
      ["C", right2, cy + dy, cx + dx, bottom, cx, bottom],
      ["C", cx - dx, bottom, left2, cy + dy, left2, cy],
      ["Z"]
    ];
  }
  function polygonToCommands(points, closed) {
    var result = points.map(function(point6, i) {
      return [i === 0 ? "M" : "L", point6[0], point6[1]];
    });
    if (closed) {
      result.push(["Z"]);
    }
    return result;
  }
  function rectToCommands(width, height, x3, y3, radius) {
    if (radius) {
      var _a = __read(radius, 4), tlr = _a[0], trr = _a[1], brr = _a[2], blr = _a[3];
      var signX = width > 0 ? 1 : -1;
      var signY = height > 0 ? 1 : -1;
      var sweepFlag = signX + signY !== 0 ? 1 : 0;
      return [
        ["M", signX * tlr + x3, y3],
        ["L", width - signX * trr + x3, y3],
        trr ? ["A", trr, trr, 0, 0, sweepFlag, width + x3, signY * trr + y3] : null,
        ["L", width + x3, height - signY * brr + y3],
        brr ? ["A", brr, brr, 0, 0, sweepFlag, width + x3 - signX * brr, height + y3] : null,
        ["L", x3 + signX * blr, height + y3],
        blr ? ["A", blr, blr, 0, 0, sweepFlag, x3, height + y3 - signY * blr] : null,
        ["L", x3, signY * tlr + y3],
        tlr ? ["A", tlr, tlr, 0, 0, sweepFlag, signX * tlr + x3, y3] : null,
        ["Z"]
      ].filter(function(command) {
        return command;
      });
    }
    return [
      ["M", x3, y3],
      ["L", x3 + width, y3],
      ["L", x3 + width, y3 + height],
      ["L", x3, y3 + height],
      ["Z"]
    ];
  }
  function convertToPath(object, transform) {
    if (transform === void 0) {
      transform = object.getLocalTransform();
    }
    var commands = [];
    switch (object.nodeName) {
      case Shape.LINE:
        var _a = object.parsedStyle, _b = _a.x1, x12 = _b === void 0 ? 0 : _b, _c = _a.y1, y12 = _c === void 0 ? 0 : _c, _d = _a.x2, x22 = _d === void 0 ? 0 : _d, _e = _a.y2, y22 = _e === void 0 ? 0 : _e;
        commands = lineToCommands(x12, y12, x22, y22);
        break;
      case Shape.CIRCLE: {
        var _f = object.parsedStyle, _g = _f.r, r = _g === void 0 ? 0 : _g, _h = _f.cx, cx = _h === void 0 ? 0 : _h, _j = _f.cy, cy = _j === void 0 ? 0 : _j;
        commands = ellipseToCommands(r, r, cx, cy);
        break;
      }
      case Shape.ELLIPSE: {
        var _k = object.parsedStyle, _l = _k.rx, rx = _l === void 0 ? 0 : _l, _m = _k.ry, ry = _m === void 0 ? 0 : _m, _o = _k.cx, cx = _o === void 0 ? 0 : _o, _p = _k.cy, cy = _p === void 0 ? 0 : _p;
        commands = ellipseToCommands(rx, ry, cx, cy);
        break;
      }
      case Shape.POLYLINE:
      case Shape.POLYGON:
        var points = object.parsedStyle.points;
        commands = polygonToCommands(points.points, object.nodeName === Shape.POLYGON);
        break;
      case Shape.RECT:
        var _q = object.parsedStyle, _r = _q.width, width_1 = _r === void 0 ? 0 : _r, _s = _q.height, height_1 = _s === void 0 ? 0 : _s, _t = _q.x, x3 = _t === void 0 ? 0 : _t, _u = _q.y, y3 = _u === void 0 ? 0 : _u, radius = _q.radius;
        var hasRadius = radius && radius.some(function(r2) {
          return r2 !== 0;
        });
        commands = rectToCommands(width_1, height_1, x3, y3, hasRadius && radius.map(function(r2) {
          return clamp_default(r2, 0, Math.min(Math.abs(width_1) / 2, Math.abs(height_1) / 2));
        }));
        break;
      case Shape.PATH:
        var absolutePath = object.parsedStyle.d.absolutePath;
        commands = __spreadArray([], __read(absolutePath), false);
        break;
    }
    if (commands.length) {
      return commandsToPathString(commands, object, transform);
    }
  }
  var internalParsePath = function(path2) {
    if (path2 === "" || Array.isArray(path2) && path2.length === 0) {
      return {
        absolutePath: [],
        hasArc: false,
        segments: [],
        polygons: [],
        polylines: [],
        curve: null,
        totalLength: 0,
        rect: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        }
      };
    }
    var absolutePath;
    try {
      absolutePath = normalizePath(path2);
    } catch (e3) {
      absolutePath = normalizePath("");
      console.error("[g]: Invalid SVG Path definition: ".concat(path2));
    }
    removeRedundantMCommand(absolutePath);
    var hasArc = hasArcOrBezier(absolutePath);
    var _a = extractPolygons(absolutePath), polygons = _a.polygons, polylines = _a.polylines;
    var segments = path2Segments(absolutePath);
    var _b = getPathBBox(segments, 0), x3 = _b.x, y3 = _b.y, width = _b.width, height = _b.height;
    return {
      absolutePath,
      hasArc,
      segments,
      polygons,
      polylines,
      // curve,
      // Delay the calculation of length.
      totalLength: 0,
      rect: {
        x: Number.isFinite(x3) ? x3 : 0,
        y: Number.isFinite(y3) ? y3 : 0,
        width: Number.isFinite(width) ? width : 0,
        height: Number.isFinite(height) ? height : 0
      }
    };
  };
  var memoizedParsePath = memoize(internalParsePath);
  function parsePath(path2) {
    return is_string_default2(path2) ? memoizedParsePath(path2) : internalParsePath(path2);
  }
  function mergePaths(left2, right2, object) {
    var curve1 = left2.curve;
    var curve2 = right2.curve;
    if (!curve1 || curve1.length === 0) {
      curve1 = path2Curve(left2.absolutePath, false);
      left2.curve = curve1;
    }
    if (!curve2 || curve2.length === 0) {
      curve2 = path2Curve(right2.absolutePath, false);
      right2.curve = curve2;
    }
    var curves = [curve1, curve2];
    if (curve1.length !== curve2.length) {
      curves = equalizeSegments(curve1, curve2);
    }
    var curve0 = getDrawDirection(curves[0]) !== getDrawDirection(curves[1]) ? reverseCurve(curves[0]) : clonePath(curves[0]);
    return [
      curve0,
      getRotatedCurve(curves[1], curve0),
      function(pathArray) {
        return pathArray;
      }
    ];
  }
  function parsePoints(pointsOrStr, object) {
    var points;
    if (is_string_default2(pointsOrStr)) {
      points = pointsOrStr.split(" ").map(function(pointStr) {
        var _a = __read(pointStr.split(","), 2), x3 = _a[0], y3 = _a[1];
        return [Number(x3), Number(y3)];
      });
    } else {
      points = pointsOrStr;
    }
    return {
      points,
      totalLength: 0,
      segments: []
    };
  }
  function mergePoints(left2, right2) {
    return [
      left2.points,
      right2.points,
      function(points) {
        return points;
      }
    ];
  }
  var _ = null;
  function cast(pattern) {
    return function(contents) {
      var i = 0;
      return pattern.map(function(x3) {
        return x3 === _ ? contents[i++] : x3;
      });
    };
  }
  function id(x3) {
    return x3;
  }
  var transformFunctions = {
    // @ts-ignore
    matrix: ["NNNNNN", [_, _, 0, 0, _, _, 0, 0, 0, 0, 1, 0, _, _, 0, 1], id],
    matrix3d: ["NNNNNNNNNNNNNNNN", id],
    rotate: ["A"],
    rotatex: ["A"],
    rotatey: ["A"],
    rotatez: ["A"],
    rotate3d: ["NNNA"],
    perspective: ["L"],
    scale: ["Nn", cast([_, _, new CSSUnitValue(1)]), id],
    scalex: [
      "N",
      cast([_, new CSSUnitValue(1), new CSSUnitValue(1)]),
      cast([_, new CSSUnitValue(1)])
    ],
    scaley: [
      "N",
      cast([new CSSUnitValue(1), _, new CSSUnitValue(1)]),
      cast([new CSSUnitValue(1), _])
    ],
    scalez: ["N", cast([new CSSUnitValue(1), new CSSUnitValue(1), _])],
    scale3d: ["NNN", id],
    skew: ["Aa", null, id],
    skewx: ["A", null, cast([_, Odeg])],
    skewy: ["A", null, cast([Odeg, _])],
    translate: ["Tt", cast([_, _, Opx]), id],
    translatex: ["T", cast([_, Opx, Opx]), cast([_, Opx])],
    translatey: ["T", cast([Opx, _, Opx]), cast([Opx, _])],
    translatez: ["L", cast([Opx, Opx, _])],
    translate3d: ["TTL", id]
  };
  function parseTransform(string) {
    string = (string || "none").toLowerCase().trim();
    if (string === "none") {
      return [];
    }
    var transformRegExp = /\s*(\w+)\(([^)]*)\)/g;
    var result = [];
    var match2;
    var prevLastIndex = 0;
    while (match2 = transformRegExp.exec(string)) {
      if (match2.index !== prevLastIndex) {
        return [];
      }
      prevLastIndex = match2.index + match2[0].length;
      var functionName = match2[1];
      var functionData = transformFunctions[functionName];
      if (!functionData) {
        return [];
      }
      var args = match2[2].split(",");
      var argTypes = functionData[0];
      if (argTypes.length < args.length) {
        return [];
      }
      var parsedArgs = [];
      for (var i = 0; i < argTypes.length; i++) {
        var arg = args[i];
        var type = argTypes[i];
        var parsedArg = void 0;
        if (!arg) {
          parsedArg = {
            a: Odeg,
            n: parsedArgs[0],
            t: Opx
          }[type];
        } else {
          parsedArg = {
            A: function(s2) {
              return s2.trim() === "0" ? Odeg : parseAngle(s2);
            },
            N: parseNumber,
            T: parseLengthOrPercentage,
            L: parseLength
          }[type.toUpperCase()](arg);
        }
        if (parsedArg === void 0) {
          return [];
        }
        parsedArgs.push(parsedArg);
      }
      result.push({ t: functionName, d: parsedArgs });
      if (transformRegExp.lastIndex === string.length) {
        return result;
      }
    }
    return [];
  }
  function parseTransformUnmemoize(string) {
    string = (string || "none").toLowerCase().trim();
    if (string === "none") {
      return [];
    }
    var transformRegExp = /\s*(\w+)\(([^)]*)\)/g;
    var result = [];
    var match2;
    var prevLastIndex = 0;
    while (match2 = transformRegExp.exec(string)) {
      if (match2.index !== prevLastIndex) {
        return [];
      }
      prevLastIndex = match2.index + match2[0].length;
      var functionName = match2[1];
      var functionData = transformFunctions[functionName];
      if (!functionData) {
        return [];
      }
      var args = match2[2].split(",");
      var argTypes = functionData[0];
      if (argTypes.length < args.length) {
        return [];
      }
      var parsedArgs = [];
      for (var i = 0; i < argTypes.length; i++) {
        var arg = args[i];
        var type = argTypes[i];
        var parsedArg = void 0;
        if (!arg) {
          parsedArg = {
            a: Odeg,
            n: parsedArgs[0],
            t: Opx
          }[type];
        } else {
          parsedArg = {
            A: function(s2) {
              return s2.trim() === "0" ? Odeg : parseAngleUnmemoize(s2);
            },
            N: parseNumberUnmemoize,
            T: parseLengthOrPercentageUnmemoize,
            L: parseLengthUnmemoize
          }[type.toUpperCase()](arg);
        }
        if (parsedArg === void 0) {
          return [];
        }
        parsedArgs.push(parsedArg);
      }
      result.push({ t: functionName, d: parsedArgs });
      if (transformRegExp.lastIndex === string.length) {
        return result;
      }
    }
    return [];
  }
  function convertItemToMatrix(item) {
    var x3;
    var y3;
    var z;
    var angle4;
    switch (item.t) {
      case "rotatex":
        angle4 = deg2rad(convertAngleUnit(item.d[0]));
        return [
          1,
          0,
          0,
          0,
          0,
          Math.cos(angle4),
          Math.sin(angle4),
          0,
          0,
          -Math.sin(angle4),
          Math.cos(angle4),
          0,
          0,
          0,
          0,
          1
        ];
      case "rotatey":
        angle4 = deg2rad(convertAngleUnit(item.d[0]));
        return [
          Math.cos(angle4),
          0,
          -Math.sin(angle4),
          0,
          0,
          1,
          0,
          0,
          Math.sin(angle4),
          0,
          Math.cos(angle4),
          0,
          0,
          0,
          0,
          1
        ];
      case "rotate":
      case "rotatez":
        angle4 = deg2rad(convertAngleUnit(item.d[0]));
        return [
          Math.cos(angle4),
          Math.sin(angle4),
          0,
          0,
          -Math.sin(angle4),
          Math.cos(angle4),
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
      case "rotate3d":
        x3 = item.d[0].value;
        y3 = item.d[1].value;
        z = item.d[2].value;
        angle4 = deg2rad(convertAngleUnit(item.d[3]));
        var sqrLength = x3 * x3 + y3 * y3 + z * z;
        if (sqrLength === 0) {
          x3 = 1;
          y3 = 0;
          z = 0;
        } else if (sqrLength !== 1) {
          var length_1 = Math.sqrt(sqrLength);
          x3 /= length_1;
          y3 /= length_1;
          z /= length_1;
        }
        var s2 = Math.sin(angle4 / 2);
        var sc = s2 * Math.cos(angle4 / 2);
        var sq = s2 * s2;
        return [
          1 - 2 * (y3 * y3 + z * z) * sq,
          2 * (x3 * y3 * sq + z * sc),
          2 * (x3 * z * sq - y3 * sc),
          0,
          2 * (x3 * y3 * sq - z * sc),
          1 - 2 * (x3 * x3 + z * z) * sq,
          2 * (y3 * z * sq + x3 * sc),
          0,
          2 * (x3 * z * sq + y3 * sc),
          2 * (y3 * z * sq - x3 * sc),
          1 - 2 * (x3 * x3 + y3 * y3) * sq,
          0,
          0,
          0,
          0,
          1
        ];
      case "scale":
        return [
          item.d[0].value,
          0,
          0,
          0,
          0,
          item.d[1].value,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
      case "scalex":
        return [item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "scaley":
        return [1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "scalez":
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, item.d[0].value, 0, 0, 0, 0, 1];
      case "scale3d":
        return [
          item.d[0].value,
          0,
          0,
          0,
          0,
          item.d[1].value,
          0,
          0,
          0,
          0,
          item.d[2].value,
          0,
          0,
          0,
          0,
          1
        ];
      case "skew":
        var xAngle = deg2rad(convertAngleUnit(item.d[0]));
        var yAngle = deg2rad(convertAngleUnit(item.d[1]));
        return [
          1,
          Math.tan(yAngle),
          0,
          0,
          Math.tan(xAngle),
          1,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          1
        ];
      case "skewx":
        angle4 = deg2rad(convertAngleUnit(item.d[0]));
        return [1, 0, 0, 0, Math.tan(angle4), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "skewy":
        angle4 = deg2rad(convertAngleUnit(item.d[0]));
        return [1, Math.tan(angle4), 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      case "translate":
        x3 = convertPercentUnit(item.d[0], 0, null) || 0;
        y3 = convertPercentUnit(item.d[1], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, 0, 1];
      case "translatex":
        x3 = convertPercentUnit(item.d[0], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, 0, 0, 1];
      case "translatey":
        y3 = convertPercentUnit(item.d[0], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, y3, 0, 1];
      case "translatez":
        z = convertPercentUnit(item.d[0], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, z, 1];
      case "translate3d":
        x3 = convertPercentUnit(item.d[0], 0, null) || 0;
        y3 = convertPercentUnit(item.d[1], 0, null) || 0;
        z = convertPercentUnit(item.d[2], 0, null) || 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x3, y3, z, 1];
      case "perspective":
        var t = convertPercentUnit(item.d[0], 0, null) || 0;
        var p2 = t ? -1 / t : 0;
        return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, p2, 0, 0, 0, 1];
      case "matrix":
        return [
          item.d[0].value,
          item.d[1].value,
          0,
          0,
          item.d[2].value,
          item.d[3].value,
          0,
          0,
          0,
          0,
          1,
          0,
          item.d[4].value,
          item.d[5].value,
          0,
          1
        ];
      case "matrix3d":
        return item.d.map(function(d2) {
          return d2.value;
        });
    }
  }
  function multiplyMatrices(a3, b) {
    return [
      a3[0] * b[0] + a3[4] * b[1] + a3[8] * b[2] + a3[12] * b[3],
      a3[1] * b[0] + a3[5] * b[1] + a3[9] * b[2] + a3[13] * b[3],
      a3[2] * b[0] + a3[6] * b[1] + a3[10] * b[2] + a3[14] * b[3],
      a3[3] * b[0] + a3[7] * b[1] + a3[11] * b[2] + a3[15] * b[3],
      a3[0] * b[4] + a3[4] * b[5] + a3[8] * b[6] + a3[12] * b[7],
      a3[1] * b[4] + a3[5] * b[5] + a3[9] * b[6] + a3[13] * b[7],
      a3[2] * b[4] + a3[6] * b[5] + a3[10] * b[6] + a3[14] * b[7],
      a3[3] * b[4] + a3[7] * b[5] + a3[11] * b[6] + a3[15] * b[7],
      a3[0] * b[8] + a3[4] * b[9] + a3[8] * b[10] + a3[12] * b[11],
      a3[1] * b[8] + a3[5] * b[9] + a3[9] * b[10] + a3[13] * b[11],
      a3[2] * b[8] + a3[6] * b[9] + a3[10] * b[10] + a3[14] * b[11],
      a3[3] * b[8] + a3[7] * b[9] + a3[11] * b[10] + a3[15] * b[11],
      a3[0] * b[12] + a3[4] * b[13] + a3[8] * b[14] + a3[12] * b[15],
      a3[1] * b[12] + a3[5] * b[13] + a3[9] * b[14] + a3[13] * b[15],
      a3[2] * b[12] + a3[6] * b[13] + a3[10] * b[14] + a3[14] * b[15],
      a3[3] * b[12] + a3[7] * b[13] + a3[11] * b[14] + a3[15] * b[15]
    ];
  }
  function convertToMatrix(transformList) {
    if (transformList.length === 0) {
      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
    }
    return transformList.map(convertItemToMatrix).reduce(multiplyMatrices);
  }
  function makeMatrixDecomposition(transformList) {
    var translate3 = [0, 0, 0];
    var scale9 = [1, 1, 1];
    var skew = [0, 0, 0];
    var perspective2 = [0, 0, 0, 1];
    var quaternion = [0, 0, 0, 1];
    decomposeMat4(
      // @ts-ignore
      convertToMatrix(transformList),
      translate3,
      scale9,
      skew,
      perspective2,
      quaternion
    );
    return [[translate3, scale9, skew, quaternion, perspective2]];
  }
  var composeMatrix = /* @__PURE__ */ function() {
    function multiply7(a3, b) {
      var result = [
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ];
      for (var i = 0; i < 4; i++) {
        for (var j = 0; j < 4; j++) {
          for (var k = 0; k < 4; k++) {
            result[i][j] += b[i][k] * a3[k][j];
          }
        }
      }
      return result;
    }
    function is2D(m3) {
      return m3[0][2] == 0 && m3[0][3] == 0 && m3[1][2] == 0 && m3[1][3] == 0 && m3[2][0] == 0 && m3[2][1] == 0 && m3[2][2] == 1 && m3[2][3] == 0 && m3[3][2] == 0 && m3[3][3] == 1;
    }
    function composeMatrix2(translate3, scale9, skew, quat2, perspective2) {
      var matrix2 = [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
      ];
      for (var i = 0; i < 4; i++) {
        matrix2[i][3] = perspective2[i];
      }
      for (var i = 0; i < 3; i++) {
        for (var j = 0; j < 3; j++) {
          matrix2[3][i] += translate3[j] * matrix2[j][i];
        }
      }
      var x3 = quat2[0], y3 = quat2[1], z = quat2[2], w = quat2[3];
      var rotMatrix = [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
      ];
      rotMatrix[0][0] = 1 - 2 * (y3 * y3 + z * z);
      rotMatrix[0][1] = 2 * (x3 * y3 - z * w);
      rotMatrix[0][2] = 2 * (x3 * z + y3 * w);
      rotMatrix[1][0] = 2 * (x3 * y3 + z * w);
      rotMatrix[1][1] = 1 - 2 * (x3 * x3 + z * z);
      rotMatrix[1][2] = 2 * (y3 * z - x3 * w);
      rotMatrix[2][0] = 2 * (x3 * z - y3 * w);
      rotMatrix[2][1] = 2 * (y3 * z + x3 * w);
      rotMatrix[2][2] = 1 - 2 * (x3 * x3 + y3 * y3);
      matrix2 = multiply7(matrix2, rotMatrix);
      var temp = [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
      ];
      if (skew[2]) {
        temp[2][1] = skew[2];
        matrix2 = multiply7(matrix2, temp);
      }
      if (skew[1]) {
        temp[2][1] = 0;
        temp[2][0] = skew[0];
        matrix2 = multiply7(matrix2, temp);
      }
      if (skew[0]) {
        temp[2][0] = 0;
        temp[1][0] = skew[0];
        matrix2 = multiply7(matrix2, temp);
      }
      for (var i = 0; i < 3; i++) {
        for (var j = 0; j < 3; j++) {
          matrix2[i][j] *= scale9[i];
        }
      }
      if (is2D(matrix2)) {
        return [
          matrix2[0][0],
          matrix2[0][1],
          matrix2[1][0],
          matrix2[1][1],
          matrix2[3][0],
          matrix2[3][1]
        ];
      }
      return matrix2[0].concat(matrix2[1], matrix2[2], matrix2[3]);
    }
    return composeMatrix2;
  }();
  function numberToLongString(x3) {
    return x3.toFixed(6).replace(".000000", "");
  }
  function mergeMatrices(left2, right2) {
    var leftArgs;
    var rightArgs;
    if (left2.decompositionPair !== right2) {
      left2.decompositionPair = right2;
      leftArgs = makeMatrixDecomposition(left2);
    }
    if (right2.decompositionPair !== left2) {
      right2.decompositionPair = left2;
      rightArgs = makeMatrixDecomposition(right2);
    }
    if (leftArgs[0] === null || rightArgs[0] === null)
      return [
        // @ts-ignore
        [false],
        // @ts-ignore
        [true],
        // @ts-ignore
        function(x3) {
          return x3 ? right2[0].d : left2[0].d;
        }
      ];
    leftArgs[0].push(0);
    rightArgs[0].push(1);
    return [
      leftArgs,
      rightArgs,
      // @ts-ignore
      function(list) {
        var q = quat(leftArgs[0][3], rightArgs[0][3], list[5]);
        var mat = composeMatrix(list[0], list[1], list[2], q, list[4]);
        var stringifiedArgs = mat.map(numberToLongString).join(",");
        return stringifiedArgs;
      }
    ];
  }
  function dot5(v1, v2) {
    var result = 0;
    for (var i = 0; i < v1.length; i++) {
      result += v1[i] * v2[i];
    }
    return result;
  }
  function quat(fromQ, toQ, f) {
    var product = dot5(fromQ, toQ);
    product = clamp_default(product, -1, 1);
    var quat2 = [];
    if (product === 1) {
      quat2 = fromQ;
    } else {
      var theta = Math.acos(product);
      var w = Math.sin(f * theta) * 1 / Math.sqrt(1 - product * product);
      for (var i = 0; i < 4; i++) {
        quat2.push(fromQ[i] * (Math.cos(f * theta) - product * w) + toQ[i] * w);
      }
    }
    return quat2;
  }
  function typeTo2D(type) {
    return type.replace(/[xy]/, "");
  }
  function typeTo3D(type) {
    return type.replace(/(x|y|z|3d)?$/, "3d");
  }
  var isMatrixOrPerspective = function(lt, rt) {
    return lt === "perspective" && rt === "perspective" || (lt === "matrix" || lt === "matrix3d") && (rt === "matrix" || rt === "matrix3d");
  };
  function mergeTransforms(left2, right2, target) {
    var flipResults = false;
    if (!left2.length || !right2.length) {
      if (!left2.length) {
        flipResults = true;
        left2 = right2;
        right2 = [];
      }
      var _loop_1 = function(i2) {
        var _a = left2[i2], type2 = _a.t, args = _a.d;
        var defaultValue = type2.substring(0, 5) === "scale" ? 1 : 0;
        right2.push({
          t: type2,
          d: args.map(function(arg) {
            if (typeof arg === "number") {
              return getOrCreateUnitValue(defaultValue);
            }
            return getOrCreateUnitValue(defaultValue, arg.unit);
          })
        });
      };
      for (var i = 0; i < left2.length; i++) {
        _loop_1(i);
      }
    }
    var leftResult = [];
    var rightResult = [];
    var types = [];
    if (left2.length !== right2.length) {
      var merged = mergeMatrices(left2, right2);
      leftResult = [merged[0]];
      rightResult = [merged[1]];
      types = [["matrix", [merged[2]]]];
    } else {
      for (var i = 0; i < left2.length; i++) {
        var leftType = left2[i].t;
        var rightType = right2[i].t;
        var leftArgs = left2[i].d;
        var rightArgs = right2[i].d;
        var leftFunctionData = transformFunctions[leftType];
        var rightFunctionData = transformFunctions[rightType];
        var type = void 0;
        if (isMatrixOrPerspective(leftType, rightType)) {
          var merged = mergeMatrices([left2[i]], [right2[i]]);
          leftResult.push(merged[0]);
          rightResult.push(merged[1]);
          types.push(["matrix", [merged[2]]]);
          continue;
        } else if (leftType === rightType) {
          type = leftType;
        } else if (leftFunctionData[2] && rightFunctionData[2] && typeTo2D(leftType) === typeTo2D(rightType)) {
          type = typeTo2D(leftType);
          leftArgs = leftFunctionData[2](leftArgs);
          rightArgs = rightFunctionData[2](rightArgs);
        } else if (leftFunctionData[1] && rightFunctionData[1] && typeTo3D(leftType) === typeTo3D(rightType)) {
          type = typeTo3D(leftType);
          leftArgs = leftFunctionData[1](leftArgs);
          rightArgs = rightFunctionData[1](rightArgs);
        } else {
          var merged = mergeMatrices(left2, right2);
          leftResult = [merged[0]];
          rightResult = [merged[1]];
          types = [["matrix", [merged[2]]]];
          break;
        }
        var leftArgsCopy = [];
        var rightArgsCopy = [];
        var stringConversions = [];
        for (var j = 0; j < leftArgs.length; j++) {
          var merged = mergeDimensions(leftArgs[j], rightArgs[j], target, false, j);
          leftArgsCopy[j] = merged[0];
          rightArgsCopy[j] = merged[1];
          stringConversions.push(merged[2]);
        }
        leftResult.push(leftArgsCopy);
        rightResult.push(rightArgsCopy);
        types.push([type, stringConversions]);
      }
    }
    if (flipResults) {
      var tmp2 = leftResult;
      leftResult = rightResult;
      rightResult = tmp2;
    }
    return [
      leftResult,
      rightResult,
      function(list) {
        return list.map(function(args, i2) {
          var stringifiedArgs = args.map(function(arg, j2) {
            return types[i2][1][j2](arg);
          }).join(",");
          if (types[i2][0] === "matrix" && stringifiedArgs.split(",").length === 16) {
            types[i2][0] = "matrix3d";
          }
          if (types[i2][0] === "matrix3d" && stringifiedArgs.split(",").length === 6) {
            types[i2][0] = "matrix";
          }
          return types[i2][0] + "(" + stringifiedArgs + ")";
        }).join(" ");
      }
    ];
  }
  var parseTransformOrigin = memoize(function(value2) {
    if (is_string_default2(value2)) {
      if (value2 === "text-anchor") {
        return [getOrCreateUnitValue(0, "px"), getOrCreateUnitValue(0, "px")];
      }
      var values = value2.split(" ");
      if (values.length === 1) {
        if (values[0] === "top" || values[0] === "bottom") {
          values[1] = values[0];
          values[0] = "center";
        } else {
          values[1] = "center";
        }
      }
      if (values.length !== 2) {
        return null;
      }
      return [
        parseLengthOrPercentage(convertKeyword2Percent(values[0])),
        parseLengthOrPercentage(convertKeyword2Percent(values[1]))
      ];
    } else {
      return [
        getOrCreateUnitValue(value2[0] || 0, "px"),
        getOrCreateUnitValue(value2[1] || 0, "px")
      ];
    }
  });
  var parseTransformOriginUnmemoize = function(value2) {
    if (is_string_default2(value2)) {
      if (value2 === "text-anchor") {
        return [getOrCreateUnitValue(0, "px"), getOrCreateUnitValue(0, "px")];
      }
      var values = value2.split(" ");
      if (values.length === 1) {
        if (values[0] === "top" || values[0] === "bottom") {
          values[1] = values[0];
          values[0] = "center";
        } else {
          values[1] = "center";
        }
      }
      if (values.length !== 2) {
        return null;
      }
      return [
        parseLengthOrPercentageUnmemoize(convertKeyword2Percent(values[0])),
        parseLengthOrPercentageUnmemoize(convertKeyword2Percent(values[1]))
      ];
    } else {
      return [
        getOrCreateUnitValue(value2[0] || 0, "px"),
        getOrCreateUnitValue(value2[1] || 0, "px")
      ];
    }
  };
  function convertKeyword2Percent(keyword) {
    if (keyword === "center") {
      return "50%";
    } else if (keyword === "left" || keyword === "top") {
      return "0%";
    } else if (keyword === "right" || keyword === "bottom") {
      return "100%";
    }
    return keyword;
  }
  var BUILT_IN_PROPERTIES = [
    {
      /**
       * used in CSS Layout API
       * eg. `display: 'flex'`
       */
      n: "display",
      k: ["none"]
    },
    {
      /**
       * range [0.0, 1.0]
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/opacity
       */
      n: "opacity",
      int: true,
      inh: true,
      d: "1",
      syntax: PropertySyntax.OPACITY_VALUE
    },
    {
      /**
       * inheritable, range [0.0, 1.0]
       * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-opacity
       * @see https://svgwg.org/svg2-draft/painting.html#FillOpacity
       */
      n: "fillOpacity",
      int: true,
      inh: true,
      d: "1",
      syntax: PropertySyntax.OPACITY_VALUE
    },
    {
      /**
       * inheritable, range [0.0, 1.0]
       * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-opacity
       * @see https://svgwg.org/svg2-draft/painting.html#StrokeOpacity
       */
      n: "strokeOpacity",
      int: true,
      inh: true,
      d: "1",
      syntax: PropertySyntax.OPACITY_VALUE
    },
    {
      /**
       * background-color is not inheritable
       * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Fills_and_Strokes
       */
      n: "fill",
      int: true,
      k: ["none"],
      d: "none",
      syntax: PropertySyntax.PAINT
    },
    {
      n: "fillRule",
      k: ["nonzero", "evenodd"],
      d: "nonzero"
    },
    /**
     * default to none
     * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke#usage_notes
     */
    {
      n: "stroke",
      int: true,
      k: ["none"],
      d: "none",
      syntax: PropertySyntax.PAINT,
      /**
       * Stroke 'none' won't affect geometry but others will.
       */
      l: true
    },
    {
      n: "shadowType",
      k: ["inner", "outer", "both"],
      d: "outer",
      l: true
    },
    {
      n: "shadowColor",
      int: true,
      syntax: PropertySyntax.COLOR
    },
    {
      n: "shadowOffsetX",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "shadowOffsetY",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "shadowBlur",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.SHADOW_BLUR
    },
    {
      /**
       * @see https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/stroke-width
       */
      n: "lineWidth",
      int: true,
      inh: true,
      d: "1",
      l: true,
      a: ["strokeWidth"],
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "increasedLineWidthForHitTesting",
      inh: true,
      d: "0",
      l: true,
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "lineJoin",
      inh: true,
      l: true,
      a: ["strokeLinejoin"],
      k: ["miter", "bevel", "round"],
      d: "miter"
    },
    {
      n: "lineCap",
      inh: true,
      l: true,
      a: ["strokeLinecap"],
      k: ["butt", "round", "square"],
      d: "butt"
    },
    {
      n: "lineDash",
      int: true,
      inh: true,
      k: ["none"],
      a: ["strokeDasharray"],
      syntax: PropertySyntax.LENGTH_PERCENTAGE_12
    },
    {
      n: "lineDashOffset",
      int: true,
      inh: true,
      d: "0",
      a: ["strokeDashoffset"],
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "offsetPath",
      syntax: PropertySyntax.DEFINED_PATH
    },
    {
      n: "offsetDistance",
      int: true,
      syntax: PropertySyntax.OFFSET_DISTANCE
    },
    {
      n: "dx",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "dy",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "zIndex",
      ind: true,
      int: true,
      d: "0",
      k: ["auto"],
      syntax: PropertySyntax.Z_INDEX
    },
    {
      n: "visibility",
      k: ["visible", "hidden"],
      ind: true,
      inh: true,
      /**
       * support interpolation
       * @see https://developer.mozilla.org/en-US/docs/Web/CSS/visibility#interpolation
       */
      int: true,
      d: "visible"
    },
    {
      n: "pointerEvents",
      inh: true,
      k: [
        "none",
        "auto",
        "stroke",
        "fill",
        "painted",
        "visible",
        "visiblestroke",
        "visiblefill",
        "visiblepainted",
        // 'bounding-box',
        "all"
      ],
      d: "auto"
    },
    {
      n: "filter",
      ind: true,
      l: true,
      k: ["none"],
      d: "none",
      syntax: PropertySyntax.FILTER
    },
    {
      n: "clipPath",
      syntax: PropertySyntax.DEFINED_PATH
    },
    {
      n: "textPath",
      syntax: PropertySyntax.DEFINED_PATH
    },
    {
      n: "textPathSide",
      k: ["left", "right"],
      d: "left"
    },
    {
      n: "textPathStartOffset",
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "transform",
      p: 100,
      int: true,
      k: ["none"],
      d: "none",
      syntax: PropertySyntax.TRANSFORM
    },
    {
      n: "transformOrigin",
      p: 100,
      d: "0 0",
      // // int: true,
      // d: (nodeName: string) => {
      //   if (nodeName === Shape.CIRCLE || nodeName === Shape.ELLIPSE) {
      //     return 'center';
      //   }
      //   if (nodeName === Shape.TEXT) {
      //     return 'text-anchor';
      //   }
      //   return 'left top';
      // },
      l: true,
      syntax: PropertySyntax.TRANSFORM_ORIGIN
    },
    {
      n: "cx",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "cy",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "cz",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "r",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "rx",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "ry",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    // Rect Image Group
    {
      // x in local space
      n: "x",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      // y in local space
      n: "y",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      // z in local space
      n: "z",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "width",
      int: true,
      l: true,
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/width
       */
      k: ["auto", "fit-content", "min-content", "max-content"],
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "height",
      int: true,
      l: true,
      /**
       * @see https://developer.mozilla.org/zh-CN/docs/Web/CSS/height
       */
      k: ["auto", "fit-content", "min-content", "max-content"],
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "radius",
      int: true,
      l: true,
      d: "0",
      syntax: PropertySyntax.LENGTH_PERCENTAGE_14
    },
    // Line
    {
      n: "x1",
      int: true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "y1",
      int: true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "z1",
      int: true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "x2",
      int: true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "y2",
      int: true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    {
      n: "z2",
      int: true,
      l: true,
      syntax: PropertySyntax.COORDINATE
    },
    // Path
    {
      n: "d",
      int: true,
      l: true,
      d: "",
      syntax: PropertySyntax.PATH,
      p: 50
    },
    // Polyline & Polygon
    {
      n: "points",
      /**
       * support interpolation
       */
      int: true,
      l: true,
      syntax: PropertySyntax.LIST_OF_POINTS,
      p: 50
    },
    // Text
    {
      n: "text",
      l: true,
      d: "",
      syntax: PropertySyntax.TEXT,
      p: 50
    },
    {
      n: "textTransform",
      l: true,
      inh: true,
      k: ["capitalize", "uppercase", "lowercase", "none"],
      d: "none",
      syntax: PropertySyntax.TEXT_TRANSFORM,
      p: 51
      // it must get parsed after text
    },
    {
      n: "font",
      l: true
    },
    {
      n: "fontSize",
      int: true,
      inh: true,
      /**
       * @see https://www.w3schools.com/css/css_font_size.asp
       */
      d: "16px",
      l: true,
      syntax: PropertySyntax.LENGTH_PERCENTAGE
    },
    {
      n: "fontFamily",
      l: true,
      inh: true,
      d: "sans-serif"
    },
    {
      n: "fontStyle",
      l: true,
      inh: true,
      k: ["normal", "italic", "oblique"],
      d: "normal"
    },
    {
      n: "fontWeight",
      l: true,
      inh: true,
      k: ["normal", "bold", "bolder", "lighter"],
      d: "normal"
    },
    {
      n: "fontVariant",
      l: true,
      inh: true,
      k: ["normal", "small-caps"],
      d: "normal"
    },
    {
      n: "lineHeight",
      l: true,
      syntax: PropertySyntax.LENGTH,
      int: true,
      d: "0"
    },
    {
      n: "letterSpacing",
      l: true,
      syntax: PropertySyntax.LENGTH,
      int: true,
      d: "0"
    },
    {
      n: "miterLimit",
      l: true,
      syntax: PropertySyntax.NUMBER,
      d: function(nodeName) {
        if (nodeName === Shape.PATH || nodeName === Shape.POLYGON || nodeName === Shape.POLYLINE) {
          return "4";
        }
        return "10";
      }
    },
    {
      n: "wordWrap",
      l: true
    },
    {
      n: "wordWrapWidth",
      l: true
    },
    {
      n: "maxLines",
      l: true
    },
    {
      n: "textOverflow",
      l: true,
      d: "clip"
    },
    {
      n: "leading",
      l: true
    },
    {
      n: "textBaseline",
      l: true,
      inh: true,
      k: ["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"],
      d: "alphabetic"
    },
    {
      n: "textAlign",
      l: true,
      inh: true,
      k: ["start", "center", "middle", "end", "left", "right"],
      d: "start"
    },
    // {
    //   n: 'whiteSpace',
    //   l: true,
    // },
    {
      n: "markerStart",
      syntax: PropertySyntax.MARKER
    },
    {
      n: "markerEnd",
      syntax: PropertySyntax.MARKER
    },
    {
      n: "markerMid",
      syntax: PropertySyntax.MARKER
    },
    {
      n: "markerStartOffset",
      syntax: PropertySyntax.LENGTH,
      l: true,
      int: true,
      d: "0"
    },
    {
      n: "markerEndOffset",
      syntax: PropertySyntax.LENGTH,
      l: true,
      int: true,
      d: "0"
    }
  ];
  var GEOMETRY_ATTRIBUTE_NAMES = BUILT_IN_PROPERTIES.filter(function(n2) {
    return !!n2.l;
  }).map(function(n2) {
    return n2.n;
  });
  var propertyMetadataCache = {};
  var unresolvedProperties = /* @__PURE__ */ new WeakMap();
  var isPropertyResolved = function(object, name2) {
    var properties = unresolvedProperties.get(object);
    if (!properties || properties.length === 0) {
      return true;
    }
    return properties.includes(name2);
  };
  var DefaultStyleValueRegistry = (
    /** @class */
    function() {
      function DefaultStyleValueRegistry2(runtime2) {
        var _this = this;
        this.runtime = runtime2;
        BUILT_IN_PROPERTIES.forEach(function(property) {
          _this.registerMetadata(property);
        });
      }
      DefaultStyleValueRegistry2.prototype.registerMetadata = function(metadata) {
        __spreadArray([metadata.n], __read(metadata.a || []), false).forEach(function(name2) {
          propertyMetadataCache[name2] = metadata;
        });
      };
      DefaultStyleValueRegistry2.prototype.unregisterMetadata = function(name2) {
        delete propertyMetadataCache[name2];
      };
      DefaultStyleValueRegistry2.prototype.getPropertySyntax = function(syntax) {
        return this.runtime.CSSPropertySyntaxFactory[syntax];
      };
      DefaultStyleValueRegistry2.prototype.processProperties = function(object, attributes, options) {
        var _this = this;
        if (options === void 0) {
          options = {
            skipUpdateAttribute: false,
            skipParse: false,
            forceUpdateGeometry: false,
            usedAttributes: [],
            memoize: true
          };
        }
        if (!this.runtime.enableCSSParsing) {
          Object.assign(object.attributes, attributes);
          var attributeNames = Object.keys(attributes);
          var oldClipPath = object.parsedStyle.clipPath;
          var oldOffsetPath = object.parsedStyle.offsetPath;
          object.parsedStyle = Object.assign(object.parsedStyle, attributes);
          var needUpdateGeometry = !!options.forceUpdateGeometry;
          if (!needUpdateGeometry) {
            for (var i = 0; i < GEOMETRY_ATTRIBUTE_NAMES.length; i++) {
              if (GEOMETRY_ATTRIBUTE_NAMES[i] in attributes) {
                needUpdateGeometry = true;
                break;
              }
            }
          }
          if (attributes.fill) {
            object.parsedStyle.fill = parseColor(attributes.fill);
          }
          if (attributes.stroke) {
            object.parsedStyle.stroke = parseColor(attributes.stroke);
          }
          if (attributes.shadowColor) {
            object.parsedStyle.shadowColor = parseColor(attributes.shadowColor);
          }
          if (attributes.filter) {
            object.parsedStyle.filter = parseFilter(attributes.filter);
          }
          if (!is_nil_default2(attributes.radius)) {
            object.parsedStyle.radius = parseDimensionArrayFormat(
              // @ts-ignore
              attributes.radius,
              4
            );
          }
          if (!is_nil_default2(attributes.lineDash)) {
            object.parsedStyle.lineDash = parseDimensionArrayFormat(attributes.lineDash, 2);
          }
          if (attributes.points) {
            object.parsedStyle.points = parsePoints(attributes.points);
          }
          if (attributes.d === "") {
            object.parsedStyle.d = __assign({}, EMPTY_PARSED_PATH);
          }
          if (attributes.d) {
            object.parsedStyle.d = parsePath(
              // @ts-ignore
              attributes.d
            );
          }
          if (attributes.textTransform) {
            this.runtime.CSSPropertySyntaxFactory["<text-transform>"].calculator(null, null, { value: attributes.textTransform }, object, null);
          }
          if (!is_undefined_default2(attributes.clipPath)) {
            this.runtime.CSSPropertySyntaxFactory["<defined-path>"].calculator("clipPath", oldClipPath, attributes.clipPath, object, this.runtime);
          }
          if (attributes.offsetPath) {
            this.runtime.CSSPropertySyntaxFactory["<defined-path>"].calculator("offsetPath", oldOffsetPath, attributes.offsetPath, object, this.runtime);
          }
          if (attributes.transform) {
            object.parsedStyle.transform = parseTransform(attributes.transform);
          }
          if (attributes.transformOrigin) {
            object.parsedStyle.transformOrigin = parseTransformOrigin(attributes.transformOrigin);
          }
          if (attributes.markerStart) {
            object.parsedStyle.markerStart = this.runtime.CSSPropertySyntaxFactory["<marker>"].calculator(
              null,
              // @ts-ignore
              attributes.markerStart,
              // @ts-ignore
              attributes.markerStart,
              null,
              null
            );
          }
          if (attributes.markerEnd) {
            object.parsedStyle.markerEnd = this.runtime.CSSPropertySyntaxFactory["<marker>"].calculator(
              null,
              // @ts-ignore
              attributes.markerEnd,
              // @ts-ignore
              attributes.markerEnd,
              null,
              null
            );
          }
          if (attributes.markerMid) {
            object.parsedStyle.markerMid = this.runtime.CSSPropertySyntaxFactory["<marker>"].calculator(
              "",
              // @ts-ignore
              attributes.markerMid,
              // @ts-ignore
              attributes.markerMid,
              null,
              null
            );
          }
          if (!is_nil_default2(attributes.zIndex)) {
            this.runtime.CSSPropertySyntaxFactory["<z-index>"].postProcessor(object, attributeNames);
          }
          if (!is_nil_default2(attributes.offsetDistance)) {
            this.runtime.CSSPropertySyntaxFactory["<offset-distance>"].postProcessor(object, attributeNames);
          }
          if (attributes.transform) {
            this.runtime.CSSPropertySyntaxFactory["<transform>"].postProcessor(object, attributeNames);
          }
          if (attributes.transformOrigin) {
            this.runtime.CSSPropertySyntaxFactory["<transform-origin>"].postProcessor(object, attributeNames);
          }
          if (needUpdateGeometry) {
            object.geometry.dirty = true;
            object.renderable.boundsDirty = true;
            object.renderable.renderBoundsDirty = true;
            if (!options.forceUpdateGeometry) {
              this.runtime.sceneGraphService.dirtifyToRoot(object);
            }
          }
        } else {
          var skipUpdateAttribute_1 = options.skipUpdateAttribute, skipParse = options.skipParse, forceUpdateGeometry = options.forceUpdateGeometry, usedAttributes = options.usedAttributes, memoize_1 = options.memoize;
          var needUpdateGeometry_1 = forceUpdateGeometry;
          var attributeNames_1 = Object.keys(attributes);
          attributeNames_1.forEach(function(attributeName) {
            var _a;
            if (!skipUpdateAttribute_1) {
              object.attributes[attributeName] = attributes[attributeName];
            }
            if (!needUpdateGeometry_1 && ((_a = propertyMetadataCache[attributeName]) === null || _a === void 0 ? void 0 : _a.l)) {
              needUpdateGeometry_1 = true;
            }
          });
          if (!skipParse) {
            attributeNames_1.forEach(function(name2) {
              object.computedStyle[name2] = _this.parseProperty(name2, object.attributes[name2], object, memoize_1);
            });
          }
          if (usedAttributes === null || usedAttributes === void 0 ? void 0 : usedAttributes.length) {
            attributeNames_1 = Array.from(new Set(attributeNames_1.concat(usedAttributes)));
          }
          attributeNames_1.forEach(function(name2) {
            if (name2 in object.computedStyle) {
              object.parsedStyle[name2] = _this.computeProperty(name2, object.computedStyle[name2], object, memoize_1);
            }
          });
          if (needUpdateGeometry_1) {
            object.geometry.dirty = true;
            object.renderable.boundsDirty = true;
            object.renderable.renderBoundsDirty = true;
            if (!options.forceUpdateGeometry) {
              this.runtime.sceneGraphService.dirtifyToRoot(object);
            }
          }
          attributeNames_1.forEach(function(name2) {
            if (name2 in object.parsedStyle) {
              _this.postProcessProperty(name2, object, attributeNames_1);
            }
          });
          if (this.runtime.enableCSSParsing && object.children.length) {
            attributeNames_1.forEach(function(name2) {
              if (name2 in object.parsedStyle && _this.isPropertyInheritable(name2)) {
                object.children.forEach(function(child) {
                  child.internalSetAttribute(name2, null, {
                    skipUpdateAttribute: true,
                    skipParse: true
                  });
                });
              }
            });
          }
        }
      };
      DefaultStyleValueRegistry2.prototype.parseProperty = function(name2, value2, object, memoized) {
        var metadata = propertyMetadataCache[name2];
        var computed = value2;
        if (value2 === "" || is_nil_default2(value2)) {
          value2 = "unset";
        }
        if (value2 === "unset" || value2 === "initial" || value2 === "inherit") {
          computed = getOrCreateKeyword(value2);
        } else {
          if (metadata) {
            var keywords = metadata.k, syntax = metadata.syntax;
            var handler = syntax && this.getPropertySyntax(syntax);
            if (keywords && keywords.indexOf(value2) > -1) {
              computed = getOrCreateKeyword(value2);
            } else if (handler) {
              if (!memoized && handler.parserUnmemoize) {
                computed = handler.parserUnmemoize(value2, object);
              } else if (handler.parser) {
                computed = handler.parser(value2, object);
              }
            }
          }
        }
        return computed;
      };
      DefaultStyleValueRegistry2.prototype.computeProperty = function(name2, computed, object, memoized) {
        var metadata = propertyMetadataCache[name2];
        var isDocumentElement = object.id === "g-root";
        var used = computed;
        if (metadata) {
          var syntax = metadata.syntax, inherited = metadata.inh, defaultValue = metadata.d;
          if (computed instanceof CSSKeywordValue) {
            var value2 = computed.value;
            if (value2 === "unset") {
              if (inherited && !isDocumentElement) {
                value2 = "inherit";
              } else {
                value2 = "initial";
              }
            }
            if (value2 === "initial") {
              if (!is_nil_default2(defaultValue)) {
                computed = this.parseProperty(name2, isFunction(defaultValue) ? defaultValue(object.nodeName) : defaultValue, object, memoized);
              }
            } else if (value2 === "inherit") {
              var resolved = this.tryToResolveProperty(object, name2, {
                inherited: true
              });
              if (!is_nil_default2(resolved)) {
                return resolved;
              } else {
                this.addUnresolveProperty(object, name2);
                return;
              }
            }
          }
          var handler = syntax && this.getPropertySyntax(syntax);
          if (handler && handler.calculator) {
            var oldParsedValue = object.parsedStyle[name2];
            used = handler.calculator(name2, oldParsedValue, computed, object, this.runtime);
          } else if (computed instanceof CSSKeywordValue) {
            used = computed.value;
          } else {
            used = computed;
          }
        }
        return used;
      };
      DefaultStyleValueRegistry2.prototype.postProcessProperty = function(name2, object, attributes) {
        var metadata = propertyMetadataCache[name2];
        if (metadata && metadata.syntax) {
          var handler = metadata.syntax && this.getPropertySyntax(metadata.syntax);
          var propertyHandler = handler;
          if (propertyHandler && propertyHandler.postProcessor) {
            propertyHandler.postProcessor(object, attributes);
          }
        }
      };
      DefaultStyleValueRegistry2.prototype.addUnresolveProperty = function(object, name2) {
        var properties = unresolvedProperties.get(object);
        if (!properties) {
          unresolvedProperties.set(object, []);
          properties = unresolvedProperties.get(object);
        }
        if (properties.indexOf(name2) === -1) {
          properties.push(name2);
        }
      };
      DefaultStyleValueRegistry2.prototype.tryToResolveProperty = function(object, name2, options) {
        if (options === void 0) {
          options = {};
        }
        var inherited = options.inherited;
        if (inherited) {
          if (object.parentElement && isPropertyResolved(object.parentElement, name2)) {
            var usedValue = object.parentElement.parsedStyle[name2];
            if (
              // usedValue instanceof CSSKeywordValue &&
              usedValue === "unset" || usedValue === "initial" || usedValue === "inherit"
            ) {
              return;
            }
            return usedValue;
          }
        }
        return;
      };
      DefaultStyleValueRegistry2.prototype.recalc = function(object) {
        var properties = unresolvedProperties.get(object);
        if (properties && properties.length) {
          var attributes_1 = {};
          properties.forEach(function(property) {
            attributes_1[property] = object.attributes[property];
          });
          this.processProperties(object, attributes_1);
          unresolvedProperties.delete(object);
        }
      };
      DefaultStyleValueRegistry2.prototype.updateGeometry = function(object) {
        var nodeName = object.nodeName;
        var geometryUpdater = this.runtime.geometryUpdaterFactory[nodeName];
        if (geometryUpdater) {
          var geometry_1 = object.geometry;
          if (!geometry_1.contentBounds) {
            geometry_1.contentBounds = new AABB();
          }
          if (!geometry_1.renderBounds) {
            geometry_1.renderBounds = new AABB();
          }
          var parsedStyle = object.parsedStyle;
          var _a = geometryUpdater.update(parsedStyle, object), _b = _a.cx, cx = _b === void 0 ? 0 : _b, _c = _a.cy, cy = _c === void 0 ? 0 : _c, _d = _a.cz, cz = _d === void 0 ? 0 : _d, _e = _a.hwidth, hwidth = _e === void 0 ? 0 : _e, _f = _a.hheight, hheight = _f === void 0 ? 0 : _f, _g = _a.hdepth, hdepth = _g === void 0 ? 0 : _g;
          var halfExtents = [
            Math.abs(hwidth),
            Math.abs(hheight),
            hdepth
          ];
          var _h = parsedStyle, stroke2 = _h.stroke, _j = _h.lineWidth, lineWidth = _j === void 0 ? 1 : _j, _k = _h.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _k === void 0 ? 0 : _k, _l = _h.shadowType, shadowType = _l === void 0 ? "outer" : _l, shadowColor = _h.shadowColor, _m = _h.filter, filter2 = _m === void 0 ? [] : _m, transformOrigin = _h.transformOrigin;
          var center2 = [cx, cy, cz];
          geometry_1.contentBounds.update(center2, halfExtents);
          var expansion = nodeName === Shape.POLYLINE || nodeName === Shape.POLYGON || nodeName === Shape.PATH ? Math.SQRT2 : 0.5;
          var hasStroke = stroke2 && !stroke2.isNone;
          if (hasStroke) {
            var halfLineWidth = ((lineWidth || 0) + (increasedLineWidthForHitTesting || 0)) * expansion;
            halfExtents[0] += halfLineWidth;
            halfExtents[1] += halfLineWidth;
          }
          geometry_1.renderBounds.update(center2, halfExtents);
          if (shadowColor && shadowType && shadowType !== "inner") {
            var _o = geometry_1.renderBounds, min10 = _o.min, max10 = _o.max;
            var _p = parsedStyle, shadowBlur = _p.shadowBlur, shadowOffsetX = _p.shadowOffsetX, shadowOffsetY = _p.shadowOffsetY;
            var shadowBlurInPixels = shadowBlur || 0;
            var shadowOffsetXInPixels = shadowOffsetX || 0;
            var shadowOffsetYInPixels = shadowOffsetY || 0;
            var shadowLeft = min10[0] - shadowBlurInPixels + shadowOffsetXInPixels;
            var shadowRight = max10[0] + shadowBlurInPixels + shadowOffsetXInPixels;
            var shadowTop = min10[1] - shadowBlurInPixels + shadowOffsetYInPixels;
            var shadowBottom = max10[1] + shadowBlurInPixels + shadowOffsetYInPixels;
            min10[0] = Math.min(min10[0], shadowLeft);
            max10[0] = Math.max(max10[0], shadowRight);
            min10[1] = Math.min(min10[1], shadowTop);
            max10[1] = Math.max(max10[1], shadowBottom);
            geometry_1.renderBounds.setMinMax(min10, max10);
          }
          filter2.forEach(function(_a2) {
            var name2 = _a2.name, params = _a2.params;
            if (name2 === "blur") {
              var blurRadius = params[0].value;
              geometry_1.renderBounds.update(geometry_1.renderBounds.center, addVec3(geometry_1.renderBounds.halfExtents, geometry_1.renderBounds.halfExtents, [blurRadius, blurRadius, 0]));
            } else if (name2 === "drop-shadow") {
              var shadowOffsetX2 = params[0].value;
              var shadowOffsetY2 = params[1].value;
              var shadowBlur2 = params[2].value;
              var _b2 = geometry_1.renderBounds, min11 = _b2.min, max11 = _b2.max;
              var shadowLeft2 = min11[0] - shadowBlur2 + shadowOffsetX2;
              var shadowRight2 = max11[0] + shadowBlur2 + shadowOffsetX2;
              var shadowTop2 = min11[1] - shadowBlur2 + shadowOffsetY2;
              var shadowBottom2 = max11[1] + shadowBlur2 + shadowOffsetY2;
              min11[0] = Math.min(min11[0], shadowLeft2);
              max11[0] = Math.max(max11[0], shadowRight2);
              min11[1] = Math.min(min11[1], shadowTop2);
              max11[1] = Math.max(max11[1], shadowBottom2);
              geometry_1.renderBounds.setMinMax(min11, max11);
            }
          });
          object.geometry.dirty = false;
          var flipY = hwidth < 0;
          var flipX = hheight < 0;
          var usedOriginXValue = (flipY ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[0], 0, object, true) : 0);
          var usedOriginYValue = (flipX ? -1 : 1) * (transformOrigin ? convertPercentUnit(transformOrigin[1], 1, object, true) : 0);
          if (usedOriginXValue || usedOriginYValue) {
            object.setOrigin(usedOriginXValue, usedOriginYValue);
          }
        }
      };
      DefaultStyleValueRegistry2.prototype.updateSizeAttenuation = function(node, zoom) {
        if (node.style.isSizeAttenuation) {
          if (!node.style.rawLineWidth) {
            node.style.rawLineWidth = node.style.lineWidth;
          }
          node.style.lineWidth = (node.style.rawLineWidth || 1) / zoom;
          if (node.nodeName === Shape.CIRCLE) {
            if (!node.style.rawR) {
              node.style.rawR = node.style.r;
            }
            node.style.r = (node.style.rawR || 1) / zoom;
          }
        } else {
          if (node.style.rawLineWidth) {
            node.style.lineWidth = node.style.rawLineWidth;
            delete node.style.rawLineWidth;
          }
          if (node.nodeName === Shape.CIRCLE) {
            if (node.style.rawR) {
              node.style.r = node.style.rawR;
              delete node.style.rawR;
            }
          }
        }
      };
      DefaultStyleValueRegistry2.prototype.isPropertyInheritable = function(name2) {
        var metadata = propertyMetadataCache[name2];
        if (!metadata) {
          return false;
        }
        return metadata.inh;
      };
      return DefaultStyleValueRegistry2;
    }()
  );
  var CSSPropertyAngle = (
    /** @class */
    function() {
      function CSSPropertyAngle2() {
        this.parser = parseAngle;
        this.parserUnmemoize = parseAngleUnmemoize;
        this.parserWithCSSDisabled = null;
        this.mixer = mergeNumbers;
      }
      CSSPropertyAngle2.prototype.calculator = function(name2, oldParsed, parsed, object) {
        return convertAngleUnit(parsed);
      };
      return CSSPropertyAngle2;
    }()
  );
  var CSSPropertyClipPath = (
    /** @class */
    function() {
      function CSSPropertyClipPath2() {
      }
      CSSPropertyClipPath2.prototype.calculator = function(name2, oldPath, newPath, object, runtime2) {
        if (newPath instanceof CSSKeywordValue) {
          newPath = null;
        }
        runtime2.sceneGraphService.updateDisplayObjectDependency(name2, oldPath, newPath, object);
        if (name2 === "clipPath") {
          object.forEach(function(leaf) {
            if (leaf.childNodes.length === 0) {
              runtime2.sceneGraphService.dirtifyToRoot(leaf);
            }
          });
        }
        return newPath;
      };
      return CSSPropertyClipPath2;
    }()
  );
  var CSSPropertyColor = (
    /** @class */
    function() {
      function CSSPropertyColor2() {
        this.parser = parseColor;
        this.parserWithCSSDisabled = parseColor;
        this.mixer = mergeColors;
      }
      CSSPropertyColor2.prototype.calculator = function(name2, oldParsed, parsed, object) {
        if (parsed instanceof CSSKeywordValue) {
          return parsed.value === "none" ? noneColor : transparentColor;
        }
        return parsed;
      };
      return CSSPropertyColor2;
    }()
  );
  var CSSPropertyFilter = (
    /** @class */
    function() {
      function CSSPropertyFilter2() {
        this.parser = parseFilter;
      }
      CSSPropertyFilter2.prototype.calculator = function(name2, oldParsed, parsed) {
        if (parsed instanceof CSSKeywordValue) {
          return [];
        }
        return parsed;
      };
      return CSSPropertyFilter2;
    }()
  );
  function getFontSize(object) {
    var fontSize = object.parsedStyle.fontSize;
    return is_nil_default2(fontSize) ? null : fontSize;
  }
  var CSSPropertyLengthOrPercentage = (
    /** @class */
    function() {
      function CSSPropertyLengthOrPercentage2() {
        this.parser = parseLengthOrPercentage;
        this.parserUnmemoize = parseLengthOrPercentageUnmemoize;
        this.parserWithCSSDisabled = null;
        this.mixer = mergeNumbers;
      }
      CSSPropertyLengthOrPercentage2.prototype.calculator = function(name2, oldParsed, computed, object, runtime2) {
        var _a;
        if (is_number_default2(computed)) {
          return computed;
        }
        if (CSSUnitValue.isRelativeUnit(computed.unit)) {
          var registry = runtime2.styleValueRegistry;
          if (computed.unit === UnitType.kPercentage) {
            return 0;
          } else if (computed.unit === UnitType.kEms) {
            if (object.parentNode) {
              var fontSize = getFontSize(object.parentNode);
              if (fontSize) {
                fontSize *= computed.value;
                return fontSize;
              } else {
                registry.addUnresolveProperty(object, name2);
              }
            } else {
              registry.addUnresolveProperty(object, name2);
            }
            return 0;
          } else if (computed.unit === UnitType.kRems) {
            if ((_a = object === null || object === void 0 ? void 0 : object.ownerDocument) === null || _a === void 0 ? void 0 : _a.documentElement) {
              var fontSize = getFontSize(object.ownerDocument.documentElement);
              if (fontSize) {
                fontSize *= computed.value;
                return fontSize;
              } else {
                registry.addUnresolveProperty(object, name2);
              }
            } else {
              registry.addUnresolveProperty(object, name2);
            }
            return 0;
          }
        } else {
          return computed.value;
        }
      };
      return CSSPropertyLengthOrPercentage2;
    }()
  );
  var CSSPropertyLengthOrPercentage12 = (
    /** @class */
    function() {
      function CSSPropertyLengthOrPercentage122() {
        this.mixer = mergeNumberLists;
      }
      CSSPropertyLengthOrPercentage122.prototype.parser = function(radius) {
        var parsed = parseDimensionArray(is_number_default2(radius) ? [radius] : radius);
        var formatted;
        if (parsed.length === 1) {
          formatted = [parsed[0], parsed[0]];
        } else {
          formatted = [parsed[0], parsed[1]];
        }
        return formatted;
      };
      CSSPropertyLengthOrPercentage122.prototype.calculator = function(name2, oldParsed, computed) {
        return computed.map(function(c5) {
          return c5.value;
        });
      };
      return CSSPropertyLengthOrPercentage122;
    }()
  );
  var CSSPropertyLengthOrPercentage14 = (
    /** @class */
    function() {
      function CSSPropertyLengthOrPercentage142() {
        this.mixer = mergeNumberLists;
      }
      CSSPropertyLengthOrPercentage142.prototype.parser = function(radius) {
        var parsed = parseDimensionArray(is_number_default2(radius) ? [radius] : radius);
        var formatted;
        if (parsed.length === 1) {
          formatted = [parsed[0], parsed[0], parsed[0], parsed[0]];
        } else if (parsed.length === 2) {
          formatted = [parsed[0], parsed[1], parsed[0], parsed[1]];
        } else if (parsed.length === 3) {
          formatted = [parsed[0], parsed[1], parsed[2], parsed[1]];
        } else {
          formatted = [parsed[0], parsed[1], parsed[2], parsed[3]];
        }
        return formatted;
      };
      CSSPropertyLengthOrPercentage142.prototype.calculator = function(name2, oldParsed, computed) {
        return computed.map(function(c5) {
          return c5.value;
        });
      };
      return CSSPropertyLengthOrPercentage142;
    }()
  );
  var CSSPropertyMarker = (
    /** @class */
    function() {
      function CSSPropertyMarker2() {
      }
      CSSPropertyMarker2.prototype.calculator = function(name2, oldMarker, newMarker, object) {
        if (newMarker instanceof CSSKeywordValue) {
          newMarker = null;
        }
        var cloned = newMarker === null || newMarker === void 0 ? void 0 : newMarker.cloneNode(true);
        if (cloned) {
          cloned.style.isMarker = true;
        }
        return cloned;
      };
      return CSSPropertyMarker2;
    }()
  );
  var CSSPropertyNumber = (
    /** @class */
    function() {
      function CSSPropertyNumber2() {
        this.mixer = mergeNumbers;
        this.parser = parseNumber;
        this.parserUnmemoize = parseNumberUnmemoize;
        this.parserWithCSSDisabled = null;
      }
      CSSPropertyNumber2.prototype.calculator = function(name2, oldParsed, computed) {
        return computed.value;
      };
      return CSSPropertyNumber2;
    }()
  );
  var CSSPropertyOffsetDistance = (
    /** @class */
    function() {
      function CSSPropertyOffsetDistance2() {
        this.parser = parseNumber;
        this.parserUnmemoize = parseNumberUnmemoize;
        this.parserWithCSSDisabled = null;
        this.mixer = clampedMergeNumbers(0, 1);
      }
      CSSPropertyOffsetDistance2.prototype.calculator = function(name2, oldParsed, computed) {
        return computed.value;
      };
      CSSPropertyOffsetDistance2.prototype.postProcessor = function(object) {
        var _a = object.parsedStyle, offsetPath = _a.offsetPath, offsetDistance = _a.offsetDistance;
        if (!offsetPath) {
          return;
        }
        var nodeName = offsetPath.nodeName;
        if (nodeName === Shape.LINE || nodeName === Shape.PATH || nodeName === Shape.POLYLINE) {
          var point6 = offsetPath.getPoint(offsetDistance);
          if (point6) {
            object.setLocalPosition(point6.x, point6.y);
          }
        }
      };
      return CSSPropertyOffsetDistance2;
    }()
  );
  var CSSPropertyOpacity = (
    /** @class */
    function() {
      function CSSPropertyOpacity2() {
        this.parser = parseNumber;
        this.parserUnmemoize = parseNumberUnmemoize;
        this.parserWithCSSDisabled = null;
        this.mixer = clampedMergeNumbers(0, 1);
      }
      CSSPropertyOpacity2.prototype.calculator = function(name2, oldParsed, computed) {
        return computed.value;
      };
      return CSSPropertyOpacity2;
    }()
  );
  var CSSPropertyPath = (
    /** @class */
    function() {
      function CSSPropertyPath2() {
        this.parser = parsePath;
        this.parserWithCSSDisabled = parsePath;
        this.mixer = mergePaths;
      }
      CSSPropertyPath2.prototype.calculator = function(name2, oldParsed, parsed) {
        if (parsed instanceof CSSKeywordValue && parsed.value === "unset") {
          return {
            absolutePath: [],
            hasArc: false,
            segments: [],
            polygons: [],
            polylines: [],
            curve: null,
            totalLength: 0,
            rect: new Rectangle(0, 0, 0, 0)
          };
        }
        return parsed;
      };
      return CSSPropertyPath2;
    }()
  );
  var CSSPropertyPoints = (
    /** @class */
    /* @__PURE__ */ function() {
      function CSSPropertyPoints2() {
        this.parser = parsePoints;
        this.mixer = mergePoints;
      }
      return CSSPropertyPoints2;
    }()
  );
  var CSSPropertyShadowBlur = (
    /** @class */
    function(_super) {
      __extends(CSSPropertyShadowBlur2, _super);
      function CSSPropertyShadowBlur2() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this.mixer = clampedMergeNumbers(0, Infinity);
        return _this;
      }
      return CSSPropertyShadowBlur2;
    }(CSSPropertyLengthOrPercentage)
  );
  var CSSPropertyText = (
    /** @class */
    function() {
      function CSSPropertyText2() {
      }
      CSSPropertyText2.prototype.calculator = function(name2, oldParsed, parsed, object) {
        if (parsed instanceof CSSKeywordValue) {
          if (parsed.value === "unset") {
            return "";
          } else {
            return parsed.value;
          }
        }
        return "".concat(parsed);
      };
      CSSPropertyText2.prototype.postProcessor = function(object) {
        object.nodeValue = "".concat(object.parsedStyle.text) || "";
      };
      return CSSPropertyText2;
    }()
  );
  var CSSPropertyTextTransform = (
    /** @class */
    function() {
      function CSSPropertyTextTransform2() {
      }
      CSSPropertyTextTransform2.prototype.calculator = function(name2, oldParsed, parsed, object) {
        var rawText = object.getAttribute("text");
        if (rawText) {
          var transformedText = rawText;
          if (parsed.value === "capitalize") {
            transformedText = rawText.charAt(0).toUpperCase() + rawText.slice(1);
          } else if (parsed.value === "lowercase") {
            transformedText = rawText.toLowerCase();
          } else if (parsed.value === "uppercase") {
            transformedText = rawText.toUpperCase();
          }
          object.parsedStyle.text = transformedText;
        }
        return parsed.value;
      };
      return CSSPropertyTextTransform2;
    }()
  );
  var canvasMap = {};
  var defaultCanvasIdCounter = 0;
  function cleanExistedCanvas(container, canvas) {
    if (container) {
      var id4 = typeof container === "string" ? container : container.id || defaultCanvasIdCounter++;
      if (canvasMap[id4]) {
        canvasMap[id4].destroy();
      }
      canvasMap[id4] = canvas;
    }
  }
  var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
  function isElement(target) {
    return !!target.getAttribute;
  }
  function sortedIndex(array2, value2) {
    var low = 0;
    var high = array2.length;
    while (low < high) {
      var mid2 = low + high >>> 1;
      if (sortByZIndex(array2[mid2], value2) < 0) {
        low = mid2 + 1;
      } else {
        high = mid2;
      }
    }
    return low;
  }
  function sortByZIndex(o1, o2) {
    var zIndex1 = Number(o1.parsedStyle.zIndex || 0);
    var zIndex2 = Number(o2.parsedStyle.zIndex || 0);
    if (zIndex1 === zIndex2) {
      var parent_1 = o1.parentNode;
      if (parent_1) {
        var children = parent_1.childNodes || [];
        return children.indexOf(o1) - children.indexOf(o2);
      }
    }
    return zIndex1 - zIndex2;
  }
  function findClosestClipPathTarget(object) {
    var _a;
    var el = object;
    do {
      var clipPath = (_a = el.parsedStyle) === null || _a === void 0 ? void 0 : _a.clipPath;
      if (clipPath)
        return el;
      el = el.parentElement;
    } while (el !== null);
    return null;
  }
  var PX_SUFFIX = "px";
  function setDOMSize($el, width, height) {
    if (isBrowser && $el.style) {
      $el.style.width = width + PX_SUFFIX;
      $el.style.height = height + PX_SUFFIX;
    }
  }
  function getStyle($el, property) {
    if (isBrowser) {
      return document.defaultView.getComputedStyle($el, null).getPropertyValue(property);
    }
  }
  function getWidth($el) {
    var width = getStyle($el, "width");
    if (width === "auto") {
      return $el.offsetWidth;
    }
    return parseFloat(width);
  }
  function getHeight($el) {
    var height = getStyle($el, "height");
    if (height === "auto") {
      return $el.offsetHeight;
    }
    return parseFloat(height);
  }
  var MOUSE_POINTER_ID = 1;
  var TOUCH_TO_POINTER = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
  };
  var clock = typeof performance === "object" && performance.now ? performance : Date;
  function isFillOrStrokeAffected(pointerEvents, fill, stroke2) {
    if (pointerEvents === void 0) {
      pointerEvents = "auto";
    }
    var hasFill = false;
    var hasStroke = false;
    var isFillOtherThanNone = !!fill && !fill.isNone;
    var isStrokeOtherThanNone = !!stroke2 && !stroke2.isNone;
    if (pointerEvents === "visiblepainted" || pointerEvents === "painted" || pointerEvents === "auto") {
      hasFill = isFillOtherThanNone;
      hasStroke = isStrokeOtherThanNone;
    } else if (pointerEvents === "visiblefill" || pointerEvents === "fill") {
      hasFill = true;
    } else if (pointerEvents === "visiblestroke" || pointerEvents === "stroke") {
      hasStroke = true;
    } else if (pointerEvents === "visible" || pointerEvents === "all") {
      hasFill = true;
      hasStroke = true;
    }
    return [hasFill, hasStroke];
  }
  var uId = 1;
  var uniqueId = function() {
    return uId++;
  };
  var root = typeof self === "object" && self.self == self ? self : (
    // @ts-ignore
    typeof global === "object" && global.global == global ? (
      // @ts-ignore
      global
    ) : {}
  );
  var nowOffset = Date.now();
  var pnow = function() {
    if (root.performance && typeof root.performance.now === "function") {
      return root.performance.now();
    }
    return Date.now() - nowOffset;
  };
  var reservedCBs = {};
  var lastTime = Date.now();
  var polyfillRaf = function(callback) {
    if (typeof callback !== "function") {
      throw new TypeError(callback + " is not a function");
    }
    var currentTime = Date.now();
    var gap = currentTime - lastTime;
    var delay = gap > 16 ? 0 : 16 - gap;
    var id4 = uniqueId();
    reservedCBs[id4] = callback;
    if (Object.keys(reservedCBs).length > 1)
      return id4;
    setTimeout(function() {
      lastTime = currentTime;
      var copied = reservedCBs;
      reservedCBs = {};
      Object.keys(copied).forEach(function(key) {
        return copied[key](pnow());
      });
    }, delay);
    return id4;
  };
  var polyfillCaf = function(id4) {
    delete reservedCBs[id4];
  };
  var vendorPrefixes = ["", "webkit", "moz", "ms", "o"];
  var getRequestAnimationFrame = function(vp2) {
    if (typeof vp2 !== "string")
      return polyfillRaf;
    if (vp2 === "")
      return root["requestAnimationFrame"];
    return root[vp2 + "RequestAnimationFrame"];
  };
  var getCancelAnimationFrame = function(vp2) {
    if (typeof vp2 !== "string")
      return polyfillCaf;
    if (vp2 === "")
      return root["cancelAnimationFrame"];
    return root[vp2 + "CancelAnimationFrame"] || root[vp2 + "CancelRequestAnimationFrame"];
  };
  var find3 = function(arr, predicate) {
    var i = 0;
    while (arr[i] !== void 0) {
      if (predicate(arr[i]))
        return arr[i];
      i = i + 1;
    }
  };
  var vp = find3(vendorPrefixes, function(vp2) {
    return !!getRequestAnimationFrame(vp2);
  });
  var raf = getRequestAnimationFrame(vp);
  var caf = getCancelAnimationFrame(vp);
  root.requestAnimationFrame = raf;
  root.cancelAnimationFrame = caf;
  var AsyncParallelHook = (
    /** @class */
    function() {
      function AsyncParallelHook2() {
        this.callbacks = [];
      }
      AsyncParallelHook2.prototype.getCallbacksNum = function() {
        return this.callbacks.length;
      };
      AsyncParallelHook2.prototype.tapPromise = function(options, fn) {
        this.callbacks.push(fn);
      };
      AsyncParallelHook2.prototype.promise = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return Promise.all(this.callbacks.map(function(callback) {
          return callback.apply(void 0, __spreadArray([], __read(args), false));
        }));
      };
      return AsyncParallelHook2;
    }()
  );
  var AsyncSeriesWaterfallHook = (
    /** @class */
    function() {
      function AsyncSeriesWaterfallHook2() {
        this.callbacks = [];
      }
      AsyncSeriesWaterfallHook2.prototype.tapPromise = function(options, fn) {
        this.callbacks.push(fn);
      };
      AsyncSeriesWaterfallHook2.prototype.promise = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function() {
          var result, i, callback;
          var _a;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (!this.callbacks.length) return [3, 6];
                return [4, (_a = this.callbacks)[0].apply(_a, __spreadArray([], __read(args), false))];
              case 1:
                result = _b.sent();
                i = 0;
                _b.label = 2;
              case 2:
                if (!(i < this.callbacks.length - 1)) return [3, 5];
                callback = this.callbacks[i];
                return [4, callback(result)];
              case 3:
                result = _b.sent();
                _b.label = 4;
              case 4:
                i++;
                return [3, 2];
              case 5:
                return [2, result];
              case 6:
                return [2, null];
            }
          });
        });
      };
      return AsyncSeriesWaterfallHook2;
    }()
  );
  var SyncHook = (
    /** @class */
    function() {
      function SyncHook2() {
        this.callbacks = [];
      }
      SyncHook2.prototype.tap = function(options, fn) {
        this.callbacks.push(fn);
      };
      SyncHook2.prototype.call = function() {
        var argsArr = arguments;
        this.callbacks.forEach(function(callback) {
          callback.apply(void 0, argsArr);
        });
      };
      return SyncHook2;
    }()
  );
  var SyncWaterfallHook = (
    /** @class */
    function() {
      function SyncWaterfallHook2() {
        this.callbacks = [];
      }
      SyncWaterfallHook2.prototype.tap = function(options, fn) {
        this.callbacks.push(fn);
      };
      SyncWaterfallHook2.prototype.call = function() {
        if (this.callbacks.length) {
          var argsArr = arguments;
          var result = this.callbacks[0].apply(void 0, argsArr);
          for (var i = 0; i < this.callbacks.length - 1; i++) {
            var callback = this.callbacks[i];
            result = callback(result);
          }
          return result;
        }
        return null;
      };
      return SyncWaterfallHook2;
    }()
  );
  var genericFontFamilies = [
    "serif",
    "sans-serif",
    "monospace",
    "cursive",
    "fantasy",
    "system-ui"
  ];
  var stringRegExp = /([\"\'])[^\'\"]+\1/;
  function toFontString(attributes) {
    var _a = attributes.fontSize, fontSize = _a === void 0 ? 16 : _a, _b = attributes.fontFamily, fontFamily = _b === void 0 ? "sans-serif" : _b, _c = attributes.fontStyle, fontStyle = _c === void 0 ? "normal" : _c, _d = attributes.fontVariant, fontVariant = _d === void 0 ? "normal" : _d, _e = attributes.fontWeight, fontWeight = _e === void 0 ? "normal" : _e;
    var fontSizeString = is_number_default2(fontSize) && "".concat(fontSize, "px") || "16px";
    var fontFamilies = fontFamily.split(",");
    for (var i = fontFamilies.length - 1; i >= 0; i--) {
      var fontFamily_1 = fontFamilies[i].trim();
      if (!stringRegExp.test(fontFamily_1) && genericFontFamilies.indexOf(fontFamily_1) < 0) {
        fontFamily_1 = '"'.concat(fontFamily_1, '"');
      }
      fontFamilies[i] = fontFamily_1;
    }
    return "".concat(fontStyle, " ").concat(fontVariant, " ").concat(fontWeight, " ").concat(fontSizeString, " ").concat(fontFamilies.join(","));
  }
  function createSkewMatrix(skewMatrix, skewX, skewY) {
    mat4_exports.identity(skewMatrix);
    skewMatrix[4] = Math.tan(skewX);
    skewMatrix[1] = Math.tan(skewY);
    return skewMatrix;
  }
  var SCALE_EPSILON = 1e-5;
  var tmpMat1 = mat4_exports.create();
  var tmpMat2 = mat4_exports.create();
  function parsedTransformToMat4(transform, object) {
    if (transform.length) {
      var m_1 = mat4_exports.identity(tmpMat1);
      transform.forEach(function(parsed) {
        var t = parsed.t, d2 = parsed.d;
        if (t === "scale") {
          var newScale = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
            return Math.max(s2.value, SCALE_EPSILON);
          })) || [
            1,
            1
          ];
          mat4_exports.fromScaling(tmpMat2, [newScale[0], newScale[1], 1]);
        } else if (t === "scalex") {
          var newScale = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
            return Math.max(s2.value, SCALE_EPSILON);
          })) || [1];
          mat4_exports.fromScaling(tmpMat2, [newScale[0], 1, 1]);
        } else if (t === "scaley") {
          var newScale = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
            return Math.max(s2.value, SCALE_EPSILON);
          })) || [1];
          mat4_exports.fromScaling(tmpMat2, [1, newScale[0], 1]);
        } else if (t === "scalez") {
          var newScale = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
            return Math.max(s2.value, SCALE_EPSILON);
          })) || [1];
          mat4_exports.fromScaling(tmpMat2, [1, 1, newScale[0]]);
        } else if (t === "scale3d") {
          var newScale = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
            return Math.max(s2.value, SCALE_EPSILON);
          })) || [
            1,
            1,
            1
          ];
          mat4_exports.fromScaling(tmpMat2, [newScale[0], newScale[1], newScale[2]]);
        } else if (t === "translate") {
          var newTranslation = d2 || [Opx, Opx];
          mat4_exports.fromTranslation(tmpMat2, [
            newTranslation[0].value,
            newTranslation[1].value,
            0
          ]);
        } else if (t === "translatex") {
          var newTranslation = d2 || [Opx];
          mat4_exports.fromTranslation(tmpMat2, [newTranslation[0].value, 0, 0]);
        } else if (t === "translatey") {
          var newTranslation = d2 || [Opx];
          mat4_exports.fromTranslation(tmpMat2, [0, newTranslation[0].value, 0]);
        } else if (t === "translatez") {
          var newTranslation = d2 || [Opx];
          mat4_exports.fromTranslation(tmpMat2, [0, 0, newTranslation[0].value]);
        } else if (t === "translate3d") {
          var newTranslation = d2 || [Opx, Opx, Opx];
          mat4_exports.fromTranslation(tmpMat2, [
            newTranslation[0].value,
            newTranslation[1].value,
            newTranslation[2].value
          ]);
        } else if (t === "rotate") {
          var newAngles = d2 || [Odeg];
          mat4_exports.fromZRotation(tmpMat2, deg2rad(convertAngleUnit(newAngles[0])));
        } else if (t === "rotatex") {
          var newAngles = d2 || [Odeg];
          mat4_exports.fromXRotation(tmpMat2, deg2rad(convertAngleUnit(newAngles[0])));
        } else if (t === "rotatey") {
          var newAngles = d2 || [Odeg];
          mat4_exports.fromYRotation(tmpMat2, deg2rad(convertAngleUnit(newAngles[0])));
        } else if (t === "rotatez") {
          var newAngles = d2 || [Odeg];
          mat4_exports.fromZRotation(tmpMat2, deg2rad(convertAngleUnit(newAngles[0])));
        } else if (t === "rotate3d") {
          var newAngles = d2 || [Opx, Opx, Opx, Odeg];
          mat4_exports.fromRotation(tmpMat2, deg2rad(convertAngleUnit(newAngles[3])), [
            newAngles[0].value,
            newAngles[1].value,
            newAngles[2].value
          ]);
        } else if (t === "skew") {
          var newSkew = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
            return s2.value;
          })) || [0, 0];
          createSkewMatrix(tmpMat2, deg2rad(newSkew[0]), deg2rad(newSkew[1]));
        } else if (t === "skewx") {
          var newSkew = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
            return s2.value;
          })) || [0];
          createSkewMatrix(tmpMat2, deg2rad(newSkew[0]), 0);
        } else if (t === "skewy") {
          var newSkew = (d2 === null || d2 === void 0 ? void 0 : d2.map(function(s2) {
            return s2.value;
          })) || [0];
          createSkewMatrix(tmpMat2, 0, deg2rad(newSkew[0]));
        } else if (t === "matrix") {
          var _a = __read(d2.map(function(s2) {
            return s2.value;
          }), 6), a3 = _a[0], b = _a[1], c5 = _a[2], dd = _a[3], tx = _a[4], ty = _a[5];
          mat4_exports.set(tmpMat2, a3, b, 0, 0, c5, dd, 0, 0, 0, 0, 1, 0, tx, ty, 0, 1);
        } else if (t === "matrix3d") {
          mat4_exports.set.apply(mat4_exports, __spreadArray([tmpMat2], __read(d2.map(function(s2) {
            return s2.value;
          })), false));
        }
        mat4_exports.mul(m_1, m_1, tmpMat2);
      });
      object.setLocalTransform(m_1);
    } else {
      object.resetLocalTransform();
    }
    return object.getLocalTransform();
  }
  var CSSPropertyTransform = (
    /** @class */
    function() {
      function CSSPropertyTransform2() {
        this.parser = parseTransform;
        this.parserUnmemoize = parseTransformUnmemoize;
        this.parserWithCSSDisabled = parseTransformUnmemoize;
        this.mixer = mergeTransforms;
      }
      CSSPropertyTransform2.prototype.calculator = function(name2, oldParsed, parsed, object) {
        if (parsed instanceof CSSKeywordValue) {
          return [];
        }
        return parsed;
      };
      CSSPropertyTransform2.prototype.postProcessor = function(object) {
        var transform = object.parsedStyle.transform;
        parsedTransformToMat4(transform, object);
      };
      return CSSPropertyTransform2;
    }()
  );
  var CSSPropertyTransformOrigin = (
    /** @class */
    function() {
      function CSSPropertyTransformOrigin2() {
        this.parser = parseTransformOrigin;
        this.parserUnmemoize = parseTransformOriginUnmemoize;
      }
      CSSPropertyTransformOrigin2.prototype.postProcessor = function(object) {
        var transformOrigin = object.parsedStyle.transformOrigin;
        if (transformOrigin[0].unit === UnitType.kPixels && transformOrigin[1].unit === UnitType.kPixels) {
          object.setOrigin(transformOrigin[0].value, transformOrigin[1].value);
        } else {
          object.getGeometryBounds();
        }
      };
      return CSSPropertyTransformOrigin2;
    }()
  );
  var CSSPropertyZIndex = (
    /** @class */
    function() {
      function CSSPropertyZIndex2() {
        this.parser = parseNumber;
        this.parserUnmemoize = parseNumberUnmemoize;
      }
      CSSPropertyZIndex2.prototype.calculator = function(name2, oldParsed, computed, object) {
        return computed.value;
      };
      CSSPropertyZIndex2.prototype.postProcessor = function(object) {
        if (object.parentNode) {
          var parentEntity = object.parentNode;
          var parentRenderable = parentEntity.renderable;
          var parentSortable = parentEntity.sortable;
          if (parentRenderable) {
            parentRenderable.dirty = true;
          }
          if (parentSortable) {
            parentSortable.dirty = true;
            parentSortable.dirtyReason = SortReason.Z_INDEX_CHANGED;
          }
        }
      };
      return CSSPropertyZIndex2;
    }()
  );
  var CircleUpdater = (
    /** @class */
    function() {
      function CircleUpdater2() {
      }
      CircleUpdater2.prototype.update = function(parsedStyle, object) {
        var _a = parsedStyle.cx, cx = _a === void 0 ? 0 : _a, _b = parsedStyle.cy, cy = _b === void 0 ? 0 : _b, _c = parsedStyle.r, r = _c === void 0 ? 0 : _c;
        return {
          cx,
          cy,
          hwidth: r,
          hheight: r
        };
      };
      return CircleUpdater2;
    }()
  );
  var EllipseUpdater = (
    /** @class */
    function() {
      function EllipseUpdater2() {
      }
      EllipseUpdater2.prototype.update = function(parsedStyle, object) {
        var _a = parsedStyle.cx, cx = _a === void 0 ? 0 : _a, _b = parsedStyle.cy, cy = _b === void 0 ? 0 : _b, _c = parsedStyle.rx, rx = _c === void 0 ? 0 : _c, _d = parsedStyle.ry, ry = _d === void 0 ? 0 : _d;
        return {
          cx,
          cy,
          hwidth: rx,
          hheight: ry
        };
      };
      return EllipseUpdater2;
    }()
  );
  var LineUpdater = (
    /** @class */
    function() {
      function LineUpdater2() {
      }
      LineUpdater2.prototype.update = function(parsedStyle) {
        var x12 = parsedStyle.x1, y12 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2;
        var minX = Math.min(x12, x22);
        var maxX = Math.max(x12, x22);
        var minY = Math.min(y12, y22);
        var maxY2 = Math.max(y12, y22);
        var width = maxX - minX;
        var height = maxY2 - minY;
        var hwidth = width / 2;
        var hheight = height / 2;
        return {
          cx: minX + hwidth,
          cy: minY + hheight,
          hwidth,
          hheight
        };
      };
      return LineUpdater2;
    }()
  );
  var PathUpdater = (
    /** @class */
    function() {
      function PathUpdater2() {
      }
      PathUpdater2.prototype.update = function(parsedStyle) {
        var d2 = parsedStyle.d;
        var _a = d2.rect, x3 = _a.x, y3 = _a.y, width = _a.width, height = _a.height;
        var hwidth = width / 2;
        var hheight = height / 2;
        return {
          cx: x3 + hwidth,
          cy: y3 + hheight,
          hwidth,
          hheight
        };
      };
      return PathUpdater2;
    }()
  );
  var PolylineUpdater = (
    /** @class */
    function() {
      function PolylineUpdater2() {
      }
      PolylineUpdater2.prototype.update = function(parsedStyle) {
        if (parsedStyle.points && is_array_default2(parsedStyle.points.points)) {
          var points = parsedStyle.points.points;
          var minX = Math.min.apply(Math, __spreadArray([], __read(points.map(function(point6) {
            return point6[0];
          })), false));
          var maxX = Math.max.apply(Math, __spreadArray([], __read(points.map(function(point6) {
            return point6[0];
          })), false));
          var minY = Math.min.apply(Math, __spreadArray([], __read(points.map(function(point6) {
            return point6[1];
          })), false));
          var maxY2 = Math.max.apply(Math, __spreadArray([], __read(points.map(function(point6) {
            return point6[1];
          })), false));
          var width = maxX - minX;
          var height = maxY2 - minY;
          var hwidth = width / 2;
          var hheight = height / 2;
          return {
            cx: minX + hwidth,
            cy: minY + hheight,
            hwidth,
            hheight
          };
        }
        return {
          cx: 0,
          cy: 0,
          hwidth: 0,
          hheight: 0
        };
      };
      return PolylineUpdater2;
    }()
  );
  var RectUpdater = (
    /** @class */
    function() {
      function RectUpdater2() {
      }
      RectUpdater2.prototype.update = function(parsedStyle, object) {
        var _a = parsedStyle.x, x3 = _a === void 0 ? 0 : _a, _b = parsedStyle.y, y3 = _b === void 0 ? 0 : _b, src = parsedStyle.src, _c = parsedStyle.width, width = _c === void 0 ? 0 : _c, _d = parsedStyle.height, height = _d === void 0 ? 0 : _d;
        var contentWidth = width;
        var contentHeight = height;
        if (src && !is_string_default2(src)) {
          if (!contentWidth) {
            contentWidth = src.width;
            parsedStyle.width = contentWidth;
          }
          if (!contentHeight) {
            contentHeight = src.height;
            parsedStyle.height = contentHeight;
          }
        }
        return {
          cx: x3 + contentWidth / 2,
          cy: y3 + contentHeight / 2,
          hwidth: contentWidth / 2,
          hheight: contentHeight / 2
        };
      };
      return RectUpdater2;
    }()
  );
  var TextUpdater = (
    /** @class */
    function() {
      function TextUpdater2(globalRuntime) {
        this.globalRuntime = globalRuntime;
      }
      TextUpdater2.prototype.isReadyToMeasure = function(parsedStyle, object) {
        var text = parsedStyle.text, textAlign = parsedStyle.textAlign, textBaseline = parsedStyle.textBaseline, fontSize = parsedStyle.fontSize, fontStyle = parsedStyle.fontStyle, fontWeight = parsedStyle.fontWeight, fontVariant = parsedStyle.fontVariant, lineWidth = parsedStyle.lineWidth;
        return runtime.enableCSSParsing ? text && fontSize && fontStyle && fontWeight && fontVariant && textAlign && textBaseline && !is_nil_default2(lineWidth) : text;
      };
      TextUpdater2.prototype.update = function(parsedStyle, object) {
        var _a, _b;
        var text = parsedStyle.text, _c = parsedStyle.textAlign, textAlign = _c === void 0 ? "start" : _c, _d = parsedStyle.lineWidth, lineWidth = _d === void 0 ? 1 : _d, _e = parsedStyle.textBaseline, textBaseline = _e === void 0 ? "alphabetic" : _e, _f = parsedStyle.dx, dx = _f === void 0 ? 0 : _f, _g = parsedStyle.dy, dy = _g === void 0 ? 0 : _g, _h = parsedStyle.x, x3 = _h === void 0 ? 0 : _h, _j = parsedStyle.y, y3 = _j === void 0 ? 0 : _j;
        if (!this.isReadyToMeasure(parsedStyle, object)) {
          parsedStyle.metrics = {
            font: "",
            width: 0,
            height: 0,
            lines: [],
            lineWidths: [],
            lineHeight: 0,
            maxLineWidth: 0,
            fontProperties: {
              ascent: 0,
              descent: 0,
              fontSize: 0
            },
            lineMetrics: []
          };
          return {
            hwidth: 0,
            hheight: 0,
            cx: 0,
            cy: 0
          };
        }
        var offscreenCanvas = (((_b = (_a = object === null || object === void 0 ? void 0 : object.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.getConfig()) || {}).offscreenCanvas;
        var metrics = this.globalRuntime.textService.measureText(text, parsedStyle, offscreenCanvas);
        parsedStyle.metrics = metrics;
        var width = metrics.width, height = metrics.height, lineHeight = metrics.lineHeight, fontProperties = metrics.fontProperties;
        var hwidth = width / 2;
        var hheight = height / 2;
        var lineXOffset = x3 + hwidth;
        if (textAlign === "center" || textAlign === "middle") {
          lineXOffset += lineWidth / 2 - hwidth;
        } else if (textAlign === "right" || textAlign === "end") {
          lineXOffset += lineWidth - hwidth * 2;
        }
        var lineYOffset = y3 - hheight;
        if (textBaseline === "middle") {
          lineYOffset += hheight;
        } else if (textBaseline === "top" || textBaseline === "hanging") {
          lineYOffset += hheight * 2;
        } else if (textBaseline === "alphabetic") {
          lineYOffset += this.globalRuntime.enableCSSParsing ? lineHeight - fontProperties.ascent : 0;
        } else if (textBaseline === "bottom" || textBaseline === "ideographic") {
          lineYOffset += 0;
        }
        if (dx) {
          lineXOffset += dx;
        }
        if (dy) {
          lineYOffset += dy;
        }
        return {
          cx: lineXOffset,
          cy: lineYOffset,
          hwidth,
          hheight
        };
      };
      return TextUpdater2;
    }()
  );
  var GroupUpdater = (
    /** @class */
    function() {
      function GroupUpdater2() {
      }
      GroupUpdater2.prototype.update = function(parsedStyle, object) {
        return {
          cx: 0,
          cy: 0,
          hwidth: 0,
          hheight: 0
        };
      };
      return GroupUpdater2;
    }()
  );
  function isFederatedEvent(value2) {
    return !!value2.type;
  }
  var FederatedEvent = (
    /** @class */
    function() {
      function FederatedEvent2(manager) {
        this.eventPhase = FederatedEvent2.prototype.NONE;
        this.bubbles = true;
        this.cancelBubble = true;
        this.cancelable = false;
        this.defaultPrevented = false;
        this.propagationStopped = false;
        this.propagationImmediatelyStopped = false;
        this.layer = new Point2();
        this.page = new Point2();
        this.canvas = new Point2();
        this.viewport = new Point2();
        this.composed = false;
        this.NONE = 0;
        this.CAPTURING_PHASE = 1;
        this.AT_TARGET = 2;
        this.BUBBLING_PHASE = 3;
        this.manager = manager;
      }
      Object.defineProperty(FederatedEvent2.prototype, "name", {
        /**
         * @deprecated
         */
        get: function() {
          return this.type;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedEvent2.prototype, "layerX", {
        get: function() {
          return this.layer.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedEvent2.prototype, "layerY", {
        get: function() {
          return this.layer.y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedEvent2.prototype, "pageX", {
        get: function() {
          return this.page.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedEvent2.prototype, "pageY", {
        get: function() {
          return this.page.y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedEvent2.prototype, "x", {
        get: function() {
          return this.canvas.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedEvent2.prototype, "y", {
        get: function() {
          return this.canvas.y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedEvent2.prototype, "canvasX", {
        get: function() {
          return this.canvas.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedEvent2.prototype, "canvasY", {
        get: function() {
          return this.canvas.y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedEvent2.prototype, "viewportX", {
        get: function() {
          return this.viewport.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedEvent2.prototype, "viewportY", {
        get: function() {
          return this.viewport.y;
        },
        enumerable: false,
        configurable: true
      });
      FederatedEvent2.prototype.composedPath = function() {
        if (this.manager && (!this.path || this.path[0] !== this.target)) {
          this.path = this.target ? this.manager.propagationPath(this.target) : [];
        }
        return this.path;
      };
      Object.defineProperty(FederatedEvent2.prototype, "propagationPath", {
        /**
         * @deprecated
         */
        get: function() {
          return this.composedPath();
        },
        enumerable: false,
        configurable: true
      });
      FederatedEvent2.prototype.preventDefault = function() {
        if (this.nativeEvent instanceof Event && this.nativeEvent.cancelable) {
          this.nativeEvent.preventDefault();
        }
        this.defaultPrevented = true;
      };
      FederatedEvent2.prototype.stopImmediatePropagation = function() {
        this.propagationImmediatelyStopped = true;
      };
      FederatedEvent2.prototype.stopPropagation = function() {
        this.propagationStopped = true;
      };
      FederatedEvent2.prototype.initEvent = function() {
      };
      FederatedEvent2.prototype.initUIEvent = function() {
      };
      FederatedEvent2.prototype.clone = function() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      return FederatedEvent2;
    }()
  );
  var FederatedMouseEvent = (
    /** @class */
    function(_super) {
      __extends(FederatedMouseEvent2, _super);
      function FederatedMouseEvent2() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this.client = new Point2();
        _this.movement = new Point2();
        _this.offset = new Point2();
        _this.global = new Point2();
        _this.screen = new Point2();
        return _this;
      }
      Object.defineProperty(FederatedMouseEvent2.prototype, "clientX", {
        get: function() {
          return this.client.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedMouseEvent2.prototype, "clientY", {
        get: function() {
          return this.client.y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedMouseEvent2.prototype, "movementX", {
        get: function() {
          return this.movement.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedMouseEvent2.prototype, "movementY", {
        get: function() {
          return this.movement.y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedMouseEvent2.prototype, "offsetX", {
        get: function() {
          return this.offset.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedMouseEvent2.prototype, "offsetY", {
        get: function() {
          return this.offset.y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedMouseEvent2.prototype, "globalX", {
        get: function() {
          return this.global.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedMouseEvent2.prototype, "globalY", {
        get: function() {
          return this.global.y;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedMouseEvent2.prototype, "screenX", {
        get: function() {
          return this.screen.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FederatedMouseEvent2.prototype, "screenY", {
        get: function() {
          return this.screen.y;
        },
        enumerable: false,
        configurable: true
      });
      FederatedMouseEvent2.prototype.getModifierState = function(key) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
      };
      FederatedMouseEvent2.prototype.initMouseEvent = function() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      return FederatedMouseEvent2;
    }(FederatedEvent)
  );
  var FederatedPointerEvent = (
    /** @class */
    function(_super) {
      __extends(FederatedPointerEvent2, _super);
      function FederatedPointerEvent2() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this.width = 0;
        _this.height = 0;
        _this.isPrimary = false;
        return _this;
      }
      FederatedPointerEvent2.prototype.getCoalescedEvents = function() {
        if (this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove") {
          return [this];
        }
        return [];
      };
      FederatedPointerEvent2.prototype.getPredictedEvents = function() {
        throw new Error("getPredictedEvents is not supported!");
      };
      FederatedPointerEvent2.prototype.clone = function() {
        return this.manager.clonePointerEvent(this);
      };
      return FederatedPointerEvent2;
    }(FederatedMouseEvent)
  );
  var FederatedWheelEvent = (
    /** @class */
    function(_super) {
      __extends(FederatedWheelEvent2, _super);
      function FederatedWheelEvent2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      FederatedWheelEvent2.prototype.clone = function() {
        return this.manager.cloneWheelEvent(this);
      };
      return FederatedWheelEvent2;
    }(FederatedMouseEvent)
  );
  var CustomEvent2 = (
    /** @class */
    function(_super) {
      __extends(CustomEvent3, _super);
      function CustomEvent3(eventName, object) {
        var _this = _super.call(this, null) || this;
        _this.type = eventName;
        _this.detail = object;
        Object.assign(_this, object);
        return _this;
      }
      return CustomEvent3;
    }(FederatedEvent)
  );
  var DELEGATION_SPLITTER = ":";
  var EventTarget = (
    /** @class */
    function() {
      function EventTarget2() {
        this.emitter = new eventemitter3_default();
      }
      EventTarget2.prototype.on = function(type, listener, options) {
        this.addEventListener(type, listener, options);
        return this;
      };
      EventTarget2.prototype.addEventListener = function(type, listener, options) {
        var capture = is_boolean_default(options) && options || is_object_default2(options) && options.capture;
        var once = is_object_default2(options) && options.once;
        var context = isFunction(listener) ? void 0 : listener;
        var useDelegatedName = false;
        var delegatedName = "";
        if (type.indexOf(DELEGATION_SPLITTER) > -1) {
          var _a = __read(type.split(DELEGATION_SPLITTER), 2), name_1 = _a[0], eventType = _a[1];
          type = eventType;
          delegatedName = name_1;
          useDelegatedName = true;
        }
        type = capture ? "".concat(type, "capture") : type;
        listener = isFunction(listener) ? listener : listener.handleEvent;
        if (useDelegatedName) {
          var originListener_1 = listener;
          listener = function() {
            var _a2;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (((_a2 = args[0].target) === null || _a2 === void 0 ? void 0 : _a2.name) !== delegatedName) {
              return;
            }
            originListener_1.apply(void 0, __spreadArray([], __read(args), false));
          };
        }
        if (once) {
          this.emitter.once(type, listener, context);
        } else {
          this.emitter.on(type, listener, context);
        }
        return this;
      };
      EventTarget2.prototype.off = function(type, listener, options) {
        if (type) {
          this.removeEventListener(type, listener, options);
        } else {
          this.removeAllEventListeners();
        }
        return this;
      };
      EventTarget2.prototype.removeAllEventListeners = function() {
        this.emitter.removeAllListeners();
      };
      EventTarget2.prototype.removeEventListener = function(type, listener, options) {
        var capture = is_boolean_default(options) && options || is_object_default2(options) && options.capture;
        var context = isFunction(listener) ? void 0 : listener;
        type = capture ? "".concat(type, "capture") : type;
        listener = isFunction(listener) ? listener : listener === null || listener === void 0 ? void 0 : listener.handleEvent;
        this.emitter.off(type, listener, context);
        return this;
      };
      EventTarget2.prototype.emit = function(eventName, object) {
        this.dispatchEvent(new CustomEvent2(eventName, object));
      };
      EventTarget2.prototype.dispatchEvent = function(e3, skipPropagate) {
        var _a, _b;
        if (skipPropagate === void 0) {
          skipPropagate = false;
        }
        if (!isFederatedEvent(e3)) {
          throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
        }
        var canvas;
        if (this.document) {
          canvas = this;
        } else if (this.defaultView) {
          canvas = this.defaultView;
        } else {
          canvas = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
        }
        if (canvas) {
          e3.manager = canvas.getEventService() || null;
          if (!e3.manager) {
            return false;
          }
          e3.defaultPrevented = false;
          e3.path = [];
          if (!skipPropagate) {
            e3.target = this;
          }
          (_b = e3.manager) === null || _b === void 0 ? void 0 : _b.dispatchEvent(e3, e3.type, skipPropagate);
        }
        return !e3.defaultPrevented;
      };
      return EventTarget2;
    }()
  );
  var Node2 = (
    /** @class */
    function(_super) {
      __extends(Node6, _super);
      function Node6() {
        var _this = _super.call(this) || this;
        _this.shadow = false;
        _this.ownerDocument = null;
        _this.isConnected = false;
        _this.baseURI = "";
        _this.childNodes = [];
        _this.nodeType = 0;
        _this.nodeName = "";
        _this.nodeValue = null;
        _this.parentNode = null;
        return _this;
      }
      Node6.isNode = function(target) {
        return !!target.childNodes;
      };
      Object.defineProperty(Node6.prototype, "textContent", {
        /**
         * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Node/textContent
         */
        get: function() {
          var e_1, _a;
          var out = "";
          if (this.nodeName === Shape.TEXT) {
            out += this.style.text;
          }
          try {
            for (var _b = __values(this.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
              var child = _c.value;
              if (child.nodeName === Shape.TEXT) {
                out += child.nodeValue;
              } else {
                out += child.textContent;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return out;
        },
        set: function(content) {
          var _this = this;
          this.childNodes.slice().forEach(function(child) {
            _this.removeChild(child);
          });
          if (this.nodeName === Shape.TEXT) {
            this.style.text = "".concat(content);
          }
        },
        enumerable: false,
        configurable: true
      });
      Node6.prototype.getRootNode = function(opts) {
        if (opts === void 0) {
          opts = {};
        }
        if (this.parentNode) {
          return this.parentNode.getRootNode(opts);
        }
        if (opts.composed && this.host) {
          return this.host.getRootNode(opts);
        }
        return this;
      };
      Node6.prototype.hasChildNodes = function() {
        return this.childNodes.length > 0;
      };
      Node6.prototype.isDefaultNamespace = function(namespace) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Node6.prototype.lookupNamespaceURI = function(prefix) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Node6.prototype.lookupPrefix = function(namespace) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Node6.prototype.normalize = function() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Node6.prototype.isEqualNode = function(otherNode) {
        return this === otherNode;
      };
      Node6.prototype.isSameNode = function(otherNode) {
        return this.isEqualNode(otherNode);
      };
      Object.defineProperty(Node6.prototype, "parent", {
        /**
         * @deprecated
         * @alias parentNode
         */
        get: function() {
          return this.parentNode;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node6.prototype, "parentElement", {
        get: function() {
          return null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node6.prototype, "nextSibling", {
        get: function() {
          return null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node6.prototype, "previousSibling", {
        get: function() {
          return null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node6.prototype, "firstChild", {
        get: function() {
          return this.childNodes.length > 0 ? this.childNodes[0] : null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Node6.prototype, "lastChild", {
        get: function() {
          return this.childNodes.length > 0 ? this.childNodes[this.childNodes.length - 1] : null;
        },
        enumerable: false,
        configurable: true
      });
      Node6.prototype.compareDocumentPosition = function(other) {
        var _a;
        if (other === this) {
          return 0;
        }
        var node1Root = other;
        var node2Root = this;
        var node1Hierarchy = [node1Root];
        var node2Hierarchy = [node2Root];
        while ((_a = node1Root.parentNode) !== null && _a !== void 0 ? _a : node2Root.parentNode) {
          node1Root = node1Root.parentNode ? (node1Hierarchy.push(node1Root.parentNode), node1Root.parentNode) : node1Root;
          node2Root = node2Root.parentNode ? (node2Hierarchy.push(node2Root.parentNode), node2Root.parentNode) : node2Root;
        }
        if (node1Root !== node2Root) {
          return Node6.DOCUMENT_POSITION_DISCONNECTED | Node6.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | Node6.DOCUMENT_POSITION_PRECEDING;
        }
        var longerHierarchy = node1Hierarchy.length > node2Hierarchy.length ? node1Hierarchy : node2Hierarchy;
        var shorterHierarchy = longerHierarchy === node1Hierarchy ? node2Hierarchy : node1Hierarchy;
        if (longerHierarchy[longerHierarchy.length - shorterHierarchy.length] === shorterHierarchy[0]) {
          return longerHierarchy === node1Hierarchy ? (
            // other is a child of this
            Node6.DOCUMENT_POSITION_CONTAINED_BY | Node6.DOCUMENT_POSITION_FOLLOWING
          ) : (
            // this is a child of other
            Node6.DOCUMENT_POSITION_CONTAINS | Node6.DOCUMENT_POSITION_PRECEDING
          );
        }
        var longerStart = longerHierarchy.length - shorterHierarchy.length;
        for (var i = shorterHierarchy.length - 1; i >= 0; i--) {
          var shorterHierarchyNode = shorterHierarchy[i];
          var longerHierarchyNode = longerHierarchy[longerStart + i];
          if (longerHierarchyNode !== shorterHierarchyNode) {
            var siblings = shorterHierarchyNode.parentNode.childNodes;
            if (siblings.indexOf(shorterHierarchyNode) < siblings.indexOf(longerHierarchyNode)) {
              if (shorterHierarchy === node1Hierarchy) {
                return Node6.DOCUMENT_POSITION_PRECEDING;
              } else {
                return Node6.DOCUMENT_POSITION_FOLLOWING;
              }
            } else {
              if (longerHierarchy === node1Hierarchy) {
                return Node6.DOCUMENT_POSITION_PRECEDING;
              } else {
                return Node6.DOCUMENT_POSITION_FOLLOWING;
              }
            }
          }
        }
        return Node6.DOCUMENT_POSITION_FOLLOWING;
      };
      Node6.prototype.contain = function(other) {
        return this.contains(other);
      };
      Node6.prototype.contains = function(other) {
        var tmp2 = other;
        while (tmp2 && this !== tmp2) {
          tmp2 = tmp2.parentNode;
        }
        return !!tmp2;
      };
      Node6.prototype.getAncestor = function(n2) {
        var temp = this;
        while (n2 > 0 && temp) {
          temp = temp.parentNode;
          n2--;
        }
        return temp;
      };
      Node6.prototype.forEach = function(callback, assigned) {
        if (assigned === void 0) {
          assigned = false;
        }
        if (!callback(this)) {
          (assigned ? this.childNodes.slice() : this.childNodes).forEach(function(child) {
            child.forEach(callback);
          });
        }
      };
      Node6.DOCUMENT_POSITION_DISCONNECTED = 1;
      Node6.DOCUMENT_POSITION_PRECEDING = 2;
      Node6.DOCUMENT_POSITION_FOLLOWING = 4;
      Node6.DOCUMENT_POSITION_CONTAINS = 8;
      Node6.DOCUMENT_POSITION_CONTAINED_BY = 16;
      Node6.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32;
      return Node6;
    }(EventTarget)
  );
  var PROPAGATION_LIMIT = 2048;
  var EventService = (
    /** @class */
    function() {
      function EventService2(globalRuntime, context) {
        var _this = this;
        this.globalRuntime = globalRuntime;
        this.context = context;
        this.emitter = new eventemitter3_default();
        this.nativeHTMLMap = /* @__PURE__ */ new WeakMap();
        this.cursor = "default";
        this.mappingTable = {};
        this.mappingState = {
          trackingData: {}
        };
        this.eventPool = /* @__PURE__ */ new Map();
        this.tmpMatrix = mat4_exports.create();
        this.tmpVec3 = vec3_exports.create();
        this.onPointerDown = function(from) {
          var e3 = _this.createPointerEvent(from);
          _this.dispatchEvent(e3, "pointerdown");
          if (e3.pointerType === "touch") {
            _this.dispatchEvent(e3, "touchstart");
          } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
            var isRightButton = e3.button === 2;
            _this.dispatchEvent(e3, isRightButton ? "rightdown" : "mousedown");
          }
          var trackingData = _this.trackingData(from.pointerId);
          trackingData.pressTargetsByButton[from.button] = e3.composedPath();
          _this.freeEvent(e3);
        };
        this.onPointerUp = function(from) {
          var _a;
          var now4 = clock.now();
          var e3 = _this.createPointerEvent(from, void 0, void 0, _this.context.config.alwaysTriggerPointerEventOnCanvas ? _this.rootTarget : void 0);
          _this.dispatchEvent(e3, "pointerup");
          if (e3.pointerType === "touch") {
            _this.dispatchEvent(e3, "touchend");
          } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
            var isRightButton = e3.button === 2;
            _this.dispatchEvent(e3, isRightButton ? "rightup" : "mouseup");
          }
          var trackingData = _this.trackingData(from.pointerId);
          var pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          var clickTarget = pressTarget;
          if (pressTarget && !e3.composedPath().includes(pressTarget)) {
            var currentTarget = pressTarget;
            while (currentTarget && !e3.composedPath().includes(currentTarget)) {
              e3.currentTarget = currentTarget;
              _this.notifyTarget(e3, "pointerupoutside");
              if (e3.pointerType === "touch") {
                _this.notifyTarget(e3, "touchendoutside");
              } else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
                var isRightButton = e3.button === 2;
                _this.notifyTarget(e3, isRightButton ? "rightupoutside" : "mouseupoutside");
              }
              if (Node2.isNode(currentTarget)) {
                currentTarget = currentTarget.parentNode;
              }
            }
            delete trackingData.pressTargetsByButton[from.button];
            clickTarget = currentTarget;
          }
          if (clickTarget) {
            var clickEvent = _this.clonePointerEvent(e3, "click");
            clickEvent.target = clickTarget;
            clickEvent.path = [];
            if (!trackingData.clicksByButton[from.button]) {
              trackingData.clicksByButton[from.button] = {
                clickCount: 0,
                target: clickEvent.target,
                timeStamp: now4
              };
            }
            var clickHistory = trackingData.clicksByButton[from.button];
            if (clickHistory.target === clickEvent.target && now4 - clickHistory.timeStamp < 200) {
              ++clickHistory.clickCount;
            } else {
              clickHistory.clickCount = 1;
            }
            clickHistory.target = clickEvent.target;
            clickHistory.timeStamp = now4;
            clickEvent.detail = clickHistory.clickCount;
            if (!((_a = e3.detail) === null || _a === void 0 ? void 0 : _a.preventClick)) {
              if (!_this.context.config.useNativeClickEvent && (clickEvent.pointerType === "mouse" || clickEvent.pointerType === "touch")) {
                _this.dispatchEvent(clickEvent, "click");
              }
              _this.dispatchEvent(clickEvent, "pointertap");
            }
            _this.freeEvent(clickEvent);
          }
          _this.freeEvent(e3);
        };
        this.onPointerMove = function(from) {
          var e3 = _this.createPointerEvent(from, void 0, void 0, _this.context.config.alwaysTriggerPointerEventOnCanvas ? _this.rootTarget : void 0);
          var isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
          var trackingData = _this.trackingData(from.pointerId);
          var outTarget = _this.findMountedTarget(trackingData.overTargets);
          if (trackingData.overTargets && outTarget !== e3.target) {
            var outType = from.type === "mousemove" ? "mouseout" : "pointerout";
            var outEvent = _this.createPointerEvent(from, outType, outTarget || void 0);
            _this.dispatchEvent(outEvent, "pointerout");
            if (isMouse)
              _this.dispatchEvent(outEvent, "mouseout");
            if (!e3.composedPath().includes(outTarget)) {
              var leaveEvent = _this.createPointerEvent(from, "pointerleave", outTarget || void 0);
              leaveEvent.eventPhase = leaveEvent.AT_TARGET;
              while (leaveEvent.target && !e3.composedPath().includes(leaveEvent.target)) {
                leaveEvent.currentTarget = leaveEvent.target;
                _this.notifyTarget(leaveEvent);
                if (isMouse) {
                  _this.notifyTarget(leaveEvent, "mouseleave");
                }
                if (Node2.isNode(leaveEvent.target)) {
                  leaveEvent.target = leaveEvent.target.parentNode;
                }
              }
              _this.freeEvent(leaveEvent);
            }
            _this.freeEvent(outEvent);
          }
          if (outTarget !== e3.target) {
            var overType = from.type === "mousemove" ? "mouseover" : "pointerover";
            var overEvent = _this.clonePointerEvent(e3, overType);
            _this.dispatchEvent(overEvent, "pointerover");
            if (isMouse)
              _this.dispatchEvent(overEvent, "mouseover");
            var overTargetAncestor = outTarget && Node2.isNode(outTarget) && outTarget.parentNode;
            while (overTargetAncestor && overTargetAncestor !== (Node2.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
              if (overTargetAncestor === e3.target)
                break;
              overTargetAncestor = overTargetAncestor.parentNode;
            }
            var didPointerEnter = !overTargetAncestor || overTargetAncestor === (Node2.isNode(_this.rootTarget) && _this.rootTarget.parentNode);
            if (didPointerEnter) {
              var enterEvent = _this.clonePointerEvent(e3, "pointerenter");
              enterEvent.eventPhase = enterEvent.AT_TARGET;
              while (enterEvent.target && enterEvent.target !== outTarget && enterEvent.target !== (Node2.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
                enterEvent.currentTarget = enterEvent.target;
                _this.notifyTarget(enterEvent);
                if (isMouse)
                  _this.notifyTarget(enterEvent, "mouseenter");
                if (Node2.isNode(enterEvent.target)) {
                  enterEvent.target = enterEvent.target.parentNode;
                }
              }
              _this.freeEvent(enterEvent);
            }
            _this.freeEvent(overEvent);
          }
          _this.dispatchEvent(e3, "pointermove");
          if (e3.pointerType === "touch")
            _this.dispatchEvent(e3, "touchmove");
          if (isMouse) {
            _this.dispatchEvent(e3, "mousemove");
            _this.cursor = _this.getCursor(e3.target);
          }
          trackingData.overTargets = e3.composedPath();
          _this.freeEvent(e3);
        };
        this.onPointerOut = function(from) {
          var trackingData = _this.trackingData(from.pointerId);
          if (trackingData.overTargets) {
            var isMouse = from.pointerType === "mouse" || from.pointerType === "pen";
            var outTarget = _this.findMountedTarget(trackingData.overTargets);
            var outEvent = _this.createPointerEvent(from, "pointerout", outTarget || void 0);
            _this.dispatchEvent(outEvent);
            if (isMouse)
              _this.dispatchEvent(outEvent, "mouseout");
            var leaveEvent = _this.createPointerEvent(from, "pointerleave", outTarget || void 0);
            leaveEvent.eventPhase = leaveEvent.AT_TARGET;
            while (leaveEvent.target && leaveEvent.target !== (Node2.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
              leaveEvent.currentTarget = leaveEvent.target;
              _this.notifyTarget(leaveEvent);
              if (isMouse) {
                _this.notifyTarget(leaveEvent, "mouseleave");
              }
              if (Node2.isNode(leaveEvent.target)) {
                leaveEvent.target = leaveEvent.target.parentNode;
              }
            }
            trackingData.overTargets = null;
            _this.freeEvent(outEvent);
            _this.freeEvent(leaveEvent);
          }
          _this.cursor = null;
        };
        this.onPointerOver = function(from) {
          var trackingData = _this.trackingData(from.pointerId);
          var e3 = _this.createPointerEvent(from);
          var isMouse = e3.pointerType === "mouse" || e3.pointerType === "pen";
          _this.dispatchEvent(e3, "pointerover");
          if (isMouse)
            _this.dispatchEvent(e3, "mouseover");
          if (e3.pointerType === "mouse")
            _this.cursor = _this.getCursor(e3.target);
          var enterEvent = _this.clonePointerEvent(e3, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          while (enterEvent.target && enterEvent.target !== (Node2.isNode(_this.rootTarget) && _this.rootTarget.parentNode)) {
            enterEvent.currentTarget = enterEvent.target;
            _this.notifyTarget(enterEvent);
            if (isMouse) {
              _this.notifyTarget(enterEvent, "mouseenter");
            }
            if (Node2.isNode(enterEvent.target)) {
              enterEvent.target = enterEvent.target.parentNode;
            }
          }
          trackingData.overTargets = e3.composedPath();
          _this.freeEvent(e3);
          _this.freeEvent(enterEvent);
        };
        this.onPointerUpOutside = function(from) {
          var trackingData = _this.trackingData(from.pointerId);
          var pressTarget = _this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
          var e3 = _this.createPointerEvent(from);
          if (pressTarget) {
            var currentTarget = pressTarget;
            while (currentTarget) {
              e3.currentTarget = currentTarget;
              _this.notifyTarget(e3, "pointerupoutside");
              if (e3.pointerType === "touch") ;
              else if (e3.pointerType === "mouse" || e3.pointerType === "pen") {
                _this.notifyTarget(e3, e3.button === 2 ? "rightupoutside" : "mouseupoutside");
              }
              if (Node2.isNode(currentTarget)) {
                currentTarget = currentTarget.parentNode;
              }
            }
            delete trackingData.pressTargetsByButton[from.button];
          }
          _this.freeEvent(e3);
        };
        this.onWheel = function(from) {
          var wheelEvent = _this.createWheelEvent(from);
          _this.dispatchEvent(wheelEvent);
          _this.freeEvent(wheelEvent);
        };
        this.onClick = function(from) {
          if (_this.context.config.useNativeClickEvent) {
            var e3 = _this.createPointerEvent(from);
            _this.dispatchEvent(e3);
            _this.freeEvent(e3);
          }
        };
        this.onPointerCancel = function(from) {
          var e3 = _this.createPointerEvent(from, void 0, void 0, _this.context.config.alwaysTriggerPointerEventOnCanvas ? _this.rootTarget : void 0);
          _this.dispatchEvent(e3);
          _this.freeEvent(e3);
        };
      }
      EventService2.prototype.init = function() {
        this.rootTarget = this.context.renderingContext.root.parentNode;
        this.addEventMapping("pointerdown", this.onPointerDown);
        this.addEventMapping("pointerup", this.onPointerUp);
        this.addEventMapping("pointermove", this.onPointerMove);
        this.addEventMapping("pointerout", this.onPointerOut);
        this.addEventMapping("pointerleave", this.onPointerOut);
        this.addEventMapping("pointercancel", this.onPointerCancel);
        this.addEventMapping("pointerover", this.onPointerOver);
        this.addEventMapping("pointerupoutside", this.onPointerUpOutside);
        this.addEventMapping("wheel", this.onWheel);
        this.addEventMapping("click", this.onClick);
      };
      EventService2.prototype.destroy = function() {
        this.emitter.removeAllListeners();
        this.mappingTable = {};
        this.mappingState = {};
        this.eventPool.clear();
      };
      EventService2.prototype.getScale = function() {
        var bbox = this.context.contextService.getBoundingClientRect();
        var scaleX = 1;
        var scaleY = 1;
        var $el = this.context.contextService.getDomElement();
        if ($el && bbox) {
          var offsetWidth = $el.offsetWidth, offsetHeight = $el.offsetHeight;
          if (offsetWidth && offsetHeight) {
            scaleX = bbox.width / offsetWidth;
            scaleY = bbox.height / offsetHeight;
          }
        }
        return {
          scaleX,
          scaleY,
          bbox
        };
      };
      EventService2.prototype.client2Viewport = function(client) {
        var _a = this.getScale(), scaleX = _a.scaleX, scaleY = _a.scaleY, bbox = _a.bbox;
        return new Point2((client.x - ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) / scaleX, (client.y - ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) / scaleY);
      };
      EventService2.prototype.viewport2Client = function(canvas) {
        var _a = this.getScale(), scaleX = _a.scaleX, scaleY = _a.scaleY, bbox = _a.bbox;
        return new Point2((canvas.x + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0)) * scaleX, (canvas.y + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0)) * scaleY);
      };
      EventService2.prototype.viewport2Canvas = function(_a) {
        var x3 = _a.x, y3 = _a.y;
        var canvas = this.rootTarget.defaultView;
        var camera = canvas.getCamera();
        var _b = this.context.config, width = _b.width, height = _b.height;
        var projectionMatrixInverse = camera.getPerspectiveInverse();
        var worldMatrix = camera.getWorldTransform();
        var vpMatrix = mat4_exports.multiply(this.tmpMatrix, worldMatrix, projectionMatrixInverse);
        var viewport = vec3_exports.set(this.tmpVec3, x3 / width * 2 - 1, (1 - y3 / height) * 2 - 1, 0);
        vec3_exports.transformMat4(viewport, viewport, vpMatrix);
        return new Point2(viewport[0], viewport[1]);
      };
      EventService2.prototype.canvas2Viewport = function(canvasP) {
        var canvas = this.rootTarget.defaultView;
        var camera = canvas.getCamera();
        var projectionMatrix = camera.getPerspective();
        var viewMatrix = camera.getViewTransform();
        var vpMatrix = mat4_exports.multiply(this.tmpMatrix, projectionMatrix, viewMatrix);
        var clip = vec3_exports.set(this.tmpVec3, canvasP.x, canvasP.y, 0);
        vec3_exports.transformMat4(this.tmpVec3, this.tmpVec3, vpMatrix);
        var _a = this.context.config, width = _a.width, height = _a.height;
        return new Point2((clip[0] + 1) / 2 * width, (1 - (clip[1] + 1) / 2) * height);
      };
      EventService2.prototype.setPickHandler = function(pickHandler) {
        this.pickHandler = pickHandler;
      };
      EventService2.prototype.addEventMapping = function(type, fn) {
        if (!this.mappingTable[type]) {
          this.mappingTable[type] = [];
        }
        this.mappingTable[type].push({
          fn,
          priority: 0
        });
        this.mappingTable[type].sort(function(a3, b) {
          return a3.priority - b.priority;
        });
      };
      EventService2.prototype.mapEvent = function(e3) {
        if (!this.rootTarget) {
          return;
        }
        var mappers = this.mappingTable[e3.type];
        if (mappers) {
          for (var i = 0, j = mappers.length; i < j; i++) {
            mappers[i].fn(e3);
          }
        } else {
          console.warn("[EventService]: Event mapping not defined for ".concat(e3.type));
        }
      };
      EventService2.prototype.dispatchEvent = function(e3, type, skipPropagate) {
        if (!skipPropagate) {
          e3.propagationStopped = false;
          e3.propagationImmediatelyStopped = false;
          this.propagate(e3, type);
        } else {
          e3.eventPhase = e3.AT_TARGET;
          var canvas = this.rootTarget.defaultView || null;
          e3.currentTarget = canvas;
          this.notifyListeners(e3, type);
        }
        this.emitter.emit(type || e3.type, e3);
      };
      EventService2.prototype.propagate = function(e3, type) {
        if (!e3.target) {
          return;
        }
        var composedPath = e3.composedPath();
        e3.eventPhase = e3.CAPTURING_PHASE;
        for (var i = composedPath.length - 1; i >= 1; i--) {
          e3.currentTarget = composedPath[i];
          this.notifyTarget(e3, type);
          if (e3.propagationStopped || e3.propagationImmediatelyStopped)
            return;
        }
        e3.eventPhase = e3.AT_TARGET;
        e3.currentTarget = e3.target;
        this.notifyTarget(e3, type);
        if (e3.propagationStopped || e3.propagationImmediatelyStopped)
          return;
        var index4 = composedPath.indexOf(e3.currentTarget);
        e3.eventPhase = e3.BUBBLING_PHASE;
        for (var i = index4 + 1; i < composedPath.length; i++) {
          e3.currentTarget = composedPath[i];
          this.notifyTarget(e3, type);
          if (e3.propagationStopped || e3.propagationImmediatelyStopped)
            return;
        }
      };
      EventService2.prototype.propagationPath = function(target) {
        var propagationPath = [target];
        var canvas = this.rootTarget.defaultView || null;
        if (canvas && canvas === target) {
          propagationPath.unshift(canvas.document);
          return propagationPath;
        }
        for (var i = 0; i < PROPAGATION_LIMIT && target !== this.rootTarget; i++) {
          if (Node2.isNode(target) && target.parentNode) {
            propagationPath.push(target.parentNode);
            target = target.parentNode;
          }
        }
        if (canvas) {
          propagationPath.push(canvas);
        }
        return propagationPath;
      };
      EventService2.prototype.hitTest = function(position) {
        var viewportX = position.viewportX, viewportY = position.viewportY;
        var _a = this.context.config, width = _a.width, height = _a.height, disableHitTesting = _a.disableHitTesting;
        if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
          return null;
        }
        return !disableHitTesting && this.pickHandler(position) || this.rootTarget || // return Document
        null;
      };
      EventService2.prototype.isNativeEventFromCanvas = function($el, nativeEvent) {
        var target = nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.target;
        if (target === null || target === void 0 ? void 0 : target.shadowRoot) {
          target = nativeEvent.composedPath()[0];
        }
        if (target) {
          if (target === $el) {
            return true;
          }
          if ($el && $el.contains) {
            return $el.contains(target);
          }
        }
        if (nativeEvent === null || nativeEvent === void 0 ? void 0 : nativeEvent.composedPath) {
          return nativeEvent.composedPath().indexOf($el) > -1;
        }
        return false;
      };
      EventService2.prototype.getExistedHTML = function(event) {
        var e_1, _a;
        if (event.nativeEvent.composedPath) {
          try {
            for (var _b = __values(event.nativeEvent.composedPath()), _c = _b.next(); !_c.done; _c = _b.next()) {
              var eventTarget = _c.value;
              var existed = this.nativeHTMLMap.get(eventTarget);
              if (existed) {
                return existed;
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
        }
        return null;
      };
      EventService2.prototype.pickTarget = function(event) {
        return this.hitTest({
          clientX: event.clientX,
          clientY: event.clientY,
          viewportX: event.viewportX,
          viewportY: event.viewportY,
          x: event.canvasX,
          y: event.canvasY
        });
      };
      EventService2.prototype.createPointerEvent = function(from, type, target, fallbackTarget) {
        var event = this.allocateEvent(FederatedPointerEvent);
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        var existedHTML = this.getExistedHTML(event);
        var $el = this.context.contextService.getDomElement();
        event.target = target !== null && target !== void 0 ? target : existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event) || fallbackTarget;
        if (typeof type === "string") {
          event.type = type;
        }
        return event;
      };
      EventService2.prototype.createWheelEvent = function(from) {
        var event = this.allocateEvent(FederatedWheelEvent);
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from;
        var existedHTML = this.getExistedHTML(event);
        var $el = this.context.contextService.getDomElement();
        event.target = existedHTML || this.isNativeEventFromCanvas($el, event.nativeEvent) && this.pickTarget(event);
        return event;
      };
      EventService2.prototype.trackingData = function(id4) {
        if (!this.mappingState.trackingData[id4]) {
          this.mappingState.trackingData[id4] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
          };
        }
        return this.mappingState.trackingData[id4];
      };
      EventService2.prototype.cloneWheelEvent = function(from) {
        var event = this.allocateEvent(FederatedWheelEvent);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyWheelData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = from.type;
        return event;
      };
      EventService2.prototype.clonePointerEvent = function(from, type) {
        var event = this.allocateEvent(FederatedPointerEvent);
        event.nativeEvent = from.nativeEvent;
        event.originalEvent = from.originalEvent;
        this.copyPointerData(from, event);
        this.copyMouseData(from, event);
        this.copyData(from, event);
        event.target = from.target;
        event.path = from.composedPath().slice();
        event.type = type !== null && type !== void 0 ? type : event.type;
        return event;
      };
      EventService2.prototype.copyPointerData = function(from, to) {
        to.pointerId = from.pointerId;
        to.width = from.width;
        to.height = from.height;
        to.isPrimary = from.isPrimary;
        to.pointerType = from.pointerType;
        to.pressure = from.pressure;
        to.tangentialPressure = from.tangentialPressure;
        to.tiltX = from.tiltX;
        to.tiltY = from.tiltY;
        to.twist = from.twist;
      };
      EventService2.prototype.copyMouseData = function(from, to) {
        to.altKey = from.altKey;
        to.button = from.button;
        to.buttons = from.buttons;
        to.ctrlKey = from.ctrlKey;
        to.metaKey = from.metaKey;
        to.shiftKey = from.shiftKey;
        to.client.copyFrom(from.client);
        to.movement.copyFrom(from.movement);
        to.canvas.copyFrom(from.canvas);
        to.screen.copyFrom(from.screen);
        to.global.copyFrom(from.global);
        to.offset.copyFrom(from.offset);
      };
      EventService2.prototype.copyWheelData = function(from, to) {
        to.deltaMode = from.deltaMode;
        to.deltaX = from.deltaX;
        to.deltaY = from.deltaY;
        to.deltaZ = from.deltaZ;
      };
      EventService2.prototype.copyData = function(from, to) {
        to.isTrusted = from.isTrusted;
        to.timeStamp = clock.now();
        to.type = from.type;
        to.detail = from.detail;
        to.view = from.view;
        to.page.copyFrom(from.page);
        to.viewport.copyFrom(from.viewport);
      };
      EventService2.prototype.allocateEvent = function(constructor) {
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        var event = this.eventPool.get(constructor).pop() || new constructor(this);
        event.eventPhase = event.NONE;
        event.currentTarget = null;
        event.path = [];
        event.target = null;
        return event;
      };
      EventService2.prototype.freeEvent = function(event) {
        if (event.manager !== this)
          throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        var constructor = event.constructor;
        if (!this.eventPool.has(constructor)) {
          this.eventPool.set(constructor, []);
        }
        this.eventPool.get(constructor).push(event);
      };
      EventService2.prototype.notifyTarget = function(e3, type) {
        type = type !== null && type !== void 0 ? type : e3.type;
        var key = e3.eventPhase === e3.CAPTURING_PHASE || e3.eventPhase === e3.AT_TARGET ? "".concat(type, "capture") : type;
        this.notifyListeners(e3, key);
        if (e3.eventPhase === e3.AT_TARGET) {
          this.notifyListeners(e3, type);
        }
      };
      EventService2.prototype.notifyListeners = function(e3, type) {
        var emitter = e3.currentTarget.emitter;
        var listeners = emitter._events[type];
        if (!listeners)
          return;
        if ("fn" in listeners) {
          if (listeners.once) {
            emitter.removeListener(type, listeners.fn, void 0, true);
          }
          listeners.fn.call(e3.currentTarget || listeners.context, e3);
        } else {
          for (var i = 0; i < listeners.length && !e3.propagationImmediatelyStopped; i++) {
            if (listeners[i].once) {
              emitter.removeListener(type, listeners[i].fn, void 0, true);
            }
            listeners[i].fn.call(e3.currentTarget || listeners[i].context, e3);
          }
        }
      };
      EventService2.prototype.findMountedTarget = function(propagationPath) {
        if (!propagationPath) {
          return null;
        }
        var currentTarget = propagationPath[propagationPath.length - 1];
        for (var i = propagationPath.length - 2; i >= 0; i--) {
          var target = propagationPath[i];
          if (target === this.rootTarget || Node2.isNode(target) && target.parentNode === currentTarget) {
            currentTarget = propagationPath[i];
          } else {
            break;
          }
        }
        return currentTarget;
      };
      EventService2.prototype.getCursor = function(target) {
        var tmp2 = target;
        while (tmp2) {
          var cursor = isElement(tmp2) && tmp2.getAttribute("cursor");
          if (cursor) {
            return cursor;
          }
          tmp2 = Node2.isNode(tmp2) && tmp2.parentNode;
        }
      };
      return EventService2;
    }()
  );
  var OffscreenCanvasCreator = (
    /** @class */
    function() {
      function OffscreenCanvasCreator2() {
      }
      OffscreenCanvasCreator2.prototype.getOrCreateCanvas = function(offscreenCanvas, contextAttributes) {
        if (this.canvas) {
          return this.canvas;
        }
        if (offscreenCanvas || runtime.offscreenCanvas) {
          this.canvas = offscreenCanvas || runtime.offscreenCanvas;
          this.context = this.canvas.getContext("2d", __assign({ willReadFrequently: true }, contextAttributes));
        } else {
          try {
            this.canvas = new window.OffscreenCanvas(0, 0);
            this.context = this.canvas.getContext("2d", __assign({ willReadFrequently: true }, contextAttributes));
            if (!this.context || !this.context.measureText) {
              this.canvas = document.createElement("canvas");
              this.context = this.canvas.getContext("2d");
            }
          } catch (ex) {
            this.canvas = document.createElement("canvas");
            this.context = this.canvas.getContext("2d", __assign({ willReadFrequently: true }, contextAttributes));
          }
        }
        this.canvas.width = 10;
        this.canvas.height = 10;
        return this.canvas;
      };
      OffscreenCanvasCreator2.prototype.getOrCreateContext = function(offscreenCanvas, contextAttributes) {
        if (this.context) {
          return this.context;
        }
        this.getOrCreateCanvas(offscreenCanvas, contextAttributes);
        return this.context;
      };
      return OffscreenCanvasCreator2;
    }()
  );
  var RenderReason;
  (function(RenderReason2) {
    RenderReason2[RenderReason2["CAMERA_CHANGED"] = 0] = "CAMERA_CHANGED";
    RenderReason2[RenderReason2["DISPLAY_OBJECT_CHANGED"] = 1] = "DISPLAY_OBJECT_CHANGED";
    RenderReason2[RenderReason2["NONE"] = 2] = "NONE";
  })(RenderReason || (RenderReason = {}));
  var RenderingService = (
    /** @class */
    function() {
      function RenderingService2(globalRuntime, context) {
        this.globalRuntime = globalRuntime;
        this.context = context;
        this.inited = false;
        this.stats = {
          /**
           * total display objects in scenegraph
           */
          total: 0,
          /**
           * number of display objects need to render in current frame
           */
          rendered: 0
        };
        this.zIndexCounter = 0;
        this.hooks = {
          /**
           * called before any frame rendered
           */
          init: new SyncHook(),
          initAsync: new AsyncParallelHook(),
          /**
           * only dirty object which has sth changed will be rendered
           */
          dirtycheck: new SyncWaterfallHook(),
          /**
           * do culling
           */
          cull: new SyncWaterfallHook(),
          /**
           * called at beginning of each frame, won't get called if nothing to re-render
           */
          beginFrame: new SyncHook(),
          /**
           * called before every dirty object get rendered
           */
          beforeRender: new SyncHook(),
          /**
           * called when every dirty object rendering even it's culled
           */
          render: new SyncHook(),
          /**
           * called after every dirty object get rendered
           */
          afterRender: new SyncHook(),
          endFrame: new SyncHook(),
          destroy: new SyncHook(),
          /**
           * use async but faster method such as GPU-based picking in `g-plugin-device-renderer`
           */
          pick: new AsyncSeriesWaterfallHook(),
          /**
           * Unsafe but sync version of pick.
           */
          pickSync: new SyncWaterfallHook(),
          /**
           * used in event system
           */
          pointerDown: new SyncHook(),
          pointerUp: new SyncHook(),
          pointerMove: new SyncHook(),
          pointerOut: new SyncHook(),
          pointerOver: new SyncHook(),
          pointerWheel: new SyncHook(),
          pointerCancel: new SyncHook(),
          click: new SyncHook()
        };
      }
      RenderingService2.prototype.init = function(callback) {
        var _this = this;
        var context = __assign(__assign({}, this.globalRuntime), this.context);
        this.context.renderingPlugins.forEach(function(plugin) {
          plugin.apply(context, _this.globalRuntime);
        });
        this.hooks.init.call();
        if (this.hooks.initAsync.getCallbacksNum() === 0) {
          this.inited = true;
          callback();
        } else {
          this.hooks.initAsync.promise().then(function() {
            _this.inited = true;
            callback();
          });
        }
      };
      RenderingService2.prototype.getStats = function() {
        return this.stats;
      };
      RenderingService2.prototype.disableDirtyRectangleRendering = function() {
        var renderer = this.context.config.renderer;
        var enableDirtyRectangleRendering = renderer.getConfig().enableDirtyRectangleRendering;
        return !enableDirtyRectangleRendering || this.context.renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
      };
      RenderingService2.prototype.render = function(canvasConfig, frame2, rerenderCallback) {
        var _this = this;
        this.stats.total = 0;
        this.stats.rendered = 0;
        this.zIndexCounter = 0;
        var renderingContext = this.context.renderingContext;
        this.globalRuntime.sceneGraphService.syncHierarchy(renderingContext.root);
        this.globalRuntime.sceneGraphService.triggerPendingEvents();
        if (renderingContext.renderReasons.size && this.inited) {
          renderingContext.dirtyRectangleRenderingDisabled = this.disableDirtyRectangleRendering();
          var onlyCameraChanged = renderingContext.renderReasons.size === 1 && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED);
          var shouldTriggerRenderHooks = !canvasConfig.disableRenderHooks || !(canvasConfig.disableRenderHooks && onlyCameraChanged);
          if (shouldTriggerRenderHooks) {
            this.renderDisplayObject(renderingContext.root, canvasConfig, renderingContext);
          }
          this.hooks.beginFrame.call(frame2);
          if (shouldTriggerRenderHooks) {
            renderingContext.renderListCurrentFrame.forEach(function(object) {
              _this.hooks.beforeRender.call(object);
              _this.hooks.render.call(object);
              _this.hooks.afterRender.call(object);
            });
          }
          this.hooks.endFrame.call(frame2);
          renderingContext.renderListCurrentFrame = [];
          renderingContext.renderReasons.clear();
          rerenderCallback();
        }
      };
      RenderingService2.prototype.renderDisplayObject = function(displayObject, canvasConfig, renderingContext) {
        var _this = this;
        var _a = canvasConfig.renderer.getConfig(), enableDirtyCheck = _a.enableDirtyCheck, enableCulling = _a.enableCulling;
        if (this.globalRuntime.enableCSSParsing) {
          this.globalRuntime.styleValueRegistry.recalc(displayObject);
        }
        var renderable = displayObject.renderable;
        var objectChanged = enableDirtyCheck ? (
          // @ts-ignore
          renderable.dirty || renderingContext.dirtyRectangleRenderingDisabled ? displayObject : null
        ) : displayObject;
        if (objectChanged) {
          var objectToRender = enableCulling ? this.hooks.cull.call(objectChanged, this.context.camera) : objectChanged;
          if (objectToRender) {
            this.stats.rendered++;
            renderingContext.renderListCurrentFrame.push(objectToRender);
          }
        }
        displayObject.renderable.dirty = false;
        displayObject.sortable.renderOrder = this.zIndexCounter++;
        this.stats.total++;
        var sortable = displayObject.sortable;
        if (sortable.dirty) {
          this.sort(displayObject, sortable);
          sortable.dirty = false;
          sortable.dirtyChildren = [];
          sortable.dirtyReason = void 0;
        }
        (sortable.sorted || displayObject.childNodes).forEach(function(child) {
          _this.renderDisplayObject(child, canvasConfig, renderingContext);
        });
      };
      RenderingService2.prototype.sort = function(displayObject, sortable) {
        if (sortable.sorted && sortable.dirtyReason !== SortReason.Z_INDEX_CHANGED) {
          sortable.dirtyChildren.forEach(function(child) {
            var index4 = displayObject.childNodes.indexOf(child);
            if (index4 === -1) {
              var index_1 = sortable.sorted.indexOf(child);
              if (index_1 >= 0) {
                sortable.sorted.splice(index_1, 1);
              }
            } else {
              if (sortable.sorted.length === 0) {
                sortable.sorted.push(child);
              } else {
                var index_2 = sortedIndex(sortable.sorted, child);
                sortable.sorted.splice(index_2, 0, child);
              }
            }
          });
        } else {
          sortable.sorted = displayObject.childNodes.slice().sort(sortByZIndex);
        }
      };
      RenderingService2.prototype.destroy = function() {
        this.inited = false;
        this.hooks.destroy.call();
        this.globalRuntime.sceneGraphService.clearPendingEvents();
      };
      RenderingService2.prototype.dirtify = function() {
        this.context.renderingContext.renderReasons.add(RenderReason.DISPLAY_OBJECT_CHANGED);
      };
      return RenderingService2;
    }()
  );
  var ATTRIBUTE_REGEXP = /\[\s*(.*)=(.*)\s*\]/;
  var DefaultSceneGraphSelector = (
    /** @class */
    function() {
      function DefaultSceneGraphSelector2() {
      }
      DefaultSceneGraphSelector2.prototype.selectOne = function(query, root2) {
        var _this = this;
        if (query.startsWith(".")) {
          return root2.find(function(node) {
            return ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this.getIdOrClassname(query)) > -1;
          });
        } else if (query.startsWith("#")) {
          return root2.find(function(node) {
            return node.id === _this.getIdOrClassname(query);
          });
        } else if (query.startsWith("[")) {
          var _a = this.getAttribute(query), name_1 = _a.name, value_1 = _a.value;
          if (name_1) {
            return root2.find(function(node) {
              return root2 !== node && (name_1 === "name" ? node.name === value_1 : _this.attributeToString(node, name_1) === value_1);
            });
          } else {
            return null;
          }
        } else {
          return root2.find(function(node) {
            return root2 !== node && node.nodeName === query;
          });
        }
      };
      DefaultSceneGraphSelector2.prototype.selectAll = function(query, root2) {
        var _this = this;
        if (query.startsWith(".")) {
          return root2.findAll(function(node) {
            return root2 !== node && ((node === null || node === void 0 ? void 0 : node.classList) || []).indexOf(_this.getIdOrClassname(query)) > -1;
          });
        } else if (query.startsWith("#")) {
          return root2.findAll(function(node) {
            return root2 !== node && node.id === _this.getIdOrClassname(query);
          });
        } else if (query.startsWith("[")) {
          var _a = this.getAttribute(query), name_2 = _a.name, value_2 = _a.value;
          if (name_2) {
            return root2.findAll(function(node) {
              return root2 !== node && (name_2 === "name" ? node.name === value_2 : _this.attributeToString(node, name_2) === value_2);
            });
          } else {
            return [];
          }
        } else {
          return root2.findAll(function(node) {
            return root2 !== node && node.nodeName === query;
          });
        }
      };
      DefaultSceneGraphSelector2.prototype.is = function(query, node) {
        if (query.startsWith(".")) {
          return node.className === this.getIdOrClassname(query);
        } else if (query.startsWith("#")) {
          return node.id === this.getIdOrClassname(query);
        } else if (query.startsWith("[")) {
          var _a = this.getAttribute(query), name_3 = _a.name, value2 = _a.value;
          return name_3 === "name" ? node.name === value2 : this.attributeToString(node, name_3) === value2;
        } else {
          return node.nodeName === query;
        }
      };
      DefaultSceneGraphSelector2.prototype.getIdOrClassname = function(query) {
        return query.substring(1);
      };
      DefaultSceneGraphSelector2.prototype.getAttribute = function(query) {
        var matches2 = query.match(ATTRIBUTE_REGEXP);
        var name2 = "";
        var value2 = "";
        if (matches2 && matches2.length > 2) {
          name2 = matches2[1].replace(/"/g, "");
          value2 = matches2[2].replace(/"/g, "");
        }
        return { name: name2, value: value2 };
      };
      DefaultSceneGraphSelector2.prototype.attributeToString = function(node, name2) {
        if (!node.getAttribute) {
          return "";
        }
        var value2 = node.getAttribute(name2);
        if (is_nil_default2(value2)) {
          return "";
        }
        if (value2.toString) {
          return value2.toString();
        }
        return "";
      };
      return DefaultSceneGraphSelector2;
    }()
  );
  var MutationEvent = (
    /** @class */
    function(_super) {
      __extends(MutationEvent2, _super);
      function MutationEvent2(typeArg, relatedNode, prevValue, newValue, attrName, attrChange, prevParsedValue, newParsedValue) {
        var _this = _super.call(this, null) || this;
        _this.relatedNode = relatedNode;
        _this.prevValue = prevValue;
        _this.newValue = newValue;
        _this.attrName = attrName;
        _this.attrChange = attrChange;
        _this.prevParsedValue = prevParsedValue;
        _this.newParsedValue = newParsedValue;
        _this.type = typeArg;
        return _this;
      }
      MutationEvent2.ADDITION = 2;
      MutationEvent2.MODIFICATION = 1;
      MutationEvent2.REMOVAL = 3;
      return MutationEvent2;
    }(FederatedEvent)
  );
  var ElementEvent;
  (function(ElementEvent2) {
    ElementEvent2["REPARENT"] = "reparent";
    ElementEvent2["DESTROY"] = "destroy";
    ElementEvent2["ATTR_MODIFIED"] = "DOMAttrModified";
    ElementEvent2["INSERTED"] = "DOMNodeInserted";
    ElementEvent2["REMOVED"] = "removed";
    ElementEvent2["MOUNTED"] = "DOMNodeInsertedIntoDocument";
    ElementEvent2["UNMOUNTED"] = "DOMNodeRemovedFromDocument";
    ElementEvent2["BOUNDS_CHANGED"] = "bounds-changed";
    ElementEvent2["CULLED"] = "culled";
  })(ElementEvent || (ElementEvent = {}));
  function markRenderableDirty(e3) {
    var renderable = e3.renderable;
    if (renderable) {
      renderable.renderBoundsDirty = true;
      renderable.boundsDirty = true;
    }
  }
  var reparentEvent = new MutationEvent(ElementEvent.REPARENT, null, "", "", "", 0, "", "");
  var DefaultSceneGraphService = (
    /** @class */
    function() {
      function DefaultSceneGraphService2(runtime2) {
        var _this = this;
        this.runtime = runtime2;
        this.pendingEvents = [];
        this.boundsChangedEvent = new CustomEvent2(ElementEvent.BOUNDS_CHANGED);
        this.rotate = function() {
          var parentInvertRotation = quat_exports.create();
          return function(element, degrees3, y3, z, dirtify) {
            if (y3 === void 0) {
              y3 = 0;
            }
            if (z === void 0) {
              z = 0;
            }
            if (dirtify === void 0) {
              dirtify = true;
            }
            if (typeof degrees3 === "number") {
              degrees3 = vec3_exports.fromValues(degrees3, y3, z);
            }
            var transform = element.transformable;
            if (element.parentNode === null || !element.parentNode.transformable) {
              _this.rotateLocal(element, degrees3);
            } else {
              var rotation = quat_exports.create();
              quat_exports.fromEuler(rotation, degrees3[0], degrees3[1], degrees3[2]);
              var rot = _this.getRotation(element);
              var parentRot = _this.getRotation(element.parentNode);
              quat_exports.copy(parentInvertRotation, parentRot);
              quat_exports.invert(parentInvertRotation, parentInvertRotation);
              quat_exports.multiply(rotation, parentInvertRotation, rotation);
              quat_exports.multiply(transform.localRotation, rotation, rot);
              quat_exports.normalize(transform.localRotation, transform.localRotation);
              if (dirtify) {
                _this.dirtifyLocal(element, transform);
              }
            }
          };
        }();
        this.rotateLocal = function() {
          var rotation = quat_exports.create();
          return function(element, degrees3, y3, z, dirtify) {
            if (y3 === void 0) {
              y3 = 0;
            }
            if (z === void 0) {
              z = 0;
            }
            if (dirtify === void 0) {
              dirtify = true;
            }
            if (typeof degrees3 === "number") {
              degrees3 = vec3_exports.fromValues(degrees3, y3, z);
            }
            var transform = element.transformable;
            quat_exports.fromEuler(rotation, degrees3[0], degrees3[1], degrees3[2]);
            quat_exports.mul(transform.localRotation, transform.localRotation, rotation);
            if (dirtify) {
              _this.dirtifyLocal(element, transform);
            }
          };
        }();
        this.setEulerAngles = function() {
          var invParentRot = quat_exports.create();
          return function(element, degrees3, y3, z, dirtify) {
            if (y3 === void 0) {
              y3 = 0;
            }
            if (z === void 0) {
              z = 0;
            }
            if (dirtify === void 0) {
              dirtify = true;
            }
            if (typeof degrees3 === "number") {
              degrees3 = vec3_exports.fromValues(degrees3, y3, z);
            }
            var transform = element.transformable;
            if (element.parentNode === null || !element.parentNode.transformable) {
              _this.setLocalEulerAngles(element, degrees3);
            } else {
              quat_exports.fromEuler(transform.localRotation, degrees3[0], degrees3[1], degrees3[2]);
              var parentRotation = _this.getRotation(element.parentNode);
              quat_exports.copy(invParentRot, quat_exports.invert(quat_exports.create(), parentRotation));
              quat_exports.mul(transform.localRotation, transform.localRotation, invParentRot);
              if (dirtify) {
                _this.dirtifyLocal(element, transform);
              }
            }
          };
        }();
        this.translateLocal = /* @__PURE__ */ function() {
          return function(element, translation, y3, z, dirtify) {
            if (y3 === void 0) {
              y3 = 0;
            }
            if (z === void 0) {
              z = 0;
            }
            if (dirtify === void 0) {
              dirtify = true;
            }
            if (typeof translation === "number") {
              translation = vec3_exports.fromValues(translation, y3, z);
            }
            var transform = element.transformable;
            if (vec3_exports.equals(translation, vec3_exports.create())) {
              return;
            }
            vec3_exports.transformQuat(translation, translation, transform.localRotation);
            vec3_exports.add(transform.localPosition, transform.localPosition, translation);
            if (dirtify) {
              _this.dirtifyLocal(element, transform);
            }
          };
        }();
        this.setPosition = function() {
          var parentInvertMatrix = mat4_exports.create();
          var tmpPosition = vec3_exports.create();
          return function(element, position, dirtify) {
            if (dirtify === void 0) {
              dirtify = true;
            }
            var transform = element.transformable;
            tmpPosition[0] = position[0];
            tmpPosition[1] = position[1];
            tmpPosition[2] = position[2] || 0;
            if (vec3_exports.equals(_this.getPosition(element), tmpPosition)) {
              return;
            }
            vec3_exports.copy(transform.position, tmpPosition);
            if (element.parentNode === null || !element.parentNode.transformable) {
              vec3_exports.copy(transform.localPosition, tmpPosition);
            } else {
              var parentTransform = element.parentNode.transformable;
              mat4_exports.copy(parentInvertMatrix, parentTransform.worldTransform);
              mat4_exports.invert(parentInvertMatrix, parentInvertMatrix);
              vec3_exports.transformMat4(transform.localPosition, tmpPosition, parentInvertMatrix);
            }
            if (dirtify) {
              _this.dirtifyLocal(element, transform);
            }
          };
        }();
        this.setLocalPosition = function() {
          var tmpPosition = vec3_exports.create();
          return function(element, position, dirtify) {
            if (dirtify === void 0) {
              dirtify = true;
            }
            var transform = element.transformable;
            tmpPosition[0] = position[0];
            tmpPosition[1] = position[1];
            tmpPosition[2] = position[2] || 0;
            if (vec3_exports.equals(transform.localPosition, tmpPosition)) {
              return;
            }
            vec3_exports.copy(transform.localPosition, tmpPosition);
            if (dirtify) {
              _this.dirtifyLocal(element, transform);
            }
          };
        }();
        this.translate = function() {
          var zeroVec3 = vec3_exports.create();
          var tmpVec3 = vec3_exports.create();
          var tr = vec3_exports.create();
          return function(element, translation, y3, z, dirtify) {
            if (y3 === void 0) {
              y3 = 0;
            }
            if (z === void 0) {
              z = 0;
            }
            if (dirtify === void 0) {
              dirtify = true;
            }
            if (typeof translation === "number") {
              translation = vec3_exports.set(tmpVec3, translation, y3, z);
            }
            if (vec3_exports.equals(translation, zeroVec3)) {
              return;
            }
            vec3_exports.add(tr, _this.getPosition(element), translation);
            _this.setPosition(element, tr, dirtify);
          };
        }();
        this.setRotation = function() {
          var parentInvertRotation = quat_exports.create();
          return function(element, rotation, y3, z, w, dirtify) {
            if (dirtify === void 0) {
              dirtify = true;
            }
            var transform = element.transformable;
            if (typeof rotation === "number") {
              rotation = quat_exports.fromValues(rotation, y3, z, w);
            }
            if (element.parentNode === null || !element.parentNode.transformable) {
              _this.setLocalRotation(element, rotation);
            } else {
              var parentRot = _this.getRotation(element.parentNode);
              quat_exports.copy(parentInvertRotation, parentRot);
              quat_exports.invert(parentInvertRotation, parentInvertRotation);
              quat_exports.multiply(transform.localRotation, parentInvertRotation, rotation);
              quat_exports.normalize(transform.localRotation, transform.localRotation);
              if (dirtify) {
                _this.dirtifyLocal(element, transform);
              }
            }
          };
        };
        this.displayObjectDependencyMap = /* @__PURE__ */ new WeakMap();
        this.calcLocalTransform = function() {
          var tmpMat = mat4_exports.create();
          var tmpPosition = vec3_exports.create();
          var tmpQuat = quat_exports.fromValues(0, 0, 0, 1);
          return function(transform) {
            var hasSkew = transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0;
            if (hasSkew) {
              mat4_exports.fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, vec3_exports.fromValues(1, 1, 1), transform.origin);
              if (transform.localSkew[0] !== 0 || transform.localSkew[1] !== 0) {
                var tmpMat42 = mat4_exports.identity(tmpMat);
                tmpMat42[4] = Math.tan(transform.localSkew[0]);
                tmpMat42[1] = Math.tan(transform.localSkew[1]);
                mat4_exports.multiply(transform.localTransform, transform.localTransform, tmpMat42);
              }
              var scaling = mat4_exports.fromRotationTranslationScaleOrigin(tmpMat, tmpQuat, tmpPosition, transform.localScale, transform.origin);
              mat4_exports.multiply(transform.localTransform, transform.localTransform, scaling);
            } else {
              mat4_exports.fromRotationTranslationScaleOrigin(transform.localTransform, transform.localRotation, transform.localPosition, transform.localScale, transform.origin);
            }
          };
        }();
      }
      DefaultSceneGraphService2.prototype.matches = function(query, root2) {
        return this.runtime.sceneGraphSelector.is(query, root2);
      };
      DefaultSceneGraphService2.prototype.querySelector = function(query, root2) {
        return this.runtime.sceneGraphSelector.selectOne(query, root2);
      };
      DefaultSceneGraphService2.prototype.querySelectorAll = function(query, root2) {
        return this.runtime.sceneGraphSelector.selectAll(query, root2);
      };
      DefaultSceneGraphService2.prototype.attach = function(child, parent, index4) {
        var _a;
        var detached = false;
        if (child.parentNode) {
          detached = child.parentNode !== parent;
          this.detach(child);
        }
        child.parentNode = parent;
        if (!is_nil_default2(index4)) {
          child.parentNode.childNodes.splice(index4, 0, child);
        } else {
          child.parentNode.childNodes.push(child);
        }
        var sortable = parent.sortable;
        if (((_a = sortable === null || sortable === void 0 ? void 0 : sortable.sorted) === null || _a === void 0 ? void 0 : _a.length) || child.parsedStyle.zIndex) {
          if (sortable.dirtyChildren.indexOf(child) === -1) {
            sortable.dirtyChildren.push(child);
          }
          sortable.dirty = true;
          sortable.dirtyReason = SortReason.ADDED;
        }
        var transform = child.transformable;
        if (transform) {
          this.dirtifyWorld(child, transform);
        }
        if (transform.frozen) {
          this.unfreezeParentToRoot(child);
        }
        if (detached) {
          child.dispatchEvent(reparentEvent);
        }
      };
      DefaultSceneGraphService2.prototype.detach = function(child) {
        var _a, _b;
        if (child.parentNode) {
          var transform = child.transformable;
          var sortable = child.parentNode.sortable;
          if (((_a = sortable === null || sortable === void 0 ? void 0 : sortable.sorted) === null || _a === void 0 ? void 0 : _a.length) || ((_b = child.style) === null || _b === void 0 ? void 0 : _b.zIndex)) {
            if (sortable.dirtyChildren.indexOf(child) === -1) {
              sortable.dirtyChildren.push(child);
            }
            sortable.dirty = true;
            sortable.dirtyReason = SortReason.REMOVED;
          }
          var index4 = child.parentNode.childNodes.indexOf(child);
          if (index4 > -1) {
            child.parentNode.childNodes.splice(index4, 1);
          }
          if (transform) {
            this.dirtifyWorld(child, transform);
          }
          child.parentNode = null;
        }
      };
      DefaultSceneGraphService2.prototype.getOrigin = function(element) {
        element.getGeometryBounds();
        return element.transformable.origin;
      };
      DefaultSceneGraphService2.prototype.setOrigin = function(element, origin, y3, z) {
        if (y3 === void 0) {
          y3 = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (typeof origin === "number") {
          origin = [origin, y3, z];
        }
        var transform = element.transformable;
        if (origin[0] === transform.origin[0] && origin[1] === transform.origin[1] && origin[2] === transform.origin[2]) {
          return;
        }
        var originVec = transform.origin;
        originVec[0] = origin[0];
        originVec[1] = origin[1];
        originVec[2] = origin[2] || 0;
        this.dirtifyLocal(element, transform);
      };
      DefaultSceneGraphService2.prototype.setLocalEulerAngles = function(element, degrees3, y3, z, dirtify) {
        if (y3 === void 0) {
          y3 = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        if (dirtify === void 0) {
          dirtify = true;
        }
        if (typeof degrees3 === "number") {
          degrees3 = vec3_exports.fromValues(degrees3, y3, z);
        }
        var transform = element.transformable;
        quat_exports.fromEuler(transform.localRotation, degrees3[0], degrees3[1], degrees3[2]);
        if (dirtify) {
          this.dirtifyLocal(element, transform);
        }
      };
      DefaultSceneGraphService2.prototype.scaleLocal = function(element, scaling, dirtify) {
        if (dirtify === void 0) {
          dirtify = true;
        }
        var transform = element.transformable;
        vec3_exports.multiply(transform.localScale, transform.localScale, vec3_exports.fromValues(scaling[0], scaling[1], scaling[2] || 1));
        if (dirtify) {
          this.dirtifyLocal(element, transform);
        }
      };
      DefaultSceneGraphService2.prototype.setLocalScale = function(element, scaling, dirtify) {
        if (dirtify === void 0) {
          dirtify = true;
        }
        var transform = element.transformable;
        var updatedScaling = vec3_exports.fromValues(scaling[0], scaling[1], scaling[2] || transform.localScale[2]);
        if (vec3_exports.equals(updatedScaling, transform.localScale)) {
          return;
        }
        vec3_exports.copy(transform.localScale, updatedScaling);
        if (dirtify) {
          this.dirtifyLocal(element, transform);
        }
      };
      DefaultSceneGraphService2.prototype.setLocalRotation = function(element, rotation, y3, z, w, dirtify) {
        if (dirtify === void 0) {
          dirtify = true;
        }
        if (typeof rotation === "number") {
          rotation = quat_exports.fromValues(rotation, y3, z, w);
        }
        var transform = element.transformable;
        quat_exports.copy(transform.localRotation, rotation);
        if (dirtify) {
          this.dirtifyLocal(element, transform);
        }
      };
      DefaultSceneGraphService2.prototype.setLocalSkew = function(element, skew, y3) {
        if (typeof skew === "number") {
          skew = vec2_exports.fromValues(skew, y3);
        }
        var transform = element.transformable;
        vec2_exports.copy(transform.localSkew, skew);
        this.dirtifyLocal(element, transform);
      };
      DefaultSceneGraphService2.prototype.dirtifyLocal = function(element, transform) {
        if (!transform.localDirtyFlag) {
          transform.localDirtyFlag = true;
          if (!transform.dirtyFlag) {
            this.dirtifyWorld(element, transform);
          }
        }
      };
      DefaultSceneGraphService2.prototype.dirtifyWorld = function(element, transform) {
        if (!transform.dirtyFlag) {
          this.unfreezeParentToRoot(element);
        }
        this.dirtifyWorldInternal(element, transform);
        this.dirtifyToRoot(element, true);
      };
      DefaultSceneGraphService2.prototype.triggerPendingEvents = function() {
        var _this = this;
        var set8 = /* @__PURE__ */ new Set();
        var trigger = function(element, detail) {
          if (element.isConnected && !set8.has(element.entity)) {
            _this.boundsChangedEvent.detail = detail;
            _this.boundsChangedEvent.target = element;
            if (element.isMutationObserved) {
              element.dispatchEvent(_this.boundsChangedEvent);
            } else {
              element.ownerDocument.defaultView.dispatchEvent(_this.boundsChangedEvent, true);
            }
            set8.add(element.entity);
          }
        };
        this.pendingEvents.forEach(function(_a) {
          var _b = __read(_a, 2), element = _b[0], detail = _b[1];
          if (detail.affectChildren) {
            element.forEach(function(e3) {
              trigger(e3, detail);
            });
          } else {
            trigger(element, detail);
          }
        });
        this.clearPendingEvents();
        set8.clear();
      };
      DefaultSceneGraphService2.prototype.clearPendingEvents = function() {
        this.pendingEvents = [];
      };
      DefaultSceneGraphService2.prototype.dirtifyToRoot = function(element, affectChildren) {
        if (affectChildren === void 0) {
          affectChildren = false;
        }
        var p2 = element;
        if (p2.renderable) {
          p2.renderable.dirty = true;
        }
        while (p2) {
          markRenderableDirty(p2);
          p2 = p2.parentNode;
        }
        if (affectChildren) {
          element.forEach(function(e3) {
            markRenderableDirty(e3);
          });
        }
        this.informDependentDisplayObjects(element);
        this.pendingEvents.push([element, { affectChildren }]);
      };
      DefaultSceneGraphService2.prototype.updateDisplayObjectDependency = function(name2, oldPath, newPath, object) {
        if (oldPath && oldPath !== newPath) {
          var oldDependencyMap = this.displayObjectDependencyMap.get(oldPath);
          if (oldDependencyMap && oldDependencyMap[name2]) {
            var index4 = oldDependencyMap[name2].indexOf(object);
            oldDependencyMap[name2].splice(index4, 1);
          }
        }
        if (newPath) {
          var newDependencyMap = this.displayObjectDependencyMap.get(newPath);
          if (!newDependencyMap) {
            this.displayObjectDependencyMap.set(newPath, {});
            newDependencyMap = this.displayObjectDependencyMap.get(newPath);
          }
          if (!newDependencyMap[name2]) {
            newDependencyMap[name2] = [];
          }
          newDependencyMap[name2].push(object);
        }
      };
      DefaultSceneGraphService2.prototype.informDependentDisplayObjects = function(object) {
        var _this = this;
        var dependencyMap = this.displayObjectDependencyMap.get(object);
        if (dependencyMap) {
          Object.keys(dependencyMap).forEach(function(name2) {
            dependencyMap[name2].forEach(function(target) {
              _this.dirtifyToRoot(target, true);
              target.dispatchEvent(new MutationEvent(ElementEvent.ATTR_MODIFIED, target, _this, _this, name2, MutationEvent.MODIFICATION, _this, _this));
              if (target.isCustomElement && target.isConnected) {
                if (target.attributeChangedCallback) {
                  target.attributeChangedCallback(name2, _this, _this);
                }
              }
            });
          });
        }
      };
      DefaultSceneGraphService2.prototype.getPosition = function(element) {
        var transform = element.transformable;
        return mat4_exports.getTranslation(transform.position, this.getWorldTransform(element, transform));
      };
      DefaultSceneGraphService2.prototype.getRotation = function(element) {
        var transform = element.transformable;
        return mat4_exports.getRotation(transform.rotation, this.getWorldTransform(element, transform));
      };
      DefaultSceneGraphService2.prototype.getScale = function(element) {
        var transform = element.transformable;
        return mat4_exports.getScaling(transform.scaling, this.getWorldTransform(element, transform));
      };
      DefaultSceneGraphService2.prototype.getWorldTransform = function(element, transform) {
        if (transform === void 0) {
          transform = element.transformable;
        }
        if (!transform.localDirtyFlag && !transform.dirtyFlag) {
          return transform.worldTransform;
        }
        if (element.parentNode && element.parentNode.transformable) {
          this.getWorldTransform(element.parentNode);
        }
        this.sync(element, transform);
        return transform.worldTransform;
      };
      DefaultSceneGraphService2.prototype.getLocalPosition = function(element) {
        return element.transformable.localPosition;
      };
      DefaultSceneGraphService2.prototype.getLocalRotation = function(element) {
        return element.transformable.localRotation;
      };
      DefaultSceneGraphService2.prototype.getLocalScale = function(element) {
        return element.transformable.localScale;
      };
      DefaultSceneGraphService2.prototype.getLocalSkew = function(element) {
        return element.transformable.localSkew;
      };
      DefaultSceneGraphService2.prototype.getLocalTransform = function(element) {
        var transform = element.transformable;
        if (transform.localDirtyFlag) {
          this.calcLocalTransform(transform);
          transform.localDirtyFlag = false;
        }
        return transform.localTransform;
      };
      DefaultSceneGraphService2.prototype.setLocalTransform = function(element, transform) {
        var t = mat4_exports.getTranslation(vec3_exports.create(), transform);
        var r = mat4_exports.getRotation(quat_exports.create(), transform);
        var s2 = mat4_exports.getScaling(vec3_exports.create(), transform);
        this.setLocalScale(element, s2, false);
        this.setLocalPosition(element, t, false);
        this.setLocalRotation(element, r, void 0, void 0, void 0, false);
        this.dirtifyLocal(element, element.transformable);
      };
      DefaultSceneGraphService2.prototype.resetLocalTransform = function(element) {
        this.setLocalScale(element, [1, 1, 1]);
        this.setLocalPosition(element, [0, 0, 0]);
        this.setLocalEulerAngles(element, [0, 0, 0]);
        this.setLocalSkew(element, [0, 0]);
      };
      DefaultSceneGraphService2.prototype.getTransformedGeometryBounds = function(element, render2, existedAABB) {
        if (render2 === void 0) {
          render2 = false;
        }
        var bounds = this.getGeometryBounds(element, render2);
        if (!AABB.isEmpty(bounds)) {
          var aabb = existedAABB || new AABB();
          aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
          return aabb;
        } else {
          return null;
        }
      };
      DefaultSceneGraphService2.prototype.getGeometryBounds = function(element, render2) {
        if (render2 === void 0) {
          render2 = false;
        }
        var geometry = element.geometry;
        if (geometry.dirty) {
          runtime.styleValueRegistry.updateGeometry(element);
        }
        var bounds = render2 ? geometry.renderBounds : geometry.contentBounds || null;
        return bounds || new AABB();
      };
      DefaultSceneGraphService2.prototype.getBounds = function(element, render2) {
        var _this = this;
        if (render2 === void 0) {
          render2 = false;
        }
        var renderable = element.renderable;
        if (!renderable.boundsDirty && !render2 && renderable.bounds) {
          return renderable.bounds;
        }
        if (!renderable.renderBoundsDirty && render2 && renderable.renderBounds) {
          return renderable.renderBounds;
        }
        var existedAABB = render2 ? renderable.renderBounds : renderable.bounds;
        var aabb = this.getTransformedGeometryBounds(element, render2, existedAABB);
        var children = element.childNodes;
        children.forEach(function(child) {
          var childBounds = _this.getBounds(child, render2);
          if (childBounds) {
            if (!aabb) {
              aabb = existedAABB || new AABB();
              aabb.update(childBounds.center, childBounds.halfExtents);
            } else {
              aabb.add(childBounds);
            }
          }
        });
        if (!aabb) {
          aabb = new AABB();
        }
        if (render2) {
          var clipped = findClosestClipPathTarget(element);
          if (clipped) {
            var clipPathBounds = clipped.parsedStyle.clipPath.getBounds(render2);
            if (!aabb) {
              aabb.update(clipPathBounds.center, clipPathBounds.halfExtents);
            } else if (clipPathBounds) {
              aabb = clipPathBounds.intersection(aabb);
            }
          }
        }
        if (render2) {
          renderable.renderBounds = aabb;
          renderable.renderBoundsDirty = false;
        } else {
          renderable.bounds = aabb;
          renderable.boundsDirty = false;
        }
        return aabb;
      };
      DefaultSceneGraphService2.prototype.getLocalBounds = function(element) {
        if (element.parentNode) {
          var parentInvert = mat4_exports.create();
          if (element.parentNode.transformable) {
            parentInvert = mat4_exports.invert(mat4_exports.create(), this.getWorldTransform(element.parentNode));
          }
          var bounds = this.getBounds(element);
          if (!AABB.isEmpty(bounds)) {
            var localBounds = new AABB();
            localBounds.setFromTransformedAABB(bounds, parentInvert);
            return localBounds;
          }
        }
        return this.getBounds(element);
      };
      DefaultSceneGraphService2.prototype.getBoundingClientRect = function(element) {
        var _a, _b;
        var aabb;
        var bounds = this.getGeometryBounds(element);
        if (!AABB.isEmpty(bounds)) {
          aabb = new AABB();
          aabb.setFromTransformedAABB(bounds, this.getWorldTransform(element));
        }
        var bbox = (_b = (_a = element.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.getContextService().getBoundingClientRect();
        if (aabb) {
          var _c = __read(aabb.getMin(), 2), left2 = _c[0], top_1 = _c[1];
          var _d = __read(aabb.getMax(), 2), right2 = _d[0], bottom = _d[1];
          return new Rectangle(left2 + ((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0), top_1 + ((bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0), right2 - left2, bottom - top_1);
        }
        return new Rectangle((bbox === null || bbox === void 0 ? void 0 : bbox.left) || 0, (bbox === null || bbox === void 0 ? void 0 : bbox.top) || 0, 0, 0);
      };
      DefaultSceneGraphService2.prototype.dirtifyWorldInternal = function(element, transform) {
        var _this = this;
        if (!transform.dirtyFlag) {
          transform.dirtyFlag = true;
          transform.frozen = false;
          element.childNodes.forEach(function(child) {
            var childTransform = child.transformable;
            if (!childTransform.dirtyFlag) {
              _this.dirtifyWorldInternal(child, childTransform);
            }
          });
          var renderable = element.renderable;
          if (renderable) {
            renderable.renderBoundsDirty = true;
            renderable.boundsDirty = true;
            renderable.dirty = true;
          }
        }
      };
      DefaultSceneGraphService2.prototype.syncHierarchy = function(element) {
        var transform = element.transformable;
        if (transform.frozen) {
          return;
        }
        transform.frozen = true;
        if (transform.localDirtyFlag || transform.dirtyFlag) {
          this.sync(element, transform);
        }
        var children = element.childNodes;
        for (var i = 0; i < children.length; i++) {
          this.syncHierarchy(children[i]);
        }
      };
      DefaultSceneGraphService2.prototype.sync = function(element, transform) {
        if (transform.localDirtyFlag) {
          this.calcLocalTransform(transform);
          transform.localDirtyFlag = false;
        }
        if (transform.dirtyFlag) {
          var parent_1 = element.parentNode;
          var parentTransform = parent_1 && parent_1.transformable;
          if (parent_1 === null || !parentTransform) {
            mat4_exports.copy(transform.worldTransform, transform.localTransform);
          } else {
            mat4_exports.multiply(transform.worldTransform, parentTransform.worldTransform, transform.localTransform);
          }
          transform.dirtyFlag = false;
        }
      };
      DefaultSceneGraphService2.prototype.unfreezeParentToRoot = function(child) {
        var p2 = child.parentNode;
        while (p2) {
          var transform = p2.transformable;
          if (transform) {
            transform.frozen = false;
          }
          p2 = p2.parentNode;
        }
      };
      return DefaultSceneGraphService2;
    }()
  );
  var TEXT_METRICS = {
    MetricsString: "|\xC9q\xC5",
    BaselineSymbol: "M",
    BaselineMultiplier: 1.4,
    HeightMultiplier: 2,
    Newlines: [
      10,
      // line feed
      13
      // carriage return
    ],
    BreakingSpaces: [
      9,
      // character tabulation
      32,
      // space
      8192,
      // en quad
      8193,
      // em quad
      8194,
      // en space
      8195,
      // em space
      8196,
      // three-per-em space
      8197,
      // four-per-em space
      8198,
      // six-per-em space
      8200,
      // punctuation space
      8201,
      // thin space
      8202,
      // hair space
      8287,
      // medium mathematical space
      12288
      // ideographic space
    ]
  };
  var LATIN_REGEX = /[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00f6\u00f8-\u00ff!"#$%&'()*+,-./:;]/;
  var regexCannotStartZhCn = /[!%),.:;?\]}¢°·'""†‡›℃∶、。〃〆〕〗〞﹚﹜！＂％＇），．：；？！］｝～]/;
  var regexCannotEndZhCn = /[$(£¥·'"〈《「『【〔〖〝﹙﹛＄（．［｛￡￥]/;
  var regexCannotStartZhTw = /[!),.:;?\]}¢·–—'"•"、。〆〞〕〉》」︰︱︲︳﹐﹑﹒﹓﹔﹕﹖﹘﹚﹜！），．：；？︶︸︺︼︾﹀﹂﹗］｜｝､]/;
  var regexCannotEndZhTw = /[([{£¥'"‵〈《「『〔〝︴﹙﹛（｛︵︷︹︻︽︿﹁﹃﹏]/;
  var regexCannotStartJaJp = /[)\]｝〕〉》」』】〙〗〟'"｠»ヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻‐゠–〜?!‼⁇⁈⁉・、:;,。.]/;
  var regexCannotEndJaJp = /[([｛〔〈《「『【〘〖〝'"｟«—...‥〳〴〵]/;
  var regexCannotStartKoKr = /[!%),.:;?\]}¢°'"†‡℃〆〈《「『〕！％），．：；？］｝]/;
  var regexCannotEndKoKr = /[$([{£¥'"々〇〉》」〔＄（［｛｠￥￦#]/;
  var regexCannotStart = new RegExp("".concat(regexCannotStartZhCn.source, "|").concat(regexCannotStartZhTw.source, "|").concat(regexCannotStartJaJp.source, "|").concat(regexCannotStartKoKr.source));
  var regexCannotEnd = new RegExp("".concat(regexCannotEndZhCn.source, "|").concat(regexCannotEndZhTw.source, "|").concat(regexCannotEndJaJp.source, "|").concat(regexCannotEndKoKr.source));
  var TextService = (
    /** @class */
    function() {
      function TextService2(runtime2) {
        var _this = this;
        this.runtime = runtime2;
        this.fontMetricsCache = {};
        this.shouldBreakByKinsokuShorui = function(char, nextChar) {
          if (_this.isBreakingSpace(nextChar))
            return false;
          if (char) {
            if (regexCannotEnd.exec(nextChar) || regexCannotStart.exec(char)) {
              return true;
            }
          }
          return false;
        };
        this.trimByKinsokuShorui = function(prev) {
          var next = __spreadArray([], __read(prev), false);
          var prevLine = next[next.length - 2];
          if (!prevLine) {
            return prev;
          }
          var lastChar = prevLine[prevLine.length - 1];
          next[next.length - 2] = prevLine.slice(0, -1);
          next[next.length - 1] = lastChar + next[next.length - 1];
          return next;
        };
      }
      TextService2.prototype.measureFont = function(font, offscreenCanvas) {
        if (this.fontMetricsCache[font]) {
          return this.fontMetricsCache[font];
        }
        var properties = {
          ascent: 0,
          descent: 0,
          fontSize: 0
        };
        var canvas = this.runtime.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
        var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
          willReadFrequently: true
        });
        context.font = font;
        var metricsString = TEXT_METRICS.MetricsString + TEXT_METRICS.BaselineSymbol;
        var width = Math.ceil(context.measureText(metricsString).width);
        var baseline = Math.ceil(context.measureText(TEXT_METRICS.BaselineSymbol).width);
        var height = TEXT_METRICS.HeightMultiplier * baseline;
        baseline = baseline * TEXT_METRICS.BaselineMultiplier | 0;
        canvas.width = width;
        canvas.height = height;
        context.fillStyle = "#f00";
        context.fillRect(0, 0, width, height);
        context.font = font;
        context.textBaseline = "alphabetic";
        context.fillStyle = "#000";
        context.fillText(metricsString, 0, baseline);
        var imagedata = context.getImageData(0, 0, width || 1, height || 1).data;
        var pixels = imagedata.length;
        var line4 = width * 4;
        var i = 0;
        var idx = 0;
        var stop = false;
        for (i = 0; i < baseline; ++i) {
          for (var j = 0; j < line4; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx += line4;
          } else {
            break;
          }
        }
        properties.ascent = baseline - i;
        idx = pixels - line4;
        stop = false;
        for (i = height; i > baseline; --i) {
          for (var j = 0; j < line4; j += 4) {
            if (imagedata[idx + j] !== 255) {
              stop = true;
              break;
            }
          }
          if (!stop) {
            idx -= line4;
          } else {
            break;
          }
        }
        properties.descent = i - baseline;
        properties.fontSize = properties.ascent + properties.descent;
        this.fontMetricsCache[font] = properties;
        return properties;
      };
      TextService2.prototype.measureText = function(text, parsedStyle, offscreenCanvas) {
        var _a = parsedStyle.fontSize, fontSize = _a === void 0 ? 16 : _a, _b = parsedStyle.wordWrap, wordWrap = _b === void 0 ? false : _b, strokeHeight = parsedStyle.lineHeight, _c = parsedStyle.lineWidth, lineWidth = _c === void 0 ? 1 : _c, _d = parsedStyle.textBaseline, textBaseline = _d === void 0 ? "alphabetic" : _d, _e = parsedStyle.textAlign, textAlign = _e === void 0 ? "start" : _e, _f = parsedStyle.letterSpacing, letterSpacing = _f === void 0 ? 0 : _f, textPath = parsedStyle.textPath;
        parsedStyle.textPathSide;
        parsedStyle.textPathStartOffset;
        var _g = parsedStyle.leading, leading = _g === void 0 ? 0 : _g;
        var font = toFontString(parsedStyle);
        var fontProperties = this.measureFont(font, offscreenCanvas);
        if (fontProperties.fontSize === 0) {
          fontProperties.fontSize = fontSize;
          fontProperties.ascent = fontSize;
        }
        var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
        context.font = font;
        parsedStyle.isOverflowing = false;
        var outputText = wordWrap ? this.wordWrap(text, parsedStyle, offscreenCanvas) : text;
        var lines = outputText.split(/(?:\r\n|\r|\n)/);
        var lineWidths = new Array(lines.length);
        var maxLineWidth = 0;
        if (textPath) {
          textPath.getTotalLength();
          for (var i = 0; i < lines.length; i++) {
            var width = context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;
          }
        } else {
          for (var i = 0; i < lines.length; i++) {
            var lineWidth_1 = context.measureText(lines[i]).width + (lines[i].length - 1) * letterSpacing;
            lineWidths[i] = lineWidth_1;
            maxLineWidth = Math.max(maxLineWidth, lineWidth_1);
          }
          var width = maxLineWidth + lineWidth;
          var lineHeight_1 = strokeHeight || fontProperties.fontSize + lineWidth;
          var height = Math.max(lineHeight_1, fontProperties.fontSize + lineWidth) + (lines.length - 1) * (lineHeight_1 + leading);
          lineHeight_1 += leading;
          var offsetY_1 = 0;
          if (textBaseline === "middle") {
            offsetY_1 = -height / 2;
          } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
            offsetY_1 = -height;
          } else if (textBaseline === "top" || textBaseline === "hanging") {
            offsetY_1 = 0;
          }
          return {
            font,
            width,
            height,
            lines,
            lineWidths,
            lineHeight: lineHeight_1,
            maxLineWidth,
            fontProperties,
            lineMetrics: lineWidths.map(function(width2, i2) {
              var offsetX = 0;
              if (textAlign === "center" || textAlign === "middle") {
                offsetX -= width2 / 2;
              } else if (textAlign === "right" || textAlign === "end") {
                offsetX -= width2;
              }
              return new Rectangle(offsetX - lineWidth / 2, offsetY_1 + i2 * lineHeight_1, width2 + lineWidth, lineHeight_1);
            })
          };
        }
      };
      TextService2.prototype.setGraphemeOnPath = function() {
      };
      TextService2.prototype.wordWrap = function(text, parsedStyle, offscreenCanvas) {
        var _this = this;
        var _a = parsedStyle.wordWrapWidth, wordWrapWidth = _a === void 0 ? 0 : _a, _b = parsedStyle.letterSpacing, letterSpacing = _b === void 0 ? 0 : _b, _c = parsedStyle.maxLines, maxLines = _c === void 0 ? Infinity : _c, textOverflow = parsedStyle.textOverflow;
        var context = this.runtime.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
        var maxWidth = wordWrapWidth + letterSpacing;
        var ellipsis = "";
        if (textOverflow === "ellipsis") {
          ellipsis = "...";
        } else if (textOverflow && textOverflow !== "clip") {
          ellipsis = textOverflow;
        }
        var lines = [];
        var currentIndex = 0;
        var currentWidth = 0;
        var cache3 = {};
        var calcWidth = function(char2) {
          return _this.getFromCache(char2, letterSpacing, cache3, context);
        };
        var ellipsisWidth = Array.from(ellipsis).reduce(function(prev, cur) {
          return prev + calcWidth(cur);
        }, 0);
        var chars = Array.from(text);
        for (var i = 0; i < chars.length; i++) {
          var char = chars[i];
          var prevChar = text[i - 1];
          var nextChar = text[i + 1];
          var charWidth = calcWidth(char);
          if (this.isNewline(char)) {
            currentIndex++;
            if (currentIndex >= maxLines) {
              parsedStyle.isOverflowing = true;
              break;
            }
            currentWidth = 0;
            lines[currentIndex] = "";
            continue;
          }
          if (currentWidth > 0 && currentWidth + charWidth > maxWidth) {
            if (currentIndex + 1 >= maxLines) {
              parsedStyle.isOverflowing = true;
              if (ellipsisWidth > 0 && ellipsisWidth <= maxWidth) {
                var currentLineLength = lines[currentIndex].length;
                var lastLineWidth = 0;
                var lastLineIndex = currentLineLength;
                for (var i_1 = 0; i_1 < currentLineLength; i_1++) {
                  var width = calcWidth(lines[currentIndex][i_1]);
                  if (lastLineWidth + width + ellipsisWidth > maxWidth) {
                    lastLineIndex = i_1;
                    break;
                  }
                  lastLineWidth += width;
                }
                lines[currentIndex] = (lines[currentIndex] || "").slice(0, lastLineIndex) + ellipsis;
              }
              break;
            }
            currentIndex++;
            currentWidth = 0;
            lines[currentIndex] = "";
            if (this.isBreakingSpace(char)) {
              continue;
            }
            if (!this.canBreakInLastChar(char)) {
              lines = this.trimToBreakable(lines);
              currentWidth = this.sumTextWidthByCache(lines[currentIndex] || "", cache3);
            }
            if (this.shouldBreakByKinsokuShorui(char, nextChar)) {
              lines = this.trimByKinsokuShorui(lines);
              currentWidth += calcWidth(prevChar || "");
            }
          }
          currentWidth += charWidth;
          lines[currentIndex] = (lines[currentIndex] || "") + char;
        }
        return lines.join("\n");
      };
      TextService2.prototype.isBreakingSpace = function(char) {
        if (typeof char !== "string") {
          return false;
        }
        return TEXT_METRICS.BreakingSpaces.indexOf(char.charCodeAt(0)) >= 0;
      };
      TextService2.prototype.isNewline = function(char) {
        if (typeof char !== "string") {
          return false;
        }
        return TEXT_METRICS.Newlines.indexOf(char.charCodeAt(0)) >= 0;
      };
      TextService2.prototype.trimToBreakable = function(prev) {
        var next = __spreadArray([], __read(prev), false);
        var prevLine = next[next.length - 2];
        var index4 = this.findBreakableIndex(prevLine);
        if (index4 === -1 || !prevLine)
          return next;
        var trimmedChar = prevLine.slice(index4, index4 + 1);
        var isTrimmedWithSpace = this.isBreakingSpace(trimmedChar);
        var trimFrom = index4 + 1;
        var trimTo = index4 + (isTrimmedWithSpace ? 0 : 1);
        next[next.length - 1] += prevLine.slice(trimFrom, prevLine.length);
        next[next.length - 2] = prevLine.slice(0, trimTo);
        return next;
      };
      TextService2.prototype.canBreakInLastChar = function(char) {
        if (char && LATIN_REGEX.test(char))
          return false;
        return true;
      };
      TextService2.prototype.sumTextWidthByCache = function(text, cache3) {
        return text.split("").reduce(function(sum3, c5) {
          if (!cache3[c5])
            throw Error("cannot count the word without cache");
          return sum3 + cache3[c5];
        }, 0);
      };
      TextService2.prototype.findBreakableIndex = function(line4) {
        for (var i = line4.length - 1; i >= 0; i--) {
          if (!LATIN_REGEX.test(line4[i]))
            return i;
        }
        return -1;
      };
      TextService2.prototype.getFromCache = function(key, letterSpacing, cache3, context) {
        var width = cache3[key];
        if (typeof width !== "number") {
          var spacing = key.length * letterSpacing;
          width = context.measureText(key).width + spacing;
          cache3[key] = width;
        }
        return width;
      };
      return TextService2;
    }()
  );
  var runtime = {};
  var geometryUpdaterFactory = function() {
    var _a;
    var rectUpdater = new RectUpdater();
    var polylineUpdater = new PolylineUpdater();
    return _a = {}, _a[Shape.CIRCLE] = new CircleUpdater(), _a[Shape.ELLIPSE] = new EllipseUpdater(), _a[Shape.RECT] = rectUpdater, _a[Shape.IMAGE] = rectUpdater, _a[Shape.GROUP] = new GroupUpdater(), _a[Shape.LINE] = new LineUpdater(), _a[Shape.TEXT] = new TextUpdater(runtime), _a[Shape.POLYLINE] = polylineUpdater, _a[Shape.POLYGON] = polylineUpdater, _a[Shape.PATH] = new PathUpdater(), _a[Shape.HTML] = null, _a[Shape.MESH] = null, _a;
  }();
  var CSSPropertySyntaxFactory = function() {
    var _a;
    var color2 = new CSSPropertyColor();
    var length5 = new CSSPropertyLengthOrPercentage();
    return _a = {}, _a[PropertySyntax.PERCENTAGE] = null, _a[PropertySyntax.NUMBER] = new CSSPropertyNumber(), _a[PropertySyntax.ANGLE] = new CSSPropertyAngle(), _a[PropertySyntax.DEFINED_PATH] = new CSSPropertyClipPath(), _a[PropertySyntax.PAINT] = color2, _a[PropertySyntax.COLOR] = color2, _a[PropertySyntax.FILTER] = new CSSPropertyFilter(), _a[PropertySyntax.LENGTH] = length5, _a[PropertySyntax.LENGTH_PERCENTAGE] = length5, _a[PropertySyntax.LENGTH_PERCENTAGE_12] = new CSSPropertyLengthOrPercentage12(), _a[PropertySyntax.LENGTH_PERCENTAGE_14] = new CSSPropertyLengthOrPercentage14(), _a[PropertySyntax.COORDINATE] = new CSSPropertyLengthOrPercentage(), _a[PropertySyntax.OFFSET_DISTANCE] = new CSSPropertyOffsetDistance(), _a[PropertySyntax.OPACITY_VALUE] = new CSSPropertyOpacity(), _a[PropertySyntax.PATH] = new CSSPropertyPath(), _a[PropertySyntax.LIST_OF_POINTS] = new CSSPropertyPoints(), _a[PropertySyntax.SHADOW_BLUR] = new CSSPropertyShadowBlur(), _a[PropertySyntax.TEXT] = new CSSPropertyText(), _a[PropertySyntax.TEXT_TRANSFORM] = new CSSPropertyTextTransform(), _a[PropertySyntax.TRANSFORM] = new CSSPropertyTransform(), _a[PropertySyntax.TRANSFORM_ORIGIN] = new CSSPropertyTransformOrigin(), _a[PropertySyntax.Z_INDEX] = new CSSPropertyZIndex(), _a[PropertySyntax.MARKER] = new CSSPropertyMarker(), _a;
  }();
  var getGlobalThis = function() {
    if (typeof globalThis !== "undefined")
      return globalThis;
    if (typeof self !== "undefined")
      return self;
    if (typeof window !== "undefined")
      return window;
    if (typeof global !== "undefined")
      return global;
    return {};
  };
  runtime.CameraContribution = Camera;
  runtime.AnimationTimeline = null;
  runtime.EasingFunction = null;
  runtime.offscreenCanvasCreator = new OffscreenCanvasCreator();
  runtime.sceneGraphSelector = new DefaultSceneGraphSelector();
  runtime.sceneGraphService = new DefaultSceneGraphService(runtime);
  runtime.textService = new TextService(runtime);
  runtime.geometryUpdaterFactory = geometryUpdaterFactory;
  runtime.CSSPropertySyntaxFactory = CSSPropertySyntaxFactory;
  runtime.styleValueRegistry = new DefaultStyleValueRegistry(runtime);
  runtime.layoutRegistry = null;
  runtime.globalThis = getGlobalThis();
  runtime.enableCSSParsing = false;
  runtime.enableDataset = false;
  runtime.enableStyleSyntax = true;
  runtime.enableAttributeDashCased = false;
  runtime.enableSizeAttenuation = false;
  var entityCounter = 0;
  var insertedEvent = new MutationEvent(ElementEvent.INSERTED, null, "", "", "", 0, "", "");
  var removedEvent = new MutationEvent(ElementEvent.REMOVED, null, "", "", "", 0, "", "");
  var destroyEvent = new CustomEvent2(ElementEvent.DESTROY);
  var Element2 = (
    /** @class */
    function(_super) {
      __extends(Element3, _super);
      function Element3() {
        var _this = _super.call(this) || this;
        _this.entity = entityCounter++;
        _this.renderable = {
          bounds: void 0,
          boundsDirty: true,
          renderBounds: void 0,
          renderBoundsDirty: true,
          dirtyRenderBounds: void 0,
          dirty: false
        };
        _this.cullable = {
          strategy: Strategy.Standard,
          visibilityPlaneMask: -1,
          visible: true,
          enable: true
        };
        _this.transformable = {
          dirtyFlag: false,
          localDirtyFlag: false,
          frozen: false,
          localPosition: [0, 0, 0],
          localRotation: [0, 0, 0, 1],
          localScale: [1, 1, 1],
          localTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
          localSkew: [0, 0],
          position: [0, 0, 0],
          rotation: [0, 0, 0, 1],
          scaling: [1, 1, 1],
          worldTransform: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
          origin: [0, 0, 0]
        };
        _this.sortable = {
          dirty: false,
          sorted: void 0,
          renderOrder: 0,
          dirtyChildren: [],
          dirtyReason: void 0
        };
        _this.geometry = {
          contentBounds: void 0,
          renderBounds: void 0,
          dirty: true
        };
        _this.rBushNode = {
          aabb: void 0
        };
        _this.namespaceURI = "g";
        _this.scrollLeft = 0;
        _this.scrollTop = 0;
        _this.clientTop = 0;
        _this.clientLeft = 0;
        _this.destroyed = false;
        _this.style = {};
        _this.computedStyle = runtime.enableCSSParsing ? {
          opacity: unsetKeywordValue,
          fillOpacity: unsetKeywordValue,
          strokeOpacity: unsetKeywordValue,
          fill: unsetKeywordValue,
          stroke: unsetKeywordValue,
          transform: unsetKeywordValue,
          transformOrigin: unsetKeywordValue,
          visibility: unsetKeywordValue,
          pointerEvents: unsetKeywordValue,
          lineWidth: unsetKeywordValue,
          lineCap: unsetKeywordValue,
          lineJoin: unsetKeywordValue,
          increasedLineWidthForHitTesting: unsetKeywordValue,
          fontSize: unsetKeywordValue,
          fontFamily: unsetKeywordValue,
          fontStyle: unsetKeywordValue,
          fontWeight: unsetKeywordValue,
          fontVariant: unsetKeywordValue,
          textAlign: unsetKeywordValue,
          textBaseline: unsetKeywordValue,
          textTransform: unsetKeywordValue,
          zIndex: unsetKeywordValue,
          filter: unsetKeywordValue,
          shadowType: unsetKeywordValue
        } : null;
        _this.parsedStyle = {
          // opacity: '',
          // fillOpacity: '',
          // strokeOpacity: '',
          // transformOrigin: '',
          // visibility: '',
          // pointerEvents: '',
          // lineWidth: '',
          // lineCap: '',
          // lineJoin: '',
          // increasedLineWidthForHitTesting: '',
          // fontSize: '',
          // fontFamily: '',
          // fontStyle: '',
          // fontWeight: '',
          // fontVariant: '',
          // textAlign: '',
          // textBaseline: '',
          // textTransform: '',
        };
        _this.attributes = {};
        return _this;
      }
      Object.defineProperty(Element3.prototype, "className", {
        /**
         * used in `getElementsByClassName`
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
         */
        get: function() {
          return this.getAttribute("class") || "";
        },
        set: function(className2) {
          this.setAttribute("class", className2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element3.prototype, "classList", {
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Element/classList
         */
        get: function() {
          return this.className.split(" ").filter(function(c5) {
            return c5 !== "";
          });
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element3.prototype, "tagName", {
        get: function() {
          return this.nodeName;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element3.prototype, "children", {
        get: function() {
          return this.childNodes;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element3.prototype, "childElementCount", {
        get: function() {
          return this.childNodes.length;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element3.prototype, "firstElementChild", {
        get: function() {
          return this.firstChild;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element3.prototype, "lastElementChild", {
        get: function() {
          return this.lastChild;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element3.prototype, "parentElement", {
        get: function() {
          return this.parentNode;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element3.prototype, "nextSibling", {
        get: function() {
          if (this.parentNode) {
            var index4 = this.parentNode.childNodes.indexOf(this);
            return this.parentNode.childNodes[index4 + 1] || null;
          }
          return null;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Element3.prototype, "previousSibling", {
        get: function() {
          if (this.parentNode) {
            var index4 = this.parentNode.childNodes.indexOf(this);
            return this.parentNode.childNodes[index4 - 1] || null;
          }
          return null;
        },
        enumerable: false,
        configurable: true
      });
      Element3.prototype.cloneNode = function(deep2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Element3.prototype.appendChild = function(child, index4) {
        var _a;
        if (child.destroyed) {
          throw new Error(ERROR_MSG_APPEND_DESTROYED_ELEMENT);
        }
        runtime.sceneGraphService.attach(child, this, index4);
        if ((_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) {
          this.ownerDocument.defaultView.mountChildren(child);
        }
        if (this.isMutationObserved) {
          insertedEvent.relatedNode = this;
          child.dispatchEvent(insertedEvent);
        }
        return child;
      };
      Element3.prototype.insertBefore = function(newChild, refChild) {
        if (!refChild) {
          this.appendChild(newChild);
        } else {
          if (newChild.parentElement) {
            newChild.parentElement.removeChild(newChild);
          }
          var index4 = this.childNodes.indexOf(refChild);
          if (index4 === -1) {
            this.appendChild(newChild);
          } else {
            this.appendChild(newChild, index4);
          }
        }
        return newChild;
      };
      Element3.prototype.replaceChild = function(newChild, oldChild) {
        var index4 = this.childNodes.indexOf(oldChild);
        this.removeChild(oldChild);
        this.appendChild(newChild, index4);
        return oldChild;
      };
      Element3.prototype.removeChild = function(child) {
        var _a;
        removedEvent.relatedNode = this;
        child.dispatchEvent(removedEvent);
        if ((_a = child.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) {
          child.ownerDocument.defaultView.unmountChildren(child);
        }
        runtime.sceneGraphService.detach(child);
        return child;
      };
      Element3.prototype.removeChildren = function() {
        for (var i = this.childNodes.length - 1; i >= 0; i--) {
          var child = this.childNodes[i];
          this.removeChild(child);
        }
      };
      Element3.prototype.destroyChildren = function() {
        for (var i = this.childNodes.length - 1; i >= 0; i--) {
          var child = this.childNodes[i];
          if (child.childNodes.length) {
            child.destroyChildren();
          }
          child.destroy();
        }
      };
      Element3.prototype.matches = function(selector) {
        return runtime.sceneGraphService.matches(selector, this);
      };
      Element3.prototype.getElementById = function(id4) {
        return runtime.sceneGraphService.querySelector("#".concat(id4), this);
      };
      Element3.prototype.getElementsByName = function(name2) {
        return runtime.sceneGraphService.querySelectorAll('[name="'.concat(name2, '"]'), this);
      };
      Element3.prototype.getElementsByClassName = function(className2) {
        return runtime.sceneGraphService.querySelectorAll(".".concat(className2), this);
      };
      Element3.prototype.getElementsByTagName = function(tagName) {
        return runtime.sceneGraphService.querySelectorAll(tagName, this);
      };
      Element3.prototype.querySelector = function(selectors) {
        return runtime.sceneGraphService.querySelector(selectors, this);
      };
      Element3.prototype.querySelectorAll = function(selectors) {
        return runtime.sceneGraphService.querySelectorAll(selectors, this);
      };
      Element3.prototype.closest = function(selectors) {
        var el = this;
        do {
          if (runtime.sceneGraphService.matches(selectors, el))
            return el;
          el = el.parentElement;
        } while (el !== null);
        return null;
      };
      Element3.prototype.find = function(filter2) {
        var _this = this;
        var target = null;
        this.forEach(function(object) {
          if (object !== _this && filter2(object)) {
            target = object;
            return true;
          }
          return false;
        });
        return target;
      };
      Element3.prototype.findAll = function(filter2) {
        var _this = this;
        var objects = [];
        this.forEach(function(object) {
          if (object !== _this && filter2(object)) {
            objects.push(object);
          }
        });
        return objects;
      };
      Element3.prototype.after = function() {
        var _this = this;
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          nodes[_i] = arguments[_i];
        }
        if (this.parentNode) {
          var index_1 = this.parentNode.childNodes.indexOf(this);
          nodes.forEach(function(node, i) {
            var _a;
            return (_a = _this.parentNode) === null || _a === void 0 ? void 0 : _a.appendChild(node, index_1 + i + 1);
          });
        }
      };
      Element3.prototype.before = function() {
        var _a;
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          nodes[_i] = arguments[_i];
        }
        if (this.parentNode) {
          var index4 = this.parentNode.childNodes.indexOf(this);
          var _b = __read(nodes), first3 = _b[0], rest = _b.slice(1);
          this.parentNode.appendChild(first3, index4);
          (_a = first3).after.apply(_a, __spreadArray([], __read(rest), false));
        }
      };
      Element3.prototype.replaceWith = function() {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          nodes[_i] = arguments[_i];
        }
        this.after.apply(this, __spreadArray([], __read(nodes), false));
        this.remove();
      };
      Element3.prototype.append = function() {
        var _this = this;
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          nodes[_i] = arguments[_i];
        }
        nodes.forEach(function(node) {
          return _this.appendChild(node);
        });
      };
      Element3.prototype.prepend = function() {
        var _this = this;
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          nodes[_i] = arguments[_i];
        }
        nodes.forEach(function(node, i) {
          return _this.appendChild(node, i);
        });
      };
      Element3.prototype.replaceChildren = function() {
        var nodes = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          nodes[_i] = arguments[_i];
        }
        while (this.childNodes.length && this.firstChild) {
          this.removeChild(this.firstChild);
        }
        this.append.apply(this, __spreadArray([], __read(nodes), false));
      };
      Element3.prototype.remove = function() {
        if (this.parentNode) {
          return this.parentNode.removeChild(this);
        }
        return this;
      };
      Element3.prototype.destroy = function() {
        this.dispatchEvent(destroyEvent);
        this.remove();
        this.emitter.removeAllListeners();
        this.destroyed = true;
      };
      Element3.prototype.getGeometryBounds = function() {
        return runtime.sceneGraphService.getGeometryBounds(this);
      };
      Element3.prototype.getRenderBounds = function() {
        return runtime.sceneGraphService.getBounds(this, true);
      };
      Element3.prototype.getBounds = function() {
        return runtime.sceneGraphService.getBounds(this);
      };
      Element3.prototype.getLocalBounds = function() {
        return runtime.sceneGraphService.getLocalBounds(this);
      };
      Element3.prototype.getBoundingClientRect = function() {
        return runtime.sceneGraphService.getBoundingClientRect(this);
      };
      Element3.prototype.getClientRects = function() {
        return [this.getBoundingClientRect()];
      };
      Element3.prototype.computedStyleMap = function() {
        return new Map(Object.entries(this.computedStyle));
      };
      Element3.prototype.getAttributeNames = function() {
        return Object.keys(this.attributes);
      };
      Element3.prototype.getAttribute = function(name2) {
        if (isSymbol(name2)) {
          return runtime.enableCSSParsing ? null : void 0;
        }
        var value2 = this.attributes[name2];
        if (value2 === void 0) {
          if (runtime.enableAttributeDashCased) {
            var attributeName = formatAttributeName(name2);
            value2 = this.attributes[attributeName];
          }
          return runtime.enableCSSParsing ? is_nil_default2(value2) ? null : value2 : value2;
        } else {
          return value2;
        }
      };
      Element3.prototype.hasAttribute = function(qualifiedName) {
        return this.getAttributeNames().includes(qualifiedName);
      };
      Element3.prototype.hasAttributes = function() {
        return !!this.getAttributeNames().length;
      };
      Element3.prototype.removeAttribute = function(attributeName) {
        this.setAttribute(attributeName, null);
        delete this.attributes[attributeName];
      };
      Element3.prototype.setAttribute = function(attributeName, value2, force, memoize2) {
        this.attributes[attributeName] = value2;
      };
      Element3.prototype.getAttributeNS = function(namespace, localName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Element3.prototype.getAttributeNode = function(qualifiedName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Element3.prototype.getAttributeNodeNS = function(namespace, localName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Element3.prototype.hasAttributeNS = function(namespace, localName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Element3.prototype.removeAttributeNS = function(namespace, localName) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Element3.prototype.removeAttributeNode = function(attr2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Element3.prototype.setAttributeNS = function(namespace, qualifiedName, value2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Element3.prototype.setAttributeNode = function(attr2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Element3.prototype.setAttributeNodeNS = function(attr2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Element3.prototype.toggleAttribute = function(qualifiedName, force) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      return Element3;
    }(Node2)
  );
  function isDisplayObject(value2) {
    return !!(value2 === null || value2 === void 0 ? void 0 : value2.nodeName);
  }
  var Proxy2 = runtime.globalThis.Proxy ? runtime.globalThis.Proxy : function() {
  };
  var mutationEvent = new MutationEvent(ElementEvent.ATTR_MODIFIED, null, null, null, null, MutationEvent.MODIFICATION, null, null);
  var DEFAULT_STYLE_PROPS = {
    opacity: "",
    fillOpacity: "",
    strokeOpacity: "",
    fill: "",
    stroke: "",
    transform: "",
    transformOrigin: "",
    visibility: "",
    pointerEvents: "",
    lineWidth: "",
    lineCap: "",
    lineJoin: "",
    increasedLineWidthForHitTesting: "",
    fontSize: "",
    fontFamily: "",
    fontStyle: "",
    fontWeight: "",
    fontVariant: "",
    textAlign: "",
    textBaseline: "",
    textTransform: "",
    zIndex: "",
    filter: "",
    shadowType: ""
  };
  var DEFAULT_PARSED_STYLE_PROPS = {
    fill: noneColor,
    stroke: noneColor,
    transform: [],
    zIndex: 0,
    filter: [],
    shadowType: "outer",
    miterLimit: 10
  };
  var INHERITABLE_BASE_STYLE_PROPS = [
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "transformOrigin",
    "visibility",
    "pointerEvents",
    "lineWidth",
    "lineCap",
    "lineJoin",
    "increasedLineWidthForHitTesting"
  ];
  var INHERITABLE_STYLE_PROPS = __spreadArray(__spreadArray([], __read(INHERITABLE_BASE_STYLE_PROPS), false), [
    "fontSize",
    "fontFamily",
    "fontStyle",
    "fontWeight",
    "fontVariant",
    "textAlign",
    "textBaseline",
    "textTransform"
  ], false);
  var DATASET_PREFIX = "data-";
  var DisplayObject = (
    /** @class */
    function(_super) {
      __extends(DisplayObject2, _super);
      function DisplayObject2(config2) {
        var _this = _super.call(this) || this;
        _this.isCustomElement = false;
        _this.isMutationObserved = false;
        _this.activeAnimations = [];
        _this.config = config2;
        _this.id = _this.config.id || "";
        _this.name = _this.config.name || "";
        if (_this.config.className || _this.config.class) {
          _this.className = _this.config.className || _this.config.class;
        }
        _this.nodeName = _this.config.type || Shape.GROUP;
        if (runtime.enableCSSParsing) {
          Object.assign(_this.attributes, DEFAULT_STYLE_PROPS);
          Object.assign(_this.parsedStyle, DEFAULT_PARSED_STYLE_PROPS, _this.config.initialParsedStyle);
        } else if (_this.config.initialParsedStyle) {
          Object.assign(
            _this.parsedStyle,
            // DEFAULT_PARSED_STYLE_PROPS_CSS_DISABLED,
            _this.config.initialParsedStyle
          );
        }
        _this.initAttributes(_this.config.style);
        if (runtime.enableDataset) {
          _this.dataset = new Proxy2({}, {
            get: function(target, name2) {
              var formattedName = "".concat(DATASET_PREFIX).concat(kebabize(name2));
              if (target[formattedName] !== void 0) {
                return target[formattedName];
              }
              return _this.getAttribute(formattedName);
            },
            set: function(_2, prop, value2) {
              _this.setAttribute("".concat(DATASET_PREFIX).concat(kebabize(prop)), value2);
              return true;
            }
          });
        }
        if (runtime.enableStyleSyntax) {
          _this.style = new Proxy2(
            // @ts-ignore
            {
              // ...this.attributes,
              setProperty: function(propertyName, value2) {
                _this.setAttribute(propertyName, value2);
              },
              getPropertyValue: function(propertyName) {
                return _this.getAttribute(propertyName);
              },
              removeProperty: function(propertyName) {
                _this.removeAttribute(propertyName);
              },
              item: function() {
                return "";
              }
            },
            {
              get: function(target, name2) {
                if (target[name2] !== void 0) {
                  return target[name2];
                }
                return _this.getAttribute(name2);
              },
              set: function(_2, prop, value2) {
                _this.setAttribute(prop, value2);
                return true;
              }
            }
          );
        }
        return _this;
      }
      DisplayObject2.prototype.destroy = function() {
        _super.prototype.destroy.call(this);
        this.getAnimations().forEach(function(animation) {
          animation.cancel();
        });
      };
      DisplayObject2.prototype.cloneNode = function(deep2, customCloneFunc) {
        var clonedStyle = __assign({}, this.attributes);
        for (var attributeName in clonedStyle) {
          var attribute = clonedStyle[attributeName];
          if (isDisplayObject(attribute) && // share the same clipPath if possible
          attributeName !== "clipPath" && attributeName !== "offsetPath" && attributeName !== "textPath") {
            clonedStyle[attributeName] = attribute.cloneNode(deep2);
          }
          if (customCloneFunc) {
            clonedStyle[attributeName] = customCloneFunc(attributeName, attribute);
          }
        }
        var cloned = new this.constructor({
          // copy id & name
          // @see https://developer.mozilla.org/en-US/docs/Web/API/Node/cloneNode#notes
          id: this.id,
          name: this.name,
          className: this.name,
          interactive: this.interactive,
          style: clonedStyle
        });
        cloned.setLocalTransform(this.getLocalTransform());
        if (deep2) {
          this.children.forEach(function(child) {
            if (!child.style.isMarker) {
              var clonedChild = child.cloneNode(deep2);
              cloned.appendChild(clonedChild);
            }
          });
        }
        return cloned;
      };
      DisplayObject2.prototype.initAttributes = function(attributes) {
        if (attributes === void 0) {
          attributes = {};
        }
        var renderable = this.renderable;
        var options = {
          forceUpdateGeometry: true
          // usedAttributes:
          //   // only Group / Text should account for text relative props
          //   this.tagName === Shape.GROUP || this.tagName === Shape.TEXT
          //     ? INHERITABLE_STYLE_PROPS
          //     : INHERITABLE_BASE_STYLE_PROPS,
        };
        if (runtime.enableCSSParsing) {
          options.usedAttributes = INHERITABLE_STYLE_PROPS;
        }
        var formattedAttributes = attributes;
        if (runtime.enableAttributeDashCased) {
          formattedAttributes = {};
          for (var name_1 in attributes) {
            var attributeName = formatAttributeName(name_1);
            formattedAttributes[attributeName] = attributes[name_1];
          }
        }
        runtime.styleValueRegistry.processProperties(this, formattedAttributes, options);
        renderable.dirty = true;
      };
      DisplayObject2.prototype.setAttribute = function(name2, value2, force, memoize2) {
        if (force === void 0) {
          force = false;
        }
        if (memoize2 === void 0) {
          memoize2 = true;
        }
        if (runtime.enableAttributeDashCased) {
          name2 = formatAttributeName(name2);
        }
        if (is_undefined_default2(value2)) {
          return;
        }
        if (force || value2 !== this.attributes[name2]) {
          this.internalSetAttribute(name2, value2, { memoize: memoize2 });
          _super.prototype.setAttribute.call(this, name2, value2);
        }
      };
      DisplayObject2.prototype.internalSetAttribute = function(name2, value2, parseOptions) {
        var _a;
        if (parseOptions === void 0) {
          parseOptions = {};
        }
        var renderable = this.renderable;
        var oldValue = this.attributes[name2];
        var oldParsedValue = this.parsedStyle[name2];
        runtime.styleValueRegistry.processProperties(this, (_a = {}, _a[name2] = value2, _a), parseOptions);
        renderable.dirty = true;
        var newParsedValue = this.parsedStyle[name2];
        if (this.isConnected) {
          mutationEvent.relatedNode = this;
          mutationEvent.prevValue = oldValue;
          mutationEvent.newValue = value2;
          mutationEvent.attrName = name2;
          mutationEvent.prevParsedValue = oldParsedValue;
          mutationEvent.newParsedValue = newParsedValue;
          if (this.isMutationObserved) {
            this.dispatchEvent(mutationEvent);
          } else {
            mutationEvent.target = this;
            this.ownerDocument.defaultView.dispatchEvent(mutationEvent, true);
          }
        }
        if ((this.isCustomElement && this.isConnected || !this.isCustomElement) && this.attributeChangedCallback) {
          this.attributeChangedCallback(name2, oldValue, value2, oldParsedValue, newParsedValue);
        }
      };
      DisplayObject2.prototype.getBBox = function() {
        var aabb = this.getBounds();
        var _a = __read(aabb.getMin(), 2), left2 = _a[0], top = _a[1];
        var _b = __read(aabb.getMax(), 2), right2 = _b[0], bottom = _b[1];
        return new Rectangle(left2, top, right2 - left2, bottom - top);
      };
      DisplayObject2.prototype.setOrigin = function(position, y3, z) {
        if (y3 === void 0) {
          y3 = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        runtime.sceneGraphService.setOrigin(this, createVec3(position, y3, z));
        return this;
      };
      DisplayObject2.prototype.getOrigin = function() {
        return runtime.sceneGraphService.getOrigin(this);
      };
      DisplayObject2.prototype.setPosition = function(position, y3, z) {
        if (y3 === void 0) {
          y3 = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        runtime.sceneGraphService.setPosition(this, createVec3(position, y3, z));
        return this;
      };
      DisplayObject2.prototype.setLocalPosition = function(position, y3, z) {
        if (y3 === void 0) {
          y3 = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        runtime.sceneGraphService.setLocalPosition(this, createVec3(position, y3, z));
        return this;
      };
      DisplayObject2.prototype.translate = function(position, y3, z) {
        if (y3 === void 0) {
          y3 = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        runtime.sceneGraphService.translate(this, createVec3(position, y3, z));
        return this;
      };
      DisplayObject2.prototype.translateLocal = function(position, y3, z) {
        if (y3 === void 0) {
          y3 = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        runtime.sceneGraphService.translateLocal(this, createVec3(position, y3, z));
        return this;
      };
      DisplayObject2.prototype.getPosition = function() {
        return runtime.sceneGraphService.getPosition(this);
      };
      DisplayObject2.prototype.getLocalPosition = function() {
        return runtime.sceneGraphService.getLocalPosition(this);
      };
      DisplayObject2.prototype.scale = function(scaling, y3, z) {
        return this.scaleLocal(scaling, y3, z);
      };
      DisplayObject2.prototype.scaleLocal = function(scaling, y3, z) {
        if (typeof scaling === "number") {
          y3 = y3 || scaling;
          z = z || scaling;
          scaling = createVec3(scaling, y3, z);
        }
        runtime.sceneGraphService.scaleLocal(this, scaling);
        return this;
      };
      DisplayObject2.prototype.setLocalScale = function(scaling, y3, z) {
        if (typeof scaling === "number") {
          y3 = y3 || scaling;
          z = z || scaling;
          scaling = createVec3(scaling, y3, z);
        }
        runtime.sceneGraphService.setLocalScale(this, scaling);
        return this;
      };
      DisplayObject2.prototype.getLocalScale = function() {
        return runtime.sceneGraphService.getLocalScale(this);
      };
      DisplayObject2.prototype.getScale = function() {
        return runtime.sceneGraphService.getScale(this);
      };
      DisplayObject2.prototype.getEulerAngles = function() {
        var _a = __read(getEuler(vec3_exports.create(), runtime.sceneGraphService.getWorldTransform(this)), 3), ez = _a[2];
        return rad2deg(ez);
      };
      DisplayObject2.prototype.getLocalEulerAngles = function() {
        var _a = __read(getEuler(vec3_exports.create(), runtime.sceneGraphService.getLocalRotation(this)), 3), ez = _a[2];
        return rad2deg(ez);
      };
      DisplayObject2.prototype.setEulerAngles = function(z) {
        runtime.sceneGraphService.setEulerAngles(this, 0, 0, z);
        return this;
      };
      DisplayObject2.prototype.setLocalEulerAngles = function(z) {
        runtime.sceneGraphService.setLocalEulerAngles(this, 0, 0, z);
        return this;
      };
      DisplayObject2.prototype.rotateLocal = function(x3, y3, z) {
        if (is_nil_default2(y3) && is_nil_default2(z)) {
          runtime.sceneGraphService.rotateLocal(this, 0, 0, x3);
        } else {
          runtime.sceneGraphService.rotateLocal(this, x3, y3, z);
        }
        return this;
      };
      DisplayObject2.prototype.rotate = function(x3, y3, z) {
        if (is_nil_default2(y3) && is_nil_default2(z)) {
          runtime.sceneGraphService.rotate(this, 0, 0, x3);
        } else {
          runtime.sceneGraphService.rotate(this, x3, y3, z);
        }
        return this;
      };
      DisplayObject2.prototype.setRotation = function(rotation, y3, z, w) {
        runtime.sceneGraphService.setRotation(this, rotation, y3, z, w);
        return this;
      };
      DisplayObject2.prototype.setLocalRotation = function(rotation, y3, z, w) {
        runtime.sceneGraphService.setLocalRotation(this, rotation, y3, z, w);
        return this;
      };
      DisplayObject2.prototype.setLocalSkew = function(skew, y3) {
        runtime.sceneGraphService.setLocalSkew(this, skew, y3);
        return this;
      };
      DisplayObject2.prototype.getRotation = function() {
        return runtime.sceneGraphService.getRotation(this);
      };
      DisplayObject2.prototype.getLocalRotation = function() {
        return runtime.sceneGraphService.getLocalRotation(this);
      };
      DisplayObject2.prototype.getLocalSkew = function() {
        return runtime.sceneGraphService.getLocalSkew(this);
      };
      DisplayObject2.prototype.getLocalTransform = function() {
        return runtime.sceneGraphService.getLocalTransform(this);
      };
      DisplayObject2.prototype.getWorldTransform = function() {
        return runtime.sceneGraphService.getWorldTransform(this);
      };
      DisplayObject2.prototype.setLocalTransform = function(transform) {
        runtime.sceneGraphService.setLocalTransform(this, transform);
        return this;
      };
      DisplayObject2.prototype.resetLocalTransform = function() {
        runtime.sceneGraphService.resetLocalTransform(this);
      };
      DisplayObject2.prototype.getAnimations = function() {
        return this.activeAnimations;
      };
      DisplayObject2.prototype.animate = function(keyframes, options) {
        var _a;
        var timeline = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.timeline;
        if (timeline) {
          return timeline.play(this, keyframes, options);
        }
        return null;
      };
      DisplayObject2.prototype.isVisible = function() {
        var _a, _b;
        return runtime.enableCSSParsing ? ((_a = this.parsedStyle) === null || _a === void 0 ? void 0 : _a.visibility) === "visible" : ((_b = this.parsedStyle) === null || _b === void 0 ? void 0 : _b.visibility) !== "hidden";
      };
      Object.defineProperty(DisplayObject2.prototype, "interactive", {
        get: function() {
          return this.isInteractive();
        },
        set: function(b) {
          this.style.pointerEvents = b ? "auto" : "none";
        },
        enumerable: false,
        configurable: true
      });
      DisplayObject2.prototype.isInteractive = function() {
        var _a;
        return ((_a = this.parsedStyle) === null || _a === void 0 ? void 0 : _a.pointerEvents) !== "none";
      };
      DisplayObject2.prototype.isCulled = function() {
        return !!(this.cullable && this.cullable.enable && !this.cullable.visible);
      };
      DisplayObject2.prototype.toFront = function() {
        if (this.parentNode) {
          this.style.zIndex = Math.max.apply(Math, __spreadArray([], __read(this.parentNode.children.map(function(child) {
            return Number(child.style.zIndex);
          })), false)) + 1;
        }
        return this;
      };
      DisplayObject2.prototype.toBack = function() {
        if (this.parentNode) {
          this.style.zIndex = Math.min.apply(Math, __spreadArray([], __read(this.parentNode.children.map(function(child) {
            return Number(child.style.zIndex);
          })), false)) - 1;
        }
        return this;
      };
      DisplayObject2.prototype.getConfig = function() {
        return this.config;
      };
      DisplayObject2.prototype.attr = function() {
        var _this = this;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var _a = __read(args, 2), name2 = _a[0], value2 = _a[1];
        if (!name2) {
          return this.attributes;
        }
        if (is_object_default2(name2)) {
          Object.keys(name2).forEach(function(key) {
            _this.setAttribute(key, name2[key]);
          });
          return this;
        }
        if (args.length === 2) {
          this.setAttribute(name2, value2);
          return this;
        }
        return this.attributes[name2];
      };
      DisplayObject2.prototype.getMatrix = function(transformMat44) {
        var transform = transformMat44 || this.getWorldTransform();
        var _a = __read(mat4_exports.getTranslation(vec3_exports.create(), transform), 2), tx = _a[0], ty = _a[1];
        var _b = __read(mat4_exports.getScaling(vec3_exports.create(), transform), 2), sx = _b[0], sy = _b[1];
        var rotation = mat4_exports.getRotation(quat_exports.create(), transform);
        var _c = __read(getEuler(vec3_exports.create(), rotation), 3), eux = _c[0], euz = _c[2];
        return fromRotationTranslationScale2(eux || euz, tx, ty, sx, sy);
      };
      DisplayObject2.prototype.getLocalMatrix = function() {
        return this.getMatrix(this.getLocalTransform());
      };
      DisplayObject2.prototype.setMatrix = function(mat) {
        var _a = __read(decompose(mat), 5), tx = _a[0], ty = _a[1], scalingX = _a[2], scalingY = _a[3], angle4 = _a[4];
        this.setEulerAngles(angle4).setPosition(tx, ty).setLocalScale(scalingX, scalingY);
      };
      DisplayObject2.prototype.setLocalMatrix = function(mat) {
        var _a = __read(decompose(mat), 5), tx = _a[0], ty = _a[1], scalingX = _a[2], scalingY = _a[3], angle4 = _a[4];
        this.setLocalEulerAngles(angle4).setLocalPosition(tx, ty).setLocalScale(scalingX, scalingY);
      };
      DisplayObject2.prototype.show = function() {
        if (runtime.enableCSSParsing) {
          this.style.visibility = "visible";
        } else {
          this.forEach(function(object) {
            object.style.visibility = "visible";
          });
        }
      };
      DisplayObject2.prototype.hide = function() {
        if (runtime.enableCSSParsing) {
          this.style.visibility = "hidden";
        } else {
          this.forEach(function(object) {
            object.style.visibility = "hidden";
          });
        }
      };
      DisplayObject2.prototype.getCount = function() {
        return this.childElementCount;
      };
      DisplayObject2.prototype.getParent = function() {
        return this.parentElement;
      };
      DisplayObject2.prototype.getChildren = function() {
        return this.children;
      };
      DisplayObject2.prototype.getFirst = function() {
        return this.firstElementChild;
      };
      DisplayObject2.prototype.getLast = function() {
        return this.lastElementChild;
      };
      DisplayObject2.prototype.getChildByIndex = function(index4) {
        return this.children[index4] || null;
      };
      DisplayObject2.prototype.add = function(child, index4) {
        return this.appendChild(child, index4);
      };
      DisplayObject2.prototype.set = function(name2, value2) {
        this.config[name2] = value2;
      };
      DisplayObject2.prototype.get = function(name2) {
        return this.config[name2];
      };
      DisplayObject2.prototype.moveTo = function(position, y3, z) {
        if (y3 === void 0) {
          y3 = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        this.setPosition(position, y3, z);
        return this;
      };
      DisplayObject2.prototype.move = function(position, y3, z) {
        if (y3 === void 0) {
          y3 = 0;
        }
        if (z === void 0) {
          z = 0;
        }
        this.setPosition(position, y3, z);
        return this;
      };
      DisplayObject2.prototype.setZIndex = function(zIndex) {
        this.style.zIndex = zIndex;
        return this;
      };
      return DisplayObject2;
    }(Element2)
  );
  var Circle = (
    /** @class */
    function(_super) {
      __extends(Circle3, _super);
      function Circle3(options) {
        if (options === void 0) {
          options = {};
        }
        return _super.call(this, __assign({ type: Shape.CIRCLE }, options)) || this;
      }
      return Circle3;
    }(DisplayObject)
  );
  var CustomElement = (
    /** @class */
    function(_super) {
      __extends(CustomElement2, _super);
      function CustomElement2(_a) {
        if (_a === void 0) {
          _a = {};
        }
        var _this = this;
        var style = _a.style, rest = __rest(_a, ["style"]);
        _this = _super.call(this, __assign({ style: runtime.enableCSSParsing ? __assign({}, style) : __assign({}, style) }, rest)) || this;
        _this.isCustomElement = true;
        return _this;
      }
      return CustomElement2;
    }(DisplayObject)
  );
  var Ellipse = (
    /** @class */
    function(_super) {
      __extends(Ellipse2, _super);
      function Ellipse2(options) {
        if (options === void 0) {
          options = {};
        }
        return _super.call(this, __assign({ type: Shape.ELLIPSE }, options)) || this;
      }
      return Ellipse2;
    }(DisplayObject)
  );
  var Group2 = (
    /** @class */
    function(_super) {
      __extends(Group3, _super);
      function Group3(options) {
        if (options === void 0) {
          options = {};
        }
        return _super.call(this, __assign({ type: Shape.GROUP }, options)) || this;
      }
      return Group3;
    }(DisplayObject)
  );
  var HTML = (
    /** @class */
    function(_super) {
      __extends(HTML2, _super);
      function HTML2(_a) {
        if (_a === void 0) {
          _a = {};
        }
        var _this = this;
        var style = _a.style, rest = __rest(_a, ["style"]);
        _this = _super.call(this, __assign({ type: Shape.HTML, style: runtime.enableCSSParsing ? __assign({ x: "", y: "", width: "auto", height: "auto", innerHTML: "" }, style) : __assign({}, style) }, rest)) || this;
        _this.cullable.enable = false;
        return _this;
      }
      HTML2.prototype.getDomElement = function() {
        return this.parsedStyle.$el;
      };
      HTML2.prototype.getBoundingClientRect = function() {
        if (this.parsedStyle.$el) {
          return this.parsedStyle.$el.getBoundingClientRect();
        } else {
          var _a = this.parsedStyle, x3 = _a.x, y3 = _a.y, width = _a.width, height = _a.height;
          return new Rectangle(x3, y3, width, height);
        }
      };
      HTML2.prototype.getClientRects = function() {
        return [this.getBoundingClientRect()];
      };
      HTML2.prototype.getBounds = function() {
        var _a, _b;
        var clientRect = this.getBoundingClientRect();
        var canvasRect = (_b = (_a = this.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.getContextService().getBoundingClientRect();
        var aabb = new AABB();
        var minX = clientRect.left - ((canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.left) || 0);
        var minY = clientRect.top - ((canvasRect === null || canvasRect === void 0 ? void 0 : canvasRect.top) || 0);
        aabb.setMinMax([minX, minY, 0], [minX + clientRect.width, minY + clientRect.height, 0]);
        return aabb;
      };
      HTML2.prototype.getLocalBounds = function() {
        if (this.parentNode) {
          var parentInvert = mat4_exports.invert(mat4_exports.create(), this.parentNode.getWorldTransform());
          var bounds = this.getBounds();
          if (!AABB.isEmpty(bounds)) {
            var localBounds = new AABB();
            localBounds.setFromTransformedAABB(bounds, parentInvert);
            return localBounds;
          }
        }
        return this.getBounds();
      };
      return HTML2;
    }(DisplayObject)
  );
  var Image2 = (
    /** @class */
    function(_super) {
      __extends(Image5, _super);
      function Image5(options) {
        if (options === void 0) {
          options = {};
        }
        return _super.call(this, __assign({ type: Shape.IMAGE }, options)) || this;
      }
      return Image5;
    }(DisplayObject)
  );
  var Line = (
    /** @class */
    function(_super) {
      __extends(Line6, _super);
      function Line6(_a) {
        if (_a === void 0) {
          _a = {};
        }
        var _this = this;
        var style = _a.style, rest = __rest(_a, ["style"]);
        _this = _super.call(this, __assign({ type: Shape.LINE, style: __assign({ x1: 0, y1: 0, x2: 0, y2: 0, z1: 0, z2: 0 }, style) }, rest)) || this;
        _this.markerStartAngle = 0;
        _this.markerEndAngle = 0;
        var _b = _this.parsedStyle, markerStart = _b.markerStart, markerEnd = _b.markerEnd;
        if (markerStart && isDisplayObject(markerStart)) {
          _this.markerStartAngle = markerStart.getLocalEulerAngles();
          _this.appendChild(markerStart);
        }
        if (markerEnd && isDisplayObject(markerEnd)) {
          _this.markerEndAngle = markerEnd.getLocalEulerAngles();
          _this.appendChild(markerEnd);
        }
        _this.transformMarker(true);
        _this.transformMarker(false);
        return _this;
      }
      Line6.prototype.attributeChangedCallback = function(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
        if (attrName === "x1" || attrName === "y1" || attrName === "x2" || attrName === "y2" || attrName === "markerStartOffset" || attrName === "markerEndOffset") {
          this.transformMarker(true);
          this.transformMarker(false);
        } else if (attrName === "markerStart") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerStartAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerStartAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(true);
          }
        } else if (attrName === "markerEnd") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerEndAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerEndAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(false);
          }
        }
      };
      Line6.prototype.transformMarker = function(isStart) {
        var _a = this.parsedStyle, markerStart = _a.markerStart, markerEnd = _a.markerEnd, markerStartOffset = _a.markerStartOffset, markerEndOffset = _a.markerEndOffset, x12 = _a.x1, x22 = _a.x2, y12 = _a.y1, y22 = _a.y2;
        var marker = isStart ? markerStart : markerEnd;
        if (!marker || !isDisplayObject(marker)) {
          return;
        }
        var rad = 0;
        var x3;
        var y3;
        var ox;
        var oy;
        var offset3;
        var originalAngle;
        if (isStart) {
          ox = x12;
          oy = y12;
          x3 = x22 - x12;
          y3 = y22 - y12;
          offset3 = markerStartOffset || 0;
          originalAngle = this.markerStartAngle;
        } else {
          ox = x22;
          oy = y22;
          x3 = x12 - x22;
          y3 = y12 - y22;
          offset3 = markerEndOffset || 0;
          originalAngle = this.markerEndAngle;
        }
        rad = Math.atan2(y3, x3);
        marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);
        marker.setLocalPosition(ox + Math.cos(rad) * offset3, oy + Math.sin(rad) * offset3);
      };
      Line6.prototype.getPoint = function(ratio, inWorldSpace) {
        if (inWorldSpace === void 0) {
          inWorldSpace = false;
        }
        var _a = this.parsedStyle, x12 = _a.x1, y12 = _a.y1, x22 = _a.x2, y22 = _a.y2;
        var _b = pointAt$3(x12, y12, x22, y22, ratio), x3 = _b.x, y3 = _b.y;
        var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
        return new Point2(transformed[0], transformed[1]);
      };
      Line6.prototype.getPointAtLength = function(distance8, inWorldSpace) {
        if (inWorldSpace === void 0) {
          inWorldSpace = false;
        }
        return this.getPoint(distance8 / this.getTotalLength(), inWorldSpace);
      };
      Line6.prototype.getTotalLength = function() {
        var _a = this.parsedStyle, x12 = _a.x1, y12 = _a.y1, x22 = _a.x2, y22 = _a.y2;
        return length$4(x12, y12, x22, y22);
      };
      return Line6;
    }(DisplayObject)
  );
  var Path2 = (
    /** @class */
    function(_super) {
      __extends(Path5, _super);
      function Path5(_a) {
        if (_a === void 0) {
          _a = {};
        }
        var _this = this;
        var style = _a.style, rest = __rest(_a, ["style"]);
        _this = _super.call(this, __assign({ type: Shape.PATH, style: runtime.enableCSSParsing ? __assign({ d: "", miterLimit: "" }, style) : __assign({}, style), initialParsedStyle: runtime.enableCSSParsing ? null : {
          miterLimit: 4,
          d: __assign({}, EMPTY_PARSED_PATH)
        } }, rest)) || this;
        _this.markerStartAngle = 0;
        _this.markerEndAngle = 0;
        _this.markerMidList = [];
        var _b = _this.parsedStyle, markerStart = _b.markerStart, markerEnd = _b.markerEnd, markerMid = _b.markerMid;
        if (markerStart && isDisplayObject(markerStart)) {
          _this.markerStartAngle = markerStart.getLocalEulerAngles();
          _this.appendChild(markerStart);
        }
        if (markerMid && isDisplayObject(markerMid)) {
          _this.placeMarkerMid(markerMid);
        }
        if (markerEnd && isDisplayObject(markerEnd)) {
          _this.markerEndAngle = markerEnd.getLocalEulerAngles();
          _this.appendChild(markerEnd);
        }
        _this.transformMarker(true);
        _this.transformMarker(false);
        return _this;
      }
      Path5.prototype.attributeChangedCallback = function(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
        if (attrName === "d") {
          this.transformMarker(true);
          this.transformMarker(false);
          this.placeMarkerMid(this.parsedStyle.markerMid);
        } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
          this.transformMarker(true);
          this.transformMarker(false);
        } else if (attrName === "markerStart") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerStartAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerStartAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(true);
          }
        } else if (attrName === "markerEnd") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerEndAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerEndAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(false);
          }
        } else if (attrName === "markerMid") {
          this.placeMarkerMid(newParsedValue);
        }
      };
      Path5.prototype.transformMarker = function(isStart) {
        var _a = this.parsedStyle, markerStart = _a.markerStart, markerEnd = _a.markerEnd, markerStartOffset = _a.markerStartOffset, markerEndOffset = _a.markerEndOffset;
        var marker = isStart ? markerStart : markerEnd;
        if (!marker || !isDisplayObject(marker)) {
          return;
        }
        var rad = 0;
        var x3;
        var y3;
        var ox;
        var oy;
        var offset3;
        var originalAngle;
        if (isStart) {
          var _b = __read(this.getStartTangent(), 2), p1 = _b[0], p2 = _b[1];
          ox = p2[0];
          oy = p2[1];
          x3 = p1[0] - p2[0];
          y3 = p1[1] - p2[1];
          offset3 = markerStartOffset || 0;
          originalAngle = this.markerStartAngle;
        } else {
          var _c = __read(this.getEndTangent(), 2), p1 = _c[0], p2 = _c[1];
          ox = p2[0];
          oy = p2[1];
          x3 = p1[0] - p2[0];
          y3 = p1[1] - p2[1];
          offset3 = markerEndOffset || 0;
          originalAngle = this.markerEndAngle;
        }
        rad = Math.atan2(y3, x3);
        marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);
        marker.setLocalPosition(ox + Math.cos(rad) * offset3, oy + Math.sin(rad) * offset3);
      };
      Path5.prototype.placeMarkerMid = function(marker) {
        var segments = this.parsedStyle.d.segments;
        this.markerMidList.forEach(function(marker2) {
          marker2.remove();
        });
        if (marker && isDisplayObject(marker)) {
          for (var i = 1; i < segments.length - 1; i++) {
            var _a = __read(segments[i].currentPoint, 2), ox = _a[0], oy = _a[1];
            var cloned = i === 1 ? marker : marker.cloneNode(true);
            this.markerMidList.push(cloned);
            this.appendChild(cloned);
            cloned.setLocalPosition(ox, oy);
          }
        }
      };
      Path5.prototype.getTotalLength = function() {
        return getOrCalculatePathTotalLength(this);
      };
      Path5.prototype.getPointAtLength = function(distance8, inWorldSpace) {
        if (inWorldSpace === void 0) {
          inWorldSpace = false;
        }
        var absolutePath = this.parsedStyle.d.absolutePath;
        var _a = getPointAtLength(absolutePath, distance8), x3 = _a.x, y3 = _a.y;
        var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
        return new Point2(transformed[0], transformed[1]);
      };
      Path5.prototype.getPoint = function(ratio, inWorldSpace) {
        if (inWorldSpace === void 0) {
          inWorldSpace = false;
        }
        return this.getPointAtLength(ratio * getOrCalculatePathTotalLength(this), inWorldSpace);
      };
      Path5.prototype.getStartTangent = function() {
        var segments = this.parsedStyle.d.segments;
        var result = [];
        if (segments.length > 1) {
          var startPoint = segments[0].currentPoint;
          var endPoint = segments[1].currentPoint;
          var tangent = segments[1].startTangent;
          result = [];
          if (tangent) {
            result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
            result.push([startPoint[0], startPoint[1]]);
          } else {
            result.push([endPoint[0], endPoint[1]]);
            result.push([startPoint[0], startPoint[1]]);
          }
        }
        return result;
      };
      Path5.prototype.getEndTangent = function() {
        var segments = this.parsedStyle.d.segments;
        var length5 = segments.length;
        var result = [];
        if (length5 > 1) {
          var startPoint = segments[length5 - 2].currentPoint;
          var endPoint = segments[length5 - 1].currentPoint;
          var tangent = segments[length5 - 1].endTangent;
          result = [];
          if (tangent) {
            result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
            result.push([endPoint[0], endPoint[1]]);
          } else {
            result.push([startPoint[0], startPoint[1]]);
            result.push([endPoint[0], endPoint[1]]);
          }
        }
        return result;
      };
      return Path5;
    }(DisplayObject)
  );
  var Polygon = (
    /** @class */
    function(_super) {
      __extends(Polygon4, _super);
      function Polygon4(_a) {
        if (_a === void 0) {
          _a = {};
        }
        var _this = this;
        var style = _a.style, rest = __rest(_a, ["style"]);
        _this = _super.call(this, __assign({ type: Shape.POLYGON, style: runtime.enableCSSParsing ? __assign({ points: "", miterLimit: "", isClosed: true }, style) : __assign({}, style), initialParsedStyle: runtime.enableCSSParsing ? null : {
          points: {
            points: [],
            totalLength: 0,
            segments: []
          },
          miterLimit: 4,
          isClosed: true
        } }, rest)) || this;
        _this.markerStartAngle = 0;
        _this.markerEndAngle = 0;
        _this.markerMidList = [];
        var _b = _this.parsedStyle, markerStart = _b.markerStart, markerEnd = _b.markerEnd, markerMid = _b.markerMid;
        if (markerStart && isDisplayObject(markerStart)) {
          _this.markerStartAngle = markerStart.getLocalEulerAngles();
          _this.appendChild(markerStart);
        }
        if (markerMid && isDisplayObject(markerMid)) {
          _this.placeMarkerMid(markerMid);
        }
        if (markerEnd && isDisplayObject(markerEnd)) {
          _this.markerEndAngle = markerEnd.getLocalEulerAngles();
          _this.appendChild(markerEnd);
        }
        _this.transformMarker(true);
        _this.transformMarker(false);
        return _this;
      }
      Polygon4.prototype.attributeChangedCallback = function(attrName, oldValue, newValue, prevParsedValue, newParsedValue) {
        if (attrName === "points") {
          this.transformMarker(true);
          this.transformMarker(false);
          this.placeMarkerMid(this.parsedStyle.markerMid);
        } else if (attrName === "markerStartOffset" || attrName === "markerEndOffset") {
          this.transformMarker(true);
          this.transformMarker(false);
        } else if (attrName === "markerStart") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerStartAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerStartAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(true);
          }
        } else if (attrName === "markerEnd") {
          if (prevParsedValue && isDisplayObject(prevParsedValue)) {
            this.markerEndAngle = 0;
            prevParsedValue.remove();
          }
          if (newParsedValue && isDisplayObject(newParsedValue)) {
            this.markerEndAngle = newParsedValue.getLocalEulerAngles();
            this.appendChild(newParsedValue);
            this.transformMarker(false);
          }
        } else if (attrName === "markerMid") {
          this.placeMarkerMid(newParsedValue);
        }
      };
      Polygon4.prototype.transformMarker = function(isStart) {
        var _a = this.parsedStyle, markerStart = _a.markerStart, markerEnd = _a.markerEnd, markerStartOffset = _a.markerStartOffset, markerEndOffset = _a.markerEndOffset, P = _a.points;
        var points = (P || {}).points;
        var marker = isStart ? markerStart : markerEnd;
        if (!marker || !isDisplayObject(marker) || !points) {
          return;
        }
        var rad = 0;
        var x3;
        var y3;
        var ox;
        var oy;
        var offset3;
        var originalAngle;
        ox = points[0][0];
        oy = points[0][1];
        if (isStart) {
          x3 = points[1][0] - points[0][0];
          y3 = points[1][1] - points[0][1];
          offset3 = markerStartOffset || 0;
          originalAngle = this.markerStartAngle;
        } else {
          var length_1 = points.length;
          if (!this.parsedStyle.isClosed) {
            ox = points[length_1 - 1][0];
            oy = points[length_1 - 1][1];
            x3 = points[length_1 - 2][0] - points[length_1 - 1][0];
            y3 = points[length_1 - 2][1] - points[length_1 - 1][1];
          } else {
            x3 = points[length_1 - 1][0] - points[0][0];
            y3 = points[length_1 - 1][1] - points[0][1];
          }
          offset3 = markerEndOffset || 0;
          originalAngle = this.markerEndAngle;
        }
        rad = Math.atan2(y3, x3);
        marker.setLocalEulerAngles(rad * 180 / Math.PI + originalAngle);
        marker.setLocalPosition(ox + Math.cos(rad) * offset3, oy + Math.sin(rad) * offset3);
      };
      Polygon4.prototype.placeMarkerMid = function(marker) {
        var P = this.parsedStyle.points;
        var points = (P || {}).points;
        this.markerMidList.forEach(function(marker2) {
          marker2.remove();
        });
        this.markerMidList = [];
        if (marker && isDisplayObject(marker) && points) {
          for (var i = 1; i < (this.parsedStyle.isClosed ? points.length : points.length - 1); i++) {
            var ox = points[i][0];
            var oy = points[i][1];
            var cloned = i === 1 ? marker : marker.cloneNode(true);
            this.markerMidList.push(cloned);
            this.appendChild(cloned);
            cloned.setLocalPosition(ox, oy);
          }
        }
      };
      return Polygon4;
    }(DisplayObject)
  );
  var Polyline = (
    /** @class */
    function(_super) {
      __extends(Polyline2, _super);
      function Polyline2(_a) {
        if (_a === void 0) {
          _a = {};
        }
        var style = _a.style, rest = __rest(_a, ["style"]);
        return _super.call(this, __assign({ type: Shape.POLYLINE, style: runtime.enableCSSParsing ? __assign({ points: "", miterLimit: "", isClosed: false }, style) : __assign({}, style), initialParsedStyle: runtime.enableCSSParsing ? null : {
          points: {
            points: [],
            totalLength: 0,
            segments: []
          },
          miterLimit: 4,
          isClosed: false
        } }, rest)) || this;
      }
      Polyline2.prototype.getTotalLength = function() {
        return getOrCalculatePolylineTotalLength(this);
      };
      Polyline2.prototype.getPointAtLength = function(distance8, inWorldSpace) {
        if (inWorldSpace === void 0) {
          inWorldSpace = false;
        }
        return this.getPoint(distance8 / this.getTotalLength(), inWorldSpace);
      };
      Polyline2.prototype.getPoint = function(ratio, inWorldSpace) {
        if (inWorldSpace === void 0) {
          inWorldSpace = false;
        }
        var points = this.parsedStyle.points.points;
        if (this.parsedStyle.points.segments.length === 0) {
          var segments_1 = [];
          var tempLength_1 = 0;
          var segmentT_1;
          var segmentL_1;
          var totalLength_1 = this.getTotalLength();
          points.forEach(function(p2, i) {
            if (points[i + 1]) {
              segmentT_1 = [0, 0];
              segmentT_1[0] = tempLength_1 / totalLength_1;
              segmentL_1 = length$4(p2[0], p2[1], points[i + 1][0], points[i + 1][1]);
              tempLength_1 += segmentL_1;
              segmentT_1[1] = tempLength_1 / totalLength_1;
              segments_1.push(segmentT_1);
            }
          });
          this.parsedStyle.points.segments = segments_1;
        }
        var subt = 0;
        var index4 = 0;
        this.parsedStyle.points.segments.forEach(function(v, i) {
          if (ratio >= v[0] && ratio <= v[1]) {
            subt = (ratio - v[0]) / (v[1] - v[0]);
            index4 = i;
          }
        });
        var _a = pointAt$3(points[index4][0], points[index4][1], points[index4 + 1][0], points[index4 + 1][1], subt), x3 = _a.x, y3 = _a.y;
        var transformed = vec3_exports.transformMat4(vec3_exports.create(), vec3_exports.fromValues(x3, y3, 0), inWorldSpace ? this.getWorldTransform() : this.getLocalTransform());
        return new Point2(transformed[0], transformed[1]);
      };
      Polyline2.prototype.getStartTangent = function() {
        var points = this.parsedStyle.points.points;
        var result = [];
        result.push([points[1][0], points[1][1]]);
        result.push([points[0][0], points[0][1]]);
        return result;
      };
      Polyline2.prototype.getEndTangent = function() {
        var points = this.parsedStyle.points.points;
        var l2 = points.length - 1;
        var result = [];
        result.push([points[l2 - 1][0], points[l2 - 1][1]]);
        result.push([points[l2][0], points[l2][1]]);
        return result;
      };
      return Polyline2;
    }(Polygon)
  );
  var Rect = (
    /** @class */
    function(_super) {
      __extends(Rect4, _super);
      function Rect4(options) {
        if (options === void 0) {
          options = {};
        }
        return _super.call(this, __assign({ type: Shape.RECT }, options)) || this;
      }
      return Rect4;
    }(DisplayObject)
  );
  var Text = (
    /** @class */
    function(_super) {
      __extends(Text5, _super);
      function Text5(_a) {
        if (_a === void 0) {
          _a = {};
        }
        var style = _a.style, rest = __rest(_a, ["style"]);
        return _super.call(this, __assign({ type: Shape.TEXT, style: runtime.enableCSSParsing ? __assign({
          x: "",
          y: "",
          text: "",
          fontSize: "",
          fontFamily: "",
          fontStyle: "",
          fontWeight: "",
          fontVariant: "",
          textAlign: "",
          textBaseline: "",
          textTransform: "",
          fill: "black",
          letterSpacing: "",
          lineHeight: "",
          miterLimit: "",
          // whiteSpace: 'pre',
          wordWrap: false,
          wordWrapWidth: 0,
          leading: 0,
          dx: "",
          dy: ""
        }, style) : __assign({ fill: "black" }, style) }, rest)) || this;
      }
      Text5.prototype.getComputedTextLength = function() {
        var _a;
        this.getGeometryBounds();
        return ((_a = this.parsedStyle.metrics) === null || _a === void 0 ? void 0 : _a.maxLineWidth) || 0;
      };
      Text5.prototype.getLineBoundingRects = function() {
        var _a;
        this.getGeometryBounds();
        return ((_a = this.parsedStyle.metrics) === null || _a === void 0 ? void 0 : _a.lineMetrics) || [];
      };
      Text5.prototype.isOverflowing = function() {
        this.getGeometryBounds();
        return !!this.parsedStyle.isOverflowing;
      };
      return Text5;
    }(DisplayObject)
  );
  var CustomElementRegistry = (
    /** @class */
    function() {
      function CustomElementRegistry2() {
        this.registry = {};
        this.define(Shape.CIRCLE, Circle);
        this.define(Shape.ELLIPSE, Ellipse);
        this.define(Shape.RECT, Rect);
        this.define(Shape.IMAGE, Image2);
        this.define(Shape.LINE, Line);
        this.define(Shape.GROUP, Group2);
        this.define(Shape.PATH, Path2);
        this.define(Shape.POLYGON, Polygon);
        this.define(Shape.POLYLINE, Polyline);
        this.define(Shape.TEXT, Text);
        this.define(Shape.HTML, HTML);
      }
      CustomElementRegistry2.prototype.define = function(name2, constructor) {
        this.registry[name2] = constructor;
      };
      CustomElementRegistry2.prototype.get = function(name2) {
        return this.registry[name2];
      };
      return CustomElementRegistry2;
    }()
  );
  var CSS2 = {
    /**
     * <number>
     * @see https://drafts.csswg.org/css-values-4/#number-value
     */
    number: function(n2) {
      return new CSSUnitValue(n2);
    },
    /**
     * <percentage>
     * @see https://drafts.csswg.org/css-values-4/#percentage-value
     */
    percent: function(n2) {
      return new CSSUnitValue(n2, "%");
    },
    /**
     * <length>
     */
    px: function(n2) {
      return new CSSUnitValue(n2, "px");
    },
    /**
     * <length>
     */
    em: function(n2) {
      return new CSSUnitValue(n2, "em");
    },
    rem: function(n2) {
      return new CSSUnitValue(n2, "rem");
    },
    /**
     * <angle>
     */
    deg: function(n2) {
      return new CSSUnitValue(n2, "deg");
    },
    /**
     * <angle>
     */
    grad: function(n2) {
      return new CSSUnitValue(n2, "grad");
    },
    /**
     * <angle>
     */
    rad: function(n2) {
      return new CSSUnitValue(n2, "rad");
    },
    /**
     * <angle>
     */
    turn: function(n2) {
      return new CSSUnitValue(n2, "turn");
    },
    /**
     * <time>
     */
    s: function(n2) {
      return new CSSUnitValue(n2, "s");
    },
    /**
     * <time>
     */
    ms: function(n2) {
      return new CSSUnitValue(n2, "ms");
    },
    /**
     * CSS Properties & Values API
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS_Properties_and_Values_API
     * @see https://drafts.css-houdini.org/css-properties-values-api/#registering-custom-properties
     * @see https://developer.mozilla.org/en-US/docs/Web/API/CSS/RegisterProperty
     */
    registerProperty: function(definition) {
      var name2 = definition.name, inherits = definition.inherits, interpolable = definition.interpolable, initialValue = definition.initialValue, syntax = definition.syntax;
      runtime.styleValueRegistry.registerMetadata({
        n: name2,
        inh: inherits,
        int: interpolable,
        d: initialValue,
        syntax
      });
    },
    /**
     * CSS Layout API
     * register layout
     *
     * @see https://github.com/w3c/css-houdini-drafts/blob/main/css-layout-api/EXPLAINER.md
     * @see https://developer.mozilla.org/en-US/docs/Web/Guide/Houdini#css_layout_api
     */
    registerLayout: function(name2, clazz) {
      runtime.layoutRegistry.registerLayout(name2, clazz);
    }
  };
  var Document2 = (
    /** @class */
    function(_super) {
      __extends(Document3, _super);
      function Document3() {
        var _this = _super.call(this) || this;
        _this.defaultView = null;
        _this.ownerDocument = null;
        _this.nodeName = "document";
        try {
          _this.timeline = new runtime.AnimationTimeline(_this);
        } catch (e3) {
        }
        var initialStyle = {};
        BUILT_IN_PROPERTIES.forEach(function(_a) {
          var n2 = _a.n, inh = _a.inh, d2 = _a.d;
          if (inh && d2) {
            initialStyle[n2] = isFunction(d2) ? d2(Shape.GROUP) : d2;
          }
        });
        _this.documentElement = new Group2({
          id: "g-root",
          style: initialStyle
        });
        _this.documentElement.ownerDocument = _this;
        _this.documentElement.parentNode = _this;
        _this.childNodes = [_this.documentElement];
        return _this;
      }
      Object.defineProperty(Document3.prototype, "children", {
        get: function() {
          return this.childNodes;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Document3.prototype, "childElementCount", {
        get: function() {
          return this.childNodes.length;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Document3.prototype, "firstElementChild", {
        get: function() {
          return this.firstChild;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Document3.prototype, "lastElementChild", {
        get: function() {
          return this.lastChild;
        },
        enumerable: false,
        configurable: true
      });
      Document3.prototype.createElement = function(tagName, options) {
        if (tagName === "svg") {
          return this.documentElement;
        }
        var clazz = this.defaultView.customElements.get(tagName);
        if (!clazz) {
          console.warn("Unsupported tagName: ", tagName);
          clazz = tagName === "tspan" ? Text : Group2;
        }
        var shape23 = new clazz(options);
        shape23.ownerDocument = this;
        return shape23;
      };
      Document3.prototype.createElementNS = function(namespaceURI, tagName, options) {
        return this.createElement(tagName, options);
      };
      Document3.prototype.cloneNode = function(deep2) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Document3.prototype.destroy = function() {
        try {
          this.documentElement.destroyChildren();
          this.timeline.destroy();
        } catch (e3) {
        }
      };
      Document3.prototype.elementsFromBBox = function(minX, minY, maxX, maxY2) {
        var rBush = this.defaultView.context.rBushRoot;
        var rBushNodes = rBush.search({ minX, minY, maxX, maxY: maxY2 });
        var hitTestList = [];
        rBushNodes.forEach(function(_a) {
          var displayObject = _a.displayObject;
          var _b = displayObject.parsedStyle.pointerEvents, pointerEvents = _b === void 0 ? "auto" : _b;
          var isVisibilityAffected = [
            "auto",
            "visiblepainted",
            "visiblefill",
            "visiblestroke",
            "visible"
          ].includes(pointerEvents);
          if ((!isVisibilityAffected || isVisibilityAffected && displayObject.isVisible()) && !displayObject.isCulled() && displayObject.isInteractive()) {
            hitTestList.push(displayObject);
          }
        });
        hitTestList.sort(function(a3, b) {
          return b.sortable.renderOrder - a3.sortable.renderOrder;
        });
        return hitTestList;
      };
      Document3.prototype.elementFromPointSync = function(x3, y3) {
        var _a = this.defaultView.canvas2Viewport({
          x: x3,
          y: y3
        }), viewportX = _a.x, viewportY = _a.y;
        var _b = this.defaultView.getConfig(), width = _b.width, height = _b.height;
        if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
          return null;
        }
        var _c = this.defaultView.viewport2Client({
          x: viewportX,
          y: viewportY
        }), clientX = _c.x, clientY = _c.y;
        var picked = this.defaultView.getRenderingService().hooks.pickSync.call({
          topmost: true,
          position: {
            x: x3,
            y: y3,
            viewportX,
            viewportY,
            clientX,
            clientY
          },
          picked: []
        }).picked;
        return picked && picked[0] || this.documentElement;
      };
      Document3.prototype.elementFromPoint = function(x3, y3) {
        return __awaiter(this, void 0, void 0, function() {
          var _a, viewportX, viewportY, _b, width, height, _c, clientX, clientY, picked;
          return __generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                _a = this.defaultView.canvas2Viewport({
                  x: x3,
                  y: y3
                }), viewportX = _a.x, viewportY = _a.y;
                _b = this.defaultView.getConfig(), width = _b.width, height = _b.height;
                if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
                  return [2, null];
                }
                _c = this.defaultView.viewport2Client({
                  x: viewportX,
                  y: viewportY
                }), clientX = _c.x, clientY = _c.y;
                return [4, this.defaultView.getRenderingService().hooks.pick.promise({
                  topmost: true,
                  position: {
                    x: x3,
                    y: y3,
                    viewportX,
                    viewportY,
                    clientX,
                    clientY
                  },
                  picked: []
                })];
              case 1:
                picked = _d.sent().picked;
                return [2, picked && picked[0] || this.documentElement];
            }
          });
        });
      };
      Document3.prototype.elementsFromPointSync = function(x3, y3) {
        var _a = this.defaultView.canvas2Viewport({
          x: x3,
          y: y3
        }), viewportX = _a.x, viewportY = _a.y;
        var _b = this.defaultView.getConfig(), width = _b.width, height = _b.height;
        if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
          return [];
        }
        var _c = this.defaultView.viewport2Client({
          x: viewportX,
          y: viewportY
        }), clientX = _c.x, clientY = _c.y;
        var picked = this.defaultView.getRenderingService().hooks.pickSync.call({
          topmost: false,
          position: {
            x: x3,
            y: y3,
            viewportX,
            viewportY,
            clientX,
            clientY
          },
          picked: []
        }).picked;
        if (picked[picked.length - 1] !== this.documentElement) {
          picked.push(this.documentElement);
        }
        return picked;
      };
      Document3.prototype.elementsFromPoint = function(x3, y3) {
        return __awaiter(this, void 0, void 0, function() {
          var _a, viewportX, viewportY, _b, width, height, _c, clientX, clientY, picked;
          return __generator(this, function(_d) {
            switch (_d.label) {
              case 0:
                _a = this.defaultView.canvas2Viewport({
                  x: x3,
                  y: y3
                }), viewportX = _a.x, viewportY = _a.y;
                _b = this.defaultView.getConfig(), width = _b.width, height = _b.height;
                if (viewportX < 0 || viewportY < 0 || viewportX > width || viewportY > height) {
                  return [2, []];
                }
                _c = this.defaultView.viewport2Client({
                  x: viewportX,
                  y: viewportY
                }), clientX = _c.x, clientY = _c.y;
                return [4, this.defaultView.getRenderingService().hooks.pick.promise({
                  topmost: false,
                  position: {
                    x: x3,
                    y: y3,
                    viewportX,
                    viewportY,
                    clientX,
                    clientY
                  },
                  picked: []
                })];
              case 1:
                picked = _d.sent().picked;
                if (picked[picked.length - 1] !== this.documentElement) {
                  picked.push(this.documentElement);
                }
                return [2, picked];
            }
          });
        });
      };
      Document3.prototype.appendChild = function(newChild, index4) {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      };
      Document3.prototype.insertBefore = function(newChild, refChild) {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      };
      Document3.prototype.removeChild = function(oldChild, destroy3) {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      };
      Document3.prototype.replaceChild = function(newChild, oldChild, destroy3) {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      };
      Document3.prototype.append = function() {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      };
      Document3.prototype.prepend = function() {
        throw new Error(ERROR_MSG_USE_DOCUMENT_ELEMENT);
      };
      Document3.prototype.getElementById = function(id4) {
        return this.documentElement.getElementById(id4);
      };
      Document3.prototype.getElementsByName = function(name2) {
        return this.documentElement.getElementsByName(name2);
      };
      Document3.prototype.getElementsByTagName = function(tagName) {
        return this.documentElement.getElementsByTagName(tagName);
      };
      Document3.prototype.getElementsByClassName = function(className2) {
        return this.documentElement.getElementsByClassName(className2);
      };
      Document3.prototype.querySelector = function(selectors) {
        return this.documentElement.querySelector(selectors);
      };
      Document3.prototype.querySelectorAll = function(selectors) {
        return this.documentElement.querySelectorAll(selectors);
      };
      Document3.prototype.find = function(filter2) {
        return this.documentElement.find(filter2);
      };
      Document3.prototype.findAll = function(filter2) {
        return this.documentElement.findAll(filter2);
      };
      return Document3;
    }(Node2)
  );
  var CullingPlugin = (
    /** @class */
    function() {
      function CullingPlugin2(strategies) {
        this.strategies = strategies;
      }
      CullingPlugin2.prototype.apply = function(context) {
        var camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext;
        var strategies = this.strategies;
        renderingService.hooks.cull.tap(CullingPlugin2.tag, function(object) {
          if (object) {
            var cullable = object.cullable;
            if (strategies.length === 0) {
              cullable.visible = renderingContext.unculledEntities.indexOf(object.entity) > -1;
            } else {
              cullable.visible = strategies.every(function(strategy) {
                return strategy.isVisible(camera, object);
              });
            }
            if (!object.isCulled() && object.isVisible()) {
              return object;
            } else {
              object.dispatchEvent(new CustomEvent2(ElementEvent.CULLED));
            }
            return null;
          }
          return object;
        });
        renderingService.hooks.afterRender.tap(CullingPlugin2.tag, function(object) {
          object.cullable.visibilityPlaneMask = -1;
        });
      };
      CullingPlugin2.tag = "Culling";
      return CullingPlugin2;
    }()
  );
  var EventPlugin = (
    /** @class */
    function() {
      function EventPlugin2() {
        var _this = this;
        this.autoPreventDefault = false;
        this.rootPointerEvent = new FederatedPointerEvent(null);
        this.rootWheelEvent = new FederatedWheelEvent(null);
        this.onPointerMove = function(nativeEvent) {
          var e_1, _a;
          var _b, _c;
          var canvas = (_c = (_b = _this.context.renderingContext.root) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.defaultView;
          if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
            return;
          var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);
          try {
            for (var normalizedEvents_1 = __values(normalizedEvents), normalizedEvents_1_1 = normalizedEvents_1.next(); !normalizedEvents_1_1.done; normalizedEvents_1_1 = normalizedEvents_1.next()) {
              var normalizedEvent = normalizedEvents_1_1.value;
              var event_1 = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
              _this.context.eventService.mapEvent(event_1);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (normalizedEvents_1_1 && !normalizedEvents_1_1.done && (_a = normalizedEvents_1.return)) _a.call(normalizedEvents_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          _this.setCursor(_this.context.eventService.cursor);
        };
        this.onClick = function(nativeEvent) {
          var e_2, _a;
          var _b, _c;
          var canvas = (_c = (_b = _this.context.renderingContext.root) === null || _b === void 0 ? void 0 : _b.ownerDocument) === null || _c === void 0 ? void 0 : _c.defaultView;
          var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);
          try {
            for (var normalizedEvents_2 = __values(normalizedEvents), normalizedEvents_2_1 = normalizedEvents_2.next(); !normalizedEvents_2_1.done; normalizedEvents_2_1 = normalizedEvents_2.next()) {
              var normalizedEvent = normalizedEvents_2_1.value;
              var event_2 = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
              _this.context.eventService.mapEvent(event_2);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (normalizedEvents_2_1 && !normalizedEvents_2_1.done && (_a = normalizedEvents_2.return)) _a.call(normalizedEvents_2);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
          _this.setCursor(_this.context.eventService.cursor);
        };
      }
      EventPlugin2.prototype.apply = function(context) {
        var _this = this;
        this.context = context;
        var renderingService = context.renderingService;
        var canvas = this.context.renderingContext.root.ownerDocument.defaultView;
        this.context.eventService.setPickHandler(function(position) {
          var picked = _this.context.renderingService.hooks.pickSync.call({
            position,
            picked: [],
            topmost: true
            // we only concern the topmost element
          }).picked;
          return picked[0] || null;
        });
        renderingService.hooks.pointerWheel.tap(EventPlugin2.tag, function(nativeEvent) {
          var wheelEvent = _this.normalizeWheelEvent(nativeEvent);
          _this.context.eventService.mapEvent(wheelEvent);
        });
        renderingService.hooks.pointerDown.tap(EventPlugin2.tag, function(nativeEvent) {
          var e_3, _a;
          if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
            return;
          var events = _this.normalizeToPointerEvent(nativeEvent, canvas);
          if (_this.autoPreventDefault && events[0].isNormalized) {
            var cancelable = nativeEvent.cancelable || !("cancelable" in nativeEvent);
            if (cancelable) {
              nativeEvent.preventDefault();
            }
          }
          try {
            for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
              var event_3 = events_1_1.value;
              var federatedEvent = _this.bootstrapEvent(_this.rootPointerEvent, event_3, canvas, nativeEvent);
              _this.context.eventService.mapEvent(federatedEvent);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
          _this.setCursor(_this.context.eventService.cursor);
        });
        renderingService.hooks.pointerUp.tap(EventPlugin2.tag, function(nativeEvent) {
          var e_4, _a;
          if (canvas.supportsTouchEvents && nativeEvent.pointerType === "touch")
            return;
          var $element = _this.context.contextService.getDomElement();
          var isNativeEventFromCanvas = _this.context.eventService.isNativeEventFromCanvas($element, nativeEvent);
          var outside2 = !isNativeEventFromCanvas ? "outside" : "";
          var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);
          try {
            for (var normalizedEvents_3 = __values(normalizedEvents), normalizedEvents_3_1 = normalizedEvents_3.next(); !normalizedEvents_3_1.done; normalizedEvents_3_1 = normalizedEvents_3.next()) {
              var normalizedEvent = normalizedEvents_3_1.value;
              var event_4 = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
              event_4.type += outside2;
              _this.context.eventService.mapEvent(event_4);
            }
          } catch (e_4_1) {
            e_4 = { error: e_4_1 };
          } finally {
            try {
              if (normalizedEvents_3_1 && !normalizedEvents_3_1.done && (_a = normalizedEvents_3.return)) _a.call(normalizedEvents_3);
            } finally {
              if (e_4) throw e_4.error;
            }
          }
          _this.setCursor(_this.context.eventService.cursor);
        });
        renderingService.hooks.pointerMove.tap(EventPlugin2.tag, this.onPointerMove);
        renderingService.hooks.pointerOver.tap(EventPlugin2.tag, this.onPointerMove);
        renderingService.hooks.pointerOut.tap(EventPlugin2.tag, this.onPointerMove);
        renderingService.hooks.click.tap(EventPlugin2.tag, this.onClick);
        renderingService.hooks.pointerCancel.tap(EventPlugin2.tag, function(nativeEvent) {
          var e_5, _a;
          var normalizedEvents = _this.normalizeToPointerEvent(nativeEvent, canvas);
          try {
            for (var normalizedEvents_4 = __values(normalizedEvents), normalizedEvents_4_1 = normalizedEvents_4.next(); !normalizedEvents_4_1.done; normalizedEvents_4_1 = normalizedEvents_4.next()) {
              var normalizedEvent = normalizedEvents_4_1.value;
              var event_5 = _this.bootstrapEvent(_this.rootPointerEvent, normalizedEvent, canvas, nativeEvent);
              _this.context.eventService.mapEvent(event_5);
            }
          } catch (e_5_1) {
            e_5 = { error: e_5_1 };
          } finally {
            try {
              if (normalizedEvents_4_1 && !normalizedEvents_4_1.done && (_a = normalizedEvents_4.return)) _a.call(normalizedEvents_4);
            } finally {
              if (e_5) throw e_5.error;
            }
          }
          _this.setCursor(_this.context.eventService.cursor);
        });
      };
      EventPlugin2.prototype.bootstrapEvent = function(event, normalizedEvent, view, nativeEvent) {
        event.view = view;
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = normalizedEvent.pointerId;
        event.width = normalizedEvent.width;
        event.height = normalizedEvent.height;
        event.isPrimary = normalizedEvent.isPrimary;
        event.pointerType = normalizedEvent.pointerType;
        event.pressure = normalizedEvent.pressure;
        event.tangentialPressure = normalizedEvent.tangentialPressure;
        event.tiltX = normalizedEvent.tiltX;
        event.tiltY = normalizedEvent.tiltY;
        event.twist = normalizedEvent.twist;
        this.transferMouseData(event, normalizedEvent);
        var _a = this.context.eventService.client2Viewport({
          x: normalizedEvent.clientX,
          y: normalizedEvent.clientY
        }), x3 = _a.x, y3 = _a.y;
        event.viewport.x = x3;
        event.viewport.y = y3;
        var _b = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _b.x, canvasY = _b.y;
        event.canvas.x = canvasX;
        event.canvas.y = canvasY;
        event.global.copyFrom(event.canvas);
        event.offset.copyFrom(event.canvas);
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === "pointerleave") {
          event.type = "pointerout";
        }
        if (event.type.startsWith("mouse")) {
          event.type = event.type.replace("mouse", "pointer");
        }
        if (event.type.startsWith("touch")) {
          event.type = TOUCH_TO_POINTER[event.type] || event.type;
        }
        return event;
      };
      EventPlugin2.prototype.normalizeWheelEvent = function(nativeEvent) {
        var event = this.rootWheelEvent;
        this.transferMouseData(event, nativeEvent);
        event.deltaMode = nativeEvent.deltaMode;
        event.deltaX = nativeEvent.deltaX;
        event.deltaY = nativeEvent.deltaY;
        event.deltaZ = nativeEvent.deltaZ;
        var _a = this.context.eventService.client2Viewport({
          x: nativeEvent.clientX,
          y: nativeEvent.clientY
        }), x3 = _a.x, y3 = _a.y;
        event.viewport.x = x3;
        event.viewport.y = y3;
        var _b = this.context.eventService.viewport2Canvas(event.viewport), canvasX = _b.x, canvasY = _b.y;
        event.canvas.x = canvasX;
        event.canvas.y = canvasY;
        event.global.copyFrom(event.canvas);
        event.offset.copyFrom(event.canvas);
        event.nativeEvent = nativeEvent;
        event.type = nativeEvent.type;
        return event;
      };
      EventPlugin2.prototype.transferMouseData = function(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = clock.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.metaKey = nativeEvent.metaKey;
        event.shiftKey = nativeEvent.shiftKey;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.screen.x = nativeEvent.screenX;
        event.screen.y = nativeEvent.screenY;
        event.relatedTarget = null;
      };
      EventPlugin2.prototype.setCursor = function(cursor) {
        this.context.contextService.applyCursorStyle(cursor || this.context.config.cursor || "default");
      };
      EventPlugin2.prototype.normalizeToPointerEvent = function(event, canvas) {
        var normalizedEvents = [];
        if (canvas.isTouchEvent(event)) {
          for (var i = 0; i < event.changedTouches.length; i++) {
            var touch = event.changedTouches[i];
            if (is_undefined_default2(touch.button))
              touch.button = 0;
            if (is_undefined_default2(touch.buttons))
              touch.buttons = 1;
            if (is_undefined_default2(touch.isPrimary)) {
              touch.isPrimary = event.touches.length === 1 && event.type === "touchstart";
            }
            if (is_undefined_default2(touch.width))
              touch.width = touch.radiusX || 1;
            if (is_undefined_default2(touch.height))
              touch.height = touch.radiusY || 1;
            if (is_undefined_default2(touch.tiltX))
              touch.tiltX = 0;
            if (is_undefined_default2(touch.tiltY))
              touch.tiltY = 0;
            if (is_undefined_default2(touch.pointerType))
              touch.pointerType = "touch";
            if (is_undefined_default2(touch.pointerId))
              touch.pointerId = touch.identifier || 0;
            if (is_undefined_default2(touch.pressure))
              touch.pressure = touch.force || 0.5;
            if (is_undefined_default2(touch.twist))
              touch.twist = 0;
            if (is_undefined_default2(touch.tangentialPressure))
              touch.tangentialPressure = 0;
            touch.isNormalized = true;
            touch.type = event.type;
            normalizedEvents.push(touch);
          }
        } else if (canvas.isMouseEvent(event)) {
          var tempEvent = event;
          if (is_undefined_default2(tempEvent.isPrimary))
            tempEvent.isPrimary = true;
          if (is_undefined_default2(tempEvent.width))
            tempEvent.width = 1;
          if (is_undefined_default2(tempEvent.height))
            tempEvent.height = 1;
          if (is_undefined_default2(tempEvent.tiltX))
            tempEvent.tiltX = 0;
          if (is_undefined_default2(tempEvent.tiltY))
            tempEvent.tiltY = 0;
          if (is_undefined_default2(tempEvent.pointerType))
            tempEvent.pointerType = "mouse";
          if (is_undefined_default2(tempEvent.pointerId))
            tempEvent.pointerId = MOUSE_POINTER_ID;
          if (is_undefined_default2(tempEvent.pressure))
            tempEvent.pressure = 0.5;
          if (is_undefined_default2(tempEvent.twist))
            tempEvent.twist = 0;
          if (is_undefined_default2(tempEvent.tangentialPressure))
            tempEvent.tangentialPressure = 0;
          tempEvent.isNormalized = true;
          normalizedEvents.push(tempEvent);
        } else {
          normalizedEvents.push(event);
        }
        return normalizedEvents;
      };
      EventPlugin2.tag = "Event";
      return EventPlugin2;
    }()
  );
  var shape2D = [
    Shape.CIRCLE,
    Shape.ELLIPSE,
    Shape.IMAGE,
    Shape.RECT,
    Shape.LINE,
    Shape.POLYLINE,
    Shape.POLYGON,
    Shape.TEXT,
    Shape.PATH,
    Shape.HTML
  ];
  var FrustumCullingStrategy = (
    /** @class */
    function() {
      function FrustumCullingStrategy2() {
      }
      FrustumCullingStrategy2.prototype.isVisible = function(camera, object) {
        var _a, _b;
        var cullable = object.cullable;
        if (!cullable.enable) {
          return true;
        }
        var renderBounds = object.getRenderBounds();
        if (AABB.isEmpty(renderBounds)) {
          return false;
        }
        var frustum2 = camera.getFrustum();
        var parentVisibilityPlaneMask = (_b = (_a = object.parentNode) === null || _a === void 0 ? void 0 : _a.cullable) === null || _b === void 0 ? void 0 : _b.visibilityPlaneMask;
        cullable.visibilityPlaneMask = this.computeVisibilityWithPlaneMask(object, renderBounds, parentVisibilityPlaneMask || Mask.INDETERMINATE, frustum2.planes);
        cullable.visible = cullable.visibilityPlaneMask !== Mask.OUTSIDE;
        return cullable.visible;
      };
      FrustumCullingStrategy2.prototype.computeVisibilityWithPlaneMask = function(object, aabb, parentPlaneMask, planes) {
        if (parentPlaneMask === Mask.OUTSIDE || parentPlaneMask === Mask.INSIDE) {
          return parentPlaneMask;
        }
        var mask = Mask.INSIDE;
        var isShape2D = shape2D.indexOf(object.nodeName) > -1;
        for (var k = 0, len5 = planes.length; k < len5; ++k) {
          var flag = 1 << k;
          if ((parentPlaneMask & flag) === 0) {
            continue;
          }
          if (isShape2D && (k === 4 || k === 5)) {
            continue;
          }
          var _a = planes[k], normal = _a.normal, distance8 = _a.distance;
          if (vec3_exports.dot(normal, aabb.getPositiveFarPoint(planes[k])) + distance8 < 0) {
            return Mask.OUTSIDE;
          }
          if (vec3_exports.dot(normal, aabb.getNegativeFarPoint(planes[k])) + distance8 < 0) {
            mask |= flag;
          }
        }
        return mask;
      };
      return FrustumCullingStrategy2;
    }()
  );
  var PrepareRendererPlugin = (
    /** @class */
    function() {
      function PrepareRendererPlugin2() {
        this.toSync = /* @__PURE__ */ new Set();
        this.isFirstTimeRendering = true;
        this.syncing = false;
        this.isFirstTimeRenderingFinished = false;
      }
      PrepareRendererPlugin2.prototype.apply = function(context) {
        var _this = this;
        var _a;
        var renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot;
        var canvas = renderingContext.root.ownerDocument.defaultView;
        this.rBush = rBushRoot;
        var handleAttributeChanged = function(e3) {
          var object = e3.target;
          object.renderable.dirty = true;
          renderingService.dirtify();
        };
        var handleBoundsChanged = function(e3) {
          var affectChildren = e3.detail.affectChildren;
          var object = e3.target;
          if (affectChildren) {
            object.forEach(function(node) {
              _this.toSync.add(node);
            });
          }
          var p2 = object;
          while (p2) {
            if (p2.renderable) {
              _this.toSync.add(p2);
            }
            p2 = p2.parentElement;
          }
          renderingService.dirtify();
        };
        var handleMounted = function(e3) {
          var object = e3.target;
          if (runtime.enableSizeAttenuation) {
            runtime.styleValueRegistry.updateSizeAttenuation(object, canvas.getCamera().getZoom());
          }
          if (runtime.enableCSSParsing) {
            runtime.styleValueRegistry.recalc(object);
          }
          runtime.sceneGraphService.dirtifyToRoot(object);
          renderingService.dirtify();
        };
        var handleUnmounted = function(e3) {
          var object = e3.target;
          var rBushNode = object.rBushNode;
          if (rBushNode.aabb) {
            _this.rBush.remove(rBushNode.aabb);
          }
          _this.toSync.delete(object);
          runtime.sceneGraphService.dirtifyToRoot(object);
          renderingService.dirtify();
        };
        renderingService.hooks.init.tap(PrepareRendererPlugin2.tag, function() {
          canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
          canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        });
        renderingService.hooks.destroy.tap(PrepareRendererPlugin2.tag, function() {
          canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
          canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
          _this.toSync.clear();
        });
        var ric = (_a = runtime.globalThis.requestIdleCallback) !== null && _a !== void 0 ? _a : raf.bind(runtime.globalThis);
        renderingService.hooks.endFrame.tap(PrepareRendererPlugin2.tag, function() {
          if (_this.isFirstTimeRendering) {
            _this.isFirstTimeRendering = false;
            _this.syncing = true;
            ric(function() {
              _this.syncRTree(true);
              _this.isFirstTimeRenderingFinished = true;
            });
          } else {
            _this.syncRTree();
          }
        });
      };
      PrepareRendererPlugin2.prototype.syncRTree = function(force) {
        var _this = this;
        if (force === void 0) {
          force = false;
        }
        if (!force && (this.syncing || this.toSync.size === 0)) {
          return;
        }
        this.syncing = true;
        var bulk = [];
        Array.from(this.toSync).filter(function(object) {
          return object.isConnected;
        }).forEach(function(node) {
          var rBushNode = node.rBushNode;
          if (rBushNode && rBushNode.aabb) {
            _this.rBush.remove(rBushNode.aabb);
          }
          var renderBounds = node.getRenderBounds();
          if (renderBounds) {
            var renderable = node.renderable;
            if (force) {
              if (!renderable.dirtyRenderBounds) {
                renderable.dirtyRenderBounds = new AABB();
              }
              renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
            }
            var _a = __read(renderBounds.getMin(), 2), minX = _a[0], minY = _a[1];
            var _b = __read(renderBounds.getMax(), 2), maxX = _b[0], maxY2 = _b[1];
            if (!rBushNode.aabb) {
              rBushNode.aabb = {};
            }
            rBushNode.aabb.displayObject = node;
            rBushNode.aabb.minX = minX;
            rBushNode.aabb.minY = minY;
            rBushNode.aabb.maxX = maxX;
            rBushNode.aabb.maxY = maxY2;
          }
          if (rBushNode.aabb) {
            if (!isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.maxX) && !isNaN(rBushNode.aabb.minX) && !isNaN(rBushNode.aabb.minY)) {
              bulk.push(rBushNode.aabb);
            }
          }
        });
        this.rBush.load(bulk);
        bulk.length = 0;
        this.toSync.clear();
        this.syncing = false;
      };
      PrepareRendererPlugin2.tag = "Prepare";
      return PrepareRendererPlugin2;
    }()
  );
  var CanvasEvent;
  (function(CanvasEvent2) {
    CanvasEvent2["READY"] = "ready";
    CanvasEvent2["BEFORE_RENDER"] = "beforerender";
    CanvasEvent2["RERENDER"] = "rerender";
    CanvasEvent2["AFTER_RENDER"] = "afterrender";
    CanvasEvent2["BEFORE_DESTROY"] = "beforedestroy";
    CanvasEvent2["AFTER_DESTROY"] = "afterdestroy";
    CanvasEvent2["RESIZE"] = "resize";
    CanvasEvent2["DIRTY_RECTANGLE"] = "dirtyrectangle";
    CanvasEvent2["RENDERER_CHANGED"] = "rendererchanged";
  })(CanvasEvent || (CanvasEvent = {}));
  var DEFAULT_CAMERA_Z = 500;
  var DEFAULT_CAMERA_NEAR = 0.1;
  var DEFAULT_CAMERA_FAR = 1e3;
  var mountedEvent = new CustomEvent2(ElementEvent.MOUNTED);
  var unmountedEvent = new CustomEvent2(ElementEvent.UNMOUNTED);
  var beforeRenderEvent = new CustomEvent2(CanvasEvent.BEFORE_RENDER);
  var rerenderEvent = new CustomEvent2(CanvasEvent.RERENDER);
  var afterRenderEvent = new CustomEvent2(CanvasEvent.AFTER_RENDER);
  var Canvas = (
    /** @class */
    function(_super) {
      __extends(Canvas3, _super);
      function Canvas3(config2) {
        var _this = _super.call(this) || this;
        _this.Element = DisplayObject;
        _this.inited = false;
        _this.context = {};
        _this.document = new Document2();
        _this.document.defaultView = _this;
        _this.customElements = new CustomElementRegistry();
        var container = config2.container, canvas = config2.canvas, offscreenCanvas = config2.offscreenCanvas, width = config2.width, height = config2.height, devicePixelRatio = config2.devicePixelRatio, renderer = config2.renderer, background = config2.background, cursor = config2.cursor, document2 = config2.document, requestAnimationFrame2 = config2.requestAnimationFrame, cancelAnimationFrame2 = config2.cancelAnimationFrame, createImage = config2.createImage, supportsPointerEvents = config2.supportsPointerEvents, supportsTouchEvents = config2.supportsTouchEvents, supportsCSSTransform = config2.supportsCSSTransform, supportsMutipleCanvasesInOneContainer = config2.supportsMutipleCanvasesInOneContainer, useNativeClickEvent = config2.useNativeClickEvent, alwaysTriggerPointerEventOnCanvas = config2.alwaysTriggerPointerEventOnCanvas, isTouchEvent = config2.isTouchEvent, isMouseEvent = config2.isMouseEvent;
        if (!supportsMutipleCanvasesInOneContainer) {
          cleanExistedCanvas(container, _this);
        }
        var canvasWidth = width;
        var canvasHeight = height;
        var dpr = devicePixelRatio;
        if (canvas) {
          dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
          dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
          canvasWidth = width || getWidth(canvas) || canvas.width / dpr;
          canvasHeight = height || getHeight(canvas) || canvas.height / dpr;
        }
        if (offscreenCanvas) {
          runtime.offscreenCanvas = offscreenCanvas;
        }
        _this.devicePixelRatio = dpr;
        _this.requestAnimationFrame = requestAnimationFrame2 !== null && requestAnimationFrame2 !== void 0 ? requestAnimationFrame2 : raf.bind(runtime.globalThis);
        _this.cancelAnimationFrame = cancelAnimationFrame2 !== null && cancelAnimationFrame2 !== void 0 ? cancelAnimationFrame2 : caf.bind(runtime.globalThis);
        _this.supportsTouchEvents = supportsTouchEvents !== null && supportsTouchEvents !== void 0 ? supportsTouchEvents : "ontouchstart" in runtime.globalThis;
        _this.supportsPointerEvents = supportsPointerEvents !== null && supportsPointerEvents !== void 0 ? supportsPointerEvents : !!runtime.globalThis.PointerEvent;
        _this.isTouchEvent = isTouchEvent !== null && isTouchEvent !== void 0 ? isTouchEvent : function(event) {
          return _this.supportsTouchEvents && event instanceof runtime.globalThis.TouchEvent;
        };
        _this.isMouseEvent = isMouseEvent !== null && isMouseEvent !== void 0 ? isMouseEvent : function(event) {
          return !runtime.globalThis.MouseEvent || event instanceof runtime.globalThis.MouseEvent && (!_this.supportsPointerEvents || !(event instanceof runtime.globalThis.PointerEvent));
        };
        _this.initRenderingContext({
          container,
          canvas,
          width: canvasWidth,
          height: canvasHeight,
          renderer,
          offscreenCanvas,
          devicePixelRatio: dpr,
          cursor: cursor || "default",
          background: background || "transparent",
          createImage,
          document: document2,
          supportsCSSTransform,
          useNativeClickEvent,
          alwaysTriggerPointerEventOnCanvas
        });
        _this.initDefaultCamera(canvasWidth, canvasHeight, renderer.clipSpaceNearZ);
        _this.initRenderer(renderer, true);
        return _this;
      }
      Canvas3.prototype.initRenderingContext = function(mergedConfig) {
        this.context.config = mergedConfig;
        this.context.renderingContext = {
          /**
           * the root node in scene graph
           */
          root: this.document.documentElement,
          renderListCurrentFrame: [],
          unculledEntities: [],
          renderReasons: /* @__PURE__ */ new Set(),
          force: false,
          dirty: false
        };
      };
      Canvas3.prototype.initDefaultCamera = function(width, height, clipSpaceNearZ) {
        var _this = this;
        var camera = new runtime.CameraContribution();
        camera.clipSpaceNearZ = clipSpaceNearZ;
        camera.setType(CameraType.EXPLORING, CameraTrackingMode.DEFAULT).setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0).setOrthographic(width / -2, width / 2, height / 2, height / -2, DEFAULT_CAMERA_NEAR, DEFAULT_CAMERA_FAR);
        camera.canvas = this;
        camera.eventEmitter.on(CameraEvent.UPDATED, function() {
          _this.context.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
          if (runtime.enableSizeAttenuation && _this.getConfig().renderer.getConfig().enableSizeAttenuation) {
            _this.updateSizeAttenuation();
          }
        });
        this.context.camera = camera;
      };
      Canvas3.prototype.updateSizeAttenuation = function() {
        var zoom = this.getCamera().getZoom();
        this.document.documentElement.forEach(function(node) {
          runtime.styleValueRegistry.updateSizeAttenuation(node, zoom);
        });
      };
      Canvas3.prototype.getConfig = function() {
        return this.context.config;
      };
      Canvas3.prototype.getRoot = function() {
        return this.document.documentElement;
      };
      Canvas3.prototype.getCamera = function() {
        return this.context.camera;
      };
      Canvas3.prototype.getContextService = function() {
        return this.context.contextService;
      };
      Canvas3.prototype.getEventService = function() {
        return this.context.eventService;
      };
      Canvas3.prototype.getRenderingService = function() {
        return this.context.renderingService;
      };
      Canvas3.prototype.getRenderingContext = function() {
        return this.context.renderingContext;
      };
      Canvas3.prototype.getStats = function() {
        return this.getRenderingService().getStats();
      };
      Object.defineProperty(Canvas3.prototype, "ready", {
        // /**
        //  * @see https://developer.mozilla.org/zh-CN/docs/Web/API/Window/getComputedStyle
        //  */
        // getComputedStyle(node: DisplayObject) {
        //   return node.computedStyle;
        // }
        get: function() {
          var _this = this;
          if (!this.readyPromise) {
            this.readyPromise = new Promise(function(resolve) {
              _this.resolveReadyPromise = function() {
                resolve(_this);
              };
            });
            if (this.inited) {
              this.resolveReadyPromise();
            }
          }
          return this.readyPromise;
        },
        enumerable: false,
        configurable: true
      });
      Canvas3.prototype.destroy = function(cleanUp, skipTriggerEvent) {
        if (cleanUp === void 0) {
          cleanUp = true;
        }
        if (skipTriggerEvent === void 0) {
          skipTriggerEvent = false;
        }
        if (!skipTriggerEvent) {
          this.dispatchEvent(new CustomEvent2(CanvasEvent.BEFORE_DESTROY));
        }
        if (this.frameId) {
          var cancelRAF = this.getConfig().cancelAnimationFrame || cancelAnimationFrame;
          cancelRAF(this.frameId);
        }
        var root2 = this.getRoot();
        this.unmountChildren(root2);
        if (cleanUp) {
          this.document.destroy();
          this.getEventService().destroy();
        }
        this.getRenderingService().destroy();
        this.getContextService().destroy();
        if (cleanUp && this.context.rBushRoot) {
          this.context.rBushRoot.clear();
          this.context.rBushRoot = null;
          this.context.renderingContext.root = null;
        }
        if (!skipTriggerEvent) {
          this.dispatchEvent(new CustomEvent2(CanvasEvent.AFTER_DESTROY));
        }
      };
      Canvas3.prototype.changeSize = function(width, height) {
        this.resize(width, height);
      };
      Canvas3.prototype.resize = function(width, height) {
        var canvasConfig = this.context.config;
        canvasConfig.width = width;
        canvasConfig.height = height;
        this.getContextService().resize(width, height);
        var camera = this.context.camera;
        var projectionMode = camera.getProjectionMode();
        camera.setPosition(width / 2, height / 2, DEFAULT_CAMERA_Z).setFocalPoint(width / 2, height / 2, 0);
        if (projectionMode === CameraProjectionMode.ORTHOGRAPHIC) {
          camera.setOrthographic(width / -2, width / 2, height / 2, height / -2, camera.getNear(), camera.getFar());
        } else {
          camera.setAspect(width / height);
        }
        this.dispatchEvent(new CustomEvent2(CanvasEvent.RESIZE, { width, height }));
      };
      Canvas3.prototype.appendChild = function(child, index4) {
        return this.document.documentElement.appendChild(child, index4);
      };
      Canvas3.prototype.insertBefore = function(newChild, refChild) {
        return this.document.documentElement.insertBefore(newChild, refChild);
      };
      Canvas3.prototype.removeChild = function(child) {
        return this.document.documentElement.removeChild(child);
      };
      Canvas3.prototype.removeChildren = function() {
        this.document.documentElement.removeChildren();
      };
      Canvas3.prototype.destroyChildren = function() {
        this.document.documentElement.destroyChildren();
      };
      Canvas3.prototype.render = function(frame2) {
        var _this = this;
        if (frame2) {
          beforeRenderEvent.detail = frame2;
          afterRenderEvent.detail = frame2;
        }
        this.dispatchEvent(beforeRenderEvent);
        var renderingService = this.getRenderingService();
        renderingService.render(this.getConfig(), frame2, function() {
          _this.dispatchEvent(rerenderEvent);
        });
        this.dispatchEvent(afterRenderEvent);
      };
      Canvas3.prototype.run = function() {
        var _this = this;
        var tick3 = function(time, frame2) {
          _this.render(frame2);
          _this.frameId = _this.requestAnimationFrame(tick3);
        };
        tick3();
      };
      Canvas3.prototype.initRenderer = function(renderer, firstContentfullPaint) {
        var _this = this;
        if (firstContentfullPaint === void 0) {
          firstContentfullPaint = false;
        }
        if (!renderer) {
          throw new Error("Renderer is required.");
        }
        this.inited = false;
        this.readyPromise = void 0;
        this.context.rBushRoot = new RBush();
        this.context.renderingPlugins = [];
        this.context.renderingPlugins.push(
          new EventPlugin(),
          new PrepareRendererPlugin(),
          // new DirtyCheckPlugin(),
          new CullingPlugin([new FrustumCullingStrategy()])
        );
        this.loadRendererContainerModule(renderer);
        this.context.contextService = new this.context.ContextService(__assign(__assign({}, runtime), this.context));
        this.context.renderingService = new RenderingService(runtime, this.context);
        this.context.eventService = new EventService(runtime, this.context);
        this.context.eventService.init();
        if (this.context.contextService.init) {
          this.context.contextService.init();
          this.initRenderingService(renderer, firstContentfullPaint, true);
        } else {
          this.context.contextService.initAsync().then(function() {
            _this.initRenderingService(renderer, firstContentfullPaint);
          });
        }
      };
      Canvas3.prototype.initRenderingService = function(renderer, firstContentfullPaint, async) {
        var _this = this;
        if (firstContentfullPaint === void 0) {
          firstContentfullPaint = false;
        }
        if (async === void 0) {
          async = false;
        }
        this.context.renderingService.init(function() {
          _this.inited = true;
          if (firstContentfullPaint) {
            if (async) {
              _this.requestAnimationFrame(function() {
                _this.dispatchEvent(new CustomEvent2(CanvasEvent.READY));
              });
            } else {
              _this.dispatchEvent(new CustomEvent2(CanvasEvent.READY));
            }
          } else {
            _this.dispatchEvent(new CustomEvent2(CanvasEvent.RENDERER_CHANGED));
          }
          if (_this.readyPromise) {
            _this.resolveReadyPromise();
          }
          if (!firstContentfullPaint) {
            _this.getRoot().forEach(function(node) {
              var renderable = node.renderable;
              if (renderable) {
                renderable.renderBoundsDirty = true;
                renderable.boundsDirty = true;
                renderable.dirty = true;
              }
            });
          }
          _this.mountChildren(_this.getRoot());
          if (renderer.getConfig().enableAutoRendering) {
            _this.run();
          }
        });
      };
      Canvas3.prototype.loadRendererContainerModule = function(renderer) {
        var _this = this;
        var plugins2 = renderer.getPlugins();
        plugins2.forEach(function(plugin) {
          plugin.context = _this.context;
          plugin.init(runtime);
        });
      };
      Canvas3.prototype.setRenderer = function(renderer) {
        var canvasConfig = this.getConfig();
        if (canvasConfig.renderer === renderer) {
          return;
        }
        var oldRenderer = canvasConfig.renderer;
        canvasConfig.renderer = renderer;
        this.destroy(false, true);
        __spreadArray([], __read(oldRenderer === null || oldRenderer === void 0 ? void 0 : oldRenderer.getPlugins()), false).reverse().forEach(function(plugin) {
          plugin.destroy(runtime);
        });
        this.initRenderer(renderer);
      };
      Canvas3.prototype.setCursor = function(cursor) {
        var canvasConfig = this.getConfig();
        canvasConfig.cursor = cursor;
        this.getContextService().applyCursorStyle(cursor);
      };
      Canvas3.prototype.unmountChildren = function(parent) {
        var _this = this;
        parent.childNodes.forEach(function(child) {
          _this.unmountChildren(child);
        });
        if (this.inited) {
          if (parent.isMutationObserved) {
            parent.dispatchEvent(unmountedEvent);
          } else {
            unmountedEvent.target = parent;
            this.dispatchEvent(unmountedEvent, true);
          }
          if (parent !== this.document.documentElement) {
            parent.ownerDocument = null;
          }
          parent.isConnected = false;
        }
        if (parent.isCustomElement) {
          if (parent.disconnectedCallback) {
            parent.disconnectedCallback();
          }
        }
      };
      Canvas3.prototype.mountChildren = function(parent) {
        var _this = this;
        if (this.inited) {
          if (!parent.isConnected) {
            parent.ownerDocument = this.document;
            parent.isConnected = true;
            if (parent.isMutationObserved) {
              parent.dispatchEvent(mountedEvent);
            } else {
              mountedEvent.target = parent;
              this.dispatchEvent(mountedEvent, true);
            }
          }
        } else {
          console.warn("[g]: You are trying to call `canvas.appendChild` before canvas' initialization finished. You can either await `canvas.ready` or listen to `CanvasEvent.READY` manually.", "appended child: ", parent.nodeName);
        }
        parent.childNodes.forEach(function(child) {
          _this.mountChildren(child);
        });
        if (parent.isCustomElement) {
          if (parent.connectedCallback) {
            parent.connectedCallback();
          }
        }
      };
      Canvas3.prototype.client2Viewport = function(client) {
        return this.getEventService().client2Viewport(client);
      };
      Canvas3.prototype.viewport2Client = function(canvas) {
        return this.getEventService().viewport2Client(canvas);
      };
      Canvas3.prototype.viewport2Canvas = function(viewport) {
        return this.getEventService().viewport2Canvas(viewport);
      };
      Canvas3.prototype.canvas2Viewport = function(canvas) {
        return this.getEventService().canvas2Viewport(canvas);
      };
      Canvas3.prototype.getPointByClient = function(clientX, clientY) {
        return this.client2Viewport({ x: clientX, y: clientY });
      };
      Canvas3.prototype.getClientByPoint = function(x3, y3) {
        return this.viewport2Client({ x: x3, y: y3 });
      };
      return Canvas3;
    }(EventTarget)
  );

  // ../../engine/rails_design/node_modules/@antv/g-camera-api/node_modules/@antv/util/esm/lodash/is-type.js
  var toString3 = {}.toString;
  var isType3 = function(value2, type) {
    return toString3.call(value2) === "[object " + type + "]";
  };
  var is_type_default3 = isType3;

  // ../../engine/rails_design/node_modules/@antv/g-camera-api/node_modules/@antv/util/esm/lodash/is-string.js
  var is_string_default3 = function(str7) {
    return is_type_default3(str7, "String");
  };

  // ../../engine/rails_design/node_modules/@antv/g-camera-api/node_modules/@antv/util/esm/lodash/is-number.js
  var isNumber4 = function(value2) {
    return is_type_default3(value2, "Number");
  };
  var is_number_default3 = isNumber4;

  // ../../engine/rails_design/node_modules/@antv/g-camera-api/dist/index.esm.js
  var AdvancedCamera = (
    /** @class */
    function(_super) {
      __extends(AdvancedCamera2, _super);
      function AdvancedCamera2() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this.landmarks = [];
        return _this;
      }
      AdvancedCamera2.prototype.rotate = function(azimuth, elevation, roll) {
        this.relElevation = getAngle2(elevation);
        this.relAzimuth = getAngle2(azimuth);
        this.relRoll = getAngle2(roll);
        this.elevation += this.relElevation;
        this.azimuth += this.relAzimuth;
        this.roll += this.relRoll;
        if (this.type === CameraType.EXPLORING) {
          var rotX = quat_exports.setAxisAngle(quat_exports.create(), [1, 0, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relElevation));
          var rotY = quat_exports.setAxisAngle(quat_exports.create(), [0, 1, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relAzimuth));
          var rotZ = quat_exports.setAxisAngle(quat_exports.create(), [0, 0, 1], deg2rad(this.relRoll));
          var rotQ = quat_exports.multiply(quat_exports.create(), rotY, rotX);
          rotQ = quat_exports.multiply(quat_exports.create(), rotQ, rotZ);
          var rotMatrix = mat4_exports.fromQuat(mat4_exports.create(), rotQ);
          mat4_exports.translate(this.matrix, this.matrix, [0, 0, -this.distance]);
          mat4_exports.multiply(this.matrix, this.matrix, rotMatrix);
          mat4_exports.translate(this.matrix, this.matrix, [0, 0, this.distance]);
        } else {
          if (Math.abs(this.elevation) > 90) {
            return this;
          }
          this.computeMatrix();
        }
        this._getAxes();
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getPosition();
        } else if (this.type === CameraType.TRACKING) {
          this._getFocalPoint();
        }
        this._update();
        return this;
      };
      AdvancedCamera2.prototype.pan = function(tx, ty) {
        var coords = createVec3(tx, ty, 0);
        var pos = vec3_exports.clone(this.position);
        vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.right, coords[0]));
        vec3_exports.add(pos, pos, vec3_exports.scale(vec3_exports.create(), this.up, coords[1]));
        this._setPosition(pos);
        this.triggerUpdate();
        return this;
      };
      AdvancedCamera2.prototype.dolly = function(value2) {
        var n2 = this.forward;
        var pos = vec3_exports.clone(this.position);
        var step2 = value2 * this.dollyingStep;
        var updatedDistance = this.distance + value2 * this.dollyingStep;
        step2 = Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) - this.distance;
        pos[0] += step2 * n2[0];
        pos[1] += step2 * n2[1];
        pos[2] += step2 * n2[2];
        this._setPosition(pos);
        if (this.type === CameraType.ORBITING || this.type === CameraType.EXPLORING) {
          this._getDistance();
        } else if (this.type === CameraType.TRACKING) {
          vec3_exports.add(this.focalPoint, pos, this.distanceVector);
        }
        this.triggerUpdate();
        return this;
      };
      AdvancedCamera2.prototype.cancelLandmarkAnimation = function() {
        if (this.landmarkAnimationID !== void 0) {
          this.canvas.cancelAnimationFrame(this.landmarkAnimationID);
        }
      };
      AdvancedCamera2.prototype.createLandmark = function(name2, params) {
        var _a, _b, _c, _d;
        if (params === void 0) {
          params = {};
        }
        var _e = params.position, position = _e === void 0 ? this.position : _e, _f = params.focalPoint, focalPoint = _f === void 0 ? this.focalPoint : _f, roll = params.roll, zoom = params.zoom;
        var camera = new runtime.CameraContribution();
        camera.setType(this.type, void 0);
        camera.setPosition(position[0], (_a = position[1]) !== null && _a !== void 0 ? _a : this.position[1], (_b = position[2]) !== null && _b !== void 0 ? _b : this.position[2]);
        camera.setFocalPoint(focalPoint[0], (_c = focalPoint[1]) !== null && _c !== void 0 ? _c : this.focalPoint[1], (_d = focalPoint[2]) !== null && _d !== void 0 ? _d : this.focalPoint[2]);
        camera.setRoll(roll !== null && roll !== void 0 ? roll : this.roll);
        camera.setZoom(zoom !== null && zoom !== void 0 ? zoom : this.zoom);
        var landmark = {
          name: name2,
          matrix: mat4_exports.clone(camera.getWorldTransform()),
          right: vec3_exports.clone(camera.right),
          up: vec3_exports.clone(camera.up),
          forward: vec3_exports.clone(camera.forward),
          position: vec3_exports.clone(camera.getPosition()),
          focalPoint: vec3_exports.clone(camera.getFocalPoint()),
          distanceVector: vec3_exports.clone(camera.getDistanceVector()),
          distance: camera.getDistance(),
          dollyingStep: camera.getDollyingStep(),
          azimuth: camera.getAzimuth(),
          elevation: camera.getElevation(),
          roll: camera.getRoll(),
          relAzimuth: camera.relAzimuth,
          relElevation: camera.relElevation,
          relRoll: camera.relRoll,
          zoom: camera.getZoom()
        };
        this.landmarks.push(landmark);
        return landmark;
      };
      AdvancedCamera2.prototype.gotoLandmark = function(name2, options) {
        var _this = this;
        if (options === void 0) {
          options = {};
        }
        var landmark = is_string_default3(name2) ? this.landmarks.find(function(l2) {
          return l2.name === name2;
        }) : name2;
        if (landmark) {
          var _a = is_number_default3(options) ? { duration: options } : options, _b = _a.easing, easing = _b === void 0 ? "linear" : _b, _c = _a.duration, duration_1 = _c === void 0 ? 100 : _c, _d = _a.easingFunction, easingFunction = _d === void 0 ? void 0 : _d, _e = _a.onfinish, onfinish_1 = _e === void 0 ? void 0 : _e, _f = _a.onframe, onframe_1 = _f === void 0 ? void 0 : _f;
          var epsilon_1 = 0.01;
          this.cancelLandmarkAnimation();
          var destPosition_1 = landmark.position;
          var destFocalPoint_1 = landmark.focalPoint;
          var destZoom_1 = landmark.zoom;
          var destRoll_1 = landmark.roll;
          var easingFunc_1 = easingFunction || runtime.EasingFunction(easing);
          var timeStart_1;
          var end_1 = function() {
            _this.setFocalPoint(destFocalPoint_1);
            _this.setPosition(destPosition_1);
            _this.setRoll(destRoll_1);
            _this.setZoom(destZoom_1);
            _this.computeMatrix();
            _this.triggerUpdate();
            onfinish_1 === null || onfinish_1 === void 0 ? void 0 : onfinish_1();
          };
          if (duration_1 === 0)
            return end_1();
          var animate_1 = function(timestamp) {
            if (timeStart_1 === void 0) {
              timeStart_1 = timestamp;
            }
            var elapsed = timestamp - timeStart_1;
            if (elapsed >= duration_1) {
              end_1();
              return;
            }
            var t = easingFunc_1(elapsed / duration_1);
            var interFocalPoint = vec3_exports.create();
            var interPosition = vec3_exports.create();
            var interZoom = 1;
            var interRoll = 0;
            vec3_exports.lerp(interFocalPoint, _this.focalPoint, destFocalPoint_1, t);
            vec3_exports.lerp(interPosition, _this.position, destPosition_1, t);
            interRoll = _this.roll * (1 - t) + destRoll_1 * t;
            interZoom = _this.zoom * (1 - t) + destZoom_1 * t;
            _this.setFocalPoint(interFocalPoint);
            _this.setPosition(interPosition);
            _this.setRoll(interRoll);
            _this.setZoom(interZoom);
            var dist5 = vec3_exports.dist(interFocalPoint, destFocalPoint_1) + vec3_exports.dist(interPosition, destPosition_1);
            if (dist5 <= epsilon_1 && destZoom_1 == void 0 && destRoll_1 == void 0) {
              return end_1();
            }
            _this.computeMatrix();
            _this.triggerUpdate();
            if (elapsed < duration_1) {
              onframe_1 === null || onframe_1 === void 0 ? void 0 : onframe_1(t);
              _this.landmarkAnimationID = _this.canvas.requestAnimationFrame(animate_1);
            }
          };
          this.canvas.requestAnimationFrame(animate_1);
        }
      };
      return AdvancedCamera2;
    }(Camera)
  );
  runtime.CameraContribution = AdvancedCamera;

  // ../../engine/rails_design/node_modules/@antv/g-dom-mutation-observer-api/dist/index.esm.js
  var MutationRecord = (
    /** @class */
    function() {
      function MutationRecord2(type, target) {
        this.type = type;
        this.target = target;
        this.addedNodes = [];
        this.attributeName = null;
        this.attributeNamespace = null;
        this.nextSibling = null;
        this.oldValue = null;
        this.previousSibling = null;
        this.removedNodes = [];
      }
      MutationRecord2.copy = function(original) {
        var record = new MutationRecord2(original.type, original.target);
        record.addedNodes = original.addedNodes.slice();
        record.removedNodes = original.removedNodes.slice();
        record.previousSibling = original.previousSibling;
        record.nextSibling = original.nextSibling;
        record.attributeName = original.attributeName;
        record.attributeNamespace = original.attributeNamespace;
        record.oldValue = original.oldValue;
        return record;
      };
      return MutationRecord2;
    }()
  );
  var uidCounter = 0;
  var registrationsTable = /* @__PURE__ */ new WeakMap();
  var Registration = (
    /** @class */
    function() {
      function Registration2(observer, target, options) {
        this.observer = observer;
        this.target = target;
        this.options = options;
        this.transientObservedNodes = [];
      }
      Registration2.prototype.enqueue = function(record) {
        var records = this.observer.records;
        var length5 = records.length;
        if (records.length > 0) {
          var lastRecord = records[length5 - 1];
          var recordToReplaceLast = selectRecord(lastRecord, record);
          if (recordToReplaceLast) {
            records[length5 - 1] = recordToReplaceLast;
            return;
          }
        } else {
          scheduleCallback(this.observer);
        }
        records[length5] = record;
      };
      Registration2.prototype.addListeners = function() {
        this.addListeners_(this.target);
      };
      Registration2.prototype.addListeners_ = function(node) {
        var options = this.options;
        if (options.attributes)
          node.addEventListener(ElementEvent.ATTR_MODIFIED, this, true);
        if (options.childList)
          node.addEventListener(ElementEvent.INSERTED, this, true);
        if (options.childList || options.subtree)
          node.addEventListener(ElementEvent.REMOVED, this, true);
      };
      Registration2.prototype.removeListeners = function() {
        this.removeListeners_(this.target);
      };
      Registration2.prototype.removeListeners_ = function(node) {
        var options = this.options;
        if (options.attributes)
          node.removeEventListener(ElementEvent.ATTR_MODIFIED, this, true);
        if (options.childList)
          node.removeEventListener(ElementEvent.INSERTED, this, true);
        if (options.childList || options.subtree)
          node.removeEventListener(ElementEvent.REMOVED, this, true);
      };
      Registration2.prototype.removeTransientObservers = function() {
        var transientObservedNodes = this.transientObservedNodes;
        this.transientObservedNodes = [];
        transientObservedNodes.forEach(function(node) {
          this.removeListeners_(node);
          var registrations = registrationsTable.get(node);
          for (var i = 0; i < registrations.length; i++) {
            if (registrations[i] === this) {
              registrations.splice(i, 1);
              break;
            }
          }
        }, this);
      };
      Registration2.prototype.handleEvent = function(e3) {
        e3.stopImmediatePropagation();
        var record;
        var target;
        switch (e3.type) {
          case ElementEvent.ATTR_MODIFIED:
            var name_1 = e3.attrName;
            var namespace_1 = e3.relatedNode.namespaceURI;
            target = e3.target;
            record = getRecord("attributes", target);
            record.attributeName = name_1;
            record.attributeNamespace = namespace_1;
            var oldValue_1 = e3.attrChange === MutationEvent.ADDITION ? null : e3.prevValue;
            forEachAncestorAndObserverEnqueueRecord(target, function(options) {
              if (!options.attributes)
                return;
              if (options.attributeFilter && options.attributeFilter.length && options.attributeFilter.indexOf(name_1) === -1 && options.attributeFilter.indexOf(namespace_1) === -1) {
                return;
              }
              if (options.attributeOldValue)
                return getRecordWithOldValue(oldValue_1);
              return record;
            });
            break;
          case ElementEvent.REMOVED:
          case ElementEvent.INSERTED:
            target = e3.relatedNode;
            var changedNode = e3.target;
            var addedNodes = void 0;
            var removedNodes = void 0;
            if (e3.type === ElementEvent.INSERTED) {
              addedNodes = [changedNode];
              removedNodes = [];
            } else {
              addedNodes = [];
              removedNodes = [changedNode];
            }
            var previousSibling = changedNode.previousSibling;
            var nextSibling = changedNode.nextSibling;
            record = getRecord("childList", target);
            record.addedNodes = addedNodes;
            record.removedNodes = removedNodes;
            record.previousSibling = previousSibling;
            record.nextSibling = nextSibling;
            forEachAncestorAndObserverEnqueueRecord(target, function(options) {
              if (!options.childList)
                return;
              return record;
            });
        }
        clearRecords();
      };
      return Registration2;
    }()
  );
  var MutationObserver2 = (
    /** @class */
    function() {
      function MutationObserver3(callback) {
        this.callback = callback;
        this.nodes = [];
        this.records = [];
        this.uid = uidCounter++;
      }
      MutationObserver3.prototype.observe = function(target, options) {
        if (!options.childList && !options.attributes && !options.characterData || // 1.2
        options.attributeOldValue && !options.attributes || // 1.3
        options.attributeFilter && options.attributeFilter.length && !options.attributes || // 1.4
        options.characterDataOldValue && !options.characterData) {
          throw new SyntaxError();
        }
        var registrations = registrationsTable.get(target);
        if (!registrations)
          registrationsTable.set(target, registrations = []);
        var registration;
        for (var i = 0; i < registrations.length; i++) {
          if (registrations[i].observer === this) {
            registration = registrations[i];
            registration.removeListeners();
            registration.options = options;
            break;
          }
        }
        if (!registration) {
          registration = new Registration(this, target, options);
          registrations.push(registration);
          this.nodes.push(target);
        }
        registration.addListeners();
      };
      MutationObserver3.prototype.disconnect = function() {
        var _this = this;
        this.nodes.forEach(function(node) {
          var registrations = registrationsTable.get(node);
          for (var i = 0; i < registrations.length; i++) {
            var registration = registrations[i];
            if (registration.observer === _this) {
              registration.removeListeners();
              registrations.splice(i, 1);
              break;
            }
          }
        }, this);
        this.records = [];
      };
      MutationObserver3.prototype.takeRecords = function() {
        var copyOfRecords = this.records;
        this.records = [];
        return copyOfRecords;
      };
      return MutationObserver3;
    }()
  );
  var currentRecord;
  var recordWithOldValue;
  function getRecord(type, target) {
    return currentRecord = new MutationRecord(type, target);
  }
  function getRecordWithOldValue(oldValue) {
    if (recordWithOldValue)
      return recordWithOldValue;
    recordWithOldValue = MutationRecord.copy(currentRecord);
    recordWithOldValue.oldValue = oldValue;
    return recordWithOldValue;
  }
  function clearRecords() {
    currentRecord = recordWithOldValue = void 0;
  }
  function recordRepresentsCurrentMutation(record) {
    return record === recordWithOldValue || record === currentRecord;
  }
  function selectRecord(lastRecord, newRecord) {
    if (lastRecord === newRecord)
      return lastRecord;
    if (recordWithOldValue && recordRepresentsCurrentMutation(lastRecord))
      return recordWithOldValue;
    return null;
  }
  function removeTransientObserversFor(observer) {
    observer.nodes.forEach(function(node) {
      var registrations = registrationsTable.get(node);
      if (!registrations)
        return;
      registrations.forEach(function(registration) {
        if (registration.observer === observer)
          registration.removeTransientObservers();
      });
    });
  }
  function forEachAncestorAndObserverEnqueueRecord(target, callback) {
    for (var node = target; node; node = node.parentNode) {
      var registrations = registrationsTable.get(node);
      if (registrations) {
        for (var j = 0; j < registrations.length; j++) {
          var registration = registrations[j];
          var options = registration.options;
          if (node !== target && !options.subtree)
            continue;
          var record = callback(options);
          if (record)
            registration.enqueue(record);
        }
      }
    }
  }
  var isScheduled = false;
  var scheduledObservers = [];
  function scheduleCallback(observer) {
    scheduledObservers.push(observer);
    if (!isScheduled) {
      isScheduled = true;
      if (typeof runtime.globalThis !== "undefined") {
        runtime.globalThis.setTimeout(dispatchCallbacks);
      } else {
        dispatchCallbacks();
      }
    }
  }
  function dispatchCallbacks() {
    isScheduled = false;
    var observers = scheduledObservers;
    scheduledObservers = [];
    observers.sort(function(o1, o2) {
      return o1.uid - o2.uid;
    });
    var anyNonEmpty = false;
    observers.forEach(function(observer) {
      var queue = observer.takeRecords();
      removeTransientObserversFor(observer);
      if (queue.length) {
        observer.callback(queue, observer);
        anyNonEmpty = true;
      }
    });
    if (anyNonEmpty)
      dispatchCallbacks();
  }

  // ../../engine/rails_design/node_modules/@antv/g-web-animations-api/node_modules/@antv/util/esm/lodash/is-nil.js
  var isNil3 = function(value2) {
    return value2 === null || value2 === void 0;
  };
  var is_nil_default3 = isNil3;

  // ../../engine/rails_design/node_modules/@antv/g-web-animations-api/node_modules/@antv/util/esm/lodash/is-type.js
  var toString4 = {}.toString;
  var isType4 = function(value2, type) {
    return toString4.call(value2) === "[object " + type + "]";
  };
  var is_type_default4 = isType4;

  // ../../engine/rails_design/node_modules/@antv/g-web-animations-api/node_modules/@antv/util/esm/lodash/clamp.js
  var clamp2 = function(a3, min10, max10) {
    if (a3 < min10) {
      return min10;
    } else if (a3 > max10) {
      return max10;
    }
    return a3;
  };
  var clamp_default2 = clamp2;

  // ../../engine/rails_design/node_modules/@antv/g-web-animations-api/node_modules/@antv/util/esm/lodash/is-number.js
  var isNumber5 = function(value2) {
    return is_type_default4(value2, "Number");
  };
  var is_number_default4 = isNumber5;

  // ../../engine/rails_design/node_modules/@antv/g-web-animations-api/dist/index.esm.js
  var AnimationEvent = (
    /** @class */
    function(_super) {
      __extends(AnimationEvent2, _super);
      function AnimationEvent2(manager, target, currentTime, timelineTime) {
        var _this = _super.call(this, manager) || this;
        _this.currentTime = currentTime;
        _this.timelineTime = timelineTime;
        _this.target = target;
        _this.type = "finish";
        _this.bubbles = false;
        _this.currentTarget = target;
        _this.defaultPrevented = false;
        _this.eventPhase = _this.AT_TARGET;
        _this.timeStamp = Date.now();
        _this.currentTime = currentTime;
        _this.timelineTime = timelineTime;
        return _this;
      }
      return AnimationEvent2;
    }(FederatedEvent)
  );
  var sequenceNumber = 0;
  var Animation = (
    /** @class */
    function() {
      function Animation2(effect, timeline) {
        var _a;
        this.currentTimePending = false;
        this._idle = true;
        this._paused = false;
        this._finishedFlag = true;
        this._currentTime = 0;
        this._playbackRate = 1;
        this._inTimeline = true;
        this.effect = effect;
        effect.animation = this;
        this.timeline = timeline;
        this.id = "".concat(sequenceNumber++);
        this._inEffect = !!this.effect.update(0);
        this._totalDuration = Number((_a = this.effect) === null || _a === void 0 ? void 0 : _a.getComputedTiming().endTime);
        this._holdTime = 0;
        this._paused = false;
        this.oldPlayState = "idle";
        this.updatePromises();
      }
      Object.defineProperty(Animation2.prototype, "pending", {
        // animation: InternalAnimation | null;
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/pending
         */
        get: function() {
          return this._startTime === null && !this._paused && this.playbackRate !== 0 || this.currentTimePending;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Animation2.prototype, "playState", {
        get: function() {
          if (this._idle)
            return "idle";
          if (this._isFinished)
            return "finished";
          if (this._paused)
            return "paused";
          return "running";
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Animation2.prototype, "ready", {
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/ready
         * @example
          animation.pause();
          animation.ready.then(function() {
            // Displays 'running'
            alert(animation.playState);
          });
          animation.play();
         */
        get: function() {
          var _this = this;
          if (!this.readyPromise) {
            if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
              this.timeline.animationsWithPromises.push(this);
            }
            this.readyPromise = new Promise(function(resolve, reject) {
              _this.resolveReadyPromise = function() {
                resolve(_this);
              };
              _this.rejectReadyPromise = function() {
                reject(new Error());
              };
            });
            if (!this.pending) {
              this.resolveReadyPromise();
            }
          }
          return this.readyPromise;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Animation2.prototype, "finished", {
        /**
         * @see https://developer.mozilla.org/en-US/docs/Web/API/Animation/finished
         * @example
          Promise.all(
            elem.getAnimations().map(
              function(animation) {
                return animation.finished
              }
            )
          ).then(
            function() {
              return elem.remove();
            }
          );
         */
        get: function() {
          var _this = this;
          if (!this.finishedPromise) {
            if (this.timeline.animationsWithPromises.indexOf(this) === -1) {
              this.timeline.animationsWithPromises.push(this);
            }
            this.finishedPromise = new Promise(function(resolve, reject) {
              _this.resolveFinishedPromise = function() {
                resolve(_this);
              };
              _this.rejectFinishedPromise = function() {
                reject(new Error());
              };
            });
            if (this.playState === "finished") {
              this.resolveFinishedPromise();
            }
          }
          return this.finishedPromise;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Animation2.prototype, "currentTime", {
        get: function() {
          this.updatePromises();
          return this._idle || this.currentTimePending ? null : this._currentTime;
        },
        set: function(newTime) {
          var _a;
          newTime = Number(newTime);
          if (isNaN(newTime))
            return;
          this.timeline.restart();
          if (!this._paused && this._startTime !== null) {
            this._startTime = Number((_a = this.timeline) === null || _a === void 0 ? void 0 : _a.currentTime) - newTime / this.playbackRate;
          }
          this.currentTimePending = false;
          if (this._currentTime === newTime) {
            return;
          }
          if (this._idle) {
            this._idle = false;
            this._paused = true;
          }
          this.tickCurrentTime(newTime, true);
          this.timeline.applyDirtiedAnimation(this);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Animation2.prototype, "startTime", {
        get: function() {
          return this._startTime;
        },
        set: function(newTime) {
          if (newTime !== null) {
            this.updatePromises();
            newTime = Number(newTime);
            if (isNaN(newTime))
              return;
            if (this._paused || this._idle)
              return;
            this._startTime = newTime;
            this.tickCurrentTime((Number(this.timeline.currentTime) - this._startTime) * this.playbackRate);
            this.timeline.applyDirtiedAnimation(this);
            this.updatePromises();
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Animation2.prototype, "playbackRate", {
        get: function() {
          return this._playbackRate;
        },
        set: function(value2) {
          if (value2 === this._playbackRate) {
            return;
          }
          this.updatePromises();
          var oldCurrentTime = this.currentTime;
          this._playbackRate = value2;
          this.startTime = null;
          if (this.playState !== "paused" && this.playState !== "idle") {
            this._finishedFlag = false;
            this._idle = false;
            this.ensureAlive();
            this.timeline.applyDirtiedAnimation(this);
          }
          if (oldCurrentTime !== null) {
            this.currentTime = oldCurrentTime;
          }
          this.updatePromises();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Animation2.prototype, "_isFinished", {
        get: function() {
          return !this._idle && (this._playbackRate > 0 && Number(this._currentTime) >= this._totalDuration || this._playbackRate < 0 && Number(this._currentTime) <= 0);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Animation2.prototype, "totalDuration", {
        get: function() {
          return this._totalDuration;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Animation2.prototype, "_needsTick", {
        get: function() {
          return this.pending || this.playState === "running" || !this._finishedFlag;
        },
        enumerable: false,
        configurable: true
      });
      Animation2.prototype.updatePromises = function() {
        var oldPlayState = this.oldPlayState;
        var newPlayState = this.pending ? "pending" : this.playState;
        if (this.readyPromise && newPlayState !== oldPlayState) {
          if (newPlayState === "idle") {
            this.rejectReadyPromise();
            this.readyPromise = void 0;
          } else if (oldPlayState === "pending") {
            this.resolveReadyPromise();
          } else if (newPlayState === "pending") {
            this.readyPromise = void 0;
          }
        }
        if (this.finishedPromise && newPlayState !== oldPlayState) {
          if (newPlayState === "idle") {
            this.rejectFinishedPromise();
            this.finishedPromise = void 0;
          } else if (newPlayState === "finished") {
            this.resolveFinishedPromise();
          } else if (oldPlayState === "finished") {
            this.finishedPromise = void 0;
          }
        }
        this.oldPlayState = newPlayState;
        return this.readyPromise || this.finishedPromise;
      };
      Animation2.prototype.play = function() {
        this.updatePromises();
        this._paused = false;
        if (this._isFinished || this._idle) {
          this.rewind();
          this._startTime = null;
        }
        this._finishedFlag = false;
        this._idle = false;
        this.ensureAlive();
        this.timeline.applyDirtiedAnimation(this);
        if (this.timeline.animations.indexOf(this) === -1) {
          this.timeline.animations.push(this);
        }
        this.updatePromises();
      };
      Animation2.prototype.pause = function() {
        this.updatePromises();
        if (this.currentTime) {
          this._holdTime = this.currentTime;
        }
        if (!this._isFinished && !this._paused && !this._idle) {
          this.currentTimePending = true;
        } else if (this._idle) {
          this.rewind();
          this._idle = false;
        }
        this._startTime = null;
        this._paused = true;
        this.updatePromises();
      };
      Animation2.prototype.finish = function() {
        this.updatePromises();
        if (this._idle)
          return;
        this.currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
        this._startTime = this._totalDuration - this.currentTime;
        this.currentTimePending = false;
        this.timeline.applyDirtiedAnimation(this);
        this.updatePromises();
      };
      Animation2.prototype.cancel = function() {
        var _this = this;
        this.updatePromises();
        if (!this._inEffect)
          return;
        this._inEffect = false;
        this._idle = true;
        this._paused = false;
        this._finishedFlag = true;
        this._currentTime = 0;
        this._startTime = null;
        this.effect.update(null);
        this.timeline.applyDirtiedAnimation(this);
        this.updatePromises();
        if (this.oncancel) {
          var event_1 = new AnimationEvent(null, this, this.currentTime, null);
          setTimeout(function() {
            _this.oncancel(event_1);
          });
        }
      };
      Animation2.prototype.reverse = function() {
        this.updatePromises();
        var oldCurrentTime = this.currentTime;
        this.playbackRate *= -1;
        this.play();
        if (oldCurrentTime !== null) {
          this.currentTime = oldCurrentTime;
        }
        this.updatePromises();
      };
      Animation2.prototype.updatePlaybackRate = function(playbackRate) {
        this.playbackRate = playbackRate;
      };
      Animation2.prototype.targetAnimations = function() {
        var _a;
        var target = (_a = this.effect) === null || _a === void 0 ? void 0 : _a.target;
        return target.getAnimations();
      };
      Animation2.prototype.markTarget = function() {
        var animations = this.targetAnimations();
        if (animations.indexOf(this) === -1) {
          animations.push(this);
        }
      };
      Animation2.prototype.unmarkTarget = function() {
        var animations = this.targetAnimations();
        var index4 = animations.indexOf(this);
        if (index4 !== -1) {
          animations.splice(index4, 1);
        }
      };
      Animation2.prototype.tick = function(timelineTime, isAnimationFrame) {
        if (!this._idle && !this._paused) {
          if (this._startTime === null) {
            if (isAnimationFrame) {
              this.startTime = timelineTime - this._currentTime / this.playbackRate;
            }
          } else if (!this._isFinished) {
            this.tickCurrentTime((timelineTime - this._startTime) * this.playbackRate);
          }
        }
        if (isAnimationFrame) {
          this.currentTimePending = false;
          this.fireEvents(timelineTime);
        }
      };
      Animation2.prototype.rewind = function() {
        if (this.playbackRate >= 0) {
          this.currentTime = 0;
        } else if (this._totalDuration < Infinity) {
          this.currentTime = this._totalDuration;
        } else {
          throw new Error("Unable to rewind negative playback rate animation with infinite duration");
        }
      };
      Animation2.prototype.persist = function() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Animation2.prototype.addEventListener = function(type, listener, options) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Animation2.prototype.removeEventListener = function(type, listener, options) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Animation2.prototype.dispatchEvent = function(event) {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Animation2.prototype.commitStyles = function() {
        throw new Error(ERROR_MSG_METHOD_NOT_IMPLEMENTED);
      };
      Animation2.prototype.ensureAlive = function() {
        var _a, _b;
        if (this.playbackRate < 0 && this.currentTime === 0) {
          this._inEffect = !!((_a = this.effect) === null || _a === void 0 ? void 0 : _a.update(-1));
        } else {
          this._inEffect = !!((_b = this.effect) === null || _b === void 0 ? void 0 : _b.update(this.currentTime));
        }
        if (!this._inTimeline && (this._inEffect || !this._finishedFlag)) {
          this._inTimeline = true;
          this.timeline.animations.push(this);
        }
      };
      Animation2.prototype.tickCurrentTime = function(newTime, ignoreLimit) {
        if (newTime !== this._currentTime) {
          this._currentTime = newTime;
          if (this._isFinished && !ignoreLimit) {
            this._currentTime = this._playbackRate > 0 ? this._totalDuration : 0;
          }
          this.ensureAlive();
        }
      };
      Animation2.prototype.fireEvents = function(baseTime) {
        var _this = this;
        if (this._isFinished) {
          if (!this._finishedFlag) {
            if (this.onfinish) {
              var event_2 = new AnimationEvent(null, this, this.currentTime, baseTime);
              setTimeout(function() {
                if (_this.onfinish) {
                  _this.onfinish(event_2);
                }
              });
            }
            this._finishedFlag = true;
          }
        } else {
          if (this.onframe && this.playState === "running") {
            var event_3 = new AnimationEvent(null, this, this.currentTime, baseTime);
            this.onframe(event_3);
          }
          this._finishedFlag = false;
        }
      };
      return Animation2;
    }()
  );
  var NEWTON_ITERATIONS = 4;
  var NEWTON_MIN_SLOPE = 1e-3;
  var SUBDIVISION_PRECISION = 1e-7;
  var SUBDIVISION_MAX_ITERATIONS = 10;
  var kSplineTableSize = 11;
  var kSampleStepSize = 1 / (kSplineTableSize - 1);
  var float32ArraySupported = typeof Float32Array === "function";
  var A2 = function(aA1, aA2) {
    return 1 - 3 * aA2 + 3 * aA1;
  };
  var B2 = function(aA1, aA2) {
    return 3 * aA2 - 6 * aA1;
  };
  var C2 = function(aA1) {
    return 3 * aA1;
  };
  var calcBezier = function(aT, aA1, aA2) {
    return ((A2(aA1, aA2) * aT + B2(aA1, aA2)) * aT + C2(aA1)) * aT;
  };
  var getSlope = function(aT, aA1, aA2) {
    return 3 * A2(aA1, aA2) * aT * aT + 2 * B2(aA1, aA2) * aT + C2(aA1);
  };
  var binarySubdivide = function(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
      currentT = aA + (aB - aA) / 2;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0)
        aB = currentT;
      else
        aA = currentT;
    } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
    return currentT;
  };
  var newtonRaphsonIterate = function(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0)
        return aGuessT;
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  };
  var bezier2 = function(mX1, mY1, mX2, mY2) {
    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1))
      throw new Error("bezier x values must be in [0, 1] range");
    if (mX1 === mY1 && mX2 === mY2)
      return function(t) {
        return t;
      };
    var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
    for (var i = 0; i < kSplineTableSize; ++i) {
      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
    var getTForX = function(aX) {
      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;
      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample)
        intervalStart += kSampleStepSize;
      --currentSample;
      var dist5 = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist5 * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);
      if (initialSlope >= NEWTON_MIN_SLOPE)
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      else if (initialSlope === 0)
        return guessForT;
      else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }
    };
    return function(t) {
      if (t === 0 || t === 1)
        return t;
      return calcBezier(getTForX(t), mY1, mY2);
    };
  };
  var convertToDash = function(str7) {
    str7 = str7.replace(/([A-Z])/g, function(letter) {
      return "-".concat(letter.toLowerCase());
    });
    return str7.charAt(0) === "-" ? str7.substring(1) : str7;
  };
  var Quad = function(t) {
    return Math.pow(t, 2);
  };
  var Cubic = function(t) {
    return Math.pow(t, 3);
  };
  var Quart = function(t) {
    return Math.pow(t, 4);
  };
  var Quint = function(t) {
    return Math.pow(t, 5);
  };
  var Expo = function(t) {
    return Math.pow(t, 6);
  };
  var Sine = function(t) {
    return 1 - Math.cos(t * Math.PI / 2);
  };
  var Circ = function(t) {
    return 1 - Math.sqrt(1 - t * t);
  };
  var Back = function(t) {
    return t * t * (3 * t - 2);
  };
  var Bounce = function(t) {
    var pow22, b = 4;
    while (t < ((pow22 = Math.pow(2, --b)) - 1) / 11) {
    }
    return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow((pow22 * 3 - 2) / 22 - t, 2);
  };
  var Elastic = function(t, params) {
    if (params === void 0) {
      params = [];
    }
    var _a = __read(params, 2), _b = _a[0], amplitude = _b === void 0 ? 1 : _b, _c = _a[1], period = _c === void 0 ? 0.5 : _c;
    var a3 = clamp_default2(Number(amplitude), 1, 10);
    var p2 = clamp_default2(Number(period), 0.1, 2);
    if (t === 0 || t === 1)
      return t;
    return -a3 * Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1 - p2 / (Math.PI * 2) * Math.asin(1 / a3)) * (Math.PI * 2) / p2);
  };
  var Spring = function(t, params, duration) {
    if (params === void 0) {
      params = [];
    }
    var _a = __read(params, 4), _b = _a[0], mass = _b === void 0 ? 1 : _b, _c = _a[1], stiffness = _c === void 0 ? 100 : _c, _d = _a[2], damping = _d === void 0 ? 10 : _d, _e = _a[3], velocity = _e === void 0 ? 0 : _e;
    mass = clamp_default2(mass, 0.1, 1e3);
    stiffness = clamp_default2(stiffness, 0.1, 1e3);
    damping = clamp_default2(damping, 0.1, 1e3);
    velocity = clamp_default2(velocity, 0.1, 1e3);
    var w0 = Math.sqrt(stiffness / mass);
    var zeta = damping / (2 * Math.sqrt(stiffness * mass));
    var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
    var a3 = 1;
    var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;
    var progress = duration ? duration * t / 1e3 : t;
    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a3 * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a3 + b * progress) * Math.exp(-progress * w0);
    }
    if (t === 0 || t === 1)
      return t;
    return 1 - progress;
  };
  var Steps = function(t, params) {
    if (params === void 0) {
      params = [];
    }
    var _a = __read(params, 2), _b = _a[0], steps = _b === void 0 ? 10 : _b, type = _a[1];
    var trunc = type == "start" ? Math.ceil : Math.floor;
    return trunc(clamp_default2(t, 0, 1) * steps) / steps;
  };
  var Bezier = function(t, params) {
    if (params === void 0) {
      params = [];
    }
    var _a = __read(params, 4), mX1 = _a[0], mY1 = _a[1], mX2 = _a[2], mY2 = _a[3];
    return bezier2(mX1, mY1, mX2, mY2)(t);
  };
  var easein = bezier2(0.42, 0, 1, 1);
  var EaseOut = function(ease) {
    return function(t, params, duration) {
      if (params === void 0) {
        params = [];
      }
      return 1 - ease(1 - t, params, duration);
    };
  };
  var EaseInOut = function(ease) {
    return function(t, params, duration) {
      if (params === void 0) {
        params = [];
      }
      return t < 0.5 ? ease(t * 2, params, duration) / 2 : 1 - ease(t * -2 + 2, params, duration) / 2;
    };
  };
  var EaseOutIn = function(ease) {
    return function(t, params, duration) {
      if (params === void 0) {
        params = [];
      }
      return t < 0.5 ? (1 - ease(1 - t * 2, params, duration)) / 2 : (ease(t * 2 - 1, params, duration) + 1) / 2;
    };
  };
  var EasingFunctions = {
    steps: Steps,
    "step-start": function(t) {
      return Steps(t, [1, "start"]);
    },
    "step-end": function(t) {
      return Steps(t, [1, "end"]);
    },
    linear: function(t) {
      return t;
    },
    "cubic-bezier": Bezier,
    ease: function(t) {
      return Bezier(t, [0.25, 0.1, 0.25, 1]);
    },
    in: easein,
    out: EaseOut(easein),
    "in-out": EaseInOut(easein),
    "out-in": EaseOutIn(easein),
    "in-quad": Quad,
    "out-quad": EaseOut(Quad),
    "in-out-quad": EaseInOut(Quad),
    "out-in-quad": EaseOutIn(Quad),
    "in-cubic": Cubic,
    "out-cubic": EaseOut(Cubic),
    "in-out-cubic": EaseInOut(Cubic),
    "out-in-cubic": EaseOutIn(Cubic),
    "in-quart": Quart,
    "out-quart": EaseOut(Quart),
    "in-out-quart": EaseInOut(Quart),
    "out-in-quart": EaseOutIn(Quart),
    "in-quint": Quint,
    "out-quint": EaseOut(Quint),
    "in-out-quint": EaseInOut(Quint),
    "out-in-quint": EaseOutIn(Quint),
    "in-expo": Expo,
    "out-expo": EaseOut(Expo),
    "in-out-expo": EaseInOut(Expo),
    "out-in-expo": EaseOutIn(Expo),
    "in-sine": Sine,
    "out-sine": EaseOut(Sine),
    "in-out-sine": EaseInOut(Sine),
    "out-in-sine": EaseOutIn(Sine),
    "in-circ": Circ,
    "out-circ": EaseOut(Circ),
    "in-out-circ": EaseInOut(Circ),
    "out-in-circ": EaseOutIn(Circ),
    "in-back": Back,
    "out-back": EaseOut(Back),
    "in-out-back": EaseInOut(Back),
    "out-in-back": EaseOutIn(Back),
    "in-bounce": Bounce,
    "out-bounce": EaseOut(Bounce),
    "in-out-bounce": EaseInOut(Bounce),
    "out-in-bounce": EaseOutIn(Bounce),
    "in-elastic": Elastic,
    "out-elastic": EaseOut(Elastic),
    "in-out-elastic": EaseInOut(Elastic),
    "out-in-elastic": EaseOutIn(Elastic),
    spring: Spring,
    "spring-in": Spring,
    "spring-out": EaseOut(Spring),
    "spring-in-out": EaseInOut(Spring),
    "spring-out-in": EaseOutIn(Spring)
  };
  var complexEasingSyntax = function(ease) {
    return convertToDash(ease).replace(/^ease-/, "").replace(/(\(|\s).+/, "").toLowerCase().trim();
  };
  var getEasingFunction = function(ease) {
    return EasingFunctions[complexEasingSyntax(ease)] || EasingFunctions.linear;
  };
  var linear = function(x3) {
    return x3;
  };
  var Start = 1;
  var Middle = 0.5;
  var End = 0;
  function step(count4, pos) {
    return function(x3) {
      if (x3 >= 1) {
        return 1;
      }
      var stepSize = 1 / count4;
      x3 += pos * stepSize;
      return x3 - x3 % stepSize;
    };
  }
  var numberString = "\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*";
  var cubicBezierRe = new RegExp("cubic-bezier\\(" + numberString + "," + numberString + "," + numberString + "," + numberString + "\\)");
  var step1Re = /steps\(\s*(\d+)\s*\)/;
  var step2Re = /steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/;
  function parseEasingFunction(normalizedEasing) {
    var cubicData = cubicBezierRe.exec(normalizedEasing);
    if (cubicData) {
      return bezier2.apply(void 0, __spreadArray([], __read(cubicData.slice(1).map(Number)), false));
    }
    var step1Data = step1Re.exec(normalizedEasing);
    if (step1Data) {
      return step(Number(step1Data[1]), End);
    }
    var step2Data = step2Re.exec(normalizedEasing);
    if (step2Data) {
      return step(Number(step2Data[1]), { start: Start, middle: Middle, end: End }[step2Data[2]]);
    }
    return getEasingFunction(normalizedEasing);
  }
  function calculateActiveDuration(timing) {
    return Math.abs(repeatedDuration(timing) / (timing.playbackRate || 1));
  }
  function repeatedDuration(timing) {
    var _a;
    if (timing.duration === 0 || timing.iterations === 0) {
      return 0;
    }
    return (timing.duration === "auto" ? 0 : Number(timing.duration)) * ((_a = timing.iterations) !== null && _a !== void 0 ? _a : 1);
  }
  var PhaseNone = 0;
  var PhaseBefore = 1;
  var PhaseAfter = 2;
  var PhaseActive = 3;
  function calculatePhase(activeDuration, localTime, timing) {
    if (localTime === null) {
      return PhaseNone;
    }
    var endTime = timing.endTime;
    if (localTime < Math.min(timing.delay, endTime)) {
      return PhaseBefore;
    }
    if (localTime >= Math.min(timing.delay + activeDuration + timing.endDelay, endTime)) {
      return PhaseAfter;
    }
    return PhaseActive;
  }
  function calculateActiveTime(activeDuration, fillMode, localTime, phase, delay) {
    switch (phase) {
      case PhaseBefore:
        if (fillMode === "backwards" || fillMode === "both")
          return 0;
        return null;
      case PhaseActive:
        return localTime - delay;
      case PhaseAfter:
        if (fillMode === "forwards" || fillMode === "both")
          return activeDuration;
        return null;
      case PhaseNone:
        return null;
    }
  }
  function calculateOverallProgress(iterationDuration, phase, iterations2, activeTime, iterationStart) {
    var overallProgress = iterationStart;
    if (iterationDuration === 0) {
      if (phase !== PhaseBefore) {
        overallProgress += iterations2;
      }
    } else {
      overallProgress += activeTime / iterationDuration;
    }
    return overallProgress;
  }
  function calculateSimpleIterationProgress(overallProgress, iterationStart, phase, iterations2, activeTime, iterationDuration) {
    var simpleIterationProgress = overallProgress === Infinity ? iterationStart % 1 : overallProgress % 1;
    if (simpleIterationProgress === 0 && phase === PhaseAfter && iterations2 !== 0 && (activeTime !== 0 || iterationDuration === 0)) {
      simpleIterationProgress = 1;
    }
    return simpleIterationProgress;
  }
  function calculateCurrentIteration(phase, iterations2, simpleIterationProgress, overallProgress) {
    if (phase === PhaseAfter && iterations2 === Infinity) {
      return Infinity;
    }
    if (simpleIterationProgress === 1) {
      return Math.floor(overallProgress) - 1;
    }
    return Math.floor(overallProgress);
  }
  function calculateDirectedProgress(playbackDirection, currentIteration, simpleIterationProgress) {
    var currentDirection = playbackDirection;
    if (playbackDirection !== "normal" && playbackDirection !== "reverse") {
      var d2 = currentIteration;
      if (playbackDirection === "alternate-reverse") {
        d2 += 1;
      }
      currentDirection = "normal";
      if (d2 !== Infinity && d2 % 2 !== 0) {
        currentDirection = "reverse";
      }
    }
    if (currentDirection === "normal") {
      return simpleIterationProgress;
    }
    return 1 - simpleIterationProgress;
  }
  function calculateIterationProgress(activeDuration, localTime, timing) {
    var phase = calculatePhase(activeDuration, localTime, timing);
    var activeTime = calculateActiveTime(activeDuration, timing.fill, localTime, phase, timing.delay);
    if (activeTime === null)
      return null;
    var duration = timing.duration === "auto" ? 0 : timing.duration;
    var overallProgress = calculateOverallProgress(duration, phase, timing.iterations, activeTime, timing.iterationStart);
    var simpleIterationProgress = calculateSimpleIterationProgress(overallProgress, timing.iterationStart, phase, timing.iterations, activeTime, duration);
    var currentIteration = calculateCurrentIteration(phase, timing.iterations, simpleIterationProgress, overallProgress);
    var directedProgress = calculateDirectedProgress(timing.direction, currentIteration, simpleIterationProgress);
    timing.currentIteration = currentIteration;
    timing.progress = directedProgress;
    return timing.easingFunction(directedProgress);
  }
  function convertEffectInput(keyframes, timing, target) {
    var propertySpecificKeyframeGroups = makePropertySpecificKeyframeGroups(keyframes, timing);
    var interpolations = makeInterpolations(propertySpecificKeyframeGroups, target);
    return function(target2, fraction) {
      if (fraction !== null) {
        interpolations.filter(function(interpolation) {
          return fraction >= interpolation.applyFrom && fraction < interpolation.applyTo;
        }).forEach(function(interpolation) {
          var offsetFraction = fraction - interpolation.startOffset;
          var localDuration = interpolation.endOffset - interpolation.startOffset;
          var scaledLocalTime = localDuration === 0 ? 0 : offsetFraction / localDuration;
          target2.setAttribute(interpolation.property, interpolation.interpolation(scaledLocalTime), false, false);
        });
      } else {
        for (var property in propertySpecificKeyframeGroups)
          if (isNotReservedWord(property)) {
            target2.setAttribute(property, null);
          }
      }
    };
  }
  function isNotReservedWord(member) {
    return member !== "offset" && member !== "easing" && member !== "composite" && member !== "computedOffset";
  }
  function makePropertySpecificKeyframeGroups(keyframes, timing) {
    var propertySpecificKeyframeGroups = {};
    for (var i = 0; i < keyframes.length; i++) {
      for (var member in keyframes[i]) {
        if (isNotReservedWord(member)) {
          var propertySpecificKeyframe = {
            offset: keyframes[i].offset,
            computedOffset: keyframes[i].computedOffset,
            easing: keyframes[i].easing,
            easingFunction: parseEasingFunction(keyframes[i].easing) || timing.easingFunction,
            value: keyframes[i][member]
          };
          propertySpecificKeyframeGroups[member] = propertySpecificKeyframeGroups[member] || [];
          propertySpecificKeyframeGroups[member].push(propertySpecificKeyframe);
        }
      }
    }
    return propertySpecificKeyframeGroups;
  }
  function makeInterpolations(propertySpecificKeyframeGroups, target) {
    var interpolations = [];
    for (var groupName in propertySpecificKeyframeGroups) {
      var keyframes = propertySpecificKeyframeGroups[groupName];
      for (var i = 0; i < keyframes.length - 1; i++) {
        var startIndex = i;
        var endIndex = i + 1;
        var startOffset = keyframes[startIndex].computedOffset;
        var endOffset = keyframes[endIndex].computedOffset;
        var applyFrom = startOffset;
        var applyTo = endOffset;
        if (i === 0) {
          applyFrom = -Infinity;
          if (endOffset === 0) {
            endIndex = startIndex;
          }
        }
        if (i === keyframes.length - 2) {
          applyTo = Infinity;
          if (startOffset === 1) {
            startIndex = endIndex;
          }
        }
        interpolations.push({
          applyFrom,
          applyTo,
          startOffset: keyframes[startIndex].computedOffset,
          endOffset: keyframes[endIndex].computedOffset,
          easingFunction: keyframes[startIndex].easingFunction,
          property: groupName,
          interpolation: propertyInterpolation(groupName, keyframes[startIndex].value, keyframes[endIndex].value, target)
        });
      }
    }
    interpolations.sort(function(leftInterpolation, rightInterpolation) {
      return leftInterpolation.startOffset - rightInterpolation.startOffset;
    });
    return interpolations;
  }
  var InterpolationFactory = function(from, to, convertToString) {
    return function(f) {
      var interpolated = interpolate3(from, to, f);
      return !runtime.enableCSSParsing && is_number_default4(interpolated) ? interpolated : convertToString(interpolated);
    };
  };
  function propertyInterpolation(property, left2, right2, target) {
    var metadata = propertyMetadataCache[property];
    if (metadata && metadata.syntax && metadata.int) {
      var propertyHandler = runtime.styleValueRegistry.getPropertySyntax(metadata.syntax);
      if (propertyHandler) {
        var usedLeft = void 0;
        var usedRight = void 0;
        if (runtime.enableCSSParsing) {
          var computedLeft = runtime.styleValueRegistry.parseProperty(property, left2, target, false);
          var computedRight = runtime.styleValueRegistry.parseProperty(property, right2, target, false);
          usedLeft = runtime.styleValueRegistry.computeProperty(property, computedLeft, target, false);
          usedRight = runtime.styleValueRegistry.computeProperty(property, computedRight, target, false);
        } else {
          var parser = propertyHandler.parserWithCSSDisabled;
          usedLeft = parser ? parser(left2, target) : left2;
          usedRight = parser ? parser(right2, target) : right2;
        }
        var interpolationArgs = propertyHandler.mixer(usedLeft, usedRight, target);
        if (interpolationArgs) {
          var interp_1 = InterpolationFactory.apply(void 0, __spreadArray([], __read(interpolationArgs), false));
          return function(t) {
            if (t === 0)
              return left2;
            if (t === 1)
              return right2;
            return interp_1(t);
          };
        }
      }
    }
    return InterpolationFactory(false, true, function(bool) {
      return bool ? right2 : left2;
    });
  }
  function interpolate3(from, to, f) {
    if (typeof from === "number" && typeof to === "number") {
      return from * (1 - f) + to * f;
    }
    if (typeof from === "boolean" && typeof to === "boolean" || typeof from === "string" && typeof to === "string") {
      return f < 0.5 ? from : to;
    }
    if (Array.isArray(from) && Array.isArray(to)) {
      var fromLength = from.length;
      var toLength = to.length;
      var length_1 = Math.max(fromLength, toLength);
      var r = [];
      for (var i = 0; i < length_1; i++) {
        r.push(interpolate3(from[i < fromLength ? i : fromLength - 1], to[i < toLength ? i : toLength - 1], f));
      }
      return r;
    }
    throw new Error("Mismatched interpolation arguments " + from + ":" + to);
  }
  var AnimationEffectTiming = (
    /** @class */
    function() {
      function AnimationEffectTiming2() {
        this.delay = 0;
        this.direction = "normal";
        this.duration = "auto";
        this._easing = "linear";
        this.easingFunction = linear;
        this.endDelay = 0;
        this.fill = "auto";
        this.iterationStart = 0;
        this.iterations = 1;
        this.currentIteration = null;
        this.progress = null;
      }
      Object.defineProperty(AnimationEffectTiming2.prototype, "easing", {
        get: function() {
          return this._easing;
        },
        set: function(value2) {
          this.easingFunction = parseEasingFunction(value2);
          this._easing = value2;
        },
        enumerable: false,
        configurable: true
      });
      return AnimationEffectTiming2;
    }()
  );
  function convertToArrayForm(effectInput) {
    var normalizedEffectInput = [];
    for (var property in effectInput) {
      if (property in ["easing", "offset", "composite"]) {
        continue;
      }
      var values = effectInput[property];
      if (!Array.isArray(values)) {
        values = [values];
      }
      var numKeyframes = values.length;
      for (var i = 0; i < numKeyframes; i++) {
        if (!normalizedEffectInput[i]) {
          var keyframe = {};
          if ("offset" in effectInput) {
            keyframe.offset = Number(effectInput.offset);
          }
          if ("easing" in effectInput) {
            keyframe.easing = effectInput.easing;
          }
          if ("composite" in effectInput) {
            keyframe.composite = effectInput.composite;
          }
          normalizedEffectInput[i] = keyframe;
        }
        if (values[i] !== void 0 && values[i] !== null) {
          normalizedEffectInput[i][property] = values[i];
        }
      }
    }
    normalizedEffectInput.sort(function(a3, b) {
      return (a3.computedOffset || 0) - (b.computedOffset || 0);
    });
    return normalizedEffectInput;
  }
  function normalizeKeyframes(effectInput, timing) {
    if (effectInput === null) {
      return [];
    }
    if (!Array.isArray(effectInput)) {
      effectInput = convertToArrayForm(effectInput);
    }
    var keyframes = effectInput.map(function(originalKeyframe) {
      var keyframe = {};
      if (timing === null || timing === void 0 ? void 0 : timing.composite) {
        keyframe.composite = "auto";
      }
      for (var member in originalKeyframe) {
        var memberValue = originalKeyframe[member];
        if (member === "offset") {
          if (memberValue !== null) {
            memberValue = Number(memberValue);
            if (!isFinite(memberValue))
              throw new Error("Keyframe offsets must be numbers.");
            if (memberValue < 0 || memberValue > 1)
              throw new Error("Keyframe offsets must be between 0 and 1.");
            keyframe.computedOffset = memberValue;
          }
        } else if (member === "composite") {
          if (["replace", "add", "accumulate", "auto"].indexOf(memberValue) === -1) {
            throw new Error("".concat(memberValue, " compositing is not supported"));
          }
        } else ;
        keyframe[member] = memberValue;
      }
      if (keyframe.offset === void 0) {
        keyframe.offset = null;
      }
      if (keyframe.easing === void 0) {
        keyframe.easing = (timing === null || timing === void 0 ? void 0 : timing.easing) || "linear";
      }
      if (keyframe.composite === void 0) {
        keyframe.composite = "auto";
      }
      return keyframe;
    });
    var everyFrameHasOffset = true;
    var previousOffset = -Infinity;
    for (var i = 0; i < keyframes.length; i++) {
      var offset3 = keyframes[i].offset;
      if (!is_nil_default3(offset3)) {
        if (offset3 < previousOffset) {
          throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");
        }
        previousOffset = offset3;
      } else {
        everyFrameHasOffset = false;
      }
    }
    keyframes = keyframes.filter(function(keyframe) {
      return Number(keyframe.offset) >= 0 && Number(keyframe.offset) <= 1;
    });
    function spaceKeyframes() {
      var _a, _b;
      var length5 = keyframes.length;
      keyframes[length5 - 1].computedOffset = Number((_a = keyframes[length5 - 1].offset) !== null && _a !== void 0 ? _a : 1);
      if (length5 > 1) {
        keyframes[0].computedOffset = Number((_b = keyframes[0].offset) !== null && _b !== void 0 ? _b : 0);
      }
      var previousIndex = 0;
      var previousOffset2 = Number(keyframes[0].computedOffset);
      for (var i2 = 1; i2 < length5; i2++) {
        var offset4 = keyframes[i2].computedOffset;
        if (!is_nil_default3(offset4) && !is_nil_default3(previousOffset2)) {
          for (var j = 1; j < i2 - previousIndex; j++)
            keyframes[previousIndex + j].computedOffset = previousOffset2 + (Number(offset4) - previousOffset2) * j / (i2 - previousIndex);
          previousIndex = i2;
          previousOffset2 = Number(offset4);
        }
      }
    }
    if (!everyFrameHasOffset)
      spaceKeyframes();
    return keyframes;
  }
  var fills = "backwards|forwards|both|none".split("|");
  var directions = "reverse|alternate|alternate-reverse".split("|");
  function makeTiming(timingInput, forGroup) {
    var timing = new AnimationEffectTiming();
    if (forGroup) {
      timing.fill = "both";
      timing.duration = "auto";
    }
    if (typeof timingInput === "number" && !isNaN(timingInput)) {
      timing.duration = timingInput;
    } else if (timingInput !== void 0) {
      Object.keys(timingInput).forEach(function(property) {
        if (timingInput[property] !== void 0 && timingInput[property] !== null && timingInput[property] !== "auto") {
          if (typeof timing[property] === "number" || property === "duration") {
            if (typeof timingInput[property] !== "number" || isNaN(timingInput[property])) {
              return;
            }
          }
          if (property === "fill" && fills.indexOf(timingInput[property]) === -1) {
            return;
          }
          if (property === "direction" && directions.indexOf(timingInput[property]) === -1) {
            return;
          }
          timing[property] = timingInput[property];
        }
      });
    }
    return timing;
  }
  function normalizeTimingInput(timingInput, forGroup) {
    timingInput = numericTimingToObject(timingInput !== null && timingInput !== void 0 ? timingInput : { duration: "auto" });
    return makeTiming(timingInput, forGroup);
  }
  function numericTimingToObject(timingInput) {
    if (typeof timingInput === "number") {
      if (isNaN(timingInput)) {
        timingInput = { duration: "auto" };
      } else {
        timingInput = { duration: timingInput };
      }
    }
    return timingInput;
  }
  var KeyframeEffect = (
    /** @class */
    function() {
      function KeyframeEffect2(target, effectInput, timingInput) {
        var _this = this;
        this.composite = "replace";
        this.iterationComposite = "replace";
        this.target = target;
        this.timing = normalizeTimingInput(timingInput, false);
        this.timing.effect = this;
        this.timing.activeDuration = calculateActiveDuration(this.timing);
        this.timing.endTime = Math.max(0, this.timing.delay + this.timing.activeDuration + this.timing.endDelay);
        this.normalizedKeyframes = normalizeKeyframes(effectInput, this.timing);
        this.interpolations = convertEffectInput(this.normalizedKeyframes, this.timing, this.target);
        var Proxy3 = runtime.globalThis.Proxy;
        this.computedTiming = Proxy3 ? new Proxy3(this.timing, {
          get: function(target2, prop) {
            if (prop === "duration") {
              return target2.duration === "auto" ? 0 : target2.duration;
            } else if (prop === "fill") {
              return target2.fill === "auto" ? "none" : target2.fill;
            } else if (prop === "localTime") {
              return _this.animation && _this.animation.currentTime || null;
            } else if (prop === "currentIteration") {
              if (!_this.animation || _this.animation.playState !== "running") {
                return null;
              }
              return target2.currentIteration || 0;
            } else if (prop === "progress") {
              if (!_this.animation || _this.animation.playState !== "running") {
                return null;
              }
              return target2.progress || 0;
            }
            return target2[prop];
          },
          set: function() {
            return true;
          }
        }) : this.timing;
      }
      KeyframeEffect2.prototype.applyInterpolations = function() {
        this.interpolations(this.target, Number(this.timeFraction));
      };
      KeyframeEffect2.prototype.update = function(localTime) {
        if (localTime === null) {
          return false;
        }
        this.timeFraction = calculateIterationProgress(this.timing.activeDuration, localTime, this.timing);
        return this.timeFraction !== null;
      };
      KeyframeEffect2.prototype.getKeyframes = function() {
        return this.normalizedKeyframes;
      };
      KeyframeEffect2.prototype.setKeyframes = function(keyframes) {
        this.normalizedKeyframes = normalizeKeyframes(keyframes);
      };
      KeyframeEffect2.prototype.getComputedTiming = function() {
        return this.computedTiming;
      };
      KeyframeEffect2.prototype.getTiming = function() {
        return this.timing;
      };
      KeyframeEffect2.prototype.updateTiming = function(timing) {
        var _this = this;
        Object.keys(timing || {}).forEach(function(name2) {
          _this.timing[name2] = timing[name2];
        });
      };
      return KeyframeEffect2;
    }()
  );
  function compareAnimations(leftAnimation, rightAnimation) {
    return Number(leftAnimation.id) - Number(rightAnimation.id);
  }
  var AnimationTimeline = (
    /** @class */
    function() {
      function AnimationTimeline2(document2) {
        var _this = this;
        this.document = document2;
        this.animations = [];
        this.ticking = false;
        this.timelineTicking = false;
        this.hasRestartedThisFrame = false;
        this.animationsWithPromises = [];
        this.inTick = false;
        this.pendingEffects = [];
        this.currentTime = null;
        this.rafId = 0;
        this.rafCallbacks = [];
        this.webAnimationsNextTick = function(t) {
          _this.currentTime = t;
          _this.discardAnimations();
          if (_this.animations.length === 0) {
            _this.timelineTicking = false;
          } else {
            _this.requestAnimationFrame(_this.webAnimationsNextTick);
          }
        };
        this.processRafCallbacks = function(t) {
          var processing = _this.rafCallbacks;
          _this.rafCallbacks = [];
          if (t < Number(_this.currentTime))
            t = Number(_this.currentTime);
          _this.animations.sort(compareAnimations);
          _this.animations = _this.tick(t, true, _this.animations)[0];
          processing.forEach(function(entry) {
            entry[1](t);
          });
          _this.applyPendingEffects();
        };
      }
      AnimationTimeline2.prototype.getAnimations = function() {
        this.discardAnimations();
        return this.animations.slice();
      };
      AnimationTimeline2.prototype.isTicking = function() {
        return this.inTick;
      };
      AnimationTimeline2.prototype.play = function(target, keyframes, options) {
        var effect = new KeyframeEffect(target, keyframes, options);
        var animation = new Animation(effect, this);
        this.animations.push(animation);
        this.restartWebAnimationsNextTick();
        animation.updatePromises();
        animation.play();
        animation.updatePromises();
        return animation;
      };
      AnimationTimeline2.prototype.applyDirtiedAnimation = function(animation) {
        var _this = this;
        if (this.inTick) {
          return;
        }
        animation.markTarget();
        var animations = animation.targetAnimations();
        animations.sort(compareAnimations);
        var inactiveAnimations = this.tick(Number(this.currentTime), false, animations.slice())[1];
        inactiveAnimations.forEach(function(animation2) {
          var index4 = _this.animations.indexOf(animation2);
          if (index4 !== -1) {
            _this.animations.splice(index4, 1);
          }
        });
        this.applyPendingEffects();
      };
      AnimationTimeline2.prototype.restart = function() {
        if (!this.ticking) {
          this.ticking = true;
          this.requestAnimationFrame(function() {
          });
          this.hasRestartedThisFrame = true;
        }
        return this.hasRestartedThisFrame;
      };
      AnimationTimeline2.prototype.destroy = function() {
        this.document.defaultView.cancelAnimationFrame(this.frameId);
      };
      AnimationTimeline2.prototype.applyPendingEffects = function() {
        this.pendingEffects.forEach(function(effect) {
          effect === null || effect === void 0 ? void 0 : effect.applyInterpolations();
        });
        this.pendingEffects = [];
      };
      AnimationTimeline2.prototype.updateAnimationsPromises = function() {
        this.animationsWithPromises = this.animationsWithPromises.filter(function(animation) {
          return animation.updatePromises();
        });
      };
      AnimationTimeline2.prototype.discardAnimations = function() {
        this.updateAnimationsPromises();
        this.animations = this.animations.filter(function(animation) {
          return animation.playState !== "finished" && animation.playState !== "idle";
        });
      };
      AnimationTimeline2.prototype.restartWebAnimationsNextTick = function() {
        if (!this.timelineTicking) {
          this.timelineTicking = true;
          this.requestAnimationFrame(this.webAnimationsNextTick);
        }
      };
      AnimationTimeline2.prototype.rAF = function(f) {
        var id4 = this.rafId++;
        if (this.rafCallbacks.length === 0) {
          this.frameId = this.document.defaultView.requestAnimationFrame(this.processRafCallbacks);
        }
        this.rafCallbacks.push([id4, f]);
        return id4;
      };
      AnimationTimeline2.prototype.requestAnimationFrame = function(f) {
        var _this = this;
        return this.rAF(function(x3) {
          _this.updateAnimationsPromises();
          f(x3);
          _this.updateAnimationsPromises();
        });
      };
      AnimationTimeline2.prototype.tick = function(t, isAnimationFrame, updatingAnimations) {
        var _a, _b;
        var _this = this;
        this.inTick = true;
        this.hasRestartedThisFrame = false;
        this.currentTime = t;
        this.ticking = false;
        var newPendingClears = [];
        var newPendingEffects = [];
        var activeAnimations = [];
        var inactiveAnimations = [];
        updatingAnimations.forEach(function(animation) {
          animation.tick(t, isAnimationFrame);
          if (!animation._inEffect) {
            newPendingClears.push(animation.effect);
            animation.unmarkTarget();
          } else {
            newPendingEffects.push(animation.effect);
            animation.markTarget();
          }
          if (animation._needsTick)
            _this.ticking = true;
          var alive = animation._inEffect || animation._needsTick;
          animation._inTimeline = alive;
          if (alive) {
            activeAnimations.push(animation);
          } else {
            inactiveAnimations.push(animation);
          }
        });
        (_a = this.pendingEffects).push.apply(_a, __spreadArray([], __read(newPendingClears), false));
        (_b = this.pendingEffects).push.apply(_b, __spreadArray([], __read(newPendingEffects), false));
        if (this.ticking)
          this.requestAnimationFrame(function() {
          });
        this.inTick = false;
        return [activeAnimations, inactiveAnimations];
      };
      return AnimationTimeline2;
    }()
  );
  runtime.EasingFunction = parseEasingFunction;
  runtime.AnimationTimeline = AnimationTimeline;

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/selection.js
  function select(node) {
    return new Selection([node], null, node, node.ownerDocument);
  }
  var Selection = class _Selection {
    constructor(elements = null, data2 = null, parent = null, document2 = null, selections = [
      null,
      null,
      null,
      null,
      null
    ], transitions = [], updateElements = []) {
      this._elements = Array.from(elements);
      this._data = data2;
      this._parent = parent;
      this._document = document2;
      this._enter = selections[0];
      this._update = selections[1];
      this._exit = selections[2];
      this._merge = selections[3];
      this._split = selections[4];
      this._transitions = transitions;
      this._facetElements = updateElements;
    }
    selectAll(selector) {
      const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _Selection(elements, null, this._elements[0], this._document);
    }
    selectFacetAll(selector) {
      const elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
      return new _Selection(this._elements, null, this._parent, this._document, void 0, void 0, elements);
    }
    /**
     * @todo Replace with querySelector which has bug now.
     */
    select(selector) {
      const element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
      return new _Selection([element], null, element, this._document);
    }
    append(node) {
      const callback = typeof node === "function" ? node : () => this.createElement(node);
      const elements = [];
      if (this._data !== null) {
        for (let i = 0; i < this._data.length; i++) {
          const d2 = this._data[i];
          const [datum, from] = Array.isArray(d2) ? d2 : [d2, null];
          const newElement = callback(datum, i);
          newElement.__data__ = datum;
          if (from !== null)
            newElement.__fromElements__ = from;
          this._parent.appendChild(newElement);
          elements.push(newElement);
        }
        return new _Selection(elements, null, this._parent, this._document);
      } else {
        for (let i = 0; i < this._elements.length; i++) {
          const element = this._elements[i];
          const datum = element.__data__;
          const newElement = callback(datum, i);
          element.appendChild(newElement);
          elements.push(newElement);
        }
        return new _Selection(elements, null, elements[0], this._document);
      }
    }
    maybeAppend(id4, node, className2) {
      const element = this._elements[0];
      const child = element.getElementById(id4);
      if (child) {
        return new _Selection([child], null, this._parent, this._document);
      }
      const newChild = typeof node === "string" ? this.createElement(node) : node();
      newChild.id = id4;
      if (className2)
        newChild.className = className2;
      element.appendChild(newChild);
      return new _Selection([newChild], null, this._parent, this._document);
    }
    /**
     * Bind data to elements, and produce three selection:
     * Enter: Selection with empty elements and data to be bind to elements.
     * Update: Selection with elements to be updated.
     * Exit: Selection with elements to be removed.
     */
    data(data2, id4 = (d2) => d2, groupId = () => null) {
      const enter = [];
      const update = [];
      const exit = new Set(this._elements);
      const merge2 = [];
      const split = /* @__PURE__ */ new Set();
      const keyElement = new Map(this._elements.map((d2, i) => [id4(d2.__data__, i), d2]));
      const keyUpdateElement = new Map(this._facetElements.map((d2, i) => [id4(d2.__data__, i), d2]));
      const groupKeyElements = group(this._elements, (d2) => groupId(d2.__data__));
      for (let i = 0; i < data2.length; i++) {
        const datum = data2[i];
        const key = id4(datum, i);
        const groupKey = groupId(datum, i);
        if (keyElement.has(key)) {
          const element = keyElement.get(key);
          element.__data__ = datum;
          element.__facet__ = false;
          update.push(element);
          exit.delete(element);
          keyElement.delete(key);
        } else if (keyUpdateElement.has(key)) {
          const element = keyUpdateElement.get(key);
          element.__data__ = datum;
          element.__facet__ = true;
          update.push(element);
          keyUpdateElement.delete(key);
        } else if (groupKeyElements.has(key)) {
          const group3 = groupKeyElements.get(key);
          merge2.push([datum, group3]);
          for (const element of group3)
            exit.delete(element);
          groupKeyElements.delete(key);
        } else if (keyElement.has(groupKey)) {
          const element = keyElement.get(groupKey);
          if (element.__toData__)
            element.__toData__.push(datum);
          else
            element.__toData__ = [datum];
          split.add(element);
          exit.delete(element);
        } else {
          enter.push(datum);
        }
      }
      const S = [
        new _Selection([], enter, this._parent, this._document),
        new _Selection(update, null, this._parent, this._document),
        new _Selection(exit, null, this._parent, this._document),
        new _Selection([], merge2, this._parent, this._document),
        new _Selection(split, null, this._parent, this._document)
      ];
      return new _Selection(this._elements, null, this._parent, this._document, S);
    }
    merge(other) {
      const elements = [...this._elements, ...other._elements];
      const transitions = [...this._transitions, ...other._transitions];
      return new _Selection(elements, null, this._parent, this._document, void 0, transitions);
    }
    createElement(type) {
      if (this._document) {
        return this._document.createElement(type, {});
      }
      const Ctor = _Selection.registry[type];
      if (Ctor)
        return new Ctor();
      return error2(`Unknown node type: ${type}`);
    }
    /**
     * Apply callback for each selection(enter, update, exit)
     * and merge them into one selection.
     */
    join(enter = (d2) => d2, update = (d2) => d2, exit = (d2) => d2.remove(), merge2 = (d2) => d2, split = (d2) => d2.remove()) {
      const newEnter = enter(this._enter);
      const newUpdate = update(this._update);
      const newExit = exit(this._exit);
      const newMerge = merge2(this._merge);
      const newSplit = split(this._split);
      return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
    }
    remove() {
      for (let i = 0; i < this._elements.length; i++) {
        const transition2 = this._transitions[i];
        if (transition2) {
          const T = Array.isArray(transition2) ? transition2 : [transition2];
          Promise.all(T.map((d2) => d2.finished)).then(() => {
            const element = this._elements[i];
            element.remove();
          });
        } else {
          const element = this._elements[i];
          element.remove();
        }
      }
      return new _Selection([], null, this._parent, this._document, void 0, this._transitions);
    }
    each(callback) {
      for (let i = 0; i < this._elements.length; i++) {
        const element = this._elements[i];
        const datum = element.__data__;
        callback(datum, i, element);
      }
      return this;
    }
    attr(key, value2) {
      const callback = typeof value2 !== "function" ? () => value2 : value2;
      return this.each(function(d2, i, element) {
        if (value2 !== void 0)
          element[key] = callback(d2, i, element);
      });
    }
    style(key, value2) {
      const callback = typeof value2 !== "function" ? () => value2 : value2;
      return this.each(function(d2, i, element) {
        if (value2 !== void 0)
          element.style[key] = callback(d2, i, element);
      });
    }
    transition(value2) {
      const callback = typeof value2 !== "function" ? () => value2 : value2;
      const { _transitions: T } = this;
      return this.each(function(d2, i, element) {
        T[i] = callback(d2, i, element);
      });
    }
    on(event, handler) {
      this.each(function(d2, i, element) {
        element.addEventListener(event, handler);
      });
      return this;
    }
    call(callback, ...args) {
      callback(this, ...args);
      return this;
    }
    node() {
      return this._elements[0];
    }
    nodes() {
      return this._elements;
    }
    transitions() {
      return this._transitions;
    }
    parent() {
      return this._parent;
    }
  };
  Selection.registry = {
    g: Group2,
    rect: Rect,
    circle: Circle,
    path: Path2,
    text: Text,
    ellipse: Ellipse,
    image: Image2,
    line: Line,
    polygon: Polygon,
    polyline: Polyline,
    html: HTML
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/number.js
  function clamp3(v, lower2, upper2) {
    return Math.max(lower2, Math.min(v, upper2));
  }
  function prettyNumber2(n2, precision = 10) {
    if (typeof n2 !== "number")
      return n2;
    return Math.abs(n2) < 1e-15 ? n2 : parseFloat(n2.toFixed(precision));
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/utils.js
  function applyStyle(selection, style) {
    for (const [key, value2] of Object.entries(style)) {
      selection.style(key, value2);
    }
  }
  function appendPolygon(path2, points) {
    points.forEach((p2, idx) => idx === 0 ? path2.moveTo(p2[0], p2[1]) : path2.lineTo(p2[0], p2[1]));
    path2.closePath();
    return path2;
  }
  function arrowPoints(from, to, options) {
    const { arrowSize } = options;
    const size2 = typeof arrowSize === "string" ? +parseFloat(arrowSize) / 100 * dist4(from, to) : arrowSize;
    const arrowAngle = Math.PI / 6;
    const angle4 = Math.atan2(to[1] - from[1], to[0] - from[0]);
    const arrowAngle1 = Math.PI / 2 - angle4 - arrowAngle;
    const arrow1 = [
      to[0] - size2 * Math.sin(arrowAngle1),
      to[1] - size2 * Math.cos(arrowAngle1)
    ];
    const arrowAngle2 = angle4 - arrowAngle;
    const arrow2 = [
      to[0] - size2 * Math.cos(arrowAngle2),
      to[1] - size2 * Math.sin(arrowAngle2)
    ];
    return [arrow1, arrow2];
  }
  function appendArc(path2, from, to, center2, radius) {
    const startAngle = angle3(sub6(center2, from)) + Math.PI;
    const endAngle = angle3(sub6(center2, to)) + Math.PI;
    path2.arc(center2[0], center2[1], radius, startAngle, endAngle, endAngle - startAngle < 0);
    return path2;
  }
  function computeGradient(C3, X, Y, from = "y", mode = "between", tpShape = false) {
    const getTheta = (from2, tpShape2) => {
      if (from2 === "y" || from2 === true) {
        if (tpShape2) {
          return 180;
        } else {
          return 90;
        }
      } else {
        if (tpShape2) {
          return 90;
        } else {
          return 0;
        }
      }
    };
    const P = from === "y" || from === true ? Y : X;
    const theta = getTheta(from, tpShape);
    const I = indexOf3(P);
    const [min10, max10] = extent(I, (i) => P[i]);
    const p2 = new Linear({
      domain: [min10, max10],
      range: [0, 100]
    });
    const percentage = (i) => is_number_default(P[i]) && !Number.isNaN(P[i]) ? p2.map(P[i]) : 0;
    const gradientMode = {
      // Interpolate the colors for this segment.
      between: (i) => `${C3[i]} ${percentage(i)}%`,
      // Use the color of the start point as the color for this segment.
      start: (i) => i === 0 ? `${C3[i]} ${percentage(i)}%` : `${C3[i - 1]} ${percentage(i)}%, ${C3[i]} ${percentage(i)}%`,
      // Use the color of the end point as the color for this segment.
      end: (i) => i === C3.length - 1 ? `${C3[i]} ${percentage(i)}%` : `${C3[i]} ${percentage(i)}%, ${C3[i + 1]} ${percentage(i)}%`
    };
    const gradient = I.sort((a3, b) => percentage(a3) - percentage(b)).map(gradientMode[mode] || gradientMode["between"]).join(",");
    return `linear-gradient(${theta}deg, ${gradient})`;
  }
  function reorder(points) {
    const [p0, p1, p2, p3] = points;
    return [p3, p0, p1, p2];
  }
  function getArcObject(coordinate, points, Y) {
    const [p0, p1, , p3] = isTranspose(coordinate) ? reorder(points) : points;
    const [y3, y12] = Y;
    const center2 = coordinate.getCenter();
    const a1 = angleWithQuadrant(sub6(p0, center2));
    const a22 = angleWithQuadrant(sub6(p1, center2));
    const a3 = a22 === a1 && y3 !== y12 ? a22 + Math.PI * 2 : a22;
    return {
      startAngle: a1,
      endAngle: a3 - a1 >= 0 ? a3 : Math.PI * 2 + a3,
      innerRadius: dist4(p3, center2),
      outerRadius: dist4(p0, center2)
    };
  }
  function toOpacityKey(options) {
    const { colorAttribute, opacityAttribute = colorAttribute } = options;
    return `${opacityAttribute}Opacity`;
  }
  function getTransform(coordinate, value2) {
    if (!isPolar(coordinate))
      return "";
    const center2 = coordinate.getCenter();
    const { transform: suffix } = value2;
    return `translate(${center2[0]}, ${center2[1]}) ${suffix || ""}`;
  }
  function getOrigin(points) {
    if (points.length === 1)
      return points[0];
    const [[x05, y05, z0 = 0], [x22, y22, z2 = 0]] = points;
    return [(x05 + x22) / 2, (y05 + y22) / 2, (z0 + z2) / 2];
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/interval/color.js
  var __rest13 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function rect(document2, points, value2, coordinate, style = {}) {
    const { inset = 0, radius = 0, insetLeft = inset, insetTop = inset, insetRight = inset, insetBottom = inset, radiusBottomLeft = radius, radiusBottomRight = radius, radiusTopLeft = radius, radiusTopRight = radius, minWidth = -Infinity, maxWidth = Infinity, minHeight = -Infinity } = style, rest = __rest13(style, ["inset", "radius", "insetLeft", "insetTop", "insetRight", "insetBottom", "radiusBottomLeft", "radiusBottomRight", "radiusTopLeft", "radiusTopRight", "minWidth", "maxWidth", "minHeight"]);
    if (!isPolar(coordinate) && !isHelix(coordinate)) {
      const tpShape = !!isTranspose(coordinate);
      const [p0, , p2] = tpShape ? reorder(points) : points;
      const [x3, y4] = p0;
      const [width, height] = sub6(p2, p0);
      const absX = width > 0 ? x3 : x3 + width;
      const absY = height > 0 ? y4 : y4 + height;
      const absWidth = Math.abs(width);
      const absHeight = Math.abs(height);
      const finalX = absX + insetLeft;
      const finalY = absY + insetTop;
      const finalWidth = absWidth - (insetLeft + insetRight);
      const finalHeight = absHeight - (insetTop + insetBottom);
      const clampWidth = tpShape ? clamp3(finalWidth, minHeight, Infinity) : clamp3(finalWidth, minWidth, maxWidth);
      const clampHeight = tpShape ? clamp3(finalHeight, minWidth, maxWidth) : clamp3(finalHeight, minHeight, Infinity);
      const clampX = tpShape ? finalX : finalX - (clampWidth - finalWidth) / 2;
      const clampY = tpShape ? finalY - (clampHeight - finalHeight) / 2 : finalY - (clampHeight - finalHeight);
      return select(document2.createElement("rect", {})).style("x", clampX).style("y", clampY).style("width", clampWidth).style("height", clampHeight).style("radius", [
        radiusTopLeft,
        radiusTopRight,
        radiusBottomRight,
        radiusBottomLeft
      ]).call(applyStyle, rest).node();
    }
    const { y: y3, y1: y12 } = value2;
    const center2 = coordinate.getCenter();
    const arcObject = getArcObject(coordinate, points, [y3, y12]);
    const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
    return select(document2.createElement("path", {})).style("d", path2(arcObject)).style("transform", `translate(${center2[0]}, ${center2[1]})`).style("radius", radius).style("inset", inset).call(applyStyle, rest).node();
  }
  var Color2 = (options, context) => {
    const { colorAttribute, opacityAttribute = "fill", first: first3 = true, last: last4 = true } = options, style = __rest13(options, ["colorAttribute", "opacityAttribute", "first", "last"]);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor, radius: defaultRadius2 = 0 } = defaults5, restDefaults = __rest13(defaults5, ["color", "radius"]);
      const defaultLineWidth = restDefaults.lineWidth || 1;
      const { stroke: stroke2, radius = defaultRadius2, radiusTopLeft = radius, radiusTopRight = radius, radiusBottomRight = radius, radiusBottomLeft = radius, innerRadius = 0, innerRadiusTopLeft = innerRadius, innerRadiusTopRight = innerRadius, innerRadiusBottomRight = innerRadius, innerRadiusBottomLeft = innerRadius, lineWidth = colorAttribute === "stroke" || stroke2 ? defaultLineWidth : 0, inset = 0, insetLeft = inset, insetRight = inset, insetBottom = inset, insetTop = inset, minWidth, maxWidth, minHeight } = style, rest = __rest13(style, ["stroke", "radius", "radiusTopLeft", "radiusTopRight", "radiusBottomRight", "radiusBottomLeft", "innerRadius", "innerRadiusTopLeft", "innerRadiusTopRight", "innerRadiusBottomRight", "innerRadiusBottomLeft", "lineWidth", "inset", "insetLeft", "insetRight", "insetBottom", "insetTop", "minWidth", "maxWidth", "minHeight"]);
      const { color: color2 = defaultColor, opacity } = value2;
      const standardDirRadius = [
        first3 ? radiusTopLeft : innerRadiusTopLeft,
        first3 ? radiusTopRight : innerRadiusTopRight,
        last4 ? radiusBottomRight : innerRadiusBottomRight,
        last4 ? radiusBottomLeft : innerRadiusBottomLeft
      ];
      const standardDir = [
        "radiusTopLeft",
        "radiusTopRight",
        "radiusBottomRight",
        "radiusBottomLeft"
      ];
      if (isTranspose(coordinate)) {
        standardDir.push(standardDir.shift());
      }
      const extendedStyle = Object.assign(Object.assign({ radius }, Object.fromEntries(standardDir.map((d2, i) => [d2, standardDirRadius[i]]))), {
        inset,
        insetLeft,
        insetRight,
        insetBottom,
        insetTop,
        minWidth,
        maxWidth,
        minHeight
      });
      return select(rect(document2, points, value2, coordinate, extendedStyle)).call(applyStyle, restDefaults).style("fill", "transparent").style(colorAttribute, color2).style(toOpacityKey(options), opacity).style("lineWidth", lineWidth).style("stroke", stroke2 === void 0 ? color2 : stroke2).call(applyStyle, rest).node();
    };
  };
  Color2.props = {
    defaultEnterAnimation: "scaleInY",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/interval/rect.js
  var Rect2 = (options, context) => {
    return Color2(Object.assign({ colorAttribute: "fill" }, options), context);
  };
  Rect2.props = Object.assign(Object.assign({}, Color2.props), { defaultMarker: "square" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/interval/hollow.js
  var Hollow = (options, context) => {
    return Color2(Object.assign({ colorAttribute: "stroke" }, options), context);
  };
  Hollow.props = Object.assign(Object.assign({}, Color2.props), { defaultMarker: "hollowSquare" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/interval/funnel.js
  var __rest14 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function getFunnelPoints(points, nextPoints, coordinate) {
    const [p0, p1, p2, p3] = points;
    if (isTranspose(coordinate)) {
      const newP12 = [nextPoints ? nextPoints[0][0] : p1[0], p1[1]];
      const newP22 = [nextPoints ? nextPoints[3][0] : p2[0], p2[1]];
      return [p0, newP12, newP22, p3];
    }
    const newP1 = [p1[0], nextPoints ? nextPoints[0][1] : p1[1]];
    const newP2 = [p2[0], nextPoints ? nextPoints[3][1] : p2[1]];
    return [p0, newP1, newP2, p3];
  }
  var Funnel = (options, context) => {
    const { adjustPoints = getFunnelPoints } = options, style = __rest14(options, ["adjustPoints"]);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5, point2d) => {
      const { index: index4 } = value2;
      const { color: defaultColor } = defaults5, rest = __rest14(defaults5, ["color"]);
      const nextPoints = point2d[index4 + 1];
      const funnelPoints = adjustPoints(points, nextPoints, coordinate);
      const tpShape = !!isTranspose(coordinate);
      const [p0, p1, p2, p3] = tpShape ? reorder(funnelPoints) : funnelPoints;
      const { color: color2 = defaultColor, opacity } = value2;
      const b = line_default().curve(linearClosed_default)([p0, p1, p2, p3]);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", b).style("fill", color2).style("fillOpacity", opacity).call(applyStyle, style).node();
    };
  };
  Funnel.props = {
    defaultMarker: "square"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/interval/pyramid.js
  function getPyramidPoints(points, nextPoints, coordinate) {
    const [p0, p1, p2, p3] = points;
    if (isTranspose(coordinate)) {
      const newP12 = [
        nextPoints ? nextPoints[0][0] : (p1[0] + p2[0]) / 2,
        p1[1]
      ];
      const newP22 = [
        nextPoints ? nextPoints[3][0] : (p1[0] + p2[0]) / 2,
        p2[1]
      ];
      return [p0, newP12, newP22, p3];
    }
    const newP1 = [
      p1[0],
      nextPoints ? nextPoints[0][1] : (p1[1] + p2[1]) / 2
    ];
    const newP2 = [
      p2[0],
      nextPoints ? nextPoints[3][1] : (p1[1] + p2[1]) / 2
    ];
    return [p0, newP1, newP2, p3];
  }
  var Pyramid = (options, context) => {
    return Funnel(Object.assign({ adjustPoints: getPyramidPoints }, options), context);
  };
  Pyramid.props = {
    defaultMarker: "square"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/createElement.js
  function createElement(descriptor) {
    const render2 = typeof descriptor === "function" ? descriptor : descriptor.render;
    return class extends CustomElement {
      connectedCallback() {
        this.draw();
      }
      attributeChangedCallback() {
        this.draw();
      }
      draw() {
        render2(this);
      }
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/line/curve.js
  var __rest15 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var DoublePath = createElement((g) => {
    const { d1, d2, style1, style2 } = g.attributes;
    const document2 = g.ownerDocument;
    select(g).maybeAppend("line", () => document2.createElement("path", {})).style("d", d1).call(applyStyle, style1);
    select(g).maybeAppend("line1", () => document2.createElement("path", {})).style("d", d2).call(applyStyle, style2);
  });
  function segmentation(points, defined4) {
    const definedPoints = [];
    const segments = [];
    let m3 = false;
    let dp = null;
    for (const p2 of points) {
      if (!defined4(p2[0]) || !defined4(p2[1]))
        m3 = true;
      else {
        definedPoints.push(p2);
        if (m3) {
          m3 = false;
          segments.push([dp, p2]);
        }
        dp = p2;
      }
    }
    return [definedPoints, segments];
  }
  var Curve = (options, context) => {
    const {
      curve,
      gradient = false,
      // The color for each segment.
      gradientColor = "between",
      defined: defined4 = (d2) => !Number.isNaN(d2) && d2 !== void 0 && d2 !== null,
      connect: connectNulls = false
    } = options, style = __rest15(options, ["curve", "gradient", "gradientColor", "defined", "connect"]);
    const { coordinate, document: document2 } = context;
    return (P, value2, defaults5) => {
      const { color: defaultColor, lineWidth: defaultSize } = defaults5, rest = __rest15(defaults5, ["color", "lineWidth"]);
      const { color: color2 = defaultColor, size: size2 = defaultSize, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
      const transform = getTransform(coordinate, value2);
      const tpShape = isTranspose(coordinate);
      const stroke2 = gradient && sc ? computeGradient(sc, sx, sy, gradient, gradientColor, tpShape) : color2;
      const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, rest), stroke2 && { stroke: stroke2 }), size2 && { lineWidth: size2 }), transform && { transform }), style);
      let linePath;
      if (isPolar(coordinate)) {
        const center2 = coordinate.getCenter();
        linePath = (points) => lineRadial_default().angle((_2, idx) => angleWithQuadrant(sub6(points[idx], center2))).radius((_2, idx) => dist4(points[idx], center2)).defined(([x3, y3]) => defined4(x3) && defined4(y3)).curve(curve)(points);
      } else {
        linePath = line_default().x((d2) => d2[0]).y((d2) => d2[1]).defined(([x3, y3]) => defined4(x3) && defined4(y3)).curve(curve);
      }
      const [DP, MS] = segmentation(P, defined4);
      const connectStyle = subObject(finalStyle, "connect");
      const missing = !!MS.length;
      if (!missing || connectNulls && !Object.keys(connectStyle).length) {
        return select(document2.createElement("path", {})).style("d", linePath(DP) || []).call(applyStyle, finalStyle).node();
      }
      if (missing && !connectNulls) {
        return select(document2.createElement("path", {})).style("d", linePath(P)).call(applyStyle, finalStyle).node();
      }
      const connectPath = (segments) => segments.map(linePath).join(",");
      return select(new DoublePath()).style("style1", Object.assign(Object.assign({}, finalStyle), connectStyle)).style("style2", finalStyle).style("d1", connectPath(MS)).style("d2", linePath(P)).node();
    };
  };
  Curve.props = {
    defaultMarker: "smooth",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/line/line.js
  var Line2 = (options, context) => {
    const { coordinate } = context;
    return (...params) => {
      const curve = isPolar(coordinate) ? linearClosed_default : linear_default;
      return Curve(Object.assign({ curve }, options), context)(...params);
    };
  };
  Line2.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/line/smooth.js
  var __rest16 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var Smooth = (options, context) => {
    const rest = __rest16(options, []);
    const { coordinate } = context;
    return (...params) => {
      const curve = isPolar(coordinate) ? catmullRomClosed_default : isTranspose(coordinate) ? monotoneY : monotoneX;
      return Curve(Object.assign({ curve }, rest), context)(...params);
    };
  };
  Smooth.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "smooth" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/line/hv.js
  var HV = (options, context) => {
    return Curve(Object.assign({ curve: stepAfter }, options), context);
  };
  HV.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hv" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/line/vh.js
  var VH = (options, context) => {
    return Curve(Object.assign({ curve: stepBefore }, options), context);
  };
  VH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "vh" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/line/hvh.js
  var HVH = (options, context) => {
    return Curve(Object.assign({ curve: step_default }, options), context);
  };
  HVH.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "hvh" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/line/trail.js
  var __rest17 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function stroke(path2, p0, p1, s0, s1) {
    const v = sub6(p1, p0);
    const a3 = angle3(v);
    const a1 = a3 + Math.PI / 2;
    const r1 = [s0 / 2 * Math.cos(a1), s0 / 2 * Math.sin(a1)];
    const r2 = [s1 / 2 * Math.cos(a1), s1 / 2 * Math.sin(a1)];
    const r3 = [s1 / 2 * Math.cos(a3), s1 / 2 * Math.sin(a3)];
    const r4 = [s0 / 2 * Math.cos(a3), s0 / 2 * Math.sin(a3)];
    const x05 = add8(p0, r1);
    const x12 = add8(p1, r2);
    const x22 = add8(x12, r3);
    const x3 = add8(p1, r3);
    const x4 = sub6(x3, r2);
    const x5 = sub6(p1, r2);
    const x6 = sub6(p0, r1);
    const x7 = sub6(x6, r4);
    const x8 = sub6(p0, r4);
    const x9 = sub6(x05, r4);
    path2.moveTo(...x05);
    path2.lineTo(...x12);
    path2.arcTo(...x22, ...x3, s1 / 2);
    path2.arcTo(...x4, ...x5, s1 / 2);
    path2.lineTo(...x6);
    path2.arcTo(...x7, ...x8, s0 / 2);
    path2.arcTo(...x9, ...x05, s0 / 2);
    path2.closePath();
  }
  var Trail = (options, context) => {
    const { document: document2 } = context;
    return (P, value2, defaults5) => {
      const { seriesSize, color: color2 } = value2;
      const { color: defaultColor } = defaults5, rest = __rest17(defaults5, ["color"]);
      const path2 = path();
      for (let i = 0; i < P.length - 1; i++) {
        const p0 = P[i];
        const p1 = P[i + 1];
        const s0 = seriesSize[i];
        const s1 = seriesSize[i + 1];
        if ([...p0, ...p1].every(defined))
          stroke(path2, p0, p1, s0, s1);
      }
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("fill", color2 || defaultColor).style("d", path2.toString()).call(applyStyle, options).node();
    };
  };
  Trail.props = Object.assign(Object.assign({}, Curve.props), { defaultMarker: "line" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/marker.js
  var __rest18 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var point4 = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3],
      ["A", r, r, 0, 1, 0, x3 + r, y3],
      ["A", r, r, 0, 1, 0, x3 - r, y3],
      ["Z"]
    ];
  };
  point4.style = ["fill"];
  var hollowPoint = point4.bind(void 0);
  hollowPoint.style = ["stroke", "lineWidth"];
  var square = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3 - r],
      ["L", x3 + r, y3 - r],
      ["L", x3 + r, y3 + r],
      ["L", x3 - r, y3 + r],
      ["Z"]
    ];
  };
  square.style = ["fill"];
  var rect2 = square.bind(void 0);
  rect2.style = ["fill"];
  var hollowSquare = square.bind(void 0);
  hollowSquare.style = ["stroke", "lineWidth"];
  var diamond = (x3, y3, r) => {
    const hr = r * 0.618;
    return [
      ["M", x3 - hr, y3],
      ["L", x3, y3 - r],
      ["L", x3 + hr, y3],
      ["L", x3, y3 + r],
      ["Z"]
    ];
  };
  diamond.style = ["fill"];
  var hollowDiamond = diamond.bind(void 0);
  hollowDiamond.style = ["stroke", "lineWidth"];
  var triangle = (x3, y3, r) => {
    const diffY = r * Math.sin(1 / 3 * Math.PI);
    return [
      ["M", x3 - r, y3 + diffY],
      ["L", x3, y3 - diffY],
      ["L", x3 + r, y3 + diffY],
      ["Z"]
    ];
  };
  triangle.style = ["fill"];
  var hollowTriangle = triangle.bind(void 0);
  hollowTriangle.style = ["stroke", "lineWidth"];
  var triangleDown = (x3, y3, r) => {
    const diffY = r * Math.sin(1 / 3 * Math.PI);
    return [
      ["M", x3 - r, y3 - diffY],
      ["L", x3 + r, y3 - diffY],
      ["L", x3, y3 + diffY],
      ["Z"]
    ];
  };
  triangleDown.style = ["fill"];
  var hollowTriangleDown = triangleDown.bind(void 0);
  hollowTriangleDown.style = ["stroke", "lineWidth"];
  var hexagon = (x3, y3, r) => {
    const diffX = r / 2 * Math.sqrt(3);
    return [
      ["M", x3, y3 - r],
      ["L", x3 + diffX, y3 - r / 2],
      ["L", x3 + diffX, y3 + r / 2],
      ["L", x3, y3 + r],
      ["L", x3 - diffX, y3 + r / 2],
      ["L", x3 - diffX, y3 - r / 2],
      ["Z"]
    ];
  };
  hexagon.style = ["fill"];
  var hollowHexagon = hexagon.bind(void 0);
  hollowHexagon.style = ["stroke", "lineWidth"];
  var bowtie = (x3, y3, r) => {
    const diffY = r - 1.5;
    return [
      ["M", x3 - r, y3 - diffY],
      ["L", x3 + r, y3 + diffY],
      ["L", x3 + r, y3 - diffY],
      ["L", x3 - r, y3 + diffY],
      ["Z"]
    ];
  };
  bowtie.style = ["fill"];
  var hollowBowtie = bowtie.bind(void 0);
  hollowBowtie.style = ["stroke", "lineWidth"];
  var line = (x3, y3, r) => {
    return [
      ["M", x3, y3 + r],
      ["L", x3, y3 - r]
    ];
  };
  line.style = ["stroke", "lineWidth"];
  var cross4 = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3 - r],
      ["L", x3 + r, y3 + r],
      ["M", x3 + r, y3 - r],
      ["L", x3 - r, y3 + r]
    ];
  };
  cross4.style = ["stroke", "lineWidth"];
  var tick = (x3, y3, r) => {
    return [
      ["M", x3 - r / 2, y3 - r],
      ["L", x3 + r / 2, y3 - r],
      ["M", x3, y3 - r],
      ["L", x3, y3 + r],
      ["M", x3 - r / 2, y3 + r],
      ["L", x3 + r / 2, y3 + r]
    ];
  };
  tick.style = ["stroke", "lineWidth"];
  var plus = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3],
      ["M", x3, y3 - r],
      ["L", x3, y3 + r]
    ];
  };
  plus.style = ["stroke", "lineWidth"];
  var hyphen = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3]
    ];
  };
  hyphen.style = ["stroke", "lineWidth"];
  var dot6 = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3]
    ];
  };
  dot6.style = ["stroke", "lineWidth"];
  var dash = dot6.bind(void 0);
  dash.style = ["stroke", "lineWidth"];
  var smooth = (x3, y3, r) => {
    return [
      ["M", x3 - r, y3],
      ["A", r / 2, r / 2, 0, 1, 1, x3, y3],
      ["A", r / 2, r / 2, 0, 1, 0, x3 + r, y3]
    ];
  };
  smooth.style = ["stroke", "lineWidth"];
  var hv = (x3, y3, r) => {
    return [
      ["M", x3 - r - 1, y3 - 2.5],
      ["L", x3, y3 - 2.5],
      ["L", x3, y3 + 2.5],
      ["L", x3 + r + 1, y3 + 2.5]
    ];
  };
  hv.style = ["stroke", "lineWidth"];
  var vh = (x3, y3, r) => {
    return [
      ["M", x3 - r - 1, y3 + 2.5],
      ["L", x3, y3 + 2.5],
      ["L", x3, y3 - 2.5],
      ["L", x3 + r + 1, y3 - 2.5]
    ];
  };
  vh.style = ["stroke", "lineWidth"];
  var hvh = (x3, y3, r) => {
    return [
      ["M", x3 - (r + 1), y3 + 2.5],
      ["L", x3 - r / 2, y3 + 2.5],
      ["L", x3 - r / 2, y3 - 2.5],
      ["L", x3 + r / 2, y3 - 2.5],
      ["L", x3 + r / 2, y3 + 2.5],
      ["L", x3 + r + 1, y3 + 2.5]
    ];
  };
  hvh.style = ["stroke", "lineWidth"];
  var vhv = (x3, y3, r) => {
    return [
      ["M", x3 - 5, y3 + 2.5],
      ["L", x3 - 5, y3],
      ["L", x3, y3],
      ["L", x3, y3 - 3],
      ["L", x3, y3 + 3],
      ["L", x3 + 6.5, y3 + 3]
    ];
  };
  vhv.style = ["stroke", "lineWidth"];
  var Symbols = /* @__PURE__ */ new Map([
    ["bowtie", bowtie],
    ["cross", cross4],
    ["dash", dash],
    ["diamond", diamond],
    ["dot", dot6],
    ["hexagon", hexagon],
    ["hollowBowtie", hollowBowtie],
    ["hollowDiamond", hollowDiamond],
    ["hollowHexagon", hollowHexagon],
    ["hollowPoint", hollowPoint],
    ["hollowSquare", hollowSquare],
    ["hollowTriangle", hollowTriangle],
    ["hollowTriangleDown", hollowTriangleDown],
    ["hv", hv],
    ["hvh", hvh],
    ["hyphen", hyphen],
    ["line", line],
    ["plus", plus],
    ["point", point4],
    ["rect", rect2],
    ["smooth", smooth],
    ["square", square],
    ["tick", tick],
    ["triangleDown", triangleDown],
    ["triangle", triangle],
    ["vh", vh],
    ["vhv", vhv]
  ]);
  function useMarker(type, _a) {
    var { d: d2, fill, lineWidth, path: path2, stroke: stroke2, color: color2 } = _a, style = __rest18(_a, ["d", "fill", "lineWidth", "path", "stroke", "color"]);
    const symbol = Symbols.get(type) || Symbols.get("point");
    return (...args) => {
      const path3 = new Path2({
        style: Object.assign(Object.assign({}, style), { d: symbol(...args), stroke: symbol.style.includes("stroke") ? color2 || stroke2 : "", fill: symbol.style.includes("fill") ? color2 || fill : "", lineWidth: symbol.style.includes("lineWidth") ? lineWidth || lineWidth || 2 : 0 })
      });
      return path3;
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/color.js
  var __rest19 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function getRadius2(mode, points, value2, coordinate) {
    if (points.length === 1)
      return void 0;
    const { size: size2 } = value2;
    if (mode === "fixed")
      return size2;
    if (mode === "normal" || isFisheye(coordinate)) {
      const [[x05, y05], [x22, y22]] = points;
      const a3 = Math.abs((x22 - x05) / 2);
      const b = Math.abs((y22 - y05) / 2);
      return Math.max(0, (a3 + b) / 2);
    }
    return size2;
  }
  var Color3 = (options, context) => {
    const { colorAttribute, symbol, mode = "auto" } = options, style = __rest19(options, ["colorAttribute", "symbol", "mode"]);
    const path2 = Symbols.get(symbol) || Symbols.get("point");
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { lineWidth, color: defaultColor } = defaults5;
      const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;
      const { color: color2 = defaultColor, transform, opacity } = value2;
      const [cx, cy] = getOrigin(points);
      const r = getRadius2(mode, points, value2, coordinate);
      const finalRadius = r || style.r || defaults5.r;
      return select(document2.createElement("path", {})).call(applyStyle, defaults5).style("fill", "transparent").style("d", path2(cx, cy, finalRadius)).style("lineWidth", finalLineWidth).style("transform", transform).style("transformOrigin", `${cx - finalRadius} ${cy - finalRadius}`).style("stroke", color2).style(toOpacityKey(options), opacity).style(colorAttribute, color2).call(applyStyle, style).node();
    };
  };
  Color3.props = {
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/hollowBowtie.js
  var HollowBowtie = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "bowtie" }, options), context);
  };
  HollowBowtie.props = Object.assign({ defaultMarker: "hollowBowtie" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/hollowDiamond.js
  var HollowDiamond = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "diamond" }, options), context);
  };
  HollowDiamond.props = Object.assign({ defaultMarker: "hollowDiamond" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/hollowHexagon.js
  var HollowHexagon = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "hexagon" }, options), context);
  };
  HollowHexagon.props = Object.assign({ defaultMarker: "hollowHexagon" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/hollow.js
  var HollowPoint = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "point" }, options), context);
  };
  HollowPoint.props = Object.assign({ defaultMarker: "hollowPoint" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/hollowSquare.js
  var HollowSquare = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "square" }, options), context);
  };
  HollowSquare.props = Object.assign({ defaultMarker: "hollowSquare" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/hollowTriangle.js
  var HollowTriangle = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "triangle" }, options), context);
  };
  HollowTriangle.props = Object.assign({ defaultMarker: "hollowTriangle" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/hollowTriangleDown.js
  var HollowTriangleDown = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "triangle-down" }, options), context);
  };
  HollowTriangleDown.props = Object.assign({ defaultMarker: "hollowTriangleDown" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/circle.js
  var __rest20 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var BaseCircle = (options, context) => {
    const { colorAttribute, mode = "auto" } = options, style = __rest20(options, ["colorAttribute", "mode"]);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { lineWidth, color: defaultColor } = defaults5;
      const finalLineWidth = style.stroke ? lineWidth || 1 : lineWidth;
      const { color: color2 = defaultColor, transform, opacity } = value2;
      const [cx, cy] = getOrigin(points);
      const r = getRadius2(mode, points, value2, coordinate);
      const finalRadius = r || style.r || defaults5.r;
      return select(document2.createElement("circle", {})).call(applyStyle, defaults5).style("fill", "transparent").style("cx", cx).style("cy", cy).style("r", finalRadius).style("lineWidth", finalLineWidth).style("transform", transform).style("transformOrigin", `${cx} ${cy}`).style("stroke", color2).style(toOpacityKey(options), opacity).style(colorAttribute, color2).call(applyStyle, style).node();
    };
  };
  var Circle2 = (options, context) => {
    return BaseCircle(Object.assign({ colorAttribute: "fill" }, options), context);
  };
  Circle2.props = {
    defaultMarker: "circle",
    defaultEnterAnimation: "fadeIn",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/hollowCircle.js
  var HollowCircle = (options, context) => {
    return BaseCircle(Object.assign({ colorAttribute: "stroke" }, options), context);
  };
  HollowCircle.props = Object.assign({ defaultMarker: "hollowPoint" }, Circle2.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/bowtie.js
  var Bowtie = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "bowtie" }, options), context);
  };
  Bowtie.props = Object.assign({ defaultMarker: "bowtie" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/cross.js
  var Cross = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "cross" }, options), context);
  };
  Cross.props = Object.assign({ defaultMarker: "cross" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/diamond.js
  var Diamond = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "diamond" }, options), context);
  };
  Diamond.props = Object.assign({ defaultMarker: "diamond" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/hexagon.js
  var Hexagon = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "hexagon" }, options), context);
  };
  Hexagon.props = Object.assign({ defaultMarker: "hexagon" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/hyphen.js
  var Hyphen = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "hyphen" }, options), context);
  };
  Hyphen.props = Object.assign({ defaultMarker: "hyphen" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/line.js
  var Line3 = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "line" }, options), context);
  };
  Line3.props = Object.assign({ defaultMarker: "line" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/plus.js
  var Plus = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "plus" }, options), context);
  };
  Plus.props = Object.assign({ defaultMarker: "plus" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/point.js
  var Point3 = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "point" }, options), context);
  };
  Point3.props = Object.assign({ defaultMarker: "point" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/square.js
  var Square = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "square" }, options), context);
  };
  Square.props = Object.assign({ defaultMarker: "square" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/tick.js
  var Tick = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "stroke", symbol: "tick" }, options), context);
  };
  Tick.props = Object.assign({ defaultMarker: "tick" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/triangle.js
  var Triangle = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "triangle" }, options), context);
  };
  Triangle.props = Object.assign({ defaultMarker: "triangle" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/point/triangleDown.js
  var TriangleDown = (options, context) => {
    return Color3(Object.assign({ colorAttribute: "fill", symbol: "triangle-down" }, options), context);
  };
  TriangleDown.props = Object.assign({ defaultMarker: "triangleDown" }, Color3.props);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/vector/vector.js
  var __rest21 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var Vector = (options, context) => {
    const { arrow = true, arrowSize = "40%" } = options, style = __rest21(options, ["arrow", "arrowSize"]);
    const { document: document2 } = context;
    return (points, value2, defaults5) => {
      const { defaultColor } = defaults5, rest = __rest21(defaults5, ["defaultColor"]);
      const { color: color2 = defaultColor, transform } = value2;
      const [from, to] = points;
      const path2 = path();
      path2.moveTo(...from);
      path2.lineTo(...to);
      if (arrow) {
        const [arrow1, arrow2] = arrowPoints(from, to, { arrowSize });
        path2.moveTo(...arrow1);
        path2.lineTo(...to);
        path2.lineTo(...arrow2);
      }
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("transform", transform).call(applyStyle, style).node();
    };
  };
  Vector.props = {
    defaultMarker: "line",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/is-array-like.js
  var isArrayLike2 = function(value2) {
    return value2 !== null && typeof value2 !== "function" && isFinite(value2.length);
  };
  var is_array_like_default2 = isArrayLike2;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/is-function.js
  var is_function_default2 = function(value2) {
    return typeof value2 === "function";
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/is-nil.js
  var isNil4 = function(value2) {
    return value2 === null || value2 === void 0;
  };
  var is_nil_default4 = isNil4;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/is-type.js
  var toString5 = {}.toString;
  var isType5 = function(value2, type) {
    return toString5.call(value2) === "[object " + type + "]";
  };
  var is_type_default5 = isType5;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/is-array.js
  var is_array_default3 = function(value2) {
    return Array.isArray ? Array.isArray(value2) : is_type_default5(value2, "Array");
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/is-object.js
  var is_object_default3 = function(value2) {
    var type = typeof value2;
    return value2 !== null && type === "object" || type === "function";
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/is-object-like.js
  var isObjectLike2 = function(value2) {
    return typeof value2 === "object" && value2 !== null;
  };
  var is_object_like_default2 = isObjectLike2;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/is-plain-object.js
  var isPlainObject2 = function(value2) {
    if (!is_object_like_default2(value2) || !is_type_default5(value2, "Object")) {
      return false;
    }
    if (Object.getPrototypeOf(value2) === null) {
      return true;
    }
    var proto = value2;
    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value2) === proto;
  };
  var is_plain_object_default2 = isPlainObject2;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/max.js
  var max_default2 = function(arr) {
    if (!is_array_default3(arr)) {
      return void 0;
    }
    return arr.reduce(function(prev, curr) {
      return Math.max(prev, curr);
    }, arr[0]);
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/min.js
  var min_default2 = function(arr) {
    if (!is_array_default3(arr)) {
      return void 0;
    }
    return arr.reduce(function(prev, curr) {
      return Math.min(prev, curr);
    }, arr[0]);
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/is-string.js
  var is_string_default4 = function(str7) {
    return is_type_default5(str7, "String");
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/clamp.js
  var clamp4 = function(a3, min10, max10) {
    if (a3 < min10) {
      return min10;
    } else if (a3 > max10) {
      return max10;
    }
    return a3;
  };
  var clamp_default3 = clamp4;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/is-number.js
  var isNumber6 = function(value2) {
    return is_type_default5(value2, "Number");
  };
  var is_number_default5 = isNumber6;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/max-by.js
  var max_by_default = function(arr, fn) {
    if (!is_array_default3(arr)) {
      return void 0;
    }
    var maxItem;
    var max10 = -Infinity;
    for (var i = 0; i < arr.length; i++) {
      var item = arr[i];
      var v = is_function_default2(fn) ? fn(item) : item[fn];
      if (v > max10) {
        maxItem = item;
        max10 = v;
      }
    }
    return maxItem;
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/min-by.js
  var min_by_default = function(arr, fn) {
    if (!is_array_default3(arr)) {
      return void 0;
    }
    var minItem;
    var min10 = Infinity;
    for (var i = 0; i < arr.length; i++) {
      var item = arr[i];
      var v = is_function_default2(fn) ? fn(item) : item[fn];
      if (v < min10) {
        minItem = item;
        min10 = v;
      }
    }
    return minItem;
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/substitute.js
  function substitute(str7, o) {
    if (!str7 || !o) {
      return str7;
    }
    return str7.replace(/\\?\{([^{}]+)\}/g, function(match2, name2) {
      if (match2.charAt(0) === "\\") {
        return match2.slice(1);
      }
      return o[name2] === void 0 ? "" : o[name2];
    });
  }
  var substitute_default = substitute;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/is-null.js
  var isNull2 = function(value2) {
    return value2 === null;
  };
  var is_null_default2 = isNull2;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/is-undefined.js
  var isUndefined4 = function(value2) {
    return value2 === void 0;
  };
  var is_undefined_default3 = isUndefined4;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/clone.js
  var clone10 = function(obj) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    var rst;
    if (is_array_default3(obj)) {
      rst = [];
      for (var i = 0, l2 = obj.length; i < l2; i++) {
        if (typeof obj[i] === "object" && obj[i] != null) {
          rst[i] = clone10(obj[i]);
        } else {
          rst[i] = obj[i];
        }
      }
    } else {
      rst = {};
      for (var k in obj) {
        if (typeof obj[k] === "object" && obj[k] != null) {
          rst[k] = clone10(obj[k]);
        } else {
          rst[k] = obj[k];
        }
      }
    }
    return rst;
  };
  var clone_default = clone10;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/debounce.js
  function debounce3(func, wait, immediate) {
    var timeout2;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout2 = null;
        if (!immediate) {
          func.apply(context, args);
        }
      };
      var callNow = immediate && !timeout2;
      clearTimeout(timeout2);
      timeout2 = setTimeout(later, wait);
      if (callNow) {
        func.apply(context, args);
      }
    };
  }
  var debounce_default2 = debounce3;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/memoize.js
  function flru(max10) {
    var num, curr, prev;
    var limit = max10 || 1;
    function keep(key, value2) {
      if (++num > limit) {
        prev = curr;
        reset(1);
        ++num;
      }
      curr[key] = value2;
    }
    function reset(isPartial) {
      num = 0;
      curr = /* @__PURE__ */ Object.create(null);
      isPartial || (prev = /* @__PURE__ */ Object.create(null));
    }
    reset();
    return {
      clear: reset,
      has: function(key) {
        return curr[key] !== void 0 || prev[key] !== void 0;
      },
      get: function(key) {
        var val = curr[key];
        if (val !== void 0)
          return val;
        if ((val = prev[key]) !== void 0) {
          keep(key, val);
          return val;
        }
      },
      set: function(key, value2) {
        if (curr[key] !== void 0) {
          curr[key] = value2;
        } else {
          keep(key, value2);
        }
      }
    };
  }
  var memoize_default = function(f, resolver, maxSize) {
    if (maxSize === void 0) {
      maxSize = 128;
    }
    if (!is_function_default2(f)) {
      throw new TypeError("Expected a function");
    }
    var memoized = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var key = resolver ? resolver.apply(this, args) : args[0];
      var cache3 = memoized.cache;
      if (cache3.has(key)) {
        return cache3.get(key);
      }
      var result = f.apply(this, args);
      cache3.set(key, result);
      return result;
    };
    memoized.cache = flru(maxSize);
    return memoized;
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/deep-mix.js
  var MAX_MIX_LEVEL2 = 5;
  function hasOwn2(object, property) {
    if (Object.hasOwn) {
      return Object.hasOwn(object, property);
    }
    if (object == null) {
      throw new TypeError("Cannot convert undefined or null to object");
    }
    return Object.prototype.hasOwnProperty.call(Object(object), property);
  }
  function _deepMix2(dist5, src, level, maxLevel) {
    level = level || 0;
    maxLevel = maxLevel || MAX_MIX_LEVEL2;
    for (var key in src) {
      if (hasOwn2(src, key)) {
        var value2 = src[key];
        if (value2 !== null && is_plain_object_default2(value2)) {
          if (!is_plain_object_default2(dist5[key])) {
            dist5[key] = {};
          }
          if (level < maxLevel) {
            _deepMix2(dist5[key], value2, level + 1, maxLevel);
          } else {
            dist5[key] = src[key];
          }
        } else if (is_array_default3(value2)) {
          dist5[key] = [];
          dist5[key] = dist5[key].concat(value2);
        } else if (value2 !== void 0) {
          dist5[key] = value2;
        }
      }
    }
  }
  var deepMix2 = function(rst) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i += 1) {
      _deepMix2(rst, args[i]);
    }
    return rst;
  };
  var deep_mix_default2 = deepMix2;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/is-equal.js
  var isEqual2 = function(value2, other) {
    if (value2 === other) {
      return true;
    }
    if (!value2 || !other) {
      return false;
    }
    if (is_string_default4(value2) || is_string_default4(other)) {
      return false;
    }
    if (is_array_like_default2(value2) || is_array_like_default2(other)) {
      if (value2.length !== other.length) {
        return false;
      }
      var rst = true;
      for (var i = 0; i < value2.length; i++) {
        rst = isEqual2(value2[i], other[i]);
        if (!rst) {
          break;
        }
      }
      return rst;
    }
    if (is_object_like_default2(value2) || is_object_like_default2(other)) {
      var valueKeys = Object.keys(value2);
      var otherKeys = Object.keys(other);
      if (valueKeys.length !== otherKeys.length) {
        return false;
      }
      var rst = true;
      for (var i = 0; i < valueKeys.length; i++) {
        rst = isEqual2(value2[valueKeys[i]], other[valueKeys[i]]);
        if (!rst) {
          break;
        }
      }
      return rst;
    }
    return false;
  };
  var is_equal_default2 = isEqual2;

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/get.js
  var get_default2 = function(obj, key, defaultValue) {
    var p2 = 0;
    var keyArr = is_string_default4(key) ? key.split(".") : key;
    while (obj && p2 < keyArr.length) {
      obj = obj[keyArr[p2++]];
    }
    return obj === void 0 || p2 < keyArr.length ? defaultValue : obj;
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/set.js
  var set_default = function(obj, path2, value2) {
    var o = obj;
    var keyArr = is_string_default4(path2) ? path2.split(".") : path2;
    keyArr.forEach(function(key, idx) {
      if (idx < keyArr.length - 1) {
        if (!is_object_default3(o[key])) {
          o[key] = is_number_default5(keyArr[idx + 1]) ? [] : {};
        }
        o = o[key];
      } else {
        o[key] = value2;
      }
    });
    return obj;
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/noop.js
  var noop_default2 = function() {
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/lodash/identity.js
  var identity_default2 = function(v) {
    return v;
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/util/esm/dom/create-dom.js
  function createDOM(str7) {
    var container = document.createElement("div");
    container.innerHTML = str7;
    var dom2 = container.childNodes[0];
    if (dom2 && container.contains(dom2)) {
      container.removeChild(dom2);
    }
    return dom2;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/traverse.js
  function traverse(element, callback) {
    callback(element);
    if (element.children) {
      element.children.forEach(function(child) {
        if (child)
          traverse(child, callback);
      });
    }
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/visibility.js
  function show(element) {
    visibility(element, true);
  }
  function hide(element) {
    visibility(element, false);
  }
  function visibility(element, visible) {
    var value2 = visible ? "visible" : "hidden";
    traverse(element, function(node) {
      node.attr("visibility", value2);
    });
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/offscreen.js
  var OffscreenGroup = (
    /** @class */
    function(_super) {
      __extends(OffscreenGroup2, _super);
      function OffscreenGroup2() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
        _this.isMutationObserved = true;
        _this.addEventListener(ElementEvent.INSERTED, function() {
          hide(_this);
        });
        return _this;
      }
      return OffscreenGroup2;
    }(Group2)
  );
  function createOffscreenGroup(container) {
    var group3 = container.appendChild(new OffscreenGroup({
      class: "offscreen"
    }));
    hide(group3);
    return group3;
  }
  function isInOffscreenGroup(group3) {
    var ancestor = group3;
    while (ancestor) {
      if (ancestor.className === "offscreen") {
        return true;
      }
      ancestor = ancestor.parent;
    }
    return false;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/shapes/Text.js
  var Text2 = (
    /** @class */
    function(_super) {
      __extends(Text5, _super);
      function Text5(_a) {
        if (_a === void 0) {
          _a = {};
        }
        var style = _a.style, restOptions = __rest(_a, ["style"]);
        return _super.call(this, __assign({ style: __assign({ text: "", fill: "black", fontFamily: "sans-serif", fontSize: 16, fontStyle: "normal", fontVariant: "normal", fontWeight: "normal", lineWidth: 1, textAlign: "start", textBaseline: "middle" }, style) }, restOptions)) || this;
      }
      Object.defineProperty(Text5.prototype, "offscreenGroup", {
        get: function() {
          if (!this._offscreen)
            this._offscreen = createOffscreenGroup(this);
          return this._offscreen;
        },
        enumerable: false,
        configurable: true
      });
      Text5.prototype.disconnectedCallback = function() {
        var _a;
        (_a = this._offscreen) === null || _a === void 0 ? void 0 : _a.destroy();
      };
      return Text5;
    }(Text)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/angle-converter.js
  function degToRad(deg) {
    return deg * Math.PI / 180;
  }
  function radToDeg(rad) {
    return Number((rad * 180 / Math.PI).toPrecision(5));
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/bbox.js
  var BBox = (
    /** @class */
    function() {
      function BBox2(x3, y3, width, height) {
        if (x3 === void 0) {
          x3 = 0;
        }
        if (y3 === void 0) {
          y3 = 0;
        }
        if (width === void 0) {
          width = 0;
        }
        if (height === void 0) {
          height = 0;
        }
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
        this.x = x3;
        this.y = y3;
        this.width = width;
        this.height = height;
      }
      Object.defineProperty(BBox2.prototype, "bottom", {
        get: function() {
          return this.y + this.height;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BBox2.prototype, "left", {
        get: function() {
          return this.x;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BBox2.prototype, "right", {
        get: function() {
          return this.x + this.width;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(BBox2.prototype, "top", {
        get: function() {
          return this.y;
        },
        enumerable: false,
        configurable: true
      });
      BBox2.fromRect = function(other) {
        return new BBox2(other.x, other.y, other.width, other.height);
      };
      BBox2.prototype.toJSON = function() {
        return {
          x: this.x,
          y: this.y,
          width: this.width,
          height: this.height,
          top: this.top,
          right: this.right,
          bottom: this.bottom,
          left: this.left
        };
      };
      BBox2.prototype.isPointIn = function(x3, y3) {
        return x3 >= this.left && x3 <= this.right && y3 >= this.top && y3 <= this.bottom;
      };
      return BBox2;
    }()
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/callback.js
  function getCallbackValue(value2, params) {
    return is_function_default2(value2) ? value2.apply(void 0, __spreadArray([], __read(params), false)) : value2;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/classnames.js
  var classNames = function(cls, prefix) {
    var PREFIX = function(str7) {
      return "".concat(prefix, "-").concat(str7);
    };
    var obj = Object.fromEntries(Object.entries(cls).map(function(_a) {
      var _b = __read(_a, 2), k = _b[0], v = _b[1];
      var name2 = PREFIX(v);
      return [
        k,
        {
          name: name2,
          class: ".".concat(name2),
          id: "#".concat(name2),
          toString: function() {
            return name2;
          }
        }
      ];
    }));
    Object.assign(obj, { prefix: PREFIX });
    return obj;
  };

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/deep-assign.js
  var MAX_MIX_LEVEL3 = 5;
  var deep = function(dist5, src, level, maxLevel) {
    if (level === void 0) {
      level = 0;
    }
    if (maxLevel === void 0) {
      maxLevel = MAX_MIX_LEVEL3;
    }
    Object.entries(src).forEach(function(_a) {
      var _b = __read(_a, 2), key = _b[0], value2 = _b[1];
      var res = dist5;
      if (Object.prototype.hasOwnProperty.call(src, key)) {
        if (!value2) {
          res[key] = value2;
        } else if (is_plain_object_default2(value2)) {
          if (!is_plain_object_default2(dist5[key])) {
            res[key] = {};
          }
          if (level < maxLevel) {
            deep(dist5[key], value2, level + 1, maxLevel);
          } else {
            res[key] = src[key];
          }
        } else if (is_array_default3(value2)) {
          res[key] = [];
          res[key] = res[key].concat(value2);
        } else {
          res[key] = value2;
        }
      }
    });
  };
  var deepAssign2 = function(rst) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i += 1) {
      deep(rst, args[i]);
    }
    return rst;
  };

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/defined.js
  var defined2 = function(x3) {
    return x3 !== void 0 && x3 != null && !Number.isNaN(x3);
  };

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/text.js
  var ctx;
  var mockMeasureTextWidth;
  var measureTextWidth = memoize_default(function(text, font) {
    var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
    if (mockMeasureTextWidth) {
      return mockMeasureTextWidth(text, fontSize);
    }
    if (!ctx) {
      ctx = runtime.offscreenCanvasCreator.getOrCreateContext(void 0);
    }
    ctx.font = [fontStyle, fontVariant, fontWeight, "".concat(fontSize, "px"), fontFamily].join(" ");
    return ctx.measureText(text).width;
  }, function(text, font) {
    return [text, Object.values(font || getFont(text)).join()].join("");
  }, 4096);
  var getFont = function(textShape) {
    var fontFamily = textShape.style.fontFamily || "sans-serif";
    var fontWeight = textShape.style.fontWeight || "normal";
    var fontStyle = textShape.style.fontStyle || "normal";
    var fontVariant = textShape.style.fontVariant;
    var fontSize = textShape.style.fontSize;
    fontSize = typeof fontSize === "object" ? fontSize.value : fontSize;
    return { fontSize, fontFamily, fontWeight, fontStyle, fontVariant };
  };
  function textOf(node) {
    if (node.nodeName === "text") {
      return node;
    }
    if (node.nodeName === "g" && node.children.length === 1 && node.children[0].nodeName === "text") {
      return node.children[0];
    }
    return null;
  }
  function applyToText(node, style) {
    var text = textOf(node);
    if (text)
      text.attr(style);
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/ellipsis.js
  function ellipsisIt(node, w, suffix) {
    if (suffix === void 0) {
      suffix = "...";
    }
    applyToText(node, { wordWrap: true, wordWrapWidth: w, maxLines: 1, textOverflow: suffix });
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/wrap.js
  function wrapIt(node, wordWrapWidth, maxLines, textBaseline) {
    if (maxLines === void 0) {
      maxLines = 2;
    }
    if (textBaseline === void 0) {
      textBaseline = "top";
    }
    applyToText(node, { wordWrap: true, wordWrapWidth, maxLines, textBaseline });
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/event.js
  function getEventPos(e3) {
    var canvas = e3.canvas, touches = e3.touches, offsetX = e3.offsetX, offsetY = e3.offsetY;
    if (canvas) {
      var x3 = canvas.x, y3 = canvas.y;
      return [x3, y3];
    }
    if (touches) {
      var _a = touches[0], clientX = _a.clientX, clientY = _a.clientY;
      return [clientX, clientY];
    }
    if (offsetX && offsetY)
      return [offsetX, offsetY];
    return [0, 0];
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/extend-display-object.js
  function renderExtDo(el) {
    if (typeof el === "function")
      return el();
    return is_string_default4(el) || is_number_default5(el) ? new Text2({ style: { text: String(el) } }) : el;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/group-by.js
  function groupBy(source, by) {
    return source.reduce(function(acc, curr) {
      (acc[curr[by]] = acc[curr[by]] || []).push(curr);
      return acc;
    }, {});
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/if-show.js
  function ifShow(show3, container, creator, removeChildren, removeHandler) {
    if (removeChildren === void 0) {
      removeChildren = true;
    }
    if (removeHandler === void 0) {
      removeHandler = function(g) {
        g.node().removeChildren();
      };
    }
    if (show3) {
      return creator(container);
    }
    if (removeChildren)
      removeHandler(container);
    return null;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/in-range.js
  function inRange(n2, start2, end, includeLeft, includeRight) {
    if (includeLeft === void 0) {
      includeLeft = true;
    }
    if (includeRight === void 0) {
      includeRight = false;
    }
    if (includeLeft && n2 === start2 || includeRight && n2 === end)
      return true;
    return n2 > start2 && n2 < end;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/interpolate.js
  var numberInterpolate = function(from, to) {
    return function(t) {
      return from * (1 - t) + to * t;
    };
  };
  function arrayInterpolate(from, to) {
    var nb = to ? to.length : 0;
    var na = from ? Math.min(nb, from.length) : 0;
    return function(t) {
      var x3 = new Array(na);
      var c5 = new Array(nb);
      var i = 0;
      for (i = 0; i < na; ++i)
        x3[i] = interpolate4(from[i], to[i]);
      for (; i < nb; ++i)
        c5[i] = to[i];
      for (i = 0; i < na; ++i)
        c5[i] = x3[i](t);
      return c5;
    };
  }
  function objectInterpolate(from, to) {
    if (from === void 0) {
      from = {};
    }
    if (to === void 0) {
      to = {};
    }
    var i = {};
    var c5 = {};
    Object.entries(to).forEach(function(_a) {
      var _b = __read(_a, 2), k = _b[0], v = _b[1];
      if (k in from)
        i[k] = interpolate4(from[k], v);
      else
        c5[k] = v;
    });
    return function(t) {
      Object.entries(i).forEach(function(_a) {
        var _b = __read(_a, 2), k = _b[0], v = _b[1];
        return c5[k] = v(t);
      });
      return c5;
    };
  }
  function interpolate4(from, to) {
    if (typeof from === "number" && typeof to === "number") {
      return numberInterpolate(from, to);
    }
    if (Array.isArray(from) && Array.isArray(to)) {
      return arrayInterpolate(from, to);
    }
    if (typeof from === "object" && typeof to === "object") {
      return objectInterpolate(from, to);
    }
    return function(t) {
      return from;
    };
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/keyframe-interpolate.js
  function keyframeInterpolate(element, from, to, options) {
    if (!options) {
      element.attr("__keyframe_data__", to);
      return null;
    }
    var _a = options.duration, duration = _a === void 0 ? 0 : _a;
    var int2 = interpolate4(from, to);
    var count4 = Math.ceil(+duration / 16);
    var keyframes = new Array(count4).fill(0).map(function(datum, index4, array2) {
      return { __keyframe_data__: int2(index4 / (array2.length - 1)) };
    });
    return element.animate(keyframes, __assign({ fill: "both" }, options));
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/layout/utils/helper.js
  function getItemsBBox(items) {
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY2 = -Infinity;
    for (var i = 0; i < items.length; i++) {
      var _a = items[i], x3 = _a.x, y3 = _a.y, width = _a.width, height = _a.height;
      var _b = __read([x3 + width, y3 + height], 2), X = _b[0], Y = _b[1];
      if (x3 < minX)
        minX = x3;
      if (y3 < minY)
        minY = y3;
      if (X > maxX)
        maxX = X;
      if (Y > maxY2)
        maxY2 = Y;
    }
    return new BBox(minX, minY, maxX - minX, maxY2 - minY);
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/layout/flex/index.js
  var flex = function(container, children, config2) {
    var width = container.width, height = container.height;
    var _a = config2.flexDirection, flexDirection = _a === void 0 ? "row" : _a, _b = config2.flexWrap, flexWrap = _b === void 0 ? "nowrap" : _b, _c = config2.justifyContent, justifyContent = _c === void 0 ? "flex-start" : _c, _d = config2.alignContent, alignContent = _d === void 0 ? "flex-start" : _d, _e = config2.alignItems, alignItems = _e === void 0 ? "flex-start" : _e;
    var isHorizontalFlow = flexDirection === "row";
    var isLeftToRightFlow = flexDirection === "row" || flexDirection === "column";
    var direction2 = isHorizontalFlow ? isLeftToRightFlow ? [1, 0] : [-1, 0] : isLeftToRightFlow ? [0, 1] : [0, -1];
    var _f = __read([0, 0], 2), offsetX = _f[0], offsetY = _f[1];
    var itemsFromDirection = children.map(function(child) {
      var _a2;
      var width2 = child.width, height2 = child.height;
      var _b2 = __read([offsetX, offsetY], 2), x3 = _b2[0], y3 = _b2[1];
      _a2 = __read([offsetX + width2 * direction2[0], offsetY + height2 * direction2[1]], 2), offsetX = _a2[0], offsetY = _a2[1];
      return new BBox(x3, y3, width2, height2);
    });
    var itemsForJustifyContentBBox = getItemsBBox(itemsFromDirection);
    var justifyContentOffset = {
      "flex-start": 0,
      "flex-end": isHorizontalFlow ? width - itemsForJustifyContentBBox.width : height - itemsForJustifyContentBBox.height,
      center: isHorizontalFlow ? (width - itemsForJustifyContentBBox.width) / 2 : (height - itemsForJustifyContentBBox.height) / 2
    };
    var itemsFromJustifyContent = itemsFromDirection.map(function(item) {
      var x3 = item.x, y3 = item.y;
      var itemBox = BBox.fromRect(item);
      itemBox.x = isHorizontalFlow ? x3 + justifyContentOffset[justifyContent] : x3;
      itemBox.y = isHorizontalFlow ? y3 : y3 + justifyContentOffset[justifyContent];
      return itemBox;
    });
    var itemsForAlignItemsBBox = getItemsBBox(itemsFromJustifyContent);
    var calcAlignItemsOffset = function(box2) {
      var _a2 = __read(isHorizontalFlow ? ["height", height] : ["width", width], 2), key = _a2[0], size2 = _a2[1];
      switch (alignItems) {
        case "flex-start":
          return 0;
        case "flex-end":
          return size2 - box2[key];
        case "center":
          return size2 / 2 - box2[key] / 2;
        default:
          return 0;
      }
    };
    var itemsFromAlignItems = itemsFromJustifyContent.map(function(item) {
      var x3 = item.x, y3 = item.y;
      var itemBox = BBox.fromRect(item);
      itemBox.x = isHorizontalFlow ? x3 : x3 + calcAlignItemsOffset(itemBox);
      itemBox.y = isHorizontalFlow ? y3 + calcAlignItemsOffset(itemBox) : y3;
      return itemBox;
    });
    var finalItems = itemsFromAlignItems.map(function(item) {
      var _a2, _b2;
      var itemBox = BBox.fromRect(item);
      itemBox.x += (_a2 = container.x) !== null && _a2 !== void 0 ? _a2 : 0;
      itemBox.y += (_b2 = container.y) !== null && _b2 !== void 0 ? _b2 : 0;
      return itemBox;
    });
    return finalItems;
  };

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/layout/grid/index.js
  var grid = function(container, children, config2) {
    return [];
  };

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/layout/executer.js
  var executer_default = function(container, children, config2) {
    if (children.length === 0)
      return [];
    var callers = { flex, grid };
    var caller = config2.display in callers ? callers[config2.display] : null;
    return (caller === null || caller === void 0 ? void 0 : caller.call(null, container, children, config2)) || [];
  };

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/matrix.js
  function scale7(vec, s2) {
    return [vec[0] * s2, vec[1] * s2];
  }
  function add9(vec1, vec2) {
    return [vec1[0] + vec2[0], vec1[1] + vec2[1]];
  }
  function sub7(vec1, vec2) {
    return [vec1[0] - vec2[0], vec1[1] - vec2[1]];
  }
  function min8(vec1, vec2) {
    return [Math.min(vec1[0], vec2[0]), Math.min(vec1[1], vec2[1])];
  }
  function max8(vec1, vec2) {
    return [Math.max(vec1[0], vec2[0]), Math.max(vec1[1], vec2[1])];
  }
  function distance5(vec1, vec2) {
    return Math.sqrt(Math.pow(vec1[0] - vec2[0], 2) + Math.pow(vec1[1] - vec2[1], 2));
  }
  function normalize7(vec) {
    if (vec[0] === 0 && vec[1] === 0)
      return [0, 0];
    var len5 = Math.sqrt(Math.pow(vec[0], 2) + Math.pow(vec[1], 2));
    return [vec[0] / len5, vec[1] / len5];
  }
  function vertical(vec, flag) {
    return flag ? [vec[1], -vec[0]] : [-vec[1], vec[0]];
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/number.js
  function toPrecision(num, precision) {
    return +num.toPrecision(precision);
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/omit.js
  function omit(obj, keys2) {
    var res = {};
    var innerKeys = Array.isArray(keys2) ? keys2 : [keys2];
    for (var key in obj) {
      if (!innerKeys.includes(key)) {
        res[key] = obj[key];
      }
    }
    return res;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/path.js
  function smoothBezier(points, smooth3, isLoop, constraint) {
    var _a;
    var cps = [];
    var hasConstraint = !!constraint;
    var prevPoint;
    var nextPoint;
    var min10 = [Infinity, Infinity];
    var max10 = [-Infinity, -Infinity];
    var nextCp0;
    var cp1;
    var cp0;
    if (hasConstraint) {
      _a = __read(constraint, 2), min10 = _a[0], max10 = _a[1];
      for (var i = 0, l2 = points.length; i < l2; i += 1) {
        var point6 = points[i];
        min10 = min8(min10, point6);
        max10 = max8(max10, point6);
      }
    }
    for (var i = 0, len5 = points.length; i < len5; i += 1) {
      var point6 = points[i];
      if (i === 0 && !isLoop) {
        cp0 = point6;
      } else if (i === len5 - 1 && !isLoop) {
        cp1 = point6;
        cps.push(cp0);
        cps.push(cp1);
      } else {
        var prevIdx = [i ? i - 1 : len5 - 1, i - 1][isLoop ? 0 : 1];
        prevPoint = points[prevIdx];
        nextPoint = points[isLoop ? (i + 1) % len5 : i + 1];
        var v = [0, 0];
        v = sub7(nextPoint, prevPoint);
        v = scale7(v, smooth3);
        var d0 = distance5(point6, prevPoint);
        var d1 = distance5(point6, nextPoint);
        var sum3 = d0 + d1;
        if (sum3 !== 0) {
          d0 /= sum3;
          d1 /= sum3;
        }
        var v1 = scale7(v, -d0);
        var v2 = scale7(v, d1);
        cp1 = add9(point6, v1);
        nextCp0 = add9(point6, v2);
        nextCp0 = min8(nextCp0, max8(nextPoint, point6));
        nextCp0 = max8(nextCp0, min8(nextPoint, point6));
        v1 = sub7(nextCp0, point6);
        v1 = scale7(v1, -d0 / d1);
        cp1 = add9(point6, v1);
        cp1 = min8(cp1, max8(prevPoint, point6));
        cp1 = max8(cp1, min8(prevPoint, point6));
        v2 = sub7(point6, cp1);
        v2 = scale7(v2, d1 / d0);
        nextCp0 = add9(point6, v2);
        if (hasConstraint) {
          cp1 = max8(cp1, min10);
          cp1 = min8(cp1, max10);
          nextCp0 = max8(nextCp0, min10);
          nextCp0 = min8(nextCp0, max10);
        }
        cps.push(cp0);
        cps.push(cp1);
        cp0 = nextCp0;
      }
    }
    if (isLoop) {
      cps.push(cps.shift());
    }
    return cps;
  }
  function catmullRom2Bezier(crp, z, constraint) {
    var _a;
    if (z === void 0) {
      z = false;
    }
    if (constraint === void 0) {
      constraint = [
        [0, 0],
        [1, 1]
      ];
    }
    var isLoop = !!z;
    var pointList = [];
    for (var i = 0, l2 = crp.length; i < l2; i += 2) {
      pointList.push([crp[i], crp[i + 1]]);
    }
    var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
    var len5 = pointList.length;
    var d1 = [];
    var cp1;
    var cp2;
    var p2;
    for (var i = 0; i < len5 - 1; i += 1) {
      cp1 = controlPointList[i * 2];
      cp2 = controlPointList[i * 2 + 1];
      p2 = pointList[i + 1];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
    }
    if (isLoop) {
      cp1 = controlPointList[len5];
      cp2 = controlPointList[len5 + 1];
      _a = __read(pointList, 1), p2 = _a[0];
      d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p2[0], p2[1]]);
    }
    return d1;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/primitive.js
  var PRIMILTIVE_ATTRIBUTES = [
    "$el",
    "cx",
    "cy",
    "d",
    "dx",
    "dy",
    "fill",
    "fillOpacity",
    "filter",
    "fontFamily",
    "fontSize",
    "fontStyle",
    "fontVariant",
    "fontWeight",
    "height",
    "img",
    "increasedLineWidthForHitTesting",
    "innerHTML",
    "isBillboard",
    "billboardRotation",
    "isSizeAttenuation",
    "isClosed",
    "isOverflowing",
    "leading",
    "letterSpacing",
    "lineDash",
    "lineHeight",
    "lineWidth",
    "markerEnd",
    "markerEndOffset",
    "markerMid",
    "markerStart",
    "markerStartOffset",
    "maxLines",
    "metrics",
    "miterLimit",
    "offsetX",
    "offsetY",
    "opacity",
    "path",
    "points",
    "r",
    "radius",
    "rx",
    "ry",
    "shadowColor",
    "src",
    "stroke",
    "strokeOpacity",
    "text",
    "textAlign",
    "textBaseline",
    "textDecorationColor",
    "textDecorationLine",
    "textDecorationStyle",
    "textOverflow",
    "textPath",
    "textPathSide",
    "textPathStartOffset",
    "transform",
    "transformOrigin",
    "visibility",
    "width",
    "wordWrap",
    "wordWrapWidth",
    "x",
    "x1",
    "x2",
    "y",
    "y1",
    "y2",
    "z1",
    "z2",
    "zIndex"
  ];
  function isPrimitiveAttribute(key) {
    return PRIMILTIVE_ATTRIBUTES.includes(key);
  }
  function getPrimitiveAttributes(attributes) {
    var object = {};
    for (var key in attributes) {
      if (isPrimitiveAttribute(key))
        object[key] = attributes[key];
    }
    return object;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/sampling.js
  function sampling(data2, size2) {
    if (data2.length <= size2)
      return data2;
    var step2 = Math.floor(data2.length / size2);
    var result = [];
    for (var i = 0; i < data2.length; i += step2) {
      result.push(data2[i]);
    }
    return result;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/scale-to-pixel.js
  function scaleToPixel(el, size2, applyScale2) {
    if (applyScale2 === void 0) {
      applyScale2 = false;
    }
    var _a = el.getBBox(), width = _a.width, height = _a.height;
    var scale9 = size2 / Math.max(width, height);
    if (applyScale2) {
      el.style.transform = "scale(".concat(scale9, ")");
    }
    return scale9;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/group.js
  function group2(array2, keyFunc) {
    var grouped = /* @__PURE__ */ new Map();
    array2.forEach(function(item) {
      var key = keyFunc(item);
      if (!grouped.has(key)) {
        grouped.set(key, []);
      }
      grouped.get(key).push(item);
    });
    return grouped;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/selection.js
  function error3(msg) {
    throw new Error(msg);
  }
  var Selection2 = (
    /** @class */
    function() {
      function Selection3(elements, data2, parent, document2, selections, transitions, updateElements) {
        if (elements === void 0) {
          elements = null;
        }
        if (data2 === void 0) {
          data2 = null;
        }
        if (parent === void 0) {
          parent = null;
        }
        if (document2 === void 0) {
          document2 = null;
        }
        if (selections === void 0) {
          selections = [null, null, null, null, null];
        }
        if (transitions === void 0) {
          transitions = [];
        }
        if (updateElements === void 0) {
          updateElements = [];
        }
        _Selection_instances.add(this);
        this._elements = Array.from(elements);
        this._data = data2;
        this._parent = parent;
        this._document = document2;
        this._enter = selections[0];
        this._update = selections[1];
        this._exit = selections[2];
        this._merge = selections[3];
        this._split = selections[4];
        this._transitions = transitions;
        this._facetElements = updateElements;
      }
      Selection3.prototype.selectAll = function(selector) {
        var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
        return new _a(elements, null, this._elements[0], this._document);
      };
      Selection3.prototype.selectFacetAll = function(selector) {
        var elements = typeof selector === "string" ? this._parent.querySelectorAll(selector) : selector;
        return new _a(this._elements, null, this._parent, this._document, void 0, void 0, elements);
      };
      Selection3.prototype.select = function(selector) {
        var element = typeof selector === "string" ? this._parent.querySelectorAll(selector)[0] || null : selector;
        return new _a([element], null, element, this._document);
      };
      Selection3.prototype.append = function(node) {
        var _this = this;
        var callback = typeof node === "function" ? node : function() {
          return _this.createElement(node);
        };
        var elements = [];
        if (this._data !== null) {
          for (var i = 0; i < this._data.length; i++) {
            var d2 = this._data[i];
            var _b = __read(Array.isArray(d2) ? d2 : [d2, null], 2), datum = _b[0], from = _b[1];
            var newElement = callback(datum, i);
            newElement.__data__ = datum;
            if (from !== null)
              newElement.__fromElements__ = from;
            this._parent.appendChild(newElement);
            elements.push(newElement);
          }
          return new _a(elements, null, this._parent, this._document);
        }
        for (var i = 0; i < this._elements.length; i++) {
          var element = this._elements[i];
          var datum = element.__data__;
          var newElement = callback(datum, i);
          element.appendChild(newElement);
          elements.push(newElement);
        }
        return new _a(elements, null, elements[0], this._document);
      };
      Selection3.prototype.maybeAppend = function(id4, node) {
        var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, id4[0] === "#" ? id4 : "#".concat(id4), node);
        element.attr("id", id4);
        return element;
      };
      Selection3.prototype.maybeAppendByClassName = function(className2, node) {
        var cls = className2.toString();
        var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, cls[0] === "." ? cls : ".".concat(cls), node);
        element.attr("className", cls);
        return element;
      };
      Selection3.prototype.maybeAppendByName = function(name2, node) {
        var element = __classPrivateFieldGet(this, _Selection_instances, "m", _Selection_maybeAppend).call(this, '[name="'.concat(name2, '"]'), node);
        element.attr("name", name2);
        return element;
      };
      Selection3.prototype.data = function(data2, id4, groupId) {
        var e_1, _b;
        if (id4 === void 0) {
          id4 = function(d2) {
            return d2;
          };
        }
        if (groupId === void 0) {
          groupId = function() {
            return null;
          };
        }
        var enter = [];
        var update = [];
        var exit = new Set(this._elements);
        var merge2 = [];
        var split = /* @__PURE__ */ new Set();
        var keyElement = new Map(this._elements.map(function(d2, i2) {
          return [id4(d2.__data__, i2), d2];
        }));
        var keyUpdateElement = new Map(this._facetElements.map(function(d2, i2) {
          return [id4(d2.__data__, i2), d2];
        }));
        var groupKeyElements = group2(this._elements, function(d2) {
          return groupId(d2.__data__);
        });
        for (var i = 0; i < data2.length; i++) {
          var datum = data2[i];
          var key = id4(datum, i);
          var groupKey = groupId(datum, i);
          if (keyElement.has(key)) {
            var element = keyElement.get(key);
            element.__data__ = datum;
            element.__facet__ = false;
            update.push(element);
            exit.delete(element);
            keyElement.delete(key);
          } else if (keyUpdateElement.has(key)) {
            var element = keyUpdateElement.get(key);
            element.__data__ = datum;
            element.__facet__ = true;
            update.push(element);
            keyUpdateElement.delete(key);
          } else if (groupKeyElements.has(key)) {
            var group_2 = groupKeyElements.get(key);
            merge2.push([datum, group_2]);
            try {
              for (var group_1 = (e_1 = void 0, __values(group_2)), group_1_1 = group_1.next(); !group_1_1.done; group_1_1 = group_1.next()) {
                var element = group_1_1.value;
                exit.delete(element);
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (group_1_1 && !group_1_1.done && (_b = group_1.return)) _b.call(group_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            groupKeyElements.delete(key);
          } else if (keyElement.has(groupKey)) {
            var element = keyElement.get(groupKey);
            if (element.__toData__)
              element.__toData__.push(datum);
            else
              element.__toData__ = [datum];
            split.add(element);
            exit.delete(element);
          } else {
            enter.push(datum);
          }
        }
        var S = [
          new _a([], enter, this._parent, this._document),
          new _a(update, null, this._parent, this._document),
          new _a(exit, null, this._parent, this._document),
          new _a([], merge2, this._parent, this._document),
          new _a(split, null, this._parent, this._document)
        ];
        return new _a(this._elements, null, this._parent, this._document, S);
      };
      Selection3.prototype.merge = function(other) {
        var elements = __spreadArray(__spreadArray([], __read(this._elements), false), __read(other._elements), false);
        var transitions = __spreadArray(__spreadArray([], __read(this._transitions), false), __read(other._transitions), false);
        return new _a(elements, null, this._parent, this._document, void 0, transitions);
      };
      Selection3.prototype.createElement = function(type) {
        if (this._document) {
          return this._document.createElement(type, {});
        }
        var Ctor = _a.registry[type];
        if (Ctor)
          return new Ctor();
        return error3("Unknown node type: ".concat(type));
      };
      Selection3.prototype.join = function(enter, update, exit, merge2, split) {
        if (enter === void 0) {
          enter = function(d2) {
            return d2;
          };
        }
        if (update === void 0) {
          update = function(d2) {
            return d2;
          };
        }
        if (exit === void 0) {
          exit = function(d2) {
            return d2.remove();
          };
        }
        if (merge2 === void 0) {
          merge2 = function(d2) {
            return d2;
          };
        }
        if (split === void 0) {
          split = function(d2) {
            return d2.remove();
          };
        }
        var newEnter = enter(this._enter);
        var newUpdate = update(this._update);
        var newExit = exit(this._exit);
        var newMerge = merge2(this._merge);
        var newSplit = split(this._split);
        return newUpdate.merge(newEnter).merge(newExit).merge(newMerge).merge(newSplit);
      };
      Selection3.prototype.remove = function() {
        var _loop_1 = function(i2) {
          var element = this_1._elements[i2];
          var transition2 = this_1._transitions[i2];
          if (transition2) {
            transition2.then(function() {
              return element.remove();
            });
          } else {
            element.remove();
          }
        };
        var this_1 = this;
        for (var i = 0; i < this._elements.length; i++) {
          _loop_1(i);
        }
        return new _a([], null, this._parent, this._document, void 0, this._transitions);
      };
      Selection3.prototype.each = function(callback) {
        for (var i = 0; i < this._elements.length; i++) {
          var element = this._elements[i];
          var datum = element.__data__;
          callback.call(element, datum, i);
        }
        return this;
      };
      Selection3.prototype.attr = function(key, value2) {
        var callback = typeof value2 !== "function" ? function() {
          return value2;
        } : value2;
        return this.each(function(d2, i) {
          if (value2 !== void 0)
            this[key] = callback.call(this, d2, i);
        });
      };
      Selection3.prototype.style = function(key, value2, callable) {
        if (callable === void 0) {
          callable = true;
        }
        var callback = typeof value2 !== "function" || !callable ? function() {
          return value2;
        } : value2;
        return this.each(function(d2, i) {
          if (value2 !== void 0)
            this.style[key] = callback.call(this, d2, i);
        });
      };
      Selection3.prototype.styles = function(style, callable) {
        if (style === void 0) {
          style = {};
        }
        if (callable === void 0) {
          callable = true;
        }
        return this.each(function(d2, i) {
          var _this = this;
          Object.entries(style).forEach(function(_b) {
            var _c = __read(_b, 2), key = _c[0], value2 = _c[1];
            var callback = typeof value2 !== "function" || !callable ? function() {
              return value2;
            } : value2;
            if (value2 !== void 0)
              _this.attr(key, callback.call(_this, d2, i));
          });
        });
      };
      Selection3.prototype.update = function(option2, callable) {
        if (callable === void 0) {
          callable = true;
        }
        var callback = typeof option2 !== "function" || !callable ? function() {
          return option2;
        } : option2;
        return this.each(function(d2, i) {
          if (option2 && this.update)
            this.update(callback.call(this, d2, i));
        });
      };
      Selection3.prototype.maybeUpdate = function(option2, callable) {
        if (callable === void 0) {
          callable = true;
        }
        var callback = typeof option2 !== "function" || !callable ? function() {
          return option2;
        } : option2;
        return this.each(function(d2, i) {
          if (option2 && this.update)
            this.update(callback.call(this, d2, i));
        });
      };
      Selection3.prototype.transition = function(callback) {
        var T = this._transitions;
        return this.each(function(d2, i) {
          T[i] = callback.call(this, d2, i);
        });
      };
      Selection3.prototype.on = function(event, handler) {
        this.each(function() {
          this.addEventListener(event, handler);
        });
        return this;
      };
      Selection3.prototype.call = function(callback) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        callback.call.apply(callback, __spreadArray([this._parent, this], __read(args), false));
        return this;
      };
      Selection3.prototype.node = function() {
        return this._elements[0];
      };
      Selection3.prototype.nodes = function() {
        return this._elements;
      };
      Selection3.prototype.transitions = function() {
        return this._transitions.filter(function(t) {
          return !!t;
        });
      };
      Selection3.prototype.parent = function() {
        return this._parent;
      };
      var _Selection_instances, _a, _Selection_maybeAppend;
      _a = Selection3, _Selection_instances = /* @__PURE__ */ new WeakSet(), _Selection_maybeAppend = function _Selection_maybeAppend2(selector, node) {
        var element = this._elements[0];
        var child = element.querySelector(selector);
        if (child)
          return new _a([child], null, this._parent, this._document);
        var newChild = typeof node === "string" ? this.createElement(node) : node();
        element.appendChild(newChild);
        return new _a([newChild], null, this._parent, this._document);
      };
      Selection3.registry = {
        g: Group2,
        rect: Rect,
        circle: Circle,
        path: Path2,
        text: Text2,
        ellipse: Ellipse,
        image: Image2,
        line: Line,
        polygon: Polygon,
        polyline: Polyline,
        html: HTML
      };
      return Selection3;
    }()
  );
  function select2(node) {
    return new Selection2([node], null, node, node.ownerDocument);
  }
  function maybeAppend(parent, selector, node) {
    if (!parent.querySelector(selector)) {
      return select2(parent).append(node);
    }
    return select2(parent).select(selector);
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/series.js
  function parseSeriesAttr(series) {
    if (is_number_default5(series)) {
      return [series, series, series, series];
    }
    if (is_array_default3(series)) {
      var len5 = series.length;
      if (len5 === 1) {
        return [series[0], series[0], series[0], series[0]];
      }
      if (len5 === 2) {
        return [series[0], series[1], series[0], series[1]];
      }
      if (len5 === 3) {
        return [series[0], series[1], series[2], series[1]];
      }
      if (len5 === 4) {
        return series;
      }
    }
    return [0, 0, 0, 0];
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/shape.js
  function getLocalBBox(shape23) {
    var _a = shape23.getLocalBounds(), min10 = _a.min, max10 = _a.max;
    var _b = __read([min10, max10], 2), _c = __read(_b[0], 2), x12 = _c[0], y12 = _c[1], _d = __read(_b[1], 2), x22 = _d[0], y22 = _d[1];
    return { x: x12, y: y12, width: x22 - x12, height: y22 - y12, left: x12, bottom: y22, top: y12, right: x22 };
  }
  function isHorizontal(p1, p2) {
    var _a = __read(p1, 2), x12 = _a[0], y12 = _a[1];
    var _b = __read(p2, 2), x22 = _b[0], y22 = _b[1];
    return x12 !== x22 && y12 === y22;
  }
  function copyAttributes2(target, source) {
    var e_1, _a;
    var attributes = source.attributes;
    try {
      for (var _b = __values(Object.entries(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2), key = _d[0], value2 = _d[1];
        if (key !== "id" && key !== "className")
          target.attr(key, value2);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/string.js
  function toUppercaseFirstLetter(string) {
    return string.toString().charAt(0).toUpperCase() + string.toString().slice(1);
  }
  function toLowercaseFirstLetter(string) {
    return string.toString().charAt(0).toLowerCase() + string.toString().slice(1);
  }
  function addPrefix(string, prefix) {
    return "".concat(prefix).concat(toUppercaseFirstLetter(string));
  }
  function removePrefix(string, prefix, lowercaseFirstLetter) {
    var _a;
    if (lowercaseFirstLetter === void 0) {
      lowercaseFirstLetter = true;
    }
    var inferPrefix = prefix || ((_a = string.match(/^([a-z][a-z0-9]+)/)) === null || _a === void 0 ? void 0 : _a[0]) || "";
    var withoutPrefix = string.replace(new RegExp("^(".concat(inferPrefix, ")")), "");
    return lowercaseFirstLetter ? toLowercaseFirstLetter(withoutPrefix) : withoutPrefix;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/style.js
  function applyStyleSheet(element, style) {
    Object.entries(style).forEach(function(_a) {
      var _b = __read(_a, 2), selector = _b[0], styleString = _b[1];
      __spreadArray([element], __read(element.querySelectorAll(selector)), false).filter(function(el) {
        return el.matches(selector);
      }).forEach(function(target) {
        if (!target)
          return;
        var temp = target;
        temp.style.cssText += Object.entries(styleString).reduce(function(total, currVal) {
          return "".concat(total).concat(currVal.join(":"), ";");
        }, "");
      });
    });
  }
  var startsWith = function(text, prefix) {
    if (!(text === null || text === void 0 ? void 0 : text.startsWith(prefix)))
      return false;
    var nextChart = text[prefix.length];
    return nextChart >= "A" && nextChart <= "Z";
  };
  function subStyleProps(style, prefix, invert5) {
    if (invert5 === void 0) {
      invert5 = false;
    }
    var result = {};
    Object.entries(style).forEach(function(_a) {
      var _b = __read(_a, 2), key = _b[0], value2 = _b[1];
      if (key === "className" || key === "class") {
      } else if (startsWith(key, "show") && startsWith(removePrefix(key, "show"), prefix) !== invert5) {
        if (key === addPrefix(prefix, "show"))
          result[key] = value2;
        else
          result[key.replace(new RegExp(toUppercaseFirstLetter(prefix)), "")] = value2;
      } else if (!startsWith(key, "show") && startsWith(key, prefix) !== invert5) {
        var name_1 = removePrefix(key, prefix);
        if (name_1 === "filter" && typeof value2 === "function") {
        } else
          result[name_1] = value2;
      }
    });
    return result;
  }
  function superStyleProps(style, prefix) {
    return Object.entries(style).reduce(function(acc, _a) {
      var _b = __read(_a, 2), key = _b[0], value2 = _b[1];
      if (key.startsWith("show"))
        acc["show".concat(prefix).concat(key.slice(4))] = value2;
      else
        acc["".concat(prefix).concat(toUppercaseFirstLetter(key))] = value2;
      return acc;
    }, {});
  }
  function splitStyle(style, ignoreStyleDict) {
    if (ignoreStyleDict === void 0) {
      ignoreStyleDict = ["x", "y", "class", "className"];
    }
    var groupStyleDict = [
      "transform",
      "transformOrigin",
      "anchor",
      "visibility",
      "pointerEvents",
      "zIndex",
      "cursor",
      "clipPath",
      "clipPathTargets",
      "offsetPath",
      "offsetPathTargets",
      "offsetDistance",
      "draggable",
      "droppable"
    ];
    var output = {};
    var groupStyle = {};
    Object.entries(style).forEach(function(_a) {
      var _b = __read(_a, 2), key = _b[0], val = _b[1];
      if (ignoreStyleDict.includes(key)) {
      } else if (groupStyleDict.indexOf(key) !== -1)
        groupStyle[key] = val;
      else
        output[key] = val;
    });
    return [output, groupStyle];
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/transform.js
  function getTranslate(node, x3, y3) {
    var _a = node.getBBox(), width = _a.width, height = _a.height;
    var _b = __read([x3, y3].map(function(v, i) {
      var _a2;
      return v.includes("%") ? parseFloat(((_a2 = v.match(/[+-]?([0-9]*[.])?[0-9]+/)) === null || _a2 === void 0 ? void 0 : _a2[0]) || "0") / 100 * (i === 0 ? width : height) : v;
    }), 2), tx = _b[0], ty = _b[1];
    return [tx, ty];
  }
  function percentTransform(node, val) {
    if (!val)
      return;
    try {
      var reg = /translate\(([+-]*[\d]+[%]*),[ ]*([+-]*[\d]+[%]*)\)/g;
      var computedVal = val.replace(reg, function(match2, x3, y3) {
        return "translate(".concat(getTranslate(node, x3, y3), ")");
      });
      node.attr("transform", computedVal);
    } catch (e3) {
    }
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/util/transpose.js
  function transpose3(m3) {
    var _a;
    return ((_a = m3[0]) === null || _a === void 0 ? void 0 : _a.map(function(x3, i) {
      return m3.map(function(x4) {
        return x4[i];
      });
    })) || [];
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/core/component.js
  function applyVisibility() {
    visibility(this, this.attributes.visibility !== "hidden");
  }
  var Component = (
    /** @class */
    function(_super) {
      __extends(Component2, _super);
      function Component2(options, defaultStyleProps) {
        if (defaultStyleProps === void 0) {
          defaultStyleProps = {};
        }
        var _this = _super.call(this, deepAssign2({}, { style: defaultStyleProps }, options)) || this;
        _this.initialized = false;
        _this._defaultOptions = defaultStyleProps;
        return _this;
      }
      Object.defineProperty(Component2.prototype, "offscreenGroup", {
        get: function() {
          if (!this._offscreen)
            this._offscreen = createOffscreenGroup(this);
          return this._offscreen;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Component2.prototype, "defaultOptions", {
        get: function() {
          return this._defaultOptions;
        },
        enumerable: false,
        configurable: true
      });
      Component2.prototype.connectedCallback = function() {
        this.render(this.attributes, this);
        this.bindEvents(this.attributes, this);
        this.initialized = true;
      };
      Component2.prototype.disconnectedCallback = function() {
        var _a;
        (_a = this._offscreen) === null || _a === void 0 ? void 0 : _a.destroy();
      };
      Component2.prototype.attributeChangedCallback = function(name2) {
        if (name2 === "visibility") {
          applyVisibility.call(this);
        }
      };
      Component2.prototype.update = function(attr2, animate2) {
        var _a;
        this.attr(deepAssign2({}, this.attributes, attr2 || {}));
        return (_a = this.render) === null || _a === void 0 ? void 0 : _a.call(this, this.attributes, this, animate2);
      };
      Component2.prototype.clear = function() {
        this.removeChildren();
      };
      Component2.prototype.bindEvents = function(attributes, container) {
      };
      Component2.prototype.getSubShapeStyle = function(attributes) {
        var x3 = attributes.x, y3 = attributes.y, transform = attributes.transform, transformOrigin = attributes.transformOrigin, _class = attributes.class, className2 = attributes.className, zIndex = attributes.zIndex, style = __rest(attributes, ["x", "y", "transform", "transformOrigin", "class", "className", "zIndex"]);
        return style;
      };
      return Component2;
    }(CustomElement)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/marker/symbol.js
  var circle = function(x3, y3, r) {
    return [["M", x3 - r, y3], ["A", r, r, 0, 1, 0, x3 + r, y3], ["A", r, r, 0, 1, 0, x3 - r, y3], ["Z"]];
  };
  var point5 = circle;
  var square2 = function(x3, y3, r) {
    return [["M", x3 - r, y3 - r], ["L", x3 + r, y3 - r], ["L", x3 + r, y3 + r], ["L", x3 - r, y3 + r], ["Z"]];
  };
  var diamond2 = function(x3, y3, r) {
    return [["M", x3 - r, y3], ["L", x3, y3 - r], ["L", x3 + r, y3], ["L", x3, y3 + r], ["Z"]];
  };
  var triangle2 = function(x3, y3, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x3 - r, y3 + diffY], ["L", x3, y3 - diffY], ["L", x3 + r, y3 + diffY], ["Z"]];
  };
  var triangleDown2 = function(x3, y3, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 - diffY], ["L", x3, y3 + diffY], ["Z"]];
  };
  var hexagon2 = function(x3, y3, r) {
    var diffX = r / 2 * Math.sqrt(3);
    return [
      ["M", x3, y3 - r],
      ["L", x3 + diffX, y3 - r / 2],
      ["L", x3 + diffX, y3 + r / 2],
      ["L", x3, y3 + r],
      ["L", x3 - diffX, y3 + r / 2],
      ["L", x3 - diffX, y3 - r / 2],
      ["Z"]
    ];
  };
  var bowtie2 = function(x3, y3, r) {
    var diffY = r - 1.5;
    return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 + diffY], ["L", x3 + r, y3 - diffY], ["L", x3 - r, y3 + diffY], ["Z"]];
  };
  var line2 = function(x3, y3, r) {
    return [
      ["M", x3, y3 + r],
      ["L", x3, y3 - r]
    ];
  };
  var cross5 = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3 - r],
      ["L", x3 + r, y3 + r],
      ["M", x3 + r, y3 - r],
      ["L", x3 - r, y3 + r]
    ];
  };
  var tick2 = function(x3, y3, r) {
    return [
      ["M", x3 - r / 2, y3 - r],
      ["L", x3 + r / 2, y3 - r],
      ["M", x3, y3 - r],
      ["L", x3, y3 + r],
      ["M", x3 - r / 2, y3 + r],
      ["L", x3 + r / 2, y3 + r]
    ];
  };
  var plus2 = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3],
      ["M", x3, y3 - r],
      ["L", x3, y3 + r]
    ];
  };
  var hyphen2 = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3]
    ];
  };
  var dot7 = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3],
      ["L", x3 + r, y3]
    ];
  };
  var dash2 = dot7;
  var smooth2 = function(x3, y3, r) {
    return [
      ["M", x3 - r, y3],
      ["A", r / 2, r / 2, 0, 1, 1, x3, y3],
      ["A", r / 2, r / 2, 0, 1, 0, x3 + r, y3]
    ];
  };
  var hv2 = function(x3, y3, r) {
    return [
      ["M", x3 - r - 1, y3 - 2.5],
      ["L", x3, y3 - 2.5],
      ["L", x3, y3 + 2.5],
      ["L", x3 + r + 1, y3 + 2.5]
    ];
  };
  var vh2 = function(x3, y3, r) {
    return [
      ["M", x3 - r - 1, y3 + 2.5],
      ["L", x3, y3 + 2.5],
      ["L", x3, y3 - 2.5],
      ["L", x3 + r + 1, y3 - 2.5]
    ];
  };
  var hvh2 = function(x3, y3, r) {
    return [
      ["M", x3 - (r + 1), y3 + 2.5],
      ["L", x3 - r / 2, y3 + 2.5],
      ["L", x3 - r / 2, y3 - 2.5],
      ["L", x3 + r / 2, y3 - 2.5],
      ["L", x3 + r / 2, y3 + 2.5],
      ["L", x3 + r + 1, y3 + 2.5]
    ];
  };
  function vhv2(x3, y3) {
    return [
      ["M", x3 - 5, y3 + 2.5],
      ["L", x3 - 5, y3],
      ["L", x3, y3],
      ["L", x3, y3 - 3],
      ["L", x3, y3 + 3],
      ["L", x3 + 6.5, y3 + 3]
    ];
  }
  var button = function(x3, y3, r) {
    return [["M", x3 - r, y3 - r], ["L", x3 + r, y3], ["L", x3 - r, y3 + r], ["Z"]];
  };

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/marker/utils.js
  function parseMarker(icon) {
    var type = "default";
    if (is_object_default3(icon) && icon instanceof Image)
      type = "image";
    else if (is_function_default2(icon))
      type = "symbol";
    else if (is_string_default4(icon)) {
      var dataURLsPattern = new RegExp("data:(image|text)");
      if (icon.match(dataURLsPattern)) {
        type = "base64";
      } else if (/^(https?:\/\/(([a-zA-Z0-9]+-?)+[a-zA-Z0-9]+\.)+[a-zA-Z]+)(:\d+)?(\/.*)?(\?.*)?(#.*)?$/.test(icon)) {
        type = "url";
      } else {
        type = "symbol";
      }
    }
    return type;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/marker/index.js
  function getType(symbol) {
    var markerType = parseMarker(symbol);
    if (["base64", "url", "image"].includes(markerType)) {
      return "image";
    }
    if (symbol && markerType === "symbol") {
      return "path";
    }
    return null;
  }
  var Marker = (
    /** @class */
    function(_super) {
      __extends(Marker2, _super);
      function Marker2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Marker2.prototype.render = function(attributes, container) {
        var _a = attributes.x, x3 = _a === void 0 ? 0 : _a, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
        var _c = this.getSubShapeStyle(attributes), symbol = _c.symbol, _d = _c.size, size2 = _d === void 0 ? 16 : _d, style = __rest(_c, ["symbol", "size"]);
        var type = getType(symbol);
        ifShow(!!type, select2(container), function(group3) {
          group3.maybeAppendByClassName("marker", type).attr("className", "marker ".concat(type, "-marker")).call(function(selection) {
            if (type === "image") {
              var r = size2 * 2;
              selection.styles({
                img: symbol,
                width: r,
                height: r,
                x: x3 - size2,
                y: y3 - size2
              });
            } else {
              var r = size2 / 2;
              var symbolFn = is_function_default2(symbol) ? symbol : Marker2.getSymbol(symbol);
              selection.styles(__assign({ d: symbolFn === null || symbolFn === void 0 ? void 0 : symbolFn(x3, y3, r) }, style));
            }
          });
        });
      };
      Marker2.MARKER_SYMBOL_MAP = /* @__PURE__ */ new Map();
      Marker2.registerSymbol = function(type, symbol) {
        Marker2.MARKER_SYMBOL_MAP.set(type, symbol);
      };
      Marker2.getSymbol = function(type) {
        return Marker2.MARKER_SYMBOL_MAP.get(type);
      };
      Marker2.getSymbols = function() {
        return Array.from(Marker2.MARKER_SYMBOL_MAP.keys());
      };
      return Marker2;
    }(Component)
  );
  Marker.registerSymbol("cross", cross5);
  Marker.registerSymbol("hyphen", hyphen2);
  Marker.registerSymbol("line", line2);
  Marker.registerSymbol("plus", plus2);
  Marker.registerSymbol("tick", tick2);
  Marker.registerSymbol("circle", circle);
  Marker.registerSymbol("point", point5);
  Marker.registerSymbol("bowtie", bowtie2);
  Marker.registerSymbol("hexagon", hexagon2);
  Marker.registerSymbol("square", square2);
  Marker.registerSymbol("diamond", diamond2);
  Marker.registerSymbol("triangle", triangle2);
  Marker.registerSymbol("triangle-down", triangleDown2);
  Marker.registerSymbol("line", line2);
  Marker.registerSymbol("dot", dot7);
  Marker.registerSymbol("dash", dash2);
  Marker.registerSymbol("smooth", smooth2);
  Marker.registerSymbol("hv", hv2);
  Marker.registerSymbol("vh", vh2);
  Marker.registerSymbol("hvh", hvh2);
  Marker.registerSymbol("vhv", vhv2);

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/utils/compose.js
  function compose3(fn, ...rest) {
    return rest.reduce((pre, cur) => (x3) => pre(cur(x3)), fn);
  }

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/utils/normalize.js
  function createNormalize2(a3, b) {
    return b - a3 ? (t) => (t - a3) / (b - a3) : (_2) => 0.5;
  }

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/utils/clamp.js
  function createClamp2(a3, b) {
    const lo = b < a3 ? b : a3;
    const hi = a3 > b ? a3 : b;
    return (x3) => Math.min(Math.max(lo, x3), hi);
  }

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/utils/bisect.js
  function bisect2(array2, x3, lo, hi, getter) {
    let i = lo || 0;
    let j = hi || array2.length;
    const get2 = getter || ((x4) => x4);
    while (i < j) {
      const mid2 = Math.floor((i + j) / 2);
      if (get2(array2[mid2]) > x3) {
        j = mid2;
      } else {
        i = mid2 + 1;
      }
    }
    return i;
  }

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/utils/ticks.js
  var e103 = Math.sqrt(50);
  var e53 = Math.sqrt(10);
  var e23 = Math.sqrt(2);
  function tickIncrement3(start2, stop, count4) {
    const step2 = (stop - start2) / Math.max(0, count4);
    const power = Math.floor(Math.log(step2) / Math.LN10);
    const error4 = step2 / 10 ** power;
    if (power >= 0) {
      return (error4 >= e103 ? 10 : error4 >= e53 ? 5 : error4 >= e23 ? 2 : 1) * 10 ** power;
    }
    return -(10 ** -power) / (error4 >= e103 ? 10 : error4 >= e53 ? 5 : error4 >= e23 ? 2 : 1);
  }

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/utils/d3-linear-nice.js
  var d3LinearNice2 = (min10, max10, count4 = 5) => {
    const d2 = [min10, max10];
    let i0 = 0;
    let i1 = d2.length - 1;
    let start2 = d2[i0];
    let stop = d2[i1];
    let step2;
    if (stop < start2) {
      [start2, stop] = [stop, start2];
      [i0, i1] = [i1, i0];
    }
    step2 = tickIncrement3(start2, stop, count4);
    if (step2 > 0) {
      start2 = Math.floor(start2 / step2) * step2;
      stop = Math.ceil(stop / step2) * step2;
      step2 = tickIncrement3(start2, stop, count4);
    } else if (step2 < 0) {
      start2 = Math.ceil(start2 * step2) / step2;
      stop = Math.floor(stop * step2) / step2;
      step2 = tickIncrement3(start2, stop, count4);
    }
    if (step2 > 0) {
      d2[i0] = Math.floor(start2 / step2) * step2;
      d2[i1] = Math.ceil(stop / step2) * step2;
    } else if (step2 < 0) {
      d2[i0] = Math.ceil(start2 * step2) / step2;
      d2[i1] = Math.floor(stop * step2) / step2;
    }
    return d2;
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/utils/is-valid.js
  function isValid2(x3) {
    return !is_undefined_default3(x3) && !is_null_default2(x3) && !Number.isNaN(x3);
  }

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/utils/color.js
  var import_color_string2 = __toESM(require_color_string());
  function hue2rgb2(p2, q, m3) {
    let t = m3;
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p2 + (q - p2) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p2 + (q - p2) * (2 / 3 - t) * 6;
    return p2;
  }
  function hsl2rbg2(hsl2) {
    const h = hsl2[0] / 360;
    const s2 = hsl2[1] / 100;
    const l2 = hsl2[2] / 100;
    const a3 = hsl2[3];
    if (s2 === 0)
      return [l2 * 255, l2 * 255, l2 * 255, a3];
    const q = l2 < 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
    const p2 = 2 * l2 - q;
    const r = hue2rgb2(p2, q, h + 1 / 3);
    const g = hue2rgb2(p2, q, h);
    const b = hue2rgb2(p2, q, h - 1 / 3);
    return [r * 255, g * 255, b * 255, a3];
  }
  function string2rbg2(s2) {
    const color2 = import_color_string2.default.get(s2);
    if (!color2)
      return null;
    const { model, value: value2 } = color2;
    if (model === "rgb")
      return value2;
    if (model === "hsl")
      return hsl2rbg2(value2);
    return null;
  }

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/utils/interpolate.js
  var createInterpolateNumber2 = (a3, b) => {
    return (t) => a3 * (1 - t) + b * t;
  };
  var createInterpolateColor2 = (a3, b) => {
    const c1 = string2rbg2(a3);
    const c22 = string2rbg2(b);
    if (c1 === null || c22 === null)
      return c1 ? () => a3 : () => b;
    return (t) => {
      const values = new Array(4);
      for (let i = 0; i < 4; i += 1) {
        const from = c1[i];
        const to = c22[i];
        values[i] = from * (1 - t) + to * t;
      }
      const [r, g, b2, a4] = values;
      return `rgba(${Math.round(r)}, ${Math.round(g)}, ${Math.round(b2)}, ${a4})`;
    };
  };
  var createInterpolateValue2 = (a3, b) => {
    if (typeof a3 === "number" && typeof b === "number")
      return createInterpolateNumber2(a3, b);
    if (typeof a3 === "string" && typeof b === "string")
      return createInterpolateColor2(a3, b);
    return () => a3;
  };
  var createInterpolateRound2 = (a3, b) => {
    const interpolateNumber = createInterpolateNumber2(a3, b);
    return (t) => Math.round(interpolateNumber(t));
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/utils/internMap.js
  function internGet2({ map: map3, initKey }, value2) {
    const key = initKey(value2);
    return map3.has(key) ? map3.get(key) : value2;
  }
  function internSet2({ map: map3, initKey }, value2) {
    const key = initKey(value2);
    if (map3.has(key))
      return map3.get(key);
    map3.set(key, value2);
    return value2;
  }
  function internDelete2({ map: map3, initKey }, value2) {
    const key = initKey(value2);
    if (map3.has(key)) {
      value2 = map3.get(key);
      map3.delete(key);
    }
    return value2;
  }
  function keyof3(value2) {
    return typeof value2 === "object" ? value2.valueOf() : value2;
  }
  var InternMap3 = class extends Map {
    constructor(entries) {
      super();
      this.map = /* @__PURE__ */ new Map();
      this.initKey = keyof3;
      if (entries !== null) {
        for (const [key, value2] of entries) {
          this.set(key, value2);
        }
      }
    }
    get(key) {
      return super.get(internGet2({ map: this.map, initKey: this.initKey }, key));
    }
    has(key) {
      return super.has(internGet2({ map: this.map, initKey: this.initKey }, key));
    }
    set(key, value2) {
      return super.set(internSet2({ map: this.map, initKey: this.initKey }, key), value2);
    }
    delete(key) {
      return super.delete(internDelete2({ map: this.map, initKey: this.initKey }, key));
    }
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/scales/base.js
  var Base2 = class {
    /**
     * 构造函数，根据自定义的选项和默认选项生成当前选项
     * @param options 需要自定义配置的选项
     */
    constructor(options) {
      this.options = deep_mix_default2({}, this.getDefaultOptions());
      this.update(options);
    }
    /**
     * 返回当前的所有选项
     * @returns 当前的所有选项
     */
    getOptions() {
      return this.options;
    }
    /**
     * 更新选项和比例尺的内部状态
     * @param updateOptions 需要更新的选项
     */
    update(updateOptions = {}) {
      this.options = deep_mix_default2({}, this.options, updateOptions);
      this.rescale(updateOptions);
    }
    /**
     * 根据需要更新 options 和更新后的 options 更新 scale 的内部状态，
     * 在函数内部可以用 this.options 获得更新后的 options
     * @param options 需要更新的 options
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    rescale(options) {
    }
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/scales/ordinal.js
  var defaultUnknown2 = Symbol("defaultUnknown");
  function updateIndexMap2(target, arr, key) {
    for (let i = 0; i < arr.length; i += 1) {
      if (!target.has(arr[i])) {
        target.set(key(arr[i]), i);
      }
    }
  }
  function mapBetweenArrByMapIndex2(options) {
    const { value: value2, from, to, mapper, notFoundReturn } = options;
    let mappedIndex = mapper.get(value2);
    if (mappedIndex === void 0) {
      if (notFoundReturn !== defaultUnknown2) {
        return notFoundReturn;
      }
      mappedIndex = from.push(value2) - 1;
      mapper.set(value2, mappedIndex);
    }
    return to[mappedIndex % to.length];
  }
  function createKey2(d2) {
    if (d2 instanceof Date)
      return (d3) => `${d3}`;
    if (typeof d2 === "object")
      return (d3) => JSON.stringify(d3);
    return (d3) => d3;
  }
  var Ordinal2 = class _Ordinal extends Base2 {
    // 覆盖默认配置
    getDefaultOptions() {
      return {
        domain: [],
        range: [],
        unknown: defaultUnknown2
      };
    }
    // 显示指定 options 的类型为 OrdinalOptions，从而推断出 O 的类型
    constructor(options) {
      super(options);
    }
    map(x3) {
      if (this.domainIndexMap.size === 0) {
        updateIndexMap2(this.domainIndexMap, this.getDomain(), this.domainKey);
      }
      return mapBetweenArrByMapIndex2({
        value: this.domainKey(x3),
        mapper: this.domainIndexMap,
        from: this.getDomain(),
        to: this.getRange(),
        notFoundReturn: this.options.unknown
      });
    }
    invert(y3) {
      if (this.rangeIndexMap.size === 0) {
        updateIndexMap2(this.rangeIndexMap, this.getRange(), this.rangeKey);
      }
      return mapBetweenArrByMapIndex2({
        value: this.rangeKey(y3),
        mapper: this.rangeIndexMap,
        from: this.getRange(),
        to: this.getDomain(),
        notFoundReturn: this.options.unknown
      });
    }
    // 因为 ordinal 比例尺更新内部状态的开销较大，所以按需更新
    rescale(options) {
      const [d2] = this.options.domain;
      const [r] = this.options.range;
      this.domainKey = createKey2(d2);
      this.rangeKey = createKey2(r);
      if (!this.rangeIndexMap) {
        this.rangeIndexMap = /* @__PURE__ */ new Map();
        this.domainIndexMap = /* @__PURE__ */ new Map();
        return;
      }
      if (!options || options.range) {
        this.rangeIndexMap.clear();
      }
      if (!options || options.domain || options.compare) {
        this.domainIndexMap.clear();
        this.sortedDomain = void 0;
      }
    }
    clone() {
      return new _Ordinal(this.options);
    }
    getRange() {
      return this.options.range;
    }
    getDomain() {
      if (this.sortedDomain)
        return this.sortedDomain;
      const { domain, compare } = this.options;
      this.sortedDomain = compare ? [...domain].sort(compare) : domain;
      return this.sortedDomain;
    }
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/scales/band.js
  function normalize8(array2) {
    const min10 = Math.min(...array2);
    return array2.map((d2) => d2 / min10);
  }
  function splice2(array2, n2) {
    const sn = array2.length;
    const diff = n2 - sn;
    return diff > 0 ? [...array2, ...new Array(diff).fill(1)] : diff < 0 ? array2.slice(0, n2) : array2;
  }
  function pretty2(n2) {
    return Math.round(n2 * 1e12) / 1e12;
  }
  function computeFlexBandState2(options) {
    const { domain, range: range3, paddingOuter, paddingInner, flex: F, round: round5, align } = options;
    const n2 = domain.length;
    const flex2 = splice2(F, n2);
    const [start2, end] = range3;
    const width = end - start2;
    const ratio = 2 / n2 * paddingOuter + 1 - 1 / n2 * paddingInner;
    const stepSum = width / ratio;
    const PI = stepSum * paddingInner / n2;
    const bandWidthSum = stepSum - n2 * PI;
    const normalizedFlex = normalize8(flex2);
    const flexSum = normalizedFlex.reduce((sum3, value2) => sum3 + value2);
    const minBandWidth = bandWidthSum / flexSum;
    const valueBandWidth = new InternMap3(domain.map((d2, i) => {
      const bandWidth3 = normalizedFlex[i] * minBandWidth;
      return [d2, round5 ? Math.floor(bandWidth3) : bandWidth3];
    }));
    const valueStep = new InternMap3(domain.map((d2, i) => {
      const bandWidth3 = normalizedFlex[i] * minBandWidth;
      const step2 = bandWidth3 + PI;
      return [d2, round5 ? Math.floor(step2) : step2];
    }));
    const finalStepSum = Array.from(valueStep.values()).reduce((sum3, value2) => sum3 + value2);
    const outerPaddingSum = width - (finalStepSum - finalStepSum / n2 * paddingInner);
    const offset3 = outerPaddingSum * align;
    const bandStart = start2 + offset3;
    let prev = round5 ? Math.round(bandStart) : bandStart;
    const adjustedRange = new Array(n2);
    for (let i = 0; i < n2; i += 1) {
      adjustedRange[i] = pretty2(prev);
      const value2 = domain[i];
      prev += valueStep.get(value2);
    }
    return {
      valueBandWidth,
      valueStep,
      adjustedRange
    };
  }
  function computeBandState2(options) {
    var _a;
    const { domain } = options;
    const n2 = domain.length;
    if (n2 === 0) {
      return {
        valueBandWidth: void 0,
        valueStep: void 0,
        adjustedRange: []
      };
    }
    const hasFlex = !!((_a = options.flex) === null || _a === void 0 ? void 0 : _a.length);
    if (hasFlex) {
      return computeFlexBandState2(options);
    }
    const { range: range3, paddingOuter, paddingInner, round: round5, align } = options;
    let step2;
    let bandWidth3;
    let rangeStart = range3[0];
    const rangeEnd = range3[1];
    const deltaRange = rangeEnd - rangeStart;
    const outerTotal = paddingOuter * 2;
    const innerTotal = n2 - paddingInner;
    step2 = deltaRange / Math.max(1, outerTotal + innerTotal);
    if (round5) {
      step2 = Math.floor(step2);
    }
    rangeStart += (deltaRange - step2 * (n2 - paddingInner)) * align;
    bandWidth3 = step2 * (1 - paddingInner);
    if (round5) {
      rangeStart = Math.round(rangeStart);
      bandWidth3 = Math.round(bandWidth3);
    }
    const adjustedRange = new Array(n2).fill(0).map((_2, i) => rangeStart + i * step2);
    return {
      valueStep: step2,
      valueBandWidth: bandWidth3,
      adjustedRange
    };
  }
  var Band2 = class _Band extends Ordinal2 {
    // 覆盖默认配置
    getDefaultOptions() {
      return {
        domain: [],
        range: [0, 1],
        align: 0.5,
        round: false,
        paddingInner: 0,
        paddingOuter: 0,
        padding: 0,
        unknown: defaultUnknown2,
        flex: []
      };
    }
    // 显示指定 options 的类型为 OrdinalOptions，从而推断出 O 的类型
    constructor(options) {
      super(options);
    }
    clone() {
      return new _Band(this.options);
    }
    getStep(x3) {
      if (this.valueStep === void 0)
        return 1;
      if (typeof this.valueStep === "number") {
        return this.valueStep;
      }
      if (x3 === void 0)
        return Array.from(this.valueStep.values())[0];
      return this.valueStep.get(x3);
    }
    getBandWidth(x3) {
      if (this.valueBandWidth === void 0)
        return 1;
      if (typeof this.valueBandWidth === "number") {
        return this.valueBandWidth;
      }
      if (x3 === void 0)
        return Array.from(this.valueBandWidth.values())[0];
      return this.valueBandWidth.get(x3);
    }
    getRange() {
      return this.adjustedRange;
    }
    getPaddingInner() {
      const { padding, paddingInner } = this.options;
      return padding > 0 ? padding : paddingInner;
    }
    getPaddingOuter() {
      const { padding, paddingOuter } = this.options;
      return padding > 0 ? padding : paddingOuter;
    }
    rescale() {
      super.rescale();
      const { align, domain, range: range3, round: round5, flex: flex2 } = this.options;
      const { adjustedRange, valueBandWidth, valueStep } = computeBandState2({
        align,
        range: range3,
        round: round5,
        flex: flex2,
        paddingInner: this.getPaddingInner(),
        paddingOuter: this.getPaddingOuter(),
        domain
      });
      this.valueStep = valueStep;
      this.valueBandWidth = valueBandWidth;
      this.adjustedRange = adjustedRange;
    }
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/tick-methods/d3-ticks.js
  var d3Ticks2 = (begin, end, count4) => {
    let n2;
    let ticks2;
    let start2 = begin;
    let stop = end;
    if (start2 === stop && count4 > 0) {
      return [start2];
    }
    let step2 = tickIncrement3(start2, stop, count4);
    if (step2 === 0 || !Number.isFinite(step2)) {
      return [];
    }
    if (step2 > 0) {
      start2 = Math.ceil(start2 / step2);
      stop = Math.floor(stop / step2);
      ticks2 = new Array(n2 = Math.ceil(stop - start2 + 1));
      for (let i = 0; i < n2; i += 1) {
        ticks2[i] = (start2 + i) * step2;
      }
    } else {
      step2 = -step2;
      start2 = Math.ceil(start2 * step2);
      stop = Math.floor(stop * step2);
      ticks2 = new Array(n2 = Math.ceil(stop - start2 + 1));
      for (let i = 0; i < n2; i += 1) {
        ticks2[i] = (start2 + i) / step2;
      }
    }
    return ticks2;
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/scales/continuous.js
  var createBiMap2 = (domain, range3, createInterpolate) => {
    const [d0, d1] = domain;
    const [r0, r1] = range3;
    let normalize10;
    let interpolate5;
    if (d0 < d1) {
      normalize10 = createNormalize2(d0, d1);
      interpolate5 = createInterpolate(r0, r1);
    } else {
      normalize10 = createNormalize2(d1, d0);
      interpolate5 = createInterpolate(r1, r0);
    }
    return compose3(interpolate5, normalize10);
  };
  var createPolyMap2 = (domain, range3, createInterpolate) => {
    const len5 = Math.min(domain.length, range3.length) - 1;
    const normalizeList = new Array(len5);
    const interpolateList = new Array(len5);
    const reverse = domain[0] > domain[len5];
    const ascendingDomain = reverse ? [...domain].reverse() : domain;
    const ascendingRange = reverse ? [...range3].reverse() : range3;
    for (let i = 0; i < len5; i += 1) {
      normalizeList[i] = createNormalize2(ascendingDomain[i], ascendingDomain[i + 1]);
      interpolateList[i] = createInterpolate(ascendingRange[i], ascendingRange[i + 1]);
    }
    return (x3) => {
      const i = bisect2(domain, x3, 1, len5) - 1;
      const normalize10 = normalizeList[i];
      const interpolate5 = interpolateList[i];
      return compose3(interpolate5, normalize10)(x3);
    };
  };
  var choosePiecewise2 = (domain, range3, interpolate5, shouldRound) => {
    const n2 = Math.min(domain.length, range3.length);
    const createPiecewise = n2 > 2 ? createPolyMap2 : createBiMap2;
    const createInterpolate = shouldRound ? createInterpolateRound2 : interpolate5;
    return createPiecewise(domain, range3, createInterpolate);
  };
  var Continuous2 = class extends Base2 {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        nice: false,
        clamp: false,
        round: false,
        interpolate: createInterpolateNumber2,
        tickCount: 5
      };
    }
    /**
     * y = interpolate(normalize(clamp(transform(x))))
     */
    map(x3) {
      if (!isValid2(x3))
        return this.options.unknown;
      return this.output(x3);
    }
    /**
     * x = transform(clamp(interpolate(normalize(y))))
     */
    invert(x3) {
      if (!isValid2(x3))
        return this.options.unknown;
      return this.input(x3);
    }
    nice() {
      if (!this.options.nice)
        return;
      const [min10, max10, tickCount, ...rest] = this.getTickMethodOptions();
      this.options.domain = this.chooseNice()(min10, max10, tickCount, ...rest);
    }
    getTicks() {
      const { tickMethod } = this.options;
      const [min10, max10, tickCount, ...rest] = this.getTickMethodOptions();
      return tickMethod(min10, max10, tickCount, ...rest);
    }
    getTickMethodOptions() {
      const { domain, tickCount } = this.options;
      const min10 = domain[0];
      const max10 = domain[domain.length - 1];
      return [min10, max10, tickCount];
    }
    chooseNice() {
      return d3LinearNice2;
    }
    rescale() {
      this.nice();
      const [transform, untransform] = this.chooseTransforms();
      this.composeOutput(transform, this.chooseClamp(transform));
      this.composeInput(transform, untransform, this.chooseClamp(untransform));
    }
    chooseClamp(transform) {
      const { clamp: shouldClamp, range: range3 } = this.options;
      const domain = this.options.domain.map(transform);
      const n2 = Math.min(domain.length, range3.length);
      return shouldClamp ? createClamp2(domain[0], domain[n2 - 1]) : identity_default2;
    }
    composeOutput(transform, clamp7) {
      const { domain, range: range3, round: round5, interpolate: interpolate5 } = this.options;
      const piecewise = choosePiecewise2(domain.map(transform), range3, interpolate5, round5);
      this.output = compose3(piecewise, clamp7, transform);
    }
    composeInput(transform, untransform, clamp7) {
      const { domain, range: range3 } = this.options;
      const piecewise = choosePiecewise2(range3, domain.map(transform), createInterpolateNumber2);
      this.input = compose3(untransform, clamp7, piecewise);
    }
  };

  // ../../engine/rails_design/node_modules/@antv/component/node_modules/@antv/scale/esm/scales/linear.js
  var Linear3 = class _Linear extends Continuous2 {
    getDefaultOptions() {
      return {
        domain: [0, 1],
        range: [0, 1],
        unknown: void 0,
        nice: false,
        clamp: false,
        round: false,
        interpolate: createInterpolateValue2,
        tickMethod: d3Ticks2,
        tickCount: 5
      };
    }
    chooseTransforms() {
      return [identity_default2, identity_default2];
    }
    clone() {
      return new _Linear(this.options);
    }
  };

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/sparkline/columns.js
  var Columns = (
    /** @class */
    function(_super) {
      __extends(Columns2, _super);
      function Columns2(_a) {
        var _this = this;
        var style = _a.style, rest = __rest(_a, ["style"]);
        _this = _super.call(this, deep_mix_default2({}, { type: "column" }, __assign({ style }, rest))) || this;
        _this.columnsGroup = new Group2({ name: "columns" });
        _this.appendChild(_this.columnsGroup);
        _this.render();
        return _this;
      }
      Columns2.prototype.render = function() {
        var _a = this.attributes, columns = _a.columns, x3 = _a.x, y3 = _a.y;
        this.columnsGroup.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        select2(this.columnsGroup).selectAll(".column").data(columns.flat()).join(function(enter) {
          return enter.append("rect").attr("className", "column").each(function(style) {
            this.attr(style);
          });
        }, function(update) {
          return update.each(function(style) {
            this.attr(style);
          });
        }, function(exit) {
          return exit.remove();
        });
      };
      Columns2.prototype.update = function(attr2) {
        this.attr(deepAssign2({}, this.attributes, attr2));
        this.render();
      };
      Columns2.prototype.clear = function() {
        this.removeChildren();
      };
      return Columns2;
    }(DisplayObject)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/sparkline/lines.js
  var Lines = (
    /** @class */
    function(_super) {
      __extends(Lines2, _super);
      function Lines2(_a) {
        var _this = this;
        var style = _a.style, rest = __rest(_a, ["style"]);
        _this = _super.call(this, deep_mix_default2({}, { type: "lines" }, __assign({ style }, rest))) || this;
        _this.linesGroup = _this.appendChild(new Group2());
        _this.areasGroup = _this.appendChild(new Group2());
        _this.render();
        return _this;
      }
      Lines2.prototype.render = function() {
        var _a = this.attributes, lines = _a.lines, areas = _a.areas, x3 = _a.x, y3 = _a.y;
        this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        if (lines)
          this.renderLines(lines);
        if (areas)
          this.renderAreas(areas);
      };
      Lines2.prototype.clear = function() {
        this.linesGroup.removeChildren();
        this.areasGroup.removeChildren();
      };
      Lines2.prototype.update = function(attr2) {
        this.attr(deepAssign2({}, this.attributes, attr2));
        this.render();
      };
      Lines2.prototype.renderLines = function(lines) {
        select2(this.linesGroup).selectAll(".line").data(lines).join(function(enter) {
          return enter.append("path").attr("className", "line").each(function(style) {
            this.attr(style);
          });
        }, function(update) {
          return update.each(function(style) {
            this.attr(style);
          });
        }, function(exit) {
          return exit.remove();
        });
      };
      Lines2.prototype.renderAreas = function(areas) {
        select2(this.linesGroup).selectAll(".area").data(areas).join(function(enter) {
          return enter.append("path").attr("className", "area").each(function(style) {
            this.attr(style);
          });
        }, function(update) {
          return update.each(function(style) {
            this.style(style);
          });
        }, function(exit) {
          return exit.remove();
        });
      };
      return Lines2;
    }(DisplayObject)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/sparkline/path.js
  function dataToLines(data2, scales) {
    var _a;
    var x3 = scales.x, y3 = scales.y;
    var _b = __read(y3.getOptions().range || [0, 0], 2), max10 = _b[0], min10 = _b[1];
    if (min10 > max10)
      _a = __read([max10, min10], 2), min10 = _a[0], max10 = _a[1];
    return data2.map(function(points) {
      var lines = points.map(function(val, idx) {
        return [x3.map(idx), clamp_default3(y3.map(val), min10, max10)];
      });
      return lines;
    });
  }
  function lineToLinePath(line4, reverse) {
    if (reverse === void 0) {
      reverse = false;
    }
    var M2 = reverse ? line4.length - 1 : 0;
    var linePath = line4.map(function(point6, idx) {
      return __spreadArray([idx === M2 ? "M" : "L"], __read(point6), false);
    });
    return reverse ? linePath.reverse() : linePath;
  }
  function lineToCurvePath(line4, reverse) {
    if (reverse === void 0) {
      reverse = false;
    }
    if (line4.length <= 2) {
      return lineToLinePath(line4);
    }
    var data2 = [];
    var len5 = line4.length;
    for (var idx = 0; idx < len5; idx += 1) {
      var point6 = reverse ? line4[len5 - idx - 1] : line4[idx];
      if (!is_equal_default2(point6, data2.slice(-2))) {
        data2.push.apply(data2, __spreadArray([], __read(point6), false));
      }
    }
    var path2 = catmullRom2Bezier(data2, false);
    if (reverse) {
      path2.unshift(__spreadArray(["M"], __read(line4[len5 - 1]), false));
    } else {
      path2.unshift(__spreadArray(["M"], __read(line4[0]), false));
    }
    return path2;
  }
  function closePathByBaseLine(path2, width, baseline) {
    var closedPath = clone_default(path2);
    closedPath.push(["L", width, baseline], ["L", 0, baseline], ["Z"]);
    return closedPath;
  }
  function linesToAreaPaths(lines, smooth3, width, baseline) {
    return lines.map(function(line4) {
      return closePathByBaseLine(smooth3 ? lineToCurvePath(line4) : lineToLinePath(line4), width, baseline);
    });
  }
  function linesToStackAreaPaths(lines, width, baseline) {
    var paths = [];
    for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
      var currLine = lines[idx];
      var currCurvePath = lineToLinePath(currLine);
      var path2 = void 0;
      if (idx === 0) {
        path2 = closePathByBaseLine(currCurvePath, width, baseline);
      } else {
        var belowLine = lines[idx - 1];
        var belowCurvePath = lineToLinePath(belowLine, true);
        belowCurvePath[0][0] = "L";
        path2 = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [["Z"]], false);
      }
      paths.push(path2);
    }
    return paths;
  }
  function linesToStackCurveAreaPaths(lines, width, baseline) {
    var paths = [];
    for (var idx = lines.length - 1; idx >= 0; idx -= 1) {
      var currLine = lines[idx];
      var currCurvePath = lineToCurvePath(currLine);
      var path2 = void 0;
      if (idx === 0) {
        path2 = closePathByBaseLine(currCurvePath, width, baseline);
      } else {
        var belowLine = lines[idx - 1];
        var belowCurvePath = lineToCurvePath(belowLine, true);
        var A5 = currLine[0];
        belowCurvePath[0][0] = "L";
        path2 = __spreadArray(__spreadArray(__spreadArray([], __read(currCurvePath), false), __read(belowCurvePath), false), [__spreadArray(["M"], __read(A5), false), ["Z"]], false);
      }
      paths.push(path2);
    }
    return paths;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/sparkline/utils.js
  function getRange(data2) {
    if (data2.length === 0)
      return [0, 0];
    return [min_default2(min_by_default(data2, function(arr) {
      return min_default2(arr) || 0;
    })), max_default2(max_by_default(data2, function(arr) {
      return max_default2(arr) || 0;
    }))];
  }
  function getStackedData(_2) {
    var data2 = clone_default(_2);
    var datumLen = data2[0].length;
    var _a = __read([Array(datumLen).fill(0), Array(datumLen).fill(0)], 2), positivePrev = _a[0], negativePrev = _a[1];
    for (var i = 0; i < data2.length; i += 1) {
      var datum = data2[i];
      for (var j = 0; j < datumLen; j += 1) {
        if (datum[j] >= 0) {
          datum[j] += positivePrev[j];
          positivePrev[j] = datum[j];
        } else {
          datum[j] += negativePrev[j];
          negativePrev[j] = datum[j];
        }
      }
    }
    return data2;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/sparkline/index.js
  var Sparkline = (
    /** @class */
    function(_super) {
      __extends(Sparkline2, _super);
      function Sparkline2(options) {
        return _super.call(this, options, {
          type: "line",
          x: 0,
          y: 0,
          width: 200,
          height: 20,
          isStack: false,
          color: ["#83daad", "#edbf45", "#d2cef9", "#e290b3", "#6f63f4"],
          smooth: true,
          lineLineWidth: 1,
          areaOpacity: 0,
          isGroup: false,
          columnLineWidth: 1,
          columnStroke: "#fff",
          scale: 1,
          spacing: 0
        }) || this;
      }
      Object.defineProperty(Sparkline2.prototype, "rawData", {
        /**
         * 将data统一格式化为数组形式
         * 如果堆叠，则生成堆叠数据
         */
        get: function() {
          var rawData = this.attributes.data;
          if (!rawData || (rawData === null || rawData === void 0 ? void 0 : rawData.length) === 0)
            return [[]];
          var data2 = clone_default(rawData);
          return is_number_default5(data2[0]) ? [data2] : data2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "data", {
        get: function() {
          if (this.attributes.isStack)
            return getStackedData(this.rawData);
          return this.rawData;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "scales", {
        get: function() {
          return this.createScales(this.data);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "baseline", {
        /**
         * 基准线，默认为 0
         */
        get: function() {
          var y3 = this.scales.y;
          var _a = __read(y3.getOptions().domain || [0, 0], 2), y12 = _a[0], y22 = _a[1];
          if (y22 < 0) {
            return y3.map(y22);
          }
          return y3.map(y12 < 0 ? 0 : y12);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "containerShape", {
        get: function() {
          var _a = this.attributes, width = _a.width, height = _a.height;
          return { width, height };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "linesStyle", {
        get: function() {
          var _this = this;
          var _a = this.attributes, type = _a.type, isStack = _a.isStack, smooth3 = _a.smooth;
          if (type !== "line")
            throw new Error("linesStyle can only be used in line type");
          var areaStyle = subStyleProps(this.attributes, "area");
          var lineStyle = subStyleProps(this.attributes, "line");
          var width = this.containerShape.width;
          var data2 = this.data;
          if (data2[0].length === 0)
            return { lines: [], areas: [] };
          var _b = this.scales, x3 = _b.x, y3 = _b.y;
          var lines = dataToLines(data2, { type: "line", x: x3, y: y3 });
          var areas = [];
          if (areaStyle) {
            var baseline = this.baseline;
            if (isStack) {
              areas = smooth3 ? linesToStackCurveAreaPaths(lines, width, baseline) : linesToStackAreaPaths(lines, width, baseline);
            } else {
              areas = linesToAreaPaths(lines, smooth3, width, baseline);
            }
          }
          return {
            lines: lines.map(function(line4, idx) {
              return __assign({ stroke: _this.getColor(idx), d: smooth3 ? lineToCurvePath(line4) : lineToLinePath(line4) }, lineStyle);
            }),
            areas: areas.map(function(path2, idx) {
              return __assign({ d: path2, fill: _this.getColor(idx) }, areaStyle);
            })
          };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Sparkline2.prototype, "columnsStyle", {
        get: function() {
          var _this = this;
          var columnStyle = subStyleProps(this.attributes, "column");
          var _a = this.attributes, isStack = _a.isStack, type = _a.type, scale9 = _a.scale;
          if (type !== "column")
            throw new Error("columnsStyle can only be used in column type");
          var height = this.containerShape.height;
          var data2 = this.rawData;
          if (!data2)
            return { columns: [] };
          if (isStack)
            data2 = getStackedData(data2);
          var _b = this.createScales(data2), x3 = _b.x, y3 = _b.y;
          var _c = __read(getRange(data2), 2), minVal = _c[0], maxVal = _c[1];
          var heightScale = new Linear3({
            domain: [0, maxVal - (minVal > 0 ? 0 : minVal)],
            range: [0, height * scale9]
          });
          var bandWidth3 = x3.getBandWidth();
          var rawData = this.rawData;
          return {
            columns: data2.map(function(column2, i) {
              return column2.map(function(val, j) {
                var barWidth = bandWidth3 / data2.length;
                var getShape2 = function() {
                  return {
                    x: x3.map(j) + barWidth * i,
                    y: val >= 0 ? y3.map(val) : y3.map(0),
                    width: barWidth,
                    height: heightScale.map(Math.abs(val))
                  };
                };
                var getStackShape = function() {
                  return {
                    x: x3.map(j),
                    y: y3.map(val),
                    width: bandWidth3,
                    height: heightScale.map(rawData[i][j])
                  };
                };
                return __assign(__assign({ fill: _this.getColor(i) }, columnStyle), isStack ? getStackShape() : getShape2());
              });
            })
          };
        },
        enumerable: false,
        configurable: true
      });
      Sparkline2.prototype.render = function(attributes, container) {
        maybeAppend(container, ".container", "rect").attr("className", "container").node();
        var type = attributes.type, x3 = attributes.x, y3 = attributes.y;
        var className2 = "spark".concat(type);
        var style = __assign({ x: x3, y: y3 }, type === "line" ? this.linesStyle : this.columnsStyle);
        select2(container).selectAll(".spark").data([type]).join(function(enter) {
          return enter.append(function(type2) {
            if (type2 === "line")
              return new Lines({ className: className2, style });
            return new Columns({ className: className2, style });
          }).attr("className", "spark ".concat(className2));
        }, function(update) {
          return update.update(style);
        }, function(exit) {
          return exit.remove();
        });
      };
      Sparkline2.prototype.getColor = function(index4) {
        var color2 = this.attributes.color;
        if (is_array_default3(color2)) {
          return color2[index4 % color2.length];
        }
        if (is_function_default2(color2)) {
          return color2.call(null, index4);
        }
        return color2;
      };
      Sparkline2.prototype.createScales = function(data2) {
        var _a, _b;
        var _c = this.attributes, type = _c.type, scale9 = _c.scale, _d = _c.range, range3 = _d === void 0 ? [] : _d, spacing = _c.spacing;
        var _e = this.containerShape, width = _e.width, height = _e.height;
        var _f = __read(getRange(data2), 2), minVal = _f[0], maxVal = _f[1];
        var yScale = new Linear3({
          domain: [(_a = range3[0]) !== null && _a !== void 0 ? _a : minVal, (_b = range3[1]) !== null && _b !== void 0 ? _b : maxVal],
          range: [height, height * (1 - scale9)]
        });
        if (type === "line") {
          return {
            type,
            x: new Linear3({
              domain: [0, data2[0].length - 1],
              range: [0, width]
            }),
            y: yScale
          };
        }
        return {
          type,
          x: new Band2({
            domain: data2[0].map(function(val, idx) {
              return idx;
            }),
            range: [0, width],
            paddingInner: spacing,
            paddingOuter: spacing / 2,
            align: 0.5
          }),
          y: yScale
        };
      };
      Sparkline2.tag = "sparkline";
      return Sparkline2;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/animation/utils.js
  function isStandardAnimationOption(option2) {
    if (typeof option2 === "boolean")
      return false;
    return "enter" in option2 && "update" in option2 && "exit" in option2;
  }
  function parseAnimationOption(option2) {
    if (!option2)
      return { enter: false, update: false, exit: false };
    var keys2 = ["enter", "update", "exit"];
    var baseOption = Object.fromEntries(Object.entries(option2).filter(function(_a) {
      var _b = __read(_a, 1), k = _b[0];
      return !keys2.includes(k);
    }));
    return Object.fromEntries(keys2.map(function(k) {
      if (isStandardAnimationOption(option2)) {
        if (option2[k] === false)
          return [k, false];
        return [k, __assign(__assign({}, option2[k]), baseOption)];
      }
      return [k, baseOption];
    }));
  }
  function onAnimateFinished(animation, callback) {
    if (!animation)
      callback();
    else
      animation.finished.then(callback);
  }
  function onAnimatesFinished(animations, callback) {
    if (animations.length === 0)
      callback();
    else
      Promise.all(animations.map(function(a3) {
        return a3 === null || a3 === void 0 ? void 0 : a3.finished;
      })).then(callback);
  }
  function attr(target, value2) {
    if ("update" in target)
      target.update(value2);
    else
      target.attr(value2);
  }
  function animate(target, keyframes, options) {
    if (keyframes.length === 0)
      return null;
    if (!options) {
      var state = keyframes.slice(-1)[0];
      attr(target, { style: state });
      return null;
    }
    return target.animate(keyframes, options);
  }
  function identicalTextNode(source, target) {
    if (source.nodeName !== "text" || target.nodeName !== "text")
      return false;
    if (source.attributes.text !== target.attributes.text)
      return false;
    return true;
  }
  function transitionShape(source, target, options, after) {
    if (after === void 0) {
      after = "destroy";
    }
    if (identicalTextNode(source, target)) {
      source.remove();
      return [null];
    }
    var afterTransition = function() {
      if (after === "destroy")
        source.destroy();
      else if (after === "hide")
        hide(source);
      if (target.isVisible())
        show(target);
    };
    if (!options) {
      afterTransition();
      return [null];
    }
    var _a = options.duration, duration = _a === void 0 ? 0 : _a, _b = options.delay, delay = _b === void 0 ? 0 : _b;
    var middle = Math.ceil(+duration / 2);
    var offset3 = +duration / 4;
    var _c = __read(source.getGeometryBounds().center, 2), sx = _c[0], sy = _c[1];
    var _d = __read(target.getGeometryBounds().center, 2), ex = _d[0], ey = _d[1];
    var _e = __read([(sx + ex) / 2 - sx, (sy + ey) / 2 - sy], 2), mx = _e[0], my = _e[1];
    var _f = source.style.opacity, so = _f === void 0 ? 1 : _f;
    var _g = target.style.opacity, to = _g === void 0 ? 1 : _g;
    var st = source.style.transform || "";
    var tt = target.style.transform || "";
    var sourceAnimation = source.animate([
      { opacity: so, transform: "translate(0, 0) ".concat(st) },
      { opacity: 0, transform: "translate(".concat(mx, ", ").concat(my, ") ").concat(st) }
    ], __assign(__assign({ fill: "both" }, options), { duration: delay + middle + offset3 }));
    var targetAnimation = target.animate([
      { opacity: 0, transform: "translate(".concat(-mx, ", ").concat(-my, ") ").concat(tt), offset: 0.01 },
      { opacity: to, transform: "translate(0, 0) ".concat(tt) }
    ], __assign(__assign({ fill: "both" }, options), { duration: middle + offset3, delay: delay + middle - offset3 }));
    onAnimateFinished(targetAnimation, afterTransition);
    return [sourceAnimation, targetAnimation];
  }
  function transition(target, state, options) {
    var from = {};
    var to = {};
    Object.entries(state).forEach(function(_a) {
      var _b = __read(_a, 2), key = _b[0], tarStyle = _b[1];
      if (!is_nil_default4(tarStyle)) {
        var currStyle = target.style[key] || target.parsedStyle[key] || 0;
        if (currStyle !== tarStyle) {
          from[key] = currStyle;
          to[key] = tarStyle;
        }
      }
    });
    if (!options) {
      attr(target, to);
      return null;
    }
    return animate(target, [from, to], __assign({ fill: "both" }, options));
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/animation/fadeOut.js
  function fadeOut_default(element, options) {
    if (!element.style.opacity)
      element.style.opacity = 1;
    return transition(element, { opacity: 0 }, options);
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/slider/constant.js
  var HANDLE_ICON_DEFAULT_CFG = {
    fill: "#fff",
    lineWidth: 1,
    radius: 2,
    size: 10,
    stroke: "#bfbfbf",
    strokeOpacity: 1,
    zIndex: 0
  };
  var HANDLE_LABEL_DEFAULT_CFG = {
    fill: "#000",
    fillOpacity: 0.45,
    fontSize: 12,
    textAlign: "center",
    textBaseline: "middle",
    zIndex: 1
  };
  var HANDLE_DEFAULT_CFG = {
    x: 0,
    y: 0,
    orientation: "horizontal",
    showLabel: true,
    type: "start"
  };
  var CLASS_NAMES = classNames({
    foreground: "foreground",
    handle: "handle",
    selection: "selection",
    sparkline: "sparkline",
    sparklineGroup: "sparkline-group",
    track: "track",
    brushArea: "brush-area"
  }, "slider");

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/slider/handle.js
  var CLASS_NAMES2 = classNames({
    labelGroup: "label-group",
    label: "label",
    iconGroup: "icon-group",
    icon: "icon",
    iconRect: "icon-rect",
    iconLine: "icon-line"
  }, "handle");
  var HandleIcon = (
    /** @class */
    function(_super) {
      __extends(HandleIcon2, _super);
      function HandleIcon2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      HandleIcon2.prototype.render = function(attributes, container) {
        var x3 = attributes.x, y3 = attributes.y, _a = attributes.size, size2 = _a === void 0 ? 10 : _a, _b = attributes.radius, radius = _b === void 0 ? size2 / 4 : _b, orientation = attributes.orientation, iconStyle = __rest(attributes, ["x", "y", "size", "radius", "orientation"]);
        var width = size2;
        var height = width * 2.4;
        var rect4 = select2(container).maybeAppendByClassName(CLASS_NAMES2.iconRect, "rect").styles(__assign(__assign({}, iconStyle), { width, height, radius, x: x3 - width / 2, y: y3 - height / 2, transformOrigin: "center" }));
        var x12 = x3 + 1 / 3 * width - width / 2;
        var x22 = x3 + 2 / 3 * width - width / 2;
        var y12 = y3 + 1 / 4 * height - height / 2;
        var y22 = y3 + 3 / 4 * height - height / 2;
        rect4.maybeAppendByClassName("".concat(CLASS_NAMES2.iconLine, "-1"), "line").styles(__assign({ x1: x12, x2: x12, y1: y12, y2: y22 }, iconStyle));
        rect4.maybeAppendByClassName("".concat(CLASS_NAMES2.iconLine, "-2"), "line").styles(__assign({ x1: x22, x2: x22, y1: y12, y2: y22 }, iconStyle));
        if (orientation === "vertical")
          rect4.node().style.transform = "rotate(90)";
      };
      return HandleIcon2;
    }(Component)
  );
  var Handle = (
    /** @class */
    function(_super) {
      __extends(Handle3, _super);
      function Handle3(options) {
        return _super.call(this, options, HANDLE_DEFAULT_CFG) || this;
      }
      Handle3.prototype.renderLabel = function(container) {
        var _this = this;
        var _a = this.attributes, x3 = _a.x, y3 = _a.y, showLabel = _a.showLabel;
        var _b = subStyleProps(this.attributes, "label"), _c = _b.x, labelX = _c === void 0 ? 0 : _c, _d = _b.y, labelY = _d === void 0 ? 0 : _d, transform = _b.transform, transformOrigin = _b.transformOrigin, style = __rest(_b, ["x", "y", "transform", "transformOrigin"]);
        var _e = __read(splitStyle(style, []), 2), labelStyle = _e[0], groupStyle = _e[1];
        var labelGroup = select2(container).maybeAppendByClassName(CLASS_NAMES2.labelGroup, "g").styles(groupStyle);
        var _f = __assign(__assign({}, HANDLE_LABEL_DEFAULT_CFG), labelStyle), text = _f.text, rest = __rest(_f, ["text"]);
        ifShow(!!showLabel, labelGroup, function(group3) {
          _this.label = group3.maybeAppendByClassName(CLASS_NAMES2.label, "text").styles(__assign(__assign({}, rest), { x: x3 + labelX, y: y3 + labelY, transform, transformOrigin, text: "".concat(text) }));
          _this.label.on("mousedown", function(e3) {
            e3.stopPropagation();
          });
          _this.label.on("touchstart", function(e3) {
            e3.stopPropagation();
          });
        });
      };
      Handle3.prototype.renderIcon = function(container) {
        var _a = this.attributes, x3 = _a.x, y3 = _a.y, orientation = _a.orientation, type = _a.type;
        var iconStyle = __assign(__assign({ x: x3, y: y3, orientation }, HANDLE_ICON_DEFAULT_CFG), subStyleProps(this.attributes, "icon"));
        var _b = this.attributes.iconShape, iconShape = _b === void 0 ? function() {
          return new HandleIcon({ style: iconStyle });
        } : _b;
        var iconGroup = select2(container).maybeAppendByClassName(CLASS_NAMES2.iconGroup, "g");
        iconGroup.selectAll(CLASS_NAMES2.icon.class).data([iconShape]).join(function(enter) {
          return enter.append(typeof iconShape === "string" ? iconShape : function() {
            return iconShape(type);
          }).attr("className", CLASS_NAMES2.icon.name);
        }, function(update) {
          return update.update(iconStyle);
        }, function(exit) {
          return exit.remove();
        });
      };
      Handle3.prototype.render = function(attributes, container) {
        this.renderIcon(container);
        this.renderLabel(container);
      };
      return Handle3;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/slider/index.js
  var Slider = (
    /** @class */
    function(_super) {
      __extends(Slider3, _super);
      function Slider3(options) {
        var _this = _super.call(this, options, __assign(__assign(__assign({ x: 0, y: 0, animate: { duration: 100, fill: "both" }, brushable: true, formatter: function(val) {
          return val.toString();
        }, handleSpacing: 2, orientation: "horizontal", padding: 0, autoFitLabel: true, scrollable: true, selectionFill: "#5B8FF9", selectionFillOpacity: 0.45, selectionZIndex: 2, showHandle: true, showLabel: true, slidable: true, trackFill: "#416180", trackLength: 200, trackOpacity: 0.05, trackSize: 20, trackZIndex: -1, values: [0, 1], type: "range", selectionType: "select", handleIconOffset: 0 }, superStyleProps(HANDLE_DEFAULT_CFG, "handle")), superStyleProps(HANDLE_ICON_DEFAULT_CFG, "handleIcon")), superStyleProps(HANDLE_LABEL_DEFAULT_CFG, "handleLabel"))) || this;
        _this.range = [0, 1];
        _this.onDragStart = function(target) {
          return function(e3) {
            e3.stopPropagation();
            _this.target = target;
            _this.prevPos = _this.getOrientVal(getEventPos(e3));
            var _a = _this.availableSpace, x3 = _a.x, y3 = _a.y;
            var _b = _this.getBBox(), X = _b.x, Y = _b.y;
            _this.selectionStartPos = _this.getRatio(_this.prevPos - _this.getOrientVal([x3, y3]) - _this.getOrientVal([+X, +Y]));
            _this.selectionWidth = 0;
            document.addEventListener("pointermove", _this.onDragging);
            document.addEventListener("pointerup", _this.onDragEnd);
          };
        };
        _this.onDragging = function(e3) {
          var _a = _this.attributes, slidable = _a.slidable, brushable = _a.brushable, type = _a.type;
          e3.stopPropagation();
          var currPos = _this.getOrientVal(getEventPos(e3));
          var diffPos = currPos - _this.prevPos;
          if (!diffPos)
            return;
          var deltaVal = _this.getRatio(diffPos);
          switch (_this.target) {
            case "start":
              if (slidable)
                _this.setValuesOffset(deltaVal);
              break;
            case "end":
              if (slidable)
                _this.setValuesOffset(0, deltaVal);
              break;
            case "selection":
              if (slidable)
                _this.setValuesOffset(deltaVal, deltaVal);
              break;
            case "track":
              if (!brushable)
                return;
              _this.selectionWidth += deltaVal;
              if (type === "range") {
                _this.innerSetValues([_this.selectionStartPos, _this.selectionStartPos + _this.selectionWidth].sort(), true);
              } else
                _this.innerSetValues([0, _this.selectionStartPos + _this.selectionWidth], true);
              break;
            default:
              break;
          }
          _this.prevPos = currPos;
        };
        _this.onDragEnd = function() {
          document.removeEventListener("pointermove", _this.onDragging);
          document.removeEventListener("pointermove", _this.onDragging);
          document.removeEventListener("pointerup", _this.onDragEnd);
          _this.target = "";
          _this.updateHandlesPosition(false);
        };
        _this.onValueChange = function(oldValue) {
          var _a = _this.attributes, onChange = _a.onChange, type = _a.type;
          var internalOldValue = type === "range" ? oldValue : oldValue[1];
          var value2 = type === "range" ? _this.getValues() : _this.getValues()[1];
          var evt = new CustomEvent2("valuechange", {
            detail: { oldValue: internalOldValue, value: value2 }
          });
          _this.dispatchEvent(evt);
          onChange === null || onChange === void 0 ? void 0 : onChange(value2);
        };
        _this.selectionStartPos = 0;
        _this.selectionWidth = 0;
        _this.prevPos = 0;
        _this.target = "";
        return _this;
      }
      Object.defineProperty(Slider3.prototype, "values", {
        get: function() {
          return this.attributes.values;
        },
        set: function(values) {
          this.attributes.values = this.clampValues(values);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Slider3.prototype, "sparklineStyle", {
        get: function() {
          var orientation = this.attributes.orientation;
          if (orientation !== "horizontal")
            return null;
          var attr2 = subStyleProps(this.attributes, "sparkline");
          return __assign(__assign({ zIndex: 0 }, this.availableSpace), attr2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Slider3.prototype, "shape", {
        get: function() {
          var _a = this.attributes, trackLength = _a.trackLength, trackSize = _a.trackSize;
          var _b = __read(this.getOrientVal([
            [trackLength, trackSize],
            [trackSize, trackLength]
          ]), 2), width = _b[0], height = _b[1];
          return { width, height };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Slider3.prototype, "availableSpace", {
        get: function() {
          var _a = this.attributes, x3 = _a.x, y3 = _a.y, padding = _a.padding;
          var _b = __read(parseSeriesAttr(padding), 4), top = _b[0], right2 = _b[1], bottom = _b[2], left2 = _b[3];
          var _c = this.shape, width = _c.width, height = _c.height;
          return {
            x: left2,
            y: top,
            width: width - (left2 + right2),
            height: height - (top + bottom)
          };
        },
        enumerable: false,
        configurable: true
      });
      Slider3.prototype.getValues = function() {
        return this.values;
      };
      Slider3.prototype.setValues = function(values, animate2) {
        if (values === void 0) {
          values = [0, 0];
        }
        if (animate2 === void 0) {
          animate2 = false;
        }
        this.attributes.values = values;
        var animation = animate2 === false ? false : this.attributes.animate;
        this.updateSelectionArea(animation);
        this.updateHandlesPosition(animation);
      };
      Slider3.prototype.updateSelectionArea = function(animation) {
        var newSelectionArea = this.calcSelectionArea();
        this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).each(function(datum, index4) {
          transition(this, newSelectionArea[index4], animation);
        });
      };
      Slider3.prototype.updateHandlesPosition = function(animation) {
        if (!this.attributes.showHandle)
          return;
        this.startHandle && transition(this.startHandle, this.getHandleStyle("start"), animation);
        this.endHandle && transition(this.endHandle, this.getHandleStyle("end"), animation);
      };
      Slider3.prototype.innerSetValues = function(values, trigger) {
        if (values === void 0) {
          values = [0, 0];
        }
        if (trigger === void 0) {
          trigger = false;
        }
        var oldValues = this.values;
        var newValues = this.clampValues(values);
        this.attributes.values = newValues;
        this.setValues(newValues);
        if (trigger) {
          this.onValueChange(oldValues);
        }
      };
      Slider3.prototype.renderTrack = function(container) {
        var _a = this.attributes, x3 = _a.x, y3 = _a.y;
        var style = subStyleProps(this.attributes, "track");
        this.trackShape = select2(container).maybeAppendByClassName(CLASS_NAMES.track, "rect").styles(__assign(__assign({ x: x3, y: y3 }, this.shape), style));
      };
      Slider3.prototype.renderBrushArea = function(container) {
        var _a = this.attributes, x3 = _a.x, y3 = _a.y, brushable = _a.brushable;
        this.brushArea = select2(container).maybeAppendByClassName(CLASS_NAMES.brushArea, "rect").styles(__assign({ x: x3, y: y3, fill: "transparent", cursor: brushable ? "crosshair" : "default" }, this.shape));
      };
      Slider3.prototype.renderSparkline = function(container) {
        var _this = this;
        var _a = this.attributes, x3 = _a.x, y3 = _a.y, orientation = _a.orientation;
        var sparklineGroup = select2(container).maybeAppendByClassName(CLASS_NAMES.sparklineGroup, "g");
        ifShow(orientation === "horizontal", sparklineGroup, function(group3) {
          var style = __assign(__assign({}, _this.sparklineStyle), { x: x3, y: y3 });
          group3.maybeAppendByClassName(CLASS_NAMES.sparkline, function() {
            return new Sparkline({ style });
          }).update(style);
        });
      };
      Slider3.prototype.renderHandles = function() {
        var _this = this;
        var _a;
        var _b = this.attributes, showHandle = _b.showHandle, type = _b.type;
        var availableHandle = type === "range" ? ["start", "end"] : ["end"];
        var data2 = showHandle ? availableHandle : [];
        var that = this;
        (_a = this.foregroundGroup) === null || _a === void 0 ? void 0 : _a.selectAll(CLASS_NAMES.handle.class).data(data2.map(function(type2) {
          return { type: type2 };
        }), function(d2) {
          return d2.type;
        }).join(function(enter) {
          return enter.append(function(_a2) {
            var type2 = _a2.type;
            return new Handle({ style: _this.getHandleStyle(type2) });
          }).each(function(_a2) {
            var type2 = _a2.type;
            this.attr("class", "".concat(CLASS_NAMES.handle.name, " ").concat(type2, "-handle"));
            var name2 = "".concat(type2, "Handle");
            that[name2] = this;
            this.addEventListener("pointerdown", that.onDragStart(type2));
          });
        }, function(update) {
          return update.each(function(_a2) {
            var type2 = _a2.type;
            this.update(that.getHandleStyle(type2));
          });
        }, function(exit) {
          return exit.each(function(_a2) {
            var type2 = _a2.type;
            var name2 = "".concat(type2, "Handle");
            that[name2] = void 0;
          }).remove();
        });
      };
      Slider3.prototype.renderSelection = function(container) {
        var _a = this.attributes, x3 = _a.x, y3 = _a.y, type = _a.type, selectionType = _a.selectionType;
        this.foregroundGroup = select2(container).maybeAppendByClassName(CLASS_NAMES.foreground, "g");
        var selectionStyle = subStyleProps(this.attributes, "selection");
        var applyStyle4 = function(selection) {
          return selection.style("visibility", function(d2) {
            return d2.show ? "visible" : "hidden";
          }).style("cursor", function(d2) {
            if (selectionType === "select")
              return "grab";
            if (selectionType === "invert")
              return "crosshair";
            return "default";
          }).styles(__assign(__assign({}, selectionStyle), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }));
        };
        var that = this;
        this.foregroundGroup.selectAll(CLASS_NAMES.selection.class).data(type === "value" ? [] : this.calcSelectionArea().map(function(area2, index4) {
          return {
            style: __assign({}, area2),
            index: index4,
            // 是否可见
            show: selectionType === "select" ? index4 === 1 : index4 !== 1
          };
        }), function(d2) {
          return d2.index;
        }).join(function(enter) {
          return enter.append("rect").attr("className", CLASS_NAMES.selection.name).call(applyStyle4).each(function(datum, index4) {
            var _this = this;
            if (index4 === 1) {
              that.selectionShape = select2(this);
              this.on("pointerdown", function(e3) {
                _this.attr("cursor", "grabbing");
                that.onDragStart("selection")(e3);
              });
              that.dispatchCustomEvent(this, "pointerenter", "selectionMouseenter");
              that.dispatchCustomEvent(this, "pointerleave", "selectionMouseleave");
              that.dispatchCustomEvent(this, "click", "selectionClick");
              this.addEventListener("pointerdown", function() {
                _this.attr("cursor", "grabbing");
              });
              this.addEventListener("pointerup", function() {
                _this.attr("cursor", "pointer");
              });
              this.addEventListener("pointerover", function() {
                _this.attr("cursor", "pointer");
              });
            } else {
              this.on("pointerdown", that.onDragStart("track"));
            }
          });
        }, function(update) {
          return update.call(applyStyle4);
        }, function(exit) {
          return exit.remove();
        });
        this.updateSelectionArea(false);
        this.renderHandles();
      };
      Slider3.prototype.render = function(attributes, container) {
        this.renderTrack(container);
        this.renderSparkline(container);
        this.renderBrushArea(container);
        this.renderSelection(container);
      };
      Slider3.prototype.clampValues = function(values, precision) {
        var _a;
        if (precision === void 0) {
          precision = 4;
        }
        var _b = __read(this.range, 2), min10 = _b[0], max10 = _b[1];
        var _c = __read(this.getValues().map(function(num) {
          return toPrecision(num, precision);
        }), 2), prevStart = _c[0], prevEnd = _c[1];
        var internalValues = Array.isArray(values) ? values : [prevStart, values !== null && values !== void 0 ? values : prevEnd];
        var _d = __read((internalValues || [prevStart, prevEnd]).map(function(num) {
          return toPrecision(num, precision);
        }), 2), startVal = _d[0], endVal = _d[1];
        if (this.attributes.type === "value")
          return [0, clamp_default3(endVal, min10, max10)];
        if (startVal > endVal) {
          _a = __read([endVal, startVal], 2), startVal = _a[0], endVal = _a[1];
        }
        var range3 = endVal - startVal;
        if (range3 > max10 - min10)
          return [min10, max10];
        if (startVal < min10) {
          if (prevStart === min10 && prevEnd === endVal)
            return [min10, endVal];
          return [min10, range3 + min10];
        }
        if (endVal > max10) {
          if (prevEnd === max10 && prevStart === startVal)
            return [startVal, max10];
          return [max10 - range3, max10];
        }
        return [startVal, endVal];
      };
      Slider3.prototype.calcSelectionArea = function(values) {
        var _a = __read(this.clampValues(values), 2), start2 = _a[0], end = _a[1];
        var _b = this.availableSpace, x3 = _b.x, y3 = _b.y, width = _b.width, height = _b.height;
        return this.getOrientVal([
          [
            { y: y3, height, x: x3, width: start2 * width },
            { y: y3, height, x: start2 * width + x3, width: (end - start2) * width },
            { y: y3, height, x: end * width, width: (1 - end) * width }
          ],
          [
            { x: x3, width, y: y3, height: start2 * height },
            { x: x3, width, y: start2 * height + y3, height: (end - start2) * height },
            { x: x3, width, y: end * height, height: (1 - end) * height }
          ]
        ]);
      };
      Slider3.prototype.calcHandlePosition = function(handleType) {
        var handleIconOffset = this.attributes.handleIconOffset;
        var _a = this.availableSpace, x3 = _a.x, y3 = _a.y, width = _a.width, height = _a.height;
        var _b = __read(this.clampValues(), 2), stVal = _b[0], endVal = _b[1];
        var offset3 = handleType === "start" ? -handleIconOffset : handleIconOffset;
        var L = (handleType === "start" ? stVal : endVal) * this.getOrientVal([width, height]) + offset3;
        return {
          x: x3 + this.getOrientVal([L, width / 2]),
          y: y3 + this.getOrientVal([height / 2, L])
        };
      };
      Slider3.prototype.inferTextStyle = function(handleType) {
        var orientation = this.attributes.orientation;
        if (orientation === "horizontal")
          return {};
        if (handleType === "start")
          return { transformOrigin: "left center", transform: "rotate(90)", textAlign: "start" };
        if (handleType === "end")
          return { transformOrigin: "right center", transform: "rotate(90)", textAlign: "end" };
        return {};
      };
      Slider3.prototype.calcHandleText = function(handleType) {
        var _a;
        var _b = this.attributes, type = _b.type, orientation = _b.orientation, formatter2 = _b.formatter, autoFitLabel = _b.autoFitLabel;
        var handleStyle = subStyleProps(this.attributes, "handle");
        var labelStyle = subStyleProps(handleStyle, "label");
        var spacing = handleStyle.spacing;
        var size2 = this.getHandleSize();
        var values = this.clampValues();
        var value2 = handleType === "start" ? values[0] : values[1];
        var text = formatter2(value2);
        var temp = new Text2({
          style: __assign(__assign(__assign({}, labelStyle), this.inferTextStyle(handleType)), { text })
        });
        var _c = temp.getBBox(), textWidth = _c.width, textHeight = _c.height;
        temp.destroy();
        if (!autoFitLabel) {
          if (type === "value")
            return { text, x: 0, y: -textHeight - spacing };
          var finaleWidth = spacing + size2 + (orientation === "horizontal" ? textWidth / 2 : 0);
          return _a = { text }, _a[orientation === "horizontal" ? "x" : "y"] = handleType === "start" ? -finaleWidth : finaleWidth, _a;
        }
        var x3 = 0;
        var y3 = 0;
        var _d = this.availableSpace, iW = _d.width, iH = _d.height;
        var _e = this.calcSelectionArea()[1], fX = _e.x, fY = _e.y, fW = _e.width, fH = _e.height;
        var totalSpacing = spacing + size2;
        if (orientation === "horizontal") {
          var finalWidth = totalSpacing + textWidth / 2;
          if (handleType === "start") {
            var left2 = fX - totalSpacing - textWidth;
            x3 = left2 > 0 ? -finalWidth : finalWidth;
          } else {
            var sign3 = iW - fX - fW - totalSpacing > textWidth;
            x3 = sign3 ? finalWidth : -finalWidth;
          }
        } else {
          var positiveSize = totalSpacing;
          var negativeSize = textHeight + totalSpacing;
          if (handleType === "start") {
            y3 = fY - size2 > textHeight ? -negativeSize : positiveSize;
          } else {
            y3 = iH - (fY + fH) - size2 > textHeight ? negativeSize : -positiveSize;
          }
        }
        return { x: x3, y: y3, text };
      };
      Slider3.prototype.getHandleLabelStyle = function(handleType) {
        var style = subStyleProps(this.attributes, "handleLabel");
        return __assign(__assign(__assign({}, style), this.calcHandleText(handleType)), this.inferTextStyle(handleType));
      };
      Slider3.prototype.getHandleIconStyle = function() {
        var shape23 = this.attributes.handleIconShape;
        var style = subStyleProps(this.attributes, "handleIcon");
        var cursor = this.getOrientVal(["ew-resize", "ns-resize"]);
        var size2 = this.getHandleSize();
        return __assign({ cursor, shape: shape23, size: size2 }, style);
      };
      Slider3.prototype.getHandleStyle = function(handleType) {
        var _a = this.attributes, ox = _a.x, oy = _a.y, showLabel = _a.showLabel, showLabelOnInteraction = _a.showLabelOnInteraction, orientation = _a.orientation;
        var _b = this.calcHandlePosition(handleType), x3 = _b.x, y3 = _b.y;
        var textStyle = this.calcHandleText(handleType);
        var internalShowLabel = showLabel;
        if (!showLabel && showLabelOnInteraction) {
          if (this.target)
            internalShowLabel = true;
          else
            internalShowLabel = false;
        }
        return __assign(__assign(__assign({}, superStyleProps(this.getHandleIconStyle(), "icon")), superStyleProps(__assign(__assign({}, this.getHandleLabelStyle(handleType)), textStyle), "label")), { transform: "translate(".concat(x3 + ox, ", ").concat(y3 + oy, ")"), orientation, showLabel: internalShowLabel, type: handleType, zIndex: 3 });
      };
      Slider3.prototype.getHandleSize = function() {
        var _a = this.attributes, size2 = _a.handleIconSize, width = _a.width, height = _a.height;
        if (size2)
          return size2;
        return Math.floor((this.getOrientVal([+height, +width]) + 4) / 2.4);
      };
      Slider3.prototype.getOrientVal = function(_a) {
        var _b = __read(_a, 2), x3 = _b[0], y3 = _b[1];
        var orientation = this.attributes.orientation;
        return orientation === "horizontal" ? x3 : y3;
      };
      Slider3.prototype.setValuesOffset = function(stOffset, endOffset, animate2) {
        if (endOffset === void 0) {
          endOffset = 0;
        }
        if (animate2 === void 0) {
          animate2 = false;
        }
        var type = this.attributes.type;
        var _a = __read(this.getValues(), 2), oldStartVal = _a[0], oldEndVal = _a[1];
        var internalStartOffset = type === "range" ? stOffset : 0;
        var values = [oldStartVal + internalStartOffset, oldEndVal + endOffset].sort();
        if (animate2)
          this.setValues(values);
        else
          this.innerSetValues(values, true);
      };
      Slider3.prototype.getRatio = function(val) {
        var _a = this.availableSpace, width = _a.width, height = _a.height;
        return val / this.getOrientVal([width, height]);
      };
      Slider3.prototype.dispatchCustomEvent = function(target, event, name2) {
        var _this = this;
        target.on(event, function(e3) {
          e3.stopPropagation();
          _this.dispatchEvent(new CustomEvent2(name2, { detail: e3 }));
        });
      };
      Slider3.prototype.bindEvents = function() {
        this.addEventListener("wheel", this.onScroll);
        var brushArea = this.brushArea;
        this.dispatchCustomEvent(brushArea, "click", "trackClick");
        this.dispatchCustomEvent(brushArea, "pointerenter", "trackMouseenter");
        this.dispatchCustomEvent(brushArea, "pointerleave", "trackMouseleave");
        brushArea.on("pointerdown", this.onDragStart("track"));
      };
      Slider3.prototype.onScroll = function(event) {
        var scrollable = this.attributes.scrollable;
        if (scrollable) {
          var deltaX = event.deltaX, deltaY = event.deltaY;
          var offset3 = deltaY || deltaX;
          var deltaVal = this.getRatio(offset3);
          this.setValuesOffset(deltaVal, deltaVal, true);
        }
      };
      Slider3.tag = "slider";
      return Slider3;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/scrollbar/index.js
  var Scrollbar = (
    /** @class */
    function(_super) {
      __extends(Scrollbar3, _super);
      function Scrollbar3(options) {
        var _this = _super.call(this, options, {
          x: 0,
          y: 0,
          isRound: true,
          orientation: "vertical",
          padding: [2, 2, 2, 2],
          scrollable: true,
          slidable: true,
          thumbCursor: "default",
          trackSize: 10,
          value: 0
        }) || this;
        _this.range = [0, 1];
        _this.onValueChange = function(oldValue) {
          var newValue = _this.attributes.value;
          if (oldValue === newValue)
            return;
          var evtVal = {
            detail: {
              oldValue,
              value: newValue
            }
          };
          _this.dispatchEvent(new CustomEvent2("scroll", evtVal));
          _this.dispatchEvent(new CustomEvent2("valuechange", evtVal));
        };
        _this.onTrackClick = function(e3) {
          var slidable = _this.attributes.slidable;
          if (!slidable)
            return;
          var _a = __read(_this.getLocalPosition(), 2), x3 = _a[0], y3 = _a[1];
          var _b = __read(_this.padding, 4), top = _b[0], left2 = _b[3];
          var basePos = _this.getOrientVal([x3 + left2, y3 + top]);
          var clickPos = _this.getOrientVal(getEventPos(e3));
          var value2 = (clickPos - basePos) / _this.trackLength;
          _this.setValue(value2, true);
        };
        _this.onThumbMouseenter = function(e3) {
          _this.dispatchEvent(new CustomEvent2("thumbMouseenter", { detail: e3.detail }));
        };
        _this.onTrackMouseenter = function(e3) {
          _this.dispatchEvent(new CustomEvent2("trackMouseenter", { detail: e3.detail }));
        };
        _this.onThumbMouseleave = function(e3) {
          _this.dispatchEvent(new CustomEvent2("thumbMouseleave", { detail: e3.detail }));
        };
        _this.onTrackMouseleave = function(e3) {
          _this.dispatchEvent(new CustomEvent2("trackMouseleave", { detail: e3.detail }));
        };
        return _this;
      }
      Object.defineProperty(Scrollbar3.prototype, "padding", {
        get: function() {
          var padding = this.attributes.padding;
          return parseSeriesAttr(padding);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scrollbar3.prototype, "value", {
        get: function() {
          var value2 = this.attributes.value;
          var _a = __read(this.range, 2), min10 = _a[0], max10 = _a[1];
          return clamp_default3(value2, min10, max10);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scrollbar3.prototype, "trackLength", {
        get: function() {
          var _a = this.attributes, viewportLength = _a.viewportLength, _b = _a.trackLength, trackLength = _b === void 0 ? viewportLength : _b;
          return trackLength;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scrollbar3.prototype, "availableSpace", {
        get: function() {
          var trackSize = this.attributes.trackSize;
          var trackLength = this.trackLength;
          var _a = __read(this.padding, 4), top = _a[0], right2 = _a[1], bottom = _a[2], left2 = _a[3];
          var _b = __read(this.getOrientVal([
            [trackLength, trackSize],
            [trackSize, trackLength]
          ]), 2), width = _b[0], height = _b[1];
          return {
            x: left2,
            y: top,
            width: +width - (left2 + right2),
            height: +height - (top + bottom)
          };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scrollbar3.prototype, "trackRadius", {
        get: function() {
          var _a = this.attributes, isRound = _a.isRound, trackSize = _a.trackSize;
          if (!isRound)
            return 0;
          return trackSize / 2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Scrollbar3.prototype, "thumbRadius", {
        get: function() {
          var _a = this.attributes, isRound = _a.isRound, thumbRadius = _a.thumbRadius;
          if (!isRound)
            return 0;
          var _b = this.availableSpace, width = _b.width, height = _b.height;
          return thumbRadius || this.getOrientVal([height, width]) / 2;
        },
        enumerable: false,
        configurable: true
      });
      Scrollbar3.prototype.getValues = function(value2) {
        if (value2 === void 0) {
          value2 = this.value;
        }
        var _a = this.attributes, viewportLength = _a.viewportLength, contentLength = _a.contentLength;
        var unit = viewportLength / contentLength;
        var _b = __read(this.range, 2), min10 = _b[0], max10 = _b[1];
        var start2 = value2 * (max10 - min10 - unit);
        return [start2, start2 + unit];
      };
      Scrollbar3.prototype.getValue = function() {
        return this.value;
      };
      Scrollbar3.prototype.renderSlider = function(container) {
        var _a = this.attributes, x3 = _a.x, y3 = _a.y, orientation = _a.orientation, trackSize = _a.trackSize, padding = _a.padding, slidable = _a.slidable;
        var trackStyle = subStyleProps(this.attributes, "track");
        var selectionStyle = subStyleProps(this.attributes, "thumb");
        var style = __assign(__assign({ x: x3, y: y3, brushable: false, orientation, padding, selectionRadius: this.thumbRadius, showHandle: false, slidable, trackLength: this.trackLength, trackRadius: this.trackRadius, trackSize, values: this.getValues() }, superStyleProps(trackStyle, "track")), superStyleProps(selectionStyle, "selection"));
        this.slider = select2(container).maybeAppendByClassName("scrollbar", function() {
          return new Slider({ style });
        }).update(style).node();
      };
      Scrollbar3.prototype.render = function(attributes, container) {
        this.renderSlider(container);
      };
      Scrollbar3.prototype.setValue = function(value2, animate2) {
        if (animate2 === void 0) {
          animate2 = false;
        }
        var oldValue = this.attributes.value;
        var _a = __read(this.range, 2), min10 = _a[0], max10 = _a[1];
        this.slider.setValues(this.getValues(clamp_default3(value2, min10, max10)), animate2);
        this.onValueChange(oldValue);
      };
      Scrollbar3.prototype.bindEvents = function() {
        var _this = this;
        this.slider.addEventListener("trackClick", function(e3) {
          e3.stopPropagation();
          _this.onTrackClick(e3.detail);
        });
        this.onHover();
      };
      Scrollbar3.prototype.getOrientVal = function(values) {
        var orientation = this.attributes.orientation;
        return orientation === "horizontal" ? values[0] : values[1];
      };
      Scrollbar3.prototype.onHover = function() {
        this.slider.addEventListener("selectionMouseenter", this.onThumbMouseenter);
        this.slider.addEventListener("trackMouseenter", this.onTrackMouseenter);
        this.slider.addEventListener("selectionMouseleave", this.onThumbMouseleave);
        this.slider.addEventListener("trackMouseleave", this.onTrackMouseleave);
      };
      Scrollbar3.tag = "scrollbar";
      return Scrollbar3;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/constant.js
  var AXIS_BASE_DEFAULT_ATTR = {
    data: [],
    animate: {
      enter: false,
      update: {
        duration: 100,
        easing: "ease-in-out-sine",
        fill: "both"
      },
      exit: {
        duration: 100,
        fill: "both"
      }
    },
    showArrow: true,
    showGrid: true,
    showLabel: true,
    showLine: true,
    showTick: true,
    showTitle: true,
    showTrunc: false,
    dataThreshold: 100,
    lineLineWidth: 1,
    lineStroke: "black",
    crossPadding: 10,
    titleFill: "black",
    titleFontSize: 12,
    titlePosition: "lb",
    titleSpacing: 0,
    titleTextAlign: "center",
    titleTextBaseline: "middle",
    lineArrow: function() {
      return new Path2({
        style: {
          d: [["M", 10, 10], ["L", -10, 0], ["L", 10, -10], ["L", 0, 0], ["L", 10, 10], ["Z"]],
          fill: "black",
          transformOrigin: "center"
        }
      });
    },
    labelAlign: "parallel",
    labelDirection: "positive",
    labelFontSize: 12,
    labelSpacing: 0,
    gridConnect: "line",
    gridControlAngles: [],
    gridDirection: "positive",
    gridLength: 0,
    gridType: "segment",
    lineArrowOffset: 15,
    lineArrowSize: 10,
    tickDirection: "positive",
    tickLength: 5,
    tickLineWidth: 1,
    tickStroke: "black",
    labelOverlap: [
      // { type: 'rotate', optionalAngles: [0, 45, 90] },
      // { type: 'ellipsis', suffix: '...', minLength: 14, maxLength: 160 },
      // { type: 'hide' },
    ]
  };
  var ARC_DEFAULT_OPTIONS = deep_mix_default2({}, AXIS_BASE_DEFAULT_ATTR, {
    style: {
      type: "arc"
    }
  });
  var HELIX_DEFAULT_OPTIONS = deep_mix_default2({}, AXIS_BASE_DEFAULT_ATTR, {
    style: {}
  });
  var CLASS_NAMES3 = classNames({
    mainGroup: "main-group",
    gridGroup: "grid-group",
    grid: "grid",
    lineGroup: "line-group",
    line: "line",
    tickGroup: "tick-group",
    tick: "tick",
    tickItem: "tick-item",
    labelGroup: "label-group",
    label: "label",
    labelItem: "label-item",
    titleGroup: "title-group",
    title: "title",
    lineFirst: "line-first",
    lineSecond: "line-second"
  }, "axis");

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/grid/index.js
  var CLASS_NAMES4 = classNames({
    lineGroup: "line-group",
    line: "line",
    regionGroup: "region-group",
    region: "region"
  }, "grid");
  function getStraightPath(points) {
    return points.reduce(function(acc, curr, idx) {
      acc.push(__spreadArray([idx === 0 ? "M" : "L"], __read(curr), false));
      return acc;
    }, []);
  }
  function getSurroundPath(points, attr2, reversed) {
    var _a = attr2.connect, connect = _a === void 0 ? "line" : _a, center2 = attr2.center;
    if (connect === "line")
      return getStraightPath(points);
    if (!center2)
      return [];
    var radius = distance5(points[0], center2);
    var sweepFlag = reversed ? 0 : 1;
    return points.reduce(function(r, p2, idx) {
      if (idx === 0)
        r.push(__spreadArray(["M"], __read(p2), false));
      else
        r.push(__spreadArray(["A", radius, radius, 0, 0, sweepFlag], __read(p2), false));
      return r;
    }, []);
  }
  function getLinePath(points, cfg, reversed) {
    if (cfg.type === "surround")
      return getSurroundPath(points, cfg, reversed);
    return getStraightPath(points);
  }
  function connectPaths(from, to, cfg) {
    var type = cfg.type, connect = cfg.connect, center2 = cfg.center, closed = cfg.closed;
    var closeFlag = closed ? [["Z"]] : [];
    var _a = __read([getLinePath(from, cfg), getLinePath(to.slice().reverse(), cfg, true)], 2), path1 = _a[0], path2 = _a[1];
    var _b = __read([from[0], to.slice(-1)[0]], 2), startOfFrom = _b[0], endOfTo = _b[1];
    var createPath = function(insertA, insertB) {
      return [path1, insertA, path2, insertB, closeFlag].flat();
    };
    if (connect === "line" || type === "surround") {
      return createPath([__spreadArray(["L"], __read(endOfTo), false)], [__spreadArray(["L"], __read(startOfFrom), false)]);
    }
    if (!center2)
      throw new Error("Arc grid need to specified center");
    var _c = __read([distance5(endOfTo, center2), distance5(startOfFrom, center2)], 2), raduis1 = _c[0], radius2 = _c[1];
    return createPath([
      __spreadArray(["A", raduis1, raduis1, 0, 0, 1], __read(endOfTo), false),
      __spreadArray(["L"], __read(endOfTo), false)
    ], [
      __spreadArray(["A", radius2, radius2, 0, 0, 0], __read(startOfFrom), false),
      __spreadArray(["L"], __read(startOfFrom), false)
    ]);
  }
  function renderGridLine(container, data2, attr2, style) {
    var animate2 = attr2.animate, isBillboard = attr2.isBillboard;
    var lines = data2.map(function(item, idx) {
      return {
        id: item.id || "grid-line-".concat(idx),
        d: getLinePath(item.points, attr2)
      };
    });
    return container.selectAll(CLASS_NAMES4.line.class).data(lines, function(d2) {
      return d2.id;
    }).join(function(enter) {
      return enter.append("path").each(function(datum, index4) {
        var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index4, lines]);
        this.attr(__assign({ class: CLASS_NAMES4.line.name, stroke: "#D9D9D9", lineWidth: 1, lineDash: [4, 4], isBillboard }, lineStyle));
      });
    }, function(update) {
      return update.transition(function(datum, index4) {
        var lineStyle = getCallbackValue(getPrimitiveAttributes(__assign({ d: datum.d }, style)), [datum, index4, lines]);
        return transition(this, lineStyle, animate2.update);
      });
    }, function(exit) {
      return exit.transition(function() {
        var _this = this;
        var animation = fadeOut_default(this, animate2.exit);
        onAnimateFinished(animation, function() {
          return _this.remove();
        });
        return animation;
      });
    }).transitions();
  }
  function renderAlternateRegion(container, data2, style) {
    var animate2 = style.animate, connect = style.connect, areaFill = style.areaFill;
    if (data2.length < 2 || !areaFill || !connect)
      return [];
    var colors = Array.isArray(areaFill) ? areaFill : [areaFill, "transparent"];
    var getColor3 = function(idx2) {
      return colors[idx2 % colors.length];
    };
    var regions = [];
    for (var idx = 0; idx < data2.length - 1; idx++) {
      var _a = __read([data2[idx].points, data2[idx + 1].points], 2), prev = _a[0], curr = _a[1];
      var path2 = connectPaths(prev, curr, style);
      regions.push({ d: path2, fill: getColor3(idx) });
    }
    return container.selectAll(CLASS_NAMES4.region.class).data(regions, function(_2, i) {
      return i;
    }).join(function(enter) {
      return enter.append("path").each(function(datum, index4) {
        var regionStyle = getCallbackValue(datum, [datum, index4, regions]);
        this.attr(regionStyle);
      }).attr("className", CLASS_NAMES4.region.name);
    }, function(update) {
      return update.transition(function(datum, index4) {
        var regionStyle = getCallbackValue(datum, [datum, index4, regions]);
        return transition(this, regionStyle, animate2.update);
      });
    }, function(exit) {
      return exit.transition(function() {
        var _this = this;
        var animation = fadeOut_default(this, animate2.exit);
        onAnimateFinished(animation, function() {
          return _this.remove();
        });
        return animation;
      });
    }).transitions();
  }
  function getData(attr2) {
    var _a = attr2.data, data2 = _a === void 0 ? [] : _a, closed = attr2.closed;
    if (!closed)
      return data2;
    return data2.map(function(datum) {
      var points = datum.points;
      var _a2 = __read(points, 1), start2 = _a2[0];
      return __assign(__assign({}, datum), { points: __spreadArray(__spreadArray([], __read(points), false), [start2], false) });
    });
  }
  var Grid = (
    /** @class */
    function(_super) {
      __extends(Grid2, _super);
      function Grid2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      Grid2.prototype.render = function(attributes, container) {
        var type = attributes.type, center2 = attributes.center, areaFill = attributes.areaFill, closed = attributes.closed, style = __rest(attributes, ["type", "center", "areaFill", "closed"]);
        var data2 = getData(attributes);
        var lineGroup = select2(container).maybeAppendByClassName(CLASS_NAMES4.lineGroup, "g");
        var regionGroup = select2(container).maybeAppendByClassName(CLASS_NAMES4.regionGroup, "g");
        var lineTransitions = renderGridLine(lineGroup, data2, attributes, style);
        var reigionTransitions = renderAlternateRegion(regionGroup, data2, attributes);
        return __spreadArray(__spreadArray([], __read(lineTransitions), false), __read(reigionTransitions), false);
      };
      return Grid2;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/guides/utils.js
  function getCallbackStyle(style, params) {
    return Object.fromEntries(Object.entries(style).map(function(_a) {
      var _b = __read(_a, 2), key = _b[0], val = _b[1];
      return [key, getCallbackValue(val, params)];
    }));
  }
  function filterExec(data2, filter2) {
    return !!filter2 && is_function_default2(filter2) ? data2.filter(filter2) : data2;
  }
  function getLineAngle(value2, attr2) {
    var startAngle = attr2.startAngle, endAngle = attr2.endAngle;
    return (endAngle - startAngle) * value2 + startAngle;
  }
  function getLineTangentVector(value2, attr2) {
    if (attr2.type === "linear") {
      var _a = __read(attr2.startPos, 2), startX = _a[0], startY = _a[1], _b = __read(attr2.endPos, 2), endX = _b[0], endY = _b[1];
      var _c = __read([endX - startX, endY - startY], 2), dx = _c[0], dy = _c[1];
      return normalize7([dx, dy]);
    }
    var angle4 = degToRad(getLineAngle(value2, attr2));
    return [-Math.sin(angle4), Math.cos(angle4)];
  }
  function getDirectionVector(value2, direction2, attr2) {
    var tangentVector = getLineTangentVector(value2, attr2);
    return vertical(tangentVector, direction2 !== "positive");
  }
  function getLabelVector(value2, attr2) {
    return getDirectionVector(value2, attr2.labelDirection, attr2);
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/guides/line.js
  function getLinearValuePos(value2, attr2) {
    var _a = __read(attr2.startPos, 2), sx = _a[0], sy = _a[1], _b = __read(attr2.endPos, 2), ex = _b[0], ey = _b[1];
    var _c = __read([ex - sx, ey - sy], 2), dx = _c[0], dy = _c[1];
    return [sx + dx * value2, sy + dy * value2];
  }
  function getArcValuePos(value2, attr2) {
    var radius = attr2.radius, _a = __read(attr2.center, 2), cx = _a[0], cy = _a[1];
    var angle4 = degToRad(getLineAngle(value2, attr2));
    return [cx + radius * Math.cos(angle4), cy + radius * Math.sin(angle4)];
  }
  function getValuePos(value2, attr2) {
    if (attr2.type === "linear")
      return getLinearValuePos(value2, attr2);
    return getArcValuePos(value2, attr2);
  }
  function isAxisHorizontal(attr2) {
    return getLineTangentVector(0, attr2)[1] === 0;
  }
  function isAxisVertical(attr2) {
    return getLineTangentVector(0, attr2)[0] === 0;
  }
  function isCircle(startAngle, endAngle) {
    return endAngle - startAngle === 360;
  }
  function getArcPath(startAngle, endAngle, cx, cy, radius) {
    var diffAngle = endAngle - startAngle;
    var _a = __read([radius, radius], 2), rx = _a[0], ry = _a[1];
    var _b = __read([degToRad(startAngle), degToRad(endAngle)], 2), startAngleRadians = _b[0], endAngleRadians = _b[1];
    var getPosByAngle = function(angle4) {
      return [cx + radius * Math.cos(angle4), cy + radius * Math.sin(angle4)];
    };
    var _c = __read(getPosByAngle(startAngleRadians), 2), x12 = _c[0], y12 = _c[1];
    var _d = __read(getPosByAngle(endAngleRadians), 2), x22 = _d[0], y22 = _d[1];
    if (isCircle(startAngle, endAngle)) {
      var middleAngleRadians = (endAngleRadians + startAngleRadians) / 2;
      var _e = __read(getPosByAngle(middleAngleRadians), 2), xm = _e[0], ym = _e[1];
      return [
        ["M", x12, y12],
        ["A", rx, ry, 0, 1, 0, xm, ym],
        ["A", rx, ry, 0, 1, 0, x22, y22]
      ];
    }
    var large = diffAngle > 180 ? 1 : 0;
    var sweep = startAngle > endAngle ? 0 : 1;
    var isClosePath = false;
    return isClosePath ? "M".concat(cx, ",").concat(cy, ",L").concat(x12, ",").concat(y12, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x22, ",").concat(y22, ",L").concat(cx, ",").concat(cy) : "M".concat(x12, ",").concat(y12, ",A").concat(rx, ",").concat(ry, ",0,").concat(large, ",").concat(sweep, ",").concat(x22, ",").concat(y22);
  }
  function getArcAttr(arc) {
    var _a = arc.attributes, startAngle = _a.startAngle, endAngle = _a.endAngle, center2 = _a.center, radius = _a.radius;
    return __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false);
  }
  function renderArc(container, attr2, style, animate2) {
    var startAngle = attr2.startAngle, endAngle = attr2.endAngle, center2 = attr2.center, radius = attr2.radius;
    return container.selectAll(CLASS_NAMES3.line.class).data([{ d: getArcPath.apply(void 0, __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false)) }], function(d2, i) {
      return i;
    }).join(function(enter) {
      return enter.append("path").attr("className", CLASS_NAMES3.line.name).styles(attr2).styles({ d: function(d2) {
        return d2.d;
      } });
    }, function(update) {
      return update.transition(function() {
        var _this = this;
        var animation = keyframeInterpolate(this, getArcAttr(this), __spreadArray(__spreadArray([startAngle, endAngle], __read(center2), false), [radius], false), animate2.update);
        if (animation) {
          var layout = function() {
            var data2 = get_default2(_this.attributes, "__keyframe_data__");
            _this.style.d = getArcPath.apply(void 0, __spreadArray([], __read(data2), false));
          };
          animation.onframe = layout;
          animation.onfinish = layout;
        }
        return animation;
      }).styles(attr2);
    }, function(exit) {
      return exit.remove();
    }).styles(style).transitions();
  }
  function renderTruncation(container, _a) {
    var truncRange = _a.truncRange, truncShape = _a.truncShape, lineExtension = _a.lineExtension;
  }
  function extendLine(startPos, endPos, range3) {
    if (range3 === void 0) {
      range3 = [0, 0];
    }
    var _a = __read([startPos, endPos, range3], 3), _b = __read(_a[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a[1], 2), x22 = _c[0], y22 = _c[1], _d = __read(_a[2], 2), l1 = _d[0], l2 = _d[1];
    var _e = __read([x22 - x12, y22 - y12], 2), x3 = _e[0], y3 = _e[1];
    var L = Math.sqrt(Math.pow(x3, 2) + Math.pow(y3, 2));
    var _f = __read([-l1 / L, l2 / L], 2), s1 = _f[0], s2 = _f[1];
    return [s1 * x3, s1 * y3, s2 * x3, s2 * y3];
  }
  function getLinePath2(points) {
    var _a = __read(points, 2), _b = __read(_a[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a[1], 2), x22 = _c[0], y22 = _c[1];
    return { x1: x12, y1: y12, x2: x22, y2: y22 };
  }
  function renderLinear(container, attr2, style, animate2) {
    var showTrunc = attr2.showTrunc, startPos = attr2.startPos, endPos = attr2.endPos, truncRange = attr2.truncRange, lineExtension = attr2.lineExtension;
    var _a = __read([startPos, endPos], 2), _b = __read(_a[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a[1], 2), x22 = _c[0], y22 = _c[1];
    var _d = __read(lineExtension ? extendLine(startPos, endPos, lineExtension) : new Array(4).fill(0), 4), ox1 = _d[0], oy1 = _d[1], ox2 = _d[2], oy2 = _d[3];
    var renderLine = function(data2) {
      return container.selectAll(CLASS_NAMES3.line.class).data(data2, function(d2, i) {
        return i;
      }).join(function(enter) {
        return enter.append("line").attr("className", function(d2) {
          return "".concat(CLASS_NAMES3.line.name, " ").concat(d2.className);
        }).styles(style).transition(function(d2) {
          return transition(this, getLinePath2(d2.line), false);
        });
      }, function(update) {
        return update.styles(style).transition(function(_a2) {
          var line4 = _a2.line;
          return transition(this, getLinePath2(line4), animate2.update);
        });
      }, function(exit) {
        return exit.remove();
      }).transitions();
    };
    if (!showTrunc || !truncRange) {
      return renderLine([
        {
          line: [
            [x12 + ox1, y12 + oy1],
            [x22 + ox2, y22 + oy2]
          ],
          className: CLASS_NAMES3.line.name
        }
      ]);
    }
    var _e = __read(truncRange, 2), r1 = _e[0], r2 = _e[1];
    var dx = x22 - x12;
    var dy = y22 - y12;
    var _f = __read([x12 + dx * r1, y12 + dy * r1], 2), x3 = _f[0], y3 = _f[1];
    var _g = __read([x12 + dx * r2, y12 + dy * r2], 2), x4 = _g[0], y4 = _g[1];
    var animation = renderLine([
      {
        line: [
          [x12 + ox1, y12 + oy1],
          [x3, y3]
        ],
        className: CLASS_NAMES3.lineFirst.name
      },
      {
        line: [
          [x4, y4],
          [x22 + ox2, y22 + oy2]
        ],
        className: CLASS_NAMES3.lineSecond.name
      }
    ]);
    renderTruncation(container, attr2);
    return animation;
  }
  function renderAxisArrow(container, type, attr2, style) {
    var showArrow = attr2.showArrow, showTrunc = attr2.showTrunc, lineArrow = attr2.lineArrow, lineArrowOffset = attr2.lineArrowOffset, lineArrowSize = attr2.lineArrowSize;
    var shapeToAddArrow;
    if (type === "arc")
      shapeToAddArrow = container.select(CLASS_NAMES3.line.class);
    else if (showTrunc)
      shapeToAddArrow = container.select(CLASS_NAMES3.lineSecond.class);
    else
      shapeToAddArrow = container.select(CLASS_NAMES3.line.class);
    if (!showArrow || !lineArrow || attr2.type === "arc" && isCircle(attr2.startAngle, attr2.endAngle)) {
      var node = shapeToAddArrow.node();
      if (node)
        node.style.markerEnd = void 0;
      return;
    }
    var arrow = renderExtDo(lineArrow);
    arrow.attr(style);
    scaleToPixel(arrow, lineArrowSize, true);
    shapeToAddArrow.style("markerEnd", arrow).style("markerEndOffset", -lineArrowOffset);
  }
  function renderAxisLine(container, attr2, animate2) {
    var type = attr2.type;
    var animation;
    var style = subStyleProps(attr2, "line");
    if (type === "linear")
      animation = renderLinear(container, attr2, omit(style, "arrow"), animate2);
    else
      animation = renderArc(container, attr2, omit(style, "arrow"), animate2);
    renderAxisArrow(container, type, attr2, style);
    return animation;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/guides/grid.js
  function getGridVector(value2, attr2) {
    return getDirectionVector(value2, attr2.gridDirection, attr2);
  }
  function getGridCenter(attr2) {
    var type = attr2.type, gridCenter = attr2.gridCenter;
    if (type === "linear")
      return gridCenter;
    return gridCenter || attr2.center;
  }
  function renderStraight(data2, attr2) {
    var gridLength = attr2.gridLength;
    return data2.map(function(_a, index4) {
      var value2 = _a.value;
      var _b = __read(getValuePos(value2, attr2), 2), x3 = _b[0], y3 = _b[1];
      var _c = __read(scale7(getGridVector(value2, attr2), gridLength), 2), dx = _c[0], dy = _c[1];
      return {
        id: index4,
        points: [
          [x3, y3],
          [x3 + dx, y3 + dy]
        ]
      };
    });
  }
  function renderSurround(data2, attr2) {
    var controlAngles = attr2.gridControlAngles;
    var center2 = getGridCenter(attr2);
    if (!center2)
      throw new Error("grid center is not provide");
    if (data2.length < 2)
      throw new Error("Invalid grid data");
    if (!controlAngles || controlAngles.length === 0)
      throw new Error("Invalid gridControlAngles");
    var _a = __read(center2, 2), cx = _a[0], cy = _a[1];
    return data2.map(function(_a2, index4) {
      var value2 = _a2.value;
      var _b = __read(getValuePos(value2, attr2), 2), sx = _b[0], sy = _b[1];
      var _c = __read([sx - cx, sy - cy], 2), dx = _c[0], dy = _c[1];
      var points = [];
      controlAngles.forEach(function(angle4) {
        var angleInRad = degToRad(angle4);
        var _a3 = __read([Math.cos(angleInRad), Math.sin(angleInRad)], 2), cosa = _a3[0], sina = _a3[1];
        var x3 = dx * cosa - dy * sina + cx;
        var y3 = dx * sina + dy * cosa + cy;
        points.push([x3, y3]);
      });
      return { points, id: index4 };
    });
  }
  function renderGrid(container, data2, attr2, animate2) {
    var gridAttr = subStyleProps(attr2, "grid");
    var type = gridAttr.type, areaFill = gridAttr.areaFill;
    var center2 = getGridCenter(attr2);
    var finalData = filterExec(data2, attr2.gridFilter);
    var gridItems = type === "segment" ? renderStraight(finalData, attr2) : renderSurround(finalData, attr2);
    var style = __assign(__assign({}, gridAttr), { center: center2, areaFill: is_function_default2(areaFill) ? finalData.map(function(datum, index4) {
      return getCallbackValue(areaFill, [datum, index4, finalData]);
    }) : areaFill, animate: animate2, data: gridItems });
    return container.selectAll(CLASS_NAMES3.grid.class).data([1]).join(function(enter) {
      return enter.append(function() {
        return new Grid({ style });
      }).attr("className", CLASS_NAMES3.grid.name);
    }, function(update) {
      return update.transition(function() {
        return this.update(style);
      });
    }, function(exit) {
      return exit.remove();
    }).transitions();
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/utils/bounds.js
  var Bounds = (
    /** @class */
    function() {
      function Bounds2(x12, y12, x22, y22) {
        this.set(x12, y12, x22, y22);
      }
      Object.defineProperty(Bounds2.prototype, "left", {
        get: function() {
          return this.x1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "top", {
        get: function() {
          return this.y1;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "right", {
        get: function() {
          return this.x2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "bottom", {
        get: function() {
          return this.y2;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "width", {
        get: function() {
          return this.defined("x2") && this.defined("x1") ? this.x2 - this.x1 : void 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Bounds2.prototype, "height", {
        get: function() {
          return this.defined("y2") && this.defined("y1") ? this.y2 - this.y1 : void 0;
        },
        enumerable: false,
        configurable: true
      });
      Bounds2.prototype.rotatedPoints = function(radian, x3, y3) {
        var _a = this, x12 = _a.x1, y12 = _a.y1, x22 = _a.x2, y22 = _a.y2;
        var cos3 = Math.cos(radian);
        var sin3 = Math.sin(radian);
        var cx = x3 - x3 * cos3 + y3 * sin3;
        var cy = y3 - x3 * sin3 - y3 * cos3;
        var points = [
          [cos3 * x12 - sin3 * y22 + cx, sin3 * x12 + cos3 * y22 + cy],
          [cos3 * x22 - sin3 * y22 + cx, sin3 * x22 + cos3 * y22 + cy],
          [cos3 * x12 - sin3 * y12 + cx, sin3 * x12 + cos3 * y12 + cy],
          [cos3 * x22 - sin3 * y12 + cx, sin3 * x22 + cos3 * y12 + cy]
        ];
        return points;
      };
      Bounds2.prototype.set = function(x12, y12, x22, y22) {
        if (x22 < x12) {
          this.x2 = x12;
          this.x1 = x22;
        } else {
          this.x1 = x12;
          this.x2 = x22;
        }
        if (y22 < y12) {
          this.y2 = y12;
          this.y1 = y22;
        } else {
          this.y1 = y12;
          this.y2 = y22;
        }
        return this;
      };
      Bounds2.prototype.defined = function(key) {
        return this[key] !== Number.MAX_VALUE && this[key] !== -Number.MAX_VALUE;
      };
      return Bounds2;
    }()
  );
  function getBounds(item, margin) {
    var angle4 = item.getEulerAngles() || 0;
    item.setEulerAngles(0);
    var _a = item.getBounds(), _b = __read(_a.min, 2), x3 = _b[0], y3 = _b[1], _c = __read(_a.max, 2), right2 = _c[0], bottom = _c[1];
    var _d = item.getBBox(), w = _d.width, h = _d.height;
    var height = h;
    var dx = 0;
    var dy = 0;
    var anchorX = x3;
    var anchorY = y3;
    var text = textOf(item);
    if (text) {
      height -= 1.5;
      var a3 = text.style.textAlign;
      var b_1 = text.style.textBaseline;
      if (a3 === "center") {
        anchorX = (x3 + right2) / 2;
      } else if (a3 === "right" || a3 === "end") {
        anchorX = right2;
      } else {
      }
      if (b_1 === "middle") {
        anchorY = (y3 + bottom) / 2;
      } else if (b_1 === "bottom") {
        anchorY = bottom;
      }
    }
    var _e = __read(parseSeriesAttr(margin), 4), _f = _e[0], t = _f === void 0 ? 0 : _f, _g = _e[1], r = _g === void 0 ? 0 : _g, _h = _e[2], b = _h === void 0 ? t : _h, _j = _e[3], l2 = _j === void 0 ? r : _j;
    var bounds = new Bounds((dx += x3) - l2, (dy += y3) - t, dx + w + r, dy + height + b);
    item.setEulerAngles(angle4);
    return bounds.rotatedPoints(degToRad(angle4), anchorX, anchorY);
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/utils/contain.js
  function onLine(line4, point6) {
    return point6[0] <= Math.max(line4[0][0], line4[1][0]) && point6[0] <= Math.min(line4[0][0], line4[1][0]) && point6[1] <= Math.max(line4[0][1], line4[1][1]) && point6[1] <= Math.min(line4[0][1], line4[1][1]);
  }
  function direction(a3, b, c5) {
    var val = (b[1] - a3[1]) * (c5[0] - b[0]) - (b[0] - a3[0]) * (c5[1] - b[1]);
    if (val === 0)
      return 0;
    return val < 0 ? 2 : 1;
  }
  function isIntersect(line1, line22) {
    var dir1 = direction(line1[0], line1[1], line22[0]);
    var dir2 = direction(line1[0], line1[1], line22[1]);
    var dir3 = direction(line22[0], line22[1], line1[0]);
    var dir4 = direction(line22[0], line22[1], line1[1]);
    if (dir1 !== dir2 && dir3 !== dir4)
      return true;
    if (dir1 === 0 && onLine(line1, line22[0]))
      return true;
    if (dir2 === 0 && onLine(line1, line22[1]))
      return true;
    if (dir3 === 0 && onLine(line22, line1[0]))
      return true;
    if (dir4 === 0 && onLine(line22, line1[1]))
      return true;
    return false;
  }
  function isPointInsideRectangle(polygon, point6) {
    var n2 = polygon.length;
    if (n2 < 3)
      return false;
    var lineToInfinity = [point6, [9999, point6[1]]];
    var count4 = 0;
    var i = 0;
    do {
      var side = [polygon[i], polygon[(i + 1) % n2]];
      if (isIntersect(side, lineToInfinity)) {
        if (direction(side[0], point6, side[1]) === 0)
          return onLine(side, point6);
        count4++;
      }
      i = (i + 1) % n2;
    } while (i !== 0);
    return !!(count4 & 1);
  }
  function isRectangleBInsideA(rectA, rectB) {
    return rectB.every(function(point6) {
      return isPointInsideRectangle(rectA, point6);
    });
  }
  function contain(container, child, margin) {
    var x12 = container.x1, x22 = container.x2, y12 = container.y1, y22 = container.y2;
    var parent = [
      [x12, y12],
      [x22, y12],
      [x22, y22],
      [x12, y22]
    ];
    var element = getBounds(child, margin);
    return isRectangleBInsideA(parent, element);
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/utils/intersect.js
  function lineToLine(line1, line22) {
    var _a = __read(line1, 4), x05 = _a[0], y05 = _a[1], x12 = _a[2], y12 = _a[3];
    var _b = __read(line22, 4), x22 = _b[0], y22 = _b[1], x3 = _b[2], y3 = _b[3];
    var s10x = x12 - x05;
    var s10y = y12 - y05;
    var s32x = x3 - x22;
    var s32y = y3 - y22;
    var denom = s10x * s32y - s32x * s10y;
    if (denom === 0)
      return false;
    var denomPositive = denom > 0;
    var s02x = x05 - x22;
    var s02y = y05 - y22;
    var sNum = s10x * s02y - s10y * s02x;
    if (sNum < 0 === denomPositive)
      return false;
    var tNum = s32x * s02y - s32y * s02x;
    if (tNum < 0 === denomPositive)
      return false;
    if (sNum > denom === denomPositive || tNum > denom === denomPositive)
      return false;
    return true;
  }
  function intersectBoxLine(box2, line4) {
    var lines = [
      [box2[0], box2[1], box2[2], box2[3]],
      [box2[2], box2[3], box2[4], box2[5]],
      [box2[4], box2[5], box2[6], box2[7]],
      [box2[6], box2[7], box2[0], box2[1]]
    ];
    return lines.some(function(boxLine) {
      return lineToLine(line4, boxLine);
    });
  }
  function intersect2(a3, b, margin) {
    var e_1, _a;
    var p2 = getBounds(a3, margin).flat(1);
    var q = getBounds(b, margin).flat(1);
    var linesP = [
      [p2[0], p2[1], p2[2], p2[3]],
      [p2[0], p2[1], p2[4], p2[5]],
      [p2[4], p2[5], p2[6], p2[7]],
      [p2[2], p2[3], p2[6], p2[7]]
    ];
    try {
      for (var linesP_1 = __values(linesP), linesP_1_1 = linesP_1.next(); !linesP_1_1.done; linesP_1_1 = linesP_1.next()) {
        var line4 = linesP_1_1.value;
        if (intersectBoxLine(q, line4))
          return true;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (linesP_1_1 && !linesP_1_1.done && (_a = linesP_1.return)) _a.call(linesP_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    return false;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/utils/test.js
  function createCrossBBox(attr2, padding) {
    var type = attr2.type, labelDirection = attr2.labelDirection, crossSize = attr2.crossSize;
    if (!crossSize)
      return false;
    if (type === "arc") {
      var center2 = attr2.center, radius = attr2.radius;
      var _a = __read(center2, 2), cx = _a[0], cy = _a[1];
      var size2 = labelDirection === "negative" ? 0 : crossSize;
      var dMin = -radius - size2;
      var dMax = radius + size2;
      var _b = __read(parseSeriesAttr(padding), 4), top_1 = _b[0], right_1 = _b[1], bottom_1 = _b[2], left_1 = _b[3];
      return new Bounds(cx + dMin - left_1, cy + dMin - top_1, cx + dMax + right_1, cy + dMax + bottom_1);
    }
    var _c = __read(attr2.startPos, 2), sx = _c[0], sy = _c[1], _d = __read(attr2.endPos, 2), ex = _d[0], ey = _d[1];
    var _e = __read(isAxisVertical(attr2) ? [-padding, 0, padding, 0] : [0, padding, 0, -padding], 4), top = _e[0], right2 = _e[1], bottom = _e[2], left2 = _e[3];
    var labelVector = getLabelVector(0, attr2);
    var diff = scale7(labelVector, crossSize);
    var bbox = new Bounds(sx, sy, ex, ey);
    bbox.x1 += left2;
    bbox.y1 += top;
    bbox.x2 += right2 + diff[0];
    bbox.y2 += bottom + diff[1];
    return bbox;
  }
  function boundTest(items, attr2, margin) {
    var e_1, _a;
    var crossPadding = attr2.crossPadding;
    var resultSet = /* @__PURE__ */ new Set();
    var prev = null;
    var crossBBox = createCrossBBox(attr2, crossPadding);
    var testContain = function(item) {
      if (crossBBox)
        return contain(crossBBox, item);
      return true;
    };
    var testIntersect = function(prevItem, currItem) {
      if (!prevItem || !prevItem.firstChild)
        return true;
      return !intersect2(prevItem.firstChild, currItem.firstChild, parseSeriesAttr(margin));
    };
    try {
      for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
        var curr = items_1_1.value;
        if (!testContain(curr)) {
          resultSet.add(curr);
        } else if (!prev || testIntersect(prev, curr)) {
          prev = curr;
        } else {
          resultSet.add(prev);
          resultSet.add(curr);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    return Array.from(resultSet);
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/overlap/autoEllipsis.js
  function parseLengthString(str7, font) {
    if (font === void 0) {
      font = {};
    }
    if (is_nil_default4(str7))
      return 0;
    if (typeof str7 === "number")
      return str7;
    return Math.floor(measureTextWidth(str7, font));
  }
  function ellipseLabels(labels, overlapCfg, attr2, utils) {
    if (labels.length <= 1)
      return;
    var _a = overlapCfg.suffix, suffix = _a === void 0 ? "..." : _a, minLength = overlapCfg.minLength, _b = overlapCfg.maxLength, maxLength = _b === void 0 ? Infinity : _b, _c = overlapCfg.step, ellipsisStep = _c === void 0 ? " " : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
    var font = getFont(utils.getTextShape(labels[0]));
    var step2 = parseLengthString(ellipsisStep, font);
    var min10 = minLength ? parseLengthString(minLength, font) : step2;
    var max10 = parseLengthString(maxLength, font);
    if (is_nil_default4(max10) || max10 === Infinity) {
      max10 = Math.max.apply(null, labels.map(function(d2) {
        return d2.getBBox().width;
      }));
    }
    var source = labels.slice();
    var _e = __read(margin, 4), _f = _e[0], top = _f === void 0 ? 0 : _f, _g = _e[1], right2 = _g === void 0 ? 0 : _g, _h = _e[2], bottom = _h === void 0 ? top : _h, _j = _e[3], left2 = _j === void 0 ? right2 : _j;
    var _loop_1 = function(allowedLength2) {
      source.forEach(function(label) {
        utils.ellipsis(utils.getTextShape(label), allowedLength2, suffix);
      });
      source = boundTest(labels, attr2, margin);
      if (source.length < 1)
        return { value: void 0 };
    };
    for (var allowedLength = max10; allowedLength > min10 + step2; allowedLength -= step2) {
      var state_1 = _loop_1(allowedLength);
      if (typeof state_1 === "object")
        return state_1.value;
    }
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/overlap/autoHide.js
  var methods = {
    parity: function(items, _a) {
      var _b = _a.seq, seq = _b === void 0 ? 2 : _b;
      return items.filter(function(item, i) {
        return i % seq ? (hide(item), false) : true;
      });
    }
  };
  var filterDefined = function(arr) {
    return arr.filter(defined2);
  };
  function hideLabels(labels, overlapCfg, attr2, utils) {
    var count4 = labels.length;
    var keepHeader = overlapCfg.keepHeader, keepTail = overlapCfg.keepTail;
    if (count4 <= 1 || count4 === 2 && keepHeader && keepTail)
      return;
    var parityHide = methods.parity;
    var reset = function(els) {
      return els.forEach(utils.show), els;
    };
    var seq = 2;
    var source = labels.slice();
    var target = labels.slice();
    var minLabelWidth = Math.min.apply(Math, __spreadArray([1], __read(labels.map(function(d2) {
      return d2.getBBox().width;
    })), false));
    if (attr2.type === "linear" && (isAxisHorizontal(attr2) || isAxisVertical(attr2))) {
      var minX = getLocalBBox(labels[0]).left;
      var maxX = getLocalBBox(labels[count4 - 1]).right;
      var distance8 = Math.abs(maxX - minX) || 1;
      seq = Math.max(Math.floor(count4 * minLabelWidth / distance8), seq);
    }
    var first3;
    var last4;
    if (keepHeader)
      first3 = source.splice(0, 1)[0];
    if (keepTail) {
      last4 = source.splice(-1, 1)[0];
      source.reverse();
    }
    reset(source);
    while (seq < labels.length && boundTest(filterDefined(last4 ? __spreadArray(__spreadArray([last4], __read(target), false), [first3], false) : __spreadArray([first3], __read(target), false)), attr2, overlapCfg === null || overlapCfg === void 0 ? void 0 : overlapCfg.margin).length) {
      if (last4 && !first3 && seq % 2 === 0) {
        var rest = source.splice(0, 1);
        rest.forEach(utils.hide);
      } else if (last4 && first3) {
        var rest = source.splice(0, 1);
        rest.forEach(utils.hide);
      }
      target = parityHide(reset(source), { seq });
      seq++;
    }
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/overlap/autoRotate.js
  function rotateLabels(labels, overlapCfg, attr2, utils) {
    var e_1, _a;
    var _b = overlapCfg.optionalAngles, optionalAngles = _b === void 0 ? [0, 45, 90] : _b, margin = overlapCfg.margin, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c;
    var defaultAngles = labels.map(function(label) {
      return label.getLocalEulerAngles();
    });
    var runAndPassed = function() {
      return boundTest(labels, attr2, margin).length < 1;
    };
    var setLabelsRotate = function(angle5) {
      return labels.forEach(function(label, index4) {
        var rotate4 = Array.isArray(angle5) ? angle5[index4] : angle5;
        utils.rotate(label, +rotate4);
      });
    };
    try {
      for (var optionalAngles_1 = __values(optionalAngles), optionalAngles_1_1 = optionalAngles_1.next(); !optionalAngles_1_1.done; optionalAngles_1_1 = optionalAngles_1.next()) {
        var angle4 = optionalAngles_1_1.value;
        setLabelsRotate(angle4);
        if (runAndPassed())
          return;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (optionalAngles_1_1 && !optionalAngles_1_1.done && (_a = optionalAngles_1.return)) _a.call(optionalAngles_1);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    if (recoverWhenFailed) {
      setLabelsRotate(defaultAngles);
    }
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/overlap/autoWrap.js
  function inferTextBaseline(attr2) {
    var type = attr2.type, labelDirection = attr2.labelDirection;
    if (type === "linear" && isAxisHorizontal(attr2)) {
      return labelDirection === "negative" ? "bottom" : "top";
    }
    return "middle";
  }
  function wrapLabels(labels, overlapCfg, attr2, utils) {
    var _a = overlapCfg.wordWrapWidth, wordWrapWidth = _a === void 0 ? 50 : _a, _b = overlapCfg.maxLines, maxLines = _b === void 0 ? 3 : _b, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
    var defaultLines = labels.map(function(label) {
      return label.attr("maxLines") || 1;
    });
    var minLines = Math.min.apply(Math, __spreadArray([], __read(defaultLines), false));
    var runAndPassed = function() {
      return boundTest(labels, attr2, margin).length < 1;
    };
    var textBaseline = inferTextBaseline(attr2);
    var setLabelsWrap = function(lines2) {
      return labels.forEach(function(label, index4) {
        var maxLines2 = Array.isArray(lines2) ? lines2[index4] : lines2;
        utils.wrap(label, wordWrapWidth, maxLines2, textBaseline);
      });
    };
    if (minLines > maxLines)
      return;
    for (var lines = minLines; lines <= maxLines; lines++) {
      setLabelsWrap(lines);
      if (runAndPassed())
        return;
    }
    if (recoverWhenFailed) {
      setLabelsWrap(defaultLines);
    }
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/overlap/index.js
  var OverlapUtils = /* @__PURE__ */ new Map([
    ["hide", hideLabels],
    ["rotate", rotateLabels],
    ["ellipsis", ellipseLabels],
    ["wrap", wrapLabels]
  ]);
  function canProcessOverlap(labels, attr2, type) {
    if (attr2.labelOverlap.length < 1)
      return false;
    if (type === "hide")
      return !isInOffscreenGroup(labels[0]);
    if (type === "rotate")
      return !labels.some(function(label) {
        var _a;
        return !!((_a = label.attr("transform")) === null || _a === void 0 ? void 0 : _a.includes("rotate"));
      });
    if (type === "ellipsis" || type === "wrap")
      return labels.filter(function(item) {
        return item.querySelector("text");
      }).length > 1;
    return true;
  }
  function processOverlap(labels, attr2, utils) {
    var _a = attr2.labelOverlap, labelOverlap = _a === void 0 ? [] : _a;
    if (!labelOverlap.length)
      return;
    labelOverlap.forEach(function(overlapCfg) {
      var type = overlapCfg.type;
      var util = OverlapUtils.get(type);
      if (canProcessOverlap(labels, attr2, type))
        util === null || util === void 0 ? void 0 : util(labels, overlapCfg, attr2, utils);
    });
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/utils/index.js
  function getFactor() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var fn = function(str7) {
      return str7 === "positive" ? -1 : 1;
    };
    return args.reduce(function(acc, cur) {
      return acc * fn(cur);
    }, 1);
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/guides/labels.js
  function angleNormalizer(angle4) {
    var normalizedAngle = angle4;
    while (normalizedAngle < 0)
      normalizedAngle += 360;
    return Math.round(normalizedAngle % 360);
  }
  function getAngle3(v1, v2) {
    var _a = __read(v1, 2), x12 = _a[0], y12 = _a[1];
    var _b = __read(v2, 2), x22 = _b[0], y22 = _b[1];
    var _c = __read([x12 * x22 + y12 * y22, x12 * y22 - y12 * x22], 2), dot8 = _c[0], det = _c[1];
    return Math.atan2(det, dot8);
  }
  function correctLabelRotation(_rotate) {
    var rotate4 = (_rotate + 360) % 180;
    if (!inRange(rotate4, -90, 90))
      rotate4 += 180;
    return rotate4;
  }
  function getLabelRotation(datum, label, attr2) {
    var _a;
    var labelAlign = attr2.labelAlign;
    var customRotate = (_a = label.style.transform) === null || _a === void 0 ? void 0 : _a.includes("rotate");
    if (customRotate)
      return label.getLocalEulerAngles();
    var rotate4 = 0;
    var labelVector = getLabelVector(datum.value, attr2);
    var tangentVector = getLineTangentVector(datum.value, attr2);
    if (labelAlign === "horizontal")
      return 0;
    if (labelAlign === "perpendicular")
      rotate4 = getAngle3([1, 0], labelVector);
    else
      rotate4 = getAngle3([tangentVector[0] < 0 ? -1 : 1, 0], tangentVector);
    return correctLabelRotation(radToDeg(rotate4));
  }
  function getLabelStyle(value2, rotate4, attr2) {
    var type = attr2.type, labelAlign = attr2.labelAlign;
    var labelVector = getLabelVector(value2, attr2);
    var labelAngle = angleNormalizer(rotate4);
    var tickAngle = angleNormalizer(radToDeg(getAngle3([1, 0], labelVector)));
    var textAlign = "center";
    var textBaseline = "middle";
    if (type === "linear") {
      if ([90, 270].includes(tickAngle) && labelAngle === 0) {
        textAlign = "center";
        textBaseline = labelVector[1] === 1 ? "top" : "bottom";
      } else if (!(tickAngle % 180) && [90, 270].includes(labelAngle)) {
        textAlign = "center";
      } else if (tickAngle === 0) {
        if (inRange(labelAngle, 0, 90, false, true)) {
          textAlign = "start";
        } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
          textAlign = "start";
        }
      } else if (tickAngle === 90) {
        if (inRange(labelAngle, 0, 90, false, true)) {
          textAlign = "start";
        } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
          textAlign = "end";
        }
      } else if (tickAngle === 270) {
        if (inRange(labelAngle, 0, 90, false, true)) {
          textAlign = "end";
        } else if (inRange(labelAngle, 90, 180) || inRange(labelAngle, 270, 360)) {
          textAlign = "start";
        }
      } else if (tickAngle === 180) {
        if (labelAngle === 90) {
          textAlign = "start";
        } else if (inRange(labelAngle, 0, 90) || inRange(labelAngle, 270, 360)) {
          textAlign = "end";
        }
      }
    } else {
      if (labelAlign === "parallel") {
        if (inRange(tickAngle, 0, 180, true)) {
          textBaseline = "top";
        } else {
          textBaseline = "bottom";
        }
      } else if (labelAlign === "horizontal") {
        if (inRange(tickAngle, 90, 270, false)) {
          textAlign = "end";
        } else if (inRange(tickAngle, 270, 360, false) || inRange(tickAngle, 0, 90)) {
          textAlign = "start";
        }
      } else if (labelAlign === "perpendicular") {
        if (inRange(tickAngle, 90, 270)) {
          textAlign = "end";
        } else {
          textAlign = "start";
        }
      }
    }
    return { textAlign, textBaseline };
  }
  function setRotateAndAdjustLabelAlign(rotate4, group3, attr2) {
    group3.setLocalEulerAngles(rotate4);
    var value2 = group3.__data__.value;
    var textStyle = getLabelStyle(value2, rotate4, attr2);
    var label = group3.querySelector(CLASS_NAMES3.labelItem.class);
    if (label)
      applyTextStyle(label, textStyle);
  }
  function getLabelPos(datum, data2, attr2) {
    var showTick = attr2.showTick, tickLength = attr2.tickLength, tickDirection = attr2.tickDirection, labelDirection = attr2.labelDirection, labelSpacing = attr2.labelSpacing;
    var index4 = data2.indexOf(datum);
    var finalLabelSpacing = getCallbackValue(labelSpacing, [datum, index4, data2]);
    var _a = __read([getLabelVector(datum.value, attr2), getFactor(labelDirection, tickDirection)], 2), labelVector = _a[0], unionFactor = _a[1];
    var extraLength = unionFactor === 1 ? getCallbackValue(showTick ? tickLength : 0, [datum, index4, data2]) : 0;
    var _b = __read(add9(scale7(labelVector, finalLabelSpacing + extraLength), getValuePos(datum.value, attr2)), 2), x3 = _b[0], y3 = _b[1];
    return { x: x3, y: y3 };
  }
  function formatter(datum, index4, data2, attr2) {
    var labelFormatter = attr2.labelFormatter;
    var element = is_function_default2(labelFormatter) ? function() {
      return renderExtDo(getCallbackValue(labelFormatter, [datum, index4, data2, getLabelVector(datum.value, attr2)]));
    } : function() {
      return renderExtDo(datum.label || "");
    };
    return element;
  }
  function applyTextStyle(node, style) {
    if (node.nodeName === "text")
      node.attr(style);
  }
  function overlapHandler(attr2) {
    processOverlap(this.node().childNodes, attr2, {
      hide,
      show,
      rotate: function(label, angle4) {
        setRotateAndAdjustLabelAlign(+angle4, label, attr2);
      },
      ellipsis: function(label, len5, suffix) {
        label && ellipsisIt(label, len5 || Infinity, suffix);
      },
      wrap: function(label, width, lines) {
        label && wrapIt(label, width, lines);
      },
      getTextShape: function(label) {
        return label.querySelector("text");
      }
    });
  }
  function renderLabel(container, datum, data2, style, attr2) {
    var index4 = data2.indexOf(datum);
    var label = select2(container).append(formatter(datum, index4, data2, attr2)).attr("className", CLASS_NAMES3.labelItem.name).node();
    var _a = __read(splitStyle(getCallbackStyle(style, [datum, index4, data2])), 2), labelStyle = _a[0], _b = _a[1], transform = _b.transform, groupStyle = __rest(_b, ["transform"]);
    percentTransform(label, transform);
    var rotate4 = getLabelRotation(datum, label, attr2);
    if (!label.getLocalEulerAngles()) {
      label.setLocalEulerAngles(rotate4);
    }
    applyTextStyle(label, __assign(__assign({}, getLabelStyle(datum.value, rotate4, attr2)), labelStyle));
    container.attr(groupStyle);
    return label;
  }
  function renderLabels(container, data2, attr2, animate2) {
    var finalData = filterExec(data2, attr2.labelFilter);
    var style = subStyleProps(attr2, "label");
    return container.selectAll(CLASS_NAMES3.label.class).data(finalData, function(d2, i) {
      return i;
    }).join(function(enter) {
      return enter.append("g").attr("className", CLASS_NAMES3.label.name).transition(function(datum) {
        renderLabel(this, datum, data2, style, attr2);
        var _a = getLabelPos(datum, data2, attr2), x3 = _a.x, y3 = _a.y;
        this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        return null;
      }).call(function() {
        overlapHandler.call(container, attr2);
      });
    }, function(update) {
      return update.transition(function(datum) {
        var prevLabel = this.querySelector(CLASS_NAMES3.labelItem.class);
        var label = renderLabel(this, datum, data2, style, attr2);
        var shapeAnimation = transitionShape(prevLabel, label, animate2.update);
        var _a = getLabelPos(datum, data2, attr2), x3 = _a.x, y3 = _a.y;
        var animation = transition(this, { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2.update);
        return __spreadArray(__spreadArray([], __read(shapeAnimation), false), [animation], false);
      }).call(function(selection) {
        var transitions = get_default2(selection, "_transitions").flat().filter(defined2);
        onAnimatesFinished(transitions, function() {
          overlapHandler.call(container, attr2);
        });
      });
    }, function(exit) {
      return exit.transition(function() {
        var _this = this;
        var animation = fadeOut_default(this.childNodes[0], animate2.exit);
        onAnimateFinished(animation, function() {
          return select2(_this).remove();
        });
        return animation;
      });
    }).transitions();
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/guides/ticks.js
  function getTickVector(value2, attr2) {
    return getDirectionVector(value2, attr2.tickDirection, attr2);
  }
  function getTickPoints(unitVector, tickLength) {
    var _a = __read(unitVector, 2), dx = _a[0], dy = _a[1];
    return [
      [0, 0],
      [dx * tickLength, dy * tickLength]
    ];
  }
  function getTickLineLayout(datum, index4, data2, tickVector, attr2) {
    var tickLength = attr2.tickLength;
    var _a = __read(getTickPoints(tickVector, getCallbackValue(tickLength, [datum, index4, data2])), 2), _b = __read(_a[0], 2), x12 = _b[0], y12 = _b[1], _c = __read(_a[1], 2), x22 = _c[0], y22 = _c[1];
    return { x1: x12, x2: x22, y1: y12, y2: y22 };
  }
  function createTickEl(container, datum, index4, data2, attr2) {
    var formatter2 = attr2.tickFormatter;
    var tickVector = getTickVector(datum.value, attr2);
    var el = "line";
    if (is_function_default2(formatter2))
      el = function() {
        return getCallbackValue(formatter2, [datum, index4, data2, tickVector]);
      };
    return container.append(el).attr("className", CLASS_NAMES3.tickItem.name);
  }
  function applyTickStyle(datum, index4, data2, tick3, group3, attr2, style) {
    var tickVector = getTickVector(datum.value, attr2);
    var _a = getTickLineLayout(datum, index4, data2, tickVector, attr2), x12 = _a.x1, x22 = _a.x2, y12 = _a.y1, y22 = _a.y2;
    var _b = __read(splitStyle(getCallbackStyle(style, [datum, index4, data2, tickVector])), 2), tickStyle = _b[0], groupStyle = _b[1];
    tick3.node().nodeName === "line" && tick3.styles(__assign({ x1: x12, x2: x22, y1: y12, y2: y22 }, tickStyle));
    group3.attr(groupStyle);
    tick3.styles(tickStyle);
  }
  function createTick(datum, index4, data2, attr2, tickAttr, animate2) {
    var tick3 = createTickEl(select2(this), datum, index4, data2, attr2);
    applyTickStyle(datum, index4, data2, tick3, this, attr2, tickAttr);
    var _a = __read(getValuePos(datum.value, attr2), 2), x3 = _a[0], y3 = _a[1];
    return transition(this, { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2);
  }
  function renderTicks(container, axisData, attr2, animate2) {
    var finalData = filterExec(axisData, attr2.tickFilter);
    var tickAttr = subStyleProps(attr2, "tick");
    return container.selectAll(CLASS_NAMES3.tick.class).data(finalData, function(d2) {
      return d2.id || d2.label;
    }).join(function(enter) {
      return enter.append("g").attr("className", CLASS_NAMES3.tick.name).transition(function(datum, index4) {
        return createTick.call(this, datum, index4, finalData, attr2, tickAttr, false);
      });
    }, function(update) {
      return update.transition(function(datum, index4) {
        this.removeChildren();
        return createTick.call(this, datum, index4, finalData, attr2, tickAttr, animate2.update);
      });
    }, function(exit) {
      return exit.transition(function() {
        var _this = this;
        var animation = fadeOut_default(this.childNodes[0], animate2.exit);
        onAnimateFinished(animation, function() {
          return _this.remove();
        });
        return animation;
      });
    }).transitions();
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/title/index.js
  var CLASS_NAMES5 = classNames({
    text: "text"
  }, "title");
  function parsePosition(position) {
    if (!/\S+-\S+/g.test(position))
      return position.length > 2 ? [position[0]] : position.split("");
    return position.split("-").map(function(str7) {
      return str7[0];
    });
  }
  function getBBox(title, content) {
    var _a = title.attributes, position = _a.position, spacing = _a.spacing, inset = _a.inset, text = _a.text;
    var titleBBox = title.getBBox();
    var contentBBox = content.getBBox();
    var pos = parsePosition(position);
    var _b = __read(parseSeriesAttr(text ? spacing : 0), 4), spacingTop = _b[0], spacingRight = _b[1], spacingBottom = _b[2], spacingLeft = _b[3];
    var _c = __read(parseSeriesAttr(inset), 4), insetTop = _c[0], insetRight = _c[1], insetBottom = _c[2], insetLeft = _c[3];
    var _d = __read([spacingLeft + spacingRight, spacingTop + spacingBottom], 2), spacingWidth = _d[0], spacingHeight = _d[1];
    var _e = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _e[0], insetHeight = _e[1];
    if (pos[0] === "l") {
      return new BBox(titleBBox.x, titleBBox.y, contentBBox.width + titleBBox.width + spacingWidth + insetWidth, Math.max(contentBBox.height + insetHeight, titleBBox.height));
    }
    if (pos[0] === "t") {
      return new BBox(titleBBox.x, titleBBox.y, Math.max(contentBBox.width + insetWidth, titleBBox.width), contentBBox.height + titleBBox.height + spacingHeight + insetHeight);
    }
    var _f = __read([
      content.attributes.width || contentBBox.width,
      content.attributes.height || contentBBox.height
    ], 2), contentWidth = _f[0], contentHeight = _f[1];
    return new BBox(contentBBox.x, contentBBox.y, contentWidth + titleBBox.width + spacingWidth + insetWidth, contentHeight + titleBBox.height + spacingHeight + insetHeight);
  }
  function mayApplyStyle(el, style) {
    var finalStyle = Object.entries(style).reduce(function(acc, _a) {
      var _b = __read(_a, 2), key = _b[0], value2 = _b[1];
      var currAttr = el.node().attr(key);
      if (!currAttr)
        acc[key] = value2;
      return acc;
    }, {});
    el.styles(finalStyle);
  }
  function getTitleLayout(cfg) {
    var _a, _b, _c, _d;
    var _e = cfg, width = _e.width, height = _e.height, position = _e.position;
    var _f = __read([+width / 2, +height / 2], 2), hW = _f[0], hH = _f[1];
    var _g = __read([+hW, +hH, "center", "middle"], 4), x3 = _g[0], y3 = _g[1], textAlign = _g[2], textBaseline = _g[3];
    var pos = parsePosition(position);
    if (pos.includes("l"))
      _a = __read([0, "start"], 2), x3 = _a[0], textAlign = _a[1];
    if (pos.includes("r"))
      _b = __read([+width, "end"], 2), x3 = _b[0], textAlign = _b[1];
    if (pos.includes("t"))
      _c = __read([0, "top"], 2), y3 = _c[0], textBaseline = _c[1];
    if (pos.includes("b"))
      _d = __read([+height, "bottom"], 2), y3 = _d[0], textBaseline = _d[1];
    return { x: x3, y: y3, textAlign, textBaseline };
  }
  var Title = (
    /** @class */
    function(_super) {
      __extends(Title3, _super);
      function Title3(options) {
        return _super.call(this, options, {
          text: "",
          width: 0,
          height: 0,
          fill: "#4a505a",
          fontWeight: "bold",
          fontSize: 12,
          fontFamily: "sans-serif",
          inset: 0,
          spacing: 0,
          position: "top-left"
        }) || this;
      }
      Title3.prototype.getAvailableSpace = function() {
        var container = this;
        var _a = this.attributes, containerWidth = _a.width, containerHeight = _a.height, position = _a.position, spacing = _a.spacing, inset = _a.inset;
        var title = container.querySelector(CLASS_NAMES5.text.class);
        if (!title)
          return new BBox(0, 0, +containerWidth, +containerHeight);
        var _b = title.getBBox(), titleWidth = _b.width, titleHeight = _b.height;
        var _c = __read(parseSeriesAttr(spacing), 4), spacingTop = _c[0], spacingRight = _c[1], spacingBottom = _c[2], spacingLeft = _c[3];
        var _d = __read([0, 0, +containerWidth, +containerHeight], 4), x3 = _d[0], y3 = _d[1], width = _d[2], height = _d[3];
        var pos = parsePosition(position);
        if (pos.includes("i"))
          return new BBox(x3, y3, width, height);
        pos.forEach(function(p2, i) {
          var _a2, _b2, _c2, _d2;
          if (p2 === "t")
            _a2 = __read(i === 0 ? [titleHeight + spacingBottom, +containerHeight - titleHeight - spacingBottom] : [0, +containerHeight], 2), y3 = _a2[0], height = _a2[1];
          if (p2 === "r")
            _b2 = __read([+containerWidth - titleWidth - spacingLeft], 1), width = _b2[0];
          if (p2 === "b")
            _c2 = __read([+containerHeight - titleHeight - spacingTop], 1), height = _c2[0];
          if (p2 === "l")
            _d2 = __read(i === 0 ? [titleWidth + spacingRight, +containerWidth - titleWidth - spacingRight] : [0, +containerWidth], 2), x3 = _d2[0], width = _d2[1];
        });
        var _e = __read(parseSeriesAttr(inset), 4), insetTop = _e[0], insetRight = _e[1], insetBottom = _e[2], insetLeft = _e[3];
        var _f = __read([insetLeft + insetRight, insetTop + insetBottom], 2), insetWidth = _f[0], insetHeight = _f[1];
        return new BBox(x3 + insetLeft, y3 + insetTop, width - insetWidth, height - insetHeight);
      };
      Title3.prototype.getBBox = function() {
        if (this.title)
          return this.title.getBBox();
        return new BBox(0, 0, 0, 0);
      };
      Title3.prototype.render = function(attributes, container) {
        var _this = this;
        var width = attributes.width, height = attributes.height, position = attributes.position, spacing = attributes.spacing, restStyle = __rest(attributes, ["width", "height", "position", "spacing"]);
        var _a = __read(splitStyle(restStyle), 1), titleStyle = _a[0];
        var _b = getTitleLayout(attributes), x3 = _b.x, y3 = _b.y, textAlign = _b.textAlign, textBaseline = _b.textBaseline;
        ifShow(!!restStyle.text, select2(container), function(group3) {
          _this.title = group3.maybeAppendByClassName(CLASS_NAMES5.text, "text").styles(titleStyle).call(mayApplyStyle, { x: x3, y: y3, textAlign, textBaseline }).node();
        });
      };
      return Title3;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/guides/title.js
  function getTitlePosition(mainGroup, titleGroup, attr2) {
    var _a = attr2.titlePosition, position = _a === void 0 ? "lb" : _a, spacing = attr2.titleSpacing;
    var pos = parsePosition(position);
    var _b = mainGroup.node().getLocalBounds(), _c = __read(_b.min, 2), mainX = _c[0], mainY = _c[1], _d = __read(_b.halfExtents, 2), mainHalfWidth = _d[0], mainHalfHeight = _d[1];
    var _e = __read(titleGroup.node().getLocalBounds().halfExtents, 2), titleHalfWidth = _e[0], titleHalfHeight = _e[1];
    var _f = __read([mainX + mainHalfWidth, mainY + mainHalfHeight], 2), x3 = _f[0], y3 = _f[1];
    var _g = __read(parseSeriesAttr(spacing), 4), spacingTop = _g[0], spacingRight = _g[1], spacingBottom = _g[2], spacingLeft = _g[3];
    if (["start", "end"].includes(position) && attr2.type === "linear") {
      var startPos = attr2.startPos, endPos = attr2.endPos;
      var _h = __read(position === "start" ? [startPos, endPos] : [endPos, startPos], 2), from = _h[0], to = _h[1];
      var direction2 = normalize7([-to[0] + from[0], -to[1] + from[1]]);
      var _j = __read(scale7(direction2, spacingTop), 2), dx = _j[0], dy = _j[1];
      return { x: from[0] + dx, y: from[1] + dy };
    }
    if (pos.includes("t"))
      y3 -= mainHalfHeight + titleHalfHeight + spacingTop;
    if (pos.includes("r"))
      x3 += mainHalfWidth + titleHalfWidth + spacingRight;
    if (pos.includes("l"))
      x3 -= mainHalfWidth + titleHalfWidth + spacingLeft;
    if (pos.includes("b"))
      y3 += mainHalfHeight + titleHalfHeight + spacingBottom;
    return { x: x3, y: y3 };
  }
  function inferTransform(n2, direction2, position) {
    var halfExtents = n2.getGeometryBounds().halfExtents;
    var height = halfExtents[1] * 2;
    if (direction2 === "vertical") {
      if (position === "left")
        return "rotate(-90) translate(0, ".concat(height / 2, ")");
      if (position === "right")
        return "rotate(-90) translate(0, -".concat(height / 2, ")");
    }
    return "";
  }
  function applyTitleStyle(title, group3, axis, attr2, animate2) {
    var style = subStyleProps(attr2, "title");
    var _a = __read(splitStyle(style), 2), titleStyle = _a[0], _b = _a[1], specified = _b.transform, transformOrigin = _b.transformOrigin, groupStyle = __rest(_b, ["transform", "transformOrigin"]);
    group3.styles(groupStyle);
    var transform = specified || inferTransform(title.node(), titleStyle.direction, titleStyle.position);
    title.styles(__assign(__assign({}, titleStyle), { transformOrigin }));
    percentTransform(title.node(), transform);
    var _c = getTitlePosition(
      // @ts-ignore
      select2(axis._offscreen || axis.querySelector(CLASS_NAMES3.mainGroup.class)),
      group3,
      attr2
    ), x3 = _c.x, y3 = _c.y;
    var animation = transition(group3.node(), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }, animate2);
    return animation;
  }
  function renderTitle(container, axis, attr2, animate2) {
    var titleText = attr2.titleText;
    return container.selectAll(CLASS_NAMES3.title.class).data([{ title: titleText }].filter(function(d2) {
      return !!d2.title;
    }), function(d2, i) {
      return d2.title;
    }).join(function(enter) {
      return enter.append(function() {
        return renderExtDo(titleText);
      }).attr("className", CLASS_NAMES3.title.name).transition(function() {
        return applyTitleStyle(select2(this), container, axis, attr2, animate2.enter);
      });
    }, function(update) {
      return update.transition(function() {
        return applyTitleStyle(select2(this), container, axis, attr2, animate2.update);
      });
    }, function(exit) {
      return exit.remove();
    }).transitions();
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/axis/axis.js
  function renderAxisMain(attributes, container, data2, animation) {
    var showLine = attributes.showLine, showTick = attributes.showTick, showLabel = attributes.showLabel;
    var lineGroup = container.maybeAppendByClassName(CLASS_NAMES3.lineGroup, "g");
    var lineTransitions = ifShow(showLine, lineGroup, function(group3) {
      return renderAxisLine(group3, attributes, animation);
    }) || [];
    var tickGroup = container.maybeAppendByClassName(CLASS_NAMES3.tickGroup, "g");
    var tickTransitions = ifShow(showTick, tickGroup, function(group3) {
      return renderTicks(group3, data2, attributes, animation);
    }) || [];
    var labelGroup = container.maybeAppendByClassName(CLASS_NAMES3.labelGroup, "g");
    var labelTransitions = ifShow(showLabel, labelGroup, function(group3) {
      return renderLabels(group3, data2, attributes, animation);
    }) || [];
    return __spreadArray(__spreadArray(__spreadArray([], __read(lineTransitions), false), __read(tickTransitions), false), __read(labelTransitions), false).filter(function(t) {
      return !!t;
    });
  }
  var Axis = (
    /** @class */
    function(_super) {
      __extends(Axis2, _super);
      function Axis2(options) {
        return _super.call(this, options, AXIS_BASE_DEFAULT_ATTR) || this;
      }
      Axis2.prototype.render = function(attributes, container, specificAnimation) {
        var _this = this;
        var titleText = attributes.titleText, data2 = attributes.data, animate2 = attributes.animate, showTitle = attributes.showTitle, showGrid = attributes.showGrid, dataThreshold = attributes.dataThreshold, truncRange = attributes.truncRange;
        var sampledData = sampling(data2, dataThreshold).filter(function(_a) {
          var value2 = _a.value;
          if (truncRange && value2 > truncRange[0] && value2 < truncRange[1])
            return false;
          return true;
        });
        var finalAnimation = parseAnimationOption(specificAnimation === void 0 ? animate2 : specificAnimation);
        var gridGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.gridGroup, "g");
        var gridTransitions = ifShow(showGrid, gridGroup, function(group3) {
          return renderGrid(group3, sampledData, attributes, finalAnimation);
        }) || [];
        var mainGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.mainGroup, "g");
        if (titleText && (!this.initialized && finalAnimation.enter || this.initialized && finalAnimation.update)) {
          renderAxisMain(attributes, select2(this.offscreenGroup), sampledData, parseAnimationOption(false));
        }
        var mainTransitions = renderAxisMain(attributes, select2(mainGroup.node()), sampledData, finalAnimation);
        var titleGroup = select2(container).maybeAppendByClassName(CLASS_NAMES3.titleGroup, "g");
        var titleTransitions = ifShow(showTitle, titleGroup, function(group3) {
          return renderTitle(group3, _this, attributes, finalAnimation);
        }) || [];
        return __spreadArray(__spreadArray(__spreadArray([], __read(gridTransitions), false), __read(mainTransitions), false), __read(titleTransitions), false).flat().filter(function(t) {
          return !!t;
        });
      };
      return Axis2;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/navigator/index.js
  var CLASS_NAMES6 = classNames({
    prevBtnGroup: "prev-btn-group",
    prevBtn: "prev-btn",
    nextBtnGroup: "next-btn-group",
    nextBtn: "next-btn",
    pageInfoGroup: "page-info-group",
    pageInfo: "page-info",
    playWindow: "play-window",
    contentGroup: "content-group",
    controller: "controller",
    clipPath: "clip-path"
  }, "navigator");
  var Navigator2 = (
    /** @class */
    function(_super) {
      __extends(Navigator3, _super);
      function Navigator3(options) {
        var _this = _super.call(this, options, {
          x: 0,
          y: 0,
          animate: {
            easing: "linear",
            duration: 200,
            fill: "both"
          },
          buttonCursor: "pointer",
          buttonFill: "black",
          buttonD: button(0, 0, 6),
          buttonSize: 12,
          controllerPadding: 5,
          controllerSpacing: 5,
          formatter: function(curr, total) {
            return "".concat(curr, "/").concat(total);
          },
          defaultPage: 0,
          loop: false,
          orientation: "horizontal",
          pageNumFill: "black",
          pageNumFontSize: 12,
          pageNumTextAlign: "start",
          pageNumTextBaseline: "middle"
        }) || this;
        _this.playState = "idle";
        _this.contentGroup = _this.appendChild(new Group2({ class: CLASS_NAMES6.contentGroup.name }));
        _this.playWindow = _this.contentGroup.appendChild(new Group2({ class: CLASS_NAMES6.playWindow.name }));
        _this.innerCurrPage = _this.defaultPage;
        return _this;
      }
      Object.defineProperty(Navigator3.prototype, "defaultPage", {
        get: function() {
          var defaultPage = this.attributes.defaultPage;
          return clamp_default3(defaultPage, 0, Math.max(this.pageViews.length - 1, 0));
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Navigator3.prototype, "pageViews", {
        get: function() {
          return this.playWindow.children;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Navigator3.prototype, "controllerShape", {
        // todo fixme
        get: function() {
          return this.totalPages > 1 ? { width: 55, height: 0 } : { width: 0, height: 0 };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Navigator3.prototype, "pageShape", {
        get: function() {
          var pageViews = this.pageViews;
          var _a = __read(transpose3(pageViews.map(function(pageView) {
            var _a2 = pageView.getBBox(), width = _a2.width, height = _a2.height;
            return [width, height];
          })).map(function(arr) {
            return Math.max.apply(Math, __spreadArray([], __read(arr), false));
          }), 2), maxWidth = _a[0], maxHeight = _a[1];
          var _b = this.attributes, _c = _b.pageWidth, pageWidth = _c === void 0 ? maxWidth : _c, _d = _b.pageHeight, pageHeight = _d === void 0 ? maxHeight : _d;
          return { pageWidth, pageHeight };
        },
        enumerable: false,
        configurable: true
      });
      Navigator3.prototype.getContainer = function() {
        return this.playWindow;
      };
      Object.defineProperty(Navigator3.prototype, "totalPages", {
        get: function() {
          return this.pageViews.length;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Navigator3.prototype, "currPage", {
        get: function() {
          return this.innerCurrPage;
        },
        enumerable: false,
        configurable: true
      });
      Navigator3.prototype.getBBox = function() {
        var _a = _super.prototype.getBBox.call(this), x3 = _a.x, y3 = _a.y;
        var controllerShape = this.controllerShape;
        var _b = this.pageShape, pageWidth = _b.pageWidth, pageHeight = _b.pageHeight;
        return new BBox(x3, y3, pageWidth + controllerShape.width, pageHeight);
      };
      Navigator3.prototype.goTo = function(pageNum) {
        var _this = this;
        var animateOptions = this.attributes.animate;
        var _a = this, currPage = _a.currPage, playState = _a.playState, playWindow = _a.playWindow, pageViews = _a.pageViews;
        if (playState !== "idle" || pageNum < 0 || pageViews.length <= 0 || pageNum >= pageViews.length)
          return null;
        pageViews[currPage].setLocalPosition(0, 0);
        this.prepareFollowingPage(pageNum);
        var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
        this.playState = "running";
        var animation = animate(playWindow, [{ transform: "translate(0, 0)" }, { transform: "translate(".concat(-dx, ", ").concat(-dy, ")") }], animateOptions);
        onAnimateFinished(animation, function() {
          _this.innerCurrPage = pageNum;
          _this.playState = "idle";
          _this.setVisiblePages([pageNum]);
          _this.updatePageInfo();
        });
        return animation;
      };
      Navigator3.prototype.prev = function() {
        var loop = this.attributes.loop;
        var pages = this.pageViews.length;
        var page = this.currPage;
        if (!loop && page <= 0)
          return null;
        var following = loop ? (page - 1 + pages) % pages : clamp_default3(page - 1, 0, pages);
        return this.goTo(following);
      };
      Navigator3.prototype.next = function() {
        var loop = this.attributes.loop;
        var pages = this.pageViews.length;
        var page = this.currPage;
        if (!loop && page >= pages - 1)
          return null;
        var following = loop ? (page + 1) % pages : clamp_default3(page + 1, 0, pages);
        return this.goTo(following);
      };
      Navigator3.prototype.renderClipPath = function(container) {
        var _a = this.pageShape, pageWidth = _a.pageWidth, pageHeight = _a.pageHeight;
        if (!pageWidth || !pageHeight) {
          this.contentGroup.style.clipPath = void 0;
          return;
        }
        this.clipPath = container.maybeAppendByClassName(CLASS_NAMES6.clipPath, "rect").styles({
          width: pageWidth,
          height: pageHeight
        });
        this.contentGroup.attr("clipPath", this.clipPath.node());
      };
      Navigator3.prototype.setVisiblePages = function(pages) {
        this.playWindow.children.forEach(function(page, index4) {
          if (pages.includes(index4))
            show(page);
          else
            hide(page);
        });
      };
      Navigator3.prototype.adjustControllerLayout = function() {
        var _a = this, prevBtn = _a.prevBtnGroup, nextBtn = _a.nextBtnGroup, pageNum = _a.pageInfoGroup;
        var _b = this.attributes, orientation = _b.orientation, padding = _b.controllerPadding;
        var _c = pageNum.getBBox(), pW = _c.width, pH = _c.height;
        var _d = __read(orientation === "horizontal" ? [-180, 0] : [-90, 90], 2), r1 = _d[0], r2 = _d[1];
        prevBtn.setLocalEulerAngles(r1);
        nextBtn.setLocalEulerAngles(r2);
        var _e = prevBtn.getBBox(), bpW = _e.width, bpH = _e.height;
        var _f = nextBtn.getBBox(), bnW = _f.width, bnH = _f.height;
        var maxWidth = Math.max(bpW, pW, bnW);
        var _g = orientation === "horizontal" ? {
          offset: [
            [0, 0],
            [bpW / 2 + padding, 0],
            [bpW + pW + padding * 2, 0]
          ],
          textAlign: "start"
        } : {
          offset: [
            [maxWidth / 2, -bpH - padding],
            [maxWidth / 2, 0],
            [maxWidth / 2, bnH + padding]
          ],
          textAlign: "center"
        }, _h = __read(_g.offset, 3), _j = __read(_h[0], 2), o1x = _j[0], o1y = _j[1], _k = __read(_h[1], 2), o2x = _k[0], o2y = _k[1], _l = __read(_h[2], 2), o3x = _l[0], o3y = _l[1], textAlign = _g.textAlign;
        var pageNumText = pageNum.querySelector("text");
        pageNumText && (pageNumText.style.textAlign = textAlign);
        prevBtn.setLocalPosition(o1x, o1y);
        pageNum.setLocalPosition(o2x, o2y);
        nextBtn.setLocalPosition(o3x, o3y);
      };
      Navigator3.prototype.updatePageInfo = function() {
        var _a;
        var _b = this, currPage = _b.currPage, pageViews = _b.pageViews, formatter2 = _b.attributes.formatter;
        if (pageViews.length < 2)
          return;
        (_a = this.pageInfoGroup.querySelector(CLASS_NAMES6.pageInfo.class)) === null || _a === void 0 ? void 0 : _a.attr("text", formatter2(currPage + 1, pageViews.length));
        this.adjustControllerLayout();
      };
      Navigator3.prototype.getFollowingPageDiff = function(pageNum) {
        var currPage = this.currPage;
        if (currPage === pageNum)
          return [0, 0];
        var orientation = this.attributes.orientation;
        var _a = this.pageShape, pageWidth = _a.pageWidth, pageHeight = _a.pageHeight;
        var sign3 = pageNum < currPage ? -1 : 1;
        return orientation === "horizontal" ? [sign3 * pageWidth, 0] : [0, sign3 * pageHeight];
      };
      Navigator3.prototype.prepareFollowingPage = function(pageNum) {
        var _a = this, currPage = _a.currPage, pageViews = _a.pageViews;
        this.setVisiblePages([pageNum, currPage]);
        if (pageNum !== currPage) {
          var _b = __read(this.getFollowingPageDiff(pageNum), 2), dx = _b[0], dy = _b[1];
          pageViews[pageNum].setLocalPosition(dx, dy);
        }
      };
      Navigator3.prototype.renderController = function(container) {
        var _this = this;
        var spacing = this.attributes.controllerSpacing;
        var _a = this.pageShape, pageWidth = _a.pageWidth, pageHeight = _a.pageHeight;
        var visible = this.pageViews.length >= 2;
        var group3 = container.maybeAppendByClassName(CLASS_NAMES6.controller, "g");
        visibility(group3.node(), visible);
        if (!visible)
          return;
        var style = subStyleProps(this.attributes, "button");
        var textStyle = subStyleProps(this.attributes, "pageNum");
        var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1], size2 = _c.size, pathStyle = __rest(_c, ["size"]);
        var whetherToAddEventListener = !group3.select(CLASS_NAMES6.prevBtnGroup.class).node();
        var prevBtnGroup = group3.maybeAppendByClassName(CLASS_NAMES6.prevBtnGroup, "g").styles(groupStyle);
        this.prevBtnGroup = prevBtnGroup.node();
        var prevBtn = prevBtnGroup.maybeAppendByClassName(CLASS_NAMES6.prevBtn, "path");
        var nextBtnGroup = group3.maybeAppendByClassName(CLASS_NAMES6.nextBtnGroup, "g").styles(groupStyle);
        this.nextBtnGroup = nextBtnGroup.node();
        var nextBtn = nextBtnGroup.maybeAppendByClassName(CLASS_NAMES6.nextBtn, "path");
        [prevBtn, nextBtn].forEach(function(btn) {
          btn.styles(__assign(__assign({}, pathStyle), { transformOrigin: "center" }));
          scaleToPixel(btn.node(), size2, true);
        });
        var pageInfoGroup = group3.maybeAppendByClassName(CLASS_NAMES6.pageInfoGroup, "g");
        this.pageInfoGroup = pageInfoGroup.node();
        pageInfoGroup.maybeAppendByClassName(CLASS_NAMES6.pageInfo, "text").styles(textStyle);
        this.updatePageInfo();
        group3.node().setLocalPosition(pageWidth + spacing, pageHeight / 2);
        if (whetherToAddEventListener) {
          this.prevBtnGroup.addEventListener("click", function() {
            _this.prev();
          });
          this.nextBtnGroup.addEventListener("click", function() {
            _this.next();
          });
        }
      };
      Navigator3.prototype.render = function(attributes, container) {
        var _a = attributes.x, x3 = _a === void 0 ? 0 : _a, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
        this.attr("transform", "translate(".concat(x3, ", ").concat(y3, ")"));
        var containerSelection = select2(container);
        this.renderClipPath(containerSelection);
        this.renderController(containerSelection);
        this.setVisiblePages([this.defaultPage]);
        this.goTo(this.defaultPage);
      };
      Navigator3.prototype.bindEvents = function() {
        var _this = this;
        var render2 = debounce_default2(function() {
          return _this.render(_this.attributes, _this);
        }, 50);
        this.playWindow.addEventListener(ElementEvent.INSERTED, render2);
        this.playWindow.addEventListener(ElementEvent.REMOVED, render2);
      };
      return Navigator3;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/legend/utils.js
  function getStepValueByValue(value2, step2, min10) {
    var count4 = Math.round((value2 - min10) / step2);
    return min10 + count4 * step2;
  }
  function hiddenHandle(x3, y3, r) {
    var ratio = 1.4;
    var diffY = ratio * r;
    return [["M", x3 - r, y3 - diffY], ["L", x3 + r, y3 - diffY], ["L", x3 + r, y3 + diffY], ["L", x3 - r, y3 + diffY], ["Z"]];
  }
  var HANDLE_HEIGHT_RATIO = 1.4;
  var HANDLE_TRIANGLE_RATIO = 0.4;
  function verticalHandle(x3, y3, r) {
    var width = r;
    var height = width * HANDLE_HEIGHT_RATIO;
    var halfWidth = width / 2;
    var oneSixthWidth = width / 6;
    var triangleX = x3 + height * HANDLE_TRIANGLE_RATIO;
    return [
      ["M", x3, y3],
      ["L", triangleX, y3 + halfWidth],
      ["L", x3 + height, y3 + halfWidth],
      ["L", x3 + height, y3 - halfWidth],
      ["L", triangleX, y3 - halfWidth],
      ["Z"],
      // 绘制两条横线
      ["M", triangleX, y3 + oneSixthWidth],
      ["L", x3 + height - 2, y3 + oneSixthWidth],
      ["M", triangleX, y3 - oneSixthWidth],
      ["L", x3 + height - 2, y3 - oneSixthWidth]
    ];
  }
  function horizontalHandle(x3, y3, r) {
    var width = r;
    var height = width * HANDLE_HEIGHT_RATIO;
    var halfWidth = width / 2;
    var oneSixthWidth = width / 6;
    var triangleY = y3 + height * HANDLE_TRIANGLE_RATIO;
    return [
      ["M", x3, y3],
      ["L", x3 - halfWidth, triangleY],
      ["L", x3 - halfWidth, y3 + height],
      ["L", x3 + halfWidth, y3 + height],
      ["L", x3 + halfWidth, triangleY],
      ["Z"],
      // 绘制两条竖线
      ["M", x3 - oneSixthWidth, triangleY],
      ["L", x3 - oneSixthWidth, y3 + height - 2],
      ["M", x3 + oneSixthWidth, triangleY],
      ["L", x3 + oneSixthWidth, y3 + height - 2]
    ];
  }
  Marker.registerSymbol("hiddenHandle", hiddenHandle);
  Marker.registerSymbol("verticalHandle", verticalHandle);
  Marker.registerSymbol("horizontalHandle", horizontalHandle);
  function getSafetySelections(domain, newSelection, oldSelection, precision) {
    var _a;
    if (precision === void 0) {
      precision = 4;
    }
    var _b = __read(domain, 2), min10 = _b[0], max10 = _b[1];
    var _c = __read(newSelection, 2), start2 = _c[0], end = _c[1];
    var _d = __read(oldSelection, 2), prevStart = _d[0], prevEnd = _d[1];
    var _e = __read([start2, end], 2), startVal = _e[0], endVal = _e[1];
    var range3 = endVal - startVal;
    if (startVal > endVal) {
      _a = __read([endVal, startVal], 2), startVal = _a[0], endVal = _a[1];
    }
    if (range3 > max10 - min10) {
      return [min10, max10];
    }
    if (startVal < min10) {
      if (prevStart === min10 && prevEnd === endVal) {
        return [min10, endVal];
      }
      return [min10, range3 + min10];
    }
    if (endVal > max10) {
      if (prevEnd === max10 && prevStart === startVal) {
        return [startVal, max10];
      }
      return [max10 - range3, max10];
    }
    return [startVal, endVal];
  }
  function ifHorizontal(orientation, a3, b) {
    if (orientation === void 0) {
      orientation = "horizontal";
    }
    return orientation === "horizontal" ? a3 : b;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/legend/category/item.js
  var CLASS_NAMES7 = classNames({
    layout: "flex",
    markerGroup: "marker-group",
    marker: "marker",
    labelGroup: "label-group",
    label: "label",
    valueGroup: "value-group",
    value: "value",
    backgroundGroup: "background-group",
    background: "background"
  }, "legend-category-item");
  function styleOfMarker(group3) {
    var marker = group3.querySelector(CLASS_NAMES7.marker.class);
    if (marker)
      return marker.style;
    return {};
  }
  var CategoryItem = (
    /** @class */
    function(_super) {
      __extends(CategoryItem2, _super);
      function CategoryItem2(options) {
        return _super.call(this, options, {
          span: [1, 1],
          marker: function() {
            return new Circle({ style: { r: 6 } });
          },
          markerSize: 10,
          labelFill: "#646464",
          valueFill: "#646464",
          labelFontSize: 12,
          valueFontSize: 12,
          labelTextBaseline: "middle",
          valueTextBaseline: "middle"
        }) || this;
      }
      Object.defineProperty(CategoryItem2.prototype, "showValue", {
        get: function() {
          var valueText = this.attributes.valueText;
          if (!valueText)
            return false;
          if (typeof valueText === "string" || typeof valueText === "number")
            return valueText !== "";
          if (typeof valueText === "function")
            return true;
          return valueText.attr("text") !== "";
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "actualSpace", {
        get: function() {
          var label = this.labelGroup;
          var value2 = this.valueGroup;
          var markerSize = this.attributes.markerSize;
          var _a = label.node().getBBox(), labelWidth = _a.width, labelHeight = _a.height;
          var _b = value2.node().getBBox(), valueWidth = _b.width, valueHeight = _b.height;
          return {
            markerWidth: markerSize,
            labelWidth,
            valueWidth,
            height: Math.max(markerSize, labelHeight, valueHeight)
          };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "span", {
        get: function() {
          var span = this.attributes.span;
          if (!span)
            return [1, 1];
          var _a = __read(parseSeriesAttr(span), 2), span1 = _a[0], innerSpan = _a[1];
          var span2 = this.showValue ? innerSpan : 0;
          var basis2 = span1 + span2;
          return [span1 / basis2, span2 / basis2];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "shape", {
        get: function() {
          var _a;
          var _b = this.attributes, markerSize = _b.markerSize, fullWidth = _b.width;
          var actualSpace = this.actualSpace;
          var markerWidth = actualSpace.markerWidth, height = actualSpace.height;
          var _c = this.actualSpace, labelWidth = _c.labelWidth, valueWidth = _c.valueWidth;
          var _d = __read(this.spacing, 2), spacing1 = _d[0], spacing2 = _d[1];
          if (fullWidth) {
            var width_1 = fullWidth - markerSize - spacing1 - spacing2;
            var _e = __read(this.span, 2), span1 = _e[0], span2 = _e[1];
            _a = __read([span1 * width_1, span2 * width_1], 2), labelWidth = _a[0], valueWidth = _a[1];
          }
          var width = markerWidth + labelWidth + valueWidth + spacing1 + spacing2;
          return { width, height, markerWidth, labelWidth, valueWidth };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "spacing", {
        get: function() {
          var spacing = this.attributes.spacing;
          if (!spacing)
            return [0, 0];
          var _a = __read(parseSeriesAttr(spacing), 2), spacing1 = _a[0], spacing2 = _a[1];
          if (this.showValue)
            return [spacing1, spacing2];
          return [spacing1, 0];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "layout", {
        get: function() {
          var _a = this.shape, markerWidth = _a.markerWidth, labelWidth = _a.labelWidth, valueWidth = _a.valueWidth, width = _a.width, height = _a.height;
          var _b = __read(this.spacing, 2), spacing1 = _b[0], spacing2 = _b[1];
          return {
            height,
            width,
            markerWidth,
            labelWidth,
            valueWidth,
            position: [markerWidth / 2, markerWidth + spacing1, markerWidth + labelWidth + spacing1 + spacing2]
          };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItem2.prototype, "scaleSize", {
        get: function() {
          var markerShapeStyle = styleOfMarker(this.markerGroup.node());
          var _a = this.attributes, markerSize = _a.markerSize, _b = _a.markerStrokeWidth, markerStrokeWidth = _b === void 0 ? markerShapeStyle.strokeWidth : _b, _c = _a.markerLineWidth, markerLineWidth = _c === void 0 ? markerShapeStyle.lineWidth : _c, _d = _a.markerStroke, markerStroke = _d === void 0 ? markerShapeStyle.stroke : _d;
          var strokeWidth = +(markerStrokeWidth || markerLineWidth || (markerStroke ? 1 : 0)) * Math.sqrt(2);
          var _e = this.markerGroup.node().getBBox(), width = _e.width, height = _e.height;
          return (1 - strokeWidth / Math.max(width, height)) * markerSize;
        },
        enumerable: false,
        configurable: true
      });
      CategoryItem2.prototype.renderMarker = function(container) {
        var _this = this;
        var marker = this.attributes.marker;
        var style = subStyleProps(this.attributes, "marker");
        this.markerGroup = container.maybeAppendByClassName(CLASS_NAMES7.markerGroup, "g").style("zIndex", 0);
        ifShow(!!marker, this.markerGroup, function() {
          var _a;
          var parent = _this.markerGroup.node();
          var oldMarker = (_a = parent.childNodes) === null || _a === void 0 ? void 0 : _a[0];
          var newMarker = typeof marker === "string" ? new Marker({ style: { symbol: marker }, className: CLASS_NAMES7.marker.name }) : marker();
          if (!oldMarker) {
            if (!(newMarker instanceof Marker))
              select2(newMarker).attr("className", CLASS_NAMES7.marker.name).styles(style);
            parent.appendChild(newMarker);
          } else if (newMarker.nodeName === oldMarker.nodeName) {
            if (oldMarker instanceof Marker)
              oldMarker.update(__assign(__assign({}, style), { symbol: marker }));
            else {
              copyAttributes2(oldMarker, newMarker);
              select2(oldMarker).styles(style);
            }
          } else {
            oldMarker.remove();
            select2(newMarker).attr("className", CLASS_NAMES7.marker.name).styles(style);
            parent.appendChild(newMarker);
          }
          _this.markerGroup.node().scale(1 / _this.markerGroup.node().getScale()[0]);
          var scale9 = scaleToPixel(_this.markerGroup.node(), _this.scaleSize, true);
          _this.markerGroup.node().style._transform = "scale(".concat(scale9, ")");
        });
      };
      CategoryItem2.prototype.renderLabel = function(container) {
        var _a = subStyleProps(this.attributes, "label"), label = _a.text, style = __rest(_a, ["text"]);
        this.labelGroup = container.maybeAppendByClassName(CLASS_NAMES7.labelGroup, "g").style("zIndex", 0);
        this.labelGroup.maybeAppendByClassName(CLASS_NAMES7.label, function() {
          return renderExtDo(label);
        }).styles(style);
      };
      CategoryItem2.prototype.renderValue = function(container) {
        var _this = this;
        var _a = subStyleProps(this.attributes, "value"), value2 = _a.text, style = __rest(_a, ["text"]);
        this.valueGroup = container.maybeAppendByClassName(CLASS_NAMES7.valueGroup, "g").style("zIndex", 0);
        ifShow(this.showValue, this.valueGroup, function() {
          _this.valueGroup.maybeAppendByClassName(CLASS_NAMES7.value, function() {
            return renderExtDo(value2);
          }).styles(style);
        });
      };
      CategoryItem2.prototype.renderBackground = function(container) {
        var _a = this.shape, width = _a.width, height = _a.height;
        var style = subStyleProps(this.attributes, "background");
        this.background = container.maybeAppendByClassName(CLASS_NAMES7.backgroundGroup, "g").style("zIndex", -1);
        this.background.maybeAppendByClassName(CLASS_NAMES7.background, "rect").styles(__assign({ width, height }, style));
      };
      CategoryItem2.prototype.adjustLayout = function() {
        var _a = this.layout, labelWidth = _a.labelWidth, valueWidth = _a.valueWidth, height = _a.height, _b = __read(_a.position, 3), markerX = _b[0], labelX = _b[1], valueX = _b[2];
        var halfHeight = height / 2;
        this.markerGroup.styles({
          transform: "translate(".concat(markerX, ", ").concat(halfHeight, ")").concat(this.markerGroup.node().style._transform)
        });
        this.labelGroup.styles({ transform: "translate(".concat(labelX, ", ").concat(halfHeight, ")") });
        ellipsisIt(this.labelGroup.select(CLASS_NAMES7.label.class).node(), Math.ceil(labelWidth));
        if (this.showValue) {
          this.valueGroup.styles({ transform: "translate(".concat(valueX, ", ").concat(halfHeight, ")") });
          ellipsisIt(this.valueGroup.select(CLASS_NAMES7.value.class).node(), Math.ceil(valueWidth));
        }
      };
      CategoryItem2.prototype.render = function(attributes, container) {
        var ctn = select2(container);
        var _a = attributes.x, x3 = _a === void 0 ? 0 : _a, _b = attributes.y, y3 = _b === void 0 ? 0 : _b;
        ctn.styles({ transform: "translate(".concat(x3, ", ").concat(y3, ")") });
        this.renderMarker(ctn);
        this.renderLabel(ctn);
        this.renderValue(ctn);
        this.renderBackground(ctn);
        this.adjustLayout();
      };
      return CategoryItem2;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/legend/category/items.js
  var CLASS_NAMES8 = classNames({
    page: "item-page",
    navigator: "navigator",
    item: "item"
  }, "items");
  var ifSatisfied = function(value2, rule, defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = true;
    }
    if (value2) {
      return rule(value2);
    }
    return defaultValue;
  };
  var CategoryItems = (
    /** @class */
    function(_super) {
      __extends(CategoryItems2, _super);
      function CategoryItems2(options) {
        var _this = _super.call(this, options, {
          data: [],
          gridRow: Infinity,
          gridCol: void 0,
          padding: 0,
          width: 1e3,
          height: 100,
          rowPadding: 0,
          colPadding: 0,
          layout: "flex",
          orientation: "horizontal",
          click: noop_default2,
          mouseenter: noop_default2,
          mouseleave: noop_default2
        }) || this;
        _this.navigatorShape = [0, 0];
        return _this;
      }
      Object.defineProperty(CategoryItems2.prototype, "pageViews", {
        get: function() {
          return this.navigator.getContainer();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItems2.prototype, "grid", {
        get: function() {
          var _a = this.attributes, gridRow = _a.gridRow, gridCol = _a.gridCol, data2 = _a.data;
          if (!gridRow && !gridCol)
            throw new Error("gridRow and gridCol can not be set null at the same time");
          if (!!gridRow && !!gridCol)
            return [gridRow, gridCol];
          if (gridRow)
            return [gridRow, data2.length];
          return [data2.length, gridCol];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CategoryItems2.prototype, "renderData", {
        get: function() {
          var _a = this.attributes, data2 = _a.data, layout = _a.layout;
          var style = subStyleProps(this.attributes, "item");
          var d2 = data2.map(function(datum, index4) {
            var _a2 = datum.id, id4 = _a2 === void 0 ? index4 : _a2, labelText = datum.label, valueText = datum.value;
            return {
              id: "".concat(id4),
              index: index4,
              style: __assign({ layout, labelText, valueText }, Object.fromEntries(Object.entries(style).map(function(_a3) {
                var _b = __read(_a3, 2), key = _b[0], val = _b[1];
                return [key, getCallbackValue(val, [datum, index4, data2])];
              })))
            };
          });
          return d2;
        },
        enumerable: false,
        configurable: true
      });
      CategoryItems2.prototype.getGridLayout = function() {
        var _this = this;
        var _a = this.attributes, orientation = _a.orientation, width = _a.width, rowPadding = _a.rowPadding, colPadding = _a.colPadding;
        var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
        var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
        var pageSize = gridCol * gridRow;
        var prevOffset = 0;
        return this.pageViews.children.map(function(item, index4) {
          var _a2, _b2;
          var page = Math.floor(index4 / pageSize);
          var pageIndex = index4 % pageSize;
          var dir = _this.ifHorizontal(gridCol, gridRow);
          var pos = [Math.floor(pageIndex / dir), pageIndex % dir];
          if (orientation === "vertical")
            pos.reverse();
          var _c2 = __read(pos, 2), row2 = _c2[0], col = _c2[1];
          var colWidth = (width - navWidth - (gridCol - 1) * colPadding) / gridCol;
          var rowHeight = item.getBBox().height;
          var _d = __read([0, 0], 2), x3 = _d[0], y3 = _d[1];
          if (orientation === "horizontal") {
            _a2 = __read([prevOffset, row2 * (rowHeight + rowPadding)], 2), x3 = _a2[0], y3 = _a2[1];
            prevOffset = col === gridCol - 1 ? 0 : prevOffset + colWidth + colPadding;
          } else {
            _b2 = __read([col * (colWidth + colPadding), prevOffset], 2), x3 = _b2[0], y3 = _b2[1];
            prevOffset = row2 === gridRow - 1 ? 0 : prevOffset + rowHeight + rowPadding;
          }
          return { page, index: index4, row: row2, col, pageIndex, width: colWidth, height: rowHeight, x: x3, y: y3 };
        });
      };
      CategoryItems2.prototype.getFlexLayout = function() {
        var _a = this.attributes, maxWidth = _a.width, maxHeight = _a.height, rowPadding = _a.rowPadding, cP = _a.colPadding;
        var _b = __read(this.navigatorShape, 1), navWidth = _b[0];
        var _c = __read(this.grid, 2), gridRow = _c[0], gridCol = _c[1];
        var _d = __read([maxWidth - navWidth, maxHeight], 2), limitWidth = _d[0], limitHeight = _d[1];
        var _e = __read([0, 0, 0, 0, 0, 0, 0, 0], 8), x3 = _e[0], y3 = _e[1], page = _e[2], pageIndex = _e[3], col = _e[4], row2 = _e[5], prevWidth = _e[6], prevHeight = _e[7];
        return this.pageViews.children.map(function(item, index4) {
          var _a2, _b2, _c2, _d2;
          var _e2 = item.getBBox(), width = _e2.width, height = _e2.height;
          var colPadding = prevWidth === 0 ? 0 : cP;
          var nextWidth = prevWidth + colPadding + width;
          if (nextWidth <= limitWidth && ifSatisfied(col, function(c5) {
            return c5 < gridCol;
          })) {
            _a2 = __read([prevWidth + colPadding, prevHeight, nextWidth], 3), x3 = _a2[0], y3 = _a2[1], prevWidth = _a2[2];
            return { width, height, x: x3, y: y3, page, index: index4, pageIndex: pageIndex++, row: row2, col: col++ };
          }
          _b2 = __read([row2 + 1, 0, 0, prevHeight + height + rowPadding], 4), row2 = _b2[0], col = _b2[1], prevWidth = _b2[2], prevHeight = _b2[3];
          var nextHeight = prevHeight + height;
          if (nextHeight <= limitHeight && ifSatisfied(row2, function(r) {
            return r < gridRow;
          })) {
            _c2 = __read([prevWidth, prevHeight, width], 3), x3 = _c2[0], y3 = _c2[1], prevWidth = _c2[2];
            return { width, height, x: x3, y: y3, page, index: index4, pageIndex: pageIndex++, row: row2, col: col++ };
          }
          _d2 = __read([0, 0, width, 0, page + 1, 0, 0, 0], 8), x3 = _d2[0], y3 = _d2[1], prevWidth = _d2[2], prevHeight = _d2[3], page = _d2[4], pageIndex = _d2[5], row2 = _d2[6], col = _d2[7];
          return { width, height, x: x3, y: y3, page, index: index4, pageIndex: pageIndex++, row: row2, col: col++ };
        });
      };
      Object.defineProperty(CategoryItems2.prototype, "itemsLayout", {
        get: function() {
          this.navigatorShape = [0, 0];
          var cb = this.attributes.layout === "grid" ? this.getGridLayout : this.getFlexLayout;
          var layout = cb.call(this);
          if (layout.slice(-1)[0].page > 0) {
            this.navigatorShape = [55, 0];
            return cb.call(this);
          }
          return layout;
        },
        enumerable: false,
        configurable: true
      });
      CategoryItems2.prototype.ifHorizontal = function(a3, b) {
        var orientation = this.attributes.orientation;
        return ifHorizontal(orientation, a3, b);
      };
      CategoryItems2.prototype.flattenPage = function(container) {
        container.querySelectorAll(CLASS_NAMES8.item.class).forEach(function(item) {
          container.appendChild(item);
        });
        container.querySelectorAll(CLASS_NAMES8.page.class).forEach(function(page) {
          var removedPage = container.removeChild(page);
          removedPage.destroy();
        });
      };
      CategoryItems2.prototype.renderItems = function(container) {
        var _a = this.attributes, click = _a.click, mouseenter = _a.mouseenter, mouseleave = _a.mouseleave;
        this.flattenPage(container);
        var dispatchCustomEvent = this.dispatchCustomEvent.bind(this);
        select2(container).selectAll(CLASS_NAMES8.item.class).data(this.renderData, function(d2) {
          return d2.id;
        }).join(function(enter) {
          return enter.append(function(_a2) {
            var style = _a2.style;
            return new CategoryItem({ style });
          }).attr("className", CLASS_NAMES8.item.name).on("click", function() {
            click === null || click === void 0 ? void 0 : click(this);
            dispatchCustomEvent("itemClick", { item: this });
          }).on("pointerenter", function() {
            mouseenter === null || mouseenter === void 0 ? void 0 : mouseenter(this);
            dispatchCustomEvent("itemMouseenter", { item: this });
          }).on("pointerleave", function() {
            mouseleave === null || mouseleave === void 0 ? void 0 : mouseleave(this);
            dispatchCustomEvent("itemMouseleave", { item: this });
          });
        }, function(update) {
          return update.each(function(_a2) {
            var style = _a2.style;
            this.update(style);
          });
        }, function(exit) {
          return exit.remove();
        });
      };
      CategoryItems2.prototype.relayoutNavigator = function() {
        var _a;
        var _b = this.attributes, layout = _b.layout, width = _b.width;
        var height = ((_a = this.pageViews.children[0]) === null || _a === void 0 ? void 0 : _a.getBBox().height) || 0;
        var _c = __read(this.navigatorShape, 2), navWidth = _c[0], navHeight = _c[1];
        this.navigator.update(layout === "grid" ? { pageWidth: width - navWidth, pageHeight: height - navHeight } : {});
      };
      CategoryItems2.prototype.adjustLayout = function() {
        var _this = this;
        var itemsLayouts = Object.entries(groupBy(this.itemsLayout, "page")).map(function(_a) {
          var _b = __read(_a, 2), page = _b[0], layouts = _b[1];
          return {
            page,
            layouts
          };
        });
        var categoryItems = __spreadArray([], __read(this.navigator.getContainer().children), false);
        itemsLayouts.forEach(function(_a) {
          var layouts = _a.layouts;
          var page = _this.pageViews.appendChild(new Group2({ className: CLASS_NAMES8.page.name }));
          layouts.forEach(function(layout) {
            var x3 = layout.x, y3 = layout.y, index4 = layout.index, width = layout.width, height = layout.height;
            var item = categoryItems[index4];
            page.appendChild(item);
            set_default(item, "__layout__", layout);
            item.update({ x: x3, y: y3, width, height });
          });
        });
        this.relayoutNavigator();
      };
      CategoryItems2.prototype.renderNavigator = function(container) {
        var orientation = this.attributes.orientation;
        var navStyle = subStyleProps(this.attributes, "nav");
        var style = deepAssign2({ orientation }, navStyle);
        var that = this;
        container.selectAll(CLASS_NAMES8.navigator.class).data(["nav"]).join(function(enter) {
          return enter.append(function() {
            return new Navigator2({ style });
          }).attr("className", CLASS_NAMES8.navigator.name).each(function() {
            that.navigator = this;
          });
        }, function(update) {
          return update.each(function() {
            this.update(style);
          });
        }, function(exit) {
          return exit.remove();
        });
        return this.navigator;
      };
      CategoryItems2.prototype.getBBox = function() {
        return this.navigator.getBBox();
      };
      CategoryItems2.prototype.render = function(attributes, container) {
        var data2 = this.attributes.data;
        if (!data2 || data2.length === 0)
          return;
        var navigator2 = this.renderNavigator(select2(container));
        this.renderItems(navigator2.getContainer());
        this.adjustLayout();
      };
      CategoryItems2.prototype.dispatchCustomEvent = function(type, payload) {
        var evt = new CustomEvent2(type, {
          detail: payload
        });
        this.dispatchEvent(evt);
      };
      return CategoryItems2;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/legend/continuous/handle.js
  var CLASS_NAMES9 = classNames({
    markerGroup: "marker-group",
    marker: "marker",
    labelGroup: "label-group",
    label: "label"
  }, "handle");
  var DEFAULT_HANDLE_CFG = {
    showLabel: true,
    formatter: function(val) {
      return val.toString();
    },
    markerSize: 25,
    markerStroke: "#c5c5c5",
    markerFill: "#fff",
    markerLineWidth: 1,
    labelFontSize: 12,
    labelFill: "#c5c5c5",
    labelText: "",
    orientation: "vertical",
    spacing: 0
  };
  var Handle2 = (
    /** @class */
    function(_super) {
      __extends(Handle3, _super);
      function Handle3(options) {
        return _super.call(this, options, DEFAULT_HANDLE_CFG) || this;
      }
      Handle3.prototype.render = function(attributes, container) {
        var markerGroup = select2(container).maybeAppendByClassName(CLASS_NAMES9.markerGroup, "g");
        this.renderMarker(markerGroup);
        var labelGroup = select2(container).maybeAppendByClassName(CLASS_NAMES9.labelGroup, "g");
        this.renderLabel(labelGroup);
      };
      Handle3.prototype.renderMarker = function(container) {
        var _this = this;
        var _a = this.attributes, orientation = _a.orientation, _b = _a.markerSymbol, markerSymbol = _b === void 0 ? ifHorizontal(orientation, "horizontalHandle", "verticalHandle") : _b;
        ifShow(!!markerSymbol, container, function(group3) {
          var handleStyle = subStyleProps(_this.attributes, "marker");
          var markerStyle = __assign({ symbol: markerSymbol }, handleStyle);
          _this.marker = group3.maybeAppendByClassName(CLASS_NAMES9.marker, function() {
            return new Marker({ style: markerStyle });
          }).update(markerStyle);
        });
      };
      Handle3.prototype.renderLabel = function(container) {
        var _this = this;
        var _a = this.attributes, showLabel = _a.showLabel, orientation = _a.orientation, _b = _a.spacing, spacing = _b === void 0 ? 0 : _b, formatter2 = _a.formatter;
        ifShow(showLabel, container, function(group3) {
          var _a2;
          var _b2 = subStyleProps(_this.attributes, "label"), text = _b2.text, labelStyle = __rest(_b2, ["text"]);
          var _c = ((_a2 = group3.select(CLASS_NAMES9.marker.class)) === null || _a2 === void 0 ? void 0 : _a2.node().getBBox()) || {}, _d = _c.width, width = _d === void 0 ? 0 : _d, _e = _c.height, height = _e === void 0 ? 0 : _e;
          var _f = __read(ifHorizontal(orientation, [0, height + spacing, "center", "top"], [width + spacing, 0, "start", "middle"]), 4), x3 = _f[0], y3 = _f[1], textAlign = _f[2], textBaseline = _f[3];
          group3.maybeAppendByClassName(CLASS_NAMES9.label, "text").styles(__assign(__assign({}, labelStyle), { x: x3, y: y3, text: formatter2(text).toString(), textAlign, textBaseline }));
        });
      };
      return Handle3;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/legend/constant.js
  var LEGEND_BASE_DEFAULT_OPTIONS = {
    showTitle: true,
    padding: 0,
    orientation: "horizontal",
    backgroundFill: "transparent",
    titleText: "",
    titleSpacing: 4,
    titlePosition: "top-left",
    titleFill: "#2C3542",
    titleFontWeight: "bold",
    titleFontFamily: "sans-serif",
    titleFontSize: 12
  };
  var CATEGORY_DEFAULT_OPTIONS = deepAssign2({}, LEGEND_BASE_DEFAULT_OPTIONS, {});
  var CONTINUOUS_DEFAULT_OPTIONS = deepAssign2({}, LEGEND_BASE_DEFAULT_OPTIONS, superStyleProps(DEFAULT_HANDLE_CFG, "handle"), {
    color: [
      "#d0e3fa",
      "#acc7f6",
      "#8daaf2",
      "#6d8eea",
      "#4d73cd",
      "#325bb1",
      "#5a3e75",
      "#8c3c79",
      "#e23455",
      "#e7655b"
    ],
    indicatorBackgroundFill: "#262626",
    indicatorLabelFill: "white",
    indicatorLabelFontSize: 12,
    indicatorVisibility: "hidden",
    labelAlign: "value",
    labelDirection: "positive",
    labelSpacing: 5,
    showHandle: true,
    showIndicator: true,
    showLabel: true,
    slidable: true,
    titleText: "",
    type: "continuous"
  });
  var STEP_RATIO = 0.01;
  var CLASS_NAMES10 = classNames({
    title: "title",
    titleGroup: "title-group",
    items: "items",
    itemsGroup: "items-group",
    contentGroup: "content-group",
    ribbonGroup: "ribbon-group",
    ribbon: "ribbon",
    handlesGroup: "handles-group",
    handle: "handle",
    startHandle: "start-handle",
    endHandle: "end-handle",
    labelGroup: "label-group",
    label: "label",
    indicator: "indicator"
  }, "legend");

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/legend/category.js
  var Category = (
    /** @class */
    function(_super) {
      __extends(Category2, _super);
      function Category2(options) {
        return _super.call(this, options, CATEGORY_DEFAULT_OPTIONS) || this;
      }
      Category2.prototype.renderTitle = function(container, width, height) {
        var _a = this.attributes, showTitle = _a.showTitle, titleText = _a.titleText;
        var style = subStyleProps(this.attributes, "title");
        var _b = __read(splitStyle(style), 2), titleStyle = _b[0], groupStyle = _b[1];
        this.titleGroup = container.maybeAppendByClassName(CLASS_NAMES10.titleGroup, "g").styles(groupStyle);
        var finalTitleStyle = __assign(__assign({ width, height }, titleStyle), { text: showTitle ? titleText : "" });
        this.title = this.titleGroup.maybeAppendByClassName(CLASS_NAMES10.title, function() {
          return new Title({ style: finalTitleStyle });
        }).update(finalTitleStyle);
      };
      Category2.prototype.renderItems = function(container, bbox) {
        var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
        var style = subStyleProps(this.attributes, "title", true);
        var _a = __read(splitStyle(style), 2), partialItemStyle = _a[0], groupStyle = _a[1];
        var itemStyle = __assign(__assign({}, partialItemStyle), { width, height, x: 0, y: 0 });
        this.itemsGroup = container.maybeAppendByClassName(CLASS_NAMES10.itemsGroup, "g").styles(__assign(__assign({}, groupStyle), { transform: "translate(".concat(x3, ", ").concat(y3, ")") }));
        var that = this;
        this.itemsGroup.selectAll(CLASS_NAMES10.items.class).data(["items"]).join(function(enter) {
          return enter.append(function() {
            return new CategoryItems({ style: itemStyle });
          }).attr("className", CLASS_NAMES10.items.name).each(function() {
            that.items = select2(this);
          });
        }, function(update) {
          return update.update(itemStyle);
        }, function(exit) {
          return exit.remove();
        });
      };
      Category2.prototype.adjustLayout = function() {
        var showTitle = this.attributes.showTitle;
        if (showTitle) {
          var _a = this.title.node().getAvailableSpace(), x3 = _a.x, y3 = _a.y;
          this.itemsGroup.node().style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        }
      };
      Object.defineProperty(Category2.prototype, "availableSpace", {
        get: function() {
          var _a = this.attributes, showTitle = _a.showTitle, width = _a.width, height = _a.height;
          if (!showTitle)
            return new BBox(0, 0, width, height);
          return this.title.node().getAvailableSpace();
        },
        enumerable: false,
        configurable: true
      });
      Category2.prototype.getBBox = function() {
        var _a, _b;
        var title = (_a = this.title) === null || _a === void 0 ? void 0 : _a.node();
        var items = (_b = this.items) === null || _b === void 0 ? void 0 : _b.node();
        if (!title || !items)
          return _super.prototype.getBBox.call(this);
        return getBBox(title, items);
      };
      Category2.prototype.render = function(attributes, container) {
        var _a = this.attributes, width = _a.width, height = _a.height, _b = _a.x, x3 = _b === void 0 ? 0 : _b, _c = _a.y, y3 = _c === void 0 ? 0 : _c;
        var ctn = select2(container);
        container.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
        this.renderTitle(ctn, width, height);
        this.renderItems(ctn, this.availableSpace);
        this.adjustLayout();
      };
      return Category2;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/indicator/constant.js
  var DEFAULT_INDICATOR_STYLE_PROPS = {
    backgroundFill: "#262626",
    backgroundLineCap: "round",
    backgroundLineWidth: 1,
    backgroundStroke: "#333",
    backgroundZIndex: -1,
    formatter: function(val) {
      return val.toString();
    },
    labelFill: "#fff",
    labelFontSize: 12,
    labelTextBaseline: "middle",
    padding: [2, 4],
    position: "right",
    radius: 0,
    zIndex: 999
  };

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/indicator/indicator.js
  var CLASS_NAMES11 = classNames({
    background: "background",
    labelGroup: "label-group",
    label: "label"
  }, "indicator");
  var Indicator = (
    /** @class */
    function(_super) {
      __extends(Indicator2, _super);
      function Indicator2(options) {
        var _this = _super.call(this, options, DEFAULT_INDICATOR_STYLE_PROPS) || this;
        _this.point = [0, 0];
        _this.group = _this.appendChild(new Group2({}));
        _this.isMutationObserved = true;
        return _this;
      }
      Indicator2.prototype.renderBackground = function() {
        if (!this.label)
          return;
        var _a = this.attributes, position = _a.position, padding = _a.padding;
        var _b = __read(parseSeriesAttr(padding), 4), t = _b[0], r = _b[1], b = _b[2], l2 = _b[3];
        var _c = this.label.node().getLocalBounds(), min10 = _c.min, max10 = _c.max;
        var bbox = new BBox(min10[0] - l2, min10[1] - t, max10[0] + r - min10[0] + l2, max10[1] + b - min10[1] + t);
        var path2 = this.getPath(position, bbox);
        var style = subStyleProps(this.attributes, "background");
        this.background = select2(this.group).maybeAppendByClassName(CLASS_NAMES11.background, "path").styles(__assign(__assign({}, style), { d: path2 }));
        this.group.appendChild(this.label.node());
      };
      Indicator2.prototype.renderLabel = function() {
        var _a = this.attributes, formatter2 = _a.formatter, labelText = _a.labelText;
        var style = subStyleProps(this.attributes, "label");
        var _b = __read(splitStyle(style), 2), _c = _b[0], groupStyle = _b[1], rawText = _c.text, textStyle = __rest(_c, ["text"]);
        this.label = select2(this.group).maybeAppendByClassName(CLASS_NAMES11.labelGroup, "g").styles(groupStyle);
        if (!labelText)
          return;
        var text = this.label.maybeAppendByClassName(CLASS_NAMES11.label, function() {
          return renderExtDo(formatter2(labelText));
        }).style("text", formatter2(labelText).toString());
        text.selectAll("text").styles(textStyle);
      };
      Indicator2.prototype.adjustLayout = function() {
        var _a = __read(this.point, 2), dx = _a[0], dy = _a[1];
        var _b = this.attributes, x3 = _b.x, y3 = _b.y;
        this.group.attr("transform", "translate(".concat(x3 - dx, ", ").concat(y3 - dy, ")"));
      };
      Indicator2.prototype.getPath = function(position, bbox) {
        var r = this.attributes.radius;
        var x3 = bbox.x, y3 = bbox.y, width = bbox.width, height = bbox.height;
        var pathArray = [
          // 0 开始路径
          ["M", x3 + r, y3],
          // 1 上边线
          ["L", x3 + width - r, y3],
          // 2 右上角圆弧
          ["A", r, r, 0, 0, 1, x3 + width, y3 + r],
          // 3 右边线
          ["L", x3 + width, y3 + height - r],
          // 4 右下角圆弧
          ["A", r, r, 0, 0, 1, x3 + width - r, y3 + height],
          // 5 下边线
          ["L", x3 + r, y3 + height],
          // 6 左下角圆弧
          ["A", r, r, 0, 0, 1, x3, y3 + height - r],
          // 7 左边线
          ["L", x3, y3 + r],
          // 8 左上角圆弧
          ["A", r, r, 0, 0, 1, x3 + r, y3],
          // 9 关闭路径
          ["Z"]
        ];
        var revertPositionMap = { top: 4, right: 6, bottom: 0, left: 2 };
        var index4 = revertPositionMap[position];
        var newPath = this.createCorner([pathArray[index4].slice(-2), pathArray[index4 + 1].slice(-2)]);
        pathArray.splice.apply(pathArray, __spreadArray([index4 + 1, 1], __read(newPath), false));
        pathArray[0][0] = "M";
        return pathArray;
      };
      Indicator2.prototype.createCorner = function(edge, size2) {
        if (size2 === void 0) {
          size2 = 10;
        }
        var cornerScale = 0.8;
        var isH = isHorizontal.apply(void 0, __spreadArray([], __read(edge), false));
        var _a = __read(edge, 2), _b = __read(_a[0], 2), x05 = _b[0], y05 = _b[1], _c = __read(_a[1], 2), x12 = _c[0], y12 = _c[1];
        var _d = __read(isH ? [x12 - x05, [x05, x12]] : [y12 - y05, [y05, y12]], 2), len5 = _d[0], _e = __read(_d[1], 2), b0 = _e[0], b1 = _e[1];
        var hL = len5 / 2;
        var sign3 = len5 / Math.abs(len5);
        var cL = size2 * sign3;
        var hCL = cL / 2;
        var cS = cL * Math.sqrt(3) / 2 * cornerScale;
        var _f = __read([b0, b0 + hL - hCL, b0 + hL, b0 + hL + hCL, b1], 5), a0 = _f[0], a1 = _f[1], a22 = _f[2], a3 = _f[3], a4 = _f[4];
        if (isH) {
          this.point = [a22, y05 - cS];
          return [
            ["L", a0, y05],
            ["L", a1, y05],
            ["L", a22, y05 - cS],
            ["L", a3, y05],
            ["L", a4, y05]
          ];
        }
        this.point = [x05 + cS, a22];
        return [
          ["L", x05, a0],
          ["L", x05, a1],
          ["L", x05 + cS, a22],
          ["L", x05, a3],
          ["L", x05, a4]
        ];
      };
      Indicator2.prototype.applyVisibility = function() {
        var visibility2 = this.attributes.visibility;
        if (visibility2 === "hidden")
          hide(this);
        else
          show(this);
      };
      Indicator2.prototype.bindEvents = function() {
        this.label.on(ElementEvent.BOUNDS_CHANGED, this.renderBackground);
      };
      Indicator2.prototype.render = function() {
        this.renderLabel();
        this.renderBackground();
        this.adjustLayout();
        this.applyVisibility();
      };
      return Indicator2;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/legend/continuous/utils.js
  function search(array2, value2) {
    for (var i = 1; i < array2.length; i += 1) {
      var st = array2[i - 1];
      var end = array2[i];
      if (value2 >= st && value2 <= end) {
        return [st, end];
      }
    }
    return [value2, value2];
  }
  function getBlockColor(partition, color2, orientation) {
    var colors = Array.from(color2);
    var count4 = partition.length;
    return new Array(count4).fill(0).reduce(function(r, v, idx) {
      var c5 = colors[idx % colors.length];
      return r += " ".concat(partition[idx], ":").concat(c5).concat(idx < count4 - 1 ? " ".concat(partition[idx + 1], ":").concat(c5) : "");
    }, "l(".concat(orientation === "horizontal" ? "0" : "270", ")"));
  }
  function getNextTickValue(ticks2, value2) {
    var _a = __read(search(ticks2, value2), 2), v1 = _a[0], v2 = _a[1];
    return { tick: value2 > (v1 + v2) / 2 ? v2 : v1, range: [v1, v2] };
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/legend/continuous/ribbon.js
  var CLASS_NAMES12 = classNames({
    trackGroup: "background-group",
    track: "background",
    selectionGroup: "ribbon-group",
    selection: "ribbon",
    clipPath: "clip-path"
  }, "ribbon");
  function getShape(attr2) {
    var orientation = attr2.orientation, size2 = attr2.size, length5 = attr2.length;
    return ifHorizontal(orientation, [length5, size2], [size2, length5]);
  }
  function getTrackPath(attr2) {
    var type = attr2.type;
    var _a = __read(getShape(attr2), 2), cw2 = _a[0], ch2 = _a[1];
    if (type === "size") {
      return [["M", 0, ch2], ["L", 0 + cw2, 0], ["L", 0 + cw2, ch2], ["Z"]];
    }
    return [["M", 0, ch2], ["L", 0, 0], ["L", 0 + cw2, 0], ["L", 0 + cw2, ch2], ["Z"]];
  }
  function getSelectionPath(attr2) {
    return getTrackPath(attr2);
  }
  function getColor(attr2) {
    var orientation = attr2.orientation, color2 = attr2.color, block = attr2.block, partition = attr2.partition;
    var colors;
    if (is_function_default2(color2)) {
      var len5 = 20;
      colors = new Array(len5).fill(0).map(function(_2, index4, arr) {
        return color2(index4 / (arr.length - 1));
      });
    } else
      colors = color2;
    var count4 = colors.length;
    var genericColor = colors.map(function(c5) {
      return parseColor(c5).toString();
    });
    if (!count4)
      return "";
    if (count4 === 1)
      return genericColor[0];
    if (block)
      return getBlockColor(partition, genericColor, orientation);
    return genericColor.reduce(function(r, c5, idx) {
      return r += " ".concat(idx / (count4 - 1), ":").concat(c5);
    }, "l(".concat(ifHorizontal(orientation, "0", "270"), ")"));
  }
  function getClipPath(attr2) {
    var orientation = attr2.orientation, range3 = attr2.range;
    if (!range3)
      return [];
    var _a = __read(getShape(attr2), 2), width = _a[0], height = _a[1];
    var _b = __read(range3, 2), st = _b[0], et = _b[1];
    var x3 = ifHorizontal(orientation, st * width, 0);
    var y3 = ifHorizontal(orientation, 0, st * height);
    var w = ifHorizontal(orientation, et * width, width);
    var h = ifHorizontal(orientation, height, et * height);
    return [["M", x3, y3], ["L", x3, h], ["L", w, h], ["L", w, y3], ["Z"]];
  }
  function renderTrack(container, attr2) {
    var style = subStyleProps(attr2, "track");
    container.maybeAppendByClassName(CLASS_NAMES12.track, "path").styles(__assign({ d: getTrackPath(attr2) }, style));
  }
  function renderSelection(container, attr2) {
    var style = subStyleProps(attr2, "selection");
    var fill = getColor(attr2);
    var ribbon = container.maybeAppendByClassName(CLASS_NAMES12.selection, "path").styles(__assign({ d: getSelectionPath(attr2), fill }, style));
    var clipPath = ribbon.maybeAppendByClassName(CLASS_NAMES12.clipPath, "path").styles({ d: getClipPath(attr2) }).node();
    ribbon.style("clipPath", clipPath);
  }
  var Ribbon = (
    /** @class */
    function(_super) {
      __extends(Ribbon3, _super);
      function Ribbon3(options) {
        return _super.call(this, options, {
          type: "color",
          orientation: "horizontal",
          size: 30,
          range: [0, 1],
          length: 200,
          block: false,
          partition: [],
          color: ["#fff", "#000"],
          trackFill: "#e5e5e5"
        }) || this;
      }
      Ribbon3.prototype.render = function(attribute, container) {
        var trackGroup = select2(container).maybeAppendByClassName(CLASS_NAMES12.trackGroup, "g");
        renderTrack(trackGroup, attribute);
        var ribbonGroup = select2(container).maybeAppendByClassName(CLASS_NAMES12.selectionGroup, "g");
        renderSelection(ribbonGroup, attribute);
      };
      return Ribbon3;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/legend/continuous.js
  function getMinMax(data2) {
    return {
      min: Math.min.apply(Math, __spreadArray([], __read(data2.map(function(d2) {
        return d2.value;
      })), false)),
      max: Math.max.apply(Math, __spreadArray([], __read(data2.map(function(d2) {
        return d2.value;
      })), false))
    };
  }
  var Continuous3 = (
    /** @class */
    function(_super) {
      __extends(Continuous4, _super);
      function Continuous4(options) {
        var _this = _super.call(this, options, CONTINUOUS_DEFAULT_OPTIONS) || this;
        _this.eventToOffsetScale = new Linear3({});
        _this.innerRibbonScale = new Linear3({});
        _this.cacheLabelBBox = null;
        _this.cacheHandleBBox = null;
        _this.onHovering = function(e3) {
          var _a = _this.attributes, data2 = _a.data, block = _a.block;
          e3.stopPropagation();
          var value2 = _this.getValueByCanvasPoint(e3);
          if (block) {
            var range3 = getNextTickValue(data2.map(function(_a2) {
              var value3 = _a2.value;
              return value3;
            }), value2).range;
            var selection = _this.getRealSelection(range3);
            _this.showIndicator((range3[0] + range3[1]) / 2, "".concat(selection[0], "-").concat(selection[1]));
            _this.dispatchIndicated(value2, range3);
          } else {
            var safetyValue = _this.getTickValue(value2);
            _this.showIndicator(safetyValue, "".concat(_this.getRealValue(safetyValue)));
            _this.dispatchIndicated(safetyValue);
          }
        };
        _this.onDragStart = function(target) {
          return function(e3) {
            e3.stopPropagation();
            if (!_this.attributes.slidable)
              return;
            _this.target = target;
            _this.prevValue = _this.getTickValue(_this.getValueByCanvasPoint(e3));
            document.addEventListener("mousemove", _this.onDragging);
            document.addEventListener("touchmove", _this.onDragging);
            document.addEventListener("mouseleave", _this.onDragEnd);
            document.addEventListener("mouseup", _this.onDragEnd);
            document.addEventListener("mouseup", _this.onDragEnd);
            document.addEventListener("touchend", _this.onDragEnd);
          };
        };
        _this.onDragging = function(e3) {
          var target = _this.target;
          _this.updateMouse();
          var _a = __read(_this.selection, 2), start2 = _a[0], end = _a[1];
          var currValue = _this.getTickValue(_this.getValueByCanvasPoint(e3));
          var diffValue = currValue - _this.prevValue;
          if (target === "start")
            start2 !== currValue && _this.updateSelection(currValue, end);
          else if (target === "end")
            end !== currValue && _this.updateSelection(start2, currValue);
          else if (target === "ribbon" && diffValue !== 0) {
            _this.prevValue = currValue;
            _this.updateSelection(diffValue, diffValue, true);
          }
        };
        _this.onDragEnd = function() {
          _this.style.cursor = "pointer";
          document.removeEventListener("mousemove", _this.onDragging);
          document.removeEventListener("touchmove", _this.onDragging);
          document.removeEventListener("mouseup", _this.onDragEnd);
          document.removeEventListener("touchend", _this.onDragEnd);
        };
        return _this;
      }
      Object.defineProperty(Continuous4.prototype, "handleOffsetRatio", {
        get: function() {
          return this.ifHorizontal(0.5, 0.5);
        },
        enumerable: false,
        configurable: true
      });
      Continuous4.prototype.getBBox = function() {
        var _a = this.attributes, width = _a.width, height = _a.height;
        return new BBox(0, 0, width, height);
      };
      Continuous4.prototype.render = function(attributes, container) {
        var _this = this;
        var showLabel = attributes.showLabel;
        this.renderTitle(select2(container));
        var _a = this.availableSpace, x3 = _a.x, y3 = _a.y;
        var contentGroup = select2(container).maybeAppendByClassName(CLASS_NAMES10.contentGroup, "g").styles({ transform: "translate(".concat(x3, ", ").concat(y3, ")") });
        var labelGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.labelGroup, "g").styles({ zIndex: 1 });
        ifShow(!!showLabel, labelGroup, function(group3) {
          _this.renderLabel(group3);
        });
        var ribbonGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.ribbonGroup, "g").styles({ zIndex: 0 });
        this.handlesGroup = contentGroup.maybeAppendByClassName(CLASS_NAMES10.handlesGroup, "g").styles({ zIndex: 2 });
        this.renderHandles();
        this.renderRibbon(ribbonGroup);
        this.renderIndicator(contentGroup);
        this.adjustLabel();
        this.adjustHandles();
      };
      Object.defineProperty(Continuous4.prototype, "range", {
        get: function() {
          var _a = this.attributes, data2 = _a.data, domain = _a.domain;
          return domain ? { min: domain[0], max: domain[1] } : getMinMax(data2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous4.prototype, "ribbonScale", {
        get: function() {
          var _a = this.range, min10 = _a.min, max10 = _a.max;
          this.innerRibbonScale.update({
            domain: [min10, max10],
            range: [0, 1]
          });
          return this.innerRibbonScale;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous4.prototype, "ribbonRange", {
        get: function() {
          var _a = __read(this.selection, 2), min10 = _a[0], max10 = _a[1];
          var scale9 = this.ribbonScale;
          return [scale9.map(min10), scale9.map(max10)];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous4.prototype, "selection", {
        get: function() {
          var _a = this.range, min10 = _a.min, max10 = _a.max;
          var _b = this.attributes.defaultValue, _c = _b === void 0 ? [min10, max10] : _b, _d = __read(_c, 2), start2 = _d[0], end = _d[1];
          return [start2, end];
        },
        enumerable: false,
        configurable: true
      });
      Continuous4.prototype.ifHorizontal = function(a3, b) {
        return ifHorizontal(this.attributes.orientation, typeof a3 === "function" ? a3() : a3, typeof b === "function" ? b() : b);
      };
      Continuous4.prototype.renderTitle = function(container) {
        var _a = this.attributes, showTitle = _a.showTitle, titleText = _a.titleText, width = _a.width, height = _a.height;
        var style = subStyleProps(this.attributes, "title");
        var finalTitleStyle = __assign(__assign({}, style), { width, height, text: titleText });
        var that = this;
        container.selectAll(CLASS_NAMES10.title.class).data(showTitle ? [titleText] : []).join(function(enter) {
          return enter.append(function() {
            return new Title({ style: finalTitleStyle });
          }).attr("className", CLASS_NAMES10.title.name).each(function() {
            that.title = this;
          });
        }, function(update) {
          return update.update(finalTitleStyle);
        }, function(exit) {
          return exit.each(function() {
            that.title = void 0;
          }).remove();
        });
      };
      Object.defineProperty(Continuous4.prototype, "availableSpace", {
        get: function() {
          if (this.title)
            return this.title.getAvailableSpace();
          var _a = this.attributes, width = _a.width, height = _a.height;
          return new BBox(0, 0, width, height);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous4.prototype, "labelFixedSpacing", {
        get: function() {
          var showTick = this.attributes.showTick;
          return showTick ? 5 : 0;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous4.prototype, "labelPosition", {
        get: function() {
          var _a = this.attributes, orientation = _a.orientation, labelDirection = _a.labelDirection;
          var positions = {
            vertical: { positive: "right", negative: "left" },
            horizontal: { positive: "bottom", negative: "top" }
          };
          return positions[orientation][labelDirection];
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous4.prototype, "labelBBox", {
        get: function() {
          var _a;
          var showLabel = this.attributes.showLabel;
          if (!showLabel)
            return new BBox(0, 0, 0, 0);
          if (this.cacheLabelBBox)
            return this.cacheLabelBBox;
          var _b = ((_a = this.label.querySelector(CLASS_NAMES3.labelGroup.class)) === null || _a === void 0 ? void 0 : _a.children.slice(-1)[0]).getBBox(), width = _b.width, height = _b.height;
          this.cacheLabelBBox = new BBox(0, 0, width, height);
          return this.cacheLabelBBox;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous4.prototype, "labelShape", {
        get: function() {
          var _a = this.attributes, showLabel = _a.showLabel, _b = _a.labelSpacing, labelSpacing = _b === void 0 ? 0 : _b;
          if (!showLabel)
            return { width: 0, height: 0, size: 0, length: 0 };
          var _c = this.labelBBox, width = _c.width, height = _c.height;
          var size2 = this.ifHorizontal(height, width) + labelSpacing + this.labelFixedSpacing;
          var length5 = this.ifHorizontal(width, height);
          return { width, height, size: size2, length: length5 };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous4.prototype, "ribbonBBox", {
        get: function() {
          var _a = this.attributes, showHandle = _a.showHandle, userDefinedRibbonSize = _a.ribbonSize;
          var _b = this.availableSpace, availableWidth = _b.width, availableHeight = _b.height;
          var _c = this.labelShape, labelSize = _c.size, labelLength = _c.length;
          var _d = __read(this.ifHorizontal([availableHeight, availableWidth], [availableWidth, availableHeight]), 2), availableSize = _d[0], availableLength = _d[1];
          var _e = showHandle ? this.handleShape : { size: 0, length: 0 }, handleSize = _e.size, handleLength = _e.length;
          var handleRatio = this.handleOffsetRatio;
          var ribbonSize = 0;
          var labelPosition = this.labelPosition;
          if (userDefinedRibbonSize) {
            ribbonSize = userDefinedRibbonSize;
          } else if (["bottom", "right"].includes(labelPosition)) {
            ribbonSize = Math.min(availableSize - labelSize, (availableSize - handleSize) / handleRatio);
          } else if (availableSize * (1 - handleRatio) > handleSize) {
            ribbonSize = Math.max(availableSize - labelSize, 0);
          } else
            ribbonSize = Math.max((availableSize - labelSize - handleSize) / handleRatio, 0);
          var edgeLength = Math.max(handleLength, labelLength);
          var ribbonLength = availableLength - edgeLength;
          var _f = __read(this.ifHorizontal([ribbonLength, ribbonSize], [ribbonSize, ribbonLength]), 2), width = _f[0], height = _f[1];
          var finalLabelOccupy = ["top", "left"].includes(labelPosition) ? labelSize : 0;
          var _g = __read(this.ifHorizontal([edgeLength / 2, finalLabelOccupy], [finalLabelOccupy, edgeLength / 2]), 2), x3 = _g[0], y3 = _g[1];
          return new BBox(x3, y3, width, height);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous4.prototype, "ribbonShape", {
        get: function() {
          var _a = this.ribbonBBox, width = _a.width, height = _a.height;
          return this.ifHorizontal({ size: height, length: width }, { size: width, length: height });
        },
        enumerable: false,
        configurable: true
      });
      Continuous4.prototype.renderRibbon = function(container) {
        var _a = this.attributes, data2 = _a.data, type = _a.type, orientation = _a.orientation, color2 = _a.color, block = _a.block;
        var ribbonStyle = subStyleProps(this.attributes, "ribbon");
        var _b = this.range, min10 = _b.min, max10 = _b.max;
        var _c = this.ribbonBBox, x3 = _c.x, y3 = _c.y;
        var _d = this.ribbonShape, length5 = _d.length, size2 = _d.size;
        var style = deepAssign2({
          transform: "translate(".concat(x3, ", ").concat(y3, ")"),
          length: length5,
          size: size2,
          type,
          orientation,
          color: color2,
          block,
          partition: data2.map(function(d2) {
            return (d2.value - min10) / (max10 - min10);
          }),
          range: this.ribbonRange
        }, ribbonStyle);
        this.ribbon = container.maybeAppendByClassName(CLASS_NAMES10.ribbon, function() {
          return new Ribbon({ style });
        }).update(style);
      };
      Continuous4.prototype.getHandleClassName = function(type) {
        return "".concat(CLASS_NAMES10.prefix("".concat(type, "-handle")));
      };
      Continuous4.prototype.renderHandles = function() {
        var _a = this.attributes, showHandle = _a.showHandle, orientation = _a.orientation;
        var handleStyle = subStyleProps(this.attributes, "handle");
        var _b = __read(this.selection, 2), min10 = _b[0], max10 = _b[1];
        var style = __assign(__assign({}, handleStyle), { orientation });
        var _c = handleStyle.shape, shape23 = _c === void 0 ? "slider" : _c;
        var HandleCtor = shape23 === "basic" ? Handle2 : Handle;
        var that = this;
        this.handlesGroup.selectAll(CLASS_NAMES10.handle.class).data(showHandle ? [
          { value: min10, type: "start" },
          { value: max10, type: "end" }
        ] : [], function(d2) {
          return d2.type;
        }).join(function(enter) {
          return enter.append(function() {
            return new HandleCtor({ style });
          }).attr("className", function(_a2) {
            var type = _a2.type;
            return "".concat(CLASS_NAMES10.handle, " ").concat(that.getHandleClassName(type));
          }).each(function(_a2) {
            var type = _a2.type, labelText = _a2.value;
            this.update({ labelText });
            var name2 = "".concat(type, "Handle");
            that[name2] = this;
            this.addEventListener("pointerdown", that.onDragStart(type));
          });
        }, function(update) {
          return update.update(style).each(function(_a2) {
            var labelText = _a2.value;
            this.update({ labelText });
          });
        }, function(exit) {
          return exit.each(function(_a2) {
            var type = _a2.type;
            var name2 = "".concat(type, "Handle");
            that[name2] = void 0;
          }).remove();
        });
      };
      Continuous4.prototype.adjustHandles = function() {
        var _a = __read(this.selection, 2), min10 = _a[0], max10 = _a[1];
        this.setHandlePosition("start", min10);
        this.setHandlePosition("end", max10);
      };
      Object.defineProperty(Continuous4.prototype, "handleBBox", {
        get: function() {
          if (this.cacheHandleBBox)
            return this.cacheHandleBBox;
          if (!this.attributes.showHandle)
            return new BBox(0, 0, 0, 0);
          var _a = this.startHandle.getBBox(), startHandleWidth = _a.width, startHandleHeight = _a.height;
          var _b = this.endHandle.getBBox(), endHandleWidth = _b.width, endHandleHeight = _b.height;
          var _c = __read([Math.max(startHandleWidth, endHandleWidth), Math.max(startHandleHeight, endHandleHeight)], 2), width = _c[0], height = _c[1];
          this.cacheHandleBBox = new BBox(0, 0, width, height);
          return this.cacheHandleBBox;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous4.prototype, "handleShape", {
        /**
         *  因为 handle label 的宽高是动态的，所以 handle bbox 是第一次渲染时的 bbox
         */
        get: function() {
          var _a = this.handleBBox, width = _a.width, height = _a.height;
          var _b = __read(this.ifHorizontal([height, width], [width, height]), 2), size2 = _b[0], length5 = _b[1];
          return { width, height, size: size2, length: length5 };
        },
        enumerable: false,
        configurable: true
      });
      Continuous4.prototype.setHandlePosition = function(type, value2) {
        var handleFormatter = this.attributes.handleFormatter;
        var _a = this.ribbonBBox, ribbonX = _a.x, ribbonY = _a.y;
        var ribbonSize = this.ribbonShape.size;
        var offset3 = this.getOffset(value2);
        var _b = __read(this.ifHorizontal([ribbonX + offset3, ribbonY + ribbonSize * this.handleOffsetRatio], [ribbonX + ribbonSize * this.handleOffsetRatio, ribbonY + offset3]), 2), x3 = _b[0], y3 = _b[1];
        var handle = this.handlesGroup.select(".".concat(this.getHandleClassName(type))).node();
        handle === null || handle === void 0 ? void 0 : handle.update({ transform: "translate(".concat(x3, ", ").concat(y3, ")"), formatter: handleFormatter });
      };
      Continuous4.prototype.renderIndicator = function(container) {
        var style = subStyleProps(this.attributes, "indicator");
        this.indicator = container.maybeAppendByClassName(CLASS_NAMES10.indicator, function() {
          return new Indicator({});
        }).update(style);
      };
      Object.defineProperty(Continuous4.prototype, "labelData", {
        get: function() {
          var _this = this;
          var data2 = this.attributes.data;
          return data2.reduce(function(acc, curr, index4, arr) {
            var _a, _b;
            var id4 = (_a = curr === null || curr === void 0 ? void 0 : curr.id) !== null && _a !== void 0 ? _a : index4.toString();
            acc.push(__assign(__assign({}, curr), { id: id4, index: index4, type: "value", label: (_b = curr === null || curr === void 0 ? void 0 : curr.label) !== null && _b !== void 0 ? _b : curr.value.toString(), value: _this.ribbonScale.map(curr.value) }));
            if (index4 < arr.length - 1) {
              var next = arr[index4 + 1];
              var _c = __read([curr.value, next.value], 2), cr = _c[0], nx = _c[1];
              var midVal = (cr + nx) / 2;
              acc.push(__assign(__assign({}, curr), { id: id4, index: index4, type: "range", range: [cr, nx], label: [cr, nx].join("~"), value: _this.ribbonScale.map(midVal) }));
            }
            return acc;
          }, []);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Continuous4.prototype, "labelStyle", {
        get: function() {
          var _a = __read(["center", "middle"], 2), labelTextAlign = _a[0], labelTextBaseline = _a[1];
          var labelPosition = this.labelPosition;
          if (labelPosition === "top")
            labelTextBaseline = "bottom";
          else if (labelPosition === "bottom")
            labelTextBaseline = "top";
          else if (labelPosition === "left")
            labelTextAlign = "end";
          else if (labelPosition === "right")
            labelTextAlign = "start";
          return {
            labelTextAlign,
            labelTextBaseline
          };
        },
        enumerable: false,
        configurable: true
      });
      Continuous4.prototype.renderLabel = function(container) {
        var _a = this.attributes, _b = _a.showTick, showTick = _b === void 0 ? false : _b, labelFilter = _a.labelFilter, labelFormatter = _a.labelFormatter;
        var tickStyle = subStyleProps(this.attributes, "tick");
        var labelStyle = subStyleProps(this.attributes, "label");
        var align = labelStyle.align;
        var style = deepAssign2(__assign({ showLine: false, showGrid: false, showTick, type: "linear", startPos: [0, 0], endPos: [0, 0], tickDirection: "negative", labelTransform: "rotate(0)" }, this.labelStyle), superStyleProps(tickStyle, "tick"), superStyleProps(labelStyle, "label"), { data: this.labelData });
        var functionStyle = {
          tickFilter: function(datum, index4, data2) {
            if ((datum === null || datum === void 0 ? void 0 : datum.type) !== "value")
              return false;
            if (labelFilter)
              return labelFilter(datum, datum.index, data2.filter(function(d2) {
                return d2.type !== "value";
              }));
            return true;
          },
          labelFilter: function(datum, index4, data2) {
            if ((datum === null || datum === void 0 ? void 0 : datum.type) !== align)
              return false;
            if (labelFilter)
              return labelFilter(datum, datum.index, data2.filter(function(d2) {
                return d2.type === align;
              }));
            return true;
          },
          labelFormatter
        };
        var finalLabelStyle = __assign(__assign(__assign({}, style), functionStyle), { labelOverlap: [{ type: "hide" }] });
        this.label = container.maybeAppendByClassName(CLASS_NAMES10.label, function() {
          return new Axis({ style: finalLabelStyle });
        }).node();
        this.label.update(finalLabelStyle, false);
      };
      Object.defineProperty(Continuous4.prototype, "labelAxisStyle", {
        get: function() {
          var _a = this.attributes, showTick = _a.showTick, labelDirection = _a.labelDirection, labelSpacing = _a.labelSpacing, definedTickLength = _a.tickLength;
          var ribbonSize = this.ribbonShape.size;
          var labelPosition = this.labelPosition;
          var labelFixedSpacing = this.labelFixedSpacing;
          var _b = __read([0, 0, 0], 3), offset3 = _b[0], spacing = _b[1], tickLength = _b[2];
          var internalVal = definedTickLength !== null && definedTickLength !== void 0 ? definedTickLength : ribbonSize;
          if (showTick) {
            tickLength = internalVal;
            spacing = labelFixedSpacing;
            if (labelDirection === "positive") {
              if (labelPosition === "right") {
                offset3 = internalVal;
                tickLength = internalVal;
              } else if (labelPosition === "bottom")
                offset3 = tickLength;
            } else if (labelDirection === "negative") {
              if (labelPosition === "top")
                offset3 = ribbonSize;
              else if (labelPosition === "left")
                offset3 = ribbonSize;
            }
          } else if (labelDirection === "positive") {
            if (labelPosition === "right")
              spacing = internalVal;
            else if (labelPosition === "bottom") {
              offset3 = ribbonSize + labelFixedSpacing;
              spacing = labelSpacing;
            }
          } else if (labelDirection === "negative") {
            if (labelPosition === "left")
              spacing = labelSpacing;
            else if (labelPosition === "top")
              spacing = labelSpacing;
          }
          return { offset: offset3, spacing, tickLength };
        },
        enumerable: false,
        configurable: true
      });
      Continuous4.prototype.adjustLabel = function() {
        var showLabel = this.attributes.showLabel;
        if (!showLabel)
          return;
        var _a = this.ribbonBBox, x3 = _a.x, y3 = _a.y, width = _a.width, height = _a.height;
        var _b = this.labelAxisStyle, axisOffset = _b.offset, axisSpacing = _b.spacing, axisTickLength = _b.tickLength;
        var _c = __read(this.ifHorizontal([
          [x3, y3 + axisOffset],
          [x3 + width, y3 + axisOffset]
        ], [
          [x3 + axisOffset, y3 + height],
          [x3 + axisOffset, y3]
        ]), 2), startPos = _c[0], endPos = _c[1];
        this.label.update({
          startPos,
          endPos,
          tickLength: axisTickLength,
          labelSpacing: axisSpacing
        }, false);
      };
      Continuous4.prototype.bindEvents = function() {
        this.style.cursor = "pointer";
        this.ribbon.on("pointerdown", this.onDragStart("ribbon"));
        this.ribbon.on("pointermove", this.onHovering);
        this.addEventListener("pointerout", this.hideIndicator);
      };
      Continuous4.prototype.showIndicator = function(value2, text) {
        if (text === void 0) {
          text = "".concat(value2);
        }
        var showIndicator = this.attributes.showIndicator;
        if (!showIndicator || typeof value2 !== "number") {
          this.hideIndicator();
          return;
        }
        var _a = this.range, min10 = _a.min, max10 = _a.max;
        var _b = this.ribbonBBox, x3 = _b.x, y3 = _b.y;
        var safeValue = clamp_default3(value2, min10, max10);
        var offset3 = this.getOffset(safeValue);
        var pos = this.ifHorizontal([offset3 + x3, y3], [x3, offset3 + y3]);
        this.indicator.update({
          x: pos[0],
          y: pos[1],
          position: this.ifHorizontal("top", "left"),
          labelText: text
        });
        show(this.indicator.node());
      };
      Continuous4.prototype.hideIndicator = function() {
        hide(this.indicator.node());
      };
      Continuous4.prototype.updateMouse = function() {
        if (this.attributes.slidable)
          this.style.cursor = "grabbing";
      };
      Continuous4.prototype.setSelection = function(start2, end) {
        this.updateSelection(start2, end);
      };
      Continuous4.prototype.updateSelection = function(stVal, endVal, isOffset) {
        var _a;
        if (isOffset === void 0) {
          isOffset = false;
        }
        var _b = __read(this.selection, 2), currSt = _b[0], currEnd = _b[1];
        var _c = __read([stVal, endVal], 2), start2 = _c[0], end = _c[1];
        if (isOffset) {
          start2 += currSt;
          end += currEnd;
        }
        var _d = this.range, min10 = _d.min, max10 = _d.max;
        _a = __read(getSafetySelections([min10, max10], [start2, end], this.selection), 2), start2 = _a[0], end = _a[1];
        this.update({ defaultValue: [start2, end] });
        this.dispatchSelection();
      };
      Object.defineProperty(Continuous4.prototype, "step", {
        get: function() {
          var _a = this.attributes.step, step2 = _a === void 0 ? 1 : _a;
          var _b = this.range, min10 = _b.min, max10 = _b.max;
          if (is_undefined_default3(step2))
            return toPrecision((max10 - min10) * STEP_RATIO, 0);
          return step2;
        },
        enumerable: false,
        configurable: true
      });
      Continuous4.prototype.getTickValue = function(value2) {
        var _a = this.attributes, data2 = _a.data, block = _a.block;
        var min10 = this.range.min;
        if (block)
          return getNextTickValue(data2.map(function(_a2) {
            var value3 = _a2.value;
            return value3;
          }), value2).tick;
        return getStepValueByValue(value2, this.step, min10);
      };
      Continuous4.prototype.getValueByCanvasPoint = function(e3) {
        var _a = this.range, min10 = _a.min, max10 = _a.max;
        var _b = __read(this.ribbon.node().getPosition(), 2), x3 = _b[0], y3 = _b[1];
        var startPos = this.ifHorizontal(x3, y3);
        var currValue = this.ifHorizontal.apply(this, __spreadArray([], __read(getEventPos(e3)), false));
        var offset3 = currValue - startPos;
        var value2 = clamp_default3(this.getOffset(offset3, true), min10, max10);
        return value2;
      };
      Continuous4.prototype.getOffset = function(value2, reverse) {
        if (reverse === void 0) {
          reverse = false;
        }
        var _a = this.range, min10 = _a.min, max10 = _a.max;
        var ribbonLen = this.ribbonShape.length;
        var scale9 = this.eventToOffsetScale;
        scale9.update({ domain: [min10, max10], range: [0, ribbonLen] });
        if (reverse)
          return scale9.invert(value2);
        return scale9.map(value2);
      };
      Continuous4.prototype.getRealSelection = function(range3) {
        var max10 = this.range.max;
        var _a = __read(range3, 2), start2 = _a[0], end = _a[1];
        return this.ifHorizontal([start2, end], [max10 - end, max10 - start2]);
      };
      Continuous4.prototype.getRealValue = function(value2) {
        var max10 = this.range.max;
        return this.ifHorizontal(value2, max10 - value2);
      };
      Continuous4.prototype.dispatchSelection = function() {
        var selection = this.getRealSelection(this.selection);
        var evt = new CustomEvent2("valuechange", {
          detail: {
            value: selection
          }
        });
        this.dispatchEvent(evt);
      };
      Continuous4.prototype.dispatchIndicated = function(value2, range3) {
        var _this = this;
        var max10 = this.range.max;
        var detail = this.ifHorizontal(function() {
          return {
            value: value2,
            range: range3
          };
        }, function() {
          return {
            value: max10 - value2,
            range: range3 ? _this.getRealSelection(range3) : void 0
          };
        });
        var evt = new CustomEvent2("indicate", {
          detail
        });
        this.dispatchEvent(evt);
      };
      return Continuous4;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/tooltip/constant.js
  function getClassNames(prefixCls) {
    if (prefixCls === void 0) {
      prefixCls = "";
    }
    return {
      CONTAINER: "".concat(prefixCls, "tooltip"),
      TITLE: "".concat(prefixCls, "tooltip-title"),
      LIST: "".concat(prefixCls, "tooltip-list"),
      LIST_ITEM: "".concat(prefixCls, "tooltip-list-item"),
      NAME: "".concat(prefixCls, "tooltip-list-item-name"),
      MARKER: "".concat(prefixCls, "tooltip-list-item-marker"),
      NAME_LABEL: "".concat(prefixCls, "tooltip-list-item-name-label"),
      VALUE: "".concat(prefixCls, "tooltip-list-item-value"),
      CROSSHAIR_X: "".concat(prefixCls, "tooltip-crosshair-x"),
      CROSSHAIR_Y: "".concat(prefixCls, "tooltip-crosshair-y")
    };
  }
  var TEXT_OVERFLOW_STYLE = {
    overflow: "hidden",
    "white-space": "nowrap",
    "text-overflow": "ellipsis"
  };
  function getDefaultTooltipStyle(prefixCls) {
    var _a;
    if (prefixCls === void 0) {
      prefixCls = "";
    }
    var CLASS_NAME = getClassNames(prefixCls);
    return _a = {}, _a[".".concat(CLASS_NAME.CONTAINER)] = {
      position: "absolute",
      visibility: "visible",
      // 'white-space': 'nowrap',
      "z-index": 8,
      transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
      "background-color": "rgba(255, 255, 255, 0.96)",
      "box-shadow": "0 6px 12px 0 rgba(0, 0, 0, 0.12)",
      "border-radius": "4px",
      color: "rgba(0, 0, 0, 0.65)",
      "font-size": "12px",
      // 'font-family': ,
      "line-height": "20px",
      padding: "12px",
      "min-width": "120px",
      "max-width": "360px",
      "font-family": "Roboto-Regular"
    }, _a[".".concat(CLASS_NAME.TITLE)] = {
      color: "rgba(0, 0, 0, 0.45)"
    }, _a[".".concat(CLASS_NAME.LIST)] = {
      margin: "0px",
      "list-style-type": "none",
      padding: "0px"
    }, _a[".".concat(CLASS_NAME.LIST_ITEM)] = {
      "list-style-type": "none",
      display: "flex",
      "line-height": "2em",
      "align-items": "center",
      "justify-content": "space-between",
      "white-space": "nowrap"
    }, _a[".".concat(CLASS_NAME.MARKER)] = {
      width: "8px",
      height: "8px",
      "border-radius": "50%",
      display: "inline-block",
      "margin-right": "4px"
    }, _a[".".concat(CLASS_NAME.NAME)] = {
      display: "flex",
      "align-items": "center",
      "max-width": "216px"
    }, _a[".".concat(CLASS_NAME.NAME_LABEL)] = __assign({ flex: 1 }, TEXT_OVERFLOW_STYLE), _a[".".concat(CLASS_NAME.VALUE)] = __assign({ display: "inline-block", float: "right", flex: 1, "text-align": "right", "min-width": "28px", "margin-left": "30px", color: "rgba(0, 0, 0, 0.85)" }, TEXT_OVERFLOW_STYLE), _a[".".concat(CLASS_NAME.CROSSHAIR_X)] = {
      position: "absolute",
      width: "1px",
      "background-color": "rgba(0, 0, 0, 0.25)"
    }, _a[".".concat(CLASS_NAME.CROSSHAIR_Y)] = {
      position: "absolute",
      height: "1px",
      "background-color": "rgba(0, 0, 0, 0.25)"
    }, _a;
  }

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/tooltip/index.js
  var Tooltip = (
    /** @class */
    function(_super) {
      __extends(Tooltip3, _super);
      function Tooltip3(options) {
        var _this = this;
        var _a, _b;
        var prefixCls = (_b = (_a = options.style) === null || _a === void 0 ? void 0 : _a.template) === null || _b === void 0 ? void 0 : _b.prefixCls;
        var CLASS_NAME = getClassNames(prefixCls);
        _this = _super.call(this, options, {
          data: [],
          x: 0,
          y: 0,
          visibility: "visible",
          title: "",
          position: "bottom-right",
          offset: [5, 5],
          enterable: false,
          container: {
            x: 0,
            y: 0
          },
          bounding: null,
          template: {
            prefixCls: "",
            container: '<div class="'.concat(CLASS_NAME.CONTAINER, '"></div>'),
            title: '<div class="'.concat(CLASS_NAME.TITLE, '"></div>'),
            item: '<li class="'.concat(CLASS_NAME.LIST_ITEM, '" data-index={index}>\n        <span class="').concat(CLASS_NAME.NAME, '">\n          <span class="').concat(CLASS_NAME.MARKER, '" style="background:{color}"></span>\n          <span class="').concat(CLASS_NAME.NAME_LABEL, '" title="{name}">{name}</span>\n        </span>\n        <span class="').concat(CLASS_NAME.VALUE, '" title="{value}">{value}</span>\n      </li>')
          },
          style: getDefaultTooltipStyle(prefixCls)
        }) || this;
        _this.timestamp = -1;
        _this.prevCustomContentKey = _this.attributes.contentKey;
        _this.initShape();
        _this.render(_this.attributes, _this);
        return _this;
      }
      Object.defineProperty(Tooltip3.prototype, "HTMLTooltipElement", {
        get: function() {
          return this.element;
        },
        enumerable: false,
        configurable: true
      });
      Tooltip3.prototype.getContainer = function() {
        return this.element;
      };
      Object.defineProperty(Tooltip3.prototype, "elementSize", {
        get: function() {
          var width = this.element.offsetWidth;
          var height = this.element.offsetHeight;
          return { width, height };
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Tooltip3.prototype, "HTMLTooltipItemsElements", {
        get: function() {
          var _a = this.attributes, data2 = _a.data, template = _a.template;
          return data2.map(function(_a2, idx) {
            var _b = _a2.name, name2 = _b === void 0 ? "" : _b, _c = _a2.color, color2 = _c === void 0 ? "black" : _c, index4 = _a2.index, rest = __rest(_a2, ["name", "color", "index"]);
            var datum = __assign({ name: name2, color: color2, index: index4 !== null && index4 !== void 0 ? index4 : idx }, rest);
            return createDOM(substitute_default(template.item, datum));
          });
        },
        enumerable: false,
        configurable: true
      });
      Tooltip3.prototype.render = function(attributes, container) {
        this.renderHTMLTooltipElement();
        this.updatePosition();
      };
      Tooltip3.prototype.destroy = function() {
        var _a;
        (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();
        _super.prototype.destroy.call(this);
      };
      Tooltip3.prototype.show = function(x3, y3) {
        var _this = this;
        if (x3 !== void 0 && y3 !== void 0) {
          var isToggle = this.element.style.visibility === "hidden";
          var setPosition = function() {
            _this.attributes.x = x3 !== null && x3 !== void 0 ? x3 : _this.attributes.x;
            _this.attributes.y = y3 !== null && y3 !== void 0 ? y3 : _this.attributes.y;
            _this.updatePosition();
          };
          isToggle ? this.closeTransition(setPosition) : setPosition();
        }
        this.element.style.visibility = "visible";
      };
      Tooltip3.prototype.hide = function(x3, y3) {
        if (x3 === void 0) {
          x3 = 0;
        }
        if (y3 === void 0) {
          y3 = 0;
        }
        var enterable = this.attributes.enterable;
        if (enterable && this.isCursorEntered(x3, y3))
          return;
        this.element.style.visibility = "hidden";
      };
      Tooltip3.prototype.initShape = function() {
        var template = this.attributes.template;
        this.element = createDOM(template.container);
        if (this.id)
          this.element.setAttribute("id", this.id);
      };
      Tooltip3.prototype.renderCustomContent = function() {
        if (this.prevCustomContentKey !== void 0 && this.prevCustomContentKey === this.attributes.contentKey)
          return;
        this.prevCustomContentKey = this.attributes.contentKey;
        var content = this.attributes.content;
        if (!content)
          return;
        if (typeof content === "string")
          this.element.innerHTML = content;
        else
          this.element.replaceChildren(content);
      };
      Tooltip3.prototype.renderHTMLTooltipElement = function() {
        var _a, _b;
        var _c = this.attributes, template = _c.template, title = _c.title, enterable = _c.enterable, style = _c.style, content = _c.content;
        var CLASS_NAME = getClassNames(template.prefixCls);
        var container = this.element;
        this.element.style.pointerEvents = enterable ? "auto" : "none";
        if (content)
          this.renderCustomContent();
        else {
          if (title) {
            container.innerHTML = template.title;
            container.getElementsByClassName(CLASS_NAME.TITLE)[0].innerHTML = title;
          } else
            (_b = (_a = container.getElementsByClassName(CLASS_NAME.TITLE)) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.remove();
          var itemsElements = this.HTMLTooltipItemsElements;
          var ul = document.createElement("ul");
          ul.className = CLASS_NAME.LIST;
          ul.replaceChildren.apply(ul, __spreadArray([], __read(itemsElements), false));
          var list = this.element.querySelector(".".concat(CLASS_NAME.LIST));
          if (list)
            list.replaceWith(ul);
          else
            container.appendChild(ul);
        }
        applyStyleSheet(container, style);
      };
      Tooltip3.prototype.getRelativeOffsetFromCursor = function(assignPosition) {
        var _a = this.attributes, position = _a.position, offset3 = _a.offset;
        var interPosition = assignPosition || position;
        var finalPosition = interPosition.split("-");
        var positionScore = { left: [-1, 0], right: [1, 0], top: [0, -1], bottom: [0, 1] };
        var _b = this.elementSize, width = _b.width, height = _b.height;
        var absolutelyOffset = [-width / 2, -height / 2];
        finalPosition.forEach(function(pos) {
          var _a2 = __read(absolutelyOffset, 2), abs1 = _a2[0], abs22 = _a2[1];
          var _b2 = __read(positionScore[pos], 2), pos1 = _b2[0], pos2 = _b2[1];
          absolutelyOffset = [abs1 + (width / 2 + offset3[0]) * pos1, abs22 + (height / 2 + offset3[1]) * pos2];
        });
        return absolutelyOffset;
      };
      Tooltip3.prototype.setOffsetPosition = function(_a) {
        var _b = __read(_a, 2), offsetX = _b[0], offsetY = _b[1];
        var _c = this.attributes, _d = _c.x, x3 = _d === void 0 ? 0 : _d, _e = _c.y, y3 = _e === void 0 ? 0 : _e, _f = _c.container, cx = _f.x, cy = _f.y;
        this.element.style.left = "".concat(+x3 + cx + offsetX, "px");
        this.element.style.top = "".concat(+y3 + cy + offsetY, "px");
      };
      Tooltip3.prototype.updatePosition = function() {
        var _a = this.attributes.showDelay, showDelay = _a === void 0 ? 60 : _a;
        var currentTimestamp = Date.now();
        if (this.timestamp > 0 && currentTimestamp - this.timestamp < showDelay)
          return;
        this.timestamp = currentTimestamp;
        this.setOffsetPosition(this.autoPosition(this.getRelativeOffsetFromCursor()));
      };
      Tooltip3.prototype.autoPosition = function(_a) {
        var _b = __read(_a, 2), offsetX = _b[0], offsetY = _b[1];
        var _c = this.attributes, cursorX = _c.x, cursorY = _c.y, bounding = _c.bounding, position = _c.position;
        if (!bounding)
          return [offsetX, offsetY];
        var _d = this.element, offsetWidth = _d.offsetWidth, offsetHeight = _d.offsetHeight;
        var _e = __read([+cursorX + offsetX, +cursorY + offsetY], 2), expectLeft = _e[0], expectTop = _e[1];
        var inversion = {
          left: "right",
          right: "left",
          top: "bottom",
          bottom: "top"
        };
        var boundingX = bounding.x, boundingY = bounding.y, boundingWidth = bounding.width, boundingHeight = bounding.height;
        var edgeCompare = {
          left: expectLeft < boundingX,
          right: expectLeft + offsetWidth > boundingX + boundingWidth,
          top: expectTop < boundingY,
          bottom: expectTop + offsetHeight > boundingY + boundingHeight
        };
        var correctivePosition = [];
        position.split("-").forEach(function(pos) {
          if (edgeCompare[pos])
            correctivePosition.push(inversion[pos]);
          else
            correctivePosition.push(pos);
        });
        var correctedPositionString = correctivePosition.join("-");
        return this.getRelativeOffsetFromCursor(correctedPositionString);
      };
      Tooltip3.prototype.isCursorEntered = function(clientX, clientY) {
        if (this.element) {
          var _a = this.element.getBoundingClientRect(), x3 = _a.x, y3 = _a.y, width = _a.width, height = _a.height;
          return new BBox(x3, y3, width, height).isPointIn(clientX, clientY);
        }
        return false;
      };
      Tooltip3.prototype.closeTransition = function(callback) {
        var _this = this;
        var transition2 = this.element.style.transition;
        this.element.style.transition = "none";
        callback();
        setTimeout(function() {
          _this.element.style.transition = transition2;
        }, 10);
      };
      Tooltip3.tag = "tooltip";
      return Tooltip3;
    }(Component)
  );

  // ../../engine/rails_design/node_modules/@antv/component/esm/ui/layout/layout.js
  var Layout = (
    /** @class */
    function(_super) {
      __extends(Layout2, _super);
      function Layout2(options) {
        var _this = _super.call(this, options) || this;
        _this.layoutEvents = [ElementEvent.BOUNDS_CHANGED, ElementEvent.INSERTED, ElementEvent.REMOVED];
        _this.$margin = parseSeriesAttr(0);
        _this.$padding = parseSeriesAttr(0);
        var _a = options.style || {}, _b = _a.margin, margin = _b === void 0 ? 0 : _b, _c = _a.padding, padding = _c === void 0 ? 0 : _c;
        _this.margin = margin;
        _this.padding = padding;
        _this.isMutationObserved = true;
        _this.bindEvents();
        return _this;
      }
      Object.defineProperty(Layout2.prototype, "margin", {
        get: function() {
          return this.$margin;
        },
        set: function(value2) {
          this.$margin = parseSeriesAttr(value2);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(Layout2.prototype, "padding", {
        get: function() {
          return this.$padding;
        },
        set: function(value2) {
          this.$padding = parseSeriesAttr(value2);
        },
        enumerable: false,
        configurable: true
      });
      Layout2.prototype.getBBox = function() {
        var _a = this.attributes, _b = _a.x, x3 = _b === void 0 ? 0 : _b, _c = _a.y, y3 = _c === void 0 ? 0 : _c, width = _a.width, height = _a.height;
        var _d = __read(this.$margin, 4), marginTop = _d[0], marginRight = _d[1], marginBottom = _d[2], marginLeft = _d[3];
        return new BBox(x3 - marginLeft, y3 - marginTop, width + marginLeft + marginRight, height + marginTop + marginBottom);
      };
      Layout2.prototype.appendChild = function(child, index4) {
        child.isMutationObserved = true;
        _super.prototype.appendChild.call(this, child, index4);
        return child;
      };
      Layout2.prototype.getAvailableSpace = function() {
        var _a = this.attributes, width = _a.width, height = _a.height;
        var _b = __read(this.$padding, 4), paddingTop = _b[0], paddingRight = _b[1], paddingBottom = _b[2], paddingLeft = _b[3];
        var _c = __read(this.$margin, 4), marginTop = _c[0], marginLeft = _c[3];
        return new BBox(paddingLeft + marginLeft, paddingTop + marginTop, width - paddingLeft - paddingRight, height - paddingTop - paddingBottom);
      };
      Layout2.prototype.layout = function() {
        if (!this.attributes.display || !this.isConnected)
          return;
        if (this.children.some(function(child) {
          return !child.isConnected;
        }))
          return;
        try {
          var _a = this.attributes, x3 = _a.x, y3 = _a.y;
          this.style.transform = "translate(".concat(x3, ", ").concat(y3, ")");
          var bboxes_1 = executer_default(this.getAvailableSpace(), this.children.map(function(child) {
            return child.getBBox();
          }), this.attributes);
          this.children.forEach(function(child, index4) {
            var _a2 = bboxes_1[index4], x4 = _a2.x, y4 = _a2.y;
            child.style.transform = "translate(".concat(x4, ", ").concat(y4, ")");
          });
        } catch (e3) {
        }
      };
      Layout2.prototype.bindEvents = function() {
        var _this = this;
        this.layoutEvents.forEach(function(event) {
          _this.addEventListener(event, function(e3) {
            e3.target.isMutationObserved = true;
            _this.layout();
          });
        });
      };
      Layout2.prototype.attributeChangedCallback = function(name2, oldValue, newValue) {
        if (name2 === "margin")
          this.margin = newValue;
        else if (name2 === "padding")
          this.padding = newValue;
        this.layout();
      };
      return Layout2;
    }(Group2)
  );

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/text/advance.js
  var __rest22 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function getConnectorPoint(shape23) {
    const { min: [x05, y05], max: [x12, y12] } = shape23.getLocalBounds();
    let x3 = 0;
    let y3 = 0;
    if (x05 > 0)
      x3 = x05;
    if (x12 < 0)
      x3 = x12;
    if (y05 > 0)
      y3 = y05;
    if (y12 < 0)
      y3 = y12;
    return [x3, y3];
  }
  function inferBackgroundBounds(textShape, padding = []) {
    const [top = 0, right2 = 0, bottom = top, left2 = right2] = padding;
    const container = textShape.parentNode;
    const angle4 = container.getEulerAngles();
    container.setEulerAngles(0);
    const { min: min10, halfExtents } = textShape.getLocalBounds();
    const [x3, y3] = min10;
    const [hw, hh] = halfExtents;
    container.setEulerAngles(angle4);
    return {
      x: x3 - left2,
      y: y3 - top,
      width: hw * 2 + left2 + right2,
      height: hh * 2 + top + bottom
    };
  }
  function inferConnectorPath(shape23, end, control, coordCenter, left2 = true, top = true) {
    const path2 = (points) => line_default()(points);
    if (!end[0] && !end[1])
      return path2([getConnectorPoint(shape23), end]);
    if (!control.length)
      return path2([[0, 0], end]);
    const [inflection, start2] = control;
    const p1 = [...start2];
    const p2 = [...inflection];
    if (start2[0] !== inflection[0]) {
      const offset3 = left2 ? -4 : 4;
      p1[1] = start2[1];
      if (top && !left2) {
        p1[0] = Math.max(inflection[0], start2[0] - offset3);
        if (start2[1] < inflection[1]) {
          p2[1] = p1[1];
        } else {
          p2[1] = inflection[1];
          p2[0] = Math.max(p2[0], p1[0] - offset3);
        }
      }
      if (!top && !left2) {
        p1[0] = Math.max(inflection[0], start2[0] - offset3);
        if (start2[1] > inflection[1]) {
          p2[1] = p1[1];
        } else {
          p2[1] = inflection[1];
          p2[0] = Math.max(p2[0], p1[0] - offset3);
        }
      }
      if (!top && left2) {
        p1[0] = Math.min(inflection[0], start2[0] - offset3);
        if (start2[1] > inflection[1]) {
          p2[1] = p1[1];
        } else {
          p2[1] = inflection[1];
          p2[0] = Math.min(p2[0], p1[0] - offset3);
        }
      }
      if (top && left2) {
        p1[0] = Math.min(inflection[0], start2[0] - offset3);
        if (start2[1] < inflection[1]) {
          p2[1] = p1[1];
        } else {
          p2[1] = inflection[1];
          p2[0] = Math.min(p2[0], p1[0] - offset3);
        }
      }
    }
    return path2([start2, p1, p2, inflection, end]);
  }
  var Advance = createElement((g) => {
    const _a = g.attributes, {
      className: className2,
      // Do not pass className
      class: _c,
      transform,
      rotate: rotate4,
      labelTransform,
      labelTransformOrigin,
      x: x3,
      y: y3,
      x0: x05 = x3,
      y0: y05 = y3,
      text,
      background,
      connector,
      startMarker,
      endMarker,
      coordCenter,
      innerHTML
    } = _a, rest = __rest22(_a, ["className", "class", "transform", "rotate", "labelTransform", "labelTransformOrigin", "x", "y", "x0", "y0", "text", "background", "connector", "startMarker", "endMarker", "coordCenter", "innerHTML"]);
    g.style.transform = `translate(${x3}, ${y3})`;
    if ([x3, y3, x05, y05].some((v) => !is_number_default(v))) {
      g.children.forEach((d2) => d2.remove());
      return;
    }
    const _b = subObject(rest, "background"), { padding } = _b, backgroundStyle = __rest22(_b, ["padding"]);
    const _d = subObject(rest, "connector"), { points: controlPoints = [] } = _d, connectorStyle = __rest22(_d, ["points"]);
    let textShape;
    if (innerHTML) {
      textShape = select(g).maybeAppend("html", "html", className2).style("zIndex", 0).style("innerHTML", innerHTML).call(applyStyle, Object.assign({ transform: labelTransform, transformOrigin: labelTransformOrigin }, rest)).node();
    } else {
      textShape = select(g).maybeAppend("text", "text").style("zIndex", 0).style("text", text).call(applyStyle, Object.assign({ textBaseline: "middle", transform: labelTransform, transformOrigin: labelTransformOrigin }, rest)).node();
    }
    const rect4 = select(g).maybeAppend("background", "rect").style("zIndex", -1).call(applyStyle, inferBackgroundBounds(textShape, padding)).call(applyStyle, background ? backgroundStyle : {}).node();
    const left2 = +x05 < coordCenter[0];
    const top = +y05 < coordCenter[1];
    const end = [+x05 - +x3, +y05 - +y3];
    const connectorPath = inferConnectorPath(rect4, end, controlPoints, coordCenter, left2, top);
    const markerStart = startMarker && new Marker({
      id: "startMarker",
      style: Object.assign({ x: 0, y: 0 }, subObject(rest, "startMarker"))
    });
    const markerEnd = endMarker && new Marker({
      id: "endMarker",
      style: Object.assign({ x: 0, y: 0 }, subObject(rest, "endMarker"))
    });
    select(g).maybeAppend("connector", "path").style("zIndex", 0).style("d", connectorPath).style("markerStart", markerStart).style("markerEnd", markerEnd).call(applyStyle, connector ? connectorStyle : {});
  });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/text/text.js
  var Text3 = (options, context) => {
    const { coordinate } = context;
    return (points, value2, defaults5) => {
      const { color: color2, text = "", fontSize, rotate: rotate4 = 0, transform = "" } = value2;
      const textStyle = {
        text: String(text),
        stroke: color2,
        fill: color2,
        fontSize
      };
      const [[x05, y05]] = points;
      return select(new Advance()).style("x", x05).style("y", y05).call(applyStyle, defaults5).style("transform", `${transform}rotate(${+rotate4})`).style("coordCenter", coordinate.getCenter()).call(applyStyle, textStyle).call(applyStyle, options).node();
    };
  };
  Text3.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/text/badge.js
  var __rest23 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function getPath(r) {
    const offset3 = r / Math.sqrt(2);
    const dy = r * Math.sqrt(2);
    const [p0x, p0y] = [-offset3, offset3 - dy];
    const [p1x, p1y] = [0, 0];
    const [p2x, p2y] = [offset3, offset3 - dy];
    return [
      ["M", p0x, p0y],
      ["A", r, r, 0, 1, 1, p2x, p2y],
      ["L", p1x, p1y],
      ["Z"]
    ];
  }
  function inferTextPosition(shape23) {
    const { min: min10, max: max10 } = shape23.getLocalBounds();
    return [(min10[0] + max10[0]) * 0.5, (min10[1] + max10[1]) * 0.5];
  }
  var BadgeShape = createElement((g) => {
    const _a = g.attributes, { class: className2, x: x05, y: y05, transform } = _a, rest = __rest23(_a, ["class", "x", "y", "transform"]);
    const markerStyle = subObject(rest, "marker");
    const { size: size2 = 24 } = markerStyle;
    const symbol = () => getPath(size2 / 2);
    const bgShape = select(g).maybeAppend("marker", () => new Marker({})).call((selection) => selection.node().update(Object.assign({ symbol }, markerStyle))).node();
    const [x3, y3] = inferTextPosition(bgShape);
    select(g).maybeAppend("text", "text").style("x", x3).style("y", y3).call(applyStyle, rest);
  });
  var Badge = (options, context) => {
    const style = __rest23(options, []);
    return (points, value2, defaults5) => {
      const { color: defaultColor } = defaults5, rest = __rest23(defaults5, ["color"]);
      const { color: color2 = defaultColor, text = "" } = value2;
      const textStyle = {
        text: String(text),
        stroke: color2,
        fill: color2
      };
      const [[x05, y05]] = points;
      return select(new BadgeShape()).call(applyStyle, rest).style("transform", `translate(${x05},${y05})`).call(applyStyle, textStyle).call(applyStyle, style).node();
    };
  };
  Badge.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/text/tag.js
  var Tag = (options, context) => {
    const { coordinate } = context;
    return (points, value2, defaults5) => {
      const { color: color2, text = "", fontSize, rotate: rotate4 = 0, transform = "" } = value2;
      const textStyle = {
        text: String(text),
        stroke: color2,
        fill: color2,
        fontSize,
        textAlign: "center",
        textBaseline: "middle"
      };
      const [[x05, y05]] = points;
      const n2 = select(new Text()).style("x", x05).style("y", y05).call(applyStyle, defaults5).style("transformOrigin", "center center").style("transform", `${transform}rotate(${rotate4}deg)`).style("coordCenter", coordinate.getCenter()).call(applyStyle, textStyle).call(applyStyle, options).node();
      return n2;
    };
  };
  Tag.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/area/curve.js
  var __rest24 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function segmentation2(points, defined4) {
    const definedPointsY1 = [];
    const definedPointsY0 = [];
    const segments = [];
    let m3 = false;
    let dp = null;
    const mid2 = points.length / 2;
    for (let i = 0; i < mid2; i++) {
      const y12 = points[i];
      const y05 = points[i + mid2];
      if ([...y12, ...y05].some((v) => !defined4(v)))
        m3 = true;
      else {
        definedPointsY1.push(y12);
        definedPointsY0.push(y05);
        if (m3 && dp) {
          m3 = false;
          const [dpy1, dpy0] = dp;
          segments.push([dpy1, y12, dpy0, y05]);
        }
        dp = [y12, y05];
      }
    }
    return [definedPointsY1.concat(definedPointsY0), segments];
  }
  var DoubleArea = createElement((g) => {
    const { areaPath, connectPath, areaStyle, connectStyle } = g.attributes;
    const document2 = g.ownerDocument;
    select(g).maybeAppend("connect-path", () => document2.createElement("path", {})).style("d", connectPath).call(applyStyle, connectStyle);
    select(g).maybeAppend("area-path", () => document2.createElement("path", {})).style("d", areaPath).call(applyStyle, areaStyle);
  });
  var Curve2 = (options, context) => {
    const { curve, gradient = false, defined: defined4 = (d2) => !Number.isNaN(d2) && d2 !== void 0 && d2 !== null, connect: connectNulls = false } = options, style = __rest24(options, ["curve", "gradient", "defined", "connect"]);
    const { coordinate, document: document2 } = context;
    return (P, value2, defaults5) => {
      const { color: defaultColor } = defaults5;
      const { color: color2 = defaultColor, seriesColor: sc, seriesX: sx, seriesY: sy } = value2;
      const tpShape = isTranspose(coordinate);
      const transform = getTransform(coordinate, value2);
      const fill = gradient && sc ? computeGradient(sc, sx, sy, gradient, void 0, tpShape) : color2;
      const finalStyle = Object.assign(Object.assign(Object.assign(Object.assign({}, defaults5), { stroke: fill, fill }), transform && { transform }), style);
      const [DP, MS] = segmentation2(P, defined4);
      const connectStyle = subObject(finalStyle, "connect");
      const missing = !!MS.length;
      const getPathNode = (path2) => {
        return select(document2.createElement("path", {})).style("d", path2 || "").call(applyStyle, finalStyle).node();
      };
      if (!isPolar(coordinate)) {
        const areaPath = (points) => {
          const Y12 = points.slice(0, points.length / 2);
          const Y02 = points.slice(points.length / 2);
          return tpShape ? area_default().y((_2, idx) => Y12[idx][1]).x1((_2, idx) => Y12[idx][0]).x0((_2, idx) => Y02[idx][0]).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y12) : area_default().x((_2, idx) => Y12[idx][0]).y1((_2, idx) => Y12[idx][1]).y0((_2, idx) => Y02[idx][1]).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y12);
        };
        if (!missing || connectNulls && !Object.keys(connectStyle).length) {
          return getPathNode(areaPath(DP));
        }
        if (missing && !connectNulls) {
          return getPathNode(areaPath(P));
        }
        return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaPath(P)).style("connectPath", MS.map(areaPath).join("")).node();
      } else {
        const areaRadialPath = (points) => {
          const center2 = coordinate.getCenter();
          const Y12 = points.slice(0, points.length / 2);
          const Y02 = points.slice(points.length / 2);
          return areaRadial_default().angle((_2, idx) => angleWithQuadrant(sub6(Y12[idx], center2))).outerRadius((_2, idx) => dist4(Y12[idx], center2)).innerRadius((_2, idx) => dist4(Y02[idx], center2)).defined((_2, idx) => [...Y12[idx], ...Y02[idx]].every(defined4)).curve(curve)(Y02);
        };
        if (!missing || connectNulls && !Object.keys(connectStyle).length) {
          return getPathNode(areaRadialPath(DP));
        }
        if (missing && !connectNulls) {
          return getPathNode(areaRadialPath(P));
        }
        return select(new DoubleArea()).style("areaStyle", finalStyle).style("connectStyle", Object.assign(Object.assign({}, connectStyle), style)).style("areaPath", areaRadialPath(P)).style("connectPath", MS.map(areaRadialPath).join("")).node();
      }
    };
  };
  Curve2.props = {
    defaultMarker: "smooth",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/area/area.js
  var Area = (options, context) => {
    const { coordinate } = context;
    return (...params) => {
      const curve = isPolar(coordinate) ? linearClosed_default : linear_default;
      return Curve2(Object.assign({ curve }, options), context)(...params);
    };
  };
  Area.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "square" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/area/smooth.js
  var __rest25 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var Smooth2 = (options, context) => {
    const rest = __rest25(options, []);
    const { coordinate } = context;
    return (...params) => {
      const curve = isPolar(coordinate) ? catmullRomClosed_default : isTranspose(coordinate) ? monotoneY : monotoneX;
      return Curve2(Object.assign({ curve }, rest), context)(...params);
    };
  };
  Smooth2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "smooth" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/area/hvh.js
  var HVH2 = (options, context) => {
    return (...params) => {
      return Curve2(Object.assign({ curve: step_default }, options), context)(...params);
    };
  };
  HVH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hvh" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/area/vh.js
  var VH2 = (options, context) => {
    return (...params) => {
      return Curve2(Object.assign({ curve: stepBefore }, options), context)(...params);
    };
  };
  VH2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "vh" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/area/hv.js
  var HV2 = (options, context) => {
    return (...params) => {
      return Curve2(Object.assign({ curve: stepAfter }, options), context)(...params);
    };
  };
  HV2.props = Object.assign(Object.assign({}, Curve2.props), { defaultMarker: "hv" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/link/link.js
  var Link = (options, context) => {
    const { arrow = false } = options;
    return (...params) => {
      return Vector(Object.assign(Object.assign({}, options), { arrow }), context)(...params);
    };
  };
  Link.props = {
    defaultMarker: "line",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/link/smooth.js
  var __rest26 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var Smooth3 = (options, context) => {
    const style = __rest26(options, []);
    const { document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor } = defaults5, rest = __rest26(defaults5, ["color"]);
      const { color: color2 = defaultColor, transform } = value2;
      const [from, to] = points;
      const path2 = path();
      path2.moveTo(from[0], from[1]);
      path2.bezierCurveTo(from[0] / 2 + to[0] / 2, from[1], from[0] / 2 + to[0] / 2, to[1], to[0], to[1]);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("transform", transform).call(applyStyle, style).node();
    };
  };
  Smooth3.props = {
    defaultMarker: "smooth",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/link/vhv.js
  var __rest27 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function getVHVPath(from, to, coordinate, ratio) {
    const path2 = path();
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      const a3 = dist4(from, center2);
      const b = dist4(to, center2);
      const radius = (b - a3) * ratio + a3;
      path2.moveTo(from[0], from[1]);
      appendArc(path2, from, to, center2, radius);
      path2.lineTo(to[0], to[1]);
      return path2;
    }
    if (isTranspose(coordinate)) {
      path2.moveTo(from[0], from[1]);
      path2.lineTo(from[0] + (to[0] - from[0]) * ratio, from[1]);
      path2.lineTo(from[0] + (to[0] - from[0]) * ratio, to[1]);
      path2.lineTo(to[0], to[1]);
      return path2;
    }
    path2.moveTo(from[0], from[1]);
    path2.lineTo(from[0], from[1] + (to[1] - from[1]) * ratio);
    path2.lineTo(to[0], from[1] + (to[1] - from[1]) * ratio);
    path2.lineTo(to[0], to[1]);
    return path2;
  }
  var VHV = (options, context) => {
    const { cornerRatio = 1 / 3 } = options, style = __rest27(options, ["cornerRatio"]);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { defaultColor } = defaults5, rest = __rest27(defaults5, ["defaultColor"]);
      const { color: color2 = defaultColor, transform } = value2;
      const [from, to] = points;
      const path2 = getVHVPath(from, to, coordinate, cornerRatio);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("transform", transform).call(applyStyle, style).node();
    };
  };
  VHV.props = {
    defaultMarker: "vhv",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/link/arc.js
  var __rest28 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var Arc = (options, context) => {
    const style = __rest28(options, []);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor } = defaults5, rest = __rest28(defaults5, ["color"]);
      const { color: color2 = defaultColor, transform } = value2;
      const [from, to] = points;
      const path2 = path();
      path2.moveTo(from[0], from[1]);
      if (isPolar(coordinate)) {
        const center2 = coordinate.getCenter();
        path2.quadraticCurveTo(center2[0], center2[1], to[0], to[1]);
      } else {
        const center2 = mid(from, to);
        const raduis = dist4(from, to) / 2;
        appendArc(path2, from, to, center2, raduis);
      }
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("transform", transform).call(applyStyle, style).node();
    };
  };
  Arc.props = {
    defaultMarker: "smooth",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/utils.js
  function baseChannels(options = {}) {
    const { shapes } = options;
    return [
      { name: "color" },
      { name: "opacity" },
      { name: "shape", range: shapes },
      { name: "enterType" },
      { name: "enterDelay", scaleKey: "enter" },
      { name: "enterDuration", scaleKey: "enter" },
      { name: "enterEasing" },
      { name: "key", scale: "identity" },
      { name: "groupKey", scale: "identity" },
      { name: "label", scale: "identity" }
    ];
  }
  function baseGeometryChannels(options = {}) {
    return [...baseChannels(options), { name: "title", scale: "identity" }];
  }
  function tooltip2d() {
    return [
      { type: MaybeTitle, channel: "color" },
      { type: MaybeTooltip, channel: ["x", "y"] }
    ];
  }
  function tooltip1d() {
    return [
      { type: MaybeTitle, channel: "x" },
      { type: MaybeTooltip, channel: ["y"] }
    ];
  }
  function tooltipXd() {
    return [
      { type: MaybeTitle, channel: "color" },
      { type: MaybeTooltip, channel: ["position"] }
    ];
  }
  function baseAnnotationChannels(options = {}) {
    return baseChannels(options);
  }
  function basePreInference() {
    return [{ type: MaybeKey }];
  }
  function basePostInference() {
    return [];
  }
  function bandWidth(scale9, x3) {
    return scale9.getBandWidth(scale9.invert(x3));
  }
  function createBandOffset(scale9, value2, options = {}) {
    const { x: X, y: Y, series: S } = value2;
    const { x: x3, y: y3, series } = scale9;
    const { style: { bandOffset = series ? 0 : 0.5, bandOffsetX = bandOffset, bandOffsetY = bandOffset } = {} } = options;
    const isBandX = !!(x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth);
    const isBandY = !!(y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth);
    const isSeries = !!(series === null || series === void 0 ? void 0 : series.getBandWidth);
    if (!isBandX && !isBandY)
      return (d2) => d2;
    return (d2, i) => {
      const widthX = isBandX ? bandWidth(x3, X[i]) : 0;
      const widthY = isBandY ? bandWidth(y3, Y[i]) : 0;
      const f = () => (bandWidth(series, S[i]) / 2 + +S[i]) * widthX;
      const offset3 = isSeries && S ? f() : 0;
      const [x05, y05] = d2;
      return [x05 + bandOffsetX * widthX + offset3, y05 + bandOffsetY * widthY];
    };
  }
  function p(d2) {
    return parseFloat(d2) / 100;
  }
  function visualMark(index4, scale9, value2, coordinate) {
    const { x: X, y: Y } = value2;
    const { innerWidth, innerHeight } = coordinate.getOptions();
    const P = Array.from(index4, (i) => {
      const x05 = X[i];
      const y05 = Y[i];
      const x3 = typeof x05 === "string" ? p(x05) * innerWidth : +x05;
      const y3 = typeof y05 === "string" ? p(y05) * innerHeight : +y05;
      return [[x3, y3]];
    });
    return [index4, P];
  }
  function field(encode) {
    return typeof encode === "function" ? encode : (d2) => d2[encode];
  }
  function valueof(data2, encode) {
    return Array.from(data2, field(encode));
  }
  function initializeData(data2, encode) {
    const { source = (d2) => d2.source, target = (d2) => d2.target, value: value2 = (d2) => d2.value } = encode;
    const { links, nodes } = data2;
    const LS = valueof(links, source);
    const LT = valueof(links, target);
    const LV = valueof(links, value2);
    return {
      links: links.map((_2, i) => ({
        target: LT[i],
        source: LS[i],
        value: LV[i]
      })),
      nodes: nodes || Array.from(/* @__PURE__ */ new Set([...LS, ...LT]), (key) => ({ key }))
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/image/image.js
  var __rest29 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var Image3 = (options, context) => {
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor } = defaults5, rest = __rest29(defaults5, ["color"]);
      const { color: color2 = defaultColor, src = "", size: size2 = 32, transform = "" } = value2;
      let { width = size2, height = size2 } = options;
      const [[x05, y05]] = points;
      const [w, h] = coordinate.getSize();
      width = typeof width === "string" ? p(width) * w : width;
      height = typeof height === "string" ? p(height) * h : height;
      const x3 = x05 - Number(width) / 2;
      const y3 = y05 - Number(height) / 2;
      return select(document2.createElement("image", {})).call(applyStyle, rest).style("x", x3).style("y", y3).style("src", src).style("stroke", color2).style("transform", transform).call(applyStyle, options).style("width", width).style("height", height).node();
    };
  };
  Image3.props = {
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/polygon/polygon.js
  var __rest30 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function getPolygonPath(points, coordinate) {
    const path2 = path();
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      const closedPoints = [...points, points[0]];
      const dists = closedPoints.map((p2) => dist4(p2, center2));
      closedPoints.forEach((curr, idx) => {
        if (idx === 0) {
          path2.moveTo(curr[0], curr[1]);
          return;
        }
        const currDist = dists[idx];
        const prev = points[idx - 1];
        const prevDist = dists[idx - 1];
        if (prevDist !== void 0 && Math.abs(currDist - prevDist) < 1e-10) {
          appendArc(path2, prev, curr, center2, currDist);
        } else {
          path2.lineTo(curr[0], curr[1]);
        }
      });
      path2.closePath();
      return path2;
    }
    return appendPolygon(path2, points);
  }
  var Polygon2 = (options, context) => {
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor } = defaults5, rest = __rest30(defaults5, ["color"]);
      const { color: color2 = defaultColor, transform } = value2;
      const path2 = getPolygonPath(points, coordinate);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2).style("fill", color2).style("transform", transform).call(applyStyle, options).node();
    };
  };
  Polygon2.props = {
    defaultMarker: "square",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/polygon/ribbon.js
  var __rest31 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function getRibbonPath(points, coordinate) {
    const [p0, p1, p2, p3] = points;
    const path2 = path();
    if (isPolar(coordinate)) {
      const center2 = coordinate.getCenter();
      const radius = dist4(center2, p0);
      path2.moveTo(p0[0], p0[1]);
      path2.quadraticCurveTo(center2[0], center2[1], p2[0], p2[1]);
      appendArc(path2, p2, p3, center2, radius);
      path2.quadraticCurveTo(center2[0], center2[1], p1[0], p1[1]);
      appendArc(path2, p1, p0, center2, radius);
      path2.closePath();
      return path2;
    }
    path2.moveTo(p0[0], p0[1]);
    path2.bezierCurveTo(p0[0] / 2 + p2[0] / 2, p0[1], p0[0] / 2 + p2[0] / 2, p2[1], p2[0], p2[1]);
    path2.lineTo(p3[0], p3[1]);
    path2.bezierCurveTo(p3[0] / 2 + p1[0] / 2, p3[1], p3[0] / 2 + p1[0] / 2, p1[1], p1[0], p1[1]);
    path2.lineTo(p0[0], p0[1]);
    path2.closePath();
    return path2;
  }
  var Ribbon2 = (options, context) => {
    const style = __rest31(options, []);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor } = defaults5, rest = __rest31(defaults5, ["color"]);
      const { color: color2 = defaultColor, transform } = value2;
      const path2 = getRibbonPath(points, coordinate);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("fill", color2 || defaultColor).style("stroke", color2 || defaultColor).style("transform", transform).call(applyStyle, style).node();
    };
  };
  Ribbon2.props = {
    defaultMarker: "square",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/box/box.js
  var __rest32 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function getPath2(points, coordinate) {
    const path2 = path();
    if (!isPolar(coordinate)) {
      path2.moveTo(...points[0]);
      path2.lineTo(...points[1]);
      path2.moveTo(...points[2]);
      path2.lineTo(...points[3]);
      path2.moveTo(...points[4]);
      path2.lineTo(...points[5]);
      path2.lineTo(...points[6]);
      path2.lineTo(...points[7]);
      path2.closePath();
      path2.moveTo(...points[8]);
      path2.lineTo(...points[9]);
      path2.moveTo(...points[10]);
      path2.lineTo(...points[11]);
      path2.moveTo(...points[12]);
      path2.lineTo(...points[13]);
    } else {
      const center2 = coordinate.getCenter();
      const [x3, y3] = center2;
      const startAngle = angle3(sub6(points[0], center2));
      const endAngle = angle3(sub6(points[1], center2));
      const radiusHigh = dist4(center2, points[2]);
      const radiusQ3 = dist4(center2, points[3]);
      const radiusMedian = dist4(center2, points[8]);
      const radiusQ1 = dist4(center2, points[10]);
      const radiusLow = dist4(center2, points[11]);
      path2.moveTo(...points[0]);
      path2.arc(x3, y3, radiusHigh, startAngle, endAngle);
      path2.arc(x3, y3, radiusHigh, endAngle, startAngle, true);
      path2.moveTo(...points[2]);
      path2.lineTo(...points[3]);
      path2.moveTo(...points[4]);
      path2.arc(x3, y3, radiusQ3, startAngle, endAngle);
      path2.lineTo(...points[6]);
      path2.arc(x3, y3, radiusQ1, endAngle, startAngle, true);
      path2.closePath();
      path2.moveTo(...points[8]);
      path2.arc(x3, y3, radiusMedian, startAngle, endAngle);
      path2.arc(x3, y3, radiusMedian, endAngle, startAngle, true);
      path2.moveTo(...points[10]);
      path2.lineTo(...points[11]);
      path2.moveTo(...points[12]);
      path2.arc(x3, y3, radiusLow, startAngle, endAngle);
      path2.arc(x3, y3, radiusLow, endAngle, startAngle, true);
    }
    return path2;
  }
  var Box = (options, context) => {
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: color2, transform } = value2;
      const { color: defaultColor, fill = defaultColor, stroke: stroke2 = defaultColor } = defaults5, rest = __rest32(defaults5, ["color", "fill", "stroke"]);
      const path2 = getPath2(points, coordinate);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", stroke2).style("fill", color2 || fill).style("transform", transform).call(applyStyle, options).node();
    };
  };
  Box.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/box/violin.js
  var __rest33 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function getPath3(p2, coordinate, size2 = 4) {
    const path2 = path();
    if (!isPolar(coordinate)) {
      path2.moveTo(...p2[2]);
      path2.lineTo(...p2[3]);
      path2.lineTo(p2[3][0] - size2, p2[3][1]);
      path2.lineTo(p2[10][0] - size2, p2[10][1]);
      path2.lineTo(p2[10][0] + size2, p2[10][1]);
      path2.lineTo(p2[3][0] + size2, p2[3][1]);
      path2.lineTo(...p2[3]);
      path2.closePath();
      path2.moveTo(...p2[10]);
      path2.lineTo(...p2[11]);
      path2.moveTo(p2[3][0] + size2 / 2, p2[8][1]);
      path2.arc(p2[3][0], p2[8][1], size2 / 2, 0, Math.PI * 2);
      path2.closePath();
      return path2;
    }
    const center2 = coordinate.getCenter();
    const [x3, y3] = center2;
    const radiusQ3 = dist4(center2, p2[3]);
    const radiusMedian = dist4(center2, p2[8]);
    const radiusQ1 = dist4(center2, p2[10]);
    const middleAngle = angle3(sub6(p2[2], center2));
    const rectAngle = Math.asin(size2 / radiusMedian);
    const startAngle = middleAngle - rectAngle;
    const endAngle = middleAngle + rectAngle;
    path2.moveTo(...p2[2]);
    path2.lineTo(...p2[3]);
    path2.moveTo(Math.cos(startAngle) * radiusQ3 + x3, Math.sin(startAngle) * radiusQ3 + y3);
    path2.arc(x3, y3, radiusQ3, startAngle, endAngle);
    path2.lineTo(Math.cos(endAngle) * radiusQ1 + x3, Math.sin(endAngle) * radiusQ1 + y3);
    path2.arc(x3, y3, radiusQ1, endAngle, startAngle, true);
    path2.lineTo(Math.cos(startAngle) * radiusQ3 + x3, Math.sin(startAngle) * radiusQ3 + y3);
    path2.closePath();
    path2.moveTo(...p2[10]);
    path2.lineTo(...p2[11]);
    const a3 = (startAngle + endAngle) / 2;
    path2.moveTo(Math.cos(a3) * (radiusMedian + size2 / 2) + x3, Math.sin(a3) * (radiusMedian + size2 / 2) + y3);
    path2.arc(Math.cos(a3) * radiusMedian + x3, Math.sin(a3) * radiusMedian + y3, size2 / 2, a3, Math.PI * 2 + a3);
    path2.closePath();
    return path2;
  }
  var Violin = (options, context) => {
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: color2, transform } = value2;
      const size2 = 4;
      const { color: defaultColor, fill = defaultColor, stroke: stroke2 = defaultColor } = defaults5, rest = __rest33(defaults5, ["color", "fill", "stroke"]);
      const path2 = getPath3(points, coordinate, size2);
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", stroke2).style("fill", color2 || fill).style("transform", transform).call(applyStyle, options).node();
    };
  };
  Violin.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/lineXY/line.js
  var __rest34 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function getArrowMarker(document2, arrowSize, arrowStyle) {
    const arrowMarker = document2.createElement("path", {
      style: Object.assign({ d: `M ${arrowSize},${arrowSize} L -${arrowSize},0 L ${arrowSize},-${arrowSize} L 0,0 Z`, transformOrigin: "center" }, arrowStyle)
    });
    return arrowMarker;
  }
  function getPath4(points, coordinate) {
    if (!isPolar(coordinate))
      return line_default().x((d2) => d2[0]).y((d2) => d2[1])(points);
    const center2 = coordinate.getCenter();
    return arc_default()({
      startAngle: 0,
      endAngle: Math.PI * 2,
      outerRadius: dist4(points[0], center2),
      innerRadius: dist4(points[1], center2)
    });
  }
  function getTransform2(coordinate, transform) {
    if (!isPolar(coordinate))
      return transform;
    const [cx, cy] = coordinate.getCenter();
    return `translate(${cx}, ${cy}) ${transform || ""}`;
  }
  var Line4 = (options, context) => {
    const { arrow, arrowSize = 4 } = options, style = __rest34(options, ["arrow", "arrowSize"]);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor, lineWidth } = defaults5, shapeTheme = __rest34(defaults5, ["color", "lineWidth"]);
      const { color: color2 = defaultColor, size: size2 = lineWidth } = value2;
      const arrowMarker = arrow ? getArrowMarker(document2, arrowSize, Object.assign({ fill: style.stroke || color2, stroke: style.stroke || color2 }, subObject(style, "arrow"))) : null;
      const path2 = getPath4(points, coordinate);
      const transform = getTransform2(coordinate, value2.transform);
      return select(document2.createElement("path", {})).call(applyStyle, shapeTheme).style("d", path2).style("stroke", color2).style("lineWidth", size2).style("transform", transform).style("markerEnd", arrowMarker).call(applyStyle, style).node();
    };
  };
  Line4.props = {
    defaultMarker: "line",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/connector/connector.js
  var __rest35 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function inferSymbol(x3, y3, r) {
    return [["M", x3, y3], ["L", x3 + 2 * r, y3 - r], ["L", x3 + 2 * r, y3 + r], ["Z"]];
  }
  function inferConnectorPath2(points) {
    return line_default().x((d2) => d2[0]).y((d2) => d2[1])(points);
  }
  function getPoints(coordinate, points, offset1, offset22, length1 = 0) {
    const [[x05, y05], [x12, y12]] = points;
    if (isTranspose(coordinate)) {
      const X02 = x05 + offset1;
      const X12 = x12 + offset22;
      const X = X02 + length1;
      return [
        [X02, y05],
        [X, y05],
        [X, y12],
        [X12, y12]
      ];
    }
    const Y02 = y05 - offset1;
    const Y12 = y12 - offset22;
    const Y = Y02 - length1;
    return [
      [x05, Y02],
      [x05, Y],
      [x12, Y],
      [x12, Y12]
    ];
  }
  var Connector = (options, context) => {
    const { offset: offset3 = 0, offset1 = offset3, offset2: offset22 = offset3, connectLength1: length1, endMarker = true } = options, style = __rest35(options, ["offset", "offset1", "offset2", "connectLength1", "endMarker"]);
    const { coordinate } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor, connectLength1 } = defaults5, rest = __rest35(defaults5, ["color", "connectLength1"]);
      const { color: color2, transform } = value2;
      const P = getPoints(coordinate, points, offset1, offset22, length1 !== null && length1 !== void 0 ? length1 : connectLength1);
      const makerStyle = subObject(Object.assign(Object.assign({}, style), defaults5), "endMarker");
      return select(new Path2()).call(applyStyle, rest).style("d", inferConnectorPath2(P)).style("stroke", color2 || defaultColor).style("transform", transform).style("markerEnd", endMarker ? new Marker({
        className: "marker",
        style: Object.assign(Object.assign({}, makerStyle), { symbol: inferSymbol })
      }) : null).call(applyStyle, style).node();
    };
  };
  Connector.props = {
    defaultMarker: "line",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/string.js
  function camelCase2(s2) {
    return s2.replace(/-(\w)/g, function(_2, letter) {
      return letter.toUpperCase();
    });
  }
  function kebabCase(s2) {
    return s2.replace(/([A-Z])/g, "-$1").toLowerCase();
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/label/position/index.js
  var position_exports = {};
  __export(position_exports, {
    area: () => area,
    bottom: () => getDefaultStyle,
    bottomLeft: () => getDefaultStyle,
    bottomRight: () => getDefaultStyle,
    inside: () => getDefaultStyle,
    left: () => getDefaultStyle,
    outside: () => outside,
    right: () => getDefaultStyle,
    spider: () => spider,
    surround: () => surround,
    top: () => getDefaultStyle,
    topLeft: () => getDefaultStyle,
    topRight: () => getDefaultStyle
  });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/label/position/area.js
  function area(position, points, value2, coordinate) {
    const l2 = points.length / 2;
    const Y12 = points.slice(0, l2);
    const Y02 = points.slice(l2);
    let idx = maxIndex(Y12, (p2, i) => Math.abs(p2[1] - Y02[i][1]));
    idx = Math.max(Math.min(idx, l2 - 2), 1);
    const mid2 = (i) => [Y12[i][0], (Y12[i][1] + Y02[i][1]) / 2];
    const point6 = mid2(idx);
    const prev = mid2(idx - 1);
    const next = mid2(idx + 1);
    const rotate4 = angle3(sub6(next, prev)) / Math.PI * 180;
    return {
      x: point6[0],
      y: point6[1],
      transform: `rotate(${rotate4})`,
      textAlign: "center",
      textBaseline: "middle"
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/label/position/default.js
  function inferNonCircularStyle(position, points, value2, coordinate) {
    const { bounds } = value2;
    const [[x05, y05], [x12, y12]] = bounds;
    const w = x12 - x05;
    const h = y12 - y05;
    const xy = (options) => {
      const { x: ox, y: oy } = options;
      const px = maybePercentage(value2.x, w);
      const py = maybePercentage(value2.y, h);
      return Object.assign(Object.assign({}, options), { x: (px || ox) + x05, y: (py || oy) + y05 });
    };
    if (position === "left")
      return xy({ x: 0, y: h / 2, textAlign: "start", textBaseline: "middle" });
    if (position === "right")
      return xy({ x: w, y: h / 2, textAlign: "end", textBaseline: "middle" });
    if (position === "top")
      return xy({ x: w / 2, y: 0, textAlign: "center", textBaseline: "top" });
    if (position === "bottom")
      return xy({ x: w / 2, y: h, textAlign: "center", textBaseline: "bottom" });
    if (position === "top-left")
      return xy({ x: 0, y: 0, textAlign: "start", textBaseline: "top" });
    if (position === "top-right")
      return xy({ x: w, y: 0, textAlign: "end", textBaseline: "top" });
    if (position === "bottom-left")
      return xy({ x: 0, y: h, textAlign: "start", textBaseline: "bottom" });
    if (position === "bottom-right")
      return xy({ x: w, y: h, textAlign: "end", textBaseline: "bottom" });
    return xy({
      x: w / 2,
      y: h / 2,
      textAlign: "center",
      textBaseline: "middle"
    });
  }
  function inferRadialStyle(position, points, value2, coordinate) {
    const { y: y3, y1: y12, autoRotate, rotateToAlignArc } = value2;
    const center2 = coordinate.getCenter();
    const arcObject = getArcObject(coordinate, points, [y3, y12]);
    const { innerRadius, outerRadius, startAngle, endAngle } = arcObject;
    const angle4 = position === "inside" ? (startAngle + endAngle) / 2 : endAngle;
    const rotate4 = inferRotation(angle4, autoRotate, rotateToAlignArc);
    const point6 = (() => {
      const [p0, p1] = points;
      const radius = innerRadius + (outerRadius - innerRadius) * 0.5;
      const [x3, y4] = position === "inside" ? pointOfArc(center2, angle4, radius) : mid(p0, p1);
      return { x: x3, y: y4 };
    })();
    return Object.assign(Object.assign({}, point6), { textAlign: position === "inside" ? "center" : "start", textBaseline: "middle", rotate: rotate4 });
  }
  function pointOfArc(center2, angle4, radius) {
    return [
      center2[0] + Math.sin(angle4) * radius,
      center2[1] - Math.cos(angle4) * radius
    ];
  }
  function inferRotation(angle4, autoRotate, rotateToAlignArc) {
    if (!autoRotate)
      return 0;
    const append3 = rotateToAlignArc ? 0 : Math.sin(angle4) < 0 ? 90 : -90;
    return angle4 / Math.PI * 180 + append3;
  }
  function inferInnerCircularStyle(position, points, value2, coordinate) {
    const { y: y3, y1: y12, autoRotate, rotateToAlignArc, radius: radiusRatio = 0.5, offset: offset3 = 0 } = value2;
    const arcObject = getArcObject(coordinate, points, [y3, y12]);
    const { startAngle, endAngle } = arcObject;
    const center2 = coordinate.getCenter();
    const angle4 = (startAngle + endAngle) / 2;
    const rotate4 = inferRotation(angle4, autoRotate, rotateToAlignArc);
    const textStyle = { textAlign: "center", textBaseline: "middle", rotate: rotate4 };
    const { innerRadius, outerRadius } = arcObject;
    const r0 = innerRadius + (outerRadius - innerRadius) * radiusRatio;
    const r1 = r0 + offset3;
    const [x05, y05] = pointOfArc(center2, angle4, r1);
    return Object.assign({ x: x05, y: y05 }, textStyle);
  }
  function maybeUndefined(d2) {
    return d2 === void 0 ? null : d2;
  }
  function inferIdentityStyle(position, points, value2, coordinate) {
    const { bounds } = value2;
    const [p2] = bounds;
    return {
      x: maybeUndefined(p2[0]),
      y: maybeUndefined(p2[1])
    };
  }
  function getDefaultStyle(position, points, value2, coordinate) {
    const { bounds } = value2;
    if (bounds.length === 1) {
      return inferIdentityStyle(position, points, value2, coordinate);
    }
    const inferDefaultStyle2 = isRadial(coordinate) ? inferRadialStyle : isCircular(coordinate) ? inferInnerCircularStyle : inferNonCircularStyle;
    return inferDefaultStyle2(position, points, value2, coordinate);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/label/position/outside.js
  function linePoints(center2, angle4, radius, radius1, offsetX) {
    const [x05, y05] = pointOfArc(center2, angle4, radius);
    const [x12, y12] = pointOfArc(center2, angle4, radius1);
    const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
    return [
      [x05, y05],
      [x12, y12],
      [x12 + sign3 * offsetX, y12]
    ];
  }
  function radiusOf2(points, value2, coordinate) {
    const arcObject = getArcObject(coordinate, points, [value2.y, value2.y1]);
    const { innerRadius, outerRadius } = arcObject;
    return innerRadius + (outerRadius - innerRadius);
  }
  function angleOf2(points, value2, coordinate) {
    const arcObject = getArcObject(coordinate, points, [value2.y, value2.y1]);
    const { startAngle, endAngle } = arcObject;
    return (startAngle + endAngle) / 2;
  }
  function inferOutsideCircularStyle(position, points, value2, coordinate) {
    const { autoRotate, rotateToAlignArc, offset: offset3 = 0, connector = true, connectorLength = offset3, connectorLength2 = 0, connectorDistance = 0 } = value2;
    const center2 = coordinate.getCenter();
    const angle4 = angleOf2(points, value2, coordinate);
    const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
    const rotate4 = inferRotation(angle4, autoRotate, rotateToAlignArc);
    const textStyle = {
      textAlign: sign3 > 0 || isRadial(coordinate) ? "start" : "end",
      textBaseline: "middle",
      rotate: rotate4
    };
    const radius = radiusOf2(points, value2, coordinate);
    const radius1 = radius + (connector ? connectorLength : offset3);
    const [[x05, y05], [x12, y12], [x22, y22]] = linePoints(center2, angle4, radius, radius1, connector ? connectorLength2 : 0);
    const dx = connector ? +connectorDistance * sign3 : 0;
    const x3 = x22 + dx;
    const y3 = y22;
    const connectorStyle = {
      connector,
      connectorPoints: [
        [x12 - x3, y12 - y3],
        [x22 - x3, y22 - y3]
      ]
    };
    return Object.assign(Object.assign({
      x0: x05,
      y0: y05,
      x: x22 + dx,
      y: y22
    }, textStyle), connectorStyle);
  }
  function outside(position, points, value2, coordinate) {
    const { bounds } = value2;
    if (bounds.length === 1) {
      return inferIdentityStyle(position, points, value2, coordinate);
    }
    const inferDefaultStyle2 = isRadial(coordinate) ? inferRadialStyle : isCircular(coordinate) ? inferOutsideCircularStyle : inferNonCircularStyle;
    return inferDefaultStyle2(position, points, value2, coordinate);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/label/position/utils.js
  function dodgeY(labels, options = {}) {
    const { labelHeight = 14, height } = options;
    const sortedLabels = sort2(labels, (d2) => d2.y);
    const n2 = sortedLabels.length;
    const boxes = new Array(n2);
    for (let i2 = 0; i2 < n2; i2++) {
      const label = sortedLabels[i2];
      const { y: y3 } = label;
      boxes[i2] = { y: y3, y1: y3 + labelHeight, labels: [y3] };
    }
    let overlap = true;
    while (overlap) {
      overlap = false;
      for (let i2 = boxes.length - 1; i2 > 0; i2--) {
        const box2 = boxes[i2];
        const preBox = boxes[i2 - 1];
        if (preBox.y1 > box2.y) {
          overlap = true;
          preBox.labels.push(...box2.labels);
          boxes.splice(i2, 1);
          preBox.y1 += box2.y1 - box2.y;
          const newHeight = preBox.y1 - preBox.y;
          preBox.y1 = Math.max(Math.min(preBox.y1, height), newHeight);
          preBox.y = preBox.y1 - newHeight;
        }
      }
    }
    let i = 0;
    for (const box2 of boxes) {
      const { y: y3, labels: labels2 } = box2;
      let prevY = y3 - labelHeight;
      for (const curY of labels2) {
        const label = sortedLabels[i++];
        const expectedY = prevY + labelHeight;
        const dy = expectedY - curY;
        label.connectorPoints[0][1] -= dy;
        label.y = prevY + labelHeight;
        prevY += labelHeight;
      }
    }
  }
  function hideAndDodgeY(unsorted, options) {
    const labels = sort2(unsorted, (d2) => d2.y);
    const { height, labelHeight = 14 } = options;
    const maxCount = Math.ceil(height / labelHeight);
    if (labels.length <= maxCount)
      return dodgeY(labels, options);
    const filtered = [];
    for (let i = 0; i < labels.length; i++) {
      if (i < labels.length - maxCount) {
        labels[i].opacity = 0;
        labels[i].connector = false;
      } else
        filtered.push(labels[i]);
    }
    dodgeY(filtered, options);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/label/position/spider.js
  var __rest36 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var styleByPoints = /* @__PURE__ */ new WeakMap();
  function compute(points, value2, coordinate) {
    const { connectorLength, connectorLength2, connectorDistance } = value2;
    const style = __rest36(inferOutsideCircularStyle("outside", points, value2, coordinate), []);
    const center2 = coordinate.getCenter();
    const radius = radiusOf2(points, value2, coordinate);
    const angle4 = angleOf2(points, value2, coordinate);
    const radius1 = radius + connectorLength + connectorLength2;
    const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
    const newX = center2[0] + (radius1 + +connectorDistance) * sign3;
    const { x: originX } = style;
    const dx = newX - originX;
    style.x += dx;
    style.connectorPoints[0][0] -= dx;
    return style;
  }
  function spider(position, points, value2, coordinate, options, labels) {
    if (!isCircular(coordinate))
      return {};
    if (styleByPoints.has(points))
      return styleByPoints.get(points);
    const computed = labels.map((points2) => compute(points2, value2, coordinate));
    const { width, height } = coordinate.getOptions();
    const left2 = computed.filter((d2) => d2.x < width / 2);
    const right2 = computed.filter((d2) => d2.x >= width / 2);
    const extendedOptions = Object.assign(Object.assign({}, options), { height });
    hideAndDodgeY(left2, extendedOptions);
    hideAndDodgeY(right2, extendedOptions);
    computed.forEach((style, i) => styleByPoints.set(labels[i], style));
    return styleByPoints.get(points);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/label/position/surround.js
  var __rest37 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function surround(position, points, value2, coordinate) {
    if (!isCircular(coordinate))
      return {};
    const { connectorLength, connectorLength2, connectorDistance } = value2;
    const style = __rest37(inferOutsideCircularStyle("outside", points, value2, coordinate), []);
    const { x0: x05, y0: y05 } = style;
    const center2 = coordinate.getCenter();
    const radius = getRadius(coordinate);
    const radius1 = radius + connectorLength;
    const angle4 = angleWithQuadrant([x05 - center2[0], y05 - center2[1]]);
    const sign3 = Math.sin(angle4) > 0 ? 1 : -1;
    const [newX, newY] = pointOfArc(center2, angle4, radius1);
    style.x = newX + (connectorLength2 + connectorDistance) * sign3;
    style.y = newY;
    return style;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/label/label.js
  var __rest38 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function inferPosition(position, coordinate) {
    if (position !== void 0)
      return position;
    if (isCircular(coordinate))
      return "inside";
    if (isTranspose(coordinate))
      return "right";
    return "top";
  }
  function getDefaultStyle2(points, value2, coordinate, theme, options, labels) {
    const { position } = value2;
    const { render: render2 } = options;
    const p2 = inferPosition(position, coordinate);
    const labelType = render2 ? "htmlLabel" : p2 === "inside" ? "innerLabel" : "label";
    const t = theme[labelType];
    const v = Object.assign({}, t, value2);
    const processor = position_exports[camelCase2(p2)];
    if (!processor) {
      throw new Error(`Unknown position: ${p2}`);
    }
    return Object.assign(Object.assign({}, t), processor(p2, points, v, coordinate, options, labels));
  }
  var Label = (options, context) => {
    const { coordinate, theme } = context;
    const { render: render2 } = options;
    return (points, value2, style, labels) => {
      const { text, x: x3, y: y3, transform: specifiedTS = "", transformOrigin, className: className2 = "" } = value2, overrideStyle = __rest38(value2, ["text", "x", "y", "transform", "transformOrigin", "className"]);
      const _a = getDefaultStyle2(points, value2, coordinate, theme, options, labels), { rotate: rotate4 = 0, transform = "" } = _a, defaultStyle2 = __rest38(_a, ["rotate", "transform"]);
      return select(new Advance()).call(applyStyle, defaultStyle2).style("text", `${text}`).style("className", `${className2} g2-label`).style("innerHTML", render2 ? render2(text, value2.datum, value2.index) : void 0).style("labelTransform", `${transform} rotate(${+rotate4}) ${specifiedTS}`.trim()).style("labelTransformOrigin", transformOrigin).style("coordCenter", coordinate.getCenter()).call(applyStyle, overrideStyle).node();
    };
  };
  Label.props = {
    defaultMarker: "point"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/path/color.js
  var __rest39 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var Color4 = (options, context) => {
    const { arrow, colorAttribute } = options, style = __rest39(options, ["arrow", "colorAttribute"]);
    const { coordinate, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { color: defaultColor, stroke: stroke2 } = defaults5, rest = __rest39(defaults5, ["color", "stroke"]);
      const { d: d2, color: color2 = defaultColor } = value2;
      const [width, height] = coordinate.getSize();
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", typeof d2 === "function" ? d2({ width, height }) : d2).style(colorAttribute, color2).call(applyStyle, style).node();
    };
  };
  Color4.props = {
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/path/path.js
  var Path3 = (options, context) => {
    return Color4(Object.assign({ colorAttribute: "fill" }, options), context);
  };
  Path3.props = {
    defaultMarker: "hvh",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/path/hollow.js
  var Hollow2 = (options, context) => {
    return Color4(Object.assign({ fill: "none", colorAttribute: "stroke" }, options), context);
  };
  Hollow2.props = {
    defaultMarker: "hvh",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/density/density.js
  var __rest40 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var Density = (options, context) => {
    const { document: document2 } = context;
    return (points, value2, defaults5) => {
      const { transform } = value2;
      const { color: defaultColor } = defaults5, rest = __rest40(defaults5, ["color"]);
      const { color: color2 = defaultColor } = value2;
      const [first3, ...p2] = points;
      const path2 = path();
      path2.moveTo(...first3);
      p2.forEach(([x3, y3]) => {
        path2.lineTo(x3, y3);
      });
      path2.closePath();
      return select(document2.createElement("path", {})).call(applyStyle, rest).style("d", path2.toString()).style("stroke", color2 || defaultColor).style("fill", color2 || defaultColor).style("fillOpacity", 0.4).style("transform", transform).call(applyStyle, options).node();
    };
  };
  Density.props = {
    defaultMarker: "square",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/flru/dist/flru.mjs
  function flru_default(max10) {
    var num, curr, prev;
    var limit = max10 || 1;
    function keep(key, value2) {
      if (++num > limit) {
        prev = curr;
        reset(1);
        ++num;
      }
      curr[key] = value2;
    }
    function reset(isPartial) {
      num = 0;
      curr = /* @__PURE__ */ Object.create(null);
      isPartial || (prev = /* @__PURE__ */ Object.create(null));
    }
    reset();
    return {
      clear: reset,
      has: function(key) {
        return curr[key] !== void 0 || prev[key] !== void 0;
      },
      get: function(key) {
        var val = curr[key];
        if (val !== void 0) return val;
        if ((val = prev[key]) !== void 0) {
          keep(key, val);
          return val;
        }
      },
      set: function(key, value2) {
        if (curr[key] !== void 0) {
          curr[key] = value2;
        } else {
          keep(key, value2);
        }
      }
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/lru.js
  var cache2 = flru_default(3);
  function lru(fn, keyFn = (...args) => `${args[0]}`, maxSize = 16) {
    const cache3 = flru_default(maxSize);
    return (...args) => {
      const key = keyFn(...args);
      let v = cache3.get(key);
      if (cache3.has(key))
        return cache3.get(key);
      v = fn(...args);
      cache3.set(key, v);
      return v;
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/heatmap/renderer/gradient.js
  function parseGradient2(gradient) {
    if (typeof gradient === "string") {
      return gradient.split(" ").map((stop) => {
        const [r, c5] = stop.split(":");
        return [+r, c5];
      });
    }
    return gradient;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/heatmap/renderer/index.js
  function newCanvas(createCanvas, width, height) {
    const c5 = createCanvas ? createCanvas() : document.createElement("canvas");
    c5.width = width;
    c5.height = height;
    return c5;
  }
  var getPointTemplate = lru((radius, blurFactor, createCanvas) => {
    const tplCanvas = newCanvas(createCanvas, radius * 2, radius * 2);
    const tplCtx = tplCanvas.getContext("2d");
    const x3 = radius;
    const y3 = radius;
    if (blurFactor === 1) {
      tplCtx.beginPath();
      tplCtx.arc(x3, y3, radius, 0, 2 * Math.PI, false);
      tplCtx.fillStyle = "rgba(0,0,0,1)";
      tplCtx.fill();
    } else {
      const gradient = tplCtx.createRadialGradient(x3, y3, radius * blurFactor, x3, y3, radius);
      gradient.addColorStop(0, "rgba(0,0,0,1)");
      gradient.addColorStop(1, "rgba(0,0,0,0)");
      tplCtx.fillStyle = gradient;
      tplCtx.fillRect(0, 0, 2 * radius, 2 * radius);
    }
    return tplCanvas;
  }, (radius) => `${radius}`);
  function getColorPalette(gradientConfig, createCanvas) {
    const paletteCanvas = newCanvas(createCanvas, 256, 1);
    const paletteCtx = paletteCanvas.getContext("2d");
    const gradient = paletteCtx.createLinearGradient(0, 0, 256, 1);
    parseGradient2(gradientConfig).forEach(([r, c5]) => {
      gradient.addColorStop(r, c5);
    });
    paletteCtx.fillStyle = gradient;
    paletteCtx.fillRect(0, 0, 256, 1);
    return paletteCtx.getImageData(0, 0, 256, 1).data;
  }
  function drawAlpha(shadowCtx, min10, max10, data2, options, createCanvas) {
    const { blur } = options;
    let len5 = data2.length;
    while (len5--) {
      const { x: x3, y: y3, value: v, radius } = data2[len5];
      const value2 = Math.min(v, max10);
      const rectX = x3 - radius;
      const rectY = y3 - radius;
      const tpl = getPointTemplate(radius, 1 - blur, createCanvas);
      const templateAlpha = (value2 - min10) / (max10 - min10);
      shadowCtx.globalAlpha = Math.max(templateAlpha, 1e-3);
      shadowCtx.drawImage(tpl, rectX, rectY);
    }
    return shadowCtx;
  }
  function colorize(shadowCtx, maxWidth, maxHeight, palette, options) {
    const { minOpacity, opacity, maxOpacity, useGradientOpacity } = options;
    const x3 = 0;
    const y3 = 0;
    const width = maxWidth;
    const height = maxHeight;
    const img = shadowCtx.getImageData(x3, y3, width, height);
    const imgData = img.data;
    const len5 = imgData.length;
    for (let i = 3; i < len5; i += 4) {
      const alpha = imgData[i];
      const offset3 = alpha * 4;
      if (!offset3) {
        continue;
      }
      const finalAlpha = opacity || Math.max(0, Math.min(maxOpacity, Math.max(minOpacity, alpha)));
      imgData[i - 3] = palette[offset3];
      imgData[i - 2] = palette[offset3 + 1];
      imgData[i - 1] = palette[offset3 + 2];
      imgData[i] = useGradientOpacity ? palette[offset3 + 3] : finalAlpha;
    }
    return img;
  }
  function HeatmapRenderer(width, height, min10, max10, data2, options, createCanvas) {
    const opts = Object.assign({ blur: 0.85, minOpacity: 0, opacity: 0.6, maxOpacity: 1, gradient: [
      [0.25, "rgb(0,0,255)"],
      [0.55, "rgb(0,255,0)"],
      [0.85, "yellow"],
      [1, "rgb(255,0,0)"]
    ] }, options);
    opts.minOpacity *= 255;
    opts.opacity *= 255;
    opts.maxOpacity *= 255;
    const shadowCanvas = newCanvas(createCanvas, width, height);
    const shadowCtx = shadowCanvas.getContext("2d");
    const palette = getColorPalette(opts.gradient, createCanvas);
    shadowCtx.clearRect(0, 0, width, height);
    drawAlpha(shadowCtx, min10, max10, data2, opts, createCanvas);
    const img = colorize(shadowCtx, width, height, palette, opts);
    const canvas = newCanvas(createCanvas, width, height);
    const ctx2 = canvas.getContext("2d");
    ctx2.putImageData(img, 0, 0);
    return ctx2;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/heatmap/heatmap.js
  var __rest41 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function deleteKey(obj, fn) {
    return Object.keys(obj).reduce((r, k) => {
      const v = obj[k];
      if (!fn(v, k))
        r[k] = v;
      return r;
    }, {});
  }
  var Heatmap = (options, context) => {
    const { gradient, opacity, maxOpacity, minOpacity, blur, useGradientOpacity } = options, style = __rest41(options, ["gradient", "opacity", "maxOpacity", "minOpacity", "blur", "useGradientOpacity"]);
    const { coordinate, createCanvas, document: document2 } = context;
    return (points, value2, defaults5) => {
      const { transform } = value2;
      const [width, height] = coordinate.getSize();
      const data2 = points.map((p2) => ({
        x: p2[0],
        y: p2[1],
        value: p2[2],
        radius: p2[3]
      }));
      const min10 = min4(points, (p2) => p2[2]);
      const max10 = max4(points, (p2) => p2[2]);
      const options2 = {
        gradient,
        opacity,
        minOpacity,
        maxOpacity,
        blur,
        useGradientOpacity
      };
      const ctx2 = width && height ? HeatmapRenderer(width, height, min10, max10, data2, deleteKey(options2, (v) => v === void 0), createCanvas) : { canvas: null };
      return select(document2.createElement("image", {})).call(applyStyle, defaults5).style("x", 0).style("y", 0).style("width", width).style("height", height).style("src", ctx2.canvas).style("transform", transform).call(applyStyle, style).node();
    };
  };
  Heatmap.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/shape/shape.js
  var __rest42 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var Shape2 = (options, context) => {
    const { render: render2 } = options, rest = __rest42(options, ["render"]);
    return (points) => {
      const [[x05, y05]] = points;
      return render2(Object.assign(Object.assign({}, rest), { x: x05, y: y05 }), context);
    };
  };
  Shape2.props = {
    defaultMarker: "point",
    defaultEnterAnimation: "fadeIn",
    defaultUpdateAnimation: "morphing",
    defaultExitAnimation: "fadeOut"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/liquid/wave.js
  var DURATION = 5e3;
  function lerp5(min10, max10, factor) {
    return min10 + (max10 - min10) * factor;
  }
  function getWaterWavePositions(x3, stage, waveLength, amplitude) {
    if (stage === 0) {
      return [
        [x3 + 1 / 2 * waveLength / Math.PI / 2, amplitude / 2],
        [x3 + 1 / 2 * waveLength / Math.PI, amplitude],
        [x3 + waveLength / 4, amplitude]
      ];
    }
    if (stage === 1) {
      return [
        [x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude],
        [
          x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
          amplitude / 2
        ],
        [x3 + waveLength / 4, 0]
      ];
    }
    if (stage === 2) {
      return [
        [x3 + 1 / 2 * waveLength / Math.PI / 2, -amplitude / 2],
        [x3 + 1 / 2 * waveLength / Math.PI, -amplitude],
        [x3 + waveLength / 4, -amplitude]
      ];
    }
    return [
      [x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude],
      [
        x3 + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1),
        -amplitude / 2
      ],
      [x3 + waveLength / 4, 0]
    ];
  }
  function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude, cx, cy) {
    const curves = Math.ceil(2 * radius / waveLength * 4) * 4;
    const path2 = [];
    let _phase = phase;
    while (_phase < -Math.PI * 2) {
      _phase += Math.PI * 2;
    }
    while (_phase > 0) {
      _phase -= Math.PI * 2;
    }
    _phase = _phase / Math.PI / 2 * waveLength;
    const left2 = cx - radius + _phase - radius * 2;
    path2.push(["M", left2, waterLevel]);
    let waveRight = 0;
    for (let c5 = 0; c5 < curves; ++c5) {
      const stage = c5 % 4;
      const pos = getWaterWavePositions(c5 * waveLength / 4, stage, waveLength, amplitude);
      path2.push([
        "C",
        pos[0][0] + left2,
        -pos[0][1] + waterLevel,
        pos[1][0] + left2,
        -pos[1][1] + waterLevel,
        pos[2][0] + left2,
        -pos[2][1] + waterLevel
      ]);
      if (c5 === curves - 1) {
        waveRight = pos[2][0];
      }
    }
    path2.push(["L", waveRight + left2, cy + radius]);
    path2.push(["L", left2, cy + radius]);
    path2.push(["Z"]);
    return path2;
  }
  function addWave(x3, y3, level, waveCount, waveAttrs, group3, minY, radius, waveLength, animation, document2) {
    const { fill, fillOpacity, opacity } = waveAttrs;
    for (let idx = 0; idx < waveCount; idx++) {
      const factor = waveCount <= 1 ? 1 : idx / (waveCount - 1);
      const path2 = getWaterWavePath(
        radius,
        minY + radius * level,
        waveLength,
        0,
        // Amplitude height.
        radius / 40,
        x3,
        y3
      );
      const wave = document2.createElement("path", {
        style: {
          d: path2,
          fill,
          opacity: lerp5(0.2, 0.9, factor) * Number(opacity || fillOpacity)
        }
      });
      group3.appendChild(wave);
      try {
        if (animation === false)
          return;
        const keyframes = [
          {
            transform: "translate(0, 0)"
          },
          {
            transform: `translate(${waveLength * 2}, 0)`
          }
        ];
        wave.animate(keyframes, {
          duration: lerp5(0.5 * DURATION, DURATION, factor) * 2,
          iterations: Infinity
        });
      } catch (e3) {
        console.warn("off-screen group animate error!");
      }
    }
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/liquid/shapes.js
  function circle2(x3, y3, r) {
    return `
      M ${x3} ${y3 - r} 
      a ${r} ${r} 0 1 0 0 ${r * 2}
      a ${r} ${r} 0 1 0 0 ${-r * 2}
      Z
    `;
  }
  function rect3(x3, y3, r) {
    const GOLDEN_SECTION_RATIO = 0.618;
    const w = r * GOLDEN_SECTION_RATIO;
    return `
      M ${x3 - w} ${y3 - r}
      L ${x3 + w} ${y3 - r}
      L ${x3 + w} ${y3 + r}
      L ${x3 - w} ${y3 + r}
      Z
    `;
  }
  function diamond3(x3, y3, r) {
    return `
      M ${x3} ${y3 - r}
      L ${x3 + r} ${y3}
      L ${x3} ${y3 + r}
      L ${x3 - r} ${y3}
      Z
    `;
  }
  function triangle3(x3, y3, r) {
    return `
      M ${x3} ${y3 - r}
      L ${x3 + r} ${y3 + r}
      L ${x3 - r} ${y3 + r}
      Z
    `;
  }
  function pin(x3, y3, radius) {
    const w = radius * 4 / 3;
    const h = Math.max(w, radius * 2);
    const r = w / 2;
    const cx = x3;
    const cy = r + y3 - h / 2;
    const theta = Math.asin(r / ((h - r) * 0.85));
    const dy = Math.sin(theta) * r;
    const dx = Math.cos(theta) * r;
    const x05 = cx - dx;
    const y05 = cy + dy;
    const cpX = x3;
    const cpY = cy + r / Math.sin(theta);
    return `
      M ${x05} ${y05}
      A ${r} ${r} 0 1 1 ${x05 + dx * 2} ${y05}
      Q ${cpX} ${cpY} ${x3} ${y3 + h / 2}
      Q ${cpX} ${cpY} ${x05} ${y05}
      Z 
    `;
  }
  var LiquidShapesPath = {
    pin,
    rect: rect3,
    circle: circle2,
    diamond: diamond3,
    triangle: triangle3
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/liquid/liquid.js
  var __rest43 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var getLiquidShape = (shape23 = "circle") => LiquidShapesPath[shape23] || LiquidShapesPath.circle;
  var Liquid = (options, context) => {
    if (!context)
      return;
    const { coordinate } = context;
    const { liquidOptions, styleOptions } = options;
    const { liquidShape, percent } = liquidOptions;
    const { background: backgroundStyle, outline = {}, wave = {} } = styleOptions, attr2 = __rest43(styleOptions, ["background", "outline", "wave"]);
    const { border = 2, distance: distance8 = 0 } = outline, outlineStyle = __rest43(outline, ["border", "distance"]);
    const { length: length5 = 192, count: count4 = 3 } = wave;
    return (points, cfg, defaultAttr) => {
      const { document: document2 } = context.canvas;
      const { color: color2, fillOpacity } = defaultAttr;
      const attrs = Object.assign(Object.assign({ fill: color2 }, defaultAttr), attr2);
      const g = document2.createElement("g", {});
      const [centerX, centerY] = coordinate.getCenter();
      const size2 = coordinate.getSize();
      const radius = Math.min(...size2) / 2;
      const buildPath = is_function_default(liquidShape) ? liquidShape : getLiquidShape(liquidShape);
      const shapePath = buildPath(centerX, centerY, radius, ...size2);
      if (Object.keys(backgroundStyle).length) {
        const backgroundShape = document2.createElement("path", {
          style: Object.assign({ d: shapePath, fill: "#fff" }, backgroundStyle)
        });
        g.appendChild(backgroundShape);
      }
      if (percent > 0) {
        const clipShape = document2.createElement("path", {
          style: {
            d: shapePath
          }
        });
        g.appendChild(clipShape);
        g.style.clipPath = clipShape;
        addWave(centerX, centerY, 1 - percent, count4, attrs, g, clipShape.getBBox().y, radius * 2, length5, true, document2);
      }
      const distanceShape = document2.createElement("path", {
        style: {
          d: shapePath,
          fill: "transparent",
          lineWidth: border + 2 * distance8,
          stroke: "#fff"
        }
      });
      const borderShape = document2.createElement("path", {
        style: Object.assign(Object.assign(Object.assign({ d: shapePath, stroke: color2, strokeOpacity: fillOpacity, lineWidth: border }, attrs), outlineStyle), { fill: "transparent" })
      });
      g.appendChild(distanceShape);
      g.appendChild(borderShape);
      return g;
    };
  };
  Liquid.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/shape/gauge/round.js
  var getR = (point1, point22) => {
    return Math.sqrt(Math.pow(point1[0] - point22[0], 2) + Math.pow(point1[1] - point22[1], 2)) / 2;
  };
  var Round = (options, context) => {
    if (!context)
      return;
    const { coordinate } = context;
    if (!(coordinate === null || coordinate === void 0 ? void 0 : coordinate.getCenter))
      return;
    const center2 = coordinate.getCenter();
    return (points, cfg, defaultCfg) => {
      const { document: document2 } = context.canvas;
      const { color: color2, index: index4 } = cfg;
      const g = document2.createElement("g", {});
      const minR = getR(points[0], points[1]);
      const maxR = getR(points[0], center2) * 2;
      const roundPath = document2.createElement("path", {
        style: Object.assign(Object.assign(Object.assign({ d: [
          ["M", ...points[0]],
          ["A", minR, minR, 0, 1, 0, ...points[1]],
          ["A", maxR + minR * 2, maxR + minR * 2, 0, 0, 0, ...points[2]],
          ["A", minR, minR, 0, 1, index4 === 0 ? 0 : 1, ...points[3]],
          ["A", maxR, maxR, 0, 0, 1, ...points[0]],
          ["Z"]
        ] }, defaultCfg), omit_default(options, ["shape", "last", "first"])), { fill: color2 || defaultCfg.color })
      });
      g.appendChild(roundPath);
      return g;
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/interval.js
  function bandWidth2(scale9, x3) {
    return scale9.getBandWidth(scale9.invert(x3));
  }
  var shape = {
    rect: Rect2,
    hollow: Hollow,
    funnel: Funnel,
    pyramid: Pyramid
  };
  var Interval2 = () => {
    return (index4, scale9, value2, coordinate) => {
      const { x: X, y: Y, y1: Y12, series: S, size: SZ } = value2;
      const x3 = scale9.x;
      const series = scale9.series;
      const [width] = coordinate.getSize();
      const NSZ = SZ ? SZ.map((d2) => +d2 / width) : null;
      const x1x2 = !SZ ? (x4, w, i) => [x4, x4 + w] : (x4, w, i) => {
        const mx = x4 + w / 2;
        const s2 = NSZ[i];
        return [mx - s2 / 2, mx + s2 / 2];
      };
      const P = Array.from(index4, (i) => {
        const groupWidth = bandWidth2(x3, X[i]);
        const ratio = series ? bandWidth2(series, S === null || S === void 0 ? void 0 : S[i]) : 1;
        const width2 = groupWidth * ratio;
        const offset3 = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
        const x05 = +X[i] + offset3;
        const [x12, x22] = x1x2(x05, width2, i);
        const y12 = +Y[i];
        const y22 = +Y12[i];
        const p1 = [x12, y12];
        const p2 = [x22, y12];
        const p3 = [x22, y22];
        const p4 = [x12, y22];
        return [p1, p2, p3, p4].map((d2) => coordinate.map(d2));
      });
      return [index4, P];
    };
  };
  Interval2.props = {
    defaultShape: "rect",
    defaultLabelShape: "label",
    composite: false,
    shape,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape) }),
      { name: "x", scale: "band", required: true },
      { name: "y", required: true },
      { name: "series", scale: "band" },
      { name: "size" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeZeroY1 },
      { type: MaybeZeroX }
    ],
    postInference: [...basePostInference(), ...tooltip1d()],
    interaction: { shareTooltip: true }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/rect.js
  var shape2 = {
    rect: Rect2,
    hollow: Hollow
  };
  var Rect3 = () => {
    return (index4, scale9, value2, coordinate) => {
      const { x: X, x1: X12, y: Y, y1: Y12 } = value2;
      const P = Array.from(index4, (i) => {
        const p1 = [+X[i], +Y[i]];
        const p2 = [+X12[i], +Y[i]];
        const p3 = [+X12[i], +Y12[i]];
        const p4 = [+X[i], +Y12[i]];
        return [p1, p2, p3, p4].map((d2) => coordinate.map(d2));
      });
      return [index4, P];
    };
  };
  Rect3.props = {
    defaultShape: "rect",
    defaultLabelShape: "label",
    composite: false,
    shape: shape2,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape2) }),
      { name: "x", required: true },
      { name: "y", required: true }
    ],
    preInference: [...basePreInference(), { type: MaybeZeroY1 }],
    postInference: [...basePostInference(), ...tooltip1d()],
    interaction: {
      shareTooltip: true
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/line.js
  var shape3 = {
    line: Line2,
    smooth: Smooth,
    hv: HV,
    vh: VH,
    hvh: HVH,
    trail: Trail
  };
  var line3 = (index4, scale9, value2, coordinate) => {
    var _a, _b;
    const { series: S, x: X, y: Y } = value2;
    const { x: x3, y: y3 } = scale9;
    if (X === void 0 || Y === void 0) {
      throw new Error("Missing encode for x or y channel.");
    }
    const series = S ? Array.from(group(index4, (i) => S[i]).values()) : [index4];
    const I = series.map((group3) => group3[0]).filter((i) => i !== void 0);
    const xoffset = (((_a = x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(x3)) || 0) / 2;
    const yoffset = (((_b = y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y3)) || 0) / 2;
    const P = Array.from(series, (I2) => {
      return I2.map((i) => coordinate.map([+X[i] + xoffset, +Y[i] + yoffset]));
    });
    return [I, P, series];
  };
  var parallel = (index4, scale9, value2, coordinate) => {
    const PV = Object.entries(value2).filter(([key]) => key.startsWith("position")).map(([, value3]) => value3);
    if (PV.length === 0) {
      throw new Error("Missing encode for position channel.");
    }
    const P = Array.from(index4, (i) => {
      const vector = PV.map((pv) => +pv[i]);
      const vectors = coordinate.map(vector);
      const points = [];
      for (let i2 = 0; i2 < vectors.length; i2 += 2) {
        points.push([vectors[i2], vectors[i2 + 1]]);
      }
      return points;
    });
    return [index4, P];
  };
  var Line5 = () => {
    return (index4, scale9, value2, coordinate) => {
      const mark = isParallel(coordinate) ? parallel : line3;
      return mark(index4, scale9, value2, coordinate);
    };
  };
  Line5.props = {
    defaultShape: "line",
    defaultLabelShape: "label",
    composite: false,
    shape: shape3,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape3) }),
      { name: "x" },
      { name: "y" },
      { name: "position", independent: true },
      { name: "size" },
      { name: "series", scale: "band" }
    ],
    preInference: [
      ...basePreInference(),
      // !!!Note This order is very important.
      { type: MaybeGradient },
      { type: MaybeSeries }
    ],
    postInference: [...basePostInference(), ...tooltip1d(), ...tooltipXd()],
    interaction: {
      shareTooltip: true,
      seriesTooltip: true,
      crosshairs: true
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/point.js
  var shape4 = {
    hollow: HollowPoint,
    hollowDiamond: HollowDiamond,
    hollowHexagon: HollowHexagon,
    hollowSquare: HollowSquare,
    hollowTriangleDown: HollowTriangleDown,
    hollowTriangle: HollowTriangle,
    hollowBowtie: HollowBowtie,
    hollowCircle: HollowCircle,
    point: Point3,
    plus: Plus,
    diamond: Diamond,
    square: Square,
    triangle: Triangle,
    hexagon: Hexagon,
    cross: Cross,
    bowtie: Bowtie,
    hyphen: Hyphen,
    line: Line3,
    tick: Tick,
    triangleDown: TriangleDown,
    circle: Circle2
  };
  var Point4 = (options) => {
    return (index4, scale9, value2, coordinate) => {
      const { x: X, y: Y, x1: X12, y1: Y12, size: S, dx: DX, dy: DY } = value2;
      const [width, height] = coordinate.getSize();
      const offset3 = createBandOffset(scale9, value2, options);
      const xy = (i) => {
        const dx = +((DX === null || DX === void 0 ? void 0 : DX[i]) || 0);
        const dy = +((DY === null || DY === void 0 ? void 0 : DY[i]) || 0);
        const x3 = X12 ? (+X[i] + +X12[i]) / 2 : +X[i];
        const y3 = Y12 ? (+Y[i] + +Y12[i]) / 2 : +Y[i];
        const cx = x3 + dx;
        const cy = y3 + dy;
        return [cx, cy];
      };
      const P = S ? Array.from(index4, (i) => {
        const [cx, cy] = xy(i);
        const r = +S[i];
        const a3 = r / width;
        const b = r / height;
        const p1 = [cx - a3, cy - b];
        const p2 = [cx + a3, cy + b];
        return [
          coordinate.map(offset3(p1, i)),
          coordinate.map(offset3(p2, i))
        ];
      }) : Array.from(index4, (i) => [coordinate.map(offset3(xy(i), i))]);
      return [index4, P];
    };
  };
  Point4.props = {
    defaultShape: "hollow",
    defaultLabelShape: "label",
    composite: false,
    shape: shape4,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape4) }),
      { name: "x", required: true },
      { name: "y", required: true },
      { name: "series", scale: "band" },
      { name: "size", quantitative: "sqrt" },
      { name: "dx", scale: "identity" },
      { name: "dy", scale: "identity" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeZeroX },
      { type: MaybeZeroY }
    ],
    postInference: [...basePostInference(), { type: MaybeSize }, ...tooltip2d()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/text.js
  var shape5 = {
    text: Text3,
    badge: Badge,
    tag: Tag
  };
  var Text4 = (options) => {
    const { cartesian: cartesian2 = false } = options;
    if (cartesian2)
      return visualMark;
    return (index4, scale9, value2, coordinate) => {
      const { x: X, y: Y } = value2;
      const offset3 = createBandOffset(scale9, value2, options);
      const P = Array.from(index4, (i) => {
        const p2 = [+X[i], +Y[i]];
        return [coordinate.map(offset3(p2, i))];
      });
      return [index4, P];
    };
  };
  Text4.props = {
    defaultShape: "text",
    defaultLabelShape: "label",
    composite: false,
    shape: shape5,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape5) }),
      { name: "x", required: true },
      { name: "y", required: true },
      { name: "text", scale: "identity" },
      { name: "fontSize", scale: "identity" },
      { name: "rotate", scale: "identity" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeTuple },
      { type: MaybeVisualPosition }
    ],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/cell.js
  var shape6 = {
    cell: Rect2,
    hollow: Hollow
  };
  var Cell = () => {
    return (index4, scale9, value2, coordinate) => {
      const { x: X, y: Y } = value2;
      const x3 = scale9.x;
      const y3 = scale9.y;
      const P = Array.from(index4, (i) => {
        const width = x3.getBandWidth(x3.invert(+X[i]));
        const height = y3.getBandWidth(y3.invert(+Y[i]));
        const x12 = +X[i];
        const y12 = +Y[i];
        const p1 = [x12, y12];
        const p2 = [x12 + width, y12];
        const p3 = [x12 + width, y12 + height];
        const p4 = [x12, y12 + height];
        return [p1, p2, p3, p4].map((d2) => coordinate.map(d2));
      });
      return [index4, P];
    };
  };
  Cell.props = {
    defaultShape: "cell",
    defaultLabelShape: "label",
    shape: shape6,
    composite: false,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape6) }),
      { name: "x", required: true, scale: "band" },
      { name: "y", required: true, scale: "band" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeZeroX },
      { type: MaybeZeroY },
      { type: MaybeZeroPadding }
    ],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/area.js
  var shape7 = {
    area: Area,
    smooth: Smooth2,
    hvh: HVH2,
    vh: VH2,
    hv: HV2
  };
  var Area2 = () => {
    return (index4, scale9, value2, coordinate) => {
      var _a, _b;
      const { x: X, y: Y, y1: Y12, series: S } = value2;
      const { x: x3, y: y3 } = scale9;
      const series = S ? Array.from(group(index4, (i) => S[i]).values()) : [index4];
      const I = series.map((group3) => group3[0]).filter((i) => i !== void 0);
      const xoffset = (((_a = x3 === null || x3 === void 0 ? void 0 : x3.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(x3)) || 0) / 2;
      const yoffset = (((_b = y3 === null || y3 === void 0 ? void 0 : y3.getBandWidth) === null || _b === void 0 ? void 0 : _b.call(y3)) || 0) / 2;
      const P = Array.from(series, (SI) => {
        const l2 = SI.length;
        const points = new Array(l2 * 2);
        for (let idx = 0; idx < SI.length; idx++) {
          const i = SI[idx];
          points[idx] = coordinate.map([+X[i] + xoffset, +Y[i] + yoffset]);
          points[l2 + idx] = coordinate.map([+X[i] + xoffset, +Y12[i] + yoffset]);
        }
        return points;
      });
      return [I, P, series];
    };
  };
  Area2.props = {
    defaultShape: "area",
    defaultLabelShape: "label",
    composite: false,
    shape: shape7,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape7) }),
      { name: "x", required: true },
      { name: "y", required: true },
      { name: "size" },
      { name: "series", scale: "band" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeSeries },
      { type: MaybeZeroY1 },
      { type: MaybeZeroPadding }
    ],
    postInference: [...basePostInference(), ...tooltip1d()],
    interaction: {
      shareTooltip: true,
      seriesTooltip: true,
      crosshairs: true
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/link.js
  var shape8 = {
    link: Link,
    arc: Arc,
    smooth: Smooth3,
    vhv: VHV
  };
  var Link2 = (options) => {
    return (index4, scale9, value2, coordinate) => {
      const { x: X, y: Y, x1: X12 = X, y1: Y12 = Y } = value2;
      const offset3 = createBandOffset(scale9, value2, options);
      const P = index4.map((i) => [
        coordinate.map(offset3([+X[i], +Y[i]], i)),
        coordinate.map(offset3([+X12[i], +Y12[i]], i))
      ]);
      return [index4, P];
    };
  };
  Link2.props = {
    defaultShape: "link",
    defaultLabelShape: "label",
    composite: false,
    shape: shape8,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape8) }),
      { name: "x", required: true },
      { name: "y", required: true }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeIdentityY },
      { type: MaybeIdentityX }
    ],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/image.js
  var shape9 = {
    image: Image3
  };
  var Image4 = (options) => {
    const { cartesian: cartesian2 } = options;
    if (cartesian2)
      return visualMark;
    return (index4, scale9, value2, coordinate) => {
      const { x: X, y: Y } = value2;
      const offset3 = createBandOffset(scale9, value2, options);
      const P = Array.from(index4, (i) => {
        const p2 = [+X[i], +Y[i]];
        return [coordinate.map(offset3(p2, i))];
      });
      return [index4, P];
    };
  };
  Image4.props = {
    defaultShape: "image",
    defaultLabelShape: "label",
    composite: false,
    shape: shape9,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape9) }),
      { name: "x", required: true },
      { name: "y", required: true },
      { name: "src", scale: "identity" },
      { name: "size" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeTuple },
      { type: MaybeVisualPosition }
    ],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/polygon.js
  var shape10 = {
    polygon: Polygon2,
    ribbon: Ribbon2
  };
  var Polygon3 = () => {
    return (index4, scale9, value2, coordinate) => {
      const Xn = Object.entries(value2).filter(([key]) => key.startsWith("x")).map(([, value3]) => value3);
      const Yn = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
      const P = index4.map((i) => {
        const Pn = [];
        for (let j = 0; j < Xn.length; j++) {
          const x3 = Xn[j][i];
          if (x3 === void 0)
            break;
          const y3 = Yn[j][i];
          Pn.push(coordinate.map([+x3, +y3]));
        }
        return Pn;
      });
      return [index4, P];
    };
  };
  Polygon3.props = {
    defaultShape: "polygon",
    defaultLabelShape: "label",
    composite: false,
    shape: shape10,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape10) }),
      { name: "x", required: true },
      { name: "y", required: true }
    ],
    preInference: [...basePreInference()],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/box.js
  var shape11 = {
    box: Box,
    violin: Violin
  };
  var Box2 = () => {
    return (index4, scale9, value2, coordinate) => {
      const { x: X, y: Y, y1: Y12, y2: Y22, y3: Y3, y4: Y4, series: S } = value2;
      const xScale = scale9.x;
      const series = scale9.series;
      const P = Array.from(index4, (i) => {
        const groupWidth = xScale.getBandWidth(xScale.invert(+X[i]));
        const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i]))) : 1;
        const width = groupWidth * ratio;
        const offset3 = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
        const x3 = +X[i] + offset3 + width / 2;
        const [low, q12, median3, q32, high] = [
          +Y[i],
          +Y12[i],
          +Y22[i],
          +Y3[i],
          +Y4[i]
        ];
        const P13 = [
          [x3 - width / 2, high],
          [x3 + width / 2, high],
          [x3, high],
          [x3, q32],
          [x3 - width / 2, q32],
          [x3 + width / 2, q32],
          [x3 + width / 2, q12],
          [x3 - width / 2, q12],
          [x3 - width / 2, median3],
          [x3 + width / 2, median3],
          [x3, q12],
          [x3, low],
          [x3 - width / 2, low],
          [x3 + width / 2, low]
        ];
        return P13.map((d2) => coordinate.map(d2));
      });
      return [index4, P];
    };
  };
  Box2.props = {
    defaultShape: "box",
    defaultLabelShape: "label",
    composite: false,
    shape: shape11,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape11) }),
      { name: "x", scale: "band", required: true },
      { name: "y", required: true },
      { name: "series", scale: "band" }
    ],
    preInference: [...basePreInference(), { type: MaybeZeroX }],
    postInference: [...basePostInference(), ...tooltip1d()],
    interaction: {
      shareTooltip: true
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/vector.js
  var shape12 = {
    vector: Vector
  };
  var Vector2 = () => {
    return (index4, scale9, value2, coordinate) => {
      const { x: X, y: Y, size: S, rotate: R } = value2;
      const [width, height] = coordinate.getSize();
      const P = index4.map((i) => {
        const angle4 = +R[i] / 180 * Math.PI;
        const s2 = +S[i];
        const a3 = s2 / width;
        const b = s2 / height;
        const vx = a3 * Math.cos(angle4);
        const vy = -b * Math.sin(angle4);
        return [
          coordinate.map([+X[i] - vx / 2, +Y[i] - vy / 2]),
          coordinate.map([+X[i] + vx / 2, +Y[i] + vy / 2])
        ];
      });
      return [index4, P];
    };
  };
  Vector2.props = {
    defaultShape: "vector",
    defaultLabelShape: "label",
    composite: false,
    shape: shape12,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape12) }),
      { name: "x", required: true },
      { name: "y", required: true },
      { name: "rotate", required: true, scale: "identity" },
      { name: "size", required: true }
    ],
    preInference: [...basePreInference()],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/lineY.js
  var shape13 = {
    line: Line4
  };
  var LineY = (options) => {
    return (index4, scale9, value2, coordinate) => {
      const { y: Y } = value2;
      const offset3 = createBandOffset(scale9, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
      const P = Array.from(index4, (i) => {
        const p1 = [0, Y[i]];
        const p2 = [1, Y[i]];
        return [p1, p2].map((d2) => coordinate.map(offset3(d2, i)));
      });
      return [index4, P];
    };
  };
  LineY.props = {
    defaultShape: "line",
    defaultLabelShape: "label",
    composite: false,
    shape: shape13,
    channels: [
      ...baseAnnotationChannels({ shapes: Object.keys(shape13) }),
      { name: "y", required: true }
    ],
    preInference: [...basePreInference(), { type: MaybeTupleY }],
    postInference: [...basePostInference()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/lineX.js
  var shape14 = {
    line: Line4
  };
  var LineX = (options) => {
    return (index4, scale9, value2, coordinate) => {
      const { x: X } = value2;
      const offset3 = createBandOffset(scale9, value2, deep_mix_default({ style: { bandOffset: 0 } }, options));
      const P = Array.from(index4, (i) => {
        const p1 = [X[i], 1];
        const p2 = [X[i], 0];
        return [p1, p2].map((d2) => coordinate.map(offset3(d2, i)));
      });
      return [index4, P];
    };
  };
  LineX.props = {
    defaultShape: "line",
    defaultLabelShape: "label",
    composite: false,
    shape: shape14,
    channels: [
      ...baseAnnotationChannels({ shapes: Object.keys(shape14) }),
      { name: "x", required: true }
    ],
    preInference: [...basePreInference(), { type: MaybeTupleX }],
    postInference: [...basePostInference()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/connector.js
  var shape15 = {
    connector: Connector
  };
  var Connector2 = (...args) => {
    return Link2(...args);
  };
  Connector2.props = {
    defaultShape: "connector",
    defaultLabelShape: "label",
    composite: false,
    shape: shape15,
    channels: [
      ...baseAnnotationChannels({ shapes: Object.keys(shape15) }),
      { name: "x", required: true },
      { name: "y", required: true }
    ],
    preInference: [...basePreInference()],
    postInference: [...basePostInference()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/range.js
  function extend5(channel, extended, value2, scale9) {
    if (extended)
      return () => [0, 1];
    const { [channel]: C3, [`${channel}1`]: C1 } = value2;
    return (i) => {
      var _a;
      const offset3 = ((_a = scale9.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scale9, scale9.invert(+C1[i]))) || 0;
      return [C3[i], C1[i] + offset3];
    };
  }
  function AbstractRange(options = {}) {
    const { extendX = false, extendY = false } = options;
    return (index4, scale9, value2, coordinate) => {
      const x3 = extend5("x", extendX, value2, scale9.x);
      const y3 = extend5("y", extendY, value2, scale9.y);
      const P = Array.from(index4, (i) => {
        const [x12, x22] = x3(i);
        const [y12, y22] = y3(i);
        const p1 = [x12, y12];
        const p2 = [x22, y12];
        const p3 = [x22, y22];
        const p4 = [x12, y22];
        return [p1, p2, p3, p4].map((d2) => coordinate.map(d2));
      });
      return [index4, P];
    };
  }
  var shape16 = { range: Rect2 };
  var Range = () => {
    return AbstractRange();
  };
  Range.props = {
    defaultShape: "range",
    defaultLabelShape: "label",
    composite: false,
    shape: shape16,
    channels: [
      ...baseAnnotationChannels({ shapes: Object.keys(shape16) }),
      { name: "x", required: true },
      { name: "y", required: true }
    ],
    preInference: [...basePreInference()],
    postInference: [...basePostInference()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/rangeX.js
  var shape17 = {
    range: Rect2
  };
  var RangeX = () => {
    return AbstractRange({ extendY: true });
  };
  RangeX.props = {
    defaultShape: "range",
    defaultLabelShape: "label",
    composite: false,
    shape: shape17,
    channels: [
      ...baseAnnotationChannels({ shapes: Object.keys(shape17) }),
      { name: "x", required: true }
    ],
    preInference: [...basePreInference(), { type: MaybeDefaultX }],
    postInference: [...basePostInference()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/rangeY.js
  var shape18 = {
    range: Rect2
  };
  var RangeY = () => {
    return AbstractRange({ extendX: true });
  };
  RangeY.props = {
    defaultShape: "range",
    defaultLabelShape: "label",
    composite: false,
    shape: shape18,
    channels: [
      ...baseAnnotationChannels({ shapes: Object.keys(shape18) }),
      { name: "y", required: true }
    ],
    preInference: [...basePreInference(), { type: MaybeDefaultY }],
    postInference: [...basePostInference()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/utils/d3-sankey/align.js
  function targetDepth(d2) {
    return d2.target.depth;
  }
  function left(node) {
    return node.depth;
  }
  function right(node, n2) {
    return n2 - 1 - node.height;
  }
  function justify(node, n2) {
    return node.sourceLinks.length ? node.depth : n2 - 1;
  }
  function center(node) {
    return node.targetLinks.length ? node.depth : node.sourceLinks.length ? min4(node.sourceLinks, targetDepth) - 1 : 0;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/utils/d3-sankey/constant.js
  function constant3(x3) {
    return function() {
      return x3;
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/utils/d3-sankey/sankey.js
  function ascendingSourceBreadth(a3, b) {
    return ascendingBreadth(a3.source, b.source) || a3.index - b.index;
  }
  function ascendingTargetBreadth(a3, b) {
    return ascendingBreadth(a3.target, b.target) || a3.index - b.index;
  }
  function ascendingBreadth(a3, b) {
    return a3.y0 - b.y0;
  }
  function value(d2) {
    return d2.value;
  }
  function defaultId(d2) {
    return d2.index;
  }
  function defaultNodes(graph) {
    return graph.nodes;
  }
  function defaultLinks(graph) {
    return graph.links;
  }
  function find4(nodeById, id4) {
    const node = nodeById.get(id4);
    if (!node)
      throw new Error("missing: " + id4);
    return node;
  }
  function computeLinkBreadths({ nodes }) {
    for (const node of nodes) {
      let y05 = node.y0;
      let y12 = y05;
      for (const link2 of node.sourceLinks) {
        link2.y0 = y05 + link2.width / 2;
        y05 += link2.width;
      }
      for (const link2 of node.targetLinks) {
        link2.y1 = y12 + link2.width / 2;
        y12 += link2.width;
      }
    }
  }
  function Sankey() {
    let x05 = 0, y05 = 0, x12 = 1, y12 = 1;
    let dx = 24;
    let dy = 8, py;
    let id4 = defaultId;
    let align = justify;
    let depth;
    let sort3;
    let linkSort;
    let nodes = defaultNodes;
    let links = defaultLinks;
    let iterations2 = 6;
    function sankey(arg) {
      const graph = {
        nodes: nodes(arg),
        links: links(arg)
      };
      computeNodeLinks(graph);
      computeNodeValues(graph);
      computeNodeDepths(graph);
      computeNodeHeights(graph);
      computeNodeBreadths(graph);
      computeLinkBreadths(graph);
      return graph;
    }
    sankey.update = function(graph) {
      computeLinkBreadths(graph);
      return graph;
    };
    sankey.nodeId = function(_2) {
      return arguments.length ? (id4 = typeof _2 === "function" ? _2 : constant3(_2), sankey) : id4;
    };
    sankey.nodeAlign = function(_2) {
      return arguments.length ? (align = typeof _2 === "function" ? _2 : constant3(_2), sankey) : align;
    };
    sankey.nodeDepth = function(_2) {
      return arguments.length ? (depth = typeof _2 === "function" ? _2 : _2, sankey) : depth;
    };
    sankey.nodeSort = function(_2) {
      return arguments.length ? (sort3 = _2, sankey) : sort3;
    };
    sankey.nodeWidth = function(_2) {
      return arguments.length ? (dx = +_2, sankey) : dx;
    };
    sankey.nodePadding = function(_2) {
      return arguments.length ? (dy = py = +_2, sankey) : dy;
    };
    sankey.nodes = function(_2) {
      return arguments.length ? (nodes = typeof _2 === "function" ? _2 : constant3(_2), sankey) : nodes;
    };
    sankey.links = function(_2) {
      return arguments.length ? (links = typeof _2 === "function" ? _2 : constant3(_2), sankey) : links;
    };
    sankey.linkSort = function(_2) {
      return arguments.length ? (linkSort = _2, sankey) : linkSort;
    };
    sankey.size = function(_2) {
      return arguments.length ? (x05 = y05 = 0, x12 = +_2[0], y12 = +_2[1], sankey) : [x12 - x05, y12 - y05];
    };
    sankey.extent = function(_2) {
      return arguments.length ? (x05 = +_2[0][0], x12 = +_2[1][0], y05 = +_2[0][1], y12 = +_2[1][1], sankey) : [
        [x05, y05],
        [x12, y12]
      ];
    };
    sankey.iterations = function(_2) {
      return arguments.length ? (iterations2 = +_2, sankey) : iterations2;
    };
    function computeNodeLinks({ nodes: nodes2, links: links2 }) {
      nodes2.forEach((node, idx) => {
        node.index = idx;
        node.sourceLinks = [];
        node.targetLinks = [];
      });
      const nodeById = new Map(nodes2.map((d2) => [id4(d2), d2]));
      links2.forEach((link2, idx) => {
        link2.index = idx;
        let { source, target } = link2;
        if (typeof source !== "object")
          source = link2.source = find4(nodeById, source);
        if (typeof target !== "object")
          target = link2.target = find4(nodeById, target);
        source.sourceLinks.push(link2);
        target.targetLinks.push(link2);
      });
      if (linkSort != null) {
        for (const { sourceLinks, targetLinks } of nodes2) {
          sourceLinks.sort(linkSort);
          targetLinks.sort(linkSort);
        }
      }
    }
    function computeNodeValues({ nodes: nodes2 }) {
      for (const node of nodes2) {
        node.value = node.fixedValue === void 0 ? Math.max(sum(node.sourceLinks, value), sum(node.targetLinks, value)) : node.fixedValue;
      }
    }
    function computeNodeDepths({ nodes: nodes2 }) {
      const n2 = nodes2.length;
      let current = new Set(nodes2);
      let next = /* @__PURE__ */ new Set();
      let x3 = 0;
      while (current.size) {
        current.forEach((node) => {
          node.depth = x3;
          for (const { target } of node.sourceLinks) {
            next.add(target);
          }
        });
        if (++x3 > n2)
          throw new Error("circular link");
        current = next;
        next = /* @__PURE__ */ new Set();
      }
      if (depth) {
        const maxDepth2 = Math.max(max4(nodes2, (d2) => d2.depth) + 1, 0);
        let node;
        for (let i = 0; i < nodes2.length; i++) {
          node = nodes2[i];
          node.depth = depth.call(null, node, maxDepth2);
        }
      }
    }
    function computeNodeHeights({ nodes: nodes2 }) {
      const n2 = nodes2.length;
      let current = new Set(nodes2);
      let next = /* @__PURE__ */ new Set();
      let x3 = 0;
      while (current.size) {
        current.forEach((node) => {
          node.height = x3;
          for (const { source } of node.targetLinks) {
            next.add(source);
          }
        });
        if (++x3 > n2)
          throw new Error("circular link");
        current = next;
        next = /* @__PURE__ */ new Set();
      }
    }
    function computeNodeLayers({ nodes: nodes2 }) {
      const x3 = Math.max(max4(nodes2, (d2) => d2.depth) + 1, 0);
      const kx = (x12 - x05 - dx) / (x3 - 1);
      const columns = new Array(x3).fill(0).map(() => []);
      for (const node of nodes2) {
        const i = Math.max(0, Math.min(x3 - 1, Math.floor(align.call(null, node, x3))));
        node.layer = i;
        node.x0 = x05 + i * kx;
        node.x1 = node.x0 + dx;
        if (columns[i])
          columns[i].push(node);
        else
          columns[i] = [node];
      }
      if (sort3)
        for (const column2 of columns) {
          column2.sort(sort3);
        }
      return columns;
    }
    function initializeNodeBreadths(columns) {
      const ky = min4(columns, (c5) => (y12 - y05 - (c5.length - 1) * py) / sum(c5, value));
      for (const nodes2 of columns) {
        let y3 = y05;
        for (const node of nodes2) {
          node.y0 = y3;
          node.y1 = y3 + node.value * ky;
          y3 = node.y1 + py;
          for (const link2 of node.sourceLinks) {
            link2.width = link2.value * ky;
          }
        }
        y3 = (y12 - y3 + py) / (nodes2.length + 1);
        for (let i = 0; i < nodes2.length; ++i) {
          const node = nodes2[i];
          node.y0 += y3 * (i + 1);
          node.y1 += y3 * (i + 1);
        }
        reorderLinks(nodes2);
      }
    }
    function computeNodeBreadths(graph) {
      const columns = computeNodeLayers(graph);
      py = Math.min(dy, (y12 - y05) / (max4(columns, (c5) => c5.length) - 1));
      initializeNodeBreadths(columns);
      for (let i = 0; i < iterations2; ++i) {
        const alpha = Math.pow(0.99, i);
        const beta = Math.max(1 - alpha, (i + 1) / iterations2);
        relaxRightToLeft(columns, alpha, beta);
        relaxLeftToRight(columns, alpha, beta);
      }
    }
    function relaxLeftToRight(columns, alpha, beta) {
      for (let i = 1, n2 = columns.length; i < n2; ++i) {
        const column2 = columns[i];
        for (const target of column2) {
          let y3 = 0;
          let w = 0;
          for (const { source, value: value2 } of target.targetLinks) {
            const v = value2 * (target.layer - source.layer);
            y3 += targetTop(source, target) * v;
            w += v;
          }
          if (!(w > 0))
            continue;
          const dy2 = (y3 / w - target.y0) * alpha;
          target.y0 += dy2;
          target.y1 += dy2;
          reorderNodeLinks(target);
        }
        if (sort3 === void 0)
          column2.sort(ascendingBreadth);
        if (column2.length)
          resolveCollisions(column2, beta);
      }
    }
    function relaxRightToLeft(columns, alpha, beta) {
      for (let n2 = columns.length, i = n2 - 2; i >= 0; --i) {
        const column2 = columns[i];
        for (const source of column2) {
          let y3 = 0;
          let w = 0;
          for (const { target, value: value2 } of source.sourceLinks) {
            const v = value2 * (target.layer - source.layer);
            y3 += sourceTop(source, target) * v;
            w += v;
          }
          if (!(w > 0))
            continue;
          const dy2 = (y3 / w - source.y0) * alpha;
          source.y0 += dy2;
          source.y1 += dy2;
          reorderNodeLinks(source);
        }
        if (sort3 === void 0)
          column2.sort(ascendingBreadth);
        if (column2.length)
          resolveCollisions(column2, beta);
      }
    }
    function resolveCollisions(nodes2, alpha) {
      const i = nodes2.length >> 1;
      const subject = nodes2[i];
      resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
      resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
      resolveCollisionsBottomToTop(nodes2, y12, nodes2.length - 1, alpha);
      resolveCollisionsTopToBottom(nodes2, y05, 0, alpha);
    }
    function resolveCollisionsTopToBottom(nodes2, y3, i, alpha) {
      for (; i < nodes2.length; ++i) {
        const node = nodes2[i];
        const dy2 = (y3 - node.y0) * alpha;
        if (dy2 > 1e-6)
          node.y0 += dy2, node.y1 += dy2;
        y3 = node.y1 + py;
      }
    }
    function resolveCollisionsBottomToTop(nodes2, y3, i, alpha) {
      for (; i >= 0; --i) {
        const node = nodes2[i];
        const dy2 = (node.y1 - y3) * alpha;
        if (dy2 > 1e-6)
          node.y0 -= dy2, node.y1 -= dy2;
        y3 = node.y0 - py;
      }
    }
    function reorderNodeLinks({ sourceLinks, targetLinks }) {
      if (linkSort === void 0) {
        for (const { source: { sourceLinks: sourceLinks2 } } of targetLinks) {
          sourceLinks2.sort(ascendingTargetBreadth);
        }
        for (const { target: { targetLinks: targetLinks2 } } of sourceLinks) {
          targetLinks2.sort(ascendingSourceBreadth);
        }
      }
    }
    function reorderLinks(nodes2) {
      if (linkSort === void 0) {
        for (const { sourceLinks, targetLinks } of nodes2) {
          sourceLinks.sort(ascendingTargetBreadth);
          targetLinks.sort(ascendingSourceBreadth);
        }
      }
    }
    function targetTop(source, target) {
      let y3 = source.y0 - (source.sourceLinks.length - 1) * py / 2;
      for (const { target: node, width } of source.sourceLinks) {
        if (node === target)
          break;
        y3 += width + py;
      }
      for (const { source: node, width } of target.targetLinks) {
        if (node === source)
          break;
        y3 -= width;
      }
      return y3;
    }
    function sourceTop(source, target) {
      let y3 = target.y0 - (target.targetLinks.length - 1) * py / 2;
      for (const { source: node, width } of target.targetLinks) {
        if (node === source)
          break;
        y3 += width + py;
      }
      for (const { target: node, width } of source.sourceLinks) {
        if (node === target)
          break;
        y3 -= width;
      }
      return y3;
    }
    return sankey;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/sankey.js
  var DEFAULT_OPTIONS = {
    nodeAlign: "justify",
    nodeWidth: 8e-3,
    nodePadding: 0.03,
    nodes: (graph) => graph.nodes,
    links: (graph) => graph.links,
    nodeSort: void 0,
    linkSort: void 0,
    iterations: 6
  };
  var ALIGN_METHOD = {
    left,
    right,
    center,
    justify
  };
  function getNodeAlignFunction(nodeAlign) {
    const type = typeof nodeAlign;
    if (type === "string")
      return ALIGN_METHOD[nodeAlign] || justify;
    if (type === "function")
      return nodeAlign;
    return justify;
  }
  var Sankey2 = (options) => {
    return (data2) => {
      const { nodeId, nodeSort, nodeAlign, nodeWidth, nodePadding, nodeDepth, nodes: nodeNodes, links: nodeLinks, linkSort, iterations: iterations2 } = Object.assign({}, DEFAULT_OPTIONS, options);
      const sankeyProcessor = Sankey().nodeSort(nodeSort).linkSort(linkSort).links(nodeLinks).nodes(nodeNodes).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).iterations(iterations2).extent([
        [0, 0],
        [1, 1]
      ]);
      if (typeof nodeId === "function") {
        sankeyProcessor.nodeId(nodeId);
      }
      const layoutData = sankeyProcessor(data2);
      const { nodes: N, links: L } = layoutData;
      const nodes = N.map((node) => {
        const { x0: x05, x1: x12, y0: y05, y1: y12 } = node;
        return Object.assign(Object.assign({}, node), { x: [x05, x12, x12, x05], y: [y05, y05, y12, y12] });
      });
      const links = L.map((edge) => {
        const { source, target } = edge;
        const sx = source.x1;
        const tx = target.x0;
        const offset3 = edge.width / 2;
        return Object.assign(Object.assign({}, edge), { x: [sx, sx, tx, tx], y: [
          edge.y0 + offset3,
          edge.y0 - offset3,
          edge.y1 + offset3,
          edge.y1 - offset3
        ] });
      });
      return { nodes, links };
    };
  };
  Sankey2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/mark.js
  function subTooltip(tooltip2, name2, defaults5 = {}, main = false) {
    if (isUnset(tooltip2))
      return tooltip2;
    if (Array.isArray(tooltip2) && main)
      return tooltip2;
    const sub8 = subObject(tooltip2, name2);
    return deep_mix_default(defaults5, sub8);
  }
  function maybeTooltip(tooltip2, defaults5 = {}) {
    if (isUnset(tooltip2))
      return tooltip2;
    if (Array.isArray(tooltip2))
      return tooltip2;
    if (!isFullTooltip(tooltip2))
      return tooltip2;
    return deep_mix_default(defaults5, tooltip2);
  }
  function isFullTooltip(tooltip2) {
    if (Object.keys(tooltip2).length === 0)
      return true;
    const { title, items } = tooltip2;
    return title !== void 0 || items !== void 0;
  }
  function maybeAnimation(animate2, sub8) {
    return typeof animate2 === "object" ? subObject(animate2, sub8) : animate2;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/sankey.js
  var __rest44 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var DEFAULT_LAYOUT_OPTIONS = {
    nodeId: (d2) => d2.key,
    nodeWidth: 0.02,
    nodePadding: 0.02
  };
  var DEFAULT_NODE_OPTIONS = {
    type: "polygon",
    axis: false,
    legend: false,
    encode: {
      shape: "polygon",
      x: "x",
      y: "y"
    },
    scale: {
      x: { type: "identity" },
      y: { type: "identity" }
    },
    style: {
      stroke: "#000"
    }
  };
  var DEFAULT_LINK_OPTIONS = {
    type: "polygon",
    axis: false,
    legend: false,
    encode: {
      shape: "ribbon",
      x: "x",
      y: "y"
    },
    style: {
      fillOpacity: 0.5,
      stroke: void 0
    }
  };
  var DEFAULT_LABEL_OPTIONS = {
    textAlign: (d2) => d2.x[0] < 0.5 ? "start" : "end",
    position: (d2) => d2.x[0] < 0.5 ? "right" : "left",
    fontSize: 10
  };
  var Sankey3 = (options) => {
    const { data: data2, encode = {}, scale: scale9, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
    const { links, nodes } = initializeData(data2, encode);
    const nodeEncode = subObject(encode, "node");
    const linkEncode = subObject(encode, "link");
    const { key: nodeKey = (d2) => d2.key, color: color2 = nodeKey } = nodeEncode;
    const { links: linkData, nodes: nodeData } = Sankey2(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS), { nodeId: field(nodeKey) }), layout))({ links, nodes });
    const _a = subObject(style, "label"), { text = nodeKey, spacing = 5 } = _a, labelStyle = __rest44(_a, ["text", "spacing"]);
    const key1 = field(nodeKey);
    const nodeTooltip = subTooltip(tooltip2, "node", {
      title: key1,
      items: [{ field: "value" }]
    }, true);
    const linkTooltip = subTooltip(tooltip2, "link", {
      title: "",
      items: [
        (d2) => ({ name: "source", value: key1(d2.source) }),
        (d2) => ({ name: "target", value: key1(d2.target) })
      ]
    });
    return [
      deep_mix_default({}, DEFAULT_NODE_OPTIONS, {
        data: nodeData,
        encode: Object.assign(Object.assign({}, nodeEncode), { color: color2 }),
        scale: scale9,
        style: subObject(style, "node"),
        labels: [
          Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS), { text, dx: (d2) => d2.x[0] < 0.5 ? spacing : -spacing }), labelStyle),
          ...nodeLabels
        ],
        tooltip: nodeTooltip,
        animate: maybeAnimation(animate2, "node"),
        axis: false
      }),
      deep_mix_default({}, DEFAULT_LINK_OPTIONS, {
        data: linkData,
        encode: linkEncode,
        labels: linkLabels,
        style: Object.assign({ fill: linkEncode.color ? void 0 : "#aaa", lineWidth: 0 }, subObject(style, "link")),
        tooltip: linkTooltip,
        animate: maybeAnimation(animate2, "link")
      })
    ];
  };
  Sankey3.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/utils/arc/sort.js
  var sort_exports = {};
  __export(sort_exports, {
    frequency: () => frequency,
    id: () => id2,
    name: () => name,
    weight: () => weight
  });
  function weight(a3, b) {
    return b.value - a3.value;
  }
  function frequency(a3, b) {
    return b.frequency - a3.frequency;
  }
  function id2(a3, b) {
    return `${a3.id}`.localeCompare(`${b.id}`);
  }
  function name(a3, b) {
    return `${a3.name}`.localeCompare(`${b.name}`);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/utils/arc/arc.js
  var DEFAULT_OPTIONS2 = {
    y: 0,
    thickness: 0.05,
    weight: false,
    marginRatio: 0.1,
    id: (node) => node.id,
    source: (edge) => edge.source,
    target: (edge) => edge.target,
    sourceWeight: (edge) => edge.value || 1,
    targetWeight: (edge) => edge.value || 1,
    sortBy: null
  };
  function Arc2(options) {
    const { y: y3, thickness, weight: weight2, marginRatio, id: id4, source, target, sourceWeight, targetWeight, sortBy } = Object.assign(Object.assign({}, DEFAULT_OPTIONS2), options);
    function arc(data2) {
      const nodes = data2.nodes.map((n2) => Object.assign({}, n2));
      const edges = data2.edges.map((n2) => Object.assign({}, n2));
      preprocess(nodes, edges);
      sortNodes(nodes, edges);
      layoutNodes(nodes, edges);
      layoutEdges(nodes, edges);
      return { nodes, edges };
    }
    function preprocess(nodes, edges) {
      edges.forEach((edge) => {
        edge.source = source(edge);
        edge.target = target(edge);
        edge.sourceWeight = sourceWeight(edge);
        edge.targetWeight = targetWeight(edge);
      });
      const edgesBySource = group(edges, (e3) => e3.source);
      const edgesByTarget = group(edges, (e3) => e3.target);
      nodes.forEach((node) => {
        node.id = id4(node);
        const sources = edgesBySource.has(node.id) ? edgesBySource.get(node.id) : [];
        const targets = edgesByTarget.has(node.id) ? edgesByTarget.get(node.id) : [];
        node.frequency = sources.length + targets.length;
        node.value = sum(sources, (d2) => d2.sourceWeight) + sum(targets, (d2) => d2.targetWeight);
      });
      return { nodes, edges };
    }
    function sortNodes(nodes, edges) {
      const method = typeof sortBy === "function" ? sortBy : sort_exports[sortBy];
      if (method) {
        nodes.sort(method);
      }
    }
    function layoutNodes(nodes, edges) {
      const size2 = nodes.length;
      if (!size2) {
        throw error2("Invalid nodes: it's empty!");
      }
      if (!weight2) {
        const deltaX = 1 / size2;
        nodes.forEach((node, i) => {
          node.x = (i + 0.5) * deltaX;
          node.y = y3;
        });
        return { nodes, edges };
      }
      const margin = marginRatio / (2 * size2);
      const total = nodes.reduce((prev, node) => prev += node.value, 0);
      nodes.reduce((deltaX, node) => {
        node.weight = node.value / total;
        node.width = node.weight * (1 - marginRatio);
        node.height = thickness;
        const minX = margin + deltaX;
        const maxX = minX + node.width;
        const minY = y3 - thickness / 2;
        const maxY2 = minY + thickness;
        node.x = [minX, maxX, maxX, minX];
        node.y = [minY, minY, maxY2, maxY2];
        return deltaX + node.width + 2 * margin;
      }, 0);
      return {
        nodes,
        edges
      };
    }
    function layoutEdges(nodes, edges) {
      const nodesMap = new Map(nodes.map((d2) => [d2.id, d2]));
      if (!weight2) {
        edges.forEach((edge) => {
          const sourceId = source(edge);
          const targetId = target(edge);
          const sourceNode = nodesMap.get(sourceId);
          const targetNode = nodesMap.get(targetId);
          if (sourceNode && targetNode) {
            edge.x = [sourceNode.x, targetNode.x];
            edge.y = [sourceNode.y, targetNode.y];
          }
        });
        return { nodes, edges };
      }
      edges.forEach((edge) => {
        edge.x = [0, 0, 0, 0];
        edge.y = [y3, y3, y3, y3];
      });
      const edgesBySource = group(edges, (e3) => e3.source);
      const edgesByTarget = group(edges, (e3) => e3.target);
      nodes.forEach((node) => {
        const { edges: edges2, width, x: x3, y: y4, value: value2, id: id5 } = node;
        const sourceEdges = edgesBySource.get(id5) || [];
        const targetEdges = edgesByTarget.get(id5) || [];
        let offset3 = 0;
        sourceEdges.map((edge) => {
          const w = edge.sourceWeight / value2 * width;
          edge.x[0] = x3[0] + offset3;
          edge.x[1] = x3[0] + offset3 + w;
          offset3 += w;
        });
        targetEdges.forEach((edge) => {
          const w = edge.targetWeight / value2 * width;
          edge.x[3] = x3[0] + offset3;
          edge.x[2] = x3[0] + offset3 + w;
          offset3 += w;
        });
      });
    }
    return arc;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/arc.js
  var Arc3 = (options) => {
    return (data2) => {
      return Arc2(options)(data2);
    };
  };
  Arc3.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/chord.js
  var __rest45 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var DEFAULT_LAYOUT_OPTIONS2 = {
    y: 0,
    thickness: 0.05,
    marginRatio: 0.1,
    id: (node) => node.key,
    source: (edge) => edge.source,
    target: (edge) => edge.target,
    sourceWeight: (edge) => edge.value || 1,
    targetWeight: (edge) => edge.value || 1,
    sortBy: null
    // optional, id | weight | frequency | {function}
  };
  var DEFAULT_NODE_OPTIONS2 = {
    type: "polygon",
    axis: false,
    legend: false,
    encode: {
      shape: "polygon",
      x: "x",
      y: "y"
    },
    scale: {
      x: { type: "identity" },
      y: { type: "identity" }
    },
    style: {
      opacity: 1,
      fillOpacity: 1,
      lineWidth: 1
    }
  };
  var DEFAULT_LINK_OPTIONS2 = {
    type: "polygon",
    axis: false,
    legend: false,
    encode: {
      shape: "ribbon",
      x: "x",
      y: "y"
    },
    style: {
      opacity: 0.5,
      lineWidth: 1
    }
  };
  var DEFAULT_LABEL_OPTIONS2 = {
    position: "outside",
    fontSize: 10
  };
  var Chord = (options, context) => {
    const { data: data2, encode = {}, scale: scale9, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
    const { nodes, links } = initializeData(data2, encode);
    const nodeEncode = subObject(encode, "node");
    const linkEncode = subObject(encode, "link");
    const { key: nodeKey = (d2) => d2.key, color: color2 = nodeKey } = nodeEncode;
    const { linkEncodeColor = (d2) => d2.source } = linkEncode;
    const { nodeWidthRatio = DEFAULT_LAYOUT_OPTIONS2.thickness, nodePaddingRatio = DEFAULT_LAYOUT_OPTIONS2.marginRatio } = layout, restLayout = __rest45(layout, ["nodeWidthRatio", "nodePaddingRatio"]);
    const { nodes: nodeData, edges: linkData } = Arc3(Object.assign(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS2), { id: field(nodeKey), thickness: nodeWidthRatio, marginRatio: nodePaddingRatio }), restLayout), { weight: true }))({ nodes, edges: links });
    const _a = subObject(style, "label"), { text = nodeKey } = _a, labelStyle = __rest45(_a, ["text"]);
    const nodeTooltip = subTooltip(tooltip2, "node", {
      title: "",
      items: [(d2) => ({ name: d2.key, value: d2.value })]
    }, true);
    const linkTooltip = subTooltip(tooltip2, "link", {
      title: "",
      items: [(d2) => ({ name: `${d2.source} -> ${d2.target}`, value: d2.value })]
    });
    const { height, width } = context;
    const minimumLen = Math.min(height, width);
    return [
      deep_mix_default({}, DEFAULT_LINK_OPTIONS2, {
        data: linkData,
        encode: Object.assign(Object.assign({}, linkEncode), { color: linkEncodeColor }),
        labels: linkLabels,
        style: Object.assign({ fill: linkEncodeColor ? void 0 : "#aaa" }, subObject(style, "link")),
        tooltip: linkTooltip,
        animate: maybeAnimation(animate2, "link")
      }),
      deep_mix_default({}, DEFAULT_NODE_OPTIONS2, {
        data: nodeData,
        encode: Object.assign(Object.assign({}, nodeEncode), { color: color2 }),
        scale: scale9,
        style: subObject(style, "node"),
        coordinate: {
          type: "polar",
          // Leave enough rendering space for the label.
          outerRadius: (minimumLen - 20) / minimumLen,
          startAngle: -Math.PI * 2,
          endAngle: 0
        },
        labels: [
          Object.assign(Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS2), { text }), labelStyle),
          ...nodeLabels
        ],
        tooltip: nodeTooltip,
        animate: maybeAnimation(animate2, "node"),
        axis: false
      })
    ];
  };
  Chord.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/path.js
  var shape19 = {
    path: Path3,
    hollow: Hollow2
  };
  var Path4 = (options) => {
    return (index4, scale9, value2, coordinate) => {
      return [index4, index4.map(() => [[0, 0]])];
    };
  };
  Path4.props = {
    defaultShape: "path",
    defaultLabelShape: "label",
    shape: shape19,
    composite: false,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape19) }),
      { name: "d", scale: "identity" }
    ],
    preInference: [...basePreInference()],
    postInference: [...basePostInference()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/cluster.js
  function defaultSeparation(a3, b) {
    return a3.parent === b.parent ? 1 : 2;
  }
  function meanX(children) {
    return children.reduce(meanXReduce, 0) / children.length;
  }
  function meanXReduce(x3, c5) {
    return x3 + c5.x;
  }
  function maxY(children) {
    return 1 + children.reduce(maxYReduce, 0);
  }
  function maxYReduce(y3, c5) {
    return Math.max(y3, c5.y);
  }
  function leafLeft(node) {
    var children;
    while (children = node.children) node = children[0];
    return node;
  }
  function leafRight(node) {
    var children;
    while (children = node.children) node = children[children.length - 1];
    return node;
  }
  function cluster_default() {
    var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = false;
    function cluster(root2) {
      var previousNode, x3 = 0;
      root2.eachAfter(function(node) {
        var children = node.children;
        if (children) {
          node.x = meanX(children);
          node.y = maxY(children);
        } else {
          node.x = previousNode ? x3 += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left2 = leafLeft(root2), right2 = leafRight(root2), x05 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
      return root2.eachAfter(nodeSize ? function(node) {
        node.x = (node.x - root2.x) * dx;
        node.y = (root2.y - node.y) * dy;
      } : function(node) {
        node.x = (node.x - x05) / (x12 - x05) * dx;
        node.y = (1 - (root2.y ? node.y / root2.y : 1)) * dy;
      });
    }
    cluster.separation = function(x3) {
      return arguments.length ? (separation = x3, cluster) : separation;
    };
    cluster.size = function(x3) {
      return arguments.length ? (nodeSize = false, dx = +x3[0], dy = +x3[1], cluster) : nodeSize ? null : [dx, dy];
    };
    cluster.nodeSize = function(x3) {
      return arguments.length ? (nodeSize = true, dx = +x3[0], dy = +x3[1], cluster) : nodeSize ? [dx, dy] : null;
    };
    return cluster;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/count.js
  function count3(node) {
    var sum3 = 0, children = node.children, i = children && children.length;
    if (!i) sum3 = 1;
    else while (--i >= 0) sum3 += children[i].value;
    node.value = sum3;
  }
  function count_default() {
    return this.eachAfter(count3);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/each.js
  function each_default2(callback, that) {
    let index4 = -1;
    for (const node of this) {
      callback.call(that, node, ++index4, this);
    }
    return this;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/eachBefore.js
  function eachBefore_default(callback, that) {
    var node = this, nodes = [node], children, i, index4 = -1;
    while (node = nodes.pop()) {
      callback.call(that, node, ++index4, this);
      if (children = node.children) {
        for (i = children.length - 1; i >= 0; --i) {
          nodes.push(children[i]);
        }
      }
    }
    return this;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/eachAfter.js
  function eachAfter_default(callback, that) {
    var node = this, nodes = [node], next = [], children, i, n2, index4 = -1;
    while (node = nodes.pop()) {
      next.push(node);
      if (children = node.children) {
        for (i = 0, n2 = children.length; i < n2; ++i) {
          nodes.push(children[i]);
        }
      }
    }
    while (node = next.pop()) {
      callback.call(that, node, ++index4, this);
    }
    return this;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/find.js
  function find_default2(callback, that) {
    let index4 = -1;
    for (const node of this) {
      if (callback.call(that, node, ++index4, this)) {
        return node;
      }
    }
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/sum.js
  function sum_default(value2) {
    return this.eachAfter(function(node) {
      var sum3 = +value2(node.data) || 0, children = node.children, i = children && children.length;
      while (--i >= 0) sum3 += children[i].value;
      node.value = sum3;
    });
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/sort.js
  function sort_default(compare) {
    return this.eachBefore(function(node) {
      if (node.children) {
        node.children.sort(compare);
      }
    });
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/path.js
  function path_default(end) {
    var start2 = this, ancestor = leastCommonAncestor(start2, end), nodes = [start2];
    while (start2 !== ancestor) {
      start2 = start2.parent;
      nodes.push(start2);
    }
    var k = nodes.length;
    while (end !== ancestor) {
      nodes.splice(k, 0, end);
      end = end.parent;
    }
    return nodes;
  }
  function leastCommonAncestor(a3, b) {
    if (a3 === b) return a3;
    var aNodes = a3.ancestors(), bNodes = b.ancestors(), c5 = null;
    a3 = aNodes.pop();
    b = bNodes.pop();
    while (a3 === b) {
      c5 = a3;
      a3 = aNodes.pop();
      b = bNodes.pop();
    }
    return c5;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/ancestors.js
  function ancestors_default() {
    var node = this, nodes = [node];
    while (node = node.parent) {
      nodes.push(node);
    }
    return nodes;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/descendants.js
  function descendants_default() {
    return Array.from(this);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/leaves.js
  function leaves_default() {
    var leaves = [];
    this.eachBefore(function(node) {
      if (!node.children) {
        leaves.push(node);
      }
    });
    return leaves;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/links.js
  function links_default() {
    var root2 = this, links = [];
    root2.each(function(node) {
      if (node !== root2) {
        links.push({ source: node.parent, target: node });
      }
    });
    return links;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/iterator.js
  function* iterator_default() {
    var node = this, current, next = [node], children, i, n2;
    do {
      current = next.reverse(), next = [];
      while (node = current.pop()) {
        yield node;
        if (children = node.children) {
          for (i = 0, n2 = children.length; i < n2; ++i) {
            next.push(children[i]);
          }
        }
      }
    } while (next.length);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/hierarchy/index.js
  function hierarchy(data2, children) {
    if (data2 instanceof Map) {
      data2 = [void 0, data2];
      if (children === void 0) children = mapChildren;
    } else if (children === void 0) {
      children = objectChildren;
    }
    var root2 = new Node3(data2), node, nodes = [root2], child, childs, i, n2;
    while (node = nodes.pop()) {
      if ((childs = children(node.data)) && (n2 = (childs = Array.from(childs)).length)) {
        node.children = childs;
        for (i = n2 - 1; i >= 0; --i) {
          nodes.push(child = childs[i] = new Node3(childs[i]));
          child.parent = node;
          child.depth = node.depth + 1;
        }
      }
    }
    return root2.eachBefore(computeHeight);
  }
  function node_copy() {
    return hierarchy(this).eachBefore(copyData);
  }
  function objectChildren(d2) {
    return d2.children;
  }
  function mapChildren(d2) {
    return Array.isArray(d2) ? d2[1] : null;
  }
  function copyData(node) {
    if (node.data.value !== void 0) node.value = node.data.value;
    node.data = node.data.data;
  }
  function computeHeight(node) {
    var height = 0;
    do
      node.height = height;
    while ((node = node.parent) && node.height < ++height);
  }
  function Node3(data2) {
    this.data = data2;
    this.depth = this.height = 0;
    this.parent = null;
  }
  Node3.prototype = hierarchy.prototype = {
    constructor: Node3,
    count: count_default,
    each: each_default2,
    eachAfter: eachAfter_default,
    eachBefore: eachBefore_default,
    find: find_default2,
    sum: sum_default,
    sort: sort_default,
    path: path_default,
    ancestors: ancestors_default,
    descendants: descendants_default,
    leaves: leaves_default,
    links: links_default,
    copy: node_copy,
    [Symbol.iterator]: iterator_default
  };

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/accessors.js
  function optional(f) {
    return f == null ? null : required(f);
  }
  function required(f) {
    if (typeof f !== "function") throw new Error();
    return f;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/constant.js
  function constantZero() {
    return 0;
  }
  function constant_default2(x3) {
    return function() {
      return x3;
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/lcg.js
  var a = 1664525;
  var c = 1013904223;
  var m = 4294967296;
  function lcg_default() {
    let s2 = 1;
    return () => (s2 = (a * s2 + c) % m) / m;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/array.js
  function array_default2(x3) {
    return typeof x3 === "object" && "length" in x3 ? x3 : Array.from(x3);
  }
  function shuffle(array2, random5) {
    let m3 = array2.length, t, i;
    while (m3) {
      i = random5() * m3-- | 0;
      t = array2[m3];
      array2[m3] = array2[i];
      array2[i] = t;
    }
    return array2;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/pack/enclose.js
  function packEncloseRandom(circles, random5) {
    var i = 0, n2 = (circles = shuffle(Array.from(circles), random5)).length, B3 = [], p2, e3;
    while (i < n2) {
      p2 = circles[i];
      if (e3 && enclosesWeak(e3, p2)) ++i;
      else e3 = encloseBasis(B3 = extendBasis(B3, p2)), i = 0;
    }
    return e3;
  }
  function extendBasis(B3, p2) {
    var i, j;
    if (enclosesWeakAll(p2, B3)) return [p2];
    for (i = 0; i < B3.length; ++i) {
      if (enclosesNot(p2, B3[i]) && enclosesWeakAll(encloseBasis2(B3[i], p2), B3)) {
        return [B3[i], p2];
      }
    }
    for (i = 0; i < B3.length - 1; ++i) {
      for (j = i + 1; j < B3.length; ++j) {
        if (enclosesNot(encloseBasis2(B3[i], B3[j]), p2) && enclosesNot(encloseBasis2(B3[i], p2), B3[j]) && enclosesNot(encloseBasis2(B3[j], p2), B3[i]) && enclosesWeakAll(encloseBasis3(B3[i], B3[j], p2), B3)) {
          return [B3[i], B3[j], p2];
        }
      }
    }
    throw new Error();
  }
  function enclosesNot(a3, b) {
    var dr = a3.r - b.r, dx = b.x - a3.x, dy = b.y - a3.y;
    return dr < 0 || dr * dr < dx * dx + dy * dy;
  }
  function enclosesWeak(a3, b) {
    var dr = a3.r - b.r + Math.max(a3.r, b.r, 1) * 1e-9, dx = b.x - a3.x, dy = b.y - a3.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }
  function enclosesWeakAll(a3, B3) {
    for (var i = 0; i < B3.length; ++i) {
      if (!enclosesWeak(a3, B3[i])) {
        return false;
      }
    }
    return true;
  }
  function encloseBasis(B3) {
    switch (B3.length) {
      case 1:
        return encloseBasis1(B3[0]);
      case 2:
        return encloseBasis2(B3[0], B3[1]);
      case 3:
        return encloseBasis3(B3[0], B3[1], B3[2]);
    }
  }
  function encloseBasis1(a3) {
    return {
      x: a3.x,
      y: a3.y,
      r: a3.r
    };
  }
  function encloseBasis2(a3, b) {
    var x12 = a3.x, y12 = a3.y, r1 = a3.r, x22 = b.x, y22 = b.y, r2 = b.r, x21 = x22 - x12, y21 = y22 - y12, r21 = r2 - r1, l2 = Math.sqrt(x21 * x21 + y21 * y21);
    return {
      x: (x12 + x22 + x21 / l2 * r21) / 2,
      y: (y12 + y22 + y21 / l2 * r21) / 2,
      r: (l2 + r1 + r2) / 2
    };
  }
  function encloseBasis3(a3, b, c5) {
    var x12 = a3.x, y12 = a3.y, r1 = a3.r, x22 = b.x, y22 = b.y, r2 = b.r, x3 = c5.x, y3 = c5.y, r3 = c5.r, a22 = x12 - x22, a32 = x12 - x3, b2 = y12 - y22, b3 = y12 - y3, c22 = r2 - r1, c32 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x22 * x22 - y22 * y22 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a32 * b2 - a22 * b3, xa = (b2 * d3 - b3 * d2) / (ab * 2) - x12, xb = (b3 * c22 - b2 * c32) / ab, ya = (a32 * d2 - a22 * d3) / (ab * 2) - y12, yb = (a22 * c32 - a32 * c22) / ab, A5 = xb * xb + yb * yb - 1, B3 = 2 * (r1 + xa * xb + ya * yb), C3 = xa * xa + ya * ya - r1 * r1, r = -(Math.abs(A5) > 1e-6 ? (B3 + Math.sqrt(B3 * B3 - 4 * A5 * C3)) / (2 * A5) : C3 / B3);
    return {
      x: x12 + xa + xb * r,
      y: y12 + ya + yb * r,
      r
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/pack/siblings.js
  function place(b, a3, c5) {
    var dx = b.x - a3.x, x3, a22, dy = b.y - a3.y, y3, b2, d2 = dx * dx + dy * dy;
    if (d2) {
      a22 = a3.r + c5.r, a22 *= a22;
      b2 = b.r + c5.r, b2 *= b2;
      if (a22 > b2) {
        x3 = (d2 + b2 - a22) / (2 * d2);
        y3 = Math.sqrt(Math.max(0, b2 / d2 - x3 * x3));
        c5.x = b.x - x3 * dx - y3 * dy;
        c5.y = b.y - x3 * dy + y3 * dx;
      } else {
        x3 = (d2 + a22 - b2) / (2 * d2);
        y3 = Math.sqrt(Math.max(0, a22 / d2 - x3 * x3));
        c5.x = a3.x + x3 * dx - y3 * dy;
        c5.y = a3.y + x3 * dy + y3 * dx;
      }
    } else {
      c5.x = a3.x + c5.r;
      c5.y = a3.y;
    }
  }
  function intersects(a3, b) {
    var dr = a3.r + b.r - 1e-6, dx = b.x - a3.x, dy = b.y - a3.y;
    return dr > 0 && dr * dr > dx * dx + dy * dy;
  }
  function score(node) {
    var a3 = node._, b = node.next._, ab = a3.r + b.r, dx = (a3.x * b.r + b.x * a3.r) / ab, dy = (a3.y * b.r + b.y * a3.r) / ab;
    return dx * dx + dy * dy;
  }
  function Node4(circle3) {
    this._ = circle3;
    this.next = null;
    this.previous = null;
  }
  function packSiblingsRandom(circles, random5) {
    if (!(n2 = (circles = array_default2(circles)).length)) return 0;
    var a3, b, c5, n2, aa, ca, i, j, k, sj, sk;
    a3 = circles[0], a3.x = 0, a3.y = 0;
    if (!(n2 > 1)) return a3.r;
    b = circles[1], a3.x = -b.r, b.x = a3.r, b.y = 0;
    if (!(n2 > 2)) return a3.r + b.r;
    place(b, a3, c5 = circles[2]);
    a3 = new Node4(a3), b = new Node4(b), c5 = new Node4(c5);
    a3.next = c5.previous = b;
    b.next = a3.previous = c5;
    c5.next = b.previous = a3;
    pack: for (i = 3; i < n2; ++i) {
      place(a3._, b._, c5 = circles[i]), c5 = new Node4(c5);
      j = b.next, k = a3.previous, sj = b._.r, sk = a3._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c5._)) {
            b = j, a3.next = b, b.previous = a3, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k._, c5._)) {
            a3 = k, a3.next = b, b.previous = a3, --i;
            continue pack;
          }
          sk += k._.r, k = k.previous;
        }
      } while (j !== k.next);
      c5.previous = a3, c5.next = b, a3.next = b.previous = b = c5;
      aa = score(a3);
      while ((c5 = c5.next) !== b) {
        if ((ca = score(c5)) < aa) {
          a3 = c5, aa = ca;
        }
      }
      b = a3.next;
    }
    a3 = [b._], c5 = b;
    while ((c5 = c5.next) !== b) a3.push(c5._);
    c5 = packEncloseRandom(a3, random5);
    for (i = 0; i < n2; ++i) a3 = circles[i], a3.x -= c5.x, a3.y -= c5.y;
    return c5.r;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/pack/index.js
  function defaultRadius(d2) {
    return Math.sqrt(d2.value);
  }
  function pack_default() {
    var radius = null, dx = 1, dy = 1, padding = constantZero;
    function pack3(root2) {
      const random5 = lcg_default();
      root2.x = dx / 2, root2.y = dy / 2;
      if (radius) {
        root2.eachBefore(radiusLeaf(radius)).eachAfter(packChildrenRandom(padding, 0.5, random5)).eachBefore(translateChild(1));
      } else {
        root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildrenRandom(constantZero, 1, random5)).eachAfter(packChildrenRandom(padding, root2.r / Math.min(dx, dy), random5)).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
      }
      return root2;
    }
    pack3.radius = function(x3) {
      return arguments.length ? (radius = optional(x3), pack3) : radius;
    };
    pack3.size = function(x3) {
      return arguments.length ? (dx = +x3[0], dy = +x3[1], pack3) : [dx, dy];
    };
    pack3.padding = function(x3) {
      return arguments.length ? (padding = typeof x3 === "function" ? x3 : constant_default2(+x3), pack3) : padding;
    };
    return pack3;
  }
  function radiusLeaf(radius) {
    return function(node) {
      if (!node.children) {
        node.r = Math.max(0, +radius(node) || 0);
      }
    };
  }
  function packChildrenRandom(padding, k, random5) {
    return function(node) {
      if (children = node.children) {
        var children, i, n2 = children.length, r = padding(node) * k || 0, e3;
        if (r) for (i = 0; i < n2; ++i) children[i].r += r;
        e3 = packSiblingsRandom(children, random5);
        if (r) for (i = 0; i < n2; ++i) children[i].r -= r;
        node.r = e3 + r;
      }
    };
  }
  function translateChild(k) {
    return function(node) {
      var parent = node.parent;
      node.r *= k;
      if (parent) {
        node.x = parent.x + k * node.x;
        node.y = parent.y + k * node.y;
      }
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/treemap/round.js
  function round_default(node) {
    node.x0 = Math.round(node.x0);
    node.y0 = Math.round(node.y0);
    node.x1 = Math.round(node.x1);
    node.y1 = Math.round(node.y1);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/treemap/dice.js
  function dice_default(parent, x05, y05, x12, y12) {
    var nodes = parent.children, node, i = -1, n2 = nodes.length, k = parent.value && (x12 - x05) / parent.value;
    while (++i < n2) {
      node = nodes[i], node.y0 = y05, node.y1 = y12;
      node.x0 = x05, node.x1 = x05 += node.value * k;
    }
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/stratify.js
  var preroot = { depth: -1 };
  var ambiguous = {};
  var imputed = {};
  function defaultId2(d2) {
    return d2.id;
  }
  function defaultParentId(d2) {
    return d2.parentId;
  }
  function stratify_default() {
    var id4 = defaultId2, parentId = defaultParentId, path2;
    function stratify(data2) {
      var nodes = Array.from(data2), currentId = id4, currentParentId = parentId, n2, d2, i, root2, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
      if (path2 != null) {
        const I = nodes.map((d3, i2) => normalize9(path2(d3, i2, data2)));
        const P = I.map(parentof);
        const S = new Set(I).add("");
        for (const i2 of P) {
          if (!S.has(i2)) {
            S.add(i2);
            I.push(i2);
            P.push(parentof(i2));
            nodes.push(imputed);
          }
        }
        currentId = (_2, i2) => I[i2];
        currentParentId = (_2, i2) => P[i2];
      }
      for (i = 0, n2 = nodes.length; i < n2; ++i) {
        d2 = nodes[i], node = nodes[i] = new Node3(d2);
        if ((nodeId = currentId(d2, i, data2)) != null && (nodeId += "")) {
          nodeKey = node.id = nodeId;
          nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
        }
        if ((nodeId = currentParentId(d2, i, data2)) != null && (nodeId += "")) {
          node.parent = nodeId;
        }
      }
      for (i = 0; i < n2; ++i) {
        node = nodes[i];
        if (nodeId = node.parent) {
          parent = nodeByKey.get(nodeId);
          if (!parent) throw new Error("missing: " + nodeId);
          if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
          if (parent.children) parent.children.push(node);
          else parent.children = [node];
          node.parent = parent;
        } else {
          if (root2) throw new Error("multiple roots");
          root2 = node;
        }
      }
      if (!root2) throw new Error("no root");
      if (path2 != null) {
        while (root2.data === imputed && root2.children.length === 1) {
          root2 = root2.children[0], --n2;
        }
        for (let i2 = nodes.length - 1; i2 >= 0; --i2) {
          node = nodes[i2];
          if (node.data !== imputed) break;
          node.data = null;
        }
      }
      root2.parent = preroot;
      root2.eachBefore(function(node2) {
        node2.depth = node2.parent.depth + 1;
        --n2;
      }).eachBefore(computeHeight);
      root2.parent = null;
      if (n2 > 0) throw new Error("cycle");
      return root2;
    }
    stratify.id = function(x3) {
      return arguments.length ? (id4 = optional(x3), stratify) : id4;
    };
    stratify.parentId = function(x3) {
      return arguments.length ? (parentId = optional(x3), stratify) : parentId;
    };
    stratify.path = function(x3) {
      return arguments.length ? (path2 = optional(x3), stratify) : path2;
    };
    return stratify;
  }
  function normalize9(path2) {
    path2 = `${path2}`;
    let i = path2.length;
    if (slash(path2, i - 1) && !slash(path2, i - 2)) path2 = path2.slice(0, -1);
    return path2[0] === "/" ? path2 : `/${path2}`;
  }
  function parentof(path2) {
    let i = path2.length;
    if (i < 2) return "";
    while (--i > 1) if (slash(path2, i)) break;
    return path2.slice(0, i);
  }
  function slash(path2, i) {
    if (path2[i] === "/") {
      let k = 0;
      while (i > 0 && path2[--i] === "\\") ++k;
      if ((k & 1) === 0) return true;
    }
    return false;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/tree.js
  function defaultSeparation2(a3, b) {
    return a3.parent === b.parent ? 1 : 2;
  }
  function nextLeft(v) {
    var children = v.children;
    return children ? children[0] : v.t;
  }
  function nextRight(v) {
    var children = v.children;
    return children ? children[children.length - 1] : v.t;
  }
  function moveSubtree(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function executeShifts(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function nextAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  function TreeNode(node, i) {
    this._ = node;
    this.parent = null;
    this.children = null;
    this.A = null;
    this.a = this;
    this.z = 0;
    this.m = 0;
    this.c = 0;
    this.s = 0;
    this.t = null;
    this.i = i;
  }
  TreeNode.prototype = Object.create(Node3.prototype);
  function treeRoot(root2) {
    var tree = new TreeNode(root2, 0), node, nodes = [tree], child, children, i, n2;
    while (node = nodes.pop()) {
      if (children = node._.children) {
        node.children = new Array(n2 = children.length);
        for (i = n2 - 1; i >= 0; --i) {
          nodes.push(child = node.children[i] = new TreeNode(children[i], i));
          child.parent = node;
        }
      }
    }
    (tree.parent = new TreeNode(null, 0)).children = [tree];
    return tree;
  }
  function tree_default2() {
    var separation = defaultSeparation2, dx = 1, dy = 1, nodeSize = null;
    function tree(root2) {
      var t = treeRoot(root2);
      t.eachAfter(firstWalk), t.parent.m = -t.z;
      t.eachBefore(secondWalk);
      if (nodeSize) root2.eachBefore(sizeNode);
      else {
        var left2 = root2, right2 = root2, bottom = root2;
        root2.eachBefore(function(node) {
          if (node.x < left2.x) left2 = node;
          if (node.x > right2.x) right2 = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var s2 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s2 - left2.x, kx = dx / (right2.x + s2 + tx), ky = dy / (bottom.depth || 1);
        root2.eachBefore(function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return root2;
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children) {
        executeShifts(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
          vom = nextLeft(vom);
          vop = nextRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !nextRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !nextLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= dx;
      node.y = node.depth * dy;
    }
    tree.separation = function(x3) {
      return arguments.length ? (separation = x3, tree) : separation;
    };
    tree.size = function(x3) {
      return arguments.length ? (nodeSize = false, dx = +x3[0], dy = +x3[1], tree) : nodeSize ? null : [dx, dy];
    };
    tree.nodeSize = function(x3) {
      return arguments.length ? (nodeSize = true, dx = +x3[0], dy = +x3[1], tree) : nodeSize ? [dx, dy] : null;
    };
    return tree;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/treemap/slice.js
  function slice_default(parent, x05, y05, x12, y12) {
    var nodes = parent.children, node, i = -1, n2 = nodes.length, k = parent.value && (y12 - y05) / parent.value;
    while (++i < n2) {
      node = nodes[i], node.x0 = x05, node.x1 = x12;
      node.y0 = y05, node.y1 = y05 += node.value * k;
    }
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/treemap/squarify.js
  var phi = (1 + Math.sqrt(5)) / 2;
  function squarifyRatio(ratio, parent, x05, y05, x12, y12) {
    var rows = [], nodes = parent.children, row2, nodeValue, i0 = 0, i1 = 0, n2 = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
    while (i0 < n2) {
      dx = x12 - x05, dy = y12 - y05;
      do
        sumValue = nodes[i1++].value;
      while (!sumValue && i1 < n2);
      minValue = maxValue = sumValue;
      alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
      beta = sumValue * sumValue * alpha;
      minRatio = Math.max(maxValue / beta, beta / minValue);
      for (; i1 < n2; ++i1) {
        sumValue += nodeValue = nodes[i1].value;
        if (nodeValue < minValue) minValue = nodeValue;
        if (nodeValue > maxValue) maxValue = nodeValue;
        beta = sumValue * sumValue * alpha;
        newRatio = Math.max(maxValue / beta, beta / minValue);
        if (newRatio > minRatio) {
          sumValue -= nodeValue;
          break;
        }
        minRatio = newRatio;
      }
      rows.push(row2 = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
      if (row2.dice) dice_default(row2, x05, y05, x12, value2 ? y05 += dy * sumValue / value2 : y12);
      else slice_default(row2, x05, y05, value2 ? x05 += dx * sumValue / value2 : x12, y12);
      value2 -= sumValue, i0 = i1;
    }
    return rows;
  }
  var squarify_default = function custom5(ratio) {
    function squarify(parent, x05, y05, x12, y12) {
      squarifyRatio(ratio, parent, x05, y05, x12, y12);
    }
    squarify.ratio = function(x3) {
      return custom5((x3 = +x3) > 1 ? x3 : 1);
    };
    return squarify;
  }(phi);

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/treemap/index.js
  function treemap_default() {
    var tile = squarify_default, round5 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
    function treemap(root2) {
      root2.x0 = root2.y0 = 0;
      root2.x1 = dx;
      root2.y1 = dy;
      root2.eachBefore(positionNode);
      paddingStack = [0];
      if (round5) root2.eachBefore(round_default);
      return root2;
    }
    function positionNode(node) {
      var p2 = paddingStack[node.depth], x05 = node.x0 + p2, y05 = node.y0 + p2, x12 = node.x1 - p2, y12 = node.y1 - p2;
      if (x12 < x05) x05 = x12 = (x05 + x12) / 2;
      if (y12 < y05) y05 = y12 = (y05 + y12) / 2;
      node.x0 = x05;
      node.y0 = y05;
      node.x1 = x12;
      node.y1 = y12;
      if (node.children) {
        p2 = paddingStack[node.depth + 1] = paddingInner(node) / 2;
        x05 += paddingLeft(node) - p2;
        y05 += paddingTop(node) - p2;
        x12 -= paddingRight(node) - p2;
        y12 -= paddingBottom(node) - p2;
        if (x12 < x05) x05 = x12 = (x05 + x12) / 2;
        if (y12 < y05) y05 = y12 = (y05 + y12) / 2;
        tile(node, x05, y05, x12, y12);
      }
    }
    treemap.round = function(x3) {
      return arguments.length ? (round5 = !!x3, treemap) : round5;
    };
    treemap.size = function(x3) {
      return arguments.length ? (dx = +x3[0], dy = +x3[1], treemap) : [dx, dy];
    };
    treemap.tile = function(x3) {
      return arguments.length ? (tile = required(x3), treemap) : tile;
    };
    treemap.padding = function(x3) {
      return arguments.length ? treemap.paddingInner(x3).paddingOuter(x3) : treemap.paddingInner();
    };
    treemap.paddingInner = function(x3) {
      return arguments.length ? (paddingInner = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingInner;
    };
    treemap.paddingOuter = function(x3) {
      return arguments.length ? treemap.paddingTop(x3).paddingRight(x3).paddingBottom(x3).paddingLeft(x3) : treemap.paddingTop();
    };
    treemap.paddingTop = function(x3) {
      return arguments.length ? (paddingTop = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingTop;
    };
    treemap.paddingRight = function(x3) {
      return arguments.length ? (paddingRight = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingRight;
    };
    treemap.paddingBottom = function(x3) {
      return arguments.length ? (paddingBottom = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingBottom;
    };
    treemap.paddingLeft = function(x3) {
      return arguments.length ? (paddingLeft = typeof x3 === "function" ? x3 : constant_default2(+x3), treemap) : paddingLeft;
    };
    return treemap;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/treemap/binary.js
  function binary_default(parent, x05, y05, x12, y12) {
    var nodes = parent.children, i, n2 = nodes.length, sum3, sums = new Array(n2 + 1);
    for (sums[0] = sum3 = i = 0; i < n2; ++i) {
      sums[i + 1] = sum3 += nodes[i].value;
    }
    partition(0, n2, parent.value, x05, y05, x12, y12);
    function partition(i2, j, value2, x06, y06, x13, y13) {
      if (i2 >= j - 1) {
        var node = nodes[i2];
        node.x0 = x06, node.y0 = y06;
        node.x1 = x13, node.y1 = y13;
        return;
      }
      var valueOffset = sums[i2], valueTarget = value2 / 2 + valueOffset, k = i2 + 1, hi = j - 1;
      while (k < hi) {
        var mid2 = k + hi >>> 1;
        if (sums[mid2] < valueTarget) k = mid2 + 1;
        else hi = mid2;
      }
      if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i2 + 1 < k) --k;
      var valueLeft = sums[k] - valueOffset, valueRight = value2 - valueLeft;
      if (x13 - x06 > y13 - y06) {
        var xk = value2 ? (x06 * valueRight + x13 * valueLeft) / value2 : x13;
        partition(i2, k, valueLeft, x06, y06, xk, y13);
        partition(k, j, valueRight, xk, y06, x13, y13);
      } else {
        var yk = value2 ? (y06 * valueRight + y13 * valueLeft) / value2 : y13;
        partition(i2, k, valueLeft, x06, y06, x13, yk);
        partition(k, j, valueRight, x06, yk, x13, y13);
      }
    }
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/treemap/sliceDice.js
  function sliceDice_default(parent, x05, y05, x12, y12) {
    (parent.depth & 1 ? slice_default : dice_default)(parent, x05, y05, x12, y12);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/node_modules/d3-hierarchy/src/treemap/resquarify.js
  var resquarify_default = function custom6(ratio) {
    function resquarify(parent, x05, y05, x12, y12) {
      if ((rows = parent._squarify) && rows.ratio === ratio) {
        var rows, row2, nodes, i, j = -1, n2, m3 = rows.length, value2 = parent.value;
        while (++j < m3) {
          row2 = rows[j], nodes = row2.children;
          for (i = row2.value = 0, n2 = nodes.length; i < n2; ++i) row2.value += nodes[i].value;
          if (row2.dice) dice_default(row2, x05, y05, x12, value2 ? y05 += (y12 - y05) * row2.value / value2 : y12);
          else slice_default(row2, x05, y05, value2 ? x05 += (x12 - x05) * row2.value / value2 : x12, y12);
          value2 -= row2.value;
        }
      } else {
        parent._squarify = rows = squarifyRatio(ratio, parent, x05, y05, x12, y12);
        rows.ratio = ratio;
      }
    }
    resquarify.ratio = function(x3) {
      return custom6((x3 = +x3) > 1 ? x3 : 1);
    };
    return resquarify;
  }(phi);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/treeDataTransform.js
  function generateHierarchyRoot(data2, path2) {
    if (Array.isArray(data2)) {
      return typeof path2 === "function" ? stratify_default().path(path2)(data2) : stratify_default()(data2);
    }
    return hierarchy(data2);
  }
  function addObjectDataPath(root2, path2 = [root2.data.name]) {
    root2.id = root2.id || root2.data.name;
    root2.path = path2;
    if (root2.children) {
      root2.children.forEach((item) => {
        item.id = `${root2.id}/${item.data.name}`;
        item.path = [...path2, item.data.name];
        addObjectDataPath(item, item.path);
      });
    }
  }
  function addArrayDataPath(root2) {
    const name2 = get_default(root2, ["data", "name"]);
    if (name2.replaceAll) {
      root2.path = name2.replaceAll(".", "/").split("/");
    }
    if (root2.children) {
      root2.children.forEach((item) => {
        addArrayDataPath(item);
      });
    }
  }
  function getTileMethod(tile, ratio) {
    const tiles = {
      treemapBinary: binary_default,
      treemapDice: dice_default,
      treemapSlice: slice_default,
      treemapSliceDice: sliceDice_default,
      treemapSquarify: squarify_default,
      treemapResquarify: resquarify_default
    };
    const tileMethod = tile === "treemapSquarify" ? tiles[tile].ratio(ratio) : tiles[tile];
    if (!tileMethod) {
      throw new TypeError("Invalid tile method!");
    }
    return tileMethod;
  }
  function treeDataTransform(data2, layout, encode) {
    const { value: value2 } = encode;
    const tileMethod = getTileMethod(layout.tile, layout.ratio);
    const root2 = generateHierarchyRoot(data2, layout.path);
    if (is_array_default(data2)) {
      addArrayDataPath(root2);
    } else {
      addObjectDataPath(root2);
    }
    value2 ? root2.sum((d2) => layout.ignoreParentValue && d2.children ? 0 : field(value2)(d2)).sort(layout.sort) : root2.count();
    treemap_default().tile(tileMethod).size(layout.size).round(layout.round).paddingInner(layout.paddingInner).paddingOuter(layout.paddingOuter).paddingTop(layout.paddingTop).paddingRight(layout.paddingRight).paddingBottom(layout.paddingBottom).paddingLeft(layout.paddingLeft)(root2);
    const nodes = root2.descendants().map((d2) => Object.assign(d2, {
      id: d2.id.replace(/^\//, ""),
      x: [d2.x0, d2.x1],
      y: [d2.y0, d2.y1]
    }));
    const filterData = nodes.filter(typeof layout.layer === "function" ? layout.layer : (d2) => d2.height === layout.layer);
    return [filterData, nodes];
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/treemap.js
  var __rest46 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var GET_DEFAULT_LAYOUT_OPTIONS = (width, height) => ({
    tile: "treemapSquarify",
    ratio: 0.5 * (1 + Math.sqrt(5)),
    size: [width, height],
    round: false,
    ignoreParentValue: true,
    padding: 0,
    paddingInner: 0,
    paddingOuter: 0,
    paddingTop: 0,
    paddingRight: 0,
    paddingBottom: 0,
    paddingLeft: 0,
    sort: (a3, b) => b.value - a3.value,
    layer: 0
  });
  var GET_DEFAULT_OPTIONS = (width, height) => ({
    type: "rect",
    axis: false,
    encode: {
      x: "x",
      y: "y",
      key: "id",
      color: (d2) => d2.path[1]
    },
    scale: {
      x: { domain: [0, width], range: [0, 1] },
      y: { domain: [0, height], range: [0, 1] }
    },
    style: {
      stroke: "#fff"
    },
    state: {
      active: { opacity: 0.6 },
      inactive: { opacity: 1 }
    }
  });
  var DEFAULT_LABEL_OPTIONS3 = {
    fontSize: 10,
    text: (d2) => last(d2.path),
    position: "inside",
    fill: "#000",
    textOverflow: "clip",
    wordWrap: true,
    maxLines: 1,
    wordWrapWidth: (d2) => d2.x1 - d2.x0
  };
  var DEFAULT_TOOLTIP_OPTIONS = {
    title: (d2) => {
      var _a, _b;
      return (_b = (_a = d2.path) === null || _a === void 0 ? void 0 : _a.join) === null || _b === void 0 ? void 0 : _b.call(_a, ".");
    },
    items: [{ field: "value" }]
  };
  var DEFAULT_TOOLTIP_OPTIONS_DRILL = {
    title: (d2) => last(d2.path),
    items: [{ field: "value" }]
  };
  var Treemap = (options, context) => {
    const { width, height, options: markOptions } = context;
    const { data: data2, encode = {}, scale: scale9, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = options, resOptions = __rest46(options, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
    const treemapDrillDown = get_default(markOptions, [
      "interaction",
      "treemapDrillDown"
    ]);
    const layoutOptions = deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS(width, height), layout, {
      layer: treemapDrillDown ? (d2) => {
        return d2.depth === 1;
      } : layout.layer
    });
    const [transformedData, transformedDataAll] = treeDataTransform(data2, layoutOptions, encode);
    const labelStyle = subObject(style, "label");
    return deep_mix_default({}, GET_DEFAULT_OPTIONS(width, height), Object.assign(Object.assign({
      data: transformedData,
      scale: scale9,
      style,
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS3), labelStyle),
        ...labels
      ]
    }, resOptions), { encode, tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS), axis: false }), treemapDrillDown ? {
      interaction: Object.assign(Object.assign({}, resOptions.interaction), { treemapDrillDown: treemapDrillDown ? Object.assign(Object.assign({}, treemapDrillDown), { originData: transformedDataAll, layout: layoutOptions }) : void 0 }),
      encode: Object.assign({ color: (d2) => last(d2.path) }, encode),
      tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS_DRILL)
    } : {});
  };
  Treemap.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/pack.js
  var __rest47 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var GET_DEFAULT_LAYOUT_OPTIONS2 = (width, height) => ({
    size: [width, height],
    padding: 0,
    sort: (a3, b) => b.value - a3.value
  });
  var GET_DEFAULT_OPTIONS2 = (width, height, encode) => ({
    type: "point",
    axis: false,
    legend: false,
    scale: {
      x: { domain: [0, width] },
      y: { domain: [0, height] },
      size: { type: "identity" }
    },
    encode: {
      x: "x",
      y: "y",
      size: "r",
      shape: "point"
    },
    style: {
      fill: !encode.color ? (d2) => d2.height === 0 ? "#ddd" : "#fff" : void 0,
      stroke: !encode.color ? (d2) => d2.height === 0 ? "" : "#000" : void 0
    }
  });
  var DEFAULT_LABEL_OPTIONS4 = {
    text: "",
    position: "inside",
    textOverflow: "clip",
    wordWrap: true,
    maxLines: 1,
    wordWrapWidth: (d2) => d2.r * 2
  };
  var DEFAULT_TOOLTIP_OPTIONS2 = {
    title: (d2) => d2.data.name,
    items: [{ field: "value" }]
  };
  var dataTransform = (data2, layout, encode) => {
    const { value: value2 } = encode;
    const root2 = is_array_default(data2) ? stratify_default().path(layout.path)(data2) : hierarchy(data2);
    value2 ? root2.sum((d2) => field(value2)(d2)).sort(layout.sort) : root2.count();
    pack_default().size(layout.size).padding(layout.padding)(root2);
    return root2.descendants();
  };
  var Pack2 = (markOptions, context) => {
    const { width, height } = context;
    const { data: data2, encode = {}, scale: scale9 = {}, style = {}, layout = {}, labels = [], tooltip: tooltip2 = {} } = markOptions, resOptions = __rest47(markOptions, ["data", "encode", "scale", "style", "layout", "labels", "tooltip"]);
    const DEFAULT_OPTIONS6 = GET_DEFAULT_OPTIONS2(width, height, encode);
    const transformedData = dataTransform(data2, deep_mix_default({}, GET_DEFAULT_LAYOUT_OPTIONS2(width, height), layout), deep_mix_default({}, DEFAULT_OPTIONS6["encode"], encode));
    const labelStyle = subObject(style, "label");
    return deep_mix_default({}, DEFAULT_OPTIONS6, Object.assign(Object.assign({
      data: transformedData,
      encode,
      scale: scale9,
      style,
      labels: [
        Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS4), labelStyle),
        ...labels
      ]
    }, resOptions), { tooltip: maybeTooltip(tooltip2, DEFAULT_TOOLTIP_OPTIONS2), axis: false }));
  };
  Pack2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/boxplot.js
  var __rest48 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function min9(I, V) {
    return min4(I, (i) => V[i]);
  }
  function max9(I, V) {
    return max4(I, (i) => V[i]);
  }
  function lower(I, V) {
    const lo = q1(I, V) * 2.5 - q3(I, V) * 1.5;
    return min4(I, (i) => V[i] >= lo ? V[i] : NaN);
  }
  function q1(I, V) {
    return quantile(I, 0.25, (i) => V[i]);
  }
  function q2(I, V) {
    return quantile(I, 0.5, (i) => V[i]);
  }
  function q3(I, V) {
    return quantile(I, 0.75, (i) => V[i]);
  }
  function upper(I, V) {
    const hi = q3(I, V) * 2.5 - q1(I, V) * 1.5;
    return max4(I, (i) => V[i] <= hi ? V[i] : NaN);
  }
  function OutlierY() {
    return (I, mark) => {
      const { encode } = mark;
      const { y: y3, x: x3 } = encode;
      const { value: V } = y3;
      const { value: X } = x3;
      const GI = Array.from(group(I, (i) => X[+i]).values());
      const FI = GI.flatMap((I2) => {
        const lo = lower(I2, V);
        const hi = upper(I2, V);
        return I2.filter((i) => V[i] < lo || V[i] > hi);
      });
      return [FI, mark];
    };
  }
  var Boxplot = (options) => {
    const { data: data2, encode, style = {}, tooltip: tooltip2 = {}, transform, animate: animate2 } = options, rest = __rest48(options, ["data", "encode", "style", "tooltip", "transform", "animate"]);
    const { point: point6 = true } = style, restStyle = __rest48(style, ["point"]);
    const { y: y3 } = encode;
    const encodeY = { y: y3, y1: y3, y2: y3, y3, y4: y3 };
    const qy = { y1: q1, y2: q2, y3: q3 };
    const boxTooltip = subTooltip(tooltip2, "box", {
      items: [
        { channel: "y", name: "min" },
        { channel: "y1", name: "q1" },
        { channel: "y2", name: "q2" },
        { channel: "y3", name: "q3" },
        { channel: "y4", name: "max" }
      ]
    }, true);
    const pointTooltip = subTooltip(tooltip2, "point", {
      title: { channel: "x" },
      items: [{ name: "outlier", channel: "y" }]
    });
    if (!point6) {
      return Object.assign({ type: "box", data: data2, transform: [
        Object.assign(Object.assign({ type: "groupX", y: min9 }, qy), { y4: max9 })
      ], encode: Object.assign(Object.assign({}, encode), encodeY), style: restStyle, tooltip: boxTooltip }, rest);
    }
    const boxStyle = subObject(restStyle, "box");
    const pointStyle = subObject(restStyle, "point");
    return [
      Object.assign({ type: "box", data: data2, transform: [
        Object.assign(Object.assign({ type: "groupX", y: lower }, qy), { y4: upper })
      ], encode: Object.assign(Object.assign({}, encode), encodeY), style: boxStyle, tooltip: boxTooltip, animate: maybeAnimation(animate2, "box") }, rest),
      // Draw outliers.
      {
        type: "point",
        data: data2,
        transform: [{ type: OutlierY }],
        encode,
        style: Object.assign({}, pointStyle),
        tooltip: pointTooltip,
        animate: maybeAnimation(animate2, "point")
      }
    ];
  };
  Boxplot.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/shape.js
  var shape20 = {
    shape: Shape2
  };
  var Shape3 = (options) => {
    const { cartesian: cartesian2 } = options;
    if (cartesian2)
      return visualMark;
    return (index4, scale9, value2, coordinate) => {
      const { x: X, y: Y } = value2;
      const offset3 = createBandOffset(scale9, value2, options);
      const P = Array.from(index4, (i) => {
        const p2 = [+X[i], +Y[i]];
        return [coordinate.map(offset3(p2, i))];
      });
      return [index4, P];
    };
  };
  Shape3.props = {
    defaultShape: "shape",
    defaultLabelShape: "label",
    composite: false,
    shape: shape20,
    channels: [
      { name: "x", required: true },
      { name: "y", required: true }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeTuple },
      { type: MaybeVisualPosition },
      { type: MaybeFunctionAttribute }
    ]
  };

  // ../../engine/rails_design/node_modules/d3-force/src/center.js
  function center_default(x3, y3) {
    var nodes, strength = 1;
    if (x3 == null) x3 = 0;
    if (y3 == null) y3 = 0;
    function force() {
      var i, n2 = nodes.length, node, sx = 0, sy = 0;
      for (i = 0; i < n2; ++i) {
        node = nodes[i], sx += node.x, sy += node.y;
      }
      for (sx = (sx / n2 - x3) * strength, sy = (sy / n2 - y3) * strength, i = 0; i < n2; ++i) {
        node = nodes[i], node.x -= sx, node.y -= sy;
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
    };
    force.x = function(_2) {
      return arguments.length ? (x3 = +_2, force) : x3;
    };
    force.y = function(_2) {
      return arguments.length ? (y3 = +_2, force) : y3;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = +_2, force) : strength;
    };
    return force;
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/add.js
  function add_default(d2) {
    const x3 = +this._x.call(null, d2), y3 = +this._y.call(null, d2);
    return add10(this.cover(x3, y3), x3, y3, d2);
  }
  function add10(tree, x3, y3, d2) {
    if (isNaN(x3) || isNaN(y3)) return tree;
    var parent, node = tree._root, leaf = { data: d2 }, x05 = tree._x0, y05 = tree._y0, x12 = tree._x1, y12 = tree._y1, xm, ym, xp, yp, right2, bottom, i, j;
    if (!node) return tree._root = leaf, tree;
    while (node.length) {
      if (right2 = x3 >= (xm = (x05 + x12) / 2)) x05 = xm;
      else x12 = xm;
      if (bottom = y3 >= (ym = (y05 + y12) / 2)) y05 = ym;
      else y12 = ym;
      if (parent = node, !(node = node[i = bottom << 1 | right2])) return parent[i] = leaf, tree;
    }
    xp = +tree._x.call(null, node.data);
    yp = +tree._y.call(null, node.data);
    if (x3 === xp && y3 === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;
    do {
      parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
      if (right2 = x3 >= (xm = (x05 + x12) / 2)) x05 = xm;
      else x12 = xm;
      if (bottom = y3 >= (ym = (y05 + y12) / 2)) y05 = ym;
      else y12 = ym;
    } while ((i = bottom << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));
    return parent[j] = node, parent[i] = leaf, tree;
  }
  function addAll(data2) {
    var d2, i, n2 = data2.length, x3, y3, xz = new Array(n2), yz = new Array(n2), x05 = Infinity, y05 = Infinity, x12 = -Infinity, y12 = -Infinity;
    for (i = 0; i < n2; ++i) {
      if (isNaN(x3 = +this._x.call(null, d2 = data2[i])) || isNaN(y3 = +this._y.call(null, d2))) continue;
      xz[i] = x3;
      yz[i] = y3;
      if (x3 < x05) x05 = x3;
      if (x3 > x12) x12 = x3;
      if (y3 < y05) y05 = y3;
      if (y3 > y12) y12 = y3;
    }
    if (x05 > x12 || y05 > y12) return this;
    this.cover(x05, y05).cover(x12, y12);
    for (i = 0; i < n2; ++i) {
      add10(this, xz[i], yz[i], data2[i]);
    }
    return this;
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/cover.js
  function cover_default(x3, y3) {
    if (isNaN(x3 = +x3) || isNaN(y3 = +y3)) return this;
    var x05 = this._x0, y05 = this._y0, x12 = this._x1, y12 = this._y1;
    if (isNaN(x05)) {
      x12 = (x05 = Math.floor(x3)) + 1;
      y12 = (y05 = Math.floor(y3)) + 1;
    } else {
      var z = x12 - x05 || 1, node = this._root, parent, i;
      while (x05 > x3 || x3 >= x12 || y05 > y3 || y3 >= y12) {
        i = (y3 < y05) << 1 | x3 < x05;
        parent = new Array(4), parent[i] = node, node = parent, z *= 2;
        switch (i) {
          case 0:
            x12 = x05 + z, y12 = y05 + z;
            break;
          case 1:
            x05 = x12 - z, y12 = y05 + z;
            break;
          case 2:
            x12 = x05 + z, y05 = y12 - z;
            break;
          case 3:
            x05 = x12 - z, y05 = y12 - z;
            break;
        }
      }
      if (this._root && this._root.length) this._root = node;
    }
    this._x0 = x05;
    this._y0 = y05;
    this._x1 = x12;
    this._y1 = y12;
    return this;
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/data.js
  function data_default() {
    var data2 = [];
    this.visit(function(node) {
      if (!node.length) do
        data2.push(node.data);
      while (node = node.next);
    });
    return data2;
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/extent.js
  function extent_default(_2) {
    return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/quad.js
  function quad_default(node, x05, y05, x12, y12) {
    this.node = node;
    this.x0 = x05;
    this.y0 = y05;
    this.x1 = x12;
    this.y1 = y12;
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/find.js
  function find_default3(x3, y3, radius) {
    var data2, x05 = this._x0, y05 = this._y0, x12, y12, x22, y22, x32 = this._x1, y32 = this._y1, quads = [], node = this._root, q, i;
    if (node) quads.push(new quad_default(node, x05, y05, x32, y32));
    if (radius == null) radius = Infinity;
    else {
      x05 = x3 - radius, y05 = y3 - radius;
      x32 = x3 + radius, y32 = y3 + radius;
      radius *= radius;
    }
    while (q = quads.pop()) {
      if (!(node = q.node) || (x12 = q.x0) > x32 || (y12 = q.y0) > y32 || (x22 = q.x1) < x05 || (y22 = q.y1) < y05) continue;
      if (node.length) {
        var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
        quads.push(
          new quad_default(node[3], xm, ym, x22, y22),
          new quad_default(node[2], x12, ym, xm, y22),
          new quad_default(node[1], xm, y12, x22, ym),
          new quad_default(node[0], x12, y12, xm, ym)
        );
        if (i = (y3 >= ym) << 1 | x3 >= xm) {
          q = quads[quads.length - 1];
          quads[quads.length - 1] = quads[quads.length - 1 - i];
          quads[quads.length - 1 - i] = q;
        }
      } else {
        var dx = x3 - +this._x.call(null, node.data), dy = y3 - +this._y.call(null, node.data), d2 = dx * dx + dy * dy;
        if (d2 < radius) {
          var d3 = Math.sqrt(radius = d2);
          x05 = x3 - d3, y05 = y3 - d3;
          x32 = x3 + d3, y32 = y3 + d3;
          data2 = node.data;
        }
      }
    }
    return data2;
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/remove.js
  function remove_default(d2) {
    if (isNaN(x3 = +this._x.call(null, d2)) || isNaN(y3 = +this._y.call(null, d2))) return this;
    var parent, node = this._root, retainer, previous, next, x05 = this._x0, y05 = this._y0, x12 = this._x1, y12 = this._y1, x3, y3, xm, ym, right2, bottom, i, j;
    if (!node) return this;
    if (node.length) while (true) {
      if (right2 = x3 >= (xm = (x05 + x12) / 2)) x05 = xm;
      else x12 = xm;
      if (bottom = y3 >= (ym = (y05 + y12) / 2)) y05 = ym;
      else y12 = ym;
      if (!(parent = node, node = node[i = bottom << 1 | right2])) return this;
      if (!node.length) break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
    }
    while (node.data !== d2) if (!(previous = node, node = node.next)) return this;
    if (next = node.next) delete node.next;
    if (previous) return next ? previous.next = next : delete previous.next, this;
    if (!parent) return this._root = next, this;
    next ? parent[i] = next : delete parent[i];
    if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
      if (retainer) retainer[j] = node;
      else this._root = node;
    }
    return this;
  }
  function removeAll(data2) {
    for (var i = 0, n2 = data2.length; i < n2; ++i) this.remove(data2[i]);
    return this;
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/root.js
  function root_default() {
    return this._root;
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/size.js
  function size_default() {
    var size2 = 0;
    this.visit(function(node) {
      if (!node.length) do
        ++size2;
      while (node = node.next);
    });
    return size2;
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/visit.js
  function visit_default2(callback) {
    var quads = [], q, node = this._root, child, x05, y05, x12, y12;
    if (node) quads.push(new quad_default(node, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      if (!callback(node = q.node, x05 = q.x0, y05 = q.y0, x12 = q.x1, y12 = q.y1) && node.length) {
        var xm = (x05 + x12) / 2, ym = (y05 + y12) / 2;
        if (child = node[3]) quads.push(new quad_default(child, xm, ym, x12, y12));
        if (child = node[2]) quads.push(new quad_default(child, x05, ym, xm, y12));
        if (child = node[1]) quads.push(new quad_default(child, xm, y05, x12, ym));
        if (child = node[0]) quads.push(new quad_default(child, x05, y05, xm, ym));
      }
    }
    return this;
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/visitAfter.js
  function visitAfter_default(callback) {
    var quads = [], next = [], q;
    if (this._root) quads.push(new quad_default(this._root, this._x0, this._y0, this._x1, this._y1));
    while (q = quads.pop()) {
      var node = q.node;
      if (node.length) {
        var child, x05 = q.x0, y05 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x05 + x12) / 2, ym = (y05 + y12) / 2;
        if (child = node[0]) quads.push(new quad_default(child, x05, y05, xm, ym));
        if (child = node[1]) quads.push(new quad_default(child, xm, y05, x12, ym));
        if (child = node[2]) quads.push(new quad_default(child, x05, ym, xm, y12));
        if (child = node[3]) quads.push(new quad_default(child, xm, ym, x12, y12));
      }
      next.push(q);
    }
    while (q = next.pop()) {
      callback(q.node, q.x0, q.y0, q.x1, q.y1);
    }
    return this;
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/x.js
  function defaultX(d2) {
    return d2[0];
  }
  function x_default(_2) {
    return arguments.length ? (this._x = _2, this) : this._x;
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/y.js
  function defaultY(d2) {
    return d2[1];
  }
  function y_default(_2) {
    return arguments.length ? (this._y = _2, this) : this._y;
  }

  // ../../engine/rails_design/node_modules/d3-quadtree/src/quadtree.js
  function quadtree(nodes, x3, y3) {
    var tree = new Quadtree(x3 == null ? defaultX : x3, y3 == null ? defaultY : y3, NaN, NaN, NaN, NaN);
    return nodes == null ? tree : tree.addAll(nodes);
  }
  function Quadtree(x3, y3, x05, y05, x12, y12) {
    this._x = x3;
    this._y = y3;
    this._x0 = x05;
    this._y0 = y05;
    this._x1 = x12;
    this._y1 = y12;
    this._root = void 0;
  }
  function leaf_copy(leaf) {
    var copy7 = { data: leaf.data }, next = copy7;
    while (leaf = leaf.next) next = next.next = { data: leaf.data };
    return copy7;
  }
  var treeProto = quadtree.prototype = Quadtree.prototype;
  treeProto.copy = function() {
    var copy7 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node = this._root, nodes, child;
    if (!node) return copy7;
    if (!node.length) return copy7._root = leaf_copy(node), copy7;
    nodes = [{ source: node, target: copy7._root = new Array(4) }];
    while (node = nodes.pop()) {
      for (var i = 0; i < 4; ++i) {
        if (child = node.source[i]) {
          if (child.length) nodes.push({ source: child, target: node.target[i] = new Array(4) });
          else node.target[i] = leaf_copy(child);
        }
      }
    }
    return copy7;
  };
  treeProto.add = add_default;
  treeProto.addAll = addAll;
  treeProto.cover = cover_default;
  treeProto.data = data_default;
  treeProto.extent = extent_default;
  treeProto.find = find_default3;
  treeProto.remove = remove_default;
  treeProto.removeAll = removeAll;
  treeProto.root = root_default;
  treeProto.size = size_default;
  treeProto.visit = visit_default2;
  treeProto.visitAfter = visitAfter_default;
  treeProto.x = x_default;
  treeProto.y = y_default;

  // ../../engine/rails_design/node_modules/d3-force/src/constant.js
  function constant_default3(x3) {
    return function() {
      return x3;
    };
  }

  // ../../engine/rails_design/node_modules/d3-force/src/jiggle.js
  function jiggle_default(random5) {
    return (random5() - 0.5) * 1e-6;
  }

  // ../../engine/rails_design/node_modules/d3-force/src/link.js
  function index3(d2) {
    return d2.index;
  }
  function find5(nodeById, nodeId) {
    var node = nodeById.get(nodeId);
    if (!node) throw new Error("node not found: " + nodeId);
    return node;
  }
  function link_default(links) {
    var id4 = index3, strength = defaultStrength, strengths, distance8 = constant_default3(30), distances, nodes, count4, bias, random5, iterations2 = 1;
    if (links == null) links = [];
    function defaultStrength(link2) {
      return 1 / Math.min(count4[link2.source.index], count4[link2.target.index]);
    }
    function force(alpha) {
      for (var k = 0, n2 = links.length; k < iterations2; ++k) {
        for (var i = 0, link2, source, target, x3, y3, l2, b; i < n2; ++i) {
          link2 = links[i], source = link2.source, target = link2.target;
          x3 = target.x + target.vx - source.x - source.vx || jiggle_default(random5);
          y3 = target.y + target.vy - source.y - source.vy || jiggle_default(random5);
          l2 = Math.sqrt(x3 * x3 + y3 * y3);
          l2 = (l2 - distances[i]) / l2 * alpha * strengths[i];
          x3 *= l2, y3 *= l2;
          target.vx -= x3 * (b = bias[i]);
          target.vy -= y3 * b;
          source.vx += x3 * (b = 1 - b);
          source.vy += y3 * b;
        }
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n2 = nodes.length, m3 = links.length, nodeById = new Map(nodes.map((d2, i2) => [id4(d2, i2, nodes), d2])), link2;
      for (i = 0, count4 = new Array(n2); i < m3; ++i) {
        link2 = links[i], link2.index = i;
        if (typeof link2.source !== "object") link2.source = find5(nodeById, link2.source);
        if (typeof link2.target !== "object") link2.target = find5(nodeById, link2.target);
        count4[link2.source.index] = (count4[link2.source.index] || 0) + 1;
        count4[link2.target.index] = (count4[link2.target.index] || 0) + 1;
      }
      for (i = 0, bias = new Array(m3); i < m3; ++i) {
        link2 = links[i], bias[i] = count4[link2.source.index] / (count4[link2.source.index] + count4[link2.target.index]);
      }
      strengths = new Array(m3), initializeStrength();
      distances = new Array(m3), initializeDistance();
    }
    function initializeStrength() {
      if (!nodes) return;
      for (var i = 0, n2 = links.length; i < n2; ++i) {
        strengths[i] = +strength(links[i], i, links);
      }
    }
    function initializeDistance() {
      if (!nodes) return;
      for (var i = 0, n2 = links.length; i < n2; ++i) {
        distances[i] = +distance8(links[i], i, links);
      }
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random5 = _random;
      initialize();
    };
    force.links = function(_2) {
      return arguments.length ? (links = _2, initialize(), force) : links;
    };
    force.id = function(_2) {
      return arguments.length ? (id4 = _2, force) : id4;
    };
    force.iterations = function(_2) {
      return arguments.length ? (iterations2 = +_2, force) : iterations2;
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initializeStrength(), force) : strength;
    };
    force.distance = function(_2) {
      return arguments.length ? (distance8 = typeof _2 === "function" ? _2 : constant_default3(+_2), initializeDistance(), force) : distance8;
    };
    return force;
  }

  // ../../engine/rails_design/node_modules/d3-dispatch/src/dispatch.js
  var noop = { value: () => {
  } };
  function dispatch2() {
    for (var i = 0, n2 = arguments.length, _2 = {}, t; i < n2; ++i) {
      if (!(t = arguments[i] + "") || t in _2 || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
      _2[t] = [];
    }
    return new Dispatch(_2);
  }
  function Dispatch(_2) {
    this._ = _2;
  }
  function parseTypenames(typenames, types) {
    return typenames.trim().split(/^|\s+/).map(function(t) {
      var name2 = "", i = t.indexOf(".");
      if (i >= 0) name2 = t.slice(i + 1), t = t.slice(0, i);
      if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
      return { type: t, name: name2 };
    });
  }
  Dispatch.prototype = dispatch2.prototype = {
    constructor: Dispatch,
    on: function(typename, callback) {
      var _2 = this._, T = parseTypenames(typename + "", _2), t, i = -1, n2 = T.length;
      if (arguments.length < 2) {
        while (++i < n2) if ((t = (typename = T[i]).type) && (t = get(_2[t], typename.name))) return t;
        return;
      }
      if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
      while (++i < n2) {
        if (t = (typename = T[i]).type) _2[t] = set7(_2[t], typename.name, callback);
        else if (callback == null) for (t in _2) _2[t] = set7(_2[t], typename.name, null);
      }
      return this;
    },
    copy: function() {
      var copy7 = {}, _2 = this._;
      for (var t in _2) copy7[t] = _2[t].slice();
      return new Dispatch(copy7);
    },
    call: function(type, that) {
      if ((n2 = arguments.length - 2) > 0) for (var args = new Array(n2), i = 0, n2, t; i < n2; ++i) args[i] = arguments[i + 2];
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (t = this._[type], i = 0, n2 = t.length; i < n2; ++i) t[i].value.apply(that, args);
    },
    apply: function(type, that, args) {
      if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
      for (var t = this._[type], i = 0, n2 = t.length; i < n2; ++i) t[i].value.apply(that, args);
    }
  };
  function get(type, name2) {
    for (var i = 0, n2 = type.length, c5; i < n2; ++i) {
      if ((c5 = type[i]).name === name2) {
        return c5.value;
      }
    }
  }
  function set7(type, name2, callback) {
    for (var i = 0, n2 = type.length; i < n2; ++i) {
      if (type[i].name === name2) {
        type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
        break;
      }
    }
    if (callback != null) type.push({ name: name2, value: callback });
    return type;
  }
  var dispatch_default2 = dispatch2;

  // ../../engine/rails_design/node_modules/d3-timer/src/timer.js
  var frame = 0;
  var timeout = 0;
  var interval = 0;
  var pokeDelay = 1e3;
  var taskHead;
  var taskTail;
  var clockLast = 0;
  var clockNow = 0;
  var clockSkew = 0;
  var clock2 = typeof performance === "object" && performance.now ? performance : Date;
  var setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
    setTimeout(f, 17);
  };
  function now3() {
    return clockNow || (setFrame(clearNow), clockNow = clock2.now() + clockSkew);
  }
  function clearNow() {
    clockNow = 0;
  }
  function Timer() {
    this._call = this._time = this._next = null;
  }
  Timer.prototype = timer.prototype = {
    constructor: Timer,
    restart: function(callback, delay, time) {
      if (typeof callback !== "function") throw new TypeError("callback is not a function");
      time = (time == null ? now3() : +time) + (delay == null ? 0 : +delay);
      if (!this._next && taskTail !== this) {
        if (taskTail) taskTail._next = this;
        else taskHead = this;
        taskTail = this;
      }
      this._call = callback;
      this._time = time;
      sleep();
    },
    stop: function() {
      if (this._call) {
        this._call = null;
        this._time = Infinity;
        sleep();
      }
    }
  };
  function timer(callback, delay, time) {
    var t = new Timer();
    t.restart(callback, delay, time);
    return t;
  }
  function timerFlush() {
    now3();
    ++frame;
    var t = taskHead, e3;
    while (t) {
      if ((e3 = clockNow - t._time) >= 0) t._call.call(null, e3);
      t = t._next;
    }
    --frame;
  }
  function wake() {
    clockNow = (clockLast = clock2.now()) + clockSkew;
    frame = timeout = 0;
    try {
      timerFlush();
    } finally {
      frame = 0;
      nap();
      clockNow = 0;
    }
  }
  function poke() {
    var now4 = clock2.now(), delay = now4 - clockLast;
    if (delay > pokeDelay) clockSkew -= delay, clockLast = now4;
  }
  function nap() {
    var t0, t1 = taskHead, t2, time = Infinity;
    while (t1) {
      if (t1._call) {
        if (time > t1._time) time = t1._time;
        t0 = t1, t1 = t1._next;
      } else {
        t2 = t1._next, t1._next = null;
        t1 = t0 ? t0._next = t2 : taskHead = t2;
      }
    }
    taskTail = t0;
    sleep(time);
  }
  function sleep(time) {
    if (frame) return;
    if (timeout) timeout = clearTimeout(timeout);
    var delay = time - clockNow;
    if (delay > 24) {
      if (time < Infinity) timeout = setTimeout(wake, time - clock2.now() - clockSkew);
      if (interval) interval = clearInterval(interval);
    } else {
      if (!interval) clockLast = clock2.now(), interval = setInterval(poke, pokeDelay);
      frame = 1, setFrame(wake);
    }
  }

  // ../../engine/rails_design/node_modules/d3-force/src/lcg.js
  var a2 = 1664525;
  var c2 = 1013904223;
  var m2 = 4294967296;
  function lcg_default2() {
    let s2 = 1;
    return () => (s2 = (a2 * s2 + c2) % m2) / m2;
  }

  // ../../engine/rails_design/node_modules/d3-force/src/simulation.js
  function x2(d2) {
    return d2.x;
  }
  function y2(d2) {
    return d2.y;
  }
  var initialRadius = 10;
  var initialAngle = Math.PI * (3 - Math.sqrt(5));
  function simulation_default(nodes) {
    var simulation, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = /* @__PURE__ */ new Map(), stepper = timer(step2), event = dispatch_default2("tick", "end"), random5 = lcg_default2();
    if (nodes == null) nodes = [];
    function step2() {
      tick3();
      event.call("tick", simulation);
      if (alpha < alphaMin) {
        stepper.stop();
        event.call("end", simulation);
      }
    }
    function tick3(iterations2) {
      var i, n2 = nodes.length, node;
      if (iterations2 === void 0) iterations2 = 1;
      for (var k = 0; k < iterations2; ++k) {
        alpha += (alphaTarget - alpha) * alphaDecay;
        forces.forEach(function(force) {
          force(alpha);
        });
        for (i = 0; i < n2; ++i) {
          node = nodes[i];
          if (node.fx == null) node.x += node.vx *= velocityDecay;
          else node.x = node.fx, node.vx = 0;
          if (node.fy == null) node.y += node.vy *= velocityDecay;
          else node.y = node.fy, node.vy = 0;
        }
      }
      return simulation;
    }
    function initializeNodes() {
      for (var i = 0, n2 = nodes.length, node; i < n2; ++i) {
        node = nodes[i], node.index = i;
        if (node.fx != null) node.x = node.fx;
        if (node.fy != null) node.y = node.fy;
        if (isNaN(node.x) || isNaN(node.y)) {
          var radius = initialRadius * Math.sqrt(0.5 + i), angle4 = i * initialAngle;
          node.x = radius * Math.cos(angle4);
          node.y = radius * Math.sin(angle4);
        }
        if (isNaN(node.vx) || isNaN(node.vy)) {
          node.vx = node.vy = 0;
        }
      }
    }
    function initializeForce(force) {
      if (force.initialize) force.initialize(nodes, random5);
      return force;
    }
    initializeNodes();
    return simulation = {
      tick: tick3,
      restart: function() {
        return stepper.restart(step2), simulation;
      },
      stop: function() {
        return stepper.stop(), simulation;
      },
      nodes: function(_2) {
        return arguments.length ? (nodes = _2, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
      },
      alpha: function(_2) {
        return arguments.length ? (alpha = +_2, simulation) : alpha;
      },
      alphaMin: function(_2) {
        return arguments.length ? (alphaMin = +_2, simulation) : alphaMin;
      },
      alphaDecay: function(_2) {
        return arguments.length ? (alphaDecay = +_2, simulation) : +alphaDecay;
      },
      alphaTarget: function(_2) {
        return arguments.length ? (alphaTarget = +_2, simulation) : alphaTarget;
      },
      velocityDecay: function(_2) {
        return arguments.length ? (velocityDecay = 1 - _2, simulation) : 1 - velocityDecay;
      },
      randomSource: function(_2) {
        return arguments.length ? (random5 = _2, forces.forEach(initializeForce), simulation) : random5;
      },
      force: function(name2, _2) {
        return arguments.length > 1 ? (_2 == null ? forces.delete(name2) : forces.set(name2, initializeForce(_2)), simulation) : forces.get(name2);
      },
      find: function(x3, y3, radius) {
        var i = 0, n2 = nodes.length, dx, dy, d2, node, closest2;
        if (radius == null) radius = Infinity;
        else radius *= radius;
        for (i = 0; i < n2; ++i) {
          node = nodes[i];
          dx = x3 - node.x;
          dy = y3 - node.y;
          d2 = dx * dx + dy * dy;
          if (d2 < radius) closest2 = node, radius = d2;
        }
        return closest2;
      },
      on: function(name2, _2) {
        return arguments.length > 1 ? (event.on(name2, _2), simulation) : event.on(name2);
      }
    };
  }

  // ../../engine/rails_design/node_modules/d3-force/src/manyBody.js
  function manyBody_default() {
    var nodes, node, random5, alpha, strength = constant_default3(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
    function force(_2) {
      var i, n2 = nodes.length, tree = quadtree(nodes, x2, y2).visitAfter(accumulate);
      for (alpha = _2, i = 0; i < n2; ++i) node = nodes[i], tree.visit(apply);
    }
    function initialize() {
      if (!nodes) return;
      var i, n2 = nodes.length, node2;
      strengths = new Array(n2);
      for (i = 0; i < n2; ++i) node2 = nodes[i], strengths[node2.index] = +strength(node2, i, nodes);
    }
    function accumulate(quad) {
      var strength2 = 0, q, c5, weight2 = 0, x3, y3, i;
      if (quad.length) {
        for (x3 = y3 = i = 0; i < 4; ++i) {
          if ((q = quad[i]) && (c5 = Math.abs(q.value))) {
            strength2 += q.value, weight2 += c5, x3 += c5 * q.x, y3 += c5 * q.y;
          }
        }
        quad.x = x3 / weight2;
        quad.y = y3 / weight2;
      } else {
        q = quad;
        q.x = q.data.x;
        q.y = q.data.y;
        do
          strength2 += strengths[q.data.index];
        while (q = q.next);
      }
      quad.value = strength2;
    }
    function apply(quad, x12, _2, x22) {
      if (!quad.value) return true;
      var x3 = quad.x - node.x, y3 = quad.y - node.y, w = x22 - x12, l2 = x3 * x3 + y3 * y3;
      if (w * w / theta2 < l2) {
        if (l2 < distanceMax2) {
          if (x3 === 0) x3 = jiggle_default(random5), l2 += x3 * x3;
          if (y3 === 0) y3 = jiggle_default(random5), l2 += y3 * y3;
          if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
          node.vx += x3 * quad.value * alpha / l2;
          node.vy += y3 * quad.value * alpha / l2;
        }
        return true;
      } else if (quad.length || l2 >= distanceMax2) return;
      if (quad.data !== node || quad.next) {
        if (x3 === 0) x3 = jiggle_default(random5), l2 += x3 * x3;
        if (y3 === 0) y3 = jiggle_default(random5), l2 += y3 * y3;
        if (l2 < distanceMin2) l2 = Math.sqrt(distanceMin2 * l2);
      }
      do
        if (quad.data !== node) {
          w = strengths[quad.data.index] * alpha / l2;
          node.vx += x3 * w;
          node.vy += y3 * w;
        }
      while (quad = quad.next);
    }
    force.initialize = function(_nodes, _random) {
      nodes = _nodes;
      random5 = _random;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
    };
    force.distanceMin = function(_2) {
      return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
    };
    force.distanceMax = function(_2) {
      return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
    };
    force.theta = function(_2) {
      return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
    };
    return force;
  }

  // ../../engine/rails_design/node_modules/d3-force/src/x.js
  function x_default2(x3) {
    var strength = constant_default3(0.1), nodes, strengths, xz;
    if (typeof x3 !== "function") x3 = constant_default3(x3 == null ? 0 : +x3);
    function force(alpha) {
      for (var i = 0, n2 = nodes.length, node; i < n2; ++i) {
        node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n2 = nodes.length;
      strengths = new Array(n2);
      xz = new Array(n2);
      for (i = 0; i < n2; ++i) {
        strengths[i] = isNaN(xz[i] = +x3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
    };
    force.x = function(_2) {
      return arguments.length ? (x3 = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : x3;
    };
    return force;
  }

  // ../../engine/rails_design/node_modules/d3-force/src/y.js
  function y_default2(y3) {
    var strength = constant_default3(0.1), nodes, strengths, yz;
    if (typeof y3 !== "function") y3 = constant_default3(y3 == null ? 0 : +y3);
    function force(alpha) {
      for (var i = 0, n2 = nodes.length, node; i < n2; ++i) {
        node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
      }
    }
    function initialize() {
      if (!nodes) return;
      var i, n2 = nodes.length;
      strengths = new Array(n2);
      yz = new Array(n2);
      for (i = 0; i < n2; ++i) {
        strengths[i] = isNaN(yz[i] = +y3(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
      }
    }
    force.initialize = function(_2) {
      nodes = _2;
      initialize();
    };
    force.strength = function(_2) {
      return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : strength;
    };
    force.y = function(_2) {
      return arguments.length ? (y3 = typeof _2 === "function" ? _2 : constant_default3(+_2), initialize(), force) : y3;
    };
    return force;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/forceGraph.js
  var __rest49 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var DEFAULT_LAYOUT_OPTIONS3 = {
    joint: true
  };
  var DEFAULT_LINK_OPTIONS3 = {
    type: "link",
    axis: false,
    legend: false,
    encode: {
      x: [(d2) => d2.source.x, (d2) => d2.target.x],
      y: [(d2) => d2.source.y, (d2) => d2.target.y]
    },
    style: {
      stroke: "#999",
      strokeOpacity: 0.6
    }
  };
  var DEFAULT_NODE_OPTIONS3 = {
    type: "point",
    axis: false,
    legend: false,
    encode: {
      x: "x",
      y: "y",
      size: 5,
      color: "group",
      shape: "point"
    },
    style: {
      stroke: "#fff"
    }
  };
  var DEFAULT_LABEL_OPTIONS5 = {
    text: ""
  };
  function dataTransform2(data2, layout, encode) {
    const { nodes, links } = data2;
    const { joint, nodeStrength, linkStrength } = layout;
    const { nodeKey = (d2) => d2.id, linkKey = (d2) => d2.id } = encode;
    const nodeForce = manyBody_default();
    const linkForce = link_default(links).id(field(linkKey));
    typeof nodeStrength === "function" && nodeForce.strength(nodeStrength);
    typeof linkStrength === "function" && linkForce.strength(linkStrength);
    const simulation = simulation_default(nodes).force("link", linkForce).force("charge", nodeForce);
    joint ? simulation.force("center", center_default()) : simulation.force("x", x_default2()).force("y", y_default2());
    simulation.stop();
    const n2 = Math.ceil(Math.log(simulation.alphaMin()) / Math.log(1 - simulation.alphaDecay()));
    for (let i = 0; i < n2; i++)
      simulation.tick();
    return {
      nodesData: nodes,
      linksData: links
    };
  }
  var ForceGraph = (options) => {
    const { data: data2, encode: e3 = {}, scale: scale9, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
    const { nodeKey = (d2) => d2.id, linkKey = (d2) => d2.id } = e3, restEncode = __rest49(e3, ["nodeKey", "linkKey"]);
    const encode = Object.assign({ nodeKey, linkKey }, restEncode);
    const nodeEncode = subObject(encode, "node");
    const linkEncode = subObject(encode, "link");
    const { links, nodes } = initializeData(data2, encode);
    const { nodesData, linksData } = dataTransform2({ links, nodes }, deep_mix_default({}, DEFAULT_LAYOUT_OPTIONS3, layout), encode);
    const linkTooltip = subTooltip(tooltip2, "link", {
      items: [
        (d2) => ({ name: "source", value: field(linkKey)(d2.source) }),
        (d2) => ({ name: "target", value: field(linkKey)(d2.target) })
      ]
    });
    const nodeTooltip = subTooltip(tooltip2, "node", {
      items: [(d2) => ({ name: "key", value: field(nodeKey)(d2) })]
    }, true);
    return [
      deep_mix_default({}, DEFAULT_LINK_OPTIONS3, {
        data: linksData,
        encode: linkEncode,
        labels: linkLabels,
        style: subObject(style, "link"),
        tooltip: linkTooltip,
        animate: maybeAnimation(animate2, "link")
      }),
      deep_mix_default({}, DEFAULT_NODE_OPTIONS3, {
        data: nodesData,
        encode: Object.assign({}, nodeEncode),
        scale: scale9,
        style: subObject(style, "node"),
        tooltip: nodeTooltip,
        labels: [
          Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS5), subObject(style, "label")),
          ...nodeLabels
        ],
        animate: maybeAnimation(animate2, "link")
      })
    ];
  };
  ForceGraph.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/cluster.js
  var hierarchyFunction = (layoutFunction) => (options) => {
    return (data2) => {
      const { field: field3 = "value", nodeSize, separation, sortBy, as = ["x", "y"] } = options;
      const [x3, y3] = as;
      const root2 = hierarchy(data2, (d2) => d2.children).sum((d2) => d2[field3]).sort(sortBy);
      const c5 = layoutFunction();
      c5.size([1, 1]);
      if (nodeSize)
        c5.nodeSize(nodeSize);
      if (separation)
        c5.separation(separation);
      c5(root2);
      const nodes = [];
      root2.each((node) => {
        node[x3] = node.x;
        node[y3] = node.y;
        node.name = node.data.name;
        nodes.push(node);
      });
      const edges = root2.links();
      edges.forEach((edge) => {
        edge[x3] = [edge.source[x3], edge.target[x3]];
        edge[y3] = [edge.source[y3], edge.target[y3]];
      });
      return { nodes, edges };
    };
  };
  var Cluster = (options) => {
    return hierarchyFunction(cluster_default)(options);
  };
  Cluster.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/tree.js
  var Tree = (options) => {
    return hierarchyFunction(tree_default2)(options);
  };
  Tree.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/tree.js
  var DEFAULT_LAYOUT_OPTIONS4 = {
    sortBy: (a3, b) => b.value - a3.value
  };
  var DEFAULT_NODE_OPTIONS4 = {
    axis: false,
    legend: false,
    type: "point",
    encode: {
      x: "x",
      y: "y",
      size: 2,
      shape: "point"
    }
  };
  var DEFAULT_LINK_OPTIONS4 = {
    type: "link",
    encode: {
      x: "x",
      y: "y",
      shape: "smooth"
    }
  };
  var DEFAULT_LABEL_OPTIONS6 = {
    text: "",
    fontSize: 10
  };
  var Tree2 = (options) => {
    const { data: data2, encode = {}, scale: scale9 = {}, style = {}, layout = {}, nodeLabels = [], linkLabels = [], animate: animate2 = {}, tooltip: tooltip2 = {} } = options;
    const valueEncode = encode === null || encode === void 0 ? void 0 : encode.value;
    const { nodes, edges } = Tree(Object.assign(Object.assign(Object.assign({}, DEFAULT_LAYOUT_OPTIONS4), layout), { field: valueEncode }))(data2);
    const nodeTooltip = subTooltip(tooltip2, "node", {
      title: "name",
      items: ["value"]
    }, true);
    const linkTooltip = subTooltip(tooltip2, "link", {
      title: "",
      items: [
        (d2) => ({ name: "source", value: d2.source.name }),
        (d2) => ({ name: "target", value: d2.target.name })
      ]
    });
    return [
      deep_mix_default({}, DEFAULT_LINK_OPTIONS4, {
        data: edges,
        encode: subObject(encode, "link"),
        scale: subObject(scale9, "link"),
        labels: linkLabels,
        style: Object.assign({ stroke: "#999" }, subObject(style, "link")),
        tooltip: linkTooltip,
        animate: maybeAnimation(animate2, "link")
      }),
      deep_mix_default({}, DEFAULT_NODE_OPTIONS4, {
        data: nodes,
        scale: subObject(scale9, "node"),
        encode: subObject(encode, "node"),
        labels: [
          Object.assign(Object.assign({}, DEFAULT_LABEL_OPTIONS6), subObject(style, "label")),
          ...nodeLabels
        ],
        style: Object.assign({}, subObject(style, "node")),
        tooltip: nodeTooltip,
        animate: maybeAnimation(animate2, "node")
      })
    ];
  };
  Tree2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/wordCloud.js
  var __awaiter3 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest50 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function initializeData2(data2, encode) {
    const { text = "text", value: value2 = "value" } = encode;
    return data2.map((d2) => Object.assign(Object.assign({}, d2), { text: d2[text], value: d2[value2] }));
  }
  var GET_DEFAULT_OPTIONS3 = () => ({
    axis: false,
    type: "text",
    encode: {
      x: "x",
      y: "y",
      text: "text",
      rotate: "rotate",
      fontSize: "size",
      shape: "tag"
    },
    scale: {
      x: { range: [0, 1] },
      y: { range: [0, 1] }
    },
    style: {
      fontFamily: (d2) => d2.fontFamily
    }
  });
  var WordCloud = (options, context) => __awaiter3(void 0, void 0, void 0, function* () {
    const { width, height } = context;
    const { data: data2, encode = {}, scale: scale9, style = {}, layout = {} } = options, resOptions = __rest50(options, ["data", "encode", "scale", "style", "layout"]);
    const initializedData = initializeData2(data2, encode);
    return deep_mix_default({}, GET_DEFAULT_OPTIONS3(), Object.assign(Object.assign({
      data: {
        value: initializedData,
        transform: [
          Object.assign({ type: "wordCloud", size: [width, height] }, layout)
        ]
      },
      encode,
      scale: scale9,
      style
    }, resOptions), { axis: false }));
  });
  WordCloud.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/gauge.js
  var __rest51 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var indicatorShape = (options, context) => {
    const { shape: shape23, radius } = options, style = __rest51(options, ["shape", "radius"]);
    const pointerStyle = subObject(style, "pointer");
    const pinStyle = subObject(style, "pin");
    const { shape: pointerShape } = pointerStyle, resPointerStyle = __rest51(pointerStyle, ["shape"]);
    const { shape: pinShape } = pinStyle, resPinStyle = __rest51(pinStyle, ["shape"]);
    const { coordinate, theme } = context;
    return (points, value2) => {
      const invertedPoints = points.map((p2) => coordinate.invert(p2));
      const [startAngle, endAngle, innerRadius] = getTransformOptions(coordinate, "polar");
      const newCoordinate = coordinate.clone();
      const { color: stroke2 } = value2;
      const newTransformations = Radial({
        startAngle,
        endAngle,
        innerRadius,
        outerRadius: radius
      });
      newTransformations.push(["cartesian"]);
      newCoordinate.update({
        transformations: newTransformations
      });
      const newPoints = invertedPoints.map((p2) => newCoordinate.map(p2));
      const [x3, y3] = getOrigin(newPoints);
      const [cx, cy] = coordinate.getCenter();
      const pointerAttrs = Object.assign(Object.assign({ x1: x3, y1: y3, x2: cx, y2: cy, stroke: stroke2 }, resPointerStyle), style);
      const pinAttrs = Object.assign(Object.assign({
        cx,
        cy,
        stroke: stroke2
      }, resPinStyle), style);
      const indicatorGroup = select(new Group2());
      if (!isUnset(pointerShape)) {
        typeof pointerShape === "function" ? indicatorGroup.append(() => pointerShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("line").call(applyStyle, pointerAttrs).node();
      }
      if (!isUnset(pinShape)) {
        typeof pinShape === "function" ? indicatorGroup.append(() => pinShape(newPoints, value2, newCoordinate, theme)) : indicatorGroup.append("circle").call(applyStyle, pinAttrs).node();
      }
      return indicatorGroup.node();
    };
  };
  var DEFAULT_OPTIONS3 = {
    coordinate: {
      type: "radial",
      innerRadius: 0.9,
      outerRadius: 1,
      startAngle: -11 / 10 * Math.PI,
      endAngle: 1 / 10 * Math.PI
    },
    axis: {
      x: false
    },
    legend: false,
    tooltip: false,
    encode: {
      x: "x",
      y: "y",
      color: "color"
    },
    scale: {
      color: {
        range: ["#30BF78", "#D0D0D0"]
      }
    }
  };
  var DEFAULT_INDICATOR_OPTIONS = {
    style: {
      shape: indicatorShape,
      lineWidth: 4,
      pointerLineCap: "round",
      pinR: 10,
      pinFill: "#fff",
      radius: 0.6
    }
  };
  var DEFAULT_TEXT_OPTIONS = {
    type: "text",
    style: {
      x: "50%",
      y: "60%",
      textAlign: "center",
      textBaseline: "middle",
      fontSize: 20,
      fontWeight: 800,
      fill: "#888"
    }
  };
  function getGaugeData(data2) {
    if (is_number_default(data2)) {
      const percent = Math.max(0, Math.min(data2, 1));
      return {
        percent,
        target: percent,
        total: 1
      };
    }
    return data2;
  }
  function dataTransform3(data2, scale9) {
    const { name: name2 = "score", target, total, percent, thresholds = [] } = getGaugeData(data2);
    const _target = percent || target;
    const _total = percent ? 1 : total;
    const newScale = Object.assign({ y: {
      domain: [0, _total]
    } }, scale9);
    if (!thresholds.length) {
      return {
        targetData: [{ x: name2, y: _target, color: "target" }],
        totalData: [
          { x: name2, y: _target, color: "target" },
          { x: name2, y: _total - _target, color: "total" }
        ],
        target: _target,
        total: _total,
        scale: newScale
      };
    }
    return {
      targetData: [{ x: name2, y: _target, color: "target" }],
      totalData: thresholds.map((d2, i) => ({
        x: name2,
        y: i >= 1 ? d2 - thresholds[i - 1] : d2,
        color: i
      })),
      target: _target,
      total: _total,
      scale: newScale
    };
  }
  function getTextContent(textStyle, { target, total }) {
    const { content } = textStyle;
    return content ? content(target, total) : target.toString();
  }
  var Gauge = (options) => {
    const { data: data2 = {}, scale: scale9 = {}, style = {}, animate: animate2 = {}, transform = [] } = options, resOptions = __rest51(options, ["data", "scale", "style", "animate", "transform"]);
    const { targetData, totalData, target, total, scale: newScale } = dataTransform3(data2, scale9);
    const textStyle = subObject(style, "text");
    const indicatorStyle = filterPrefixObject(style, ["pointer", "pin"]);
    const arcStyle = subObject(style, "arc");
    const shape23 = arcStyle.shape;
    return [
      deep_mix_default({}, DEFAULT_OPTIONS3, Object.assign({ type: "interval", transform: [{ type: "stackY" }], data: totalData, scale: newScale, style: shape23 === "round" ? Object.assign(Object.assign({}, arcStyle), { shape: Round }) : arcStyle, animate: typeof animate2 === "object" ? subObject(animate2, "arc") : animate2 }, resOptions)),
      deep_mix_default({}, DEFAULT_OPTIONS3, DEFAULT_INDICATOR_OPTIONS, Object.assign({ type: "point", data: targetData, scale: newScale, style: indicatorStyle, animate: typeof animate2 === "object" ? subObject(animate2, "indicator") : animate2 }, resOptions)),
      deep_mix_default({}, DEFAULT_TEXT_OPTIONS, {
        style: Object.assign({ text: getTextContent(textStyle, { target, total }) }, textStyle),
        animate: typeof animate2 === "object" ? subObject(animate2, "text") : animate2
      })
    ];
  };
  Gauge.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/density.js
  var shape21 = {
    density: Density
  };
  var Density2 = () => {
    return (index4, scale9, value2, coordinate) => {
      const { x: X, series: S } = value2;
      const Yn = Object.entries(value2).filter(([key]) => key.startsWith("y")).map(([, value3]) => value3);
      const SZn = Object.entries(value2).filter(([key]) => key.startsWith("size")).map(([, value3]) => value3);
      if (X === void 0 || Yn === void 0 || SZn === void 0) {
        throw new Error("Missing encode for x or y or size channel.");
      }
      const xScale = scale9.x;
      const series = scale9.series;
      const P = Array.from(index4, (i) => {
        const groupWidth = xScale.getBandWidth(xScale.invert(+X[i]));
        const ratio = series ? series.getBandWidth(series.invert(+(S === null || S === void 0 ? void 0 : S[i]))) : 1;
        const width = groupWidth * ratio;
        const offset3 = (+(S === null || S === void 0 ? void 0 : S[i]) || 0) * groupWidth;
        const x3 = +X[i] + offset3 + width / 2;
        const PN = [
          ...Yn.map((_2, idx) => [x3 + +SZn[idx][i] / index4.length, +Yn[idx][i]]),
          ...Yn.map((_2, idx) => [
            x3 - +SZn[idx][i] / index4.length,
            +Yn[idx][i]
          ]).reverse()
          // left
        ];
        return PN.map((p2) => coordinate.map(p2));
      });
      return [index4, P];
    };
  };
  Density2.props = {
    defaultShape: "density",
    defaultLabelShape: "label",
    composite: false,
    shape: shape21,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape21) }),
      { name: "x", scale: "band", required: true },
      { name: "y", required: true },
      { name: "size", required: true },
      { name: "series", scale: "band" },
      { name: "size", required: true, scale: "identity" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeZeroY1 },
      { type: MaybeZeroX }
    ],
    postInference: [...basePostInference(), ...tooltip1d()],
    interaction: { shareTooltip: true }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/heatmap.js
  var shape22 = {
    heatmap: Heatmap
  };
  var Heatmap2 = (options) => {
    return (index4, scale9, value2, coordinate) => {
      const { x: X, y: Y, size: S, color: C3 } = value2;
      const P = Array.from(index4, (i) => {
        const r = S ? +S[i] : 40;
        return [...coordinate.map([+X[i], +Y[i]]), C3[i], r];
      });
      return [[0], [P]];
    };
  };
  Heatmap2.props = {
    defaultShape: "heatmap",
    defaultLabelShape: "label",
    composite: false,
    shape: shape22,
    channels: [
      ...baseGeometryChannels({ shapes: Object.keys(shape22) }),
      { name: "x", required: true },
      { name: "y", required: true },
      { name: "color", scale: "identity", required: true },
      { name: "size" }
    ],
    preInference: [
      ...basePreInference(),
      { type: MaybeZeroX },
      { type: MaybeZeroY }
    ],
    postInference: [...basePostInference(), ...tooltip2d()]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/mark/liquid.js
  var __rest52 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var DEFAULT_OPTIONS4 = {
    axis: {
      x: false,
      y: false
    },
    legend: false,
    tooltip: false,
    encode: {
      x: "type",
      y: "percent"
    },
    scale: {
      y: {
        domain: [0, 1]
      }
    },
    style: {
      shape: Liquid
    },
    animate: {
      enter: {
        type: "fadeIn"
      }
    }
  };
  var DEFAULT_TEXT_OPTIONS2 = {
    type: "text",
    style: {
      x: "50%",
      y: "50%",
      textAlign: "center",
      textBaseline: "middle",
      fontSize: 20,
      fontWeight: 800,
      fill: "#888"
    },
    animate: {
      enter: {
        type: "fadeIn"
      }
    }
  };
  var Liquid2 = (options) => {
    const { data: data2 = {}, style = {}, animate: animate2 } = options, resOptions = __rest52(options, ["data", "style", "animate"]);
    const percent = Math.max(0, is_number_default(data2) ? data2 : data2 === null || data2 === void 0 ? void 0 : data2.percent);
    const newData = [{ percent, type: "liquid" }];
    const contentStyle = Object.assign(Object.assign({}, subObject(style, "text")), subObject(style, "content"));
    const outline = subObject(style, "outline");
    const wave = subObject(style, "wave");
    const background = subObject(style, "background");
    return [
      deep_mix_default({}, DEFAULT_OPTIONS4, Object.assign({ type: "interval", data: newData, style: {
        liquidOptions: {
          percent,
          liquidShape: style === null || style === void 0 ? void 0 : style.shape
        },
        styleOptions: Object.assign(Object.assign({}, style), {
          outline,
          wave,
          background
        })
      }, animate: animate2 }, resOptions)),
      deep_mix_default({}, DEFAULT_TEXT_OPTIONS2, {
        style: Object.assign({ text: `${prettyNumber2(percent * 100)} %` }, contentStyle),
        animate: animate2
      })
    ];
  };
  Liquid2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/palette/category10.js
  var Category10 = () => {
    return [
      "#5B8FF9",
      "#5AD8A6",
      "#5D7092",
      "#F6BD16",
      "#6F5EF9",
      "#6DC8EC",
      "#945FB9",
      "#FF9845",
      "#1E9493",
      "#FF99C3"
    ];
  };
  Category10.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/palette/category20.js
  var Category20 = () => {
    return [
      "#5B8FF9",
      "#CDDDFD",
      "#5AD8A6",
      "#CDF3E4",
      "#5D7092",
      "#CED4DE",
      "#F6BD16",
      "#FCEBB9",
      "#6F5EF9",
      "#D3CEFD",
      "#6DC8EC",
      "#D3EEF9",
      "#945FB9",
      "#DECFEA",
      "#FF9845",
      "#FFE0C7",
      "#1E9493",
      "#BBDEDE",
      "#FF99C3",
      "#FFE0ED"
    ];
  };
  Category20.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/band.js
  var Band3 = (options) => {
    return new Band(options);
  };
  Band3.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/linear.js
  var Linear4 = (options) => {
    return new Linear(options);
  };
  Linear4.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/ordinal.js
  var Ordinal3 = (options) => {
    return new Ordinal(options);
  };
  Ordinal3.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/identity.js
  var Identity2 = (options) => {
    return new Identity(options);
  };
  Identity2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/point.js
  var Point5 = (options) => {
    return new Point(options);
  };
  Point5.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/time.js
  var Time2 = (options) => {
    return new Time(options);
  };
  Time2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/log.js
  var Log2 = (options) => {
    return new Log(options);
  };
  Log2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/pow.js
  var Pow2 = (options) => {
    return new Pow(options);
  };
  Pow2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/threshold.js
  var Threshold2 = (options) => {
    return new Threshold(options);
  };
  Threshold2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/quantile.js
  var Quantile2 = (options) => {
    return new Quantile(options);
  };
  Quantile2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/quantize.js
  var Quantize2 = (options) => {
    return new Quantize(options);
  };
  Quantize2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/sqrt.js
  var Sqrt2 = (options) => {
    return new Sqrt(options);
  };
  Sqrt2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/sequential.js
  var Sequential3 = (options) => {
    return new Sequential(options);
  };
  Sequential3.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/scale/constant.js
  var Constant3 = (options) => {
    return new Constant2(options);
  };
  Constant3.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/theme/create.js
  function create7({ colorDefault, colorBlack, colorWhite, colorStroke, colorBackground, padding1, padding2, padding3, alpha90, alpha65, alpha45, alpha25, alpha10, category10, category20, sizeDefault = 1, padding = "auto", margin = 16 }) {
    return {
      padding,
      margin,
      size: sizeDefault,
      color: colorDefault,
      category10,
      category20,
      enter: {
        duration: 300,
        fill: "both",
        delay: 0
      },
      update: {
        duration: 300,
        fill: "both",
        delay: 0
      },
      exit: {
        duration: 300,
        fill: "both",
        delay: 0
      },
      view: {
        viewFill: colorBackground,
        plotFill: "transparent",
        mainFill: "transparent",
        contentFill: "transparent"
      },
      line: {
        line: {
          fill: "",
          strokeOpacity: 1,
          lineWidth: 1,
          lineCap: "round"
        }
      },
      point: {
        point: {
          r: 3,
          fillOpacity: 0.95,
          lineWidth: 0
        },
        hollow: {
          r: 3,
          strokeOpacity: 0.95,
          lineWidth: 1
        },
        plus: {
          r: 3,
          strokeOpacity: 0.95,
          lineWidth: 3
        },
        diamond: {
          r: 3,
          strokeOpacity: 0.95,
          lineWidth: 1
        }
      },
      interval: {
        rect: {
          fillOpacity: 0.95
        },
        hollow: {
          fill: "",
          strokeOpacity: 1,
          lineWidth: 2
        }
      },
      area: {
        area: {
          fillOpacity: 0.85,
          lineWidth: 0
        }
      },
      polygon: {
        polygon: {
          fillOpacity: 0.95
        }
      },
      cell: {
        cell: {
          fillOpacity: 0.95
        },
        hollow: {
          fill: "",
          strokeOpacity: 1,
          lineWidth: 2
        }
      },
      rect: {
        rect: {
          fillOpacity: 0.95
        },
        hollow: {
          fill: "",
          strokeOpacity: 1,
          lineWidth: 2
        }
      },
      link: {
        link: {
          fill: "",
          strokeOpacity: 1
        }
      },
      vector: {
        vector: {
          fillOpacity: 1
        }
      },
      box: {
        box: {
          fillOpacity: 0.95,
          stroke: colorBlack,
          lineWidth: 1
        }
      },
      text: {
        text: {
          fill: "#1D2129",
          fontSize: 12,
          lineWidth: 0,
          connectorStroke: colorStroke,
          connectorStrokeOpacity: 0.45,
          connectorLineWidth: 1,
          backgroundFill: colorStroke,
          backgroundFillOpacity: 0.15,
          backgroundPadding: [2, 4],
          startMarkerSymbol: "circle",
          startMarkerSize: 4,
          endMarkerSymbol: "circle",
          endMarkerSize: 4
        },
        badge: {
          fill: "#1D2129",
          fillOpacity: 0.65,
          lineWidth: 0,
          fontSize: 10,
          textAlign: "center",
          textBaseline: "middle",
          markerFill: colorStroke,
          markerFillOpacity: 0.25,
          markerStrokeOpacity: 0
        }
      },
      lineX: {
        line: {
          stroke: colorStroke,
          strokeOpacity: 0.45,
          lineWidth: 1
        }
      },
      lineY: {
        line: {
          stroke: colorStroke,
          strokeOpacity: 0.45,
          lineWidth: 1
        }
      },
      rangeX: {
        range: {
          fill: colorStroke,
          fillOpacity: 0.15,
          lineWidth: 0
        }
      },
      rangeY: {
        range: {
          fill: colorStroke,
          fillOpacity: 0.15,
          lineWidth: 0
        }
      },
      connector: {
        connector: {
          stroke: colorStroke,
          strokeOpacity: 0.45,
          lineWidth: 1,
          connectLength1: 12,
          endMarker: true,
          endMarkerSize: 6,
          endMarkerFill: colorStroke,
          endMarkerFillOpacity: 0.95
        }
      },
      axis: {
        arrow: false,
        gridLineDash: [3, 4],
        gridLineWidth: 0.5,
        gridStroke: colorBlack,
        gridStrokeOpacity: alpha10,
        labelAlign: "horizontal",
        labelFill: colorBlack,
        labelOpacity: alpha45,
        labelFontSize: 12,
        labelFontWeight: "normal",
        labelSpacing: padding1,
        line: false,
        lineLineWidth: 0.5,
        lineStroke: colorBlack,
        lineStrokeOpacity: alpha45,
        tickLength: 4,
        tickLineWidth: 1,
        tickStroke: colorBlack,
        tickOpacity: alpha45,
        titleFill: colorBlack,
        titleOpacity: alpha90,
        titleFontSize: 12,
        titleFontWeight: "normal",
        titleSpacing: 12,
        titleTransformOrigin: "center",
        lineArrowOffset: 6,
        lineArrowSize: 6
      },
      axisTop: {
        gridDirection: "positive",
        labelDirection: "negative",
        tickDirection: "negative",
        titlePosition: "top",
        titleSpacing: 12,
        labelSpacing: 4,
        titleTextBaseline: "middle"
      },
      axisBottom: {
        gridDirection: "negative",
        labelDirection: "positive",
        tickDirection: "positive",
        titlePosition: "bottom",
        titleSpacing: 12,
        labelSpacing: 4,
        titleTextBaseline: "bottom",
        titleTransform: "translate(0, 8)"
      },
      axisLeft: {
        gridDirection: "positive",
        labelDirection: "negative",
        labelSpacing: 4,
        tickDirection: "negative",
        titlePosition: "left",
        titleSpacing: 12,
        titleTextBaseline: "middle",
        titleDirection: "vertical",
        titleTransform: "rotate(-90) translate(0, -8)",
        titleTransformOrigin: "center"
      },
      axisRight: {
        gridDirection: "negative",
        labelDirection: "positive",
        labelSpacing: 4,
        tickDirection: "positive",
        titlePosition: "right",
        titleSpacing: 12,
        titleTextBaseline: "top",
        titleDirection: "vertical",
        titleTransformOrigin: "center"
      },
      axisLinear: {
        girdClosed: true,
        gridConnect: "arc",
        gridDirection: "negative",
        gridType: "surround",
        titlePosition: "top",
        titleSpacing: 0
      },
      axisArc: {
        title: false,
        titlePosition: "inner",
        line: false,
        tick: true,
        labelSpacing: 4
      },
      axisRadar: {
        girdClosed: true,
        gridStrokeOpacity: 0.3,
        gridType: "surround",
        label: false,
        tick: false,
        titlePosition: "start"
      },
      legendCategory: {
        backgroundFill: "transparent",
        itemBackgroundFill: "transparent",
        itemLabelFill: colorBlack,
        itemLabelFillOpacity: alpha90,
        itemLabelFontSize: 12,
        itemLabelFontWeight: "normal",
        itemMarkerFillOpacity: 1,
        itemMarkerSize: 8,
        itemSpacing: [padding1, padding1],
        itemValueFill: colorBlack,
        itemValueFillOpacity: 0.65,
        itemValueFontSize: 12,
        itemValueFontWeight: "normal",
        navButtonFill: colorBlack,
        navButtonFillOpacity: 0.65,
        navPageNumFill: colorBlack,
        navPageNumFillOpacity: 0.45,
        navPageNumFontSize: 12,
        padding: 8,
        title: false,
        titleFill: colorBlack,
        titleFillOpacity: 0.65,
        titleFontSize: 12,
        titleFontWeight: "normal",
        titleSpacing: 4,
        tickStroke: colorBlack,
        tickStrokeOpacity: 0.25,
        rowPadding: padding1,
        colPadding: padding2,
        maxRows: 3,
        maxCols: 3
      },
      legendContinuous: {
        handleHeight: 12,
        handleLabelFill: colorBlack,
        handleLabelFillOpacity: alpha45,
        handleLabelFontSize: 12,
        handleLabelFontWeight: "normal",
        handleMarkerFill: colorBlack,
        handleMarkerFillOpacity: 0.6,
        handleMarkerLineWidth: 1,
        handleMarkerStroke: colorBlack,
        handleMarkerStrokeOpacity: 0.25,
        handleWidth: 10,
        labelFill: colorBlack,
        labelFillOpacity: alpha45,
        labelFontSize: 12,
        labelFontWeight: "normal",
        labelSpacing: 3,
        tick: true,
        tickLength: 12,
        ribbonSize: 12,
        ribbonFill: "#aaa",
        handle: true,
        handleLabel: false,
        handleShape: "slider",
        handleIconSize: 12 / 1.8,
        indicator: false,
        titleFontSize: 12,
        titleSpacing: 4,
        titleFontWeight: "normal",
        titleFillOpacity: alpha90,
        tickStroke: colorBlack,
        tickStrokeOpacity: alpha45
      },
      label: {
        fill: colorBlack,
        fillOpacity: 0.65,
        fontSize: 12,
        fontWeight: "normal",
        stroke: void 0,
        offset: 12,
        connectorStroke: colorBlack,
        connectorStrokeOpacity: 0.45,
        connectorLineWidth: 1,
        connectorLength: 12,
        connectorLength2: 8,
        connectorDistance: 4
      },
      innerLabel: {
        fill: colorWhite,
        fontSize: 12,
        fillOpacity: 0.85,
        fontWeight: "normal",
        stroke: void 0,
        offset: 0
      },
      htmlLabel: {
        fontSize: 12,
        opacity: 0.65,
        color: colorBlack,
        fontWeight: "normal"
      },
      slider: {
        trackSize: 16,
        trackFill: colorStroke,
        trackFillOpacity: 1,
        selectionFill: colorDefault,
        selectionFillOpacity: 0.15,
        handleIconSize: 10,
        handleIconFill: "#f7f7f7",
        handleIconFillOpacity: 1,
        handleIconStroke: colorBlack,
        handleIconStrokeOpacity: 0.25,
        handleIconLineWidth: 1,
        handleIconRadius: 2,
        handleLabelFill: colorBlack,
        handleLabelFillOpacity: 0.45,
        handleLabelFontSize: 12,
        handleLabelFontWeight: "normal"
      },
      scrollbar: {
        padding: [0, 0, 0, 0],
        trackSize: 6,
        isRound: true,
        slidable: true,
        scrollable: true,
        trackFill: "#e5e5e5",
        trackFillOpacity: 0,
        thumbFill: "#000",
        thumbFillOpacity: 0.15,
        thumbHighlightedFillOpacity: 0.2
      },
      title: {
        spacing: 8,
        titleFill: colorBlack,
        titleFillOpacity: alpha90,
        titleFontSize: 16,
        titleFontWeight: "bold",
        titleTextBaseline: "top",
        subtitleFill: colorBlack,
        subtitleFillOpacity: alpha65,
        subtitleFontSize: 12,
        subtitleFontWeight: "normal",
        subtitleTextBaseline: "top"
      },
      tooltip: {
        css: {
          ".g2-tooltip": {
            "font-family": "sans-serif"
          }
        }
      }
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/theme/light.js
  var tokens = {
    colorBlack: "#1D2129",
    colorWhite: "#ffffff",
    colorStroke: "#416180",
    colorDefault: "#1783FF",
    colorBackground: "transparent",
    category10: [
      "#1783FF",
      "#00C9C9",
      "#F0884D",
      "#D580FF",
      "#7863FF",
      "#60C42D",
      "#BD8F24",
      "#FF80CA",
      "#2491B3",
      "#17C76F"
    ],
    category20: [
      "#1783FF",
      "#00C9C9",
      "#F0884D",
      "#D580FF",
      "#7863FF",
      "#60C42D",
      "#BD8F24",
      "#FF80CA",
      "#2491B3",
      "#17C76F",
      "#AABA01",
      "#BC7CFC",
      "#237CBC",
      "#2DE379",
      "#CE8032",
      "#FF7AF4",
      "#545FD3",
      "#AFE410",
      "#D8C608",
      "#FFA1E0"
    ],
    padding1: 8,
    padding2: 12,
    padding3: 20,
    alpha90: 0.9,
    alpha65: 0.65,
    alpha45: 0.45,
    alpha25: 0.25,
    alpha10: 0.1
  };
  var defaults2 = create7(tokens);
  var Light = (options) => {
    return deep_mix_default({}, defaults2, options);
  };
  Light.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/theme/classic.js
  var Classic = (options) => {
    return deep_mix_default({}, Light(), {
      category10: "category10",
      category20: "category20"
    }, options);
  };
  Classic.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/theme/dark.js
  var tokens2 = {
    colorBlack: "#fff",
    colorWhite: "#000",
    colorStroke: "#416180",
    colorDefault: "#1783FF",
    colorBackground: "transparent",
    category10: [
      "#1783FF",
      "#00C9C9",
      "#F0884D",
      "#D580FF",
      "#7863FF",
      "#60C42D",
      "#BD8F24",
      "#FF80CA",
      "#2491B3",
      "#17C76F"
    ],
    category20: [
      "#1783FF",
      "#00C9C9",
      "#F0884D",
      "#D580FF",
      "#7863FF",
      "#60C42D",
      "#BD8F24",
      "#FF80CA",
      "#2491B3",
      "#17C76F",
      "#AABA01",
      "#BC7CFC",
      "#237CBC",
      "#2DE379",
      "#CE8032",
      "#FF7AF4",
      "#545FD3",
      "#AFE410",
      "#D8C608",
      "#FFA1E0"
    ],
    padding1: 8,
    padding2: 12,
    padding3: 20,
    alpha90: 0.9,
    alpha65: 0.65,
    alpha45: 0.45,
    alpha25: 0.25,
    alpha10: 0.25
  };
  var defaults3 = create7(tokens2);
  var Dark = (options) => {
    return deep_mix_default({}, defaults3, {
      tooltip: {
        crosshairsStroke: "#fff",
        crosshairsLineWidth: 1,
        crosshairsStrokeOpacity: 0.25,
        css: {
          ".g2-tooltip": {
            background: "#1f1f1f",
            opacity: 0.95
          },
          ".g2-tooltip-title": {
            color: "#A6A6A6"
          },
          ".g2-tooltip-list-item-name-label": {
            color: "#A6A6A6"
          },
          ".g2-tooltip-list-item-value": {
            color: "#A6A6A6"
          }
        }
      }
    }, options);
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/theme/classicDark.js
  var ClassicDark = (options) => {
    return Object.assign({}, Dark(), {
      category10: "category10",
      category20: "category20"
    }, options);
  };
  ClassicDark.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/theme/academy.js
  var tokens3 = {
    colorBlack: "#000",
    colorWhite: "#fff",
    colorStroke: "#888",
    colorDefault: "#4e79a7",
    colorBackground: "transparent",
    category10: [
      "#4e79a7",
      "#f28e2c",
      "#e15759",
      "#76b7b2",
      "#59a14f",
      "#edc949",
      "#af7aa1",
      "#ff9da7",
      "#9c755f",
      "#bab0ab"
    ],
    category20: [
      "#4e79a7",
      "#f28e2c",
      "#e15759",
      "#76b7b2",
      "#59a14f",
      "#edc949",
      "#af7aa1",
      "#ff9da7",
      "#9c755f",
      "#bab0ab"
    ],
    padding1: 8,
    padding2: 12,
    padding3: 20,
    alpha90: 0.9,
    alpha65: 0.65,
    alpha45: 0.45,
    alpha25: 0.25,
    alpha10: 0.1
  };
  var defaults4 = create7(tokens3);
  var Academy = (options) => {
    return deep_mix_default({}, defaults4, {
      text: { text: { fontSize: 10 } },
      axis: {
        gridLineDash: [0, 0],
        gridLineWidth: 1,
        gridStroke: "#ddd",
        gridStrokeOpacity: 1,
        labelOpacity: 1,
        labelStrokeOpacity: 1,
        labelFontSize: 10,
        line: true,
        lineLineWidth: 1,
        lineStroke: "#888",
        lineStrokeOpacity: 1,
        tickLength: 5,
        tickStrokeOpacity: 1,
        titleOpacity: 1,
        titleStrokeOpacity: 1,
        titleFillOpacity: 1,
        titleFontSize: 11,
        titleFontWeight: "bold"
      },
      axisLeft: {
        gridFilter: (_2, i) => i !== 0
      },
      axisRight: {
        gridFilter: (_2, i) => i !== 0
      },
      legendCategory: {
        itemLabelFillOpacity: 1,
        itemLabelFontSize: 10,
        itemValueFillOpacity: 1,
        itemValueFontSize: 10,
        titleFillOpacity: 1,
        titleFontSize: 11,
        titleFontWeight: "bold"
      },
      legendContinuous: {
        handleLabelFontSize: 10,
        labelFillOpacity: 0.45,
        labelFontSize: 10
      },
      label: {
        fontSize: 10
      },
      innerLabel: {
        fontSize: 10
      },
      htmlLabel: {
        fontSize: 10
      },
      slider: {
        handleLabelFontSize: 10,
        trackFillOpacity: 0.05
      }
    }, options);
  };
  Academy.props = {};

  // ../../engine/rails_design/node_modules/d3-format/src/formatDecimal.js
  function formatDecimal_default(x3) {
    return Math.abs(x3 = Math.round(x3)) >= 1e21 ? x3.toLocaleString("en").replace(/,/g, "") : x3.toString(10);
  }
  function formatDecimalParts(x3, p2) {
    if ((i = (x3 = p2 ? x3.toExponential(p2 - 1) : x3.toExponential()).indexOf("e")) < 0) return null;
    var i, coefficient = x3.slice(0, i);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x3.slice(i + 1)
    ];
  }

  // ../../engine/rails_design/node_modules/d3-format/src/exponent.js
  function exponent_default(x3) {
    return x3 = formatDecimalParts(Math.abs(x3)), x3 ? x3[1] : NaN;
  }

  // ../../engine/rails_design/node_modules/d3-format/src/formatGroup.js
  function formatGroup_default(grouping, thousands) {
    return function(value2, width) {
      var i = value2.length, t = [], j = 0, g = grouping[0], length5 = 0;
      while (i > 0 && g > 0) {
        if (length5 + g + 1 > width) g = Math.max(1, width - length5);
        t.push(value2.substring(i -= g, i + g));
        if ((length5 += g + 1) > width) break;
        g = grouping[j = (j + 1) % grouping.length];
      }
      return t.reverse().join(thousands);
    };
  }

  // ../../engine/rails_design/node_modules/d3-format/src/formatNumerals.js
  function formatNumerals_default(numerals) {
    return function(value2) {
      return value2.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // ../../engine/rails_design/node_modules/d3-format/src/formatSpecifier.js
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match2 = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match2;
    return new FormatSpecifier({
      fill: match2[1],
      align: match2[2],
      sign: match2[3],
      symbol: match2[4],
      zero: match2[5],
      width: match2[6],
      comma: match2[7],
      precision: match2[8] && match2[8].slice(1),
      trim: match2[9],
      type: match2[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };

  // ../../engine/rails_design/node_modules/d3-format/src/formatTrim.js
  function formatTrim_default(s2) {
    out: for (var n2 = s2.length, i = 1, i0 = -1, i1; i < n2; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0) i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i]) break out;
          if (i0 > 0) i0 = 0;
          break;
      }
    }
    return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
  }

  // ../../engine/rails_design/node_modules/d3-format/src/formatPrefixAuto.js
  var prefixExponent;
  function formatPrefixAuto_default(x3, p2) {
    var d2 = formatDecimalParts(x3, p2);
    if (!d2) return x3 + "";
    var coefficient = d2[0], exponent = d2[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n2 = coefficient.length;
    return i === n2 ? coefficient : i > n2 ? coefficient + new Array(i - n2 + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x3, Math.max(0, p2 + i - 1))[0];
  }

  // ../../engine/rails_design/node_modules/d3-format/src/formatRounded.js
  function formatRounded_default(x3, p2) {
    var d2 = formatDecimalParts(x3, p2);
    if (!d2) return x3 + "";
    var coefficient = d2[0], exponent = d2[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  // ../../engine/rails_design/node_modules/d3-format/src/formatTypes.js
  var formatTypes_default = {
    "%": (x3, p2) => (x3 * 100).toFixed(p2),
    "b": (x3) => Math.round(x3).toString(2),
    "c": (x3) => x3 + "",
    "d": formatDecimal_default,
    "e": (x3, p2) => x3.toExponential(p2),
    "f": (x3, p2) => x3.toFixed(p2),
    "g": (x3, p2) => x3.toPrecision(p2),
    "o": (x3) => Math.round(x3).toString(8),
    "p": (x3, p2) => formatRounded_default(x3 * 100, p2),
    "r": formatRounded_default,
    "s": formatPrefixAuto_default,
    "X": (x3) => Math.round(x3).toString(16).toUpperCase(),
    "x": (x3) => Math.round(x3).toString(16)
  };

  // ../../engine/rails_design/node_modules/d3-format/src/identity.js
  function identity_default3(x3) {
    return x3;
  }

  // ../../engine/rails_design/node_modules/d3-format/src/locale.js
  var map2 = Array.prototype.map;
  var prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function locale_default(locale2) {
    var group3 = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity_default3 : formatGroup_default(map2.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity_default3 : formatNumerals_default(map2.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill = specifier.fill, align = specifier.align, sign3 = specifier.sign, symbol = specifier.symbol, zero5 = specifier.zero, width = specifier.width, comma = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
      if (type === "n") comma = true, type = "g";
      else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim = true, type = "g";
      if (zero5 || fill === "0" && align === "=") zero5 = true, fill = "0", align = "=";
      var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
      var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
      precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format3(value2) {
        var valuePrefix = prefix, valueSuffix = suffix, i, n2, c5;
        if (type === "c") {
          valueSuffix = formatType(value2) + valueSuffix;
          value2 = "";
        } else {
          value2 = +value2;
          var valueNegative = value2 < 0 || 1 / value2 < 0;
          value2 = isNaN(value2) ? nan : formatType(Math.abs(value2), precision);
          if (trim) value2 = formatTrim_default(value2);
          if (valueNegative && +value2 === 0 && sign3 !== "+") valueNegative = false;
          valuePrefix = (valueNegative ? sign3 === "(" ? sign3 : minus : sign3 === "-" || sign3 === "(" ? "" : sign3) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign3 === "(" ? ")" : "");
          if (maybeSuffix) {
            i = -1, n2 = value2.length;
            while (++i < n2) {
              if (c5 = value2.charCodeAt(i), 48 > c5 || c5 > 57) {
                valueSuffix = (c5 === 46 ? decimal + value2.slice(i + 1) : value2.slice(i)) + valueSuffix;
                value2 = value2.slice(0, i);
                break;
              }
            }
          }
        }
        if (comma && !zero5) value2 = group3(value2, Infinity);
        var length5 = valuePrefix.length + value2.length + valueSuffix.length, padding = length5 < width ? new Array(width - length5 + 1).join(fill) : "";
        if (comma && zero5) value2 = group3(padding + value2, padding.length ? width - valueSuffix.length : Infinity), padding = "";
        switch (align) {
          case "<":
            value2 = valuePrefix + value2 + valueSuffix + padding;
            break;
          case "=":
            value2 = valuePrefix + padding + value2 + valueSuffix;
            break;
          case "^":
            value2 = padding.slice(0, length5 = padding.length >> 1) + valuePrefix + value2 + valueSuffix + padding.slice(length5);
            break;
          default:
            value2 = padding + valuePrefix + value2 + valueSuffix;
            break;
        }
        return numerals(value2);
      }
      format3.toString = function() {
        return specifier + "";
      };
      return format3;
    }
    function formatPrefix2(specifier, value2) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent_default(value2) / 3))) * 3, k = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
      return function(value3) {
        return f(k * value3) + prefix;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }

  // ../../engine/rails_design/node_modules/d3-format/src/defaultLocale.js
  var locale;
  var format2;
  var formatPrefix;
  defaultLocale2({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale2(definition) {
    locale = locale_default(definition);
    format2 = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/utils.js
  var __rest53 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function createComponent(descriptor) {
    return class extends CustomElement {
      constructor(config2) {
        super(config2);
        this.descriptor = descriptor;
      }
      connectedCallback() {
        var _a, _b;
        (_b = (_a = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a, this.attributes, this);
      }
      update(cfg = {}) {
        var _a, _b;
        this.attr(deep_mix_default({}, this.attributes, cfg));
        (_b = (_a = this.descriptor).render) === null || _b === void 0 ? void 0 : _b.call(_a, this.attributes, this);
      }
    };
  }
  function maybeAppend2(parent, selector, node) {
    if (!parent.querySelector(selector)) {
      return select(parent).append(node);
    }
    return select(parent).select(selector);
  }
  function titleContent(field3) {
    return Array.isArray(field3) ? field3.join(", ") : `${field3 || ""}`;
  }
  function inferComponentLayout(position, userDefinitions) {
    const preset = {
      display: "flex",
      flexDirection: "row",
      justifyContent: "flex-start",
      alignItems: "center"
    };
    let { flexDirection, justifyContent, alignItems } = preset;
    const layout = {
      top: ["row", "flex-start", "center"],
      bottom: ["row", "flex-start", "center"],
      left: ["column", "flex-start", "center"],
      right: ["column", "flex-start", "center"],
      center: ["column", "center", "center"]
    };
    if (position in layout) {
      [flexDirection, justifyContent, alignItems] = layout[position];
    }
    return Object.assign({
      display: "flex",
      flexDirection,
      justifyContent,
      alignItems
    }, userDefinitions);
  }
  var G2Layout = class extends Layout {
    get child() {
      var _a;
      return (_a = this.children) === null || _a === void 0 ? void 0 : _a[0];
    }
    update(options) {
      var _a;
      this.attr(options);
      const { subOptions } = options;
      (_a = this.child) === null || _a === void 0 ? void 0 : _a.update(subOptions);
    }
  };
  var LegendCategoryLayout = class extends G2Layout {
    update(options) {
      var _a;
      const { subOptions } = options;
      this.attr(options);
      (_a = this.child) === null || _a === void 0 ? void 0 : _a.update(subOptions);
    }
  };
  function scaleOf(scales, type) {
    var _a;
    return (_a = scales.filter((s2) => s2.getOptions().name === type)) === null || _a === void 0 ? void 0 : _a[0];
  }
  function isHorizontal2(orientation) {
    return orientation === "horizontal" || orientation === 0;
  }
  function isVertical(orientation) {
    return orientation === "vertical" || orientation === -Math.PI / 2;
  }
  function inferComponentShape(value2, options, component) {
    const { bbox } = value2;
    const { position = "top", size: userDefinedSize, length: userDefinedLength } = options;
    const isHorizontal3 = ["top", "bottom", "center"].includes(position);
    const [bboxSize, bboxLength] = isHorizontal3 ? [bbox.height, bbox.width] : [bbox.width, bbox.height];
    const { defaultSize, defaultLength } = component.props;
    const size2 = userDefinedSize || defaultSize || bboxSize;
    const length5 = userDefinedLength || defaultLength || bboxLength;
    const orientation = isHorizontal3 ? "horizontal" : "vertical";
    const [width, height] = isHorizontal3 ? [length5, size2] : [size2, length5];
    return {
      orientation,
      width,
      height,
      size: size2,
      length: length5
    };
  }
  function domainOf2(scales) {
    return scales.find((scale9) => scale9.getOptions().domain.length > 0).getOptions().domain;
  }
  function adaptor(style) {
    const reservedKeys = [
      "arrow",
      "crosshairs",
      "grid",
      "handle",
      "handleLabel",
      "indicator",
      "label",
      "line",
      "tick",
      "tip",
      "title",
      "trunc"
    ];
    const { style: styles } = style, rest = __rest53(style, ["style"]);
    const finalStyle = {};
    Object.entries(rest).forEach(([key, value2]) => {
      if (reservedKeys.includes(key)) {
        finalStyle[`show${upper_first_default(key)}`] = value2;
      } else
        finalStyle[key] = value2;
    });
    return Object.assign(Object.assign({}, finalStyle), styles);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/axis.js
  var __rest54 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function rotateAxis(axis, options) {
    const { eulerAngles, origin } = options;
    if (origin) {
      axis.setOrigin(origin);
    }
    if (eulerAngles) {
      axis.rotate(eulerAngles[0], eulerAngles[1], eulerAngles[2]);
    }
  }
  function sizeOf(coordinate) {
    const { innerWidth, innerHeight, depth } = coordinate.getOptions();
    return [innerWidth, innerHeight, depth];
  }
  function createFisheye(position, coordinate) {
    const { width, height } = coordinate.getOptions();
    return (tick3) => {
      if (!isFisheye(coordinate))
        return tick3;
      const tickPoint = position === "bottom" ? [tick3, 1] : [0, tick3];
      const vector = coordinate.map(tickPoint);
      if (position === "bottom") {
        const v = vector[0];
        const x3 = new Linear({
          domain: [0, width],
          range: [0, 1]
        });
        return x3.map(v);
      } else if (position === "left") {
        const v = vector[1];
        const x3 = new Linear({
          domain: [0, height],
          range: [0, 1]
        });
        return x3.map(v);
      }
      return tick3;
    };
  }
  function ticksOf(scale9, domain, tickMethod) {
    if (scale9.getTicks)
      return scale9.getTicks();
    if (!tickMethod)
      return domain;
    const [min10, max10] = extent(domain, (d2) => +d2);
    const { tickCount } = scale9.getOptions();
    return tickMethod(min10, max10, tickCount);
  }
  function createInset(position, coordinate) {
    if (isPolar(coordinate))
      return (d2) => d2;
    const options = coordinate.getOptions();
    const { innerWidth, innerHeight, insetTop, insetBottom, insetLeft, insetRight } = options;
    const [start2, end, size2] = position === "left" || position === "right" ? [insetTop, insetBottom, innerHeight] : [insetLeft, insetRight, innerWidth];
    const x3 = new Linear({
      domain: [0, 1],
      range: [start2 / size2, 1 - end / size2]
    });
    return (i) => x3.map(i);
  }
  function getData2(scale9, domain, tickCount, defaultTickFormatter, tickFilter, tickMethod, position, coordinate) {
    var _a;
    if (tickCount !== void 0 || tickMethod !== void 0) {
      scale9.update(Object.assign(Object.assign({}, tickCount && { tickCount }), tickMethod && { tickMethod }));
    }
    const ticks2 = ticksOf(scale9, domain, tickMethod);
    const filteredTicks = tickFilter ? ticks2.filter(tickFilter) : ticks2;
    const toString10 = (d2) => d2 instanceof Date ? String(d2) : typeof d2 === "object" && !!d2 ? d2 : String(d2);
    const labelFormatter = defaultTickFormatter || ((_a = scale9.getFormatter) === null || _a === void 0 ? void 0 : _a.call(scale9)) || toString10;
    const applyInset = createInset(position, coordinate);
    const applyFisheye = createFisheye(position, coordinate);
    const isHorizontal3 = (position2) => ["top", "bottom", "center", "outer"].includes(position2);
    const isVertical2 = (position2) => ["left", "right"].includes(position2);
    if (isPolar(coordinate) || isTranspose(coordinate)) {
      return filteredTicks.map((d2, i, array2) => {
        var _a2, _b;
        const offset3 = ((_a2 = scale9.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scale9, d2)) / 2 || 0;
        const tick3 = applyInset(scale9.map(d2) + offset3);
        const shouldReverse = isRadial(coordinate) && position === "center" || isTranspose(coordinate) && ((_b = scale9.getTicks) === null || _b === void 0 ? void 0 : _b.call(scale9)) && isHorizontal3(position) || isTranspose(coordinate) && isVertical2(position);
        return {
          value: shouldReverse ? 1 - tick3 : tick3,
          label: toString10(labelFormatter(prettyNumber2(d2), i, array2)),
          id: String(i)
        };
      });
    }
    return filteredTicks.map((d2, i, array2) => {
      var _a2;
      const offset3 = ((_a2 = scale9.getBandWidth) === null || _a2 === void 0 ? void 0 : _a2.call(scale9, d2)) / 2 || 0;
      const tick3 = applyFisheye(applyInset(scale9.map(d2) + offset3));
      const shouldReverse = isVertical2(position);
      return {
        value: shouldReverse ? 1 - tick3 : tick3,
        label: toString10(labelFormatter(prettyNumber2(d2), i, array2)),
        id: String(i)
      };
    });
  }
  function inferGridLength(position, coordinate, plane = "xy") {
    const [width, height, depth] = sizeOf(coordinate);
    if (plane === "xy") {
      if (position.includes("bottom") || position.includes("top"))
        return height;
      return width;
    } else if (plane === "xz") {
      if (position.includes("bottom") || position.includes("top"))
        return depth;
      return width;
    } else {
      if (position.includes("bottom") || position.includes("top"))
        return height;
      return depth;
    }
  }
  function inferLabelOverlap(transform = [], style) {
    if (transform.length > 0)
      return transform;
    const { labelAutoRotate, labelAutoHide, labelAutoEllipsis, labelAutoWrap } = style;
    const finalTransforms = [];
    const addToTransforms = (overlap, state) => {
      if (state) {
        finalTransforms.push(Object.assign(Object.assign({}, overlap), state));
      }
    };
    addToTransforms({
      type: "rotate",
      optionalAngles: [0, 15, 30, 45, 60, 90]
    }, labelAutoRotate);
    addToTransforms({ type: "ellipsis", minLength: 20 }, labelAutoEllipsis);
    addToTransforms({ type: "hide" }, labelAutoHide);
    addToTransforms({ type: "wrap", wordWrapWidth: 100, maxLines: 3, recoveryWhenFail: true }, labelAutoWrap);
    return finalTransforms;
  }
  function inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate) {
    const { x: x3, y: y3, width, height } = bbox;
    const center2 = [x3 + width / 2, y3 + height / 2];
    const radius = Math.min(width, height) / 2;
    const [startAngle, endAngle] = angleOf(coordinate);
    const [w, h] = sizeOf(coordinate);
    const r = Math.min(w, h) / 2;
    const common = {
      center: center2,
      radius,
      startAngle,
      endAngle,
      gridLength: (outerRadius - innerRadius) * r
    };
    if (position === "inner") {
      const { insetLeft, insetTop } = coordinate.getOptions();
      return Object.assign(Object.assign({}, common), { center: [center2[0] - insetLeft, center2[1] - insetTop], labelAlign: "perpendicular", labelDirection: "positive", tickDirection: "positive", gridDirection: "negative" });
    }
    return Object.assign(Object.assign({}, common), { labelAlign: "parallel", labelDirection: "negative", tickDirection: "negative", gridDirection: "positive" });
  }
  function inferGrid(value2, coordinate, scale9) {
    if (isTheta(coordinate) || isParallel(coordinate))
      return false;
    return value2 === void 0 ? !!scale9.getTicks : value2;
  }
  function infer3DAxisLinearOverrideStyle(coordinate) {
    const { depth } = coordinate.getOptions();
    return depth ? {
      tickIsBillboard: true,
      lineIsBillboard: true,
      labelIsBillboard: true,
      titleIsBillboard: true,
      gridIsBillboard: true
    } : {};
  }
  function inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale) {
    const { x: x3, y: y3, width, height } = bbox;
    if (position === "bottom") {
      return { startPos: [x3, y3], endPos: [x3 + width, y3] };
    }
    if (position === "left") {
      return { startPos: [x3 + width, y3 + height], endPos: [x3 + width, y3] };
    }
    if (position === "right") {
      return { startPos: [x3, y3 + height], endPos: [x3, y3] };
    }
    if (position === "top") {
      return { startPos: [x3, y3 + height], endPos: [x3 + width, y3 + height] };
    }
    if (position === "center") {
      if (orientation === "vertical") {
        return {
          startPos: [x3, y3],
          endPos: [x3, y3 + height]
        };
      } else if (orientation === "horizontal") {
        return {
          startPos: [x3, y3],
          endPos: [x3 + width, y3]
        };
      } else if (typeof orientation === "number") {
        const [cx, cy] = coordinate.getCenter();
        const [innerRadius, outerRadius] = radiusOf(coordinate);
        const [startAngle, endAngle] = angleOf(coordinate);
        const r = Math.min(width, height) / 2;
        const { insetLeft, insetTop } = coordinate.getOptions();
        const innerR = innerRadius * r;
        const outerR = outerRadius * r;
        const [actualCx, actualCy] = [cx + x3 - insetLeft, cy + y3 - insetTop];
        const [cos3, sin3] = [Math.cos(orientation), Math.sin(orientation)];
        const startPos = [
          actualCx + outerR * cos3,
          actualCy + outerR * sin3
        ];
        const endPos = [
          actualCx + innerR * cos3,
          actualCy + innerR * sin3
        ];
        const getAxisXDomainLength = () => {
          const { domain } = xScale.getOptions();
          return domain.length;
        };
        const controllAngleCount = isPolar(coordinate) && xScale ? getAxisXDomainLength() : 3;
        return {
          startPos,
          endPos,
          gridClosed: Math.abs(endAngle - startAngle - 360) < 1e-6,
          gridCenter: [actualCx, actualCy],
          gridControlAngles: new Array(controllAngleCount).fill(0).map((d2, i, arr) => (endAngle - startAngle) / controllAngleCount * i)
        };
      }
    }
    return {};
  }
  var ArcAxisComponent = (options) => {
    const { order, size: size2, position, orientation, labelFormatter, tickFilter, tickCount, tickMethod, important = {}, style = {}, indexBBox, title, grid: grid2 = false } = options, rest = __rest54(options, ["order", "size", "position", "orientation", "labelFormatter", "tickFilter", "tickCount", "tickMethod", "important", "style", "indexBBox", "title", "grid"]);
    return ({ scales: [scale9], value: value2, coordinate, theme }) => {
      const { bbox } = value2;
      const { domain } = scale9.getOptions();
      const data2 = getData2(scale9, domain, tickCount, labelFormatter, tickFilter, tickMethod, position, coordinate);
      const labels = indexBBox ? data2.map((d2, i) => {
        const bbox2 = indexBBox.get(i);
        if (!bbox2)
          return d2;
        if (bbox2[0] !== d2.label)
          return d2;
        return Object.assign(Object.assign({}, d2), { bbox: bbox2[1] });
      }) : data2;
      const [innerRadius, outerRadius] = radiusOf(coordinate);
      const defaultStyle2 = inferArcStyle(position, bbox, innerRadius, outerRadius, coordinate);
      const { axis: axisTheme, axisArc = {} } = theme;
      const finalStyle = adaptor(deep_mix_default({}, axisTheme, axisArc, defaultStyle2, Object.assign(Object.assign({ type: "arc", data: labels, titleText: titleContent(title), grid: grid2 }, rest), important)));
      return new Axis({
        // @fixme transform is not valid for arcAxis.
        // @ts-ignore
        style: omit_default(finalStyle, ["transform"])
      });
    };
  };
  function inferThemeStyle(scale9, coordinate, theme, direction2, position, orientation) {
    const baseStyle = theme.axis;
    const positionStyle = ["top", "right", "bottom", "left"].includes(position) ? theme[`axis${capitalizeFirst(position)}`] : theme.axisLinear;
    const channel = scale9.getOptions().name;
    const channelStyle = theme[`axis${upper_first_default(channel)}`] || {};
    return Object.assign({}, baseStyle, positionStyle, channelStyle);
  }
  function inferDefaultStyle(scale9, coordinate, theme, direction2, position, orientation) {
    const themeStyle = inferThemeStyle(scale9, coordinate, theme, direction2, position, orientation);
    if (position === "center") {
      return Object.assign(Object.assign(Object.assign(Object.assign({}, themeStyle), { labelDirection: direction2 === "right" ? "negative" : "positive" }), direction2 === "center" ? { labelTransform: "translate(50%,0)" } : null), { tickDirection: direction2 === "right" ? "negative" : "positive", labelSpacing: direction2 === "center" ? 0 : 4, titleSpacing: isVertical(orientation) ? 10 : 0, tick: direction2 === "center" ? false : void 0 });
    }
    return themeStyle;
  }
  var LinearAxisComponent = (options) => {
    const { direction: direction2 = "left", important = {}, labelFormatter, order, orientation, actualPosition, position, size: size2, style = {}, title, tickCount, tickFilter, tickMethod, transform, indexBBox } = options, userDefinitions = __rest54(options, ["direction", "important", "labelFormatter", "order", "orientation", "actualPosition", "position", "size", "style", "title", "tickCount", "tickFilter", "tickMethod", "transform", "indexBBox"]);
    return ({ scales, value: value2, coordinate, theme }) => {
      const { bbox } = value2;
      const [scale9] = scales;
      const { domain, xScale } = scale9.getOptions();
      const defaultStyle2 = inferDefaultStyle(scale9, coordinate, theme, direction2, position, orientation);
      const internalAxisStyle = Object.assign(Object.assign(Object.assign({}, defaultStyle2), style), userDefinitions);
      const gridLength = inferGridLength(actualPosition || position, coordinate, options.plane);
      const overrideStyle = inferAxisLinearOverrideStyle(position, orientation, bbox, coordinate, xScale);
      const threeDOverrideStyle = infer3DAxisLinearOverrideStyle(coordinate);
      const data2 = getData2(scale9, domain, tickCount, labelFormatter, tickFilter, tickMethod, position, coordinate);
      const labels = indexBBox ? data2.map((d2, i) => {
        const bbox2 = indexBBox.get(i);
        if (!bbox2)
          return d2;
        if (bbox2[0] !== d2.label)
          return d2;
        return Object.assign(Object.assign({}, d2), { bbox: bbox2[1] });
      }) : data2;
      const finalAxisStyle = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, internalAxisStyle), {
        type: "linear",
        data: labels,
        crossSize: size2,
        titleText: titleContent(title),
        labelOverlap: inferLabelOverlap(transform, internalAxisStyle),
        grid: inferGrid(internalAxisStyle.grid, coordinate, scale9),
        gridLength,
        // Always showLine, make title could align the end of axis.
        line: true,
        indexBBox
      }), !internalAxisStyle.line ? { lineOpacity: 0 } : null), overrideStyle), threeDOverrideStyle), important);
      const hasHide = finalAxisStyle.labelOverlap.find((d2) => d2.type === "hide");
      if (hasHide)
        finalAxisStyle.crossSize = false;
      return new Axis({
        className: "axis",
        style: adaptor(finalAxisStyle)
      });
    };
  };
  var axisFactor = (axis) => {
    return (options) => {
      const { labelFormatter: useDefinedLabelFormatter, labelFilter: userDefinedLabelFilter = () => true } = options;
      return (context) => {
        var _a;
        const { scales: [scale9] } = context;
        const ticks2 = ((_a = scale9.getTicks) === null || _a === void 0 ? void 0 : _a.call(scale9)) || scale9.getOptions().domain;
        const labelFormatter = typeof useDefinedLabelFormatter === "string" ? format2(useDefinedLabelFormatter) : useDefinedLabelFormatter;
        const labelFilter = (datum, index4, array2) => userDefinedLabelFilter(ticks2[index4], index4, ticks2);
        const normalizedOptions = Object.assign(Object.assign({}, options), {
          labelFormatter,
          labelFilter,
          scale: scale9
        });
        return axis(normalizedOptions)(context);
      };
    };
  };
  var LinearAxis = axisFactor(LinearAxisComponent);
  var ArcAxis = axisFactor(ArcAxisComponent);
  LinearAxis.props = {
    defaultPosition: "center",
    defaultSize: 45,
    defaultOrder: 0,
    defaultCrossPadding: [12, 12],
    defaultPadding: [12, 12]
  };
  ArcAxis.props = {
    defaultPosition: "outer",
    defaultOrientation: "vertical",
    defaultSize: 45,
    defaultOrder: 0,
    defaultCrossPadding: [12, 12],
    defaultPadding: [12, 12]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/axisX.js
  var AxisX = (options) => {
    return (...args) => {
      const axisX = LinearAxis(Object.assign({}, { crossPadding: 50 }, options))(...args);
      rotateAxis(axisX, options);
      return axisX;
    };
  };
  AxisX.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "bottom" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/axisY.js
  var AxisY = (options) => {
    return (...args) => {
      const axisY = LinearAxis(Object.assign({}, { crossPadding: 10 }, options))(...args);
      rotateAxis(axisY, options);
      return axisY;
    };
  };
  AxisY.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "left" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/axisRadar.js
  var __rest55 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function inferTitleTransform(orientation) {
    const internalOrientation = orientation % (Math.PI * 2);
    if (internalOrientation === Math.PI / 2) {
      return { titleTransform: "translate(0, 50%)" };
    }
    if (internalOrientation > -Math.PI / 2 && internalOrientation < Math.PI / 2) {
      return { titleTransform: "translate(50%, 0)" };
    }
    if (internalOrientation > Math.PI / 2 && internalOrientation < Math.PI * 3 / 2) {
      return { titleTransform: "translate(-50%, 0)" };
    }
    return {};
  }
  function inferAxisStyle(options, theme, coordinate, scales) {
    const { radar } = options;
    const [scale9] = scales;
    const name2 = scale9.getOptions().name;
    const [startAngle, endAngle] = angleOf(coordinate);
    const { axisRadar: radarTheme = {} } = theme;
    return Object.assign(Object.assign({}, radarTheme), { grid: name2 === "position", gridConnect: "line", gridControlAngles: new Array(radar.count).fill(0).map((_2, i) => {
      const angle4 = (endAngle - startAngle) / radar.count;
      return angle4 * i;
    }) });
  }
  var AxisRadar = (options) => {
    const { important = {} } = options, restOptions = __rest55(options, ["important"]);
    return (context) => {
      const { theme, coordinate, scales } = context;
      return LinearAxis(Object.assign(Object.assign(Object.assign({}, restOptions), inferTitleTransform(options.orientation)), { important: Object.assign(Object.assign({}, inferAxisStyle(options, theme, coordinate, scales)), important) }))(context);
    };
  };
  AxisRadar.props = Object.assign(Object.assign({}, LinearAxis.props), { defaultPosition: "center" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/legendCategory.js
  var __rest56 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function inferShape(scales, markState) {
    const shapeScale = scaleOf(scales, "shape");
    const colorScale = scaleOf(scales, "color");
    const shapeScale1 = shapeScale ? shapeScale.clone() : null;
    const shapes = [];
    for (const [mark, state] of markState) {
      const namespace = mark.type;
      const domain = (colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain.length) > 0 ? colorScale === null || colorScale === void 0 ? void 0 : colorScale.getOptions().domain : state.data;
      const shape23 = domain.map((d2, i) => {
        var _a;
        if (shapeScale1)
          return shapeScale1.map(d2 || "point");
        return ((_a = mark === null || mark === void 0 ? void 0 : mark.style) === null || _a === void 0 ? void 0 : _a.shape) || state.defaultShape || "point";
      });
      if (typeof namespace === "string")
        shapes.push([namespace, shape23]);
    }
    if (shapes.length === 0)
      return ["point", ["point"]];
    if (shapes.length === 1)
      return shapes[0];
    if (!shapeScale)
      return shapes[0];
    const { range: range3 } = shapeScale.getOptions();
    return shapes.map(([namespace, shape23]) => {
      let sum3 = 0;
      for (let i = 0; i < shapes.length; i++) {
        const targetShape = range3[i % range3.length];
        if (shape23[i] === targetShape)
          sum3++;
      }
      return [sum3 / shape23.length, [namespace, shape23]];
    }).sort((a3, b) => b[0] - a3[0])[0][1];
  }
  function inferItemMarker(options, context) {
    const { scales, library: library3, markState } = context;
    const [mark, shapes] = inferShape(scales, markState);
    const { itemMarker, itemMarkerSize: size2 } = options;
    const create8 = (name2, d2) => {
      var _a, _b, _c;
      const marker = ((_c = (_b = (_a = library3[`mark.${mark}`]) === null || _a === void 0 ? void 0 : _a.props) === null || _b === void 0 ? void 0 : _b.shape[name2]) === null || _c === void 0 ? void 0 : _c.props.defaultMarker) || last(name2.split("."));
      const radius = typeof size2 === "function" ? size2(d2) : size2;
      return () => useMarker(marker, { color: d2.color })(0, 0, radius);
    };
    const shapeOf = (i) => `${shapes[i]}`;
    const shapeScale = scaleOf(scales, "shape");
    if (shapeScale && !itemMarker)
      return (d2, i) => create8(shapeOf(i), d2);
    if (typeof itemMarker === "function") {
      return (d2, i) => {
        const node = itemMarker(d2.id, i);
        if (typeof node === "string")
          return create8(node, d2);
        return node;
      };
    }
    return (d2, i) => create8(itemMarker || shapeOf(i), d2);
  }
  function inferItemMarkerOpacity(scales) {
    const scale9 = scaleOf(scales, "opacity");
    if (scale9) {
      const { range: range3 } = scale9.getOptions();
      return (d2, i) => range3[i];
    }
    return void 0;
  }
  function inferItemMarkerSize(scales, defaults5) {
    const scale9 = scaleOf(scales, "size");
    if (scale9 instanceof Identity)
      return scale9.map(NaN) * 2;
    return defaults5;
  }
  function inferCategoryStyle(options, context) {
    const { labelFormatter = (d2) => `${d2}` } = options;
    const { scales, theme } = context;
    const defaultSize = theme.legendCategory.itemMarkerSize;
    const itemMarkerSize = inferItemMarkerSize(scales, defaultSize);
    const baseStyle = {
      itemMarker: inferItemMarker(Object.assign(Object.assign({}, options), { itemMarkerSize }), context),
      itemMarkerSize,
      itemMarkerOpacity: inferItemMarkerOpacity(scales)
    };
    const finalLabelFormatter = typeof labelFormatter === "string" ? format2(labelFormatter) : labelFormatter;
    const colorScale = scaleOf(scales, "color");
    const domain = domainOf2(scales);
    const colorOf = colorScale ? (d2) => colorScale.map(d2) : () => context.theme.color;
    return Object.assign(Object.assign({}, baseStyle), { data: domain.map((d2) => ({
      id: d2,
      label: finalLabelFormatter(d2),
      color: colorOf(d2)
    })) });
  }
  function inferLegendShape(value2, options, component) {
    const { position } = options;
    if (position === "center") {
      const { bbox } = value2;
      const { width: width2, height: height2 } = bbox;
      return { width: width2, height: height2 };
    }
    const { width, height } = inferComponentShape(value2, options, component);
    return { width, height };
  }
  var LegendCategory = (options) => {
    const { labelFormatter, layout, order, orientation, position, size: size2, title, cols, itemMarker } = options, style = __rest56(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "cols", "itemMarker"]);
    const { gridRow } = style;
    return (context) => {
      const { value: value2, theme } = context;
      const { bbox } = value2;
      const { width, height } = inferLegendShape(value2, options, LegendCategory);
      const finalLayout = inferComponentLayout(position, layout);
      const legendStyle = Object.assign(Object.assign(Object.assign(Object.assign({
        orientation: ["right", "left", "center"].includes(position) ? "vertical" : "horizontal",
        width,
        height,
        layout: cols !== void 0 ? "grid" : "flex"
      }, cols !== void 0 && { gridCol: cols }), gridRow !== void 0 && { gridRow }), { titleText: titleContent(title) }), inferCategoryStyle(options, context));
      const { legendCategory: legendTheme = {} } = theme;
      const categoryStyle = adaptor(Object.assign({}, legendTheme, legendStyle, style));
      const layoutWrapper = new LegendCategoryLayout({
        style: Object.assign(Object.assign({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, finalLayout), {
          // @ts-ignore
          subOptions: categoryStyle
        })
      });
      layoutWrapper.appendChild(new Category({
        className: "legend-category",
        style: categoryStyle
      }));
      return layoutWrapper;
    };
  };
  LegendCategory.props = {
    defaultPosition: "top",
    defaultOrder: 1,
    defaultSize: 40,
    defaultCrossPadding: [12, 12],
    defaultPadding: [12, 12]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/legendContinuous.js
  var __rest57 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function updateShapeDimensions(shape23, finalSize, orientation) {
    shape23.size = finalSize;
    if (isHorizontal2(orientation)) {
      shape23.height = finalSize;
    } else {
      shape23.width = finalSize;
    }
    return shape23;
  }
  function inferContinuousShape(value2, options, component) {
    const { size: size2 } = options;
    const shape23 = inferComponentShape(value2, options, component);
    return updateShapeDimensions(shape23, size2, shape23.orientation);
  }
  function getFormatter(max10) {
    return (value2) => ({
      value: value2 / max10,
      label: String(value2)
    });
  }
  function getQuantizeOrQuantileConfig(shape23, colorScale, min10, max10, range3) {
    const thresholds = colorScale.thresholds;
    const formatter2 = getFormatter(max10);
    return Object.assign(Object.assign({}, shape23), { color: range3, data: [min10, ...thresholds, max10].map(formatter2) });
  }
  function getThresholdConfig(shape23, colorScale, range3) {
    const thresholds = colorScale.thresholds;
    const data2 = [-Infinity, ...thresholds, Infinity].map((value2, index4) => ({
      value: index4,
      label: value2
    }));
    return Object.assign(Object.assign({}, shape23), { data: data2, color: range3, labelFilter: (datum, index4) => {
      return index4 > 0 && index4 < data2.length - 1;
    } });
  }
  function rangeOf3(scale9) {
    const { domain } = scale9.getOptions();
    const [min10, max10] = [domain[0], lastOf(domain)];
    return [min10, max10];
  }
  function createColorScale(scale9, defaultColor) {
    const options = scale9.getOptions();
    const newScale = scale9.clone();
    newScale.update(Object.assign(Object.assign({}, options), { range: [parseColor(defaultColor).toString()] }));
    return newScale;
  }
  function getLinearConfig(shape23, colorScale, sizeScale, opacityScale, scales, theme) {
    const { length: length5 } = shape23;
    const definedScale = sizeScale || opacityScale;
    const defaultColor = scales.color ? theme.legendContinuous.ribbonFill || "black" : theme.color;
    const scale9 = colorScale || createColorScale(definedScale, defaultColor);
    const [min10, max10] = rangeOf3(scale9);
    const [domainMin, domainMax] = rangeOf3([colorScale, sizeScale, opacityScale].filter((d2) => d2 !== void 0).find((d2) => !(d2 instanceof Constant2)));
    return Object.assign(Object.assign({}, shape23), { domain: [domainMin, domainMax], data: scale9.getTicks().map((value2) => ({ value: value2 })), color: new Array(Math.floor(length5)).fill(0).map((d2, i) => {
      const value2 = (max10 - min10) / (length5 - 1) * i + min10;
      const color2 = scale9.map(value2) || defaultColor;
      const opacity = opacityScale ? opacityScale.map(value2) : 1;
      return color2.replace(/rgb[a]*\(([\d]{1,3}) *, *([\d]{1,3}) *, *([\d]{1,3})[\S\s]*\)/, (match2, p1, p2, p3) => `rgba(${p1}, ${p2}, ${p3}, ${opacity})`);
    }) });
  }
  function inferContinuousConfig(scales, scale9, value2, options, component, theme) {
    const colorScale = scaleOf(scales, "color");
    const shape23 = inferContinuousShape(value2, options, component);
    if (colorScale instanceof Threshold) {
      const { range: range3 } = colorScale.getOptions();
      const [min10, max10] = rangeOf3(colorScale);
      if (colorScale instanceof Quantize || colorScale instanceof Quantile) {
        return getQuantizeOrQuantileConfig(shape23, colorScale, min10, max10, range3);
      }
      return getThresholdConfig(shape23, colorScale, range3);
    }
    const sizeScale = scaleOf(scales, "size");
    const opacityScale = scaleOf(scales, "opacity");
    return getLinearConfig(shape23, colorScale, sizeScale, opacityScale, scale9, theme);
  }
  var LegendContinuous = (options) => {
    const { labelFormatter, layout, order, orientation, position, size: size2, title, style, crossPadding, padding } = options, rest = __rest57(options, ["labelFormatter", "layout", "order", "orientation", "position", "size", "title", "style", "crossPadding", "padding"]);
    return ({ scales, value: value2, theme, scale: scale9 }) => {
      const { bbox } = value2;
      const { x: x3, y: y3, width, height } = bbox;
      const finalLayout = inferComponentLayout(position, layout);
      const { legendContinuous: legendTheme = {} } = theme;
      const finalStyle = adaptor(Object.assign({}, legendTheme, Object.assign(Object.assign({ titleText: titleContent(title), labelAlign: "value", labelFormatter: typeof labelFormatter === "string" ? (d2) => format2(labelFormatter)(d2.label) : labelFormatter }, inferContinuousConfig(scales, scale9, value2, options, LegendContinuous, theme)), style), rest));
      const layoutWrapper = new G2Layout({
        style: Object.assign(Object.assign({
          x: x3,
          y: y3,
          width,
          height
        }, finalLayout), {
          // @ts-ignore
          subOptions: finalStyle
        })
      });
      layoutWrapper.appendChild(new Continuous3({
        className: "legend-continuous",
        style: finalStyle
      }));
      return layoutWrapper;
    };
  };
  LegendContinuous.props = {
    defaultPosition: "top",
    defaultOrientation: "vertical",
    defaultOrder: 1,
    defaultSize: 60,
    defaultLength: 200,
    defaultLegendSize: 60,
    defaultPadding: [20, 10],
    defaultCrossPadding: [12, 12]
    // [horizontal, vertical]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/legendContinuousBlock.js
  var LegendContinuousBlock = (options) => {
    return (...args) => LegendContinuous(Object.assign({}, { block: true }, options))(...args);
  };
  LegendContinuousBlock.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/legendContinuousSize.js
  var LegendContinuousSize = (options) => {
    return (context) => {
      const { scales } = context;
      const sizeScale = scaleOf(scales, "size");
      return LegendContinuous(Object.assign({}, {
        type: "size",
        data: sizeScale.getTicks().map((value2, index4) => ({
          value: value2,
          label: String(value2)
        }))
      }, options))(context);
    };
  };
  LegendContinuousSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/legendContinuousBlockSize.js
  var LegendContinuousBlockSize = (options) => {
    return LegendContinuousSize(Object.assign({}, { block: true }, options));
  };
  LegendContinuousBlockSize.props = Object.assign(Object.assign({}, LegendContinuous.props), { defaultPosition: "top", defaultOrientation: "horizontal" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/title.js
  var __rest58 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function inferStyleByAlign(x3, y3, width, align) {
    switch (align) {
      case "center":
        return {
          x: x3 + width / 2,
          y: y3,
          textAlign: "middle"
        };
      case "right":
        return {
          x: x3 + width,
          y: y3,
          textAlign: "right"
        };
      default:
        return {
          x: x3,
          y: y3,
          textAlign: "left"
        };
    }
  }
  var Title2 = createComponent({
    render(attributes, container) {
      const { width, title, subtitle, spacing = 2, align = "left", x: x3, y: y3 } = attributes, style = __rest58(attributes, ["width", "title", "subtitle", "spacing", "align", "x", "y"]);
      container.style.transform = `translate(${x3}, ${y3})`;
      const titleStyle = subObject(style, "title");
      const subtitleStyle = subObject(style, "subtitle");
      const mainTitle = maybeAppend2(container, ".title", "text").attr("className", "title").call(applyStyle, Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, 0, width, align)), { fontSize: 14, textBaseline: "top", text: title }), titleStyle)).node();
      const bounds = mainTitle.getLocalBounds();
      maybeAppend2(container, ".sub-title", "text").attr("className", "sub-title").call((selection) => {
        if (!subtitle)
          return selection.node().remove();
        selection.node().attr(Object.assign(Object.assign(Object.assign({}, inferStyleByAlign(0, bounds.max[1] + spacing, width, align)), { fontSize: 12, textBaseline: "top", text: subtitle }), subtitleStyle));
      });
    }
  });
  var TitleComponent = (options) => {
    return ({ value: value2, theme }) => {
      const { x: x3, y: y3, width, height } = value2.bbox;
      return new Title2({
        style: deep_mix_default({}, theme.title, Object.assign({
          x: x3,
          y: y3,
          width,
          height
        }, options))
      });
    };
  };
  TitleComponent.props = {
    defaultPosition: "top",
    defaultOrder: 2,
    defaultSize: 36,
    defaultCrossPadding: [20, 20],
    defaultPadding: [12, 12]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/scale.js
  function constrain(x3, lo, hi) {
    return Math.min(hi, Math.max(lo, x3));
  }
  function isOrdinalScale(scale9) {
    return !!scale9.getBandWidth;
  }
  function invert4(scale9, x3, start2) {
    if (!isOrdinalScale(scale9))
      return scale9.invert(x3);
    const { adjustedRange } = scale9;
    const { domain } = scale9.getOptions();
    const offset3 = start2 ? -1 : 0;
    const step2 = scale9.getStep();
    const range3 = start2 ? adjustedRange : adjustedRange.map((d2) => d2 + step2);
    const i0 = bisectLeft(range3, x3);
    const i1 = constrain(i0 + offset3, 0, domain.length - 1);
    return domain[i1];
  }
  function domainOf3(scale9, values, ratioX) {
    if (!values)
      return scale9.getOptions().domain;
    if (!isOrdinalScale(scale9)) {
      const sortedDomain = sort2(values);
      if (!ratioX)
        return sortedDomain;
      const [d2] = sortedDomain;
      const { range: range3 } = scale9.getOptions();
      const [r0, r1] = range3;
      const v = r0 > r1 ? -1 : 1;
      const d1 = scale9.invert(scale9.map(d2) + v * ratioX);
      return [d2, d1];
    }
    const { domain } = scale9.getOptions();
    const v1 = values[0];
    const start2 = domain.indexOf(v1);
    if (ratioX) {
      const end2 = start2 + Math.round(domain.length * ratioX);
      return domain.slice(start2, end2);
    }
    const v2 = values[values.length - 1];
    const end = domain.indexOf(v2);
    return domain.slice(start2, end + 1);
  }
  function selectionOf(x3, y3, x12, y12, scale9, coordinate) {
    const { x: scaleX, y: scaleY } = scale9;
    const abstractDomain = (point6, start2) => {
      const [x4, y4] = coordinate.invert(point6);
      return [invert4(scaleX, x4, start2), invert4(scaleY, y4, start2)];
    };
    const p0 = abstractDomain([x3, y3], true);
    const p1 = abstractDomain([x12, y12], false);
    const domainX = domainOf3(scaleX, [p0[0], p1[0]]);
    const domainY = domainOf3(scaleY, [p0[1], p1[1]]);
    return [domainX, domainY];
  }
  function abstractOf(domain, scale9) {
    const [d0, d1] = domain;
    const maybeStep = (scale10) => scale10.getStep ? scale10.getStep() : 0;
    return [scale9.map(d0), scale9.map(d1) + maybeStep(scale9)];
  }
  function pixelsOf(selection, scale9, coordinate) {
    const { x: scaleX, y: scaleY } = scale9;
    const [X, Y] = selection;
    const AX = abstractOf(X, scaleX);
    const AY = abstractOf(Y, scaleY);
    const p0 = [AX[0], AY[0]];
    const p1 = [AX[1], AY[1]];
    const [x3, y3] = coordinate.map(p0);
    const [x12, y12] = coordinate.map(p1);
    return [x3, y3, x12, y12];
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/slider.js
  var __rest59 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function inferPosition2(bbox, position, trackSize) {
    const { x: x3, y: y3, width, height } = bbox;
    if (position === "left")
      return [x3 + width - trackSize, y3];
    if (position === "right")
      return [x3, y3];
    if (position === "bottom")
      return [x3, y3];
    if (position === "top")
      return [x3, y3 + height - trackSize];
  }
  var Slider2 = (options) => {
    const { orientation, labelFormatter, size: size2, style = {}, position } = options, rest = __rest59(options, ["orientation", "labelFormatter", "size", "style", "position"]);
    return (context) => {
      var _a;
      const { scales: [scale9], value: value2, theme, coordinate } = context;
      const { bbox } = value2;
      const { width, height } = bbox;
      const { slider: sliderTheme = {} } = theme;
      const defaultFormatter = ((_a = scale9.getFormatter) === null || _a === void 0 ? void 0 : _a.call(scale9)) || ((v) => v + "");
      const formatter2 = typeof labelFormatter === "string" ? format2(labelFormatter) : labelFormatter;
      const isHorizontal3 = orientation === "horizontal";
      const reverse = isTranspose(coordinate) && isHorizontal3;
      const { trackSize = sliderTheme.trackSize } = style;
      const [x05, y05] = inferPosition2(bbox, position, trackSize);
      return new Slider({
        className: "slider",
        style: Object.assign({}, sliderTheme, Object.assign(Object.assign({ x: x05, y: y05, trackLength: isHorizontal3 ? width : height, orientation, formatter: (v) => {
          const f = formatter2 || defaultFormatter;
          const v1 = reverse ? 1 - v : v;
          const tick3 = invert4(scale9, v1, true);
          return f(tick3);
        }, sparklineData: inferSparklineData(options, context) }, style), rest))
      });
    };
  };
  function markValue(markState, channels) {
    const [value2] = Array.from(markState.entries()).filter(([mark]) => mark.type === "line" || mark.type === "area").filter(([mark]) => mark.slider).map(([mark]) => {
      const { encode, slider } = mark;
      if (slider === null || slider === void 0 ? void 0 : slider.x) {
        const channel = (name2) => {
          const channel2 = encode[name2];
          return [name2, channel2 ? channel2.value : void 0];
        };
        return Object.fromEntries(channels.map(channel));
      }
    });
    if (!(value2 === null || value2 === void 0 ? void 0 : value2.series))
      return value2 === null || value2 === void 0 ? void 0 : value2.y;
    const result = value2.series.reduce((acc, curr, index4) => {
      acc[curr] = acc[curr] || [];
      acc[curr].push(value2.y[index4]);
      return acc;
    }, {});
    return Object.values(result);
  }
  function inferSparklineData(options, context) {
    const { markState } = context;
    if (is_array_default(options.sparklineData))
      return options.sparklineData;
    return markValue(markState, ["y", "series"]);
  }
  Slider2.props = {
    defaultPosition: "bottom",
    defaultSize: 24,
    defaultOrder: 1,
    defaultCrossPadding: [12, 12],
    defaultPadding: [12, 12]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/sliderX.js
  var SliderX = (options) => {
    return Slider2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
  };
  SliderX.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "bottom" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/sliderY.js
  var SliderY = (options) => {
    return Slider2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
  };
  SliderY.props = Object.assign(Object.assign({}, Slider2.props), { defaultPosition: "left" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/scrollbar.js
  var __rest60 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var Scrollbar2 = (options) => {
    const { orientation, labelFormatter, style } = options, rest = __rest60(options, ["orientation", "labelFormatter", "style"]);
    return ({ scales: [scale9], value: value2, theme }) => {
      const { bbox } = value2;
      const { x: x3, y: y3, width, height } = bbox;
      const { scrollbar: scrollbarTheme = {} } = theme;
      const { ratio, range: range3 } = scale9.getOptions();
      const mainSize = orientation === "horizontal" ? width : height;
      const actualSize = mainSize / ratio;
      const [r0, r1] = range3;
      const value1 = r1 > r0 ? 0 : 1;
      return new Scrollbar({
        className: "g2-scrollbar",
        style: Object.assign({}, scrollbarTheme, Object.assign(Object.assign(Object.assign(Object.assign({}, style), {
          x: x3,
          y: y3,
          trackLength: mainSize,
          value: value1
        }), rest), { orientation, contentLength: actualSize, viewportLength: mainSize }))
      });
    };
  };
  Scrollbar2.props = {
    defaultPosition: "bottom",
    defaultSize: 24,
    defaultOrder: 1,
    defaultCrossPadding: [12, 12],
    defaultPadding: [12, 12]
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/scrollbarX.js
  var ScrollbarX = (options) => {
    return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "horizontal" }));
  };
  ScrollbarX.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "bottom" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/scrollbarY.js
  var ScrollbarY = (options) => {
    return Scrollbar2(Object.assign(Object.assign({}, options), { orientation: "vertical" }));
  };
  ScrollbarY.props = Object.assign(Object.assign({}, Scrollbar2.props), { defaultPosition: "left" });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/legends.js
  var Legends = (options) => {
    return () => {
      return new Group2();
    };
  };
  Legends.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/scaleInX.js
  var ScaleInX = (options, context) => {
    const ZERO = 1e-4;
    const { coordinate } = context;
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const [transformOrigin, transform] = isTranspose(coordinate) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
      const keyframes = [
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          transform: `${prefix} scale(1, 1)`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      return animation;
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/scaleOutX.js
  var ScaleOutX = (options, context) => {
    const ZERO = 1e-4;
    const { coordinate } = context;
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const [transformOrigin, transform] = isTranspose(coordinate) ? [`left bottom`, `scale(1, ${ZERO})`] : [`left top`, `scale(${ZERO}, 1)`];
      const keyframes = [
        {
          transform: `${prefix} scale(1, 1)`.trimStart(),
          transformOrigin
        },
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.99
        },
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        }
      ];
      const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      return animation;
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/scaleInY.js
  var ScaleInY = (options, context) => {
    const ZERO = 1e-4;
    const { coordinate } = context;
    CSS2.registerProperty({
      name: "scaleInYRadius",
      inherits: false,
      initialValue: "",
      interpolable: true,
      syntax: PropertySyntax.NUMBER
    });
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const PolarScaleInY = (shape24) => {
        const { __data__, style } = shape24;
        const { radius = 0, inset = 0, fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
        const { points, y: y3, y1: y12 } = __data__;
        const arcObject = getArcObject(coordinate, points, [y3, y12]);
        const { innerRadius, outerRadius } = arcObject;
        const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
        const pathForConversion = new Path2({});
        const createArcPath = (arcParams) => {
          pathForConversion.attr({
            d: path2(arcParams)
          });
          const convertedPathDefinition = convertToPath(pathForConversion);
          return convertedPathDefinition;
        };
        const keyframes = [
          {
            scaleInYRadius: innerRadius + ZERO,
            fillOpacity: 0,
            strokeOpacity: 0,
            opacity: 0
          },
          {
            scaleInYRadius: innerRadius + ZERO,
            fillOpacity,
            strokeOpacity,
            opacity,
            offset: 0.01
          },
          {
            scaleInYRadius: outerRadius,
            fillOpacity,
            strokeOpacity,
            opacity
          }
        ];
        const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
        animation.onframe = function() {
          shape24.style.d = createArcPath(Object.assign(Object.assign({}, arcObject), { outerRadius: Number(shape24.style.scaleInYRadius) }));
        };
        animation.onfinish = function() {
          shape24.style.d = createArcPath(Object.assign(Object.assign({}, arcObject), { outerRadius }));
        };
        return animation;
      };
      const RectangularScaleInY = (shape24) => {
        const { style } = shape24;
        const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
        const [transformOrigin, transform] = isTranspose(coordinate) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
        const keyframes = [
          {
            transform: `${prefix} ${transform}`.trimStart(),
            transformOrigin,
            fillOpacity: 0,
            strokeOpacity: 0,
            opacity: 0
          },
          {
            transform: `${prefix} ${transform}`.trimStart(),
            transformOrigin,
            fillOpacity,
            strokeOpacity,
            opacity,
            offset: 0.01
          },
          {
            transform: `${prefix} scale(1, 1)`.trimStart(),
            transformOrigin,
            fillOpacity,
            strokeOpacity,
            opacity
          }
        ];
        const animation = shape24.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
        return animation;
      };
      if (isPolar(coordinate)) {
        return PolarScaleInY(shape23);
      } else {
        return RectangularScaleInY(shape23);
      }
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/scaleOutY.js
  var ScaleOutY = (options, context) => {
    const ZERO = 1e-4;
    const { coordinate } = context;
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const [transformOrigin, transform] = isTranspose(coordinate) ? [`left top`, `scale(${ZERO}, 1)`] : [`left bottom`, `scale(1, ${ZERO})`];
      const keyframes = [
        {
          transform: `${prefix} scale(1, 1)`.trimStart(),
          transformOrigin
        },
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.99
        },
        {
          transform: `${prefix} ${transform}`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        }
      ];
      const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      return animation;
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/fadeIn.js
  var FadeIn = (options) => {
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const keyframes = [
        { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
        {
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
    };
  };
  FadeIn.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/fadeOut.js
  var FadeOut = (options) => {
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const keyframes = [
        {
          fillOpacity,
          strokeOpacity,
          opacity
        },
        { fillOpacity: 0, strokeOpacity: 0, opacity: 0 }
      ];
      return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
    };
  };
  FadeOut.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/utils.js
  var DEFAULT_ATTRIBUTE_VALUE = {
    opacity: 1,
    strokeOpacity: 1,
    fillOpacity: 1,
    lineWidth: 0,
    x: 0,
    y: 0,
    cx: 0,
    cy: 0,
    r: 0,
    rx: 0,
    ry: 0,
    width: 0,
    height: 0
  };
  var GEOMETRY_ATTRIBUTES = {
    [Shape.CIRCLE]: ["cx", "cy", "r"],
    [Shape.ELLIPSE]: ["cx", "cy", "rx", "ry"],
    [Shape.RECT]: ["x", "y", "width", "height"],
    [Shape.IMAGE]: ["x", "y", "width", "height"],
    [Shape.LINE]: ["x1", "y1", "x2", "y2"],
    [Shape.POLYLINE]: ["points"],
    [Shape.POLYGON]: ["points"]
  };
  function attributeOf(shape23, keys2, useDefaultValue = false) {
    const attribute = {};
    for (const key of keys2) {
      const value2 = shape23.style[key];
      if (value2) {
        attribute[key] = value2;
      } else if (useDefaultValue) {
        attribute[key] = DEFAULT_ATTRIBUTE_VALUE[key];
      }
    }
    return attribute;
  }
  var attributeKeys = [
    "fill",
    "stroke",
    "fillOpacity",
    "strokeOpacity",
    "opacity",
    "lineWidth"
  ];

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/morphing.js
  function localBBoxOf(shape23) {
    const { min: min10, max: max10 } = shape23.getLocalBounds();
    const [x05, y05] = min10;
    const [x12, y12] = max10;
    const height = y12 - y05;
    const width = x12 - x05;
    return [x05, y05, width, height];
  }
  function d(bbox) {
    const [x3, y3, width, height] = bbox;
    return `
    M ${x3} ${y3}
    L ${x3 + width} ${y3}
    L ${x3 + width} ${y3 + height}
    L ${x3} ${y3 + height}
    Z
  `;
  }
  function pack2(shape23, count4) {
    const [x05, y05, width, height] = localBBoxOf(shape23);
    const aspect = height / width;
    const col = Math.ceil(Math.sqrt(count4 / aspect));
    const row2 = Math.ceil(count4 / col);
    const B3 = [];
    const h = height / row2;
    let j = 0;
    let n2 = count4;
    while (n2 > 0) {
      const c5 = Math.min(n2, col);
      const w = width / c5;
      for (let i = 0; i < c5; i++) {
        const x3 = x05 + i * w;
        const y3 = y05 + j * h;
        B3.push(d([x3, y3, w, h]));
      }
      n2 -= c5;
      j += 1;
    }
    return B3;
  }
  function normalizeSplit(split = "pack") {
    if (typeof split == "function")
      return split;
    return pack2;
  }
  function shapeToShape(from, to, timeEffect) {
    let { transform: fromTransform } = from.style;
    const { transform: toTransform } = to.style;
    replaceChild(to, from);
    let keys2 = attributeKeys;
    if (from.nodeName === Shape.GROUP) {
      const [x05, y05, w0, h0] = localBBoxOf(from);
      const [x12, y12, w1, h1] = localBBoxOf(to);
      const dx = x05 - x12;
      const dy = y05 - y12;
      const sx = w0 / w1;
      const sy = h0 / h1;
      fromTransform = `translate(${dx}, ${dy}) scale(${sx}, ${sy})`;
    } else {
      keys2 = keys2.concat(GEOMETRY_ATTRIBUTES[from.nodeName] || []);
    }
    const keyframes = [
      Object.assign({ transform: fromTransform !== null && fromTransform !== void 0 ? fromTransform : "none" }, attributeOf(from, keys2, true)),
      Object.assign({ transform: toTransform !== null && toTransform !== void 0 ? toTransform : "none" }, attributeOf(to, keys2, true))
    ];
    const animation = to.animate(keyframes, timeEffect);
    return animation;
  }
  function replaceChild(newChild, oldChild) {
    newChild["__data__"] = oldChild["__data__"];
    newChild.className = oldChild.className;
    newChild.markType = oldChild.markType;
    oldChild.parentNode.replaceChild(newChild, oldChild);
  }
  function maybePath(node, d2) {
    const { nodeName } = node;
    if (nodeName === "path")
      return node;
    const path2 = new Path2({
      style: Object.assign(Object.assign({}, attributeOf(node, attributeKeys)), { d: d2 })
    });
    replaceChild(path2, node);
    return path2;
  }
  function hasUniqueString(search2, pattern) {
    const first3 = search2.indexOf(pattern);
    const last4 = search2.lastIndexOf(pattern);
    return first3 === last4;
  }
  function hasSubPath(path2) {
    return !hasUniqueString(path2, "m") || !hasUniqueString(path2, "M");
  }
  function shape2path(shape23) {
    const path2 = convertToPath(shape23);
    if (!path2)
      return;
    if (hasSubPath(path2))
      return;
    return path2;
  }
  function oneToOne(shape23, from, to, timeEffect) {
    const { nodeName: fromName } = from;
    const { nodeName: toName } = to;
    const fromPath = shape2path(from);
    const toPath = shape2path(to);
    const isSameNodes = fromName === toName && fromName !== "path";
    const hasNonPathNode = fromPath === void 0 || toPath === void 0;
    if (isSameNodes || hasNonPathNode)
      return shapeToShape(from, to, timeEffect);
    const pathShape = maybePath(shape23, fromPath);
    const keyframes = [
      Object.assign({}, attributeOf(from, attributeKeys)),
      Object.assign({}, attributeOf(to, attributeKeys))
    ];
    if (fromPath !== toPath) {
      keyframes[0].d = fromPath;
      keyframes[1].d = toPath;
      const animation = pathShape.animate(keyframes, timeEffect);
      animation.onfinish = () => {
        const d2 = pathShape.style.d;
        copyAttributes(pathShape, to);
        pathShape.style.d = d2;
        pathShape.style.transform = "none";
      };
      pathShape.style.transform = "none";
      return animation;
    }
    return null;
  }
  function oneToMultiple(from, to, timeEffect, split) {
    from.style.visibility = "hidden";
    const D2 = split(from, to.length);
    return to.map((shape23, i) => {
      const path2 = new Path2({
        style: Object.assign({ d: D2[i] }, attributeOf(from, attributeKeys))
      });
      return oneToOne(shape23, path2, shape23, timeEffect);
    });
  }
  function multipleToOne(from, to, timeEffect, split) {
    const D2 = split(to, from.length);
    const { fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = to.style;
    const keyframes = [
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0 },
      { fillOpacity: 0, strokeOpacity: 0, opacity: 0, offset: 0.99 },
      {
        fillOpacity,
        strokeOpacity,
        opacity
      }
    ];
    const animation = to.animate(keyframes, timeEffect);
    const animations = from.map((shape23, i) => {
      const path2 = new Path2({
        style: {
          d: D2[i],
          fill: to.style.fill
        }
      });
      return oneToOne(shape23, shape23, path2, timeEffect);
    });
    return [...animations, animation];
  }
  var Morphing = (options) => {
    return (from, to, defaults5) => {
      const split = normalizeSplit(options.split);
      const timeEffect = Object.assign(Object.assign({}, defaults5), options);
      const { length: fl } = from;
      const { length: tl } = to;
      if (fl === 1 && tl === 1 || fl > 1 && tl > 1) {
        const [f] = from;
        const [t] = to;
        return oneToOne(f, f, t, timeEffect);
      }
      if (fl === 1 && tl > 1) {
        const [f] = from;
        return oneToMultiple(f, to, timeEffect, split);
      }
      if (fl > 1 && tl === 1) {
        const [t] = to;
        return multipleToOne(from, t, timeEffect, split);
      }
      return null;
    };
  };
  Morphing.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/waveIn.js
  var WaveIn = (options, context) => {
    const ZERO = 1e-4;
    CSS2.registerProperty({
      name: "waveInArcAngle",
      inherits: false,
      initialValue: "",
      interpolable: true,
      syntax: PropertySyntax.NUMBER
    });
    const { coordinate } = context;
    return (from, to, defaults5) => {
      const [shape23] = from;
      if (!isPolar(coordinate)) {
        return ScaleInX(options, context)(from, to, defaults5);
      }
      const { __data__, style } = shape23;
      const { radius = 0, inset = 0, fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = style;
      const { points, y: y3, y1: y12 } = __data__;
      const path2 = arc_default().cornerRadius(radius).padAngle(inset * Math.PI / 180);
      const arcObject = getArcObject(coordinate, points, [y3, y12]);
      const { startAngle, endAngle } = arcObject;
      const keyframes = [
        // Use custom interpolable CSS property.
        {
          waveInArcAngle: startAngle + ZERO,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          waveInArcAngle: startAngle + ZERO,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          waveInArcAngle: endAngle,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      animation.onframe = function() {
        shape23.style.d = path2(Object.assign(Object.assign({}, arcObject), { endAngle: Number(shape23.style.waveInArcAngle) }));
      };
      animation.onfinish = function() {
        shape23.style.d = path2(Object.assign(Object.assign({}, arcObject), { endAngle }));
      };
      return animation;
    };
  };
  WaveIn.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/zoomIn.js
  var ZoomIn = (options) => {
    const ZERO = 1e-4;
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const transformOrigin = "center center";
      const keyframes = [
        {
          transform: `${prefix} scale(${ZERO})`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        },
        {
          transform: `${prefix} scale(${ZERO})`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.01
        },
        {
          transform: `${prefix} scale(1)`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity
        }
      ];
      const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      return animation;
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/zoomOut.js
  var ZoomOut = (options) => {
    const ZERO = 1e-4;
    return (from, _2, defaults5) => {
      const [shape23] = from;
      const { transform: prefix = "", fillOpacity = 1, strokeOpacity = 1, opacity = 1 } = shape23.style;
      const transformOrigin = "center center";
      const keyframes = [
        { transform: `${prefix} scale(1)`.trimStart(), transformOrigin },
        {
          transform: `${prefix} scale(${ZERO})`.trimStart(),
          transformOrigin,
          fillOpacity,
          strokeOpacity,
          opacity,
          offset: 0.99
        },
        {
          transform: `${prefix} scale(${ZERO})`.trimStart(),
          transformOrigin,
          fillOpacity: 0,
          strokeOpacity: 0,
          opacity: 0
        }
      ];
      const animation = shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
      return animation;
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/pathIn.js
  var PathIn = (options) => {
    return (from, _2, defaults5) => {
      var _a, _b;
      const [shape23] = from;
      const length5 = ((_b = (_a = shape23).getTotalLength) === null || _b === void 0 ? void 0 : _b.call(_a)) || 0;
      const keyframes = [
        { lineDash: [0, length5] },
        { lineDash: [length5, 0] }
      ];
      return shape23.animate(keyframes, Object.assign(Object.assign({}, defaults5), options));
    };
  };
  PathIn.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/growInX.js
  var GrowInX = (options, context) => {
    return (from, to, defaults5) => {
      const [shape23] = from;
      const { min: [x3, y3], halfExtents } = shape23.getLocalBounds();
      const width = halfExtents[0] * 2;
      const height = halfExtents[1] * 2;
      const clipPath = new Path2({
        style: {
          d: `M${x3},${y3}L${x3 + width},${y3}L${x3 + width},${y3 + height}L${x3},${y3 + height}Z`
        }
      });
      shape23.appendChild(clipPath);
      shape23.style.clipPath = clipPath;
      const animation = ScaleInX(options, context)([clipPath], to, defaults5);
      return animation;
    };
  };
  GrowInX.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/animation/growInY.js
  var GrowInY = (options, context) => {
    return (from, to, defaults5) => {
      const [shape23] = from;
      const { min: [x3, y3], halfExtents } = shape23.getLocalBounds();
      const width = halfExtents[0] * 2;
      const height = halfExtents[1] * 2;
      const clipPath = new Path2({
        style: {
          d: `M${x3},${y3}L${x3 + width},${y3}L${x3 + width},${y3 + height}L${x3},${y3 + height}Z`
        }
      });
      shape23.appendChild(clipPath);
      shape23.style.clipPath = clipPath;
      const animation = ScaleInY(options, context)([clipPath], to, defaults5);
      return animation;
    };
  };
  GrowInY.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/runtime/constant.js
  var MAIN_LAYER_CLASS_NAME = "main-layer";
  var LABEL_LAYER_CLASS_NAME = "label-layer";
  var ELEMENT_CLASS_NAME = "element";
  var VIEW_CLASS_NAME = "view";
  var PLOT_CLASS_NAME = "plot";
  var COMPONENT_CLASS_NAME = "component";
  var LABEL_CLASS_NAME = "label";
  var AREA_CLASS_NAME = "area";

  // ../../engine/rails_design/node_modules/@antv/g-plugin-canvas-path-generator/node_modules/@antv/util/esm/lodash/clamp.js
  var clamp5 = function(a3, min10, max10) {
    if (a3 < min10) {
      return min10;
    } else if (a3 > max10) {
      return max10;
    }
    return a3;
  };
  var clamp_default4 = clamp5;

  // ../../engine/rails_design/node_modules/@antv/g-plugin-canvas-path-generator/dist/index.esm.js
  function generatePath$6(context, parsedStyle) {
    var _a = parsedStyle.cx, cx = _a === void 0 ? 0 : _a, _b = parsedStyle.cy, cy = _b === void 0 ? 0 : _b, r = parsedStyle.r;
    context.arc(cx, cy, r, 0, Math.PI * 2, false);
  }
  function generatePath$5(context, parsedStyle) {
    var _a = parsedStyle.cx, cx = _a === void 0 ? 0 : _a, _b = parsedStyle.cy, cy = _b === void 0 ? 0 : _b, rx = parsedStyle.rx, ry = parsedStyle.ry;
    if (context.ellipse) {
      context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
    } else {
      var r = rx > ry ? rx : ry;
      var scaleX = rx > ry ? 1 : rx / ry;
      var scaleY = rx > ry ? ry / rx : 1;
      context.save();
      context.scale(scaleX, scaleY);
      context.arc(cx, cy, r, 0, Math.PI * 2);
    }
  }
  function generatePath$4(context, parsedStyle) {
    var x12 = parsedStyle.x1, y12 = parsedStyle.y1, x22 = parsedStyle.x2, y22 = parsedStyle.y2, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad = 0;
    var x3;
    var y3;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      x3 = x22 - x12;
      y3 = y22 - y12;
      rad = Math.atan2(y3, x3);
      startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      x3 = x12 - x22;
      y3 = y12 - y22;
      rad = Math.atan2(y3, x3);
      endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
    }
    context.moveTo(x12 + startOffsetX, y12 + startOffsetY);
    context.lineTo(x22 + endOffsetX, y22 + endOffsetY);
  }
  function generatePath$3(context, parsedStyle) {
    var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var _a = parsedStyle.d, absolutePath = _a.absolutePath, segments = _a.segments;
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad = 0;
    var x3;
    var y3;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      var _b = __read(markerStart.parentNode.getStartTangent(), 2), p1 = _b[0], p2 = _b[1];
      x3 = p1[0] - p2[0];
      y3 = p1[1] - p2[1];
      rad = Math.atan2(y3, x3);
      startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      var _c = __read(markerEnd.parentNode.getEndTangent(), 2), p1 = _c[0], p2 = _c[1];
      x3 = p1[0] - p2[0];
      y3 = p1[1] - p2[1];
      rad = Math.atan2(y3, x3);
      endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
    }
    for (var i = 0; i < absolutePath.length; i++) {
      var params = absolutePath[i];
      var command = params[0];
      var nextSegment = absolutePath[i + 1];
      var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
      var useEndOffset = (i === absolutePath.length - 1 || nextSegment && (nextSegment[0] === "M" || nextSegment[0] === "Z")) && endOffsetX !== 0 && endOffsetY !== 0;
      switch (command) {
        case "M":
          if (useStartOffset) {
            context.moveTo(params[1] + startOffsetX, params[2] + startOffsetY);
            context.lineTo(params[1], params[2]);
          } else {
            context.moveTo(params[1], params[2]);
          }
          break;
        case "L":
          if (useEndOffset) {
            context.lineTo(params[1] + endOffsetX, params[2] + endOffsetY);
          } else {
            context.lineTo(params[1], params[2]);
          }
          break;
        case "Q":
          context.quadraticCurveTo(params[1], params[2], params[3], params[4]);
          if (useEndOffset) {
            context.lineTo(params[3] + endOffsetX, params[4] + endOffsetY);
          }
          break;
        case "C":
          context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5], params[6]);
          if (useEndOffset) {
            context.lineTo(params[5] + endOffsetX, params[6] + endOffsetY);
          }
          break;
        case "A": {
          var arcParams = segments[i].arcParams;
          var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
          if (context.ellipse) {
            context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));
          } else {
            var r = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;
            context.translate(cx, cy);
            context.rotate(xRotation);
            context.scale(scaleX, scaleY);
            context.arc(0, 0, r, startAngle, endAngle, !!(1 - sweepFlag));
            context.scale(1 / scaleX, 1 / scaleY);
            context.rotate(-xRotation);
            context.translate(-cx, -cy);
          }
          if (useEndOffset) {
            context.lineTo(params[6] + endOffsetX, params[7] + endOffsetY);
          }
          break;
        }
        case "Z":
          context.closePath();
          break;
      }
    }
  }
  function generatePath$2(context, parsedStyle) {
    var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var points = parsedStyle.points.points;
    var length5 = points.length;
    var x12 = points[0][0];
    var y12 = points[0][1];
    var x22 = points[length5 - 1][0];
    var y22 = points[length5 - 1][1];
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad = 0;
    var x3;
    var y3;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      x3 = points[1][0] - points[0][0];
      y3 = points[1][1] - points[0][1];
      rad = Math.atan2(y3, x3);
      startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      x3 = points[length5 - 1][0] - points[0][0];
      y3 = points[length5 - 1][1] - points[0][1];
      rad = Math.atan2(y3, x3);
      endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
    }
    context.moveTo(x12 + (startOffsetX || endOffsetX), y12 + (startOffsetY || endOffsetY));
    for (var i = 1; i < length5 - 1; i++) {
      var point6 = points[i];
      context.lineTo(point6[0], point6[1]);
    }
    context.lineTo(x22, y22);
  }
  function generatePath$1(context, parsedStyle) {
    var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var points = parsedStyle.points.points;
    var length5 = points.length;
    var x12 = points[0][0];
    var y12 = points[0][1];
    var x22 = points[length5 - 1][0];
    var y22 = points[length5 - 1][1];
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad = 0;
    var x3;
    var y3;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
      x3 = points[1][0] - points[0][0];
      y3 = points[1][1] - points[0][1];
      rad = Math.atan2(y3, x3);
      startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
      startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
      x3 = points[length5 - 2][0] - points[length5 - 1][0];
      y3 = points[length5 - 2][1] - points[length5 - 1][1];
      rad = Math.atan2(y3, x3);
      endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
      endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
    }
    context.moveTo(x12 + startOffsetX, y12 + startOffsetY);
    for (var i = 1; i < length5 - 1; i++) {
      var point6 = points[i];
      context.lineTo(point6[0], point6[1]);
    }
    context.lineTo(x22 + endOffsetX, y22 + endOffsetY);
  }
  function generatePath(context, parsedStyle) {
    var _a = parsedStyle.x, x3 = _a === void 0 ? 0 : _a, _b = parsedStyle.y, y3 = _b === void 0 ? 0 : _b, radius = parsedStyle.radius, width = parsedStyle.width, height = parsedStyle.height;
    var w = width;
    var h = height;
    var hasRadius = radius && radius.some(function(r) {
      return r !== 0;
    });
    if (!hasRadius) {
      context.rect(x3, y3, w, h);
    } else {
      var signX = width > 0 ? 1 : -1;
      var signY = height > 0 ? 1 : -1;
      var sweepFlag = signX + signY === 0;
      var _c = __read(radius.map(function(r) {
        return clamp_default4(r, 0, Math.min(Math.abs(w) / 2, Math.abs(h) / 2));
      }), 4), tlr = _c[0], trr = _c[1], brr = _c[2], blr = _c[3];
      context.moveTo(signX * tlr + x3, y3);
      context.lineTo(w - signX * trr + x3, y3);
      if (trr !== 0) {
        context.arc(w - signX * trr + x3, signY * trr + y3, trr, -signY * Math.PI / 2, signX > 0 ? 0 : Math.PI, sweepFlag);
      }
      context.lineTo(w + x3, h - signY * brr + y3);
      if (brr !== 0) {
        context.arc(w - signX * brr + x3, h - signY * brr + y3, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);
      }
      context.lineTo(signX * blr + x3, h + y3);
      if (blr !== 0) {
        context.arc(signX * blr + x3, h - signY * blr + y3, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);
      }
      context.lineTo(x3, signY * tlr + y3);
      if (tlr !== 0) {
        context.arc(signX * tlr + x3, signY * tlr + y3, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);
      }
    }
  }
  var Plugin = (
    /** @class */
    function(_super) {
      __extends(Plugin8, _super);
      function Plugin8() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this.name = "canvas-path-generator";
        return _this;
      }
      Plugin8.prototype.init = function() {
        var _a;
        var pathGeneratorFactory = (_a = {}, _a[Shape.CIRCLE] = generatePath$6, _a[Shape.ELLIPSE] = generatePath$5, _a[Shape.RECT] = generatePath, _a[Shape.LINE] = generatePath$4, _a[Shape.POLYLINE] = generatePath$1, _a[Shape.POLYGON] = generatePath$2, _a[Shape.PATH] = generatePath$3, _a[Shape.TEXT] = void 0, _a[Shape.GROUP] = void 0, _a[Shape.IMAGE] = void 0, _a[Shape.HTML] = void 0, _a[Shape.MESH] = void 0, _a);
        this.context.pathGeneratorFactory = pathGeneratorFactory;
      };
      Plugin8.prototype.destroy = function() {
        delete this.context.pathGeneratorFactory;
      };
      return Plugin8;
    }(AbstractRendererPlugin)
  );

  // ../../engine/rails_design/node_modules/@antv/g-plugin-canvas-picker/node_modules/@antv/util/esm/lodash/clamp.js
  var clamp6 = function(a3, min10, max10) {
    if (a3 < min10) {
      return min10;
    } else if (a3 > max10) {
      return max10;
    }
    return a3;
  };
  var clamp_default5 = clamp6;

  // ../../engine/rails_design/node_modules/@antv/g-plugin-canvas-picker/node_modules/@antv/util/esm/path/util/rotate-vector.js
  function rotateVector2(x3, y3, rad) {
    var X = x3 * Math.cos(rad) - y3 * Math.sin(rad);
    var Y = x3 * Math.sin(rad) + y3 * Math.cos(rad);
    return { x: X, y: Y };
  }

  // ../../engine/rails_design/node_modules/@antv/g-plugin-canvas-picker/node_modules/@antv/util/esm/path/process/arc-2-cubic.js
  function arcToCubic2(X12, Y12, RX, RY, angle4, LAF, SF, X22, Y22, recursive) {
    var x12 = X12;
    var y12 = Y12;
    var rx = RX;
    var ry = RY;
    var x22 = X22;
    var y22 = Y22;
    var d120 = Math.PI * 120 / 180;
    var rad = Math.PI / 180 * (+angle4 || 0);
    var res = [];
    var xy;
    var f1;
    var f2;
    var cx;
    var cy;
    if (!recursive) {
      xy = rotateVector2(x12, y12, -rad);
      x12 = xy.x;
      y12 = xy.y;
      xy = rotateVector2(x22, y22, -rad);
      x22 = xy.x;
      y22 = xy.y;
      var x3 = (x12 - x22) / 2;
      var y3 = (y12 - y22) / 2;
      var h = x3 * x3 / (rx * rx) + y3 * y3 / (ry * ry);
      if (h > 1) {
        h = Math.sqrt(h);
        rx *= h;
        ry *= h;
      }
      var rx2 = rx * rx;
      var ry2 = ry * ry;
      var k = (LAF === SF ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y3 * y3 - ry2 * x3 * x3) / (rx2 * y3 * y3 + ry2 * x3 * x3)));
      cx = k * rx * y3 / ry + (x12 + x22) / 2;
      cy = k * -ry * x3 / rx + (y12 + y22) / 2;
      f1 = Math.asin(((y12 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
      f2 = Math.asin(((y22 - cy) / ry * Math.pow(10, 9) >> 0) / Math.pow(10, 9));
      f1 = x12 < cx ? Math.PI - f1 : f1;
      f2 = x22 < cx ? Math.PI - f2 : f2;
      if (f1 < 0)
        f1 = Math.PI * 2 + f1;
      if (f2 < 0)
        f2 = Math.PI * 2 + f2;
      if (SF && f1 > f2) {
        f1 -= Math.PI * 2;
      }
      if (!SF && f2 > f1) {
        f2 -= Math.PI * 2;
      }
    } else {
      f1 = recursive[0], f2 = recursive[1], cx = recursive[2], cy = recursive[3];
    }
    var df = f2 - f1;
    if (Math.abs(df) > d120) {
      var f2old = f2;
      var x2old = x22;
      var y2old = y22;
      f2 = f1 + d120 * (SF && f2 > f1 ? 1 : -1);
      x22 = cx + rx * Math.cos(f2);
      y22 = cy + ry * Math.sin(f2);
      res = arcToCubic2(x22, y22, rx, ry, angle4, 0, SF, x2old, y2old, [f2, f2old, cx, cy]);
    }
    df = f2 - f1;
    var c1 = Math.cos(f1);
    var s1 = Math.sin(f1);
    var c22 = Math.cos(f2);
    var s2 = Math.sin(f2);
    var t = Math.tan(df / 4);
    var hx = 4 / 3 * rx * t;
    var hy = 4 / 3 * ry * t;
    var m1 = [x12, y12];
    var m22 = [x12 + hx * s1, y12 - hy * c1];
    var m3 = [x22 + hx * s2, y22 - hy * c22];
    var m4 = [x22, y22];
    m22[0] = 2 * m1[0] - m22[0];
    m22[1] = 2 * m1[1] - m22[1];
    if (recursive) {
      return m22.concat(m3, m4, res);
    }
    res = m22.concat(m3, m4, res);
    var newres = [];
    for (var i = 0, ii = res.length; i < ii; i += 1) {
      newres[i] = i % 2 ? rotateVector2(res[i - 1], res[i], rad).y : rotateVector2(res[i], res[i + 1], rad).x;
    }
    return newres;
  }

  // ../../engine/rails_design/node_modules/@antv/g-plugin-canvas-picker/node_modules/@antv/g-math/dist/index.esm.js
  function distance6(x12, y12, x22, y22) {
    var dx = x12 - x22;
    var dy = y12 - y22;
    return Math.sqrt(dx * dx + dy * dy);
  }
  var EPSILON2 = 1e-4;
  function nearestPoint$2(xArr, yArr, x3, y3, tCallback, length5) {
    var t = -1;
    var d2 = Infinity;
    var v0 = [x3, y3];
    var segNum = 20;
    if (length5 && length5 > 200) {
      segNum = length5 / 10;
    }
    var increaseRate = 1 / segNum;
    var interval2 = increaseRate / 10;
    for (var i = 0; i <= segNum; i++) {
      var _t = i * increaseRate;
      var v1 = [
        tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([_t])), false)),
        tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([_t])), false))
      ];
      var d1 = distance6(v0[0], v0[1], v1[0], v1[1]);
      if (d1 < d2) {
        t = _t;
        d2 = d1;
      }
    }
    if (t === 0) {
      return {
        x: xArr[0],
        y: yArr[0]
      };
    }
    if (t === 1) {
      var count4 = xArr.length;
      return {
        x: xArr[count4 - 1],
        y: yArr[count4 - 1]
      };
    }
    d2 = Infinity;
    for (var i = 0; i < 32; i++) {
      if (interval2 < EPSILON2) {
        break;
      }
      var prev = t - interval2;
      var next = t + interval2;
      var v1 = [
        tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([prev])), false)),
        tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([prev])), false))
      ];
      var d1 = distance6(v0[0], v0[1], v1[0], v1[1]);
      if (prev >= 0 && d1 < d2) {
        t = prev;
        d2 = d1;
      } else {
        var v2 = [
          tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([next])), false)),
          tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([next])), false))
        ];
        var d22 = distance6(v0[0], v0[1], v2[0], v2[1]);
        if (next <= 1 && d22 < d2) {
          t = next;
          d2 = d22;
        } else {
          interval2 *= 0.5;
        }
      }
    }
    return {
      x: tCallback.apply(void 0, __spreadArray([], __read(xArr.concat([t])), false)),
      y: tCallback.apply(void 0, __spreadArray([], __read(yArr.concat([t])), false))
    };
  }
  function pointToLine(x12, y12, x22, y22, x3, y3) {
    var d2 = [x22 - x12, y22 - y12];
    if (vec2_exports.exactEquals(d2, [0, 0])) {
      return Math.sqrt((x3 - x12) * (x3 - x12) + (y3 - y12) * (y3 - y12));
    }
    var u = [-d2[1], d2[0]];
    vec2_exports.normalize(u, u);
    var a3 = [x3 - x12, y3 - y12];
    return Math.abs(vec2_exports.dot(a3, u));
  }
  function cubicAt2(p0, p1, p2, p3, t) {
    var onet = 1 - t;
    return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
  }
  function nearestPoint$1(x12, y12, x22, y22, x3, y3, x4, y4, x05, y05, length5) {
    return nearestPoint$2([x12, x22, x3, x4], [y12, y22, y3, y4], x05, y05, cubicAt2, length5);
  }
  function pointDistance$3(x12, y12, x22, y22, x3, y3, x4, y4, x05, y05, length5) {
    var point6 = nearestPoint$1(x12, y12, x22, y22, x3, y3, x4, y4, x05, y05, length5);
    return distance6(point6.x, point6.y, x05, y05);
  }
  function quadraticAt2(p0, p1, p2, t) {
    var onet = 1 - t;
    return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
  }
  function nearestPoint(x12, y12, x22, y22, x3, y3, x05, y05) {
    return nearestPoint$2([x12, x22, x3], [y12, y22, y3], x05, y05, quadraticAt2);
  }
  function pointDistance(x12, y12, x22, y22, x3, y3, x05, y05) {
    var point6 = nearestPoint(x12, y12, x22, y22, x3, y3, x05, y05);
    return distance6(point6.x, point6.y, x05, y05);
  }

  // ../../engine/rails_design/node_modules/@antv/g-plugin-canvas-picker/dist/index.esm.js
  var tmpVec3a = vec3_exports.create();
  var tmpVec3b = vec3_exports.create();
  var tmpVec3c = vec3_exports.create();
  var tmpMat4 = mat4_exports.create();
  var CanvasPickerPlugin = (
    /** @class */
    function() {
      function CanvasPickerPlugin2() {
        var _this = this;
        this.isHit = function(displayObject, position, worldTransform, isClipPath) {
          var pick3 = _this.context.pointInPathPickerFactory[displayObject.nodeName];
          if (pick3) {
            var invertWorldMat = mat4_exports.invert(tmpMat4, worldTransform);
            var localPosition = vec3_exports.transformMat4(tmpVec3b, vec3_exports.set(tmpVec3c, position[0], position[1], 0), invertWorldMat);
            if (pick3(displayObject, new Point2(localPosition[0], localPosition[1]), isClipPath, _this.isPointInPath, _this.context, _this.runtime)) {
              return true;
            }
          }
          return false;
        };
        this.isPointInPath = function(displayObject, position) {
          var context = _this.runtime.offscreenCanvasCreator.getOrCreateContext(_this.context.config.offscreenCanvas);
          var generatePath2 = _this.context.pathGeneratorFactory[displayObject.nodeName];
          if (generatePath2) {
            context.beginPath();
            generatePath2(context, displayObject.parsedStyle);
            context.closePath();
          }
          return context.isPointInPath(position.x, position.y);
        };
      }
      CanvasPickerPlugin2.prototype.apply = function(context, runtime2) {
        var _this = this;
        var _a;
        var renderingService = context.renderingService, renderingContext = context.renderingContext;
        this.context = context;
        this.runtime = runtime2;
        var document2 = (_a = renderingContext.root) === null || _a === void 0 ? void 0 : _a.ownerDocument;
        renderingService.hooks.pick.tapPromise(CanvasPickerPlugin2.tag, function(result) {
          return __awaiter(_this, void 0, void 0, function() {
            return __generator(this, function(_a2) {
              return [2, this.pick(document2, result)];
            });
          });
        });
        renderingService.hooks.pickSync.tap(CanvasPickerPlugin2.tag, function(result) {
          return _this.pick(document2, result);
        });
      };
      CanvasPickerPlugin2.prototype.pick = function(document2, result) {
        var e_1, _a;
        var topmost = result.topmost, _b = result.position, x3 = _b.x, y3 = _b.y;
        var position = vec3_exports.set(tmpVec3a, x3, y3, 0);
        var hitTestList = document2.elementsFromBBox(position[0], position[1], position[0], position[1]);
        var pickedDisplayObjects = [];
        try {
          for (var hitTestList_1 = __values(hitTestList), hitTestList_1_1 = hitTestList_1.next(); !hitTestList_1_1.done; hitTestList_1_1 = hitTestList_1.next()) {
            var displayObject = hitTestList_1_1.value;
            var worldTransform = displayObject.getWorldTransform();
            var isHitOriginShape = this.isHit(displayObject, position, worldTransform, false);
            if (isHitOriginShape) {
              var clipped = findClosestClipPathTarget(displayObject);
              if (clipped) {
                var clipPath = clipped.parsedStyle.clipPath;
                var isHitClipPath = this.isHit(clipPath, position, clipPath.getWorldTransform(), true);
                if (isHitClipPath) {
                  if (topmost) {
                    result.picked = [displayObject];
                    return result;
                  } else {
                    pickedDisplayObjects.push(displayObject);
                  }
                }
              } else {
                if (topmost) {
                  result.picked = [displayObject];
                  return result;
                } else {
                  pickedDisplayObjects.push(displayObject);
                }
              }
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (hitTestList_1_1 && !hitTestList_1_1.done && (_a = hitTestList_1.return)) _a.call(hitTestList_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        result.picked = pickedDisplayObjects;
        return result;
      };
      CanvasPickerPlugin2.tag = "CanvasPicker";
      return CanvasPickerPlugin2;
    }()
  );
  function isPointInPath$7(displayObject, position, isClipPath) {
    var _a = displayObject.parsedStyle, _b = _a.cx, cx = _b === void 0 ? 0 : _b, _c = _a.cy, cy = _c === void 0 ? 0 : _c, r = _a.r, fill = _a.fill, stroke2 = _a.stroke, _d = _a.lineWidth, lineWidth = _d === void 0 ? 1 : _d, _e = _a.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _e === void 0 ? 0 : _e, _f = _a.pointerEvents, pointerEvents = _f === void 0 ? "auto" : _f;
    var halfLineWidth = (lineWidth + increasedLineWidthForHitTesting) / 2;
    var absDistance = distance6(cx, cy, position.x, position.y);
    var _g = __read(isFillOrStrokeAffected(pointerEvents, fill, stroke2), 2), hasFill = _g[0], hasStroke = _g[1];
    if (hasFill && hasStroke || isClipPath) {
      return absDistance <= r + halfLineWidth;
    }
    if (hasFill) {
      return absDistance <= r;
    }
    if (hasStroke) {
      return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
    }
    return false;
  }
  function ellipseDistance(squareX, squareY, rx, ry) {
    return squareX / (rx * rx) + squareY / (ry * ry);
  }
  function isPointInPath$6(displayObject, position, isClipPath) {
    var _a = displayObject.parsedStyle, _b = _a.cx, cx = _b === void 0 ? 0 : _b, _c = _a.cy, cy = _c === void 0 ? 0 : _c, rx = _a.rx, ry = _a.ry, fill = _a.fill, stroke2 = _a.stroke, _d = _a.lineWidth, lineWidth = _d === void 0 ? 1 : _d, _e = _a.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _e === void 0 ? 0 : _e, _f = _a.pointerEvents, pointerEvents = _f === void 0 ? "auto" : _f;
    var x3 = position.x, y3 = position.y;
    var _g = __read(isFillOrStrokeAffected(pointerEvents, fill, stroke2), 2), hasFill = _g[0], hasStroke = _g[1];
    var halfLineWith = (lineWidth + increasedLineWidthForHitTesting) / 2;
    var squareX = (x3 - cx) * (x3 - cx);
    var squareY = (y3 - cy) * (y3 - cy);
    if (hasFill && hasStroke || isClipPath) {
      return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    if (hasFill) {
      return ellipseDistance(squareX, squareY, rx, ry) <= 1;
    }
    if (hasStroke) {
      return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
    }
    return false;
  }
  function inBox(minX, minY, width, height, x3, y3) {
    return x3 >= minX && x3 <= minX + width && y3 >= minY && y3 <= minY + height;
  }
  function inRect(minX, minY, width, height, lineWidth, x3, y3) {
    var halfWidth = lineWidth / 2;
    return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x3, y3) || // 上边
    inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x3, y3) || // 右边
    inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x3, y3) || // 下边
    inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x3, y3);
  }
  function inArc(cx, cy, r, startAngle, endAngle, lineWidth, x3, y3) {
    var angle4 = (Math.atan2(y3 - cy, x3 - cx) + Math.PI * 2) % (Math.PI * 2);
    var point6 = {
      x: cx + r * Math.cos(angle4),
      y: cy + r * Math.sin(angle4)
    };
    return distance6(point6.x, point6.y, x3, y3) <= lineWidth / 2;
  }
  function inLine(x12, y12, x22, y22, lineWidth, x3, y3) {
    var minX = Math.min(x12, x22);
    var maxX = Math.max(x12, x22);
    var minY = Math.min(y12, y22);
    var maxY2 = Math.max(y12, y22);
    var halfWidth = lineWidth / 2;
    if (!(x3 >= minX - halfWidth && x3 <= maxX + halfWidth && y3 >= minY - halfWidth && y3 <= maxY2 + halfWidth)) {
      return false;
    }
    return pointToLine(x12, y12, x22, y22, x3, y3) <= lineWidth / 2;
  }
  function inPolyline(points, lineWidth, x3, y3, isClose) {
    var count4 = points.length;
    if (count4 < 2) {
      return false;
    }
    for (var i = 0; i < count4 - 1; i++) {
      var x12 = points[i][0];
      var y12 = points[i][1];
      var x22 = points[i + 1][0];
      var y22 = points[i + 1][1];
      if (inLine(x12, y12, x22, y22, lineWidth, x3, y3)) {
        return true;
      }
    }
    if (isClose) {
      var first3 = points[0];
      var last4 = points[count4 - 1];
      if (inLine(first3[0], first3[1], last4[0], last4[1], lineWidth, x3, y3)) {
        return true;
      }
    }
    return false;
  }
  var tolerance = 1e-6;
  function dcmp(x3) {
    if (Math.abs(x3) < tolerance) {
      return 0;
    }
    return x3 < 0 ? -1 : 1;
  }
  function onSegment(p1, p2, q) {
    if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
      return true;
    }
    return false;
  }
  function inPolygon(points, x3, y3) {
    var isHit = false;
    var n2 = points.length;
    if (n2 <= 2) {
      return false;
    }
    for (var i = 0; i < n2; i++) {
      var p1 = points[i];
      var p2 = points[(i + 1) % n2];
      if (onSegment(p1, p2, [x3, y3])) {
        return true;
      }
      if (dcmp(p1[1] - y3) > 0 !== dcmp(p2[1] - y3) > 0 && dcmp(x3 - (y3 - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
        isHit = !isHit;
      }
    }
    return isHit;
  }
  function inPolygons(polygons, x3, y3) {
    var isHit = false;
    for (var i = 0; i < polygons.length; i++) {
      var points = polygons[i];
      isHit = inPolygon(points, x3, y3);
      if (isHit) {
        break;
      }
    }
    return isHit;
  }
  function isPointInPath$5(displayObject, position, isClipPath) {
    var _a = displayObject.parsedStyle, x12 = _a.x1, y12 = _a.y1, x22 = _a.x2, y22 = _a.y2, _b = _a.lineWidth, lineWidth = _b === void 0 ? 1 : _b, _c = _a.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _c === void 0 ? 0 : _c, _d = _a.pointerEvents, pointerEvents = _d === void 0 ? "auto" : _d, fill = _a.fill, stroke2 = _a.stroke;
    var _e = __read(isFillOrStrokeAffected(pointerEvents, fill, stroke2), 2), hasStroke = _e[1];
    if (!hasStroke && !isClipPath || !lineWidth) {
      return false;
    }
    return inLine(x12, y12, x22, y22, lineWidth + increasedLineWidthForHitTesting, position.x, position.y);
  }
  function isPointInStroke(segments, lineWidth, px, py, length5) {
    var isHit = false;
    var halfWidth = lineWidth / 2;
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
      if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, px, py)) {
        continue;
      }
      switch (segment.command) {
        case "L":
        case "Z":
          isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, px, py);
          if (isHit) {
            return true;
          }
          break;
        case "Q":
          var qDistance = pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], px, py);
          isHit = qDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
          break;
        case "C":
          var cDistance = pointDistance$3(
            prePoint[0],
            // 上一段结束位置, 即 C 的起始点
            prePoint[1],
            params[1],
            // 'C' 的参数，1、2 为第一个控制点，3、4 为第二个控制点，5、6 为结束点
            params[2],
            params[3],
            params[4],
            params[5],
            params[6],
            px,
            py,
            length5
          );
          isHit = cDistance <= lineWidth / 2;
          if (isHit) {
            return true;
          }
          break;
        case "A":
          if (!segment.cubicParams) {
            segment.cubicParams = arcToCubic2(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6], params[7], void 0);
          }
          var args = segment.cubicParams;
          var prePointInCubic = prePoint;
          for (var i_1 = 0; i_1 < args.length; i_1 += 6) {
            var cDistance_1 = pointDistance$3(
              prePointInCubic[0],
              // 上一段结束位置, 即 C 的起始点
              prePointInCubic[1],
              args[i_1],
              args[i_1 + 1],
              args[i_1 + 2],
              args[i_1 + 3],
              args[i_1 + 4],
              args[i_1 + 5],
              px,
              py,
              length5
            );
            prePointInCubic = [args[i_1 + 4], args[i_1 + 5]];
            isHit = cDistance_1 <= lineWidth / 2;
            if (isHit) {
              return true;
            }
          }
          break;
      }
    }
    return isHit;
  }
  function isPointInPath$4(displayObject, position, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
    var _a = displayObject.parsedStyle, _b = _a.lineWidth, lineWidth = _b === void 0 ? 1 : _b, _c = _a.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _c === void 0 ? 0 : _c, stroke2 = _a.stroke, fill = _a.fill, d2 = _a.d, _d = _a.pointerEvents, pointerEvents = _d === void 0 ? "auto" : _d;
    var segments = d2.segments, hasArc = d2.hasArc, polylines = d2.polylines, polygons = d2.polygons;
    var _e = __read(isFillOrStrokeAffected(
      pointerEvents,
      // Only a closed path can be filled.
      (polygons === null || polygons === void 0 ? void 0 : polygons.length) && fill,
      stroke2
    ), 2), hasFill = _e[0], hasStroke = _e[1];
    var totalLength = getOrCalculatePathTotalLength(displayObject);
    var isHit = false;
    if (hasFill || isClipPath) {
      if (hasArc) {
        isHit = isPointInPath2(displayObject, position);
      } else {
        isHit = inPolygons(polygons, position.x, position.y) || inPolygons(polylines, position.x, position.y);
      }
      return isHit;
    } else if (hasStroke || isClipPath) {
      isHit = isPointInStroke(segments, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, totalLength);
    }
    return isHit;
  }
  function isPointInPath$3(displayObject, position, isClipPath) {
    var _a = displayObject.parsedStyle, stroke2 = _a.stroke, fill = _a.fill, _b = _a.lineWidth, lineWidth = _b === void 0 ? 1 : _b, _c = _a.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _c === void 0 ? 0 : _c, points = _a.points, _d = _a.pointerEvents, pointerEvents = _d === void 0 ? "auto" : _d;
    var _e = __read(isFillOrStrokeAffected(pointerEvents, fill, stroke2), 2), hasFill = _e[0], hasStroke = _e[1];
    var isHit = false;
    if (hasStroke || isClipPath) {
      isHit = inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, true);
    }
    if (!isHit && (hasFill || isClipPath)) {
      isHit = inPolygon(points.points, position.x, position.y);
    }
    return isHit;
  }
  function isPointInPath$2(displayObject, position, isClipPath) {
    var _a = displayObject.parsedStyle, _b = _a.lineWidth, lineWidth = _b === void 0 ? 1 : _b, _c = _a.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _c === void 0 ? 0 : _c, points = _a.points, _d = _a.pointerEvents, pointerEvents = _d === void 0 ? "auto" : _d, fill = _a.fill, stroke2 = _a.stroke;
    var _e = __read(isFillOrStrokeAffected(pointerEvents, fill, stroke2), 2), hasStroke = _e[1];
    if (!hasStroke && !isClipPath || !lineWidth) {
      return false;
    }
    return inPolyline(points.points, lineWidth + increasedLineWidthForHitTesting, position.x, position.y, false);
  }
  function isPointInPath$1(displayObject, position, isClipPath, isPointInPath2, runtime2) {
    var _a = displayObject.parsedStyle, radius = _a.radius, fill = _a.fill, stroke2 = _a.stroke, _b = _a.lineWidth, lineWidth = _b === void 0 ? 1 : _b, _c = _a.increasedLineWidthForHitTesting, increasedLineWidthForHitTesting = _c === void 0 ? 0 : _c, _d = _a.x, x3 = _d === void 0 ? 0 : _d, _e = _a.y, y3 = _e === void 0 ? 0 : _e, width = _a.width, height = _a.height, _f = _a.pointerEvents, pointerEvents = _f === void 0 ? "auto" : _f;
    var _g = __read(isFillOrStrokeAffected(pointerEvents, fill, stroke2), 2), hasFill = _g[0], hasStroke = _g[1];
    var hasRadius = radius && radius.some(function(r) {
      return r !== 0;
    });
    var lineWidthForHitTesting = lineWidth + increasedLineWidthForHitTesting;
    if (!hasRadius) {
      var halfWidth = lineWidthForHitTesting / 2;
      if (hasFill && hasStroke || isClipPath) {
        return inBox(x3 - halfWidth, y3 - halfWidth, width + halfWidth, height + halfWidth, position.x, position.y);
      }
      if (hasFill) {
        return inBox(x3, y3, width, height, position.x, position.y);
      }
      if (hasStroke) {
        return inRect(x3, y3, width, height, lineWidthForHitTesting, position.x, position.y);
      }
    } else {
      var isHit = false;
      if (hasStroke || isClipPath) {
        isHit = inRectWithRadius(x3, y3, width, height, radius.map(function(r) {
          return clamp_default5(r, 0, Math.min(Math.abs(width) / 2, Math.abs(height) / 2));
        }), lineWidthForHitTesting, position.x, position.y);
      }
      if (!isHit && (hasFill || isClipPath)) {
        isHit = isPointInPath2(displayObject, position);
      }
      return isHit;
    }
    return false;
  }
  function inRectWithRadius(minX, minY, width, height, radiusArray, lineWidth, x3, y3) {
    var _a = __read(radiusArray, 4), tlr = _a[0], trr = _a[1], brr = _a[2], blr = _a[3];
    return inLine(minX + tlr, minY, minX + width - trr, minY, lineWidth, x3, y3) || inLine(minX + width, minY + trr, minX + width, minY + height - brr, lineWidth, x3, y3) || inLine(minX + width - brr, minY + height, minX + blr, minY + height, lineWidth, x3, y3) || inLine(minX, minY + height - blr, minX, minY + tlr, lineWidth, x3, y3) || inArc(minX + width - trr, minY + trr, trr, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x3, y3) || inArc(minX + width - brr, minY + height - brr, brr, 0, 0.5 * Math.PI, lineWidth, x3, y3) || inArc(minX + blr, minY + height - blr, blr, 0.5 * Math.PI, Math.PI, lineWidth, x3, y3) || inArc(minX + tlr, minY + tlr, tlr, Math.PI, 1.5 * Math.PI, lineWidth, x3, y3);
  }
  function isPointInPath(displayObject, position, isClipPath, isPointInPath2, renderingPluginContext, runtime2) {
    var _a = displayObject.parsedStyle, _b = _a.pointerEvents, pointerEvents = _b === void 0 ? "auto" : _b, _c = _a.x, x3 = _c === void 0 ? 0 : _c, _d = _a.y, y3 = _d === void 0 ? 0 : _d, width = _a.width, height = _a.height;
    if (pointerEvents === "non-transparent-pixel") {
      var offscreenCanvas = renderingPluginContext.config.offscreenCanvas;
      var canvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
      var context = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas, {
        willReadFrequently: true
      });
      canvas.width = width;
      canvas.height = height;
      renderingPluginContext.defaultStyleRendererFactory[Shape.IMAGE].render(context, __assign(__assign({}, displayObject.parsedStyle), { x: 0, y: 0 }), displayObject, void 0, void 0, void 0);
      var imagedata = context.getImageData(position.x - x3, position.y - y3, 1, 1).data;
      return imagedata.every(function(component) {
        return component !== 0;
      });
    }
    return true;
  }
  var Plugin2 = (
    /** @class */
    function(_super) {
      __extends(Plugin8, _super);
      function Plugin8() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this.name = "canvas-picker";
        return _this;
      }
      Plugin8.prototype.init = function() {
        var _a;
        var trueFunc = function() {
          return true;
        };
        var pointInPathPickerFactory = (_a = {}, _a[Shape.CIRCLE] = isPointInPath$7, _a[Shape.ELLIPSE] = isPointInPath$6, _a[Shape.RECT] = isPointInPath$1, _a[Shape.LINE] = isPointInPath$5, _a[Shape.POLYLINE] = isPointInPath$2, _a[Shape.POLYGON] = isPointInPath$3, _a[Shape.PATH] = isPointInPath$4, _a[Shape.TEXT] = trueFunc, _a[Shape.GROUP] = null, _a[Shape.IMAGE] = isPointInPath, _a[Shape.HTML] = null, _a[Shape.MESH] = null, _a);
        this.context.pointInPathPickerFactory = pointInPathPickerFactory;
        this.addRenderingPlugin(new CanvasPickerPlugin());
      };
      Plugin8.prototype.destroy = function() {
        delete this.context.pointInPathPickerFactory;
        this.removeAllRenderingPlugins();
      };
      return Plugin8;
    }(AbstractRendererPlugin)
  );

  // ../../engine/rails_design/node_modules/@antv/g-plugin-canvas-renderer/node_modules/@antv/util/esm/lodash/is-nil.js
  var isNil5 = function(value2) {
    return value2 === null || value2 === void 0;
  };
  var is_nil_default5 = isNil5;

  // ../../engine/rails_design/node_modules/@antv/g-plugin-canvas-renderer/node_modules/@antv/util/esm/lodash/is-type.js
  var toString6 = {}.toString;
  var isType6 = function(value2, type) {
    return toString6.call(value2) === "[object " + type + "]";
  };
  var is_type_default6 = isType6;

  // ../../engine/rails_design/node_modules/@antv/g-plugin-canvas-renderer/node_modules/@antv/util/esm/lodash/is-string.js
  var is_string_default5 = function(str7) {
    return is_type_default6(str7, "String");
  };

  // ../../engine/rails_design/node_modules/@antv/g-plugin-canvas-renderer/dist/index.esm.js
  var CanvasRendererPlugin = (
    /** @class */
    function() {
      function CanvasRendererPlugin2(canvasRendererPluginOptions) {
        this.canvasRendererPluginOptions = canvasRendererPluginOptions;
        this.removedRBushNodeAABBs = [];
        this.renderQueue = [];
        this.restoreStack = [];
        this.clearFullScreenLastFrame = false;
        this.clearFullScreen = false;
        this.vpMatrix = mat4_exports.create();
        this.dprMatrix = mat4_exports.create();
        this.tmpMat4 = mat4_exports.create();
        this.vec3a = vec3_exports.create();
        this.vec3b = vec3_exports.create();
        this.vec3c = vec3_exports.create();
        this.vec3d = vec3_exports.create();
      }
      CanvasRendererPlugin2.prototype.apply = function(context, runtime2) {
        var _this = this;
        this.context = context;
        var config2 = context.config, camera = context.camera, renderingService = context.renderingService, renderingContext = context.renderingContext, rBushRoot = context.rBushRoot, pathGeneratorFactory = context.pathGeneratorFactory;
        this.rBush = rBushRoot;
        this.pathGeneratorFactory = pathGeneratorFactory;
        var contextService = context.contextService;
        var canvas = renderingContext.root.ownerDocument.defaultView;
        var handleUnmounted = function(e3) {
          var object = e3.target;
          var rBushNode = object.rBushNode;
          if (rBushNode.aabb) {
            _this.removedRBushNodeAABBs.push(rBushNode.aabb);
          }
        };
        var handleCulled = function(e3) {
          var object = e3.target;
          var rBushNode = object.rBushNode;
          if (rBushNode.aabb) {
            _this.removedRBushNodeAABBs.push(rBushNode.aabb);
          }
        };
        renderingService.hooks.init.tap(CanvasRendererPlugin2.tag, function() {
          canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas.addEventListener(ElementEvent.CULLED, handleCulled);
          var dpr = contextService.getDPR();
          var width = config2.width, height = config2.height;
          var context2 = contextService.getContext();
          _this.clearRect(context2, 0, 0, width * dpr, height * dpr, config2.background);
        });
        renderingService.hooks.destroy.tap(CanvasRendererPlugin2.tag, function() {
          canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas.removeEventListener(ElementEvent.CULLED, handleCulled);
          _this.renderQueue = [];
          _this.removedRBushNodeAABBs = [];
          _this.restoreStack = [];
        });
        renderingService.hooks.beginFrame.tap(CanvasRendererPlugin2.tag, function() {
          var _a;
          var context2 = contextService.getContext();
          var dpr = contextService.getDPR();
          var width = config2.width, height = config2.height;
          var _b = _this.canvasRendererPluginOptions, dirtyObjectNumThreshold = _b.dirtyObjectNumThreshold, dirtyObjectRatioThreshold = _b.dirtyObjectRatioThreshold;
          var _c = renderingService.getStats(), total = _c.total, rendered = _c.rendered;
          var ratio = rendered / total;
          _this.clearFullScreen = _this.clearFullScreenLastFrame || // @ts-ignore
          !((_a = canvas.context.renderingPlugins[1]) === null || _a === void 0 ? void 0 : _a.isFirstTimeRenderingFinished) || renderingService.disableDirtyRectangleRendering() || rendered > dirtyObjectNumThreshold && ratio > dirtyObjectRatioThreshold;
          if (context2) {
            context2.resetTransform ? context2.resetTransform() : context2.setTransform(1, 0, 0, 1, 0, 0);
            if (_this.clearFullScreen) {
              _this.clearRect(context2, 0, 0, width * dpr, height * dpr, config2.background);
            }
          }
        });
        var renderByZIndex = function(object, context2) {
          if (object.isVisible() && !object.isCulled()) {
            _this.renderDisplayObject(object, context2, _this.context, _this.restoreStack, runtime2);
          }
          var sorted = object.sortable.sorted || object.childNodes;
          sorted.forEach(function(child) {
            renderByZIndex(child, context2);
          });
        };
        renderingService.hooks.endFrame.tap(CanvasRendererPlugin2.tag, function() {
          if (renderingContext.root.childNodes.length === 0) {
            _this.clearFullScreenLastFrame = true;
            return;
          }
          _this.clearFullScreenLastFrame = false;
          var context2 = contextService.getContext();
          var dpr = contextService.getDPR();
          mat4_exports.fromScaling(_this.dprMatrix, [dpr, dpr, 1]);
          mat4_exports.multiply(_this.vpMatrix, _this.dprMatrix, camera.getOrthoMatrix());
          if (_this.clearFullScreen) {
            renderByZIndex(renderingContext.root, context2);
          } else {
            var dirtyRenderBounds = _this.safeMergeAABB.apply(_this, __spreadArray([_this.mergeDirtyAABBs(_this.renderQueue)], __read(_this.removedRBushNodeAABBs.map(function(_a) {
              var minX = _a.minX, minY = _a.minY, maxX = _a.maxX, maxY2 = _a.maxY;
              var aabb = new AABB();
              aabb.setMinMax(
                // vec3.fromValues(minX, minY, 0),
                // vec3.fromValues(maxX, maxY, 0),
                [minX, minY, 0],
                [maxX, maxY2, 0]
              );
              return aabb;
            })), false));
            _this.removedRBushNodeAABBs = [];
            if (AABB.isEmpty(dirtyRenderBounds)) {
              _this.renderQueue = [];
              return;
            }
            var dirtyRect = _this.convertAABB2Rect(dirtyRenderBounds);
            var x3 = dirtyRect.x, y3 = dirtyRect.y, width = dirtyRect.width, height = dirtyRect.height;
            var tl = vec3_exports.transformMat4(_this.vec3a, [x3, y3, 0], _this.vpMatrix);
            var tr = vec3_exports.transformMat4(_this.vec3b, [x3 + width, y3, 0], _this.vpMatrix);
            var bl = vec3_exports.transformMat4(_this.vec3c, [x3, y3 + height, 0], _this.vpMatrix);
            var br = vec3_exports.transformMat4(_this.vec3d, [x3 + width, y3 + height, 0], _this.vpMatrix);
            var minx = Math.min(tl[0], tr[0], br[0], bl[0]);
            var miny = Math.min(tl[1], tr[1], br[1], bl[1]);
            var maxx = Math.max(tl[0], tr[0], br[0], bl[0]);
            var maxy = Math.max(tl[1], tr[1], br[1], bl[1]);
            var ix = Math.floor(minx);
            var iy = Math.floor(miny);
            var iwidth = Math.ceil(maxx - minx);
            var iheight = Math.ceil(maxy - miny);
            context2.save();
            _this.clearRect(context2, ix, iy, iwidth, iheight, config2.background);
            context2.beginPath();
            context2.rect(ix, iy, iwidth, iheight);
            context2.clip();
            context2.setTransform(_this.vpMatrix[0], _this.vpMatrix[1], _this.vpMatrix[4], _this.vpMatrix[5], _this.vpMatrix[12], _this.vpMatrix[13]);
            var enableDirtyRectangleRenderingDebug = config2.renderer.getConfig().enableDirtyRectangleRenderingDebug;
            if (enableDirtyRectangleRenderingDebug) {
              canvas.dispatchEvent(new CustomEvent2(CanvasEvent.DIRTY_RECTANGLE, {
                dirtyRect: {
                  x: ix,
                  y: iy,
                  width: iwidth,
                  height: iheight
                }
              }));
            }
            var dirtyObjects = _this.searchDirtyObjects(dirtyRenderBounds);
            dirtyObjects.sort(function(a3, b) {
              return a3.sortable.renderOrder - b.sortable.renderOrder;
            }).forEach(function(object) {
              if (object && object.isVisible() && !object.isCulled()) {
                _this.renderDisplayObject(object, context2, _this.context, _this.restoreStack, runtime2);
              }
            });
            context2.restore();
            _this.renderQueue.forEach(function(object) {
              _this.saveDirtyAABB(object);
            });
            _this.renderQueue = [];
          }
          _this.restoreStack.forEach(function() {
            context2.restore();
          });
          _this.restoreStack = [];
        });
        renderingService.hooks.render.tap(CanvasRendererPlugin2.tag, function(object) {
          if (!_this.clearFullScreen) {
            _this.renderQueue.push(object);
          }
        });
      };
      CanvasRendererPlugin2.prototype.clearRect = function(context, x3, y3, width, height, background) {
        context.clearRect(x3, y3, width, height);
        if (background) {
          context.fillStyle = background;
          context.fillRect(x3, y3, width, height);
        }
      };
      CanvasRendererPlugin2.prototype.renderDisplayObject = function(object, context, canvasContext, restoreStack, runtime2) {
        var nodeName = object.nodeName;
        var parent = restoreStack[restoreStack.length - 1];
        if (parent && !(object.compareDocumentPosition(parent) & Node2.DOCUMENT_POSITION_CONTAINS)) {
          context.restore();
          restoreStack.pop();
        }
        var styleRenderer = this.context.styleRendererFactory[nodeName];
        var generatePath2 = this.pathGeneratorFactory[nodeName];
        var clipPath = object.parsedStyle.clipPath;
        if (clipPath) {
          this.applyWorldTransform(context, clipPath);
          var generatePath_1 = this.pathGeneratorFactory[clipPath.nodeName];
          if (generatePath_1) {
            context.save();
            restoreStack.push(object);
            context.beginPath();
            generatePath_1(context, clipPath.parsedStyle);
            context.closePath();
            context.clip();
          }
        }
        if (styleRenderer) {
          this.applyWorldTransform(context, object);
          context.save();
          this.applyAttributesToContext(context, object);
        }
        if (generatePath2) {
          context.beginPath();
          generatePath2(context, object.parsedStyle);
          if (object.nodeName !== Shape.LINE && object.nodeName !== Shape.PATH && object.nodeName !== Shape.POLYLINE) {
            context.closePath();
          }
        }
        if (styleRenderer) {
          styleRenderer.render(context, object.parsedStyle, object, canvasContext, this, runtime2);
          context.restore();
        }
        object.renderable.dirty = false;
      };
      CanvasRendererPlugin2.prototype.convertAABB2Rect = function(aabb) {
        var min10 = aabb.getMin();
        var max10 = aabb.getMax();
        var minX = Math.floor(min10[0]);
        var minY = Math.floor(min10[1]);
        var maxX = Math.ceil(max10[0]);
        var maxY2 = Math.ceil(max10[1]);
        var width = maxX - minX;
        var height = maxY2 - minY;
        return { x: minX, y: minY, width, height };
      };
      CanvasRendererPlugin2.prototype.mergeDirtyAABBs = function(dirtyObjects) {
        var aabb = new AABB();
        dirtyObjects.forEach(function(object) {
          var renderBounds = object.getRenderBounds();
          aabb.add(renderBounds);
          var dirtyRenderBounds = object.renderable.dirtyRenderBounds;
          if (dirtyRenderBounds) {
            aabb.add(dirtyRenderBounds);
          }
        });
        return aabb;
      };
      CanvasRendererPlugin2.prototype.searchDirtyObjects = function(dirtyRectangle) {
        var _a = __read(dirtyRectangle.getMin(), 2), minX = _a[0], minY = _a[1];
        var _b = __read(dirtyRectangle.getMax(), 2), maxX = _b[0], maxY2 = _b[1];
        var rBushNodes = this.rBush.search({
          minX,
          minY,
          maxX,
          maxY: maxY2
        });
        return rBushNodes.map(function(_a2) {
          var displayObject = _a2.displayObject;
          return displayObject;
        });
      };
      CanvasRendererPlugin2.prototype.saveDirtyAABB = function(object) {
        var renderable = object.renderable;
        if (!renderable.dirtyRenderBounds) {
          renderable.dirtyRenderBounds = new AABB();
        }
        var renderBounds = object.getRenderBounds();
        if (renderBounds) {
          renderable.dirtyRenderBounds.update(renderBounds.center, renderBounds.halfExtents);
        }
      };
      CanvasRendererPlugin2.prototype.applyAttributesToContext = function(context, object) {
        var _a = object.parsedStyle, stroke2 = _a.stroke, fill = _a.fill, opacity = _a.opacity, lineDash = _a.lineDash, lineDashOffset = _a.lineDashOffset;
        if (lineDash) {
          context.setLineDash(lineDash);
        }
        if (!is_nil_default5(lineDashOffset)) {
          context.lineDashOffset = lineDashOffset;
        }
        if (!is_nil_default5(opacity)) {
          context.globalAlpha *= opacity;
        }
        if (!is_nil_default5(stroke2) && !Array.isArray(stroke2) && !stroke2.isNone) {
          context.strokeStyle = object.attributes.stroke;
        }
        if (!is_nil_default5(fill) && !Array.isArray(fill) && !fill.isNone) {
          context.fillStyle = object.attributes.fill;
        }
      };
      CanvasRendererPlugin2.prototype.applyWorldTransform = function(context, object, matrix2) {
        if (matrix2) {
          mat4_exports.copy(this.tmpMat4, object.getLocalTransform());
          mat4_exports.multiply(this.tmpMat4, matrix2, this.tmpMat4);
          mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
        } else {
          mat4_exports.copy(this.tmpMat4, object.getWorldTransform());
          mat4_exports.multiply(this.tmpMat4, this.vpMatrix, this.tmpMat4);
        }
        context.setTransform(this.tmpMat4[0], this.tmpMat4[1], this.tmpMat4[4], this.tmpMat4[5], this.tmpMat4[12], this.tmpMat4[13]);
      };
      CanvasRendererPlugin2.prototype.safeMergeAABB = function() {
        var aabbs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          aabbs[_i] = arguments[_i];
        }
        var merged = new AABB();
        aabbs.forEach(function(aabb) {
          merged.add(aabb);
        });
        return merged;
      };
      CanvasRendererPlugin2.tag = "CanvasRenderer";
      return CanvasRendererPlugin2;
    }()
  );
  var DefaultRenderer = (
    /** @class */
    function() {
      function DefaultRenderer2(imagePool) {
        this.imagePool = imagePool;
      }
      DefaultRenderer2.prototype.render = function(context, parsedStyle, object, canvasContext, plugin, runtime2) {
        var fill = parsedStyle.fill, fillRule = parsedStyle.fillRule, _a = parsedStyle.opacity, opacity = _a === void 0 ? 1 : _a, _b = parsedStyle.fillOpacity, fillOpacity = _b === void 0 ? 1 : _b, stroke2 = parsedStyle.stroke, _c = parsedStyle.strokeOpacity, strokeOpacity = _c === void 0 ? 1 : _c, _d = parsedStyle.lineWidth, lineWidth = _d === void 0 ? 1 : _d, lineCap = parsedStyle.lineCap, lineJoin = parsedStyle.lineJoin, shadowType = parsedStyle.shadowType, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur, filter2 = parsedStyle.filter, miterLimit = parsedStyle.miterLimit;
        var hasFill = fill && !fill.isNone;
        var hasStroke = stroke2 && !stroke2.isNone && lineWidth > 0;
        var isFillTransparent = (fill === null || fill === void 0 ? void 0 : fill.alpha) === 0;
        var hasFilter = !!(filter2 && filter2.length);
        var hasShadow = !is_nil_default5(shadowColor) && shadowBlur > 0;
        var nodeName = object.nodeName;
        var isInnerShadow = shadowType === "inner";
        var shouldDrawShadowWithStroke = hasStroke && hasShadow && (nodeName === Shape.PATH || nodeName === Shape.LINE || nodeName === Shape.POLYLINE || isFillTransparent || isInnerShadow);
        if (hasFill) {
          context.globalAlpha = opacity * fillOpacity;
          if (!shouldDrawShadowWithStroke) {
            setShadowAndFilter(object, context, hasShadow);
          }
          applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool);
          if (!shouldDrawShadowWithStroke) {
            this.clearShadowAndFilter(context, hasFilter, hasShadow);
          }
        }
        if (hasStroke) {
          context.globalAlpha = opacity * strokeOpacity;
          context.lineWidth = lineWidth;
          if (!is_nil_default5(miterLimit)) {
            context.miterLimit = miterLimit;
          }
          if (!is_nil_default5(lineCap)) {
            context.lineCap = lineCap;
          }
          if (!is_nil_default5(lineJoin)) {
            context.lineJoin = lineJoin;
          }
          if (shouldDrawShadowWithStroke) {
            if (isInnerShadow) {
              context.globalCompositeOperation = "source-atop";
            }
            setShadowAndFilter(object, context, true);
            if (isInnerShadow) {
              applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, this.imagePool);
              context.globalCompositeOperation = "source-over";
              this.clearShadowAndFilter(context, hasFilter, true);
            }
          }
          applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, this.imagePool);
        }
      };
      DefaultRenderer2.prototype.clearShadowAndFilter = function(context, hasFilter, hasShadow) {
        if (hasShadow) {
          context.shadowColor = "transparent";
          context.shadowBlur = 0;
        }
        if (hasFilter) {
          var oldFilter = context.filter;
          if (!is_nil_default5(oldFilter) && oldFilter.indexOf("drop-shadow") > -1) {
            context.filter = oldFilter.replace(/drop-shadow\([^)]*\)/, "").trim() || "none";
          }
        }
      };
      return DefaultRenderer2;
    }()
  );
  function setShadowAndFilter(object, context, hasShadow) {
    var _a = object.parsedStyle, filter2 = _a.filter, shadowColor = _a.shadowColor, shadowBlur = _a.shadowBlur, shadowOffsetX = _a.shadowOffsetX, shadowOffsetY = _a.shadowOffsetY;
    if (filter2 && filter2.length) {
      context.filter = object.style.filter;
    }
    if (hasShadow) {
      context.shadowColor = shadowColor.toString();
      context.shadowBlur = shadowBlur || 0;
      context.shadowOffsetX = shadowOffsetX || 0;
      context.shadowOffsetY = shadowOffsetY || 0;
    }
  }
  function getPattern(pattern, object, context, canvasContext, plugin, runtime2, imagePool) {
    var $offscreenCanvas;
    var dpr;
    if (pattern.image.nodeName === "rect") {
      var _a = pattern.image.parsedStyle, width = _a.width, height = _a.height;
      dpr = canvasContext.contextService.getDPR();
      var offscreenCanvas = canvasContext.config.offscreenCanvas;
      $offscreenCanvas = runtime2.offscreenCanvasCreator.getOrCreateCanvas(offscreenCanvas);
      $offscreenCanvas.width = width * dpr;
      $offscreenCanvas.height = height * dpr;
      var offscreenCanvasContext_1 = runtime2.offscreenCanvasCreator.getOrCreateContext(offscreenCanvas);
      var restoreStack_1 = [];
      pattern.image.forEach(function(object2) {
        plugin.renderDisplayObject(object2, offscreenCanvasContext_1, canvasContext, restoreStack_1, runtime2);
      });
      restoreStack_1.forEach(function() {
        offscreenCanvasContext_1.restore();
      });
    }
    var canvasPattern = imagePool.getOrCreatePatternSync(pattern, context, $offscreenCanvas, dpr, object.getGeometryBounds().min, function() {
      object.renderable.dirty = true;
      canvasContext.renderingService.dirtify();
    });
    return canvasPattern;
  }
  function getColor2(parsedColor, object, context, imagePool) {
    var color2;
    if (parsedColor.type === GradientType.LinearGradient || parsedColor.type === GradientType.RadialGradient) {
      var bounds = object.getGeometryBounds();
      var width = bounds && bounds.halfExtents[0] * 2 || 1;
      var height = bounds && bounds.halfExtents[1] * 2 || 1;
      var min10 = bounds && bounds.min || [0, 0];
      color2 = imagePool.getOrCreateGradient(__assign(__assign({ type: parsedColor.type }, parsedColor.value), { min: min10, width, height }), context);
    }
    return color2;
  }
  function applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, imagePool, skipFill) {
    if (skipFill === void 0) {
      skipFill = false;
    }
    if (Array.isArray(fill)) {
      fill.forEach(function(gradient) {
        context.fillStyle = getColor2(gradient, object, context, imagePool);
        if (!skipFill) {
          fillRule ? context.fill(fillRule) : context.fill();
        }
      });
    } else {
      if (isPattern(fill)) {
        context.fillStyle = getPattern(fill, object, context, canvasContext, plugin, runtime2, imagePool);
      }
      if (!skipFill) {
        fillRule ? context.fill(fillRule) : context.fill();
      }
    }
  }
  function applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, imagePool, skipStroke) {
    if (skipStroke === void 0) {
      skipStroke = false;
    }
    if (Array.isArray(stroke2)) {
      stroke2.forEach(function(gradient) {
        context.strokeStyle = getColor2(gradient, object, context, imagePool);
        if (!skipStroke) {
          context.stroke();
        }
      });
    } else {
      if (isPattern(stroke2)) {
        context.strokeStyle = getPattern(stroke2, object, context, canvasContext, plugin, runtime2, imagePool);
      }
      if (!skipStroke) {
        context.stroke();
      }
    }
  }
  var ImageRenderer = (
    /** @class */
    function() {
      function ImageRenderer2(imagePool) {
        this.imagePool = imagePool;
      }
      ImageRenderer2.prototype.render = function(context, parsedStyle, object) {
        var _a = parsedStyle.x, x3 = _a === void 0 ? 0 : _a, _b = parsedStyle.y, y3 = _b === void 0 ? 0 : _b, width = parsedStyle.width, height = parsedStyle.height, src = parsedStyle.src, shadowColor = parsedStyle.shadowColor, shadowBlur = parsedStyle.shadowBlur;
        var image;
        var iw = width;
        var ih = height;
        if (is_string_default5(src)) {
          image = this.imagePool.getImageSync(src);
        } else {
          iw || (iw = src.width);
          ih || (ih = src.height);
          image = src;
        }
        if (image) {
          var hasShadow = !is_nil_default5(shadowColor) && shadowBlur > 0;
          setShadowAndFilter(object, context, hasShadow);
          try {
            context.drawImage(image, x3, y3, iw, ih);
          } catch (e3) {
          }
        }
      };
      return ImageRenderer2;
    }()
  );
  var TextRenderer = (
    /** @class */
    function() {
      function TextRenderer2(imagePool) {
        this.imagePool = imagePool;
      }
      TextRenderer2.prototype.render = function(context, parsedStyle, object, canvasContext, plugin, runtime2) {
        object.getBounds();
        var _a = parsedStyle, _b = _a.lineWidth, lineWidth = _b === void 0 ? 1 : _b, _c = _a.textAlign, textAlign = _c === void 0 ? "start" : _c, _d = _a.textBaseline, textBaseline = _d === void 0 ? "alphabetic" : _d, _e = _a.lineJoin, lineJoin = _e === void 0 ? "miter" : _e, _f = _a.miterLimit, miterLimit = _f === void 0 ? 10 : _f, _g = _a.letterSpacing, letterSpacing = _g === void 0 ? 0 : _g, stroke2 = _a.stroke, fill = _a.fill, fillRule = _a.fillRule, _h = _a.fillOpacity, fillOpacity = _h === void 0 ? 1 : _h, _j = _a.strokeOpacity, strokeOpacity = _j === void 0 ? 1 : _j, _k = _a.opacity, opacity = _k === void 0 ? 1 : _k, metrics = _a.metrics, _l = _a.x, x3 = _l === void 0 ? 0 : _l, _m = _a.y, y3 = _m === void 0 ? 0 : _m, dx = _a.dx, dy = _a.dy, shadowColor = _a.shadowColor, shadowBlur = _a.shadowBlur;
        var font = metrics.font, lines = metrics.lines, height = metrics.height, lineHeight = metrics.lineHeight, lineMetrics = metrics.lineMetrics;
        context.font = font;
        context.lineWidth = lineWidth;
        context.textAlign = textAlign === "middle" ? "center" : textAlign;
        var formattedTextBaseline = textBaseline;
        if (
          // formattedTextBaseline === 'bottom' ||
          !runtime2.enableCSSParsing && formattedTextBaseline === "alphabetic"
        ) {
          formattedTextBaseline = "bottom";
        }
        context.lineJoin = lineJoin;
        if (!is_nil_default5(miterLimit)) {
          context.miterLimit = miterLimit;
        }
        var linePositionY = y3;
        if (textBaseline === "middle") {
          linePositionY += -height / 2 - lineHeight / 2;
        } else if (textBaseline === "bottom" || textBaseline === "alphabetic" || textBaseline === "ideographic") {
          linePositionY += -height;
        } else if (textBaseline === "top" || textBaseline === "hanging") {
          linePositionY += -lineHeight;
        }
        var offsetX = x3 + (dx || 0);
        linePositionY += dy || 0;
        if (lines.length === 1) {
          if (formattedTextBaseline === "bottom") {
            formattedTextBaseline = "middle";
            linePositionY -= 0.5 * height;
          } else if (formattedTextBaseline === "top") {
            formattedTextBaseline = "middle";
            linePositionY += 0.5 * height;
          }
        }
        context.textBaseline = formattedTextBaseline;
        var hasShadow = !is_nil_default5(shadowColor) && shadowBlur > 0;
        setShadowAndFilter(object, context, hasShadow);
        for (var i = 0; i < lines.length; i++) {
          var linePositionX = lineWidth / 2 + offsetX;
          linePositionY += lineHeight;
          if (!is_nil_default5(stroke2) && !stroke2.isNone && lineWidth) {
            this.drawLetterSpacing(context, object, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke2, strokeOpacity, opacity, true, canvasContext, plugin, runtime2);
          }
          if (!is_nil_default5(fill)) {
            this.drawLetterSpacing(context, object, lines[i], lineMetrics[i], textAlign, linePositionX, linePositionY, letterSpacing, fill, fillRule, fillOpacity, stroke2, strokeOpacity, opacity, false, canvasContext, plugin, runtime2);
          }
        }
      };
      TextRenderer2.prototype.drawLetterSpacing = function(context, object, text, lineMetrics, textAlign, x3, y3, letterSpacing, fill, fillRule, fillOpacity, stroke2, strokeOpacity, opacity, isStroke, canvasContext, plugin, runtime2) {
        if (letterSpacing === 0) {
          if (isStroke) {
            this.strokeText(context, object, text, x3, y3, stroke2, strokeOpacity, canvasContext, plugin, runtime2);
          } else {
            this.fillText(context, object, text, x3, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2);
          }
          return;
        }
        var currentTextAlign = context.textAlign;
        context.textAlign = "left";
        var currentPosition = x3;
        if (textAlign === "center" || textAlign === "middle") {
          currentPosition = x3 - lineMetrics.width / 2;
        } else if (textAlign === "right" || textAlign === "end") {
          currentPosition = x3 - lineMetrics.width;
        }
        var stringArray = Array.from(text);
        var previousWidth = context.measureText(text).width;
        var currentWidth = 0;
        for (var i = 0; i < stringArray.length; ++i) {
          var currentChar = stringArray[i];
          if (isStroke) {
            this.strokeText(context, object, currentChar, currentPosition, y3, stroke2, strokeOpacity, canvasContext, plugin, runtime2);
          } else {
            this.fillText(context, object, currentChar, currentPosition, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2);
          }
          currentWidth = context.measureText(text.substring(i + 1)).width;
          currentPosition += previousWidth - currentWidth + letterSpacing;
          previousWidth = currentWidth;
        }
        context.textAlign = currentTextAlign;
      };
      TextRenderer2.prototype.fillText = function(context, object, text, x3, y3, fill, fillRule, fillOpacity, opacity, canvasContext, plugin, runtime2) {
        applyFill(context, object, fill, fillRule, canvasContext, plugin, runtime2, this.imagePool, true);
        var currentGlobalAlpha;
        var applyOpacity = !is_nil_default5(fillOpacity) && fillOpacity !== 1;
        if (applyOpacity) {
          currentGlobalAlpha = context.globalAlpha;
          context.globalAlpha = fillOpacity * opacity;
        }
        context.fillText(text, x3, y3);
        if (applyOpacity) {
          context.globalAlpha = currentGlobalAlpha;
        }
      };
      TextRenderer2.prototype.strokeText = function(context, object, text, x3, y3, stroke2, strokeOpacity, canvasContext, plugin, runtime2) {
        applyStroke(context, object, stroke2, canvasContext, plugin, runtime2, this.imagePool, true);
        var currentGlobalAlpha;
        var applyOpacity = !is_nil_default5(strokeOpacity) && strokeOpacity !== 1;
        if (applyOpacity) {
          currentGlobalAlpha = context.globalAlpha;
          context.globalAlpha = strokeOpacity;
        }
        context.strokeText(text, x3, y3);
        if (applyOpacity) {
          context.globalAlpha = currentGlobalAlpha;
        }
      };
      return TextRenderer2;
    }()
  );
  var RectRenderer = (
    /** @class */
    function(_super) {
      __extends(RectRenderer2, _super);
      function RectRenderer2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return RectRenderer2;
    }(DefaultRenderer)
  );
  var CircleRenderer = (
    /** @class */
    function(_super) {
      __extends(CircleRenderer2, _super);
      function CircleRenderer2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return CircleRenderer2;
    }(DefaultRenderer)
  );
  var EllipseRenderer = (
    /** @class */
    function(_super) {
      __extends(EllipseRenderer2, _super);
      function EllipseRenderer2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return EllipseRenderer2;
    }(DefaultRenderer)
  );
  var LineRenderer = (
    /** @class */
    function(_super) {
      __extends(LineRenderer2, _super);
      function LineRenderer2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return LineRenderer2;
    }(DefaultRenderer)
  );
  var PolylineRenderer = (
    /** @class */
    function(_super) {
      __extends(PolylineRenderer2, _super);
      function PolylineRenderer2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return PolylineRenderer2;
    }(DefaultRenderer)
  );
  var PolygonRenderer = (
    /** @class */
    function(_super) {
      __extends(PolygonRenderer2, _super);
      function PolygonRenderer2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return PolygonRenderer2;
    }(DefaultRenderer)
  );
  var PathRenderer = (
    /** @class */
    function(_super) {
      __extends(PathRenderer2, _super);
      function PathRenderer2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return PathRenderer2;
    }(DefaultRenderer)
  );
  var Plugin3 = (
    /** @class */
    function(_super) {
      __extends(Plugin8, _super);
      function Plugin8(options) {
        if (options === void 0) {
          options = {};
        }
        var _this = _super.call(this) || this;
        _this.options = options;
        _this.name = "canvas-renderer";
        return _this;
      }
      Plugin8.prototype.init = function() {
        var _a;
        var canvasRendererPluginOptions = __assign({ dirtyObjectNumThreshold: 500, dirtyObjectRatioThreshold: 0.8 }, this.options);
        var imagePool = this.context.imagePool;
        var defaultRenderer = new DefaultRenderer(imagePool);
        var defaultStyleRendererFactory = (_a = {}, _a[Shape.CIRCLE] = defaultRenderer, _a[Shape.ELLIPSE] = defaultRenderer, _a[Shape.RECT] = defaultRenderer, _a[Shape.IMAGE] = new ImageRenderer(imagePool), _a[Shape.TEXT] = new TextRenderer(imagePool), _a[Shape.LINE] = defaultRenderer, _a[Shape.POLYLINE] = defaultRenderer, _a[Shape.POLYGON] = defaultRenderer, _a[Shape.PATH] = defaultRenderer, _a[Shape.GROUP] = void 0, _a[Shape.HTML] = void 0, _a[Shape.MESH] = void 0, _a);
        this.context.defaultStyleRendererFactory = defaultStyleRendererFactory;
        this.context.styleRendererFactory = defaultStyleRendererFactory;
        this.addRenderingPlugin(new CanvasRendererPlugin(canvasRendererPluginOptions));
      };
      Plugin8.prototype.destroy = function() {
        this.removeAllRenderingPlugins();
        delete this.context.defaultStyleRendererFactory;
        delete this.context.styleRendererFactory;
      };
      return Plugin8;
    }(AbstractRendererPlugin)
  );

  // ../../engine/rails_design/node_modules/@antv/g-plugin-dom-interaction/dist/index.esm.js
  var DOMInteractionPlugin = (
    /** @class */
    function() {
      function DOMInteractionPlugin2() {
      }
      DOMInteractionPlugin2.prototype.apply = function(context, runtime2) {
        var _this = this;
        var renderingService = context.renderingService, renderingContext = context.renderingContext, config2 = context.config;
        this.context = context;
        var canvas = renderingContext.root.ownerDocument.defaultView;
        var onPointerMove = function(ev) {
          renderingService.hooks.pointerMove.call(ev);
        };
        var onPointerUp = function(ev) {
          renderingService.hooks.pointerUp.call(ev);
        };
        var onPointerDown = function(ev) {
          renderingService.hooks.pointerDown.call(ev);
        };
        var onPointerOver = function(ev) {
          renderingService.hooks.pointerOver.call(ev);
        };
        var onPointerOut = function(ev) {
          renderingService.hooks.pointerOut.call(ev);
        };
        var onPointerCancel = function(ev) {
          renderingService.hooks.pointerCancel.call(ev);
        };
        var onPointerWheel = function(ev) {
          renderingService.hooks.pointerWheel.call(ev);
        };
        var onClick = function(ev) {
          renderingService.hooks.click.call(ev);
        };
        var addPointerEventListener = function($el) {
          runtime2.globalThis.document.addEventListener("pointermove", onPointerMove, true);
          $el.addEventListener("pointerdown", onPointerDown, true);
          $el.addEventListener("pointerleave", onPointerOut, true);
          $el.addEventListener("pointerover", onPointerOver, true);
          runtime2.globalThis.addEventListener("pointerup", onPointerUp, true);
          runtime2.globalThis.addEventListener("pointercancel", onPointerCancel, true);
        };
        var addTouchEventListener = function($el) {
          $el.addEventListener("touchstart", onPointerDown, true);
          $el.addEventListener("touchend", onPointerUp, true);
          $el.addEventListener("touchmove", onPointerMove, true);
          $el.addEventListener("touchcancel", onPointerCancel, true);
        };
        var addMouseEventListener = function($el) {
          runtime2.globalThis.document.addEventListener("mousemove", onPointerMove, true);
          $el.addEventListener("mousedown", onPointerDown, true);
          $el.addEventListener("mouseout", onPointerOut, true);
          $el.addEventListener("mouseover", onPointerOver, true);
          runtime2.globalThis.addEventListener("mouseup", onPointerUp, true);
        };
        var removePointerEventListener = function($el) {
          runtime2.globalThis.document.removeEventListener("pointermove", onPointerMove, true);
          $el.removeEventListener("pointerdown", onPointerDown, true);
          $el.removeEventListener("pointerleave", onPointerOut, true);
          $el.removeEventListener("pointerover", onPointerOver, true);
          runtime2.globalThis.removeEventListener("pointerup", onPointerUp, true);
        };
        var removeTouchEventListener = function($el) {
          $el.removeEventListener("touchstart", onPointerDown, true);
          $el.removeEventListener("touchend", onPointerUp, true);
          $el.removeEventListener("touchmove", onPointerMove, true);
          $el.removeEventListener("touchcancel", onPointerCancel, true);
        };
        var removeMouseEventListener = function($el) {
          runtime2.globalThis.document.removeEventListener("mousemove", onPointerMove, true);
          $el.removeEventListener("mousedown", onPointerDown, true);
          $el.removeEventListener("mouseout", onPointerOut, true);
          $el.removeEventListener("mouseover", onPointerOver, true);
          runtime2.globalThis.removeEventListener("mouseup", onPointerUp, true);
        };
        renderingService.hooks.init.tap(DOMInteractionPlugin2.tag, function() {
          var $el = _this.context.contextService.getDomElement();
          if (runtime2.globalThis.navigator.msPointerEnabled) {
            $el.style.msContentZooming = "none";
            $el.style.msTouchAction = "none";
          } else if (canvas.supportsPointerEvents) {
            $el.style.touchAction = "none";
          }
          if (canvas.supportsPointerEvents) {
            addPointerEventListener($el);
          } else {
            addMouseEventListener($el);
          }
          if (canvas.supportsTouchEvents) {
            addTouchEventListener($el);
          }
          if (config2.useNativeClickEvent) {
            $el.addEventListener("click", onClick, true);
          }
          $el.addEventListener("wheel", onPointerWheel, {
            passive: true,
            capture: true
          });
        });
        renderingService.hooks.destroy.tap(DOMInteractionPlugin2.tag, function() {
          var $el = _this.context.contextService.getDomElement();
          if (runtime2.globalThis.navigator.msPointerEnabled) {
            $el.style.msContentZooming = "";
            $el.style.msTouchAction = "";
          } else if (canvas.supportsPointerEvents) {
            $el.style.touchAction = "";
          }
          if (canvas.supportsPointerEvents) {
            removePointerEventListener($el);
          } else {
            removeMouseEventListener($el);
          }
          if (canvas.supportsTouchEvents) {
            removeTouchEventListener($el);
          }
          if (config2.useNativeClickEvent) {
            $el.removeEventListener("click", onClick, true);
          }
          $el.removeEventListener("wheel", onPointerWheel, true);
        });
      };
      DOMInteractionPlugin2.tag = "DOMInteraction";
      return DOMInteractionPlugin2;
    }()
  );
  var Plugin4 = (
    /** @class */
    function(_super) {
      __extends(Plugin8, _super);
      function Plugin8() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this.name = "dom-interaction";
        return _this;
      }
      Plugin8.prototype.init = function() {
        this.addRenderingPlugin(new DOMInteractionPlugin());
      };
      Plugin8.prototype.destroy = function() {
        this.removeAllRenderingPlugins();
      };
      return Plugin8;
    }(AbstractRendererPlugin)
  );

  // ../../engine/rails_design/node_modules/@antv/g-plugin-html-renderer/node_modules/@antv/util/esm/lodash/is-nil.js
  var isNil6 = function(value2) {
    return value2 === null || value2 === void 0;
  };
  var is_nil_default6 = isNil6;

  // ../../engine/rails_design/node_modules/@antv/g-plugin-html-renderer/node_modules/@antv/util/esm/lodash/is-type.js
  var toString7 = {}.toString;
  var isType7 = function(value2, type) {
    return toString7.call(value2) === "[object " + type + "]";
  };
  var is_type_default7 = isType7;

  // ../../engine/rails_design/node_modules/@antv/g-plugin-html-renderer/node_modules/@antv/util/esm/lodash/is-string.js
  var is_string_default6 = function(str7) {
    return is_type_default7(str7, "String");
  };

  // ../../engine/rails_design/node_modules/@antv/g-plugin-html-renderer/node_modules/@antv/util/esm/lodash/is-number.js
  var isNumber7 = function(value2) {
    return is_type_default7(value2, "Number");
  };
  var is_number_default6 = isNumber7;

  // ../../engine/rails_design/node_modules/@antv/g-plugin-html-renderer/dist/index.esm.js
  var CANVAS_CAMERA_ID = "g-canvas-camera";
  var HTMLRenderingPlugin = (
    /** @class */
    function() {
      function HTMLRenderingPlugin2() {
        this.displayObjectHTMLElementMap = /* @__PURE__ */ new WeakMap();
      }
      HTMLRenderingPlugin2.prototype.joinTransformMatrix = function(matrix2) {
        return "matrix(".concat([
          matrix2[0],
          matrix2[1],
          matrix2[4],
          matrix2[5],
          matrix2[12],
          matrix2[13]
        ].join(","), ")");
      };
      HTMLRenderingPlugin2.prototype.apply = function(context, runtime2) {
        var _this = this;
        var camera = context.camera, renderingContext = context.renderingContext, renderingService = context.renderingService;
        this.context = context;
        var canvas = renderingContext.root.ownerDocument.defaultView;
        var nativeHTMLMap = canvas.context.eventService.nativeHTMLMap;
        var setTransform = function(object, $el) {
          $el.style.transform = _this.joinTransformMatrix(object.getWorldTransform());
        };
        var handleMounted = function(e3) {
          var object = e3.target;
          if (object.nodeName === Shape.HTML) {
            if (!_this.$camera) {
              _this.$camera = _this.createCamera(camera);
            }
            var $el_1 = _this.getOrCreateEl(object);
            _this.$camera.appendChild($el_1);
            if (runtime2.enableCSSParsing) {
              var attributes_1 = object.ownerDocument.documentElement.attributes;
              Object.keys(attributes_1).forEach(function(name2) {
                $el_1.style[name2] = attributes_1[name2];
              });
            }
            Object.keys(object.attributes).forEach(function(name2) {
              _this.updateAttribute(name2, object);
            });
            setTransform(object, $el_1);
            nativeHTMLMap.set($el_1, object);
          }
        };
        var handleUnmounted = function(e3) {
          var object = e3.target;
          if (object.nodeName === Shape.HTML && _this.$camera) {
            var $el = _this.getOrCreateEl(object);
            if ($el) {
              $el.remove();
              nativeHTMLMap.delete($el);
            }
          }
        };
        var handleAttributeChanged = function(e3) {
          var object = e3.target;
          if (object.nodeName === Shape.HTML) {
            var attrName = e3.attrName;
            _this.updateAttribute(attrName, object);
          }
        };
        var handleBoundsChanged = function(e3) {
          var object = e3.target;
          if (object.nodeName === Shape.HTML) {
            var $el = _this.getOrCreateEl(object);
            setTransform(object, $el);
          }
        };
        var handleCanvasResize = function() {
          if (_this.$camera) {
            var _a = _this.context.config, width = _a.width, height = _a.height;
            _this.$camera.style.width = "".concat(width || 0, "px");
            _this.$camera.style.height = "".concat(height || 0, "px");
          }
        };
        renderingService.hooks.init.tap(HTMLRenderingPlugin2.tag, function() {
          canvas.addEventListener(CanvasEvent.RESIZE, handleCanvasResize);
          canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas.addEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
          canvas.addEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        });
        renderingService.hooks.endFrame.tap(HTMLRenderingPlugin2.tag, function() {
          if (_this.$camera && renderingContext.renderReasons.has(RenderReason.CAMERA_CHANGED)) {
            _this.$camera.style.transform = _this.joinTransformMatrix(camera.getOrthoMatrix());
          }
        });
        renderingService.hooks.destroy.tap(HTMLRenderingPlugin2.tag, function() {
          if (_this.$camera) {
            _this.$camera.remove();
          }
          canvas.removeEventListener(CanvasEvent.RESIZE, handleCanvasResize);
          canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas.removeEventListener(ElementEvent.UNMOUNTED, handleUnmounted);
          canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
          canvas.removeEventListener(ElementEvent.BOUNDS_CHANGED, handleBoundsChanged);
        });
      };
      HTMLRenderingPlugin2.prototype.createCamera = function(camera) {
        var _a = this.context.config, doc = _a.document, width = _a.width, height = _a.height;
        var $canvas = this.context.contextService.getDomElement();
        var $container = $canvas.parentNode;
        if ($container) {
          var cameraId = CANVAS_CAMERA_ID;
          var $existedCamera = $container.querySelector("#" + cameraId);
          if (!$existedCamera) {
            var $camera = (doc || document).createElement("div");
            $existedCamera = $camera;
            $camera.id = cameraId;
            $camera.style.position = "absolute";
            $camera.style.left = "".concat($canvas.offsetLeft || 0, "px");
            $camera.style.top = "".concat($canvas.offsetTop || 0, "px");
            $camera.style.transformOrigin = "left top";
            $camera.style.transform = this.joinTransformMatrix(camera.getOrthoMatrix());
            $camera.style.overflow = "hidden";
            $camera.style.pointerEvents = "none";
            $camera.style.width = "".concat(width || 0, "px");
            $camera.style.height = "".concat(height || 0, "px");
            $container.appendChild($camera);
          }
          return $existedCamera;
        }
        return null;
      };
      HTMLRenderingPlugin2.prototype.getOrCreateEl = function(object) {
        var doc = this.context.config.document;
        var $existedElement = this.displayObjectHTMLElementMap.get(object);
        if (!$existedElement) {
          $existedElement = (doc || document).createElement("div");
          object.parsedStyle.$el = $existedElement;
          this.displayObjectHTMLElementMap.set(object, $existedElement);
          if (object.id) {
            $existedElement.id = object.id;
          }
          if (object.name) {
            $existedElement.setAttribute("name", object.name);
          }
          if (object.className) {
            $existedElement.className = object.className;
          }
          $existedElement.style.position = "absolute";
          $existedElement.style["will-change"] = "transform";
          $existedElement.style.transform = this.joinTransformMatrix(object.getWorldTransform());
        }
        return $existedElement;
      };
      HTMLRenderingPlugin2.prototype.updateAttribute = function(name2, object) {
        var $el = this.getOrCreateEl(object);
        switch (name2) {
          case "innerHTML":
            var innerHTML = object.parsedStyle.innerHTML;
            if (is_string_default6(innerHTML)) {
              $el.innerHTML = innerHTML;
            } else {
              $el.innerHTML = "";
              $el.appendChild(innerHTML);
            }
            break;
          case "x":
            $el.style.left = "".concat(object.parsedStyle.x, "px");
            break;
          case "y":
            $el.style.top = "".concat(object.parsedStyle.y, "px");
            break;
          case "transformOrigin":
            var transformOrigin = object.parsedStyle.transformOrigin;
            $el.style["transform-origin"] = "".concat(transformOrigin[0].value, " ").concat(transformOrigin[1].value);
            break;
          case "width":
            if (this.context.enableCSSParsing) {
              var width = object.computedStyleMap().get("width");
              $el.style.width = width.toString();
            } else {
              var width = object.parsedStyle.width;
              $el.style.width = is_number_default6(width) ? "".concat(width, "px") : width.toString();
            }
            break;
          case "height":
            if (this.context.enableCSSParsing) {
              var height = object.computedStyleMap().get("height");
              $el.style.height = height.toString();
            } else {
              var height = object.parsedStyle.height;
              $el.style.height = is_number_default6(height) ? "".concat(height, "px") : height.toString();
            }
            break;
          case "zIndex":
            var zIndex = object.parsedStyle.zIndex;
            $el.style["z-index"] = "".concat(zIndex);
            break;
          case "visibility":
            var visibility2 = object.parsedStyle.visibility;
            $el.style.visibility = visibility2;
            break;
          case "pointerEvents":
            var _a = object.parsedStyle.pointerEvents, pointerEvents = _a === void 0 ? "auto" : _a;
            $el.style.pointerEvents = pointerEvents;
            break;
          case "opacity":
            var opacity = object.parsedStyle.opacity;
            $el.style.opacity = "".concat(opacity);
            break;
          case "fill":
            var fill = object.parsedStyle.fill;
            var color2 = "";
            if (isCSSRGB(fill)) {
              if (fill.isNone) {
                color2 = "transparent";
              } else {
                color2 = object.getAttribute("fill");
              }
            } else if (Array.isArray(fill)) {
              color2 = object.getAttribute("fill");
            } else if (isPattern(fill)) ;
            $el.style.background = color2;
            break;
          case "stroke":
            var stroke2 = object.parsedStyle.stroke;
            var borderColor = "";
            if (isCSSRGB(stroke2)) {
              if (stroke2.isNone) {
                borderColor = "transparent";
              } else {
                borderColor = object.getAttribute("stroke");
              }
            } else if (Array.isArray(stroke2)) {
              borderColor = object.getAttribute("stroke");
            } else if (isPattern(stroke2)) ;
            $el.style["border-color"] = borderColor;
            $el.style["border-style"] = "solid";
            break;
          case "lineWidth":
            var lineWidth = object.parsedStyle.lineWidth;
            $el.style["border-width"] = "".concat(lineWidth || 0, "px");
            break;
          case "lineDash":
            $el.style["border-style"] = "dashed";
            break;
          case "filter":
            var filter2 = object.style.filter;
            $el.style.filter = filter2;
            break;
          default:
            if (!is_nil_default6(object.style[name2]) && object.style[name2] !== "") {
              $el.style[name2] = object.style[name2];
            }
        }
      };
      HTMLRenderingPlugin2.tag = "HTMLRendering";
      return HTMLRenderingPlugin2;
    }()
  );
  var Plugin5 = (
    /** @class */
    function(_super) {
      __extends(Plugin8, _super);
      function Plugin8() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this.name = "html-renderer";
        return _this;
      }
      Plugin8.prototype.init = function() {
        this.addRenderingPlugin(new HTMLRenderingPlugin());
      };
      Plugin8.prototype.destroy = function() {
        this.removeAllRenderingPlugins();
      };
      return Plugin8;
    }(AbstractRendererPlugin)
  );

  // ../../engine/rails_design/node_modules/@antv/g-plugin-image-loader/node_modules/@antv/util/esm/lodash/is-type.js
  var toString8 = {}.toString;
  var isType8 = function(value2, type) {
    return toString8.call(value2) === "[object " + type + "]";
  };
  var is_type_default8 = isType8;

  // ../../engine/rails_design/node_modules/@antv/g-plugin-image-loader/node_modules/@antv/util/esm/lodash/is-string.js
  var is_string_default7 = function(str7) {
    return is_type_default8(str7, "String");
  };

  // ../../engine/rails_design/node_modules/@antv/g-plugin-image-loader/dist/index.esm.js
  var ImagePool = (
    /** @class */
    function() {
      function ImagePool2(canvasConfig) {
        this.canvasConfig = canvasConfig;
        this.imageCache = {};
        this.gradientCache = {};
        this.patternCache = {};
      }
      ImagePool2.prototype.getImageSync = function(src, callback) {
        if (!this.imageCache[src]) {
          this.getOrCreateImage(src).then(function(img) {
            if (callback) {
              callback(img);
            }
          });
        } else {
          if (callback) {
            callback(this.imageCache[src]);
          }
        }
        return this.imageCache[src];
      };
      ImagePool2.prototype.getOrCreateImage = function(src) {
        var _this = this;
        if (this.imageCache[src]) {
          return Promise.resolve(this.imageCache[src]);
        }
        var createImage = this.canvasConfig.createImage;
        return new Promise(function(resolve, reject) {
          var image;
          if (createImage) {
            image = createImage(src);
          } else if (isBrowser) {
            image = new window.Image();
          }
          if (image) {
            image.onload = function() {
              _this.imageCache[src] = image;
              resolve(image);
            };
            image.onerror = function(ev) {
              reject(ev);
            };
            image.crossOrigin = "Anonymous";
            image.src = src;
          }
        });
      };
      ImagePool2.prototype.getOrCreatePatternSync = function(pattern, context, $offscreenCanvas, dpr, min10, callback) {
        var patternKey = this.generatePatternKey(pattern);
        if (patternKey && this.patternCache[patternKey]) {
          return this.patternCache[patternKey];
        }
        var image = pattern.image, repetition = pattern.repetition, transform = pattern.transform;
        var src;
        var needScaleWithDPR = false;
        if (is_string_default7(image)) {
          src = this.getImageSync(image, callback);
        } else if ($offscreenCanvas) {
          src = $offscreenCanvas;
          needScaleWithDPR = true;
        } else {
          src = image;
        }
        var canvasPattern = src && context.createPattern(src, repetition);
        if (canvasPattern) {
          var mat = void 0;
          if (transform) {
            mat = parsedTransformToMat4(parseTransform(transform), new DisplayObject({}));
          } else {
            mat = mat4_exports.identity(mat4_exports.create());
          }
          if (needScaleWithDPR) {
            mat4_exports.scale(mat, mat, [1 / dpr, 1 / dpr, 1]);
          }
          canvasPattern.setTransform({
            a: mat[0],
            b: mat[1],
            c: mat[4],
            d: mat[5],
            e: mat[12] + min10[0],
            f: mat[13] + min10[1]
          });
        }
        if (patternKey && canvasPattern) {
          this.patternCache[patternKey] = canvasPattern;
        }
        return canvasPattern;
      };
      ImagePool2.prototype.getOrCreateGradient = function(params, context) {
        var key = this.generateGradientKey(params);
        var type = params.type, steps = params.steps, min10 = params.min, width = params.width, height = params.height, angle4 = params.angle, cx = params.cx, cy = params.cy, size2 = params.size;
        if (this.gradientCache[key]) {
          return this.gradientCache[key];
        }
        var gradient = null;
        if (type === GradientType.LinearGradient) {
          var _a = computeLinearGradient(min10, width, height, angle4), x12 = _a.x1, y12 = _a.y1, x22 = _a.x2, y22 = _a.y2;
          gradient = context.createLinearGradient(x12, y12, x22, y22);
        } else if (type === GradientType.RadialGradient) {
          var _b = computeRadialGradient(min10, width, height, cx, cy, size2), x3 = _b.x, y3 = _b.y, r = _b.r;
          gradient = context.createRadialGradient(x3, y3, 0, x3, y3, r);
        }
        if (gradient) {
          steps.forEach(function(_a2) {
            var offset3 = _a2.offset, color2 = _a2.color;
            if (offset3.unit === UnitType.kPercentage) {
              gradient === null || gradient === void 0 ? void 0 : gradient.addColorStop(offset3.value / 100, color2.toString());
            }
          });
          this.gradientCache[key] = gradient;
        }
        return this.gradientCache[key];
      };
      ImagePool2.prototype.generateGradientKey = function(params) {
        var type = params.type, min10 = params.min, width = params.width, height = params.height, steps = params.steps, angle4 = params.angle, cx = params.cx, cy = params.cy, size2 = params.size;
        return "gradient-".concat(type, "-").concat((angle4 === null || angle4 === void 0 ? void 0 : angle4.toString()) || 0, "-").concat((cx === null || cx === void 0 ? void 0 : cx.toString()) || 0, "-").concat((cy === null || cy === void 0 ? void 0 : cy.toString()) || 0, "-").concat((size2 === null || size2 === void 0 ? void 0 : size2.toString()) || 0, "-").concat(min10[0], "-").concat(min10[1], "-").concat(width, "-").concat(height, "-").concat(steps.map(function(_a) {
          var offset3 = _a.offset, color2 = _a.color;
          return "".concat(offset3).concat(color2);
        }).join("-"));
      };
      ImagePool2.prototype.generatePatternKey = function(pattern) {
        var image = pattern.image, repetition = pattern.repetition;
        if (is_string_default7(image)) {
          return "pattern-".concat(image, "-").concat(repetition);
        } else if (image.nodeName === "rect") {
          return "pattern-".concat(image.entity, "-").concat(repetition);
        }
      };
      return ImagePool2;
    }()
  );
  var LoadImagePlugin = (
    /** @class */
    function() {
      function LoadImagePlugin2() {
      }
      LoadImagePlugin2.prototype.apply = function(context) {
        var renderingService = context.renderingService, renderingContext = context.renderingContext, imagePool = context.imagePool;
        var canvas = renderingContext.root.ownerDocument.defaultView;
        var calculateWithAspectRatio = function(object, imageWidth, imageHeight) {
          var _a = object.parsedStyle, width = _a.width, height = _a.height;
          if (width && !height) {
            object.setAttribute("height", imageHeight / imageWidth * width);
          } else if (!width && height) {
            object.setAttribute("width", imageWidth / imageHeight * height);
          }
        };
        var handleMounted = function(e3) {
          var object = e3.target;
          var nodeName = object.nodeName, attributes = object.attributes;
          if (nodeName === Shape.IMAGE) {
            var src = attributes.src, keepAspectRatio_1 = attributes.keepAspectRatio;
            if (is_string_default7(src)) {
              imagePool.getImageSync(src, function(_a) {
                var width = _a.width, height = _a.height;
                if (keepAspectRatio_1) {
                  calculateWithAspectRatio(object, width, height);
                }
                object.renderable.dirty = true;
                renderingService.dirtify();
              });
            }
          }
        };
        var handleAttributeChanged = function(e3) {
          var object = e3.target;
          var attrName = e3.attrName, newValue = e3.newValue;
          if (object.nodeName === Shape.IMAGE) {
            if (attrName === "src") {
              if (is_string_default7(newValue)) {
                imagePool.getOrCreateImage(newValue).then(function(_a) {
                  var width = _a.width, height = _a.height;
                  if (object.attributes.keepAspectRatio) {
                    calculateWithAspectRatio(object, width, height);
                  }
                  object.renderable.dirty = true;
                  renderingService.dirtify();
                });
              }
            }
          }
        };
        renderingService.hooks.init.tap(LoadImagePlugin2.tag, function() {
          canvas.addEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas.addEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        });
        renderingService.hooks.destroy.tap(LoadImagePlugin2.tag, function() {
          canvas.removeEventListener(ElementEvent.MOUNTED, handleMounted);
          canvas.removeEventListener(ElementEvent.ATTR_MODIFIED, handleAttributeChanged);
        });
      };
      LoadImagePlugin2.tag = "LoadImage";
      return LoadImagePlugin2;
    }()
  );
  var Plugin6 = (
    /** @class */
    function(_super) {
      __extends(Plugin8, _super);
      function Plugin8() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this.name = "image-loader";
        return _this;
      }
      Plugin8.prototype.init = function() {
        this.context.imagePool = new ImagePool(this.context.config);
        this.addRenderingPlugin(new LoadImagePlugin());
      };
      Plugin8.prototype.destroy = function() {
        this.removeAllRenderingPlugins();
      };
      return Plugin8;
    }(AbstractRendererPlugin)
  );

  // ../../engine/rails_design/node_modules/@antv/g-canvas/node_modules/@antv/util/esm/lodash/is-type.js
  var toString9 = {}.toString;
  var isType9 = function(value2, type) {
    return toString9.call(value2) === "[object " + type + "]";
  };
  var is_type_default9 = isType9;

  // ../../engine/rails_design/node_modules/@antv/g-canvas/node_modules/@antv/util/esm/lodash/is-string.js
  var is_string_default8 = function(str7) {
    return is_type_default9(str7, "String");
  };

  // ../../engine/rails_design/node_modules/@antv/g-canvas/dist/index.esm.js
  var Canvas2DContextService = (
    /** @class */
    function() {
      function Canvas2DContextService2(context) {
        this.renderingContext = context.renderingContext;
        this.canvasConfig = context.config;
      }
      Canvas2DContextService2.prototype.init = function() {
        var _a = this.canvasConfig, container = _a.container, canvas = _a.canvas;
        if (canvas) {
          this.$canvas = canvas;
          if (container && canvas.parentElement !== container) {
            container.appendChild(canvas);
          }
          this.$container = canvas.parentElement;
          this.canvasConfig.container = this.$container;
        } else if (container) {
          this.$container = is_string_default8(container) ? document.getElementById(container) : container;
          if (this.$container) {
            var $canvas = document.createElement("canvas");
            this.$container.appendChild($canvas);
            if (!this.$container.style.position) {
              this.$container.style.position = "relative";
            }
            this.$canvas = $canvas;
          }
        }
        this.context = this.$canvas.getContext("2d");
        this.resize(this.canvasConfig.width, this.canvasConfig.height);
      };
      Canvas2DContextService2.prototype.getContext = function() {
        return this.context;
      };
      Canvas2DContextService2.prototype.getDomElement = function() {
        return this.$canvas;
      };
      Canvas2DContextService2.prototype.getDPR = function() {
        return this.dpr;
      };
      Canvas2DContextService2.prototype.getBoundingClientRect = function() {
        if (this.$canvas.getBoundingClientRect) {
          return this.$canvas.getBoundingClientRect();
        }
      };
      Canvas2DContextService2.prototype.destroy = function() {
        if (this.$container && this.$canvas && this.$canvas.parentNode) {
          this.$container.removeChild(this.$canvas);
        }
      };
      Canvas2DContextService2.prototype.resize = function(width, height) {
        var devicePixelRatio = this.canvasConfig.devicePixelRatio;
        var dpr = devicePixelRatio || isBrowser && window.devicePixelRatio || 1;
        dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
        this.dpr = dpr;
        if (this.$canvas) {
          this.$canvas.width = this.dpr * width;
          this.$canvas.height = this.dpr * height;
          setDOMSize(this.$canvas, width, height);
        }
        this.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
      };
      Canvas2DContextService2.prototype.applyCursorStyle = function(cursor) {
        if (this.$container && this.$container.style) {
          this.$container.style.cursor = cursor;
        }
      };
      Canvas2DContextService2.prototype.toDataURL = function(options) {
        if (options === void 0) {
          options = {};
        }
        return __awaiter(this, void 0, void 0, function() {
          var type, encoderOptions;
          return __generator(this, function(_a) {
            type = options.type, encoderOptions = options.encoderOptions;
            return [2, this.context.canvas.toDataURL(type, encoderOptions)];
          });
        });
      };
      return Canvas2DContextService2;
    }()
  );
  var ContextRegisterPlugin = (
    /** @class */
    function(_super) {
      __extends(ContextRegisterPlugin2, _super);
      function ContextRegisterPlugin2() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this.name = "canvas-context-register";
        return _this;
      }
      ContextRegisterPlugin2.prototype.init = function() {
        this.context.ContextService = Canvas2DContextService;
      };
      ContextRegisterPlugin2.prototype.destroy = function() {
        delete this.context.ContextService;
      };
      return ContextRegisterPlugin2;
    }(AbstractRendererPlugin)
  );
  var Renderer2 = (
    /** @class */
    function(_super) {
      __extends(Renderer3, _super);
      function Renderer3(config2) {
        var _this = _super.call(this, config2) || this;
        _this.registerPlugin(new ContextRegisterPlugin());
        _this.registerPlugin(new Plugin6());
        _this.registerPlugin(new Plugin());
        _this.registerPlugin(new Plugin3());
        _this.registerPlugin(new Plugin4());
        _this.registerPlugin(new Plugin2());
        _this.registerPlugin(new Plugin5());
        return _this;
      }
      return Renderer3;
    }(AbstractRenderer)
  );

  // ../../engine/rails_design/node_modules/@antv/g-plugin-dragndrop/node_modules/@antv/util/esm/path/util/distance-square-root.js
  function distanceSquareRoot2(a3, b) {
    return Math.sqrt((a3[0] - b[0]) * (a3[0] - b[0]) + (a3[1] - b[1]) * (a3[1] - b[1]));
  }

  // ../../engine/rails_design/node_modules/@antv/g-plugin-dragndrop/dist/index.esm.js
  var DragndropPlugin = (
    /** @class */
    function() {
      function DragndropPlugin2(dragndropPluginOptions) {
        this.dragndropPluginOptions = dragndropPluginOptions;
      }
      DragndropPlugin2.prototype.apply = function(context) {
        var _this = this;
        var renderingService = context.renderingService, renderingContext = context.renderingContext;
        var document2 = renderingContext.root.ownerDocument;
        var canvas = document2.defaultView;
        var handlePointerdown = function(event) {
          var target = event.target;
          var isDocument = target === document2;
          var draggableEventTarget = isDocument && _this.dragndropPluginOptions.isDocumentDraggable ? document2 : target.closest && target.closest("[draggable=true]");
          if (draggableEventTarget) {
            var dragstartTriggered_1 = false;
            var dragstartTimeStamp_1 = event.timeStamp;
            var dragstartClientCoordinates_1 = [
              event.clientX,
              event.clientY
            ];
            var currentDroppable_1 = null;
            var lastDragClientCoordinates_1 = [event.clientX, event.clientY];
            var handlePointermove_1 = function(event2) {
              return __awaiter(_this, void 0, void 0, function() {
                var timeElapsed, distanceMoved, point6, elementsBelow, elementBelow, droppableBelow;
                return __generator(this, function(_a) {
                  switch (_a.label) {
                    case 0:
                      if (!dragstartTriggered_1) {
                        timeElapsed = event2.timeStamp - dragstartTimeStamp_1;
                        distanceMoved = distanceSquareRoot2([event2.clientX, event2.clientY], dragstartClientCoordinates_1);
                        if (timeElapsed <= this.dragndropPluginOptions.dragstartTimeThreshold || distanceMoved <= this.dragndropPluginOptions.dragstartDistanceThreshold) {
                          return [
                            2
                            /*return*/
                          ];
                        }
                        event2.type = "dragstart";
                        draggableEventTarget.dispatchEvent(event2);
                        dragstartTriggered_1 = true;
                      }
                      event2.type = "drag";
                      event2.dx = event2.clientX - lastDragClientCoordinates_1[0];
                      event2.dy = event2.clientY - lastDragClientCoordinates_1[1];
                      draggableEventTarget.dispatchEvent(event2);
                      lastDragClientCoordinates_1 = [event2.clientX, event2.clientY];
                      if (!!isDocument) return [3, 2];
                      point6 = this.dragndropPluginOptions.overlap === "pointer" ? [event2.canvasX, event2.canvasY] : target.getBounds().center;
                      return [4, document2.elementsFromPoint(point6[0], point6[1])];
                    case 1:
                      elementsBelow = _a.sent();
                      elementBelow = elementsBelow[elementsBelow.indexOf(target) + 1];
                      droppableBelow = (elementBelow === null || elementBelow === void 0 ? void 0 : elementBelow.closest("[droppable=true]")) || (this.dragndropPluginOptions.isDocumentDroppable ? document2 : null);
                      if (currentDroppable_1 !== droppableBelow) {
                        if (currentDroppable_1) {
                          event2.type = "dragleave";
                          event2.target = currentDroppable_1;
                          currentDroppable_1.dispatchEvent(event2);
                        }
                        if (droppableBelow) {
                          event2.type = "dragenter";
                          event2.target = droppableBelow;
                          droppableBelow.dispatchEvent(event2);
                        }
                        currentDroppable_1 = droppableBelow;
                        if (currentDroppable_1) {
                          event2.type = "dragover";
                          event2.target = currentDroppable_1;
                          currentDroppable_1.dispatchEvent(event2);
                        }
                      }
                      _a.label = 2;
                    case 2:
                      return [
                        2
                        /*return*/
                      ];
                  }
                });
              });
            };
            canvas.addEventListener("pointermove", handlePointermove_1);
            var stopDragging = function(originalPointerUpEvent) {
              if (dragstartTriggered_1) {
                originalPointerUpEvent.detail = {
                  preventClick: true
                };
                var event_1 = originalPointerUpEvent.clone();
                if (currentDroppable_1) {
                  event_1.type = "drop";
                  event_1.target = currentDroppable_1;
                  currentDroppable_1.dispatchEvent(event_1);
                }
                event_1.type = "dragend";
                draggableEventTarget.dispatchEvent(event_1);
                dragstartTriggered_1 = false;
              }
              canvas.removeEventListener("pointermove", handlePointermove_1);
            };
            target.addEventListener("pointerup", stopDragging, { once: true });
            target.addEventListener("pointerupoutside", stopDragging, {
              once: true
            });
          }
        };
        renderingService.hooks.init.tap(DragndropPlugin2.tag, function() {
          canvas.addEventListener("pointerdown", handlePointerdown);
        });
        renderingService.hooks.destroy.tap(DragndropPlugin2.tag, function() {
          canvas.removeEventListener("pointerdown", handlePointerdown);
        });
      };
      DragndropPlugin2.tag = "Dragndrop";
      return DragndropPlugin2;
    }()
  );
  var Plugin7 = (
    /** @class */
    function(_super) {
      __extends(Plugin8, _super);
      function Plugin8(options) {
        if (options === void 0) {
          options = {};
        }
        var _this = _super.call(this) || this;
        _this.options = options;
        _this.name = "dragndrop";
        return _this;
      }
      Plugin8.prototype.init = function() {
        this.addRenderingPlugin(new DragndropPlugin(__assign({ overlap: "pointer", isDocumentDraggable: false, isDocumentDroppable: false, dragstartDistanceThreshold: 0, dragstartTimeThreshold: 0 }, this.options)));
      };
      Plugin8.prototype.destroy = function() {
        this.removeAllRenderingPlugins();
      };
      Plugin8.prototype.setOptions = function(options) {
        Object.assign(this.plugins[0].dragndropPluginOptions, options);
      };
      return Plugin8;
    }(AbstractRendererPlugin)
  );

  // ../../engine/rails_design/node_modules/@antv/event-emitter/esm/index.js
  var WILDCARD = "*";
  var EventEmitter2 = (
    /** @class */
    function() {
      function EventEmitter3() {
        this._events = {};
      }
      EventEmitter3.prototype.on = function(evt, callback, once) {
        if (!this._events[evt]) {
          this._events[evt] = [];
        }
        this._events[evt].push({
          callback,
          once: !!once
        });
        return this;
      };
      EventEmitter3.prototype.once = function(evt, callback) {
        return this.on(evt, callback, true);
      };
      EventEmitter3.prototype.emit = function(evt) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }
        var events = this._events[evt] || [];
        var wildcardEvents = this._events[WILDCARD] || [];
        var doEmit = function(es) {
          var length5 = es.length;
          for (var i = 0; i < length5; i++) {
            if (!es[i]) {
              continue;
            }
            var _a = es[i], callback = _a.callback, once = _a.once;
            if (once) {
              es.splice(i, 1);
              if (es.length === 0) {
                delete _this._events[evt];
              }
              length5--;
              i--;
            }
            callback.apply(_this, args);
          }
        };
        doEmit(events);
        doEmit(wildcardEvents);
      };
      EventEmitter3.prototype.off = function(evt, callback) {
        if (!evt) {
          this._events = {};
        } else {
          if (!callback) {
            delete this._events[evt];
          } else {
            var events = this._events[evt] || [];
            var length_1 = events.length;
            for (var i = 0; i < length_1; i++) {
              if (events[i].callback === callback) {
                events.splice(i, 1);
                length_1--;
                i--;
              }
            }
            if (events.length === 0) {
              delete this._events[evt];
            }
          }
        }
        return this;
      };
      EventEmitter3.prototype.getEvents = function() {
        return this._events;
      };
      return EventEmitter3;
    }()
  );
  var esm_default = EventEmitter2;

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/event.js
  var ChartEvent = {
    BEFORE_RENDER: "beforerender",
    AFTER_RENDER: "afterrender",
    BEFORE_PAINT: "beforepaint",
    AFTER_PAINT: "afterpaint",
    BEFORE_CHANGE_DATA: "beforechangedata",
    AFTER_CHANGE_DATA: "afterchangedata",
    BEFORE_CLEAR: "beforeclear",
    AFTER_CLEAR: "afterclear",
    BEFORE_DESTROY: "beforedestroy",
    AFTER_DESTROY: "afterdestroy",
    BEFORE_CHANGE_SIZE: "beforechangesize",
    AFTER_CHANGE_SIZE: "afterchangesize",
    POINTER_TAP: "pointertap",
    POINTER_DOWN: "pointerdown",
    POINTER_UP: "pointerup",
    POINTER_OVER: "pointerover",
    POINTER_OUT: "pointerout",
    POINTER_MOVE: "pointermove",
    POINTER_ENTER: "pointerenter",
    POINTER_LEAVE: "pointerleave",
    POINTER_UPOUTSIDE: "pointerupoutside",
    DRAG_START: "dragstart",
    DRAG: "drag",
    DRAG_END: "dragend",
    DRAG_ENTER: "dragenter",
    DRAG_LEAVE: "dragleave",
    DRAG_OVER: "dragover",
    DROP: "DROP",
    CLICK: "click",
    DBLCLICK: "dblclick"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/component/constant.js
  var LEGEND_INFER_STRATEGIES = [
    [
      "legendCategory",
      [
        [
          ["color", "discrete"],
          ["opacity", "discrete"],
          ["shape", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "constant"],
          ["shape", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "discrete"],
          ["shape", "constant"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "constant"],
          ["shape", "constant"],
          ["size", "constant"]
        ],
        [
          ["color", "constant"],
          ["opacity", "discrete"],
          ["shape", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "constant"],
          ["opacity", "constant"],
          ["shape", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "constant"],
          ["opacity", "discrete"],
          ["shape", "constant"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["shape", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "discrete"],
          ["shape", "discrete"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "constant"],
          ["shape", "discrete"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "constant"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["shape", "constant"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "discrete"],
          ["shape", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "constant"],
          ["shape", "constant"]
        ],
        [
          ["color", "constant"],
          ["shape", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "constant"],
          ["opacity", "discrete"],
          ["shape", "discrete"]
        ],
        [
          ["color", "constant"],
          ["opacity", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "constant"],
          ["opacity", "constant"],
          ["shape", "discrete"]
        ],
        // [
        //   ['color', 'constant'],
        //   ['opacity', 'constant'],
        //   ['size', 'constant'],
        // ],
        // [
        //   ['color', 'constant'],
        //   ['shape', 'constant'],
        //   ['size', 'constant'],
        // ],
        [
          ["color", "constant"],
          ["opacity", "discrete"],
          ["shape", "constant"]
        ],
        [
          ["color", "discrete"],
          ["shape", "discrete"]
        ],
        [
          ["color", "discrete"],
          ["size", "constant"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "discrete"]
        ],
        [
          ["color", "discrete"],
          ["opacity", "constant"]
        ],
        [
          ["color", "discrete"],
          ["shape", "constant"]
        ],
        [
          ["color", "constant"],
          ["shape", "discrete"]
        ],
        [
          ["color", "constant"],
          ["size", "constant"]
        ],
        [
          ["color", "constant"],
          ["opacity", "discrete"]
        ],
        // [
        //   ['color', 'constant'],
        //   ['opacity', 'constant'],
        // ],
        // [
        //   ['color', 'constant'],
        //   ['shape', 'constant'],
        // ],
        [["color", "discrete"]]
        // [['color', 'constant']],
      ]
    ],
    [
      "legendContinuousSize",
      [
        [
          ["color", "continuous"],
          ["opacity", "continuous"],
          ["size", "continuous"]
        ],
        [
          ["color", "constant"],
          ["opacity", "continuous"],
          ["size", "continuous"]
        ],
        [
          ["color", "continuous"],
          ["size", "continuous"]
        ],
        [
          ["color", "constant"],
          ["size", "continuous"]
        ],
        [
          ["size", "continuous"],
          ["opacity", "continuous"]
        ],
        [["size", "continuous"]]
      ]
    ],
    [
      "legendContinuousBlockSize",
      [
        [
          ["color", "distribution"],
          ["opacity", "distribution"],
          ["size", "distribution"]
        ],
        [
          ["color", "distribution"],
          ["size", "distribution"]
        ]
      ]
    ],
    [
      "legendContinuousBlock",
      [
        [
          ["color", "distribution"],
          ["opacity", "continuous"]
        ],
        [["color", "distribution"]]
      ]
    ],
    [
      "legendContinuous",
      [
        [
          ["color", "continuous"],
          ["opacity", "continuous"]
        ],
        [["color", "continuous"]],
        [["opacity", "continuous"]]
      ]
    ]
  ];

  // ../../engine/rails_design/node_modules/@antv/g2/esm/runtime/coordinate.js
  var import_coord = __toESM(require_coordinate_min());

  // ../../engine/rails_design/node_modules/@antv/g2/esm/composition/utils.js
  var __rest61 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function useDefaultAdaptor(adaptor2) {
    return (options, ...rest) => deep_mix_default({}, adaptor2(options, ...rest), options);
  }
  function useOverrideAdaptor(adaptor2) {
    return (options, ...rest) => deep_mix_default({}, options, adaptor2(options, ...rest));
  }
  function isObject2(d2) {
    if (d2 instanceof Date)
      return false;
    return typeof d2 === "object";
  }
  function mergeData(dataDescriptor, dataValue) {
    if (!dataDescriptor)
      return dataValue;
    if (Array.isArray(dataDescriptor))
      return dataDescriptor;
    if (isObject2(dataDescriptor)) {
      const { value: value2 = dataValue } = dataDescriptor, rest = __rest61(dataDescriptor, ["value"]);
      return Object.assign(Object.assign({}, rest), { value: value2 });
    }
    return dataDescriptor;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/composition/spaceLayer.js
  var __rest62 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var SpaceLayer = () => {
    return (options) => {
      const { children } = options;
      if (!Array.isArray(children))
        return [];
      const { x: viewX = 0, y: viewY = 0, width: viewWidth, height: viewHeight, data: layerData } = options;
      return children.map((_a) => {
        var { data: data2, x: x3, y: y3, width, height } = _a, rest = __rest62(_a, ["data", "x", "y", "width", "height"]);
        return Object.assign(Object.assign({}, rest), { data: mergeData(data2, layerData), x: x3 !== null && x3 !== void 0 ? x3 : viewX, y: y3 !== null && y3 !== void 0 ? y3 : viewY, width: width !== null && width !== void 0 ? width : viewWidth, height: height !== null && height !== void 0 ? height : viewHeight });
      });
    };
  };
  SpaceLayer.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/composition/spaceFlex.js
  var __rest63 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var SpaceFlex = () => {
    return (options) => {
      const { children } = options;
      if (!Array.isArray(children))
        return [];
      const { direction: direction2 = "row", ratio = children.map(() => 1), padding = 0, data: flexData } = options;
      const [mainStart, mainSize, crossSize, crossStart] = direction2 === "col" ? ["y", "height", "width", "x"] : ["x", "width", "height", "y"];
      const sum3 = ratio.reduce((total, value2) => total + value2);
      const totalSize = options[mainSize] - padding * (children.length - 1);
      const sizes = ratio.map((value2) => totalSize * (value2 / sum3));
      const newChildren = [];
      let next = options[mainStart] || 0;
      for (let i = 0; i < sizes.length; i += 1) {
        const _a = children[i], { data: data2 } = _a, rest = __rest63(_a, ["data"]);
        const newData = mergeData(data2, flexData);
        newChildren.push(Object.assign({ [mainStart]: next, [mainSize]: sizes[i], [crossStart]: options[crossStart] || 0, [crossSize]: options[crossSize], data: newData }, rest));
        next += sizes[i] + padding;
      }
      return newChildren;
    };
  };
  SpaceFlex.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/composition/view.js
  var __rest64 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var View2 = () => {
    return (options) => {
      const { children } = options, restOptions = __rest64(options, ["children"]);
      if (!Array.isArray(children))
        return [];
      const { data: viewData, scale: viewScale = {}, axis: viewAxis = {}, legend: viewLegend = {}, encode: viewEncode = {}, transform: viewTransform = [] } = restOptions, rest = __rest64(restOptions, ["data", "scale", "axis", "legend", "encode", "transform"]);
      const marks = children.map((_a) => {
        var { data: data2, scale: scale9 = {}, axis = {}, legend = {}, encode = {}, transform = [] } = _a, rest2 = __rest64(_a, ["data", "scale", "axis", "legend", "encode", "transform"]);
        return Object.assign({ data: mergeData(data2, viewData), scale: deep_mix_default({}, viewScale, scale9), encode: deep_mix_default({}, viewEncode, encode), transform: [...viewTransform, ...transform], axis: axis && viewAxis ? deep_mix_default({}, viewAxis, axis) : false, legend: legend && viewLegend ? deep_mix_default({}, viewLegend, legend) : false }, rest2);
      });
      return [Object.assign(Object.assign({}, rest), { marks, type: "standardView" })];
    };
  };
  View2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/composition/mark.js
  var __rest65 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var Mark = ({ static: isStatic = false } = {}) => {
    return (options) => {
      const { width, height, depth, paddingLeft, paddingRight, paddingTop, paddingBottom, padding, inset, insetLeft, insetTop, insetRight, insetBottom, margin, marginLeft, marginBottom, marginTop, marginRight, data: data2, coordinate, theme, component, interaction, x: x3, y: y3, z, key, frame: frame2, labelTransform, parentKey, clip, viewStyle, title } = options, mark = __rest65(options, ["width", "height", "depth", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "padding", "inset", "insetLeft", "insetTop", "insetRight", "insetBottom", "margin", "marginLeft", "marginBottom", "marginTop", "marginRight", "data", "coordinate", "theme", "component", "interaction", "x", "y", "z", "key", "frame", "labelTransform", "parentKey", "clip", "viewStyle", "title"]);
      return [
        Object.assign(Object.assign({
          type: "standardView",
          x: x3,
          y: y3,
          z,
          key,
          width,
          height,
          depth,
          padding,
          paddingLeft,
          paddingRight,
          paddingTop,
          inset,
          insetLeft,
          insetTop,
          insetRight,
          insetBottom,
          paddingBottom,
          theme,
          coordinate,
          component,
          interaction,
          frame: frame2,
          labelTransform,
          margin,
          marginLeft,
          marginBottom,
          marginTop,
          marginRight,
          parentKey,
          clip,
          style: viewStyle
        }, !isStatic && { title }), { marks: [Object.assign(Object.assign(Object.assign({}, mark), { key: `${key}-0`, data: data2 }), isStatic && { title })] })
      ];
    };
  };
  Mark.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/container.js
  var Container = class _Container {
    constructor(x3) {
      this.$value = x3;
    }
    static of(x3) {
      return new _Container(x3);
    }
    call(f, ...rest) {
      return this.$value = f(this.$value, ...rest), this;
    }
    value() {
      return this.$value;
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/composition/facetRect.js
  var __rest66 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var setScale = useDefaultAdaptor((options) => {
    const { encode, data: data2, scale: scale9, shareSize = false } = options;
    const { x: x3, y: y3 } = encode;
    const flexDomain = (encode2, channel) => {
      var _a;
      if (encode2 === void 0 || !shareSize)
        return {};
      const groups2 = group(data2, (d2) => d2[encode2]);
      const domain = ((_a = scale9 === null || scale9 === void 0 ? void 0 : scale9[channel]) === null || _a === void 0 ? void 0 : _a.domain) || Array.from(groups2.keys());
      const flex2 = domain.map((key) => {
        if (!groups2.has(key))
          return 1;
        return groups2.get(key).length;
      });
      return { domain, flex: flex2 };
    };
    return {
      scale: {
        x: Object.assign(Object.assign({ paddingOuter: 0, paddingInner: 0.1, guide: x3 === void 0 ? null : { position: "top" } }, x3 === void 0 && { paddingInner: 0 }), flexDomain(x3, "x")),
        y: Object.assign(Object.assign({ range: [0, 1], paddingOuter: 0, paddingInner: 0.1, guide: y3 === void 0 ? null : { position: "right" } }, y3 === void 0 && { paddingInner: 0 }), flexDomain(y3, "y"))
      }
    };
  });
  var inferColor = useOverrideAdaptor((options) => {
    const { data: data2, scale: scale9, legend } = options;
    const discovered = [options];
    let encodeColor;
    let scaleColor;
    let legendColor;
    while (discovered.length) {
      const node = discovered.shift();
      const { children, encode = {}, scale: scale10 = {}, legend: legend2 = {} } = node;
      const { color: c5 } = encode;
      const { color: cs } = scale10;
      const { color: cl } = legend2;
      if (c5 !== void 0)
        encodeColor = c5;
      if (cs !== void 0)
        scaleColor = cs;
      if (cl !== void 0)
        legendColor = cl;
      if (Array.isArray(children)) {
        discovered.push(...children);
      }
    }
    const domainColor = () => {
      var _a;
      const domain2 = (_a = scale9 === null || scale9 === void 0 ? void 0 : scale9.color) === null || _a === void 0 ? void 0 : _a.domain;
      if (domain2 !== void 0)
        return [domain2];
      if (encodeColor === void 0)
        return [void 0];
      const color2 = typeof encodeColor === "function" ? encodeColor : (d2) => d2[encodeColor];
      const values = data2.map(color2);
      if (values.some((d2) => typeof d2 === "number"))
        return [extent(values)];
      return [Array.from(new Set(values)), "ordinal"];
    };
    const title = typeof encodeColor === "string" ? encodeColor : "";
    const [domain, type] = domainColor();
    return Object.assign({ encode: { color: { type: "column", value: domain !== null && domain !== void 0 ? domain : [] } }, scale: { color: deep_mix_default({}, scaleColor, { domain, type }) } }, legend === void 0 && {
      legend: { color: deep_mix_default({ title }, legendColor) }
    });
  });
  var setAnimation = useDefaultAdaptor(() => ({
    animate: {
      enterType: "fadeIn"
    }
  }));
  var setStyle = useOverrideAdaptor(() => ({
    frame: false,
    encode: {
      shape: "hollow"
    },
    style: {
      lineWidth: 0
    }
  }));
  var toCell = useOverrideAdaptor(() => ({
    type: "cell"
  }));
  var setData = useOverrideAdaptor((options) => {
    const { data: data2 } = options;
    const connector = {
      type: "custom",
      callback: () => {
        const { data: data3, encode } = options;
        const { x: x3, y: y3 } = encode;
        const X = x3 ? Array.from(new Set(data3.map((d2) => d2[x3]))) : [];
        const Y = y3 ? Array.from(new Set(data3.map((d2) => d2[y3]))) : [];
        const cellData = () => {
          if (X.length && Y.length) {
            const cellData2 = [];
            for (const vx of X) {
              for (const vy of Y) {
                cellData2.push({ [x3]: vx, [y3]: vy });
              }
            }
            return cellData2;
          }
          if (X.length)
            return X.map((d2) => ({ [x3]: d2 }));
          if (Y.length)
            return Y.map((d2) => ({ [y3]: d2 }));
        };
        return cellData();
      }
    };
    return {
      data: { type: "inline", value: data2, transform: [connector] }
    };
  });
  var setChildren = useOverrideAdaptor((options, subLayout = subLayoutRect, createGuideX2 = createGuideXRect, createGuideY2 = createGuideYRect, childOptions = {}) => {
    const { data: dataValue, encode, children, scale: facetScale, x: originX = 0, y: originY = 0, shareData = false, key: viewKey } = options;
    const { value: data2 } = dataValue;
    const { x: encodeX, y: encodeY } = encode;
    const { color: facetScaleColor } = facetScale;
    const { domain: facetDomainColor } = facetScaleColor;
    const createChildren = (visualData, scale9, layout) => {
      const { x: scaleX, y: scaleY } = scale9;
      const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
      const { domain: domainX } = scaleX.getOptions();
      const { domain: domainY } = scaleY.getOptions();
      const index4 = indexOf3(visualData);
      const bboxs = visualData.map(subLayout);
      const values = visualData.map(({ x: x3, y: y3 }) => [
        scaleX.invert(x3),
        scaleY.invert(y3)
      ]);
      const filters = values.map(([fx, fy]) => (d2) => {
        const { [encodeX]: x3, [encodeY]: y3 } = d2;
        const inX = encodeX !== void 0 ? x3 === fx : true;
        const inY = encodeY !== void 0 ? y3 === fy : true;
        return inX && inY;
      });
      const facetData2d = filters.map((f) => data2.filter(f));
      const maxDataDomain = shareData ? max4(facetData2d, (data3) => data3.length) : void 0;
      const facets = values.map(([fx, fy]) => ({
        columnField: encodeX,
        columnIndex: domainX.indexOf(fx),
        columnValue: fx,
        columnValuesLength: domainX.length,
        rowField: encodeY,
        rowIndex: domainY.indexOf(fy),
        rowValue: fy,
        rowValuesLength: domainY.length
      }));
      const normalizedChildren = facets.map((facet) => {
        if (Array.isArray(children))
          return children;
        return [children(facet)].flat(1);
      });
      return index4.flatMap((i) => {
        const [left2, top, width, height] = bboxs[i];
        const facet = facets[i];
        const facetData = facetData2d[i];
        const children2 = normalizedChildren[i];
        return children2.map((_a) => {
          var _b, _c;
          var { scale: scale10, key, facet: isFacet = true, axis = {}, legend = {} } = _a, rest = __rest66(_a, ["scale", "key", "facet", "axis", "legend"]);
          const guideY = ((_b = scale10 === null || scale10 === void 0 ? void 0 : scale10.y) === null || _b === void 0 ? void 0 : _b.guide) || axis.y;
          const guideX = ((_c = scale10 === null || scale10 === void 0 ? void 0 : scale10.x) === null || _c === void 0 ? void 0 : _c.guide) || axis.x;
          const defaultScale = {
            x: { tickCount: encodeX ? 5 : void 0 },
            y: { tickCount: encodeY ? 5 : void 0 }
          };
          const newData = isFacet ? facetData : facetData.length === 0 ? [] : data2;
          const newScale = {
            color: { domain: facetDomainColor }
          };
          const newAxis = {
            x: createGuide(guideX, createGuideX2)(facet, newData),
            y: createGuide(guideY, createGuideY2)(facet, newData)
          };
          return Object.assign(Object.assign({
            key: `${key}-${i}`,
            data: newData,
            margin: 0,
            x: left2 + paddingLeft + originX + marginLeft,
            y: top + paddingTop + originY + marginTop,
            parentKey: viewKey,
            width,
            height,
            paddingLeft: 0,
            paddingRight: 0,
            paddingTop: 0,
            paddingBottom: 0,
            frame: newData.length ? true : false,
            dataDomain: maxDataDomain,
            scale: deep_mix_default(defaultScale, scale10, newScale),
            axis: deep_mix_default({}, axis, newAxis),
            // Hide all legends for child mark by default,
            // they are displayed in the top-level.
            legend: false
          }, rest), childOptions);
        });
      });
    };
    return {
      children: createChildren
    };
  });
  function subLayoutRect(data2) {
    const { points } = data2;
    return calcBBox(points);
  }
  function createInnerGuide(guide, data2) {
    return data2.length ? deep_mix_default({
      title: false,
      tick: null,
      label: null
    }, guide) : deep_mix_default({
      title: false,
      tick: null,
      label: null,
      grid: null
    }, guide);
  }
  function createGuideXRect(guide) {
    return (facet, data2) => {
      const { rowIndex, rowValuesLength, columnIndex, columnValuesLength } = facet;
      if (rowIndex !== rowValuesLength - 1)
        return createInnerGuide(guide, data2);
      const title = columnIndex !== columnValuesLength - 1 ? false : void 0;
      const grid2 = data2.length ? void 0 : null;
      return deep_mix_default({ title, grid: grid2 }, guide);
    };
  }
  function createGuideYRect(guide) {
    return (facet, data2) => {
      const { rowIndex, columnIndex } = facet;
      if (columnIndex !== 0)
        return createInnerGuide(guide, data2);
      const title = rowIndex !== 0 ? false : void 0;
      const grid2 = data2.length ? void 0 : null;
      return deep_mix_default({ title, grid: grid2 }, guide);
    };
  }
  function createGuide(guide, factory) {
    if (typeof guide === "function")
      return guide;
    if (guide === null || guide === false)
      return () => null;
    return factory(guide);
  }
  var FacetRect = () => {
    return (options) => {
      const newOptions = Container.of(options).call(toCell).call(inferColor).call(setAnimation).call(setScale).call(setStyle).call(setData).call(setChildren).value();
      return [newOptions];
    };
  };
  FacetRect.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/composition/repeatMatrix.js
  var __rest67 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var setScale2 = useDefaultAdaptor((options) => {
    return {
      scale: {
        x: { guide: null, paddingOuter: 0, paddingInner: 0.1 },
        y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
      }
    };
  });
  var setChildren2 = useOverrideAdaptor((options) => {
    const { data: data2, children, x: originX = 0, y: originY = 0, key: viewKey } = options;
    const createChildren = (visualData, scale9, layout) => {
      const { x: scaleX, y: scaleY } = scale9;
      const { paddingLeft, paddingTop, marginLeft, marginTop } = layout;
      const { domain: domainX } = scaleX.getOptions();
      const { domain: domainY } = scaleY.getOptions();
      const index4 = indexOf3(visualData);
      const bboxs = visualData.map(({ points }) => calcBBox(points));
      const values = visualData.map(({ x: x3, y: y3 }) => [
        scaleX.invert(x3),
        scaleY.invert(y3)
      ]);
      const facets = values.map(([fx, fy]) => ({
        columnField: fx,
        columnIndex: domainX.indexOf(fx),
        columnValue: fx,
        columnValuesLength: domainX.length,
        rowField: fy,
        rowIndex: domainY.indexOf(fy),
        rowValue: fy,
        rowValuesLength: domainY.length
      }));
      const normalizedChildren = facets.map((facet) => {
        if (Array.isArray(children))
          return children;
        return [children(facet)].flat(1);
      });
      return index4.flatMap((i) => {
        const [left2, top, width, height] = bboxs[i];
        const [fx, fy] = values[i];
        const facet = facets[i];
        const children2 = normalizedChildren[i];
        return children2.map((d2) => {
          var _a, _b;
          const { scale: scale10, key, encode, axis, interaction } = d2, rest = __rest67(d2, ["scale", "key", "encode", "axis", "interaction"]);
          const guideY = (_a = scale10 === null || scale10 === void 0 ? void 0 : scale10.y) === null || _a === void 0 ? void 0 : _a.guide;
          const guideX = (_b = scale10 === null || scale10 === void 0 ? void 0 : scale10.x) === null || _b === void 0 ? void 0 : _b.guide;
          const defaultScale = {
            // Do not sync position scales among facets by default.
            x: { facet: false },
            // Do not sync position scales among facets by default.
            y: { facet: false }
          };
          const newAxis = {
            x: createGuideX(guideX)(facet, data2),
            y: createGuideY(guideY)(facet, data2)
          };
          const defaultAxis = {
            x: { tickCount: 5 },
            y: { tickCount: 5 }
          };
          return Object.assign({
            data: data2,
            parentKey: viewKey,
            key: `${key}-${i}`,
            x: left2 + paddingLeft + originX + marginLeft,
            y: top + paddingTop + originY + marginTop,
            width,
            height,
            margin: 0,
            paddingLeft: 0,
            paddingRight: 0,
            paddingTop: 0,
            paddingBottom: 0,
            frame: true,
            scale: deep_mix_default(defaultScale, scale10),
            axis: deep_mix_default(defaultAxis, axis, newAxis),
            // Hide all legends for child mark by default,
            // they are displayed in the top-level.
            legend: false,
            encode: deep_mix_default({}, encode, {
              x: fx,
              y: fy
            }),
            interaction: deep_mix_default({}, interaction, {
              // Register this interaction in parent node.
              legendFilter: false
            })
          }, rest);
        });
      });
    };
    return {
      children: createChildren
    };
  });
  var setData2 = useOverrideAdaptor((options) => {
    const { encode } = options, rest = __rest67(options, ["encode"]);
    const { position: P = [], x: X = P, y: Y = [...P].reverse() } = encode, restEncode = __rest67(encode, ["position", "x", "y"]);
    const data2 = [];
    for (const $x of [X].flat(1)) {
      for (const $y of [Y].flat(1)) {
        data2.push({ $x, $y });
      }
    }
    return Object.assign(Object.assign({}, rest), { data: data2, encode: Object.assign(Object.assign({}, restEncode), { x: "$x", y: "$y" }), scale: Object.assign(Object.assign({}, [X].flat(1).length === 1 && { x: { paddingInner: 0 } }), [Y].flat(1).length === 1 && { y: { paddingInner: 0 } }) });
  });
  function createGuideX(guideX) {
    if (typeof guideX === "function")
      return guideX;
    if (guideX === null)
      return () => null;
    return (facet, data2) => {
      const { rowIndex, rowValuesLength } = facet;
      if (rowIndex !== rowValuesLength - 1)
        return createInnerGuide(guideX, data2);
    };
  }
  function createGuideY(guideY) {
    if (typeof guideY === "function")
      return guideY;
    if (guideY === null)
      return () => null;
    return (facet, data2) => {
      const { columnIndex } = facet;
      if (columnIndex !== 0)
        return createInnerGuide(guideY, data2);
    };
  }
  var RepeatMatrix = () => {
    return (options) => {
      const newOptions = Container.of(options).call(toCell).call(inferColor).call(setChildren2).call(setData2).call(setAnimation).call(setStyle).call(setScale2).value();
      return [newOptions];
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/composition/facetCircle.js
  var __rest68 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var setScale3 = useDefaultAdaptor((options) => {
    return {
      scale: {
        x: { guide: { type: "axisArc" }, paddingOuter: 0, paddingInner: 0.1 },
        y: { guide: null, range: [0, 1], paddingOuter: 0, paddingInner: 0.1 }
      }
    };
  });
  var setCoordinate = useDefaultAdaptor((options) => {
    return {
      coordinate: { type: "polar" }
    };
  });
  var setEncode = (options) => {
    const { encode } = options, rest = __rest68(options, ["encode"]);
    const { position } = encode;
    return Object.assign(Object.assign({}, rest), { encode: { x: position } });
  };
  function createGuideFacetCircle(guide) {
    return (facet) => null;
  }
  function subLayoutFacetCircle(data2) {
    const { points } = data2;
    const [p0, p1, p2, p3] = points;
    const sr = dist4(p0, p3);
    const v0 = sub6(p0, p3);
    const v1 = sub6(p1, p2);
    const a01 = angleBetween(v0, v1);
    const t = 1 / Math.sin(a01 / 2);
    const ir = sr / (1 + t);
    const s2 = ir * Math.sqrt(2);
    const [x05, y05] = p2;
    const a0 = angleWithQuadrant(v0);
    const a3 = a0 + a01 / 2;
    const d2 = ir * t;
    const cx = x05 + d2 * Math.sin(a3);
    const cy = y05 - d2 * Math.cos(a3);
    return [cx - s2 / 2, cy - s2 / 2, s2, s2];
  }
  var FacetCircle = () => {
    return (options) => {
      const newOptions = Container.of(options).call(toCell).call(setEncode).call(inferColor).call(setCoordinate).call(setData).call(setChildren, subLayoutFacetCircle, createGuideFacetCircle, createGuideFacetCircle, { frame: false }).call(setAnimation).call(setStyle).call(setScale3).value();
      return [newOptions];
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/composition/timingKeyframe.js
  function range2(direction2, iterationCount, keyframeCount) {
    const start2 = 0;
    const end = keyframeCount;
    const normal = [start2, end];
    const reverse = [-end + 1, -start2 + 1];
    if (direction2 === "normal")
      return normal;
    if (direction2 === "reverse")
      return reverse;
    if (direction2 === "alternate") {
      return iterationCount % 2 === 0 ? normal : reverse;
    }
    if (direction2 === "reverse-alternate") {
      return iterationCount % 2 === 0 ? reverse : normal;
    }
  }
  function setAnimation2(node, duration, easing) {
    const discovered = [node];
    while (discovered.length) {
      const n2 = discovered.pop();
      n2.animate = deep_mix_default({
        enter: {
          duration
        },
        update: {
          duration,
          easing,
          type: "morphing",
          fill: "both"
        },
        exit: {
          type: "fadeOut",
          duration
        }
      }, n2.animate || {});
      const { children } = n2;
      if (Array.isArray(children))
        discovered.push(...children);
    }
    return node;
  }
  var TimingKeyframe = () => {
    return (options) => {
      const { children = [], duration = 1e3, iterationCount = 1, direction: direction2 = "normal", easing = "ease-in-out-sine" } = options;
      const n2 = children.length;
      if (!Array.isArray(children) || n2 === 0)
        return [];
      const { key } = children[0];
      const newChildren = children.map((d2) => Object.assign(Object.assign({}, d2), { key })).map((d2) => setAnimation2(d2, duration, easing));
      return function* () {
        let count4 = 0;
        let prevIndex;
        while (iterationCount === "infinite" || count4 < iterationCount) {
          const [start2, end] = range2(direction2, count4, n2);
          for (let i = start2; i < end; i += 1) {
            const index4 = Math.abs(i);
            if (prevIndex !== index4)
              yield newChildren[index4];
            prevIndex = index4;
          }
          count4++;
        }
      };
    };
  };
  TimingKeyframe.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/composition/geoPath.js
  var __rest69 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var GeoPath = () => {
    return (options) => {
      const { type, data: data2, scale: scale9, encode, style, animate: animate2, key, state } = options, rest = __rest69(options, ["type", "data", "scale", "encode", "style", "animate", "key", "state"]);
      return [
        Object.assign(Object.assign({ type: "geoView" }, rest), { children: [
          {
            type: "geoPath",
            key: `${key}-0`,
            data: {
              value: data2
            },
            scale: scale9,
            encode,
            style,
            animate: animate2,
            state
          }
        ] })
      ];
    };
  };
  GeoPath.props = {};

  // ../../engine/rails_design/node_modules/d3-geo/src/math.js
  var epsilon3 = 1e-6;
  var epsilon22 = 1e-12;
  var pi3 = Math.PI;
  var halfPi2 = pi3 / 2;
  var quarterPi = pi3 / 4;
  var tau3 = pi3 * 2;
  var degrees2 = 180 / pi3;
  var radians2 = pi3 / 180;
  var abs2 = Math.abs;
  var atan = Math.atan;
  var atan22 = Math.atan2;
  var cos2 = Math.cos;
  var ceil4 = Math.ceil;
  var exp2 = Math.exp;
  var log = Math.log;
  var pow2 = Math.pow;
  var sin2 = Math.sin;
  var sign2 = Math.sign || function(x3) {
    return x3 > 0 ? 1 : x3 < 0 ? -1 : 0;
  };
  var sqrt2 = Math.sqrt;
  var tan = Math.tan;
  function acos2(x3) {
    return x3 > 1 ? 0 : x3 < -1 ? pi3 : Math.acos(x3);
  }
  function asin2(x3) {
    return x3 > 1 ? halfPi2 : x3 < -1 ? -halfPi2 : Math.asin(x3);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/noop.js
  function noop2() {
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/stream.js
  function streamGeometry(geometry, stream) {
    if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
      streamGeometryType[geometry.type](geometry, stream);
    }
  }
  var streamObjectType = {
    Feature: function(object, stream) {
      streamGeometry(object.geometry, stream);
    },
    FeatureCollection: function(object, stream) {
      var features = object.features, i = -1, n2 = features.length;
      while (++i < n2) streamGeometry(features[i].geometry, stream);
    }
  };
  var streamGeometryType = {
    Sphere: function(object, stream) {
      stream.sphere();
    },
    Point: function(object, stream) {
      object = object.coordinates;
      stream.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n2 = coordinates.length;
      while (++i < n2) object = coordinates[i], stream.point(object[0], object[1], object[2]);
    },
    LineString: function(object, stream) {
      streamLine(object.coordinates, stream, 0);
    },
    MultiLineString: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n2 = coordinates.length;
      while (++i < n2) streamLine(coordinates[i], stream, 0);
    },
    Polygon: function(object, stream) {
      streamPolygon(object.coordinates, stream);
    },
    MultiPolygon: function(object, stream) {
      var coordinates = object.coordinates, i = -1, n2 = coordinates.length;
      while (++i < n2) streamPolygon(coordinates[i], stream);
    },
    GeometryCollection: function(object, stream) {
      var geometries = object.geometries, i = -1, n2 = geometries.length;
      while (++i < n2) streamGeometry(geometries[i], stream);
    }
  };
  function streamLine(coordinates, stream, closed) {
    var i = -1, n2 = coordinates.length - closed, coordinate;
    stream.lineStart();
    while (++i < n2) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
    stream.lineEnd();
  }
  function streamPolygon(coordinates, stream) {
    var i = -1, n2 = coordinates.length;
    stream.polygonStart();
    while (++i < n2) streamLine(coordinates[i], stream, 1);
    stream.polygonEnd();
  }
  function stream_default(object, stream) {
    if (object && streamObjectType.hasOwnProperty(object.type)) {
      streamObjectType[object.type](object, stream);
    } else {
      streamGeometry(object, stream);
    }
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/cartesian.js
  function spherical(cartesian2) {
    return [atan22(cartesian2[1], cartesian2[0]), asin2(cartesian2[2])];
  }
  function cartesian(spherical2) {
    var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos2(phi2);
    return [cosPhi * cos2(lambda), cosPhi * sin2(lambda), sin2(phi2)];
  }
  function cartesianDot(a3, b) {
    return a3[0] * b[0] + a3[1] * b[1] + a3[2] * b[2];
  }
  function cartesianCross(a3, b) {
    return [a3[1] * b[2] - a3[2] * b[1], a3[2] * b[0] - a3[0] * b[2], a3[0] * b[1] - a3[1] * b[0]];
  }
  function cartesianAddInPlace(a3, b) {
    a3[0] += b[0], a3[1] += b[1], a3[2] += b[2];
  }
  function cartesianScale(vector, k) {
    return [vector[0] * k, vector[1] * k, vector[2] * k];
  }
  function cartesianNormalizeInPlace(d2) {
    var l2 = sqrt2(d2[0] * d2[0] + d2[1] * d2[1] + d2[2] * d2[2]);
    d2[0] /= l2, d2[1] /= l2, d2[2] /= l2;
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/compose.js
  function compose_default(a3, b) {
    function compose4(x3, y3) {
      return x3 = a3(x3, y3), b(x3[0], x3[1]);
    }
    if (a3.invert && b.invert) compose4.invert = function(x3, y3) {
      return x3 = b.invert(x3, y3), x3 && a3.invert(x3[0], x3[1]);
    };
    return compose4;
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/rotation.js
  function rotationIdentity(lambda, phi2) {
    if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau3) * tau3;
    return [lambda, phi2];
  }
  rotationIdentity.invert = rotationIdentity;
  function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
    return (deltaLambda %= tau3) ? deltaPhi || deltaGamma ? compose_default(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
  }
  function forwardRotationLambda(deltaLambda) {
    return function(lambda, phi2) {
      lambda += deltaLambda;
      if (abs2(lambda) > pi3) lambda -= Math.round(lambda / tau3) * tau3;
      return [lambda, phi2];
    };
  }
  function rotationLambda(deltaLambda) {
    var rotation = forwardRotationLambda(deltaLambda);
    rotation.invert = forwardRotationLambda(-deltaLambda);
    return rotation;
  }
  function rotationPhiGamma(deltaPhi, deltaGamma) {
    var cosDeltaPhi = cos2(deltaPhi), sinDeltaPhi = sin2(deltaPhi), cosDeltaGamma = cos2(deltaGamma), sinDeltaGamma = sin2(deltaGamma);
    function rotation(lambda, phi2) {
      var cosPhi = cos2(phi2), x3 = cos2(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z = sin2(phi2), k = z * cosDeltaPhi + x3 * sinDeltaPhi;
      return [
        atan22(y3 * cosDeltaGamma - k * sinDeltaGamma, x3 * cosDeltaPhi - z * sinDeltaPhi),
        asin2(k * cosDeltaGamma + y3 * sinDeltaGamma)
      ];
    }
    rotation.invert = function(lambda, phi2) {
      var cosPhi = cos2(phi2), x3 = cos2(lambda) * cosPhi, y3 = sin2(lambda) * cosPhi, z = sin2(phi2), k = z * cosDeltaGamma - y3 * sinDeltaGamma;
      return [
        atan22(y3 * cosDeltaGamma + z * sinDeltaGamma, x3 * cosDeltaPhi + k * sinDeltaPhi),
        asin2(k * cosDeltaPhi - x3 * sinDeltaPhi)
      ];
    };
    return rotation;
  }
  function rotation_default(rotate4) {
    rotate4 = rotateRadians(rotate4[0] * radians2, rotate4[1] * radians2, rotate4.length > 2 ? rotate4[2] * radians2 : 0);
    function forward(coordinates) {
      coordinates = rotate4(coordinates[0] * radians2, coordinates[1] * radians2);
      return coordinates[0] *= degrees2, coordinates[1] *= degrees2, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate4.invert(coordinates[0] * radians2, coordinates[1] * radians2);
      return coordinates[0] *= degrees2, coordinates[1] *= degrees2, coordinates;
    };
    return forward;
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/circle.js
  function circleStream(stream, radius, delta, direction2, t0, t1) {
    if (!delta) return;
    var cosRadius = cos2(radius), sinRadius = sin2(radius), step2 = direction2 * delta;
    if (t0 == null) {
      t0 = radius + direction2 * tau3;
      t1 = radius - step2 / 2;
    } else {
      t0 = circleRadius(cosRadius, t0);
      t1 = circleRadius(cosRadius, t1);
      if (direction2 > 0 ? t0 < t1 : t0 > t1) t0 += direction2 * tau3;
    }
    for (var point6, t = t0; direction2 > 0 ? t > t1 : t < t1; t -= step2) {
      point6 = spherical([cosRadius, -sinRadius * cos2(t), -sinRadius * sin2(t)]);
      stream.point(point6[0], point6[1]);
    }
  }
  function circleRadius(cosRadius, point6) {
    point6 = cartesian(point6), point6[0] -= cosRadius;
    cartesianNormalizeInPlace(point6);
    var radius = acos2(-point6[1]);
    return ((-point6[2] < 0 ? -radius : radius) + tau3 - epsilon3) % tau3;
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/clip/buffer.js
  function buffer_default() {
    var lines = [], line4;
    return {
      point: function(x3, y3, m3) {
        line4.push([x3, y3, m3]);
      },
      lineStart: function() {
        lines.push(line4 = []);
      },
      lineEnd: noop2,
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      },
      result: function() {
        var result = lines;
        lines = [];
        line4 = null;
        return result;
      }
    };
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/pointEqual.js
  function pointEqual_default(a3, b) {
    return abs2(a3[0] - b[0]) < epsilon3 && abs2(a3[1] - b[1]) < epsilon3;
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/clip/rejoin.js
  function Intersection(point6, points, other, entry) {
    this.x = point6;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function rejoin_default(segments, compareIntersection2, startInside, interpolate5, stream) {
    var subject = [], clip = [], i, n2;
    segments.forEach(function(segment) {
      if ((n3 = segment.length - 1) <= 0) return;
      var n3, p0 = segment[0], p1 = segment[n3], x3;
      if (pointEqual_default(p0, p1)) {
        if (!p0[2] && !p1[2]) {
          stream.lineStart();
          for (i = 0; i < n3; ++i) stream.point((p0 = segment[i])[0], p0[1]);
          stream.lineEnd();
          return;
        }
        p1[0] += 2 * epsilon3;
      }
      subject.push(x3 = new Intersection(p0, segment, null, true));
      clip.push(x3.o = new Intersection(p0, null, x3, false));
      subject.push(x3 = new Intersection(p1, segment, null, false));
      clip.push(x3.o = new Intersection(p1, null, x3, true));
    });
    if (!subject.length) return;
    clip.sort(compareIntersection2);
    link(subject);
    link(clip);
    for (i = 0, n2 = clip.length; i < n2; ++i) {
      clip[i].e = startInside = !startInside;
    }
    var start2 = subject[0], points, point6;
    while (1) {
      var current = start2, isSubject = true;
      while (current.v) if ((current = current.n) === start2) return;
      points = current.z;
      stream.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (i = 0, n2 = points.length; i < n2; ++i) stream.point((point6 = points[i])[0], point6[1]);
          } else {
            interpolate5(current.x, current.n.x, 1, stream);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (i = points.length - 1; i >= 0; --i) stream.point((point6 = points[i])[0], point6[1]);
          } else {
            interpolate5(current.x, current.p.x, -1, stream);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      stream.lineEnd();
    }
  }
  function link(array2) {
    if (!(n2 = array2.length)) return;
    var n2, i = 0, a3 = array2[0], b;
    while (++i < n2) {
      a3.n = b = array2[i];
      b.p = a3;
      a3 = b;
    }
    a3.n = b = array2[0];
    b.p = a3;
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/polygonContains.js
  function longitude(point6) {
    return abs2(point6[0]) <= pi3 ? point6[0] : sign2(point6[0]) * ((abs2(point6[0]) + pi3) % tau3 - pi3);
  }
  function polygonContains_default(polygon, point6) {
    var lambda = longitude(point6), phi2 = point6[1], sinPhi = sin2(phi2), normal = [sin2(lambda), -cos2(lambda), 0], angle4 = 0, winding = 0;
    var sum3 = new Adder();
    if (sinPhi === 1) phi2 = halfPi2 + epsilon3;
    else if (sinPhi === -1) phi2 = -halfPi2 - epsilon3;
    for (var i = 0, n2 = polygon.length; i < n2; ++i) {
      if (!(m3 = (ring = polygon[i]).length)) continue;
      var ring, m3, point0 = ring[m3 - 1], lambda0 = longitude(point0), phi0 = point0[1] / 2 + quarterPi, sinPhi0 = sin2(phi0), cosPhi0 = cos2(phi0);
      for (var j = 0; j < m3; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
        var point1 = ring[j], lambda1 = longitude(point1), phi1 = point1[1] / 2 + quarterPi, sinPhi1 = sin2(phi1), cosPhi1 = cos2(phi1), delta = lambda1 - lambda0, sign3 = delta >= 0 ? 1 : -1, absDelta = sign3 * delta, antimeridian = absDelta > pi3, k = sinPhi0 * sinPhi1;
        sum3.add(atan22(k * sign3 * sin2(absDelta), cosPhi0 * cosPhi1 + k * cos2(absDelta)));
        angle4 += antimeridian ? delta + sign3 * tau3 : delta;
        if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
          var arc = cartesianCross(cartesian(point0), cartesian(point1));
          cartesianNormalizeInPlace(arc);
          var intersection = cartesianCross(normal, arc);
          cartesianNormalizeInPlace(intersection);
          var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin2(intersection[2]);
          if (phi2 > phiArc || phi2 === phiArc && (arc[0] || arc[1])) {
            winding += antimeridian ^ delta >= 0 ? 1 : -1;
          }
        }
      }
    }
    return (angle4 < -epsilon3 || angle4 < epsilon3 && sum3 < -epsilon22) ^ winding & 1;
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/clip/index.js
  function clip_default(pointVisible, clipLine, interpolate5, start2) {
    return function(sink) {
      var line4 = clipLine(sink), ringBuffer = buffer_default(), ringSink = clipLine(ringBuffer), polygonStarted = false, polygon, segments, ring;
      var clip = {
        point: point6,
        lineStart,
        lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point6;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = merge(segments);
          var startInside = polygonContains_default(polygon, start2);
          if (segments.length) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            rejoin_default(segments, compareIntersection, startInside, interpolate5, sink);
          } else if (startInside) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            interpolate5(null, null, 1, sink);
            sink.lineEnd();
          }
          if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          sink.polygonStart();
          sink.lineStart();
          interpolate5(null, null, 1, sink);
          sink.lineEnd();
          sink.polygonEnd();
        }
      };
      function point6(lambda, phi2) {
        if (pointVisible(lambda, phi2)) sink.point(lambda, phi2);
      }
      function pointLine(lambda, phi2) {
        line4.point(lambda, phi2);
      }
      function lineStart() {
        clip.point = pointLine;
        line4.lineStart();
      }
      function lineEnd() {
        clip.point = point6;
        line4.lineEnd();
      }
      function pointRing(lambda, phi2) {
        ring.push([lambda, phi2]);
        ringSink.point(lambda, phi2);
      }
      function ringStart() {
        ringSink.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringSink.lineEnd();
        var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n2 = ringSegments.length, m3, segment, point7;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n2) return;
        if (clean & 1) {
          segment = ringSegments[0];
          if ((m3 = segment.length - 1) > 0) {
            if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
            sink.lineStart();
            for (i = 0; i < m3; ++i) sink.point((point7 = segment[i])[0], point7[1]);
            sink.lineEnd();
          }
          return;
        }
        if (n2 > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(validSegment));
      }
      return clip;
    };
  }
  function validSegment(segment) {
    return segment.length > 1;
  }
  function compareIntersection(a3, b) {
    return ((a3 = a3.x)[0] < 0 ? a3[1] - halfPi2 - epsilon3 : halfPi2 - a3[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi2 - epsilon3 : halfPi2 - b[1]);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/clip/antimeridian.js
  var antimeridian_default = clip_default(
    function() {
      return true;
    },
    clipAntimeridianLine,
    clipAntimeridianInterpolate,
    [-pi3, -halfPi2]
  );
  function clipAntimeridianLine(stream) {
    var lambda0 = NaN, phi0 = NaN, sign0 = NaN, clean;
    return {
      lineStart: function() {
        stream.lineStart();
        clean = 1;
      },
      point: function(lambda1, phi1) {
        var sign1 = lambda1 > 0 ? pi3 : -pi3, delta = abs2(lambda1 - lambda0);
        if (abs2(delta - pi3) < epsilon3) {
          stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? halfPi2 : -halfPi2);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          stream.point(lambda1, phi0);
          clean = 0;
        } else if (sign0 !== sign1 && delta >= pi3) {
          if (abs2(lambda0 - sign0) < epsilon3) lambda0 -= sign0 * epsilon3;
          if (abs2(lambda1 - sign1) < epsilon3) lambda1 -= sign1 * epsilon3;
          phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
          stream.point(sign0, phi0);
          stream.lineEnd();
          stream.lineStart();
          stream.point(sign1, phi0);
          clean = 0;
        }
        stream.point(lambda0 = lambda1, phi0 = phi1);
        sign0 = sign1;
      },
      lineEnd: function() {
        stream.lineEnd();
        lambda0 = phi0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
    var cosPhi0, cosPhi1, sinLambda0Lambda1 = sin2(lambda0 - lambda1);
    return abs2(sinLambda0Lambda1) > epsilon3 ? atan((sin2(phi0) * (cosPhi1 = cos2(phi1)) * sin2(lambda1) - sin2(phi1) * (cosPhi0 = cos2(phi0)) * sin2(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
  }
  function clipAntimeridianInterpolate(from, to, direction2, stream) {
    var phi2;
    if (from == null) {
      phi2 = direction2 * halfPi2;
      stream.point(-pi3, phi2);
      stream.point(0, phi2);
      stream.point(pi3, phi2);
      stream.point(pi3, 0);
      stream.point(pi3, -phi2);
      stream.point(0, -phi2);
      stream.point(-pi3, -phi2);
      stream.point(-pi3, 0);
      stream.point(-pi3, phi2);
    } else if (abs2(from[0] - to[0]) > epsilon3) {
      var lambda = from[0] < to[0] ? pi3 : -pi3;
      phi2 = direction2 * lambda / 2;
      stream.point(-lambda, phi2);
      stream.point(0, phi2);
      stream.point(lambda, phi2);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/clip/circle.js
  function circle_default(radius) {
    var cr = cos2(radius), delta = 2 * radians2, smallRadius = cr > 0, notHemisphere = abs2(cr) > epsilon3;
    function interpolate5(from, to, direction2, stream) {
      circleStream(stream, radius, delta, direction2, from, to);
    }
    function visible(lambda, phi2) {
      return cos2(lambda) * cos2(phi2) > cr;
    }
    function clipLine(stream) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(lambda, phi2) {
          var point1 = [lambda, phi2], point22, v = visible(lambda, phi2), c5 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi3 : -pi3), phi2) : 0;
          if (!point0 && (v00 = v0 = v)) stream.lineStart();
          if (v !== v0) {
            point22 = intersect4(point0, point1);
            if (!point22 || pointEqual_default(point0, point22) || pointEqual_default(point1, point22))
              point1[2] = 1;
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              stream.lineStart();
              point22 = intersect4(point1, point0);
              stream.point(point22[0], point22[1]);
            } else {
              point22 = intersect4(point0, point1);
              stream.point(point22[0], point22[1], 2);
              stream.lineEnd();
            }
            point0 = point22;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c5 & c0) && (t = intersect4(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                stream.lineStart();
                stream.point(t[0][0], t[0][1]);
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
              } else {
                stream.point(t[1][0], t[1][1]);
                stream.lineEnd();
                stream.lineStart();
                stream.point(t[0][0], t[0][1], 3);
              }
            }
          }
          if (v && (!point0 || !pointEqual_default(point0, point1))) {
            stream.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c5;
        },
        lineEnd: function() {
          if (v0) stream.lineEnd();
          point0 = null;
        },
        // Rejoin first and last segments if there were intersections and the first
        // and last points were visible.
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect4(a3, b, two) {
      var pa = cartesian(a3), pb = cartesian(b);
      var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant3 = n2n2 - n1n2 * n1n2;
      if (!determinant3) return !two && a3;
      var c1 = cr * n2n2 / determinant3, c22 = -cr * n1n2 / determinant3, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B3 = cartesianScale(n2, c22);
      cartesianAddInPlace(A5, B3);
      var u = n1xn2, w = cartesianDot(A5, u), uu = cartesianDot(u, u), t2 = w * w - uu * (cartesianDot(A5, A5) - 1);
      if (t2 < 0) return;
      var t = sqrt2(t2), q = cartesianScale(u, (-w - t) / uu);
      cartesianAddInPlace(q, A5);
      q = spherical(q);
      if (!two) return q;
      var lambda0 = a3[0], lambda1 = b[0], phi0 = a3[1], phi1 = b[1], z;
      if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;
      var delta2 = lambda1 - lambda0, polar = abs2(delta2 - pi3) < epsilon3, meridian = polar || delta2 < epsilon3;
      if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z;
      if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < (abs2(q[0] - lambda0) < epsilon3 ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta2 > pi3 ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
        var q12 = cartesianScale(u, (-w + t) / uu);
        cartesianAddInPlace(q12, A5);
        return [q, spherical(q12)];
      }
    }
    function code(lambda, phi2) {
      var r = smallRadius ? radius : pi3 - radius, code2 = 0;
      if (lambda < -r) code2 |= 1;
      else if (lambda > r) code2 |= 2;
      if (phi2 < -r) code2 |= 4;
      else if (phi2 > r) code2 |= 8;
      return code2;
    }
    return clip_default(visible, clipLine, interpolate5, smallRadius ? [0, -radius] : [-pi3, radius - pi3]);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/clip/line.js
  function line_default2(a3, b, x05, y05, x12, y12) {
    var ax = a3[0], ay = a3[1], bx = b[0], by = b[1], t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
    r = x05 - ax;
    if (!dx && r > 0) return;
    r /= dx;
    if (dx < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dx > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }
    r = x12 - ax;
    if (!dx && r < 0) return;
    r /= dx;
    if (dx < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dx > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }
    r = y05 - ay;
    if (!dy && r > 0) return;
    r /= dy;
    if (dy < 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    } else if (dy > 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    }
    r = y12 - ay;
    if (!dy && r < 0) return;
    r /= dy;
    if (dy < 0) {
      if (r > t1) return;
      if (r > t0) t0 = r;
    } else if (dy > 0) {
      if (r < t0) return;
      if (r < t1) t1 = r;
    }
    if (t0 > 0) a3[0] = ax + t0 * dx, a3[1] = ay + t0 * dy;
    if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
    return true;
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/clip/rectangle.js
  var clipMax = 1e9;
  var clipMin = -clipMax;
  function clipRectangle(x05, y05, x12, y12) {
    function visible(x3, y3) {
      return x05 <= x3 && x3 <= x12 && y05 <= y3 && y3 <= y12;
    }
    function interpolate5(from, to, direction2, stream) {
      var a3 = 0, a1 = 0;
      if (from == null || (a3 = corner(from, direction2)) !== (a1 = corner(to, direction2)) || comparePoint(from, to) < 0 ^ direction2 > 0) {
        do
          stream.point(a3 === 0 || a3 === 3 ? x05 : x12, a3 > 1 ? y12 : y05);
        while ((a3 = (a3 + direction2 + 4) % 4) !== a1);
      } else {
        stream.point(to[0], to[1]);
      }
    }
    function corner(p2, direction2) {
      return abs2(p2[0] - x05) < epsilon3 ? direction2 > 0 ? 0 : 3 : abs2(p2[0] - x12) < epsilon3 ? direction2 > 0 ? 2 : 1 : abs2(p2[1] - y05) < epsilon3 ? direction2 > 0 ? 1 : 0 : direction2 > 0 ? 3 : 2;
    }
    function compareIntersection2(a3, b) {
      return comparePoint(a3.x, b.x);
    }
    function comparePoint(a3, b) {
      var ca = corner(a3, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a3[1] : ca === 1 ? a3[0] - b[0] : ca === 2 ? a3[1] - b[1] : b[0] - a3[0];
    }
    return function(stream) {
      var activeStream = stream, bufferStream = buffer_default(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first3, clean;
      var clipStream = {
        point: point6,
        lineStart,
        lineEnd,
        polygonStart,
        polygonEnd
      };
      function point6(x3, y3) {
        if (visible(x3, y3)) activeStream.point(x3, y3);
      }
      function polygonInside() {
        var winding = 0;
        for (var i = 0, n2 = polygon.length; i < n2; ++i) {
          for (var ring2 = polygon[i], j = 1, m3 = ring2.length, point7 = ring2[0], a0, a1, b0 = point7[0], b1 = point7[1]; j < m3; ++j) {
            a0 = b0, a1 = b1, point7 = ring2[j], b0 = point7[0], b1 = point7[1];
            if (a1 <= y12) {
              if (b1 > y12 && (b0 - a0) * (y12 - a1) > (b1 - a1) * (x05 - a0)) ++winding;
            } else {
              if (b1 <= y12 && (b0 - a0) * (y12 - a1) < (b1 - a1) * (x05 - a0)) --winding;
            }
          }
        }
        return winding;
      }
      function polygonStart() {
        activeStream = bufferStream, segments = [], polygon = [], clean = true;
      }
      function polygonEnd() {
        var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge(segments)).length;
        if (cleanInside || visible2) {
          stream.polygonStart();
          if (cleanInside) {
            stream.lineStart();
            interpolate5(null, null, 1, stream);
            stream.lineEnd();
          }
          if (visible2) {
            rejoin_default(segments, compareIntersection2, startInside, interpolate5, stream);
          }
          stream.polygonEnd();
        }
        activeStream = stream, segments = polygon = ring = null;
      }
      function lineStart() {
        clipStream.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first3 = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferStream.rejoin();
          segments.push(bufferStream.result());
        }
        clipStream.point = point6;
        if (v_) activeStream.lineEnd();
      }
      function linePoint(x3, y3) {
        var v = visible(x3, y3);
        if (polygon) ring.push([x3, y3]);
        if (first3) {
          x__ = x3, y__ = y3, v__ = v;
          first3 = false;
          if (v) {
            activeStream.lineStart();
            activeStream.point(x3, y3);
          }
        } else {
          if (v && v_) activeStream.point(x3, y3);
          else {
            var a3 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x3 = Math.max(clipMin, Math.min(clipMax, x3)), y3 = Math.max(clipMin, Math.min(clipMax, y3))];
            if (line_default2(a3, b, x05, y05, x12, y12)) {
              if (!v_) {
                activeStream.lineStart();
                activeStream.point(a3[0], a3[1]);
              }
              activeStream.point(b[0], b[1]);
              if (!v) activeStream.lineEnd();
              clean = false;
            } else if (v) {
              activeStream.lineStart();
              activeStream.point(x3, y3);
              clean = false;
            }
          }
        }
        x_ = x3, y_ = y3, v_ = v;
      }
      return clipStream;
    };
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/graticule.js
  function graticuleX(y05, y12, dy) {
    var y3 = range(y05, y12 - epsilon3, dy).concat(y12);
    return function(x3) {
      return y3.map(function(y4) {
        return [x3, y4];
      });
    };
  }
  function graticuleY(x05, x12, dx) {
    var x3 = range(x05, x12 - epsilon3, dx).concat(x12);
    return function(y3) {
      return x3.map(function(x4) {
        return [x4, y3];
      });
    };
  }
  function graticule() {
    var x12, x05, X12, X02, y12, y05, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x3, y3, X, Y, precision = 2.5;
    function graticule2() {
      return { type: "MultiLineString", coordinates: lines() };
    }
    function lines() {
      return range(ceil4(X02 / DX) * DX, X12, DX).map(X).concat(range(ceil4(Y02 / DY) * DY, Y12, DY).map(Y)).concat(range(ceil4(x05 / dx) * dx, x12, dx).filter(function(x4) {
        return abs2(x4 % DX) > epsilon3;
      }).map(x3)).concat(range(ceil4(y05 / dy) * dy, y12, dy).filter(function(y4) {
        return abs2(y4 % DY) > epsilon3;
      }).map(y3));
    }
    graticule2.lines = function() {
      return lines().map(function(coordinates) {
        return { type: "LineString", coordinates };
      });
    };
    graticule2.outline = function() {
      return {
        type: "Polygon",
        coordinates: [
          X(X02).concat(
            Y(Y12).slice(1),
            X(X12).reverse().slice(1),
            Y(Y02).reverse().slice(1)
          )
        ]
      };
    };
    graticule2.extent = function(_2) {
      if (!arguments.length) return graticule2.extentMinor();
      return graticule2.extentMajor(_2).extentMinor(_2);
    };
    graticule2.extentMajor = function(_2) {
      if (!arguments.length) return [[X02, Y02], [X12, Y12]];
      X02 = +_2[0][0], X12 = +_2[1][0];
      Y02 = +_2[0][1], Y12 = +_2[1][1];
      if (X02 > X12) _2 = X02, X02 = X12, X12 = _2;
      if (Y02 > Y12) _2 = Y02, Y02 = Y12, Y12 = _2;
      return graticule2.precision(precision);
    };
    graticule2.extentMinor = function(_2) {
      if (!arguments.length) return [[x05, y05], [x12, y12]];
      x05 = +_2[0][0], x12 = +_2[1][0];
      y05 = +_2[0][1], y12 = +_2[1][1];
      if (x05 > x12) _2 = x05, x05 = x12, x12 = _2;
      if (y05 > y12) _2 = y05, y05 = y12, y12 = _2;
      return graticule2.precision(precision);
    };
    graticule2.step = function(_2) {
      if (!arguments.length) return graticule2.stepMinor();
      return graticule2.stepMajor(_2).stepMinor(_2);
    };
    graticule2.stepMajor = function(_2) {
      if (!arguments.length) return [DX, DY];
      DX = +_2[0], DY = +_2[1];
      return graticule2;
    };
    graticule2.stepMinor = function(_2) {
      if (!arguments.length) return [dx, dy];
      dx = +_2[0], dy = +_2[1];
      return graticule2;
    };
    graticule2.precision = function(_2) {
      if (!arguments.length) return precision;
      precision = +_2;
      x3 = graticuleX(y05, y12, 90);
      y3 = graticuleY(x05, x12, precision);
      X = graticuleX(Y02, Y12, 90);
      Y = graticuleY(X02, X12, precision);
      return graticule2;
    };
    return graticule2.extentMajor([[-180, -90 + epsilon3], [180, 90 - epsilon3]]).extentMinor([[-180, -80 - epsilon3], [180, 80 + epsilon3]]);
  }
  function graticule10() {
    return graticule()();
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/identity.js
  var identity_default4 = (x3) => x3;

  // ../../engine/rails_design/node_modules/d3-geo/src/path/area.js
  var areaSum = new Adder();
  var areaRingSum = new Adder();
  var x00;
  var y00;
  var x0;
  var y0;
  var areaStream = {
    point: noop2,
    lineStart: noop2,
    lineEnd: noop2,
    polygonStart: function() {
      areaStream.lineStart = areaRingStart;
      areaStream.lineEnd = areaRingEnd;
    },
    polygonEnd: function() {
      areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop2;
      areaSum.add(abs2(areaRingSum));
      areaRingSum = new Adder();
    },
    result: function() {
      var area2 = areaSum / 2;
      areaSum = new Adder();
      return area2;
    }
  };
  function areaRingStart() {
    areaStream.point = areaPointFirst;
  }
  function areaPointFirst(x3, y3) {
    areaStream.point = areaPoint;
    x00 = x0 = x3, y00 = y0 = y3;
  }
  function areaPoint(x3, y3) {
    areaRingSum.add(y0 * x3 - x0 * y3);
    x0 = x3, y0 = y3;
  }
  function areaRingEnd() {
    areaPoint(x00, y00);
  }
  var area_default2 = areaStream;

  // ../../engine/rails_design/node_modules/d3-geo/src/path/bounds.js
  var x02 = Infinity;
  var y02 = x02;
  var x1 = -x02;
  var y1 = x1;
  var boundsStream = {
    point: boundsPoint,
    lineStart: noop2,
    lineEnd: noop2,
    polygonStart: noop2,
    polygonEnd: noop2,
    result: function() {
      var bounds = [[x02, y02], [x1, y1]];
      x1 = y1 = -(y02 = x02 = Infinity);
      return bounds;
    }
  };
  function boundsPoint(x3, y3) {
    if (x3 < x02) x02 = x3;
    if (x3 > x1) x1 = x3;
    if (y3 < y02) y02 = y3;
    if (y3 > y1) y1 = y3;
  }
  var bounds_default = boundsStream;

  // ../../engine/rails_design/node_modules/d3-geo/src/path/centroid.js
  var X0 = 0;
  var Y0 = 0;
  var Z0 = 0;
  var X1 = 0;
  var Y1 = 0;
  var Z1 = 0;
  var X2 = 0;
  var Y2 = 0;
  var Z2 = 0;
  var x002;
  var y002;
  var x03;
  var y03;
  var centroidStream = {
    point: centroidPoint,
    lineStart: centroidLineStart,
    lineEnd: centroidLineEnd,
    polygonStart: function() {
      centroidStream.lineStart = centroidRingStart;
      centroidStream.lineEnd = centroidRingEnd;
    },
    polygonEnd: function() {
      centroidStream.point = centroidPoint;
      centroidStream.lineStart = centroidLineStart;
      centroidStream.lineEnd = centroidLineEnd;
    },
    result: function() {
      var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
      X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
      return centroid;
    }
  };
  function centroidPoint(x3, y3) {
    X0 += x3;
    Y0 += y3;
    ++Z0;
  }
  function centroidLineStart() {
    centroidStream.point = centroidPointFirstLine;
  }
  function centroidPointFirstLine(x3, y3) {
    centroidStream.point = centroidPointLine;
    centroidPoint(x03 = x3, y03 = y3);
  }
  function centroidPointLine(x3, y3) {
    var dx = x3 - x03, dy = y3 - y03, z = sqrt2(dx * dx + dy * dy);
    X1 += z * (x03 + x3) / 2;
    Y1 += z * (y03 + y3) / 2;
    Z1 += z;
    centroidPoint(x03 = x3, y03 = y3);
  }
  function centroidLineEnd() {
    centroidStream.point = centroidPoint;
  }
  function centroidRingStart() {
    centroidStream.point = centroidPointFirstRing;
  }
  function centroidRingEnd() {
    centroidPointRing(x002, y002);
  }
  function centroidPointFirstRing(x3, y3) {
    centroidStream.point = centroidPointRing;
    centroidPoint(x002 = x03 = x3, y002 = y03 = y3);
  }
  function centroidPointRing(x3, y3) {
    var dx = x3 - x03, dy = y3 - y03, z = sqrt2(dx * dx + dy * dy);
    X1 += z * (x03 + x3) / 2;
    Y1 += z * (y03 + y3) / 2;
    Z1 += z;
    z = y03 * x3 - x03 * y3;
    X2 += z * (x03 + x3);
    Y2 += z * (y03 + y3);
    Z2 += z * 3;
    centroidPoint(x03 = x3, y03 = y3);
  }
  var centroid_default = centroidStream;

  // ../../engine/rails_design/node_modules/d3-geo/src/path/context.js
  function PathContext(context) {
    this._context = context;
  }
  PathContext.prototype = {
    _radius: 4.5,
    pointRadius: function(_2) {
      return this._radius = _2, this;
    },
    polygonStart: function() {
      this._line = 0;
    },
    polygonEnd: function() {
      this._line = NaN;
    },
    lineStart: function() {
      this._point = 0;
    },
    lineEnd: function() {
      if (this._line === 0) this._context.closePath();
      this._point = NaN;
    },
    point: function(x3, y3) {
      switch (this._point) {
        case 0: {
          this._context.moveTo(x3, y3);
          this._point = 1;
          break;
        }
        case 1: {
          this._context.lineTo(x3, y3);
          break;
        }
        default: {
          this._context.moveTo(x3 + this._radius, y3);
          this._context.arc(x3, y3, this._radius, 0, tau3);
          break;
        }
      }
    },
    result: noop2
  };

  // ../../engine/rails_design/node_modules/d3-geo/src/path/measure.js
  var lengthSum = new Adder();
  var lengthRing;
  var x003;
  var y003;
  var x04;
  var y04;
  var lengthStream = {
    point: noop2,
    lineStart: function() {
      lengthStream.point = lengthPointFirst;
    },
    lineEnd: function() {
      if (lengthRing) lengthPoint(x003, y003);
      lengthStream.point = noop2;
    },
    polygonStart: function() {
      lengthRing = true;
    },
    polygonEnd: function() {
      lengthRing = null;
    },
    result: function() {
      var length5 = +lengthSum;
      lengthSum = new Adder();
      return length5;
    }
  };
  function lengthPointFirst(x3, y3) {
    lengthStream.point = lengthPoint;
    x003 = x04 = x3, y003 = y04 = y3;
  }
  function lengthPoint(x3, y3) {
    x04 -= x3, y04 -= y3;
    lengthSum.add(sqrt2(x04 * x04 + y04 * y04));
    x04 = x3, y04 = y3;
  }
  var measure_default = lengthStream;

  // ../../engine/rails_design/node_modules/d3-geo/src/path/string.js
  var cacheDigits;
  var cacheAppend;
  var cacheRadius;
  var cacheCircle;
  var PathString = class {
    constructor(digits) {
      this._append = digits == null ? append2 : appendRound2(digits);
      this._radius = 4.5;
      this._ = "";
    }
    pointRadius(_2) {
      this._radius = +_2;
      return this;
    }
    polygonStart() {
      this._line = 0;
    }
    polygonEnd() {
      this._line = NaN;
    }
    lineStart() {
      this._point = 0;
    }
    lineEnd() {
      if (this._line === 0) this._ += "Z";
      this._point = NaN;
    }
    point(x3, y3) {
      switch (this._point) {
        case 0: {
          this._append`M${x3},${y3}`;
          this._point = 1;
          break;
        }
        case 1: {
          this._append`L${x3},${y3}`;
          break;
        }
        default: {
          this._append`M${x3},${y3}`;
          if (this._radius !== cacheRadius || this._append !== cacheAppend) {
            const r = this._radius;
            const s2 = this._;
            this._ = "";
            this._append`m0,${r}a${r},${r} 0 1,1 0,${-2 * r}a${r},${r} 0 1,1 0,${2 * r}z`;
            cacheRadius = r;
            cacheAppend = this._append;
            cacheCircle = this._;
            this._ = s2;
          }
          this._ += cacheCircle;
          break;
        }
      }
    }
    result() {
      const result = this._;
      this._ = "";
      return result.length ? result : null;
    }
  };
  function append2(strings) {
    let i = 1;
    this._ += strings[0];
    for (const j = strings.length; i < j; ++i) {
      this._ += arguments[i] + strings[i];
    }
  }
  function appendRound2(digits) {
    const d2 = Math.floor(digits);
    if (!(d2 >= 0)) throw new RangeError(`invalid digits: ${digits}`);
    if (d2 > 15) return append2;
    if (d2 !== cacheDigits) {
      const k = 10 ** d2;
      cacheDigits = d2;
      cacheAppend = function append3(strings) {
        let i = 1;
        this._ += strings[0];
        for (const j = strings.length; i < j; ++i) {
          this._ += Math.round(arguments[i] * k) / k + strings[i];
        }
      };
    }
    return cacheAppend;
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/path/index.js
  function path_default2(projection3, context) {
    let digits = 3, pointRadius = 4.5, projectionStream, contextStream;
    function path2(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        stream_default(object, projectionStream(contextStream));
      }
      return contextStream.result();
    }
    path2.area = function(object) {
      stream_default(object, projectionStream(area_default2));
      return area_default2.result();
    };
    path2.measure = function(object) {
      stream_default(object, projectionStream(measure_default));
      return measure_default.result();
    };
    path2.bounds = function(object) {
      stream_default(object, projectionStream(bounds_default));
      return bounds_default.result();
    };
    path2.centroid = function(object) {
      stream_default(object, projectionStream(centroid_default));
      return centroid_default.result();
    };
    path2.projection = function(_2) {
      if (!arguments.length) return projection3;
      projectionStream = _2 == null ? (projection3 = null, identity_default4) : (projection3 = _2).stream;
      return path2;
    };
    path2.context = function(_2) {
      if (!arguments.length) return context;
      contextStream = _2 == null ? (context = null, new PathString(digits)) : new PathContext(context = _2);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return path2;
    };
    path2.pointRadius = function(_2) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
      return path2;
    };
    path2.digits = function(_2) {
      if (!arguments.length) return digits;
      if (_2 == null) digits = null;
      else {
        const d2 = Math.floor(_2);
        if (!(d2 >= 0)) throw new RangeError(`invalid digits: ${_2}`);
        digits = d2;
      }
      if (context === null) contextStream = new PathString(digits);
      return path2;
    };
    return path2.projection(projection3).digits(digits).context(context);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/transform.js
  function transformer(methods2) {
    return function(stream) {
      var s2 = new TransformStream();
      for (var key in methods2) s2[key] = methods2[key];
      s2.stream = stream;
      return s2;
    };
  }
  function TransformStream() {
  }
  TransformStream.prototype = {
    constructor: TransformStream,
    point: function(x3, y3) {
      this.stream.point(x3, y3);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/fit.js
  function fit(projection3, fitBounds, object) {
    var clip = projection3.clipExtent && projection3.clipExtent();
    projection3.scale(150).translate([0, 0]);
    if (clip != null) projection3.clipExtent(null);
    stream_default(object, projection3.stream(bounds_default));
    fitBounds(bounds_default.result());
    if (clip != null) projection3.clipExtent(clip);
    return projection3;
  }
  function fitExtent(projection3, extent2, object) {
    return fit(projection3, function(b) {
      var w = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x3 = +extent2[0][0] + (w - k * (b[1][0] + b[0][0])) / 2, y3 = +extent2[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
      projection3.scale(150 * k).translate([x3, y3]);
    }, object);
  }
  function fitSize(projection3, size2, object) {
    return fitExtent(projection3, [[0, 0], size2], object);
  }
  function fitWidth(projection3, width, object) {
    return fit(projection3, function(b) {
      var w = +width, k = w / (b[1][0] - b[0][0]), x3 = (w - k * (b[1][0] + b[0][0])) / 2, y3 = -k * b[0][1];
      projection3.scale(150 * k).translate([x3, y3]);
    }, object);
  }
  function fitHeight(projection3, height, object) {
    return fit(projection3, function(b) {
      var h = +height, k = h / (b[1][1] - b[0][1]), x3 = -k * b[0][0], y3 = (h - k * (b[1][1] + b[0][1])) / 2;
      projection3.scale(150 * k).translate([x3, y3]);
    }, object);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/resample.js
  var maxDepth = 16;
  var cosMinDistance = cos2(30 * radians2);
  function resample_default(project, delta2) {
    return +delta2 ? resample(project, delta2) : resampleNone(project);
  }
  function resampleNone(project) {
    return transformer({
      point: function(x3, y3) {
        x3 = project(x3, y3);
        this.stream.point(x3[0], x3[1]);
      }
    });
  }
  function resample(project, delta2) {
    function resampleLineTo(x05, y05, lambda0, a0, b0, c0, x12, y12, lambda1, a1, b1, c1, depth, stream) {
      var dx = x12 - x05, dy = y12 - y05, d2 = dx * dx + dy * dy;
      if (d2 > 4 * delta2 && depth--) {
        var a3 = a0 + a1, b = b0 + b1, c5 = c0 + c1, m3 = sqrt2(a3 * a3 + b * b + c5 * c5), phi2 = asin2(c5 /= m3), lambda2 = abs2(abs2(c5) - 1) < epsilon3 || abs2(lambda0 - lambda1) < epsilon3 ? (lambda0 + lambda1) / 2 : atan22(b, a3), p2 = project(lambda2, phi2), x22 = p2[0], y22 = p2[1], dx2 = x22 - x05, dy2 = y22 - y05, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > delta2 || abs2((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x05, y05, lambda0, a0, b0, c0, x22, y22, lambda2, a3 /= m3, b /= m3, c5, depth, stream);
          stream.point(x22, y22);
          resampleLineTo(x22, y22, lambda2, a3, b, c5, x12, y12, lambda1, a1, b1, c1, depth, stream);
        }
      }
    }
    return function(stream) {
      var lambda00, x004, y004, a00, b00, c00, lambda0, x05, y05, a0, b0, c0;
      var resampleStream = {
        point: point6,
        lineStart,
        lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resampleStream.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resampleStream.lineStart = lineStart;
        }
      };
      function point6(x3, y3) {
        x3 = project(x3, y3);
        stream.point(x3[0], x3[1]);
      }
      function lineStart() {
        x05 = NaN;
        resampleStream.point = linePoint;
        stream.lineStart();
      }
      function linePoint(lambda, phi2) {
        var c5 = cartesian([lambda, phi2]), p2 = project(lambda, phi2);
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x05 = p2[0], y05 = p2[1], lambda0 = lambda, a0 = c5[0], b0 = c5[1], c0 = c5[2], maxDepth, stream);
        stream.point(x05, y05);
      }
      function lineEnd() {
        resampleStream.point = point6;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resampleStream.point = ringPoint;
        resampleStream.lineEnd = ringEnd;
      }
      function ringPoint(lambda, phi2) {
        linePoint(lambda00 = lambda, phi2), x004 = x05, y004 = y05, a00 = a0, b00 = b0, c00 = c0;
        resampleStream.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x05, y05, lambda0, a0, b0, c0, x004, y004, lambda00, a00, b00, c00, maxDepth, stream);
        resampleStream.lineEnd = lineEnd;
        lineEnd();
      }
      return resampleStream;
    };
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/index.js
  var transformRadians = transformer({
    point: function(x3, y3) {
      this.stream.point(x3 * radians2, y3 * radians2);
    }
  });
  function transformRotate(rotate4) {
    return transformer({
      point: function(x3, y3) {
        var r = rotate4(x3, y3);
        return this.stream.point(r[0], r[1]);
      }
    });
  }
  function scaleTranslate(k, dx, dy, sx, sy) {
    function transform(x3, y3) {
      x3 *= sx;
      y3 *= sy;
      return [dx + k * x3, dy - k * y3];
    }
    transform.invert = function(x3, y3) {
      return [(x3 - dx) / k * sx, (dy - y3) / k * sy];
    };
    return transform;
  }
  function scaleTranslateRotate(k, dx, dy, sx, sy, alpha) {
    if (!alpha) return scaleTranslate(k, dx, dy, sx, sy);
    var cosAlpha = cos2(alpha), sinAlpha = sin2(alpha), a3 = cosAlpha * k, b = sinAlpha * k, ai = cosAlpha / k, bi = sinAlpha / k, ci = (sinAlpha * dy - cosAlpha * dx) / k, fi = (sinAlpha * dx + cosAlpha * dy) / k;
    function transform(x3, y3) {
      x3 *= sx;
      y3 *= sy;
      return [a3 * x3 - b * y3 + dx, dy - b * x3 - a3 * y3];
    }
    transform.invert = function(x3, y3) {
      return [sx * (ai * x3 - bi * y3 + ci), sy * (fi - bi * x3 - ai * y3)];
    };
    return transform;
  }
  function projection2(project) {
    return projectionMutator(function() {
      return project;
    })();
  }
  function projectionMutator(projectAt) {
    var project, k = 150, x3 = 480, y3 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate4, alpha = 0, sx = 1, sy = 1, theta = null, preclip = antimeridian_default, x05 = null, y05, x12, y12, postclip = identity_default4, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache3, cacheStream;
    function projection3(point6) {
      return projectRotateTransform(point6[0] * radians2, point6[1] * radians2);
    }
    function invert5(point6) {
      point6 = projectRotateTransform.invert(point6[0], point6[1]);
      return point6 && [point6[0] * degrees2, point6[1] * degrees2];
    }
    projection3.stream = function(stream) {
      return cache3 && cacheStream === stream ? cache3 : cache3 = transformRadians(transformRotate(rotate4)(preclip(projectResample(postclip(cacheStream = stream)))));
    };
    projection3.preclip = function(_2) {
      return arguments.length ? (preclip = _2, theta = void 0, reset()) : preclip;
    };
    projection3.postclip = function(_2) {
      return arguments.length ? (postclip = _2, x05 = y05 = x12 = y12 = null, reset()) : postclip;
    };
    projection3.clipAngle = function(_2) {
      return arguments.length ? (preclip = +_2 ? circle_default(theta = _2 * radians2) : (theta = null, antimeridian_default), reset()) : theta * degrees2;
    };
    projection3.clipExtent = function(_2) {
      return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x12 = y12 = null, identity_default4) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
    };
    projection3.scale = function(_2) {
      return arguments.length ? (k = +_2, recenter()) : k;
    };
    projection3.translate = function(_2) {
      return arguments.length ? (x3 = +_2[0], y3 = +_2[1], recenter()) : [x3, y3];
    };
    projection3.center = function(_2) {
      return arguments.length ? (lambda = _2[0] % 360 * radians2, phi2 = _2[1] % 360 * radians2, recenter()) : [lambda * degrees2, phi2 * degrees2];
    };
    projection3.rotate = function(_2) {
      return arguments.length ? (deltaLambda = _2[0] % 360 * radians2, deltaPhi = _2[1] % 360 * radians2, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians2 : 0, recenter()) : [deltaLambda * degrees2, deltaPhi * degrees2, deltaGamma * degrees2];
    };
    projection3.angle = function(_2) {
      return arguments.length ? (alpha = _2 % 360 * radians2, recenter()) : alpha * degrees2;
    };
    projection3.reflectX = function(_2) {
      return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
    };
    projection3.reflectY = function(_2) {
      return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
    };
    projection3.precision = function(_2) {
      return arguments.length ? (projectResample = resample_default(projectTransform, delta2 = _2 * _2), reset()) : sqrt2(delta2);
    };
    projection3.fitExtent = function(extent2, object) {
      return fitExtent(projection3, extent2, object);
    };
    projection3.fitSize = function(size2, object) {
      return fitSize(projection3, size2, object);
    };
    projection3.fitWidth = function(width, object) {
      return fitWidth(projection3, width, object);
    };
    projection3.fitHeight = function(height, object) {
      return fitHeight(projection3, height, object);
    };
    function recenter() {
      var center2 = scaleTranslateRotate(k, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform = scaleTranslateRotate(k, x3 - center2[0], y3 - center2[1], sx, sy, alpha);
      rotate4 = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
      projectTransform = compose_default(project, transform);
      projectRotateTransform = compose_default(rotate4, projectTransform);
      projectResample = resample_default(projectTransform, delta2);
      return reset();
    }
    function reset() {
      cache3 = cacheStream = null;
      return projection3;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection3.invert = project.invert && invert5;
      return recenter();
    };
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/conic.js
  function conicProjection(projectAt) {
    var phi0 = 0, phi1 = pi3 / 3, m3 = projectionMutator(projectAt), p2 = m3(phi0, phi1);
    p2.parallels = function(_2) {
      return arguments.length ? m3(phi0 = _2[0] * radians2, phi1 = _2[1] * radians2) : [phi0 * degrees2, phi1 * degrees2];
    };
    return p2;
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/cylindricalEqualArea.js
  function cylindricalEqualAreaRaw(phi0) {
    var cosPhi0 = cos2(phi0);
    function forward(lambda, phi2) {
      return [lambda * cosPhi0, sin2(phi2) / cosPhi0];
    }
    forward.invert = function(x3, y3) {
      return [x3 / cosPhi0, asin2(y3 * cosPhi0)];
    };
    return forward;
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/conicEqualArea.js
  function conicEqualAreaRaw(y05, y12) {
    var sy0 = sin2(y05), n2 = (sy0 + sin2(y12)) / 2;
    if (abs2(n2) < epsilon3) return cylindricalEqualAreaRaw(y05);
    var c5 = 1 + sy0 * (2 * n2 - sy0), r0 = sqrt2(c5) / n2;
    function project(x3, y3) {
      var r = sqrt2(c5 - 2 * n2 * sin2(y3)) / n2;
      return [r * sin2(x3 *= n2), r0 - r * cos2(x3)];
    }
    project.invert = function(x3, y3) {
      var r0y = r0 - y3, l2 = atan22(x3, abs2(r0y)) * sign2(r0y);
      if (r0y * n2 < 0)
        l2 -= pi3 * sign2(x3) * sign2(r0y);
      return [l2 / n2, asin2((c5 - (x3 * x3 + r0y * r0y) * n2 * n2) / (2 * n2))];
    };
    return project;
  }
  function conicEqualArea_default() {
    return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/albers.js
  function albers_default() {
    return conicEqualArea_default().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/albersUsa.js
  function multiplex(streams) {
    var n2 = streams.length;
    return {
      point: function(x3, y3) {
        var i = -1;
        while (++i < n2) streams[i].point(x3, y3);
      },
      sphere: function() {
        var i = -1;
        while (++i < n2) streams[i].sphere();
      },
      lineStart: function() {
        var i = -1;
        while (++i < n2) streams[i].lineStart();
      },
      lineEnd: function() {
        var i = -1;
        while (++i < n2) streams[i].lineEnd();
      },
      polygonStart: function() {
        var i = -1;
        while (++i < n2) streams[i].polygonStart();
      },
      polygonEnd: function() {
        var i = -1;
        while (++i < n2) streams[i].polygonEnd();
      }
    };
  }
  function albersUsa_default() {
    var cache3, cacheStream, lower48 = albers_default(), lower48Point, alaska = conicEqualArea_default().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea_default().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point6, pointStream = { point: function(x3, y3) {
      point6 = [x3, y3];
    } };
    function albersUsa(coordinates) {
      var x3 = coordinates[0], y3 = coordinates[1];
      return point6 = null, (lower48Point.point(x3, y3), point6) || (alaskaPoint.point(x3, y3), point6) || (hawaiiPoint.point(x3, y3), point6);
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x3 = (coordinates[0] - t[0]) / k, y3 = (coordinates[1] - t[1]) / k;
      return (y3 >= 0.12 && y3 < 0.234 && x3 >= -0.425 && x3 < -0.214 ? alaska : y3 >= 0.166 && y3 < 0.234 && x3 >= -0.214 && x3 < -0.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      return cache3 && cacheStream === stream ? cache3 : cache3 = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
    };
    albersUsa.precision = function(_2) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
      return reset();
    };
    albersUsa.scale = function(_2) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_2) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x3 = +_2[0], y3 = +_2[1];
      lower48Point = lower48.translate(_2).clipExtent([[x3 - 0.455 * k, y3 - 0.238 * k], [x3 + 0.455 * k, y3 + 0.238 * k]]).stream(pointStream);
      alaskaPoint = alaska.translate([x3 - 0.307 * k, y3 + 0.201 * k]).clipExtent([[x3 - 0.425 * k + epsilon3, y3 + 0.12 * k + epsilon3], [x3 - 0.214 * k - epsilon3, y3 + 0.234 * k - epsilon3]]).stream(pointStream);
      hawaiiPoint = hawaii.translate([x3 - 0.205 * k, y3 + 0.212 * k]).clipExtent([[x3 - 0.214 * k + epsilon3, y3 + 0.166 * k + epsilon3], [x3 - 0.115 * k - epsilon3, y3 + 0.234 * k - epsilon3]]).stream(pointStream);
      return reset();
    };
    albersUsa.fitExtent = function(extent2, object) {
      return fitExtent(albersUsa, extent2, object);
    };
    albersUsa.fitSize = function(size2, object) {
      return fitSize(albersUsa, size2, object);
    };
    albersUsa.fitWidth = function(width, object) {
      return fitWidth(albersUsa, width, object);
    };
    albersUsa.fitHeight = function(height, object) {
      return fitHeight(albersUsa, height, object);
    };
    function reset() {
      cache3 = cacheStream = null;
      return albersUsa;
    }
    return albersUsa.scale(1070);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/azimuthal.js
  function azimuthalRaw(scale9) {
    return function(x3, y3) {
      var cx = cos2(x3), cy = cos2(y3), k = scale9(cx * cy);
      if (k === Infinity) return [2, 0];
      return [
        k * cy * sin2(x3),
        k * sin2(y3)
      ];
    };
  }
  function azimuthalInvert(angle4) {
    return function(x3, y3) {
      var z = sqrt2(x3 * x3 + y3 * y3), c5 = angle4(z), sc = sin2(c5), cc = cos2(c5);
      return [
        atan22(x3 * sc, z * cc),
        asin2(z && y3 * sc / z)
      ];
    };
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/azimuthalEqualArea.js
  var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
    return sqrt2(2 / (1 + cxcy));
  });
  azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
    return 2 * asin2(z / 2);
  });
  function azimuthalEqualArea_default() {
    return projection2(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/azimuthalEquidistant.js
  var azimuthalEquidistantRaw = azimuthalRaw(function(c5) {
    return (c5 = acos2(c5)) && c5 / sin2(c5);
  });
  azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
    return z;
  });
  function azimuthalEquidistant_default() {
    return projection2(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/mercator.js
  function mercatorRaw(lambda, phi2) {
    return [lambda, log(tan((halfPi2 + phi2) / 2))];
  }
  mercatorRaw.invert = function(x3, y3) {
    return [x3, 2 * atan(exp2(y3)) - halfPi2];
  };
  function mercator_default() {
    return mercatorProjection(mercatorRaw).scale(961 / tau3);
  }
  function mercatorProjection(project) {
    var m3 = projection2(project), center2 = m3.center, scale9 = m3.scale, translate3 = m3.translate, clipExtent = m3.clipExtent, x05 = null, y05, x12, y12;
    m3.scale = function(_2) {
      return arguments.length ? (scale9(_2), reclip()) : scale9();
    };
    m3.translate = function(_2) {
      return arguments.length ? (translate3(_2), reclip()) : translate3();
    };
    m3.center = function(_2) {
      return arguments.length ? (center2(_2), reclip()) : center2();
    };
    m3.clipExtent = function(_2) {
      return arguments.length ? (_2 == null ? x05 = y05 = x12 = y12 = null : (x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reclip()) : x05 == null ? null : [[x05, y05], [x12, y12]];
    };
    function reclip() {
      var k = pi3 * scale9(), t = m3(rotation_default(m3.rotate()).invert([0, 0]));
      return clipExtent(x05 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x05), y05], [Math.min(t[0] + k, x12), y12]] : [[x05, Math.max(t[1] - k, y05)], [x12, Math.min(t[1] + k, y12)]]);
    }
    return reclip();
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/conicConformal.js
  function tany(y3) {
    return tan((halfPi2 + y3) / 2);
  }
  function conicConformalRaw(y05, y12) {
    var cy0 = cos2(y05), n2 = y05 === y12 ? sin2(y05) : log(cy0 / cos2(y12)) / log(tany(y12) / tany(y05)), f = cy0 * pow2(tany(y05), n2) / n2;
    if (!n2) return mercatorRaw;
    function project(x3, y3) {
      if (f > 0) {
        if (y3 < -halfPi2 + epsilon3) y3 = -halfPi2 + epsilon3;
      } else {
        if (y3 > halfPi2 - epsilon3) y3 = halfPi2 - epsilon3;
      }
      var r = f / pow2(tany(y3), n2);
      return [r * sin2(n2 * x3), f - r * cos2(n2 * x3)];
    }
    project.invert = function(x3, y3) {
      var fy = f - y3, r = sign2(n2) * sqrt2(x3 * x3 + fy * fy), l2 = atan22(x3, abs2(fy)) * sign2(fy);
      if (fy * n2 < 0)
        l2 -= pi3 * sign2(x3) * sign2(fy);
      return [l2 / n2, 2 * atan(pow2(f / r, 1 / n2)) - halfPi2];
    };
    return project;
  }
  function conicConformal_default() {
    return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/equirectangular.js
  function equirectangularRaw(lambda, phi2) {
    return [lambda, phi2];
  }
  equirectangularRaw.invert = equirectangularRaw;
  function equirectangular_default() {
    return projection2(equirectangularRaw).scale(152.63);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/conicEquidistant.js
  function conicEquidistantRaw(y05, y12) {
    var cy0 = cos2(y05), n2 = y05 === y12 ? sin2(y05) : (cy0 - cos2(y12)) / (y12 - y05), g = cy0 / n2 + y05;
    if (abs2(n2) < epsilon3) return equirectangularRaw;
    function project(x3, y3) {
      var gy = g - y3, nx = n2 * x3;
      return [gy * sin2(nx), g - gy * cos2(nx)];
    }
    project.invert = function(x3, y3) {
      var gy = g - y3, l2 = atan22(x3, abs2(gy)) * sign2(gy);
      if (gy * n2 < 0)
        l2 -= pi3 * sign2(x3) * sign2(gy);
      return [l2 / n2, g - sign2(n2) * sqrt2(x3 * x3 + gy * gy)];
    };
    return project;
  }
  function conicEquidistant_default() {
    return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/equalEarth.js
  var A1 = 1.340264;
  var A22 = -0.081106;
  var A3 = 893e-6;
  var A4 = 3796e-6;
  var M = sqrt2(3) / 2;
  var iterations = 12;
  function equalEarthRaw(lambda, phi2) {
    var l2 = asin2(M * sin2(phi2)), l22 = l2 * l2, l6 = l22 * l22 * l22;
    return [
      lambda * cos2(l2) / (M * (A1 + 3 * A22 * l22 + l6 * (7 * A3 + 9 * A4 * l22))),
      l2 * (A1 + A22 * l22 + l6 * (A3 + A4 * l22))
    ];
  }
  equalEarthRaw.invert = function(x3, y3) {
    var l2 = y3, l22 = l2 * l2, l6 = l22 * l22 * l22;
    for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
      fy = l2 * (A1 + A22 * l22 + l6 * (A3 + A4 * l22)) - y3;
      fpy = A1 + 3 * A22 * l22 + l6 * (7 * A3 + 9 * A4 * l22);
      l2 -= delta = fy / fpy, l22 = l2 * l2, l6 = l22 * l22 * l22;
      if (abs2(delta) < epsilon22) break;
    }
    return [
      M * x3 * (A1 + 3 * A22 * l22 + l6 * (7 * A3 + 9 * A4 * l22)) / cos2(l2),
      asin2(sin2(l2) / M)
    ];
  };
  function equalEarth_default() {
    return projection2(equalEarthRaw).scale(177.158);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/gnomonic.js
  function gnomonicRaw(x3, y3) {
    var cy = cos2(y3), k = cos2(x3) * cy;
    return [cy * sin2(x3) / k, sin2(y3) / k];
  }
  gnomonicRaw.invert = azimuthalInvert(atan);
  function gnomonic_default() {
    return projection2(gnomonicRaw).scale(144.049).clipAngle(60);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/identity.js
  function identity_default5() {
    var k = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x05 = null, y05, x12, y12, kx = 1, ky = 1, transform = transformer({
      point: function(x3, y3) {
        var p2 = projection3([x3, y3]);
        this.stream.point(p2[0], p2[1]);
      }
    }), postclip = identity_default4, cache3, cacheStream;
    function reset() {
      kx = k * sx;
      ky = k * sy;
      cache3 = cacheStream = null;
      return projection3;
    }
    function projection3(p2) {
      var x3 = p2[0] * kx, y3 = p2[1] * ky;
      if (alpha) {
        var t = y3 * ca - x3 * sa;
        x3 = x3 * ca + y3 * sa;
        y3 = t;
      }
      return [x3 + tx, y3 + ty];
    }
    projection3.invert = function(p2) {
      var x3 = p2[0] - tx, y3 = p2[1] - ty;
      if (alpha) {
        var t = y3 * ca + x3 * sa;
        x3 = x3 * ca - y3 * sa;
        y3 = t;
      }
      return [x3 / kx, y3 / ky];
    };
    projection3.stream = function(stream) {
      return cache3 && cacheStream === stream ? cache3 : cache3 = transform(postclip(cacheStream = stream));
    };
    projection3.postclip = function(_2) {
      return arguments.length ? (postclip = _2, x05 = y05 = x12 = y12 = null, reset()) : postclip;
    };
    projection3.clipExtent = function(_2) {
      return arguments.length ? (postclip = _2 == null ? (x05 = y05 = x12 = y12 = null, identity_default4) : clipRectangle(x05 = +_2[0][0], y05 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset()) : x05 == null ? null : [[x05, y05], [x12, y12]];
    };
    projection3.scale = function(_2) {
      return arguments.length ? (k = +_2, reset()) : k;
    };
    projection3.translate = function(_2) {
      return arguments.length ? (tx = +_2[0], ty = +_2[1], reset()) : [tx, ty];
    };
    projection3.angle = function(_2) {
      return arguments.length ? (alpha = _2 % 360 * radians2, sa = sin2(alpha), ca = cos2(alpha), reset()) : alpha * degrees2;
    };
    projection3.reflectX = function(_2) {
      return arguments.length ? (sx = _2 ? -1 : 1, reset()) : sx < 0;
    };
    projection3.reflectY = function(_2) {
      return arguments.length ? (sy = _2 ? -1 : 1, reset()) : sy < 0;
    };
    projection3.fitExtent = function(extent2, object) {
      return fitExtent(projection3, extent2, object);
    };
    projection3.fitSize = function(size2, object) {
      return fitSize(projection3, size2, object);
    };
    projection3.fitWidth = function(width, object) {
      return fitWidth(projection3, width, object);
    };
    projection3.fitHeight = function(height, object) {
      return fitHeight(projection3, height, object);
    };
    return projection3;
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/naturalEarth1.js
  function naturalEarth1Raw(lambda, phi2) {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    return [
      lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
      phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
    ];
  }
  naturalEarth1Raw.invert = function(x3, y3) {
    var phi2 = y3, i = 25, delta;
    do {
      var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
      phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y3) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
    } while (abs2(delta) > epsilon3 && --i > 0);
    return [
      x3 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
      phi2
    ];
  };
  function naturalEarth1_default() {
    return projection2(naturalEarth1Raw).scale(175.295);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/orthographic.js
  function orthographicRaw(x3, y3) {
    return [cos2(y3) * sin2(x3), sin2(y3)];
  }
  orthographicRaw.invert = azimuthalInvert(asin2);
  function orthographic_default() {
    return projection2(orthographicRaw).scale(249.5).clipAngle(90 + epsilon3);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/stereographic.js
  function stereographicRaw(x3, y3) {
    var cy = cos2(y3), k = 1 + cos2(x3) * cy;
    return [cy * sin2(x3) / k, sin2(y3) / k];
  }
  stereographicRaw.invert = azimuthalInvert(function(z) {
    return 2 * atan(z);
  });
  function stereographic_default() {
    return projection2(stereographicRaw).scale(250).clipAngle(142);
  }

  // ../../engine/rails_design/node_modules/d3-geo/src/projection/transverseMercator.js
  function transverseMercatorRaw(lambda, phi2) {
    return [log(tan((halfPi2 + phi2) / 2)), -lambda];
  }
  transverseMercatorRaw.invert = function(x3, y3) {
    return [-y3, 2 * atan(exp2(x3)) - halfPi2];
  };
  function transverseMercator_default() {
    var m3 = mercatorProjection(transverseMercatorRaw), center2 = m3.center, rotate4 = m3.rotate;
    m3.center = function(_2) {
      return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
    };
    m3.rotate = function(_2) {
      return arguments.length ? rotate4([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate4(), [_2[0], _2[1], _2[2] - 90]);
    };
    return rotate4([0, 0, 90]).scale(159.155);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/composition/d3Projection.js
  var d3Projection_exports = {};
  __export(d3Projection_exports, {
    geoAlbers: () => albers_default,
    geoAlbersUsa: () => albersUsa_default,
    geoAzimuthalEqualArea: () => azimuthalEqualArea_default,
    geoAzimuthalEqualAreaRaw: () => azimuthalEqualAreaRaw,
    geoAzimuthalEquidistant: () => azimuthalEquidistant_default,
    geoAzimuthalEquidistantRaw: () => azimuthalEquidistantRaw,
    geoConicConformal: () => conicConformal_default,
    geoConicConformalRaw: () => conicConformalRaw,
    geoConicEqualArea: () => conicEqualArea_default,
    geoConicEqualAreaRaw: () => conicEqualAreaRaw,
    geoConicEquidistant: () => conicEquidistant_default,
    geoConicEquidistantRaw: () => conicEquidistantRaw,
    geoEqualEarth: () => equalEarth_default,
    geoEqualEarthRaw: () => equalEarthRaw,
    geoEquirectangular: () => equirectangular_default,
    geoEquirectangularRaw: () => equirectangularRaw,
    geoGnomonic: () => gnomonic_default,
    geoGnomonicRaw: () => gnomonicRaw,
    geoIdentity: () => identity_default5,
    geoMercator: () => mercator_default,
    geoMercatorRaw: () => mercatorRaw,
    geoNaturalEarth1: () => naturalEarth1_default,
    geoNaturalEarth1Raw: () => naturalEarth1Raw,
    geoOrthographic: () => orthographic_default,
    geoOrthographicRaw: () => orthographicRaw,
    geoProjection: () => projection2,
    geoProjectionMutator: () => projectionMutator,
    geoStereographic: () => stereographic_default,
    geoStereographicRaw: () => stereographicRaw,
    geoTransverseMercator: () => transverseMercator_default,
    geoTransverseMercatorRaw: () => transverseMercatorRaw
  });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/composition/geoView.js
  var __rest70 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function normalizeProjection(type) {
    if (typeof type === "function")
      return type;
    const name2 = `geo${upper_first_default(type)}`;
    const projection3 = d3Projection_exports[name2];
    if (!projection3)
      throw new Error(`Unknown coordinate: ${type}`);
    return projection3;
  }
  function mergeGeoJSON(gjs) {
    return {
      type: "FeatureCollection",
      features: gjs.flatMap((gj) => normalizeGeoJSON(gj).features)
    };
  }
  function normalizeGeoJSON(gj) {
    const types = {
      Point: "geometry",
      MultiPoint: "geometry",
      LineString: "geometry",
      MultiLineString: "geometry",
      Polygon: "geometry",
      MultiPolygon: "geometry",
      GeometryCollection: "geometry",
      Feature: "feature",
      FeatureCollection: "featureCollection"
    };
    if (!gj || !gj.type)
      return null;
    const type = types[gj.type];
    if (!type)
      return null;
    if (type === "geometry") {
      return {
        type: "FeatureCollection",
        features: [
          {
            type: "Feature",
            properties: {},
            geometry: gj
          }
        ]
      };
    } else if (type === "feature") {
      return {
        type: "FeatureCollection",
        features: [gj]
      };
    } else if (type === "featureCollection") {
      return gj;
    }
  }
  function setProjectionOptions(projection3, options) {
    var _a;
    for (const [key, value2] of Object.entries(options)) {
      (_a = projection3[key]) === null || _a === void 0 ? void 0 : _a.call(projection3, value2);
    }
  }
  function setProjectionSize(projection3, nodes, layout, options) {
    const defaultOutline = () => {
      const geoNodes = nodes.filter(isGeoPath);
      const sphere = geoNodes.find((d2) => d2.sphere);
      if (sphere)
        return { type: "Sphere" };
      return mergeGeoJSON(geoNodes.filter((d2) => !d2.sphere).flatMap((d2) => d2.data.value));
    };
    const { outline = defaultOutline() } = options;
    const { size: size2 = "fitExtent" } = options;
    if (size2 === "fitExtent") {
      return setFitExtent(projection3, outline, layout);
    } else if (size2 === "fitWidth") {
      return setFitWidth(projection3, outline, layout);
    }
  }
  function setFitExtent(projection3, object, layout) {
    const { x: x3, y: y3, width, height } = layout;
    projection3.fitExtent([
      [x3, y3],
      [width, height]
    ], object);
  }
  function setFitWidth(projection3, object, layout) {
    const { width, height } = layout;
    const [[x05, y05], [x12, y12]] = path_default2(projection3.fitWidth(width, object)).bounds(object);
    const dy = Math.ceil(y12 - y05);
    const l2 = Math.min(Math.ceil(x12 - x05), dy);
    const s2 = projection3.scale() * (l2 - 1) / l2;
    const [tx, ty] = projection3.translate();
    const t = ty + (height - dy) / 2;
    projection3.scale(s2).translate([tx, t]).precision(0.2);
  }
  function normalizeDataSource(node) {
    const { data: data2 } = node;
    if (Array.isArray(data2))
      return Object.assign(Object.assign({}, node), { data: { value: data2 } });
    const { type } = data2;
    if (type === "graticule10") {
      return Object.assign(Object.assign({}, node), { data: { value: [graticule10()] } });
    } else if (type === "sphere") {
      return Object.assign(Object.assign({}, node), { sphere: true, data: { value: [{ type: "Sphere" }] } });
    }
    return node;
  }
  function isGeoPath(d2) {
    return d2.type === "geoPath";
  }
  var GeoView = () => {
    return (options) => {
      const { children, coordinate: projection3 = {} } = options;
      if (!Array.isArray(children))
        return [];
      const { type = "equalEarth" } = projection3, projectionOptions = __rest70(projection3, ["type"]);
      const createProjection = normalizeProjection(type);
      const nodes = children.map(normalizeDataSource);
      let path2;
      function Geo() {
        return [
          [
            "custom",
            (x3, y3, width, height) => {
              const visual = createProjection();
              const layout = { x: x3, y: y3, width, height };
              setProjectionSize(visual, nodes, layout, projectionOptions);
              setProjectionOptions(visual, projectionOptions);
              path2 = path_default2(visual);
              const scaleX = new Linear({
                domain: [x3, x3 + width]
              });
              const scaleY = new Linear({
                domain: [y3, y3 + height]
              });
              const normalize10 = (point6) => {
                const visualPoint = visual(point6);
                if (!visualPoint)
                  return [null, null];
                const [vx, vy] = visualPoint;
                return [scaleX.map(vx), scaleY.map(vy)];
              };
              const normalizeInvert = (point6) => {
                if (!point6)
                  return null;
                const [px, py] = point6;
                const visualPoint = [scaleX.invert(px), scaleY.invert(py)];
                return visual.invert(visualPoint);
              };
              return {
                transform: (point6) => normalize10(point6),
                untransform: (point6) => normalizeInvert(point6)
              };
            }
          ]
        ];
      }
      function GeoPath2(options2) {
        const { style, tooltip: tooltip2 = {} } = options2;
        return Object.assign(Object.assign({}, options2), { type: "path", tooltip: maybeTooltip(tooltip2, {
          title: "id",
          items: [{ channel: "color" }]
        }), style: Object.assign(Object.assign({}, style), { d: (d2) => path2(d2) || [] }) });
      }
      const t = (d2) => isGeoPath(d2) ? GeoPath2(d2) : d2;
      return [
        Object.assign(Object.assign({}, options), { type: "view", scale: {
          x: { type: "identity" },
          y: { type: "identity" }
        }, axis: false, coordinate: { type: Geo }, children: nodes.flatMap(t) })
      ];
    };
  };
  GeoView.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/event.js
  function dataOf(element, view) {
    const { __data__: datum } = element;
    const { markKey, index: index4, seriesIndex } = datum;
    const { markState } = view;
    const selectedMark = Array.from(markState.keys()).find((mark) => mark.key === markKey);
    if (!selectedMark)
      return;
    if (seriesIndex) {
      return seriesIndex.map((i) => selectedMark.data[i]);
    }
    return selectedMark.data[index4];
  }
  function maybeComponentRoot(node) {
    return maybeRoot(node, (node2) => node2.className === "component");
  }
  function maybeElementRoot(node) {
    return maybeRoot(node, (node2) => node2.className === "element");
  }
  function maybeLabelRoot(node) {
    return maybeRoot(node, (node2) => node2.className === "label");
  }
  function bubblesEvent(eventType, view, emitter, predicate = (event) => true) {
    return (e3) => {
      if (!predicate(e3))
        return;
      emitter.emit(`plot:${eventType}`, e3);
      const { target } = e3;
      if (!target)
        return;
      const { className: className2 } = target;
      if (className2 === "plot")
        return;
      const elementRoot = maybeElementRoot(target);
      const componentRoot = maybeComponentRoot(target);
      const babelRoot = maybeLabelRoot(target);
      const root2 = elementRoot || componentRoot || babelRoot;
      if (!root2)
        return;
      const { className: elementType2, markType } = root2;
      const e1 = Object.assign(Object.assign({}, e3), { nativeEvent: true });
      if (elementType2 === "element") {
        e1["data"] = { data: dataOf(root2, view) };
        emitter.emit(`element:${eventType}`, e1);
        emitter.emit(`${markType}:${eventType}`, e1);
      } else if (elementType2 === "label") {
        e1["data"] = { data: root2.attributes.datum };
        emitter.emit(`label:${eventType}`, e1);
        emitter.emit(`${className2}:${eventType}`, e1);
      } else {
        emitter.emit(`component:${eventType}`, e1);
        emitter.emit(`${className2}:${eventType}`, e1);
      }
    };
  }
  function Event2() {
    return (context, _2, emitter) => {
      const { container, view } = context;
      const click = bubblesEvent(ChartEvent.CLICK, view, emitter, (e3) => e3.detail === 1);
      const dblclick2 = bubblesEvent(ChartEvent.DBLCLICK, view, emitter, (e3) => e3.detail === 2);
      const pointertap = bubblesEvent(ChartEvent.POINTER_TAP, view, emitter);
      const pointerdown = bubblesEvent(ChartEvent.POINTER_DOWN, view, emitter);
      const pointerup = bubblesEvent(ChartEvent.POINTER_UP, view, emitter);
      const pointerover = bubblesEvent(ChartEvent.POINTER_OVER, view, emitter);
      const pointerout = bubblesEvent(ChartEvent.POINTER_OUT, view, emitter);
      const pointermove = bubblesEvent(ChartEvent.POINTER_MOVE, view, emitter);
      const pointerenter = bubblesEvent(ChartEvent.POINTER_ENTER, view, emitter);
      const pointerleave = bubblesEvent(ChartEvent.POINTER_LEAVE, view, emitter);
      const pointerupoutside = bubblesEvent(ChartEvent.POINTER_UPOUTSIDE, view, emitter);
      const dragstart = bubblesEvent(ChartEvent.DRAG_START, view, emitter);
      const drag = bubblesEvent(ChartEvent.DRAG, view, emitter);
      const dragend = bubblesEvent(ChartEvent.DRAG_END, view, emitter);
      const dragenter = bubblesEvent(ChartEvent.DRAG_ENTER, view, emitter);
      const dragleave = bubblesEvent(ChartEvent.DRAG_LEAVE, view, emitter);
      const dragover = bubblesEvent(ChartEvent.DRAG_OVER, view, emitter);
      const drop3 = bubblesEvent(ChartEvent.DROP, view, emitter);
      container.addEventListener("click", click);
      container.addEventListener("click", dblclick2);
      container.addEventListener("pointertap", pointertap);
      container.addEventListener("pointerdown", pointerdown);
      container.addEventListener("pointerup", pointerup);
      container.addEventListener("pointerover", pointerover);
      container.addEventListener("pointerout", pointerout);
      container.addEventListener("pointermove", pointermove);
      container.addEventListener("pointerenter", pointerenter);
      container.addEventListener("pointerleave", pointerleave);
      container.addEventListener("pointerupoutside", pointerupoutside);
      container.addEventListener("dragstart", dragstart);
      container.addEventListener("drag", drag);
      container.addEventListener("dragend", dragend);
      container.addEventListener("dragenter", dragenter);
      container.addEventListener("dragleave", dragleave);
      container.addEventListener("dragover", dragover);
      container.addEventListener("drop", drop3);
      return () => {
        container.removeEventListener("click", click);
        container.removeEventListener("click", dblclick2);
        container.removeEventListener("pointertap", pointertap);
        container.removeEventListener("pointerdown", pointerdown);
        container.removeEventListener("pointerup", pointerup);
        container.removeEventListener("pointerover", pointerover);
        container.removeEventListener("pointerout", pointerout);
        container.removeEventListener("pointermove", pointermove);
        container.removeEventListener("pointerenter", pointerenter);
        container.removeEventListener("pointerleave", pointerleave);
        container.removeEventListener("pointerupoutside", pointerupoutside);
        container.removeEventListener("dragstart", dragstart);
        container.removeEventListener("drag", drag);
        container.removeEventListener("dragend", dragend);
        container.removeEventListener("dragenter", dragenter);
        container.removeEventListener("dragleave", dragleave);
        container.removeEventListener("dragover", dragover);
        container.removeEventListener("drop", drop3);
      };
    };
  }
  Event2.props = {
    reapplyWhenUpdate: true
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/lib/builtinlib.js
  function builtinlib() {
    return {
      "component.axisRadar": AxisRadar,
      "component.axisLinear": LinearAxis,
      "component.axisArc": ArcAxis,
      "component.legendContinuousBlock": LegendContinuousBlock,
      "component.legendContinuousBlockSize": LegendContinuousBlockSize,
      "component.legendContinuousSize": LegendContinuousSize,
      "interaction.event": Event2,
      "composition.mark": Mark,
      "composition.view": View2,
      "shape.label.label": Label
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/runtime/library.js
  var __rest71 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function useLibrary(namespace, publicLibrary) {
    const library3 = Object.assign(Object.assign({}, builtinlib()), publicLibrary);
    const create8 = (type) => {
      if (typeof type !== "string")
        return type;
      const key = `${namespace}.${type}`;
      return library3[key] || error2(`Unknown Component: ${key}`);
    };
    const use = (options, context) => {
      const { type } = options, rest = __rest71(options, ["type"]);
      if (!type)
        error2(`Plot type is required!`);
      const currentLibrary = create8(type);
      return currentLibrary === null || currentLibrary === void 0 ? void 0 : currentLibrary(rest, context);
    };
    return [use, create8];
  }
  function documentOf(library3) {
    const { canvas, group: group3 } = library3;
    return (canvas === null || canvas === void 0 ? void 0 : canvas.document) || (group3 === null || group3 === void 0 ? void 0 : group3.ownerDocument) || error2(`Cannot find library document`);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/runtime/coordinate.js
  var __rest72 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function createCoordinate(layout, partialOptions, library3) {
    const [useCoordinate] = useLibrary("coordinate", library3);
    const { innerHeight, innerWidth, insetLeft, insetTop, insetRight, insetBottom } = layout;
    const { coordinates: partialTransform = [] } = partialOptions;
    const transform = inferCoordinate(partialTransform);
    const isCartesian3D = transform[0].type === "cartesian3D";
    const options = Object.assign(Object.assign({}, layout), { x: insetLeft, y: insetTop, width: innerWidth - insetLeft - insetRight, height: innerHeight - insetBottom - insetTop, transformations: transform.flatMap(useCoordinate) });
    const coordinate = isCartesian3D ? (
      // @ts-ignore
      new import_coord.Coordinate3D(options)
    ) : new import_coord.Coordinate(options);
    return coordinate;
  }
  function coordinate2Transform(node, library3) {
    const { coordinate = {}, coordinates } = node, rest = __rest72(node, ["coordinate", "coordinates"]);
    if (coordinates)
      return node;
    const { type, transform = [] } = coordinate, options = __rest72(coordinate, ["type", "transform"]);
    if (!type)
      return Object.assign(Object.assign({}, rest), { coordinates: transform });
    const [, createCoordinate2] = useLibrary("coordinate", library3);
    const { transform: isTransform = false } = createCoordinate2(type).props || {};
    if (isTransform) {
      throw new Error(`Unknown coordinate: ${type}.`);
    }
    return Object.assign(Object.assign({}, rest), { coordinates: [Object.assign({ type }, options), ...transform] });
  }
  function coordOf(coordinates, type) {
    return coordinates.filter((d2) => d2.type === type);
  }
  function isPolar2(coordinates) {
    return coordOf(coordinates, "polar").length > 0;
  }
  function isHelix2(coordinates) {
    return coordOf(coordinates, "helix").length > 0;
  }
  function isTranspose2(coordinates) {
    return coordOf(coordinates, "transpose").length % 2 === 1;
  }
  function isParallel2(coordinates) {
    return coordOf(coordinates, "parallel").length > 0;
  }
  function isTheta2(coordinates) {
    return coordOf(coordinates, "theta").length > 0;
  }
  function isReflect(coordinates) {
    return coordOf(coordinates, "reflect").length > 0;
  }
  function isRadial2(coordinates) {
    return coordOf(coordinates, "radial").length > 0;
  }
  function isRadar2(coordinates) {
    return coordOf(coordinates, "radar").length > 0;
  }
  function isReflectY(coordinates) {
    return coordOf(coordinates, "reflectY").length > 0;
  }
  function inferCoordinate(coordinates) {
    if (coordinates.find((d2) => d2.type === "cartesian" || d2.type === "cartesian3D"))
      return coordinates;
    return [...coordinates, { type: "cartesian" }];
  }

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/index.js
  var src_exports3 = {};
  __export(src_exports3, {
    interpolateBlues: () => Blues_default,
    interpolateBrBG: () => BrBG_default,
    interpolateBuGn: () => BuGn_default,
    interpolateBuPu: () => BuPu_default,
    interpolateCividis: () => cividis_default,
    interpolateCool: () => cool,
    interpolateCubehelixDefault: () => cubehelix_default2,
    interpolateGnBu: () => GnBu_default,
    interpolateGreens: () => Greens_default,
    interpolateGreys: () => Greys_default,
    interpolateInferno: () => inferno,
    interpolateMagma: () => magma,
    interpolateOrRd: () => OrRd_default,
    interpolateOranges: () => Oranges_default,
    interpolatePRGn: () => PRGn_default,
    interpolatePiYG: () => PiYG_default,
    interpolatePlasma: () => plasma,
    interpolatePuBu: () => PuBu_default,
    interpolatePuBuGn: () => PuBuGn_default,
    interpolatePuOr: () => PuOr_default,
    interpolatePuRd: () => PuRd_default,
    interpolatePurples: () => Purples_default,
    interpolateRainbow: () => rainbow_default,
    interpolateRdBu: () => RdBu_default,
    interpolateRdGy: () => RdGy_default,
    interpolateRdPu: () => RdPu_default,
    interpolateRdYlBu: () => RdYlBu_default,
    interpolateRdYlGn: () => RdYlGn_default,
    interpolateReds: () => Reds_default,
    interpolateSinebow: () => sinebow_default,
    interpolateSpectral: () => Spectral_default,
    interpolateTurbo: () => turbo_default,
    interpolateViridis: () => viridis_default,
    interpolateWarm: () => warm,
    interpolateYlGn: () => YlGn_default,
    interpolateYlGnBu: () => YlGnBu_default,
    interpolateYlOrBr: () => YlOrBr_default,
    interpolateYlOrRd: () => YlOrRd_default,
    schemeAccent: () => Accent_default,
    schemeBlues: () => scheme22,
    schemeBrBG: () => scheme,
    schemeBuGn: () => scheme10,
    schemeBuPu: () => scheme11,
    schemeCategory10: () => category10_default,
    schemeDark2: () => Dark2_default,
    schemeGnBu: () => scheme12,
    schemeGreens: () => scheme23,
    schemeGreys: () => scheme24,
    schemeObservable10: () => observable10_default,
    schemeOrRd: () => scheme13,
    schemeOranges: () => scheme27,
    schemePRGn: () => scheme2,
    schemePaired: () => Paired_default,
    schemePastel1: () => Pastel1_default,
    schemePastel2: () => Pastel2_default,
    schemePiYG: () => scheme3,
    schemePuBu: () => scheme15,
    schemePuBuGn: () => scheme14,
    schemePuOr: () => scheme4,
    schemePuRd: () => scheme16,
    schemePurples: () => scheme25,
    schemeRdBu: () => scheme5,
    schemeRdGy: () => scheme6,
    schemeRdPu: () => scheme17,
    schemeRdYlBu: () => scheme7,
    schemeRdYlGn: () => scheme8,
    schemeReds: () => scheme26,
    schemeSet1: () => Set1_default,
    schemeSet2: () => Set2_default,
    schemeSet3: () => Set3_default,
    schemeSpectral: () => scheme9,
    schemeTableau10: () => Tableau10_default,
    schemeYlGn: () => scheme19,
    schemeYlGnBu: () => scheme18,
    schemeYlOrBr: () => scheme20,
    schemeYlOrRd: () => scheme21
  });

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/colors.js
  function colors_default(specifier) {
    var n2 = specifier.length / 6 | 0, colors = new Array(n2), i = 0;
    while (i < n2) colors[i] = "#" + specifier.slice(i * 6, ++i * 6);
    return colors;
  }

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/categorical/category10.js
  var category10_default = colors_default("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/categorical/Accent.js
  var Accent_default = colors_default("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/categorical/Dark2.js
  var Dark2_default = colors_default("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/categorical/observable10.js
  var observable10_default = colors_default("4269d0efb118ff725c6cc5b03ca951ff8ab7a463f297bbf59c6b4e9498a0");

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/categorical/Paired.js
  var Paired_default = colors_default("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/categorical/Pastel1.js
  var Pastel1_default = colors_default("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/categorical/Pastel2.js
  var Pastel2_default = colors_default("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/categorical/Set1.js
  var Set1_default = colors_default("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/categorical/Set2.js
  var Set2_default = colors_default("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/categorical/Set3.js
  var Set3_default = colors_default("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/categorical/Tableau10.js
  var Tableau10_default = colors_default("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");

  // ../../engine/rails_design/node_modules/d3-interpolate/src/basis.js
  function basis(t1, v0, v1, v2, v3) {
    var t2 = t1 * t1, t3 = t2 * t1;
    return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values) {
    var n2 = values.length - 1;
    return function(t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n2 - 1) : Math.floor(t * n2), v1 = values[i], v2 = values[i + 1], v0 = i > 0 ? values[i - 1] : 2 * v1 - v2, v3 = i < n2 - 1 ? values[i + 2] : 2 * v2 - v1;
      return basis((t - i / n2) * n2, v0, v1, v2, v3);
    };
  }

  // ../../engine/rails_design/node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values) {
    var n2 = values.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n2), v0 = values[(i + n2 - 1) % n2], v1 = values[i % n2], v2 = values[(i + 1) % n2], v3 = values[(i + 2) % n2];
      return basis((t - i / n2) * n2, v0, v1, v2, v3);
    };
  }

  // ../../engine/rails_design/node_modules/d3-interpolate/src/constant.js
  var constant_default4 = (x3) => () => x3;

  // ../../engine/rails_design/node_modules/d3-interpolate/src/color.js
  function linear2(a3, d2) {
    return function(t) {
      return a3 + t * d2;
    };
  }
  function exponential(a3, b, y3) {
    return a3 = Math.pow(a3, y3), b = Math.pow(b, y3) - a3, y3 = 1 / y3, function(t) {
      return Math.pow(a3 + t * b, y3);
    };
  }
  function hue(a3, b) {
    var d2 = b - a3;
    return d2 ? linear2(a3, d2 > 180 || d2 < -180 ? d2 - 360 * Math.round(d2 / 360) : d2) : constant_default4(isNaN(a3) ? b : a3);
  }
  function gamma(y3) {
    return (y3 = +y3) === 1 ? nogamma : function(a3, b) {
      return b - a3 ? exponential(a3, b, y3) : constant_default4(isNaN(a3) ? b : a3);
    };
  }
  function nogamma(a3, b) {
    var d2 = b - a3;
    return d2 ? linear2(a3, d2) : constant_default4(isNaN(a3) ? b : a3);
  }

  // ../../engine/rails_design/node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y3) {
    var color2 = gamma(y3);
    function rgb2(start2, end) {
      var r = color2((start2 = rgb(start2)).r, (end = rgb(end)).r), g = color2(start2.g, end.g), b = color2(start2.b, end.b), opacity = nogamma(start2.opacity, end.opacity);
      return function(t) {
        start2.r = r(t);
        start2.g = g(t);
        start2.b = b(t);
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    rgb2.gamma = rgbGamma;
    return rgb2;
  }(1);
  function rgbSpline(spline) {
    return function(colors) {
      var n2 = colors.length, r = new Array(n2), g = new Array(n2), b = new Array(n2), i, color2;
      for (i = 0; i < n2; ++i) {
        color2 = rgb(colors[i]);
        r[i] = color2.r || 0;
        g[i] = color2.g || 0;
        b[i] = color2.b || 0;
      }
      r = spline(r);
      g = spline(g);
      b = spline(b);
      color2.opacity = 1;
      return function(t) {
        color2.r = r(t);
        color2.g = g(t);
        color2.b = b(t);
        return color2 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // ../../engine/rails_design/node_modules/d3-interpolate/src/cubehelix.js
  function cubehelix2(hue2) {
    return function cubehelixGamma(y3) {
      y3 = +y3;
      function cubehelix3(start2, end) {
        var h = hue2((start2 = cubehelix(start2)).h, (end = cubehelix(end)).h), s2 = nogamma(start2.s, end.s), l2 = nogamma(start2.l, end.l), opacity = nogamma(start2.opacity, end.opacity);
        return function(t) {
          start2.h = h(t);
          start2.s = s2(t);
          start2.l = l2(Math.pow(t, y3));
          start2.opacity = opacity(t);
          return start2 + "";
        };
      }
      cubehelix3.gamma = cubehelixGamma;
      return cubehelix3;
    }(1);
  }
  var cubehelix_default = cubehelix2(hue);
  var cubehelixLong = cubehelix2(nogamma);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/ramp.js
  var ramp_default = (scheme28) => rgbBasis(scheme28[scheme28.length - 1]);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/diverging/BrBG.js
  var scheme = new Array(3).concat(
    "d8b365f5f5f55ab4ac",
    "a6611adfc27d80cdc1018571",
    "a6611adfc27df5f5f580cdc1018571",
    "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
    "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
    "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
    "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
    "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
    "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
  ).map(colors_default);
  var BrBG_default = ramp_default(scheme);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/diverging/PRGn.js
  var scheme2 = new Array(3).concat(
    "af8dc3f7f7f77fbf7b",
    "7b3294c2a5cfa6dba0008837",
    "7b3294c2a5cff7f7f7a6dba0008837",
    "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
    "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
    "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
    "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
    "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
    "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
  ).map(colors_default);
  var PRGn_default = ramp_default(scheme2);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/diverging/PiYG.js
  var scheme3 = new Array(3).concat(
    "e9a3c9f7f7f7a1d76a",
    "d01c8bf1b6dab8e1864dac26",
    "d01c8bf1b6daf7f7f7b8e1864dac26",
    "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
    "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
    "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
    "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
    "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
    "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
  ).map(colors_default);
  var PiYG_default = ramp_default(scheme3);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/diverging/PuOr.js
  var scheme4 = new Array(3).concat(
    "998ec3f7f7f7f1a340",
    "5e3c99b2abd2fdb863e66101",
    "5e3c99b2abd2f7f7f7fdb863e66101",
    "542788998ec3d8daebfee0b6f1a340b35806",
    "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
    "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
    "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
    "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
    "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
  ).map(colors_default);
  var PuOr_default = ramp_default(scheme4);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/diverging/RdBu.js
  var scheme5 = new Array(3).concat(
    "ef8a62f7f7f767a9cf",
    "ca0020f4a58292c5de0571b0",
    "ca0020f4a582f7f7f792c5de0571b0",
    "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
    "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
    "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
    "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
    "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
    "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
  ).map(colors_default);
  var RdBu_default = ramp_default(scheme5);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/diverging/RdGy.js
  var scheme6 = new Array(3).concat(
    "ef8a62ffffff999999",
    "ca0020f4a582bababa404040",
    "ca0020f4a582ffffffbababa404040",
    "b2182bef8a62fddbc7e0e0e09999994d4d4d",
    "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
    "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
    "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
    "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
    "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
  ).map(colors_default);
  var RdGy_default = ramp_default(scheme6);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/diverging/RdYlBu.js
  var scheme7 = new Array(3).concat(
    "fc8d59ffffbf91bfdb",
    "d7191cfdae61abd9e92c7bb6",
    "d7191cfdae61ffffbfabd9e92c7bb6",
    "d73027fc8d59fee090e0f3f891bfdb4575b4",
    "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
    "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
    "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
    "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
    "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
  ).map(colors_default);
  var RdYlBu_default = ramp_default(scheme7);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/diverging/RdYlGn.js
  var scheme8 = new Array(3).concat(
    "fc8d59ffffbf91cf60",
    "d7191cfdae61a6d96a1a9641",
    "d7191cfdae61ffffbfa6d96a1a9641",
    "d73027fc8d59fee08bd9ef8b91cf601a9850",
    "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
    "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
    "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
    "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
    "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
  ).map(colors_default);
  var RdYlGn_default = ramp_default(scheme8);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/diverging/Spectral.js
  var scheme9 = new Array(3).concat(
    "fc8d59ffffbf99d594",
    "d7191cfdae61abdda42b83ba",
    "d7191cfdae61ffffbfabdda42b83ba",
    "d53e4ffc8d59fee08be6f59899d5943288bd",
    "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
    "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
    "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
    "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
    "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
  ).map(colors_default);
  var Spectral_default = ramp_default(scheme9);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/BuGn.js
  var scheme10 = new Array(3).concat(
    "e5f5f999d8c92ca25f",
    "edf8fbb2e2e266c2a4238b45",
    "edf8fbb2e2e266c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a42ca25f006d2c",
    "edf8fbccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
    "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
  ).map(colors_default);
  var BuGn_default = ramp_default(scheme10);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/BuPu.js
  var scheme11 = new Array(3).concat(
    "e0ecf49ebcda8856a7",
    "edf8fbb3cde38c96c688419d",
    "edf8fbb3cde38c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
    "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
    "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
  ).map(colors_default);
  var BuPu_default = ramp_default(scheme11);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/GnBu.js
  var scheme12 = new Array(3).concat(
    "e0f3dba8ddb543a2ca",
    "f0f9e8bae4bc7bccc42b8cbe",
    "f0f9e8bae4bc7bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
    "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
    "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
  ).map(colors_default);
  var GnBu_default = ramp_default(scheme12);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/OrRd.js
  var scheme13 = new Array(3).concat(
    "fee8c8fdbb84e34a33",
    "fef0d9fdcc8afc8d59d7301f",
    "fef0d9fdcc8afc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59e34a33b30000",
    "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
    "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
  ).map(colors_default);
  var OrRd_default = ramp_default(scheme13);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/PuBuGn.js
  var scheme14 = new Array(3).concat(
    "ece2f0a6bddb1c9099",
    "f6eff7bdc9e167a9cf02818a",
    "f6eff7bdc9e167a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
    "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
    "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
  ).map(colors_default);
  var PuBuGn_default = ramp_default(scheme14);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/PuBu.js
  var scheme15 = new Array(3).concat(
    "ece7f2a6bddb2b8cbe",
    "f1eef6bdc9e174a9cf0570b0",
    "f1eef6bdc9e174a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
    "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
    "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
  ).map(colors_default);
  var PuBu_default = ramp_default(scheme15);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/PuRd.js
  var scheme16 = new Array(3).concat(
    "e7e1efc994c7dd1c77",
    "f1eef6d7b5d8df65b0ce1256",
    "f1eef6d7b5d8df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0dd1c77980043",
    "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
    "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
  ).map(colors_default);
  var PuRd_default = ramp_default(scheme16);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/RdPu.js
  var scheme17 = new Array(3).concat(
    "fde0ddfa9fb5c51b8a",
    "feebe2fbb4b9f768a1ae017e",
    "feebe2fbb4b9f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
    "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
    "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
  ).map(colors_default);
  var RdPu_default = ramp_default(scheme17);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/YlGnBu.js
  var scheme18 = new Array(3).concat(
    "edf8b17fcdbb2c7fb8",
    "ffffcca1dab441b6c4225ea8",
    "ffffcca1dab441b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
    "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
    "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
  ).map(colors_default);
  var YlGnBu_default = ramp_default(scheme18);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/YlGn.js
  var scheme19 = new Array(3).concat(
    "f7fcb9addd8e31a354",
    "ffffccc2e69978c679238443",
    "ffffccc2e69978c67931a354006837",
    "ffffccd9f0a3addd8e78c67931a354006837",
    "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
    "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
  ).map(colors_default);
  var YlGn_default = ramp_default(scheme19);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrBr.js
  var scheme20 = new Array(3).concat(
    "fff7bcfec44fd95f0e",
    "ffffd4fed98efe9929cc4c02",
    "ffffd4fed98efe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929d95f0e993404",
    "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
    "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
  ).map(colors_default);
  var YlOrBr_default = ramp_default(scheme20);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/YlOrRd.js
  var scheme21 = new Array(3).concat(
    "ffeda0feb24cf03b20",
    "ffffb2fecc5cfd8d3ce31a1c",
    "ffffb2fecc5cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cf03b20bd0026",
    "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
    "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
  ).map(colors_default);
  var YlOrRd_default = ramp_default(scheme21);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-single/Blues.js
  var scheme22 = new Array(3).concat(
    "deebf79ecae13182bd",
    "eff3ffbdd7e76baed62171b5",
    "eff3ffbdd7e76baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed63182bd08519c",
    "eff3ffc6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
    "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
  ).map(colors_default);
  var Blues_default = ramp_default(scheme22);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-single/Greens.js
  var scheme23 = new Array(3).concat(
    "e5f5e0a1d99b31a354",
    "edf8e9bae4b374c476238b45",
    "edf8e9bae4b374c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47631a354006d2c",
    "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
    "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
  ).map(colors_default);
  var Greens_default = ramp_default(scheme23);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-single/Greys.js
  var scheme24 = new Array(3).concat(
    "f0f0f0bdbdbd636363",
    "f7f7f7cccccc969696525252",
    "f7f7f7cccccc969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696636363252525",
    "f7f7f7d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
    "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
  ).map(colors_default);
  var Greys_default = ramp_default(scheme24);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-single/Purples.js
  var scheme25 = new Array(3).concat(
    "efedf5bcbddc756bb1",
    "f2f0f7cbc9e29e9ac86a51a3",
    "f2f0f7cbc9e29e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
    "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
    "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
  ).map(colors_default);
  var Purples_default = ramp_default(scheme25);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-single/Reds.js
  var scheme26 = new Array(3).concat(
    "fee0d2fc9272de2d26",
    "fee5d9fcae91fb6a4acb181d",
    "fee5d9fcae91fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
    "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
    "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
  ).map(colors_default);
  var Reds_default = ramp_default(scheme26);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-single/Oranges.js
  var scheme27 = new Array(3).concat(
    "fee6cefdae6be6550d",
    "feeddefdbe85fd8d3cd94701",
    "feeddefdbe85fd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3ce6550da63603",
    "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
    "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
  ).map(colors_default);
  var Oranges_default = ramp_default(scheme27);

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/cividis.js
  function cividis_default(t) {
    t = Math.max(0, Math.min(1, t));
    return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
  }

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/cubehelix.js
  var cubehelix_default2 = cubehelixLong(cubehelix(300, 0.5, 0), cubehelix(-240, 0.5, 1));

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/rainbow.js
  var warm = cubehelixLong(cubehelix(-100, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
  var cool = cubehelixLong(cubehelix(260, 0.75, 0.35), cubehelix(80, 1.5, 0.8));
  var c3 = cubehelix();
  function rainbow_default(t) {
    if (t < 0 || t > 1) t -= Math.floor(t);
    var ts = Math.abs(t - 0.5);
    c3.h = 360 * t - 100;
    c3.s = 1.5 - 1.5 * ts;
    c3.l = 0.8 - 0.9 * ts;
    return c3 + "";
  }

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/sinebow.js
  var c4 = rgb();
  var pi_1_3 = Math.PI / 3;
  var pi_2_3 = Math.PI * 2 / 3;
  function sinebow_default(t) {
    var x3;
    t = (0.5 - t) * Math.PI;
    c4.r = 255 * (x3 = Math.sin(t)) * x3;
    c4.g = 255 * (x3 = Math.sin(t + pi_1_3)) * x3;
    c4.b = 255 * (x3 = Math.sin(t + pi_2_3)) * x3;
    return c4 + "";
  }

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/turbo.js
  function turbo_default(t) {
    t = Math.max(0, Math.min(1, t));
    return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
  }

  // ../../engine/rails_design/node_modules/d3-scale-chromatic/src/sequential-multi/viridis.js
  function ramp(range3) {
    var n2 = range3.length;
    return function(t) {
      return range3[Math.max(0, Math.min(n2 - 1, Math.floor(t * n2)))];
    };
  }
  var viridis_default = ramp(colors_default("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
  var magma = ramp(colors_default("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
  var inferno = ramp(colors_default("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
  var plasma = ramp(colors_default("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));

  // ../../engine/rails_design/node_modules/@antv/g2/esm/runtime/scale.js
  function inferScale(name2, values, options, coordinates, theme, library3) {
    const { guide = {} } = options;
    const type = inferScaleType(name2, values, options);
    if (typeof type !== "string")
      return options;
    const expectedDomain = inferScaleDomain(type, name2, values, options);
    const actualDomain = maybeRatio(type, expectedDomain, options);
    return Object.assign(Object.assign(Object.assign({}, options), inferScaleOptions(type, name2, values, options, coordinates)), {
      domain: actualDomain,
      range: inferScaleRange(type, name2, values, options, actualDomain, theme, library3),
      expectedDomain,
      guide,
      name: name2,
      type
    });
  }
  function applyScale(channels, scale9) {
    const scaledValue = {};
    for (const channel of channels) {
      const { values, name: scaleName } = channel;
      const scaleInstance = scale9[scaleName];
      for (const value2 of values) {
        const { name: name2, value: V } = value2;
        scaledValue[name2] = V.map((d2) => scaleInstance.map(d2));
      }
    }
    return scaledValue;
  }
  function groupTransform(markState, uidScale) {
    const channels = Array.from(markState.values()).flatMap((d2) => d2.channels);
    const scaleGroups = rollups(channels, (channels2) => channels2.map((d2) => uidScale.get(d2.scale.uid)), (d2) => d2.name).filter(([, scales]) => scales.some((d2) => typeof d2.getOptions().groupTransform === "function") && // only sync scales with groupTransform options
    scales.every((d2) => d2.getTicks)).map((d2) => d2[1]);
    scaleGroups.forEach((group3) => {
      const groupTransform2 = group3.map((d2) => d2.getOptions().groupTransform)[0];
      groupTransform2(group3);
    });
  }
  function collectScales(states, options) {
    var _a;
    const { components = [] } = options;
    const NONE_STATIC_KEYS = [
      "scale",
      "encode",
      "axis",
      "legend",
      "data",
      "transform"
    ];
    const scales = Array.from(new Set(states.flatMap((d2) => d2.channels.map((d3) => d3.scale))));
    const nameScale = new Map(scales.map((scale9) => [scale9.name, scale9]));
    for (const component of components) {
      const channels = inferChannelsForComponent(component);
      for (const channel of channels) {
        const scale9 = nameScale.get(channel);
        const staticScale = ((_a = component.scale) === null || _a === void 0 ? void 0 : _a[channel]) || {};
        const { independent = false } = staticScale;
        if (scale9 && !independent) {
          const { guide } = scale9;
          const guide1 = typeof guide === "boolean" ? {} : guide;
          scale9.guide = deep_mix_default({}, guide1, component);
          Object.assign(scale9, staticScale);
        } else {
          const options1 = Object.assign(Object.assign({}, staticScale), { expectedDomain: staticScale.domain, name: channel, guide: omit_default(component, NONE_STATIC_KEYS) });
          scales.push(options1);
        }
      }
    }
    return scales;
  }
  function useRelation(relations) {
    if (!relations || !Array.isArray(relations))
      return [identity5, identity5];
    let map3;
    let invert5;
    const conditionalize = (scale9) => {
      var _a;
      map3 = scale9.map.bind(scale9);
      invert5 = (_a = scale9.invert) === null || _a === void 0 ? void 0 : _a.bind(scale9);
      const funcRelations = relations.filter(([v]) => typeof v === "function");
      const valueRelations = relations.filter(([v]) => typeof v !== "function");
      const valueOutput = new Map(valueRelations);
      scale9.map = (x3) => {
        for (const [verify, value2] of funcRelations) {
          if (verify(x3))
            return value2;
        }
        if (valueOutput.has(x3))
          return valueOutput.get(x3);
        return map3(x3);
      };
      if (!invert5)
        return scale9;
      const outputValue = new Map(valueRelations.map(([a3, b]) => [b, a3]));
      const outputFunc = new Map(funcRelations.map(([a3, b]) => [b, a3]));
      scale9.invert = (x3) => {
        if (outputFunc.has(x3))
          return x3;
        if (outputValue.has(x3))
          return outputValue.get(x3);
        return invert5(x3);
      };
      return scale9;
    };
    const deconditionalize = (scale9) => {
      if (map3 !== null)
        scale9.map = map3;
      if (invert5 !== null)
        scale9.invert = invert5;
      return scale9;
    };
    return [conditionalize, deconditionalize];
  }
  function assignScale(target, source) {
    const keys2 = Object.keys(target);
    for (const scale9 of Object.values(source)) {
      const { name: name2 } = scale9.getOptions();
      if (!(name2 in target))
        target[name2] = scale9;
      else {
        const I = keys2.filter((d2) => d2.startsWith(name2)).map((d2) => +(d2.replace(name2, "") || 0));
        const index4 = max4(I) + 1;
        const newKey = `${name2}${index4}`;
        target[newKey] = scale9;
        scale9.getOptions().key = newKey;
      }
    }
    return target;
  }
  function useRelationScale(options, library3) {
    const [useScale] = useLibrary("scale", library3);
    const { relations } = options;
    const [conditionalize] = useRelation(relations);
    const scale9 = useScale(options);
    return conditionalize(scale9);
  }
  function syncFacetsScales(states) {
    const scales = states.flatMap((d2) => Array.from(d2.values())).flatMap((d2) => d2.channels.map((d3) => d3.scale));
    syncFacetsScaleByChannel(scales, "x");
    syncFacetsScaleByChannel(scales, "y");
  }
  function inferChannelsForComponent(component) {
    const { channels = [], type, scale: scale9 = {} } = component;
    const L = ["shape", "color", "opacity", "size"];
    if (channels.length !== 0)
      return channels;
    if (type === "axisX")
      return ["x"];
    if (type === "axisY")
      return ["y"];
    if (type === "legends")
      return Object.keys(scale9).filter((d2) => L.includes(d2));
    return [];
  }
  function syncFacetsScaleByChannel(scales, channel) {
    const S = scales.filter(({ name: name2, facet = true }) => facet && name2 === channel);
    const D2 = S.flatMap((d2) => d2.domain);
    const syncedD = S.every(isQuantitativeScale) ? extent(D2) : S.every(isDiscreteScale) ? Array.from(new Set(D2)) : null;
    if (syncedD === null)
      return;
    for (const scale9 of S) {
      scale9.domain = syncedD;
    }
  }
  function maybeRatio(type, domain, options) {
    const { ratio } = options;
    if (ratio === void 0 || ratio === null)
      return domain;
    if (isQuantitativeScale({ type })) {
      return clampQuantitativeScale(domain, ratio, type);
    }
    if (isDiscreteScale({ type }))
      return clampDiscreteScale(domain, ratio);
    return domain;
  }
  function clampQuantitativeScale(domain, ratio, type) {
    const D2 = domain.map(Number);
    const scale9 = new Linear({
      domain: D2,
      range: [D2[0], D2[0] + (D2[D2.length - 1] - D2[0]) * ratio]
    });
    if (type === "time")
      return domain.map((d2) => new Date(scale9.map(d2)));
    return domain.map((d2) => scale9.map(d2));
  }
  function clampDiscreteScale(domain, ratio) {
    const index4 = Math.round(domain.length * ratio);
    return domain.slice(0, index4);
  }
  function isQuantitativeScale(scale9) {
    const { type } = scale9;
    if (typeof type !== "string")
      return false;
    const names = ["linear", "log", "pow", "time"];
    return names.includes(type);
  }
  function isDiscreteScale(scale9) {
    const { type } = scale9;
    if (typeof type !== "string")
      return false;
    const names = ["band", "point", "ordinal"];
    return names.includes(type);
  }
  function inferScaleType(name2, values, options) {
    const { type, domain, range: range3, quantitative, ordinal } = options;
    if (type !== void 0)
      return type;
    if (isObject3(values))
      return "identity";
    if (typeof range3 === "string")
      return "linear";
    if ((domain || range3 || []).length > 2)
      return asOrdinalType(name2, ordinal);
    if (domain !== void 0) {
      if (isOrdinal([domain]))
        return asOrdinalType(name2, ordinal);
      if (isTemporal(values))
        return "time";
      return asQuantitativeType(name2, range3, quantitative);
    }
    if (isOrdinal(values))
      return asOrdinalType(name2, ordinal);
    if (isTemporal(values))
      return "time";
    return asQuantitativeType(name2, range3, quantitative);
  }
  function inferScaleDomain(type, name2, values, options) {
    const { domain } = options;
    if (domain !== void 0)
      return domain;
    switch (type) {
      case "linear":
      case "time":
      case "log":
      case "pow":
      case "sqrt":
      case "quantize":
      case "threshold":
        return maybeMinMax(inferDomainQ(values, options), options);
      case "band":
      case "ordinal":
      case "point":
        return inferDomainC(values);
      case "quantile":
        return inferDomainO(values);
      case "sequential":
        return maybeMinMax(inferDomainS(values), options);
      default:
        return [];
    }
  }
  function inferScaleRange(type, name2, values, options, domain, theme, library3) {
    const { range: range3 } = options;
    if (typeof range3 === "string")
      return gradientColors(range3);
    if (range3 !== void 0)
      return range3;
    const { rangeMin, rangeMax } = options;
    switch (type) {
      case "linear":
      case "time":
      case "log":
      case "pow":
      case "sqrt": {
        const colors = categoricalColors(values, options, domain, theme, library3);
        const [r0, r1] = inferRangeQ(name2, colors);
        return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : r0, rangeMax !== null && rangeMax !== void 0 ? rangeMax : r1];
      }
      case "band":
      case "point": {
        const min10 = name2 === "size" ? 5 : 0;
        const max10 = name2 === "size" ? 10 : 1;
        return [rangeMin !== null && rangeMin !== void 0 ? rangeMin : min10, rangeMax !== null && rangeMax !== void 0 ? rangeMax : max10];
      }
      case "ordinal": {
        return categoricalColors(values, options, domain, theme, library3);
      }
      case "sequential":
        return void 0;
      case "constant":
        return [values[0][0]];
      default:
        return [];
    }
  }
  function inferScaleOptions(type, name2, values, options, coordinates) {
    switch (type) {
      case "linear":
      case "time":
      case "log":
      case "pow":
      case "sqrt":
        return inferOptionsQ(coordinates, options);
      case "band":
      case "point":
        return inferOptionsC(type, name2, coordinates, options);
      case "sequential":
        return inferOptionsS(options);
      default:
        return options;
    }
  }
  function categoricalColors(values, options, domain, theme, library3) {
    const [usePalette] = useLibrary("palette", library3);
    const { category10: c10, category20: c20 } = theme;
    const defaultPalette = unique(domain).length <= c10.length ? c10 : c20;
    const { palette = defaultPalette, offset: offset3 } = options;
    if (Array.isArray(palette))
      return palette;
    try {
      return usePalette({ type: palette });
    } catch (e3) {
      const colors = interpolatedColors(palette, domain, offset3);
      if (colors)
        return colors;
      throw new Error(`Unknown Component: ${palette} `);
    }
  }
  function gradientColors(range3) {
    return range3.split("-");
  }
  function interpolatedColors(palette, domain, offset3 = (d2) => d2) {
    if (!palette)
      return null;
    const fullName = upper_first_default(palette);
    const scheme28 = src_exports3[`scheme${fullName}`];
    const interpolator = src_exports3[`interpolate${fullName}`];
    if (!scheme28 && !interpolator)
      return null;
    if (scheme28) {
      if (!scheme28.some(Array.isArray))
        return scheme28;
      const schemeColors = scheme28[domain.length];
      if (schemeColors)
        return schemeColors;
    }
    return domain.map((_2, i) => interpolator(offset3(i / domain.length)));
  }
  function inferOptionsS(options) {
    const { palette = "ylGnBu", offset: offset3 } = options;
    const name2 = upper_first_default(palette);
    const interpolator = src_exports3[`interpolate${name2}`];
    if (!interpolator)
      throw new Error(`Unknown palette: ${name2}`);
    return {
      interpolator: offset3 ? (x3) => interpolator(offset3(x3)) : interpolator
    };
  }
  function inferOptionsQ(coordinates, options) {
    const { interpolate: interpolate5 = createInterpolateValue, nice: nice2 = false, tickCount = 5 } = options;
    return Object.assign(Object.assign({}, options), { interpolate: interpolate5, nice: nice2, tickCount });
  }
  function inferOptionsC(type, name2, coordinates, options) {
    if (options.padding !== void 0 || options.paddingInner !== void 0 || options.paddingOuter !== void 0) {
      return Object.assign(Object.assign({}, options), { unknown: NaN });
    }
    const padding = inferPadding(type, name2, coordinates);
    const { paddingInner = padding, paddingOuter = padding } = options;
    return Object.assign(Object.assign({}, options), {
      paddingInner,
      paddingOuter,
      padding,
      unknown: NaN
    });
  }
  function inferPadding(type, name2, coordinates) {
    if (name2 === "enterDelay" || name2 === "enterDuration")
      return 0;
    if (name2 === "size")
      return 0;
    if (type === "band")
      return isTheta2(coordinates) ? 0 : 0.1;
    if (type === "point")
      return 0.5;
    return 0;
  }
  function asOrdinalType(name2, defaults5) {
    if (defaults5)
      return defaults5;
    return isQuantitative(name2) ? "point" : "ordinal";
  }
  function asQuantitativeType(name2, range3, defaults5) {
    if (defaults5)
      return defaults5;
    if (name2 !== "color")
      return "linear";
    return range3 ? "linear" : "sequential";
  }
  function maybeMinMax(domain, options) {
    if (domain.length === 0)
      return domain;
    const { domainMin, domainMax } = options;
    const [d0, d1] = domain;
    return [domainMin !== null && domainMin !== void 0 ? domainMin : d0, domainMax !== null && domainMax !== void 0 ? domainMax : d1];
  }
  function inferDomainQ(values, options) {
    const { zero: zero5 = false } = options;
    let min10 = Infinity;
    let max10 = -Infinity;
    for (const value2 of values) {
      for (const d2 of value2) {
        if (defined(d2)) {
          min10 = Math.min(min10, +d2);
          max10 = Math.max(max10, +d2);
        }
      }
    }
    if (min10 === Infinity)
      return [];
    return zero5 ? [Math.min(0, min10), max10] : [min10, max10];
  }
  function inferDomainC(values) {
    return Array.from(new Set(values.flat()));
  }
  function inferDomainO(values) {
    return values.flat().sort();
  }
  function inferDomainS(values) {
    let min10 = Infinity;
    let max10 = -Infinity;
    for (const value2 of values) {
      for (const d2 of value2) {
        if (defined(d2)) {
          min10 = Math.min(min10, +d2);
          max10 = Math.max(max10, +d2);
        }
      }
    }
    if (min10 === Infinity)
      return [];
    return [min10 < 0 ? -max10 : min10, max10];
  }
  function inferRangeQ(name2, palette) {
    if (name2 === "enterDelay")
      return [0, 1e3];
    if (name2 == "enterDuration")
      return [300, 1e3];
    if (name2.startsWith("y") || name2.startsWith("position"))
      return [1, 0];
    if (name2 === "color")
      return [firstOf(palette), lastOf(palette)];
    if (name2 === "opacity")
      return [0, 1];
    if (name2 === "size")
      return [1, 10];
    return [0, 1];
  }
  function isOrdinal(values) {
    return some(values, (d2) => {
      const type = typeof d2;
      return type === "string" || type === "boolean";
    });
  }
  function isTemporal(values) {
    return some(values, (d2) => d2 instanceof Date);
  }
  function isObject3(values) {
    return some(values, isStrictObject);
  }
  function some(values, callback) {
    for (const V of values) {
      if (V.some(callback))
        return true;
    }
    return false;
  }
  function isQuantitative(name2) {
    return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2.startsWith("size");
  }
  function isPosition(name2) {
    return name2.startsWith("x") || name2.startsWith("y") || name2.startsWith("position") || name2 === "enterDelay" || name2 === "enterDuration" || name2 === "updateDelay" || name2 === "updateDuration" || name2 === "exitDelay" || name2 === "exitDuration";
  }
  function isValidScale(scale9) {
    if (!scale9 || !scale9.type)
      return false;
    if (typeof scale9.type === "function")
      return true;
    const { type, domain, range: range3, interpolator } = scale9;
    const isValidDomain = domain && domain.length > 0;
    const isValidRange = range3 && range3.length > 0;
    if ([
      "linear",
      "sqrt",
      "log",
      "time",
      "pow",
      "threshold",
      "quantize",
      "quantile",
      "ordinal",
      "band",
      "point"
    ].includes(type) && isValidDomain && isValidRange) {
      return true;
    }
    if (["sequential"].includes(type) && isValidDomain && (isValidRange || interpolator)) {
      return true;
    }
    if (["constant", "identity"].includes(type) && isValidRange)
      return true;
    return false;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/runtime/types/scale.js
  var ContinuousScale = {
    linear: "linear",
    identity: "identity",
    log: "log",
    pow: "pow",
    sqrt: "sqrt",
    sequential: "sequential"
  };
  var DistributionScale = {
    threshold: "threshold",
    quantize: "quantize",
    quantile: "quantile"
  };
  var DiscreteScale = {
    ordinal: "ordinal",
    band: "band",
    point: "point"
  };
  var ConstantScale = {
    constant: "constant"
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/runtime/component.js
  var __rest73 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function inferComponent(scales, partialOptions, library3) {
    const { coordinates = [], title } = partialOptions;
    const [, createGuideComponent] = useLibrary("component", library3);
    const displayedScales = scales.filter(({ guide }) => {
      if (guide === null)
        return false;
      return true;
    });
    const components = [];
    const sliders = inferScrollableComponents(partialOptions, scales, library3);
    components.push(...sliders);
    if (title) {
      const { props } = createGuideComponent("title");
      const { defaultPosition, defaultOrientation, defaultOrder, defaultSize, defaultCrossPadding } = props;
      const titleOptions = typeof title === "string" ? { title } : title;
      components.push(Object.assign({ type: "title", position: defaultPosition, orientation: defaultOrientation, order: defaultOrder, crossPadding: defaultCrossPadding[0], defaultSize }, titleOptions));
    }
    const inferredComponents = inferComponentsType(displayedScales, coordinates);
    inferredComponents.forEach(([type, relativeScales]) => {
      const { props } = createGuideComponent(type);
      const { defaultPosition, defaultPlane = "xy", defaultOrientation, defaultSize, defaultOrder, defaultLength, defaultPadding: DP = [0, 0], defaultCrossPadding: DCP = [0, 0] } = props;
      const scale9 = deep_mix_default({}, ...relativeScales);
      const { guide: guideOptions, field: field3 } = scale9;
      const guides = Array.isArray(guideOptions) ? guideOptions : [guideOptions];
      for (const partialGuide of guides) {
        const [position, orientation] = inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, partialGuide, relativeScales, displayedScales, coordinates);
        if (!position && !orientation)
          continue;
        const isVertical2 = position === "left" || position === "right";
        const defaultPadding = isVertical2 ? DP[1] : DP[0];
        const defaultCrossPadding = isVertical2 ? DCP[1] : DCP[0];
        const { size: size2, order = defaultOrder, length: length5 = defaultLength, padding = defaultPadding, crossPadding = defaultCrossPadding } = partialGuide;
        components.push(Object.assign(Object.assign({ title: field3 }, partialGuide), {
          defaultSize,
          length: length5,
          position,
          plane: defaultPlane,
          orientation,
          padding,
          order,
          crossPadding,
          size: size2,
          type,
          scales: relativeScales
        }));
      }
    });
    return components;
  }
  function renderComponent(component, coordinate, theme, library3, markState) {
    const [useGuideComponent] = useLibrary("component", library3);
    const { scaleInstances: scales, scale: scale9, bbox } = component, options = __rest73(component, ["scaleInstances", "scale", "bbox"]);
    const value2 = { bbox, library: library3 };
    const render2 = useGuideComponent(options);
    return render2({
      coordinate,
      library: library3,
      markState,
      scales,
      theme,
      value: value2,
      scale: scale9
    });
  }
  function normalizeComponents(components) {
    return components.map((d2) => {
      const component = deep_mix_default(d2, d2.style);
      delete component.style;
      return component;
    });
  }
  function groupComponents(components, crossSize) {
    const P = ["left", "right", "bottom", "top"];
    const key = ({ type, position, group: group3 }) => {
      if (!P.includes(position))
        return Symbol("independent");
      if (group3 === void 0) {
        if (type.startsWith("legend"))
          return `legend-${position}`;
        return Symbol("independent");
      }
      if (group3 === "independent")
        return Symbol("independent");
      return group3;
    };
    const grouped = groups(components, key);
    return grouped.flatMap(([, components2]) => {
      if (components2.length === 1)
        return components2[0];
      if (crossSize !== void 0) {
        const DL = components2.filter((d2) => d2.length !== void 0).map((d2) => d2.length);
        const totalLength = sum(DL);
        if (totalLength > crossSize) {
          components2.forEach((d2) => d2.group = Symbol("independent"));
          return components2;
        }
        const emptyLength = crossSize - totalLength;
        const emptyCount = components2.length - DL.length;
        const length5 = emptyLength / emptyCount;
        components2.forEach((d2) => {
          if (d2.length !== void 0)
            return;
          d2.length = length5;
        });
      }
      const size2 = max4(components2, (d2) => d2.size);
      const order = max4(components2, (d2) => d2.order);
      const crossPadding = max4(components2, (d2) => d2.crossPadding);
      const position = components2[0].position;
      return {
        type: "group",
        size: size2,
        order,
        position,
        children: components2,
        crossPadding
      };
    });
  }
  function inferLegendComponentType(scales, coordinates) {
    const channels = ["shape", "size", "color", "opacity"];
    const isConstantSize = (type, name2) => type === "constant" && name2 === "size";
    const accepts = scales.filter(({ type, name: name2 }) => typeof type === "string" && channels.includes(name2) && !isConstantSize(type, name2));
    const constants = accepts.filter(({ type }) => type === "constant");
    const nonConstants = accepts.filter(({ type }) => type !== "constant");
    const groupKey = (d2) => d2.field ? d2.field : Symbol("independent");
    const fieldScales = groups(nonConstants, groupKey).map(([key, scales2]) => [key, [...scales2, ...constants]]).filter(([, scales2]) => scales2.some((scale9) => scale9.type !== "constant"));
    const scalesByField = new Map(fieldScales);
    if (scalesByField.size === 0)
      return [];
    const sort3 = (arr) => arr.sort(([a3], [b]) => a3.localeCompare(b));
    const components = Array.from(scalesByField).map(([, scs]) => {
      const combinations = combine(scs).sort((a3, b) => b.length - a3.length);
      const options = combinations.map((combination) => ({
        combination,
        option: combination.map((scale9) => [scale9.name, getScaleType(scale9)])
      }));
      for (const { option: option2, combination } of options) {
        if (option2.every((d2) => d2[1] === "constant"))
          continue;
        if (option2.every((d2) => d2[1] === "discrete" || d2[1] === "constant")) {
          return ["legendCategory", combination];
        }
      }
      for (const [componentType, accords] of LEGEND_INFER_STRATEGIES) {
        for (const { option: option2, combination } of options) {
          if (accords.some((accord) => is_equal_default(sort3(accord), sort3(option2)))) {
            return [componentType, combination];
          }
        }
      }
      return null;
    }).filter(defined);
    return components;
  }
  function getScaleType(scale9) {
    const { type } = scale9;
    if (typeof type !== "string")
      return null;
    if (type in ContinuousScale)
      return "continuous";
    if (type in DiscreteScale)
      return "discrete";
    if (type in DistributionScale)
      return "distribution";
    if (type in ConstantScale)
      return "constant";
    return null;
  }
  function inferAxisComponentType(scales, coordinates) {
    return scales.map((scale9) => {
      const { name: name2 } = scale9;
      if (isHelix2(coordinates) || isTheta2(coordinates))
        return null;
      if (isTranspose2(coordinates) && (isPolar2(coordinates) || isRadial2(coordinates)))
        return null;
      if (name2.startsWith("x")) {
        if (isPolar2(coordinates))
          return ["axisArc", [scale9]];
        if (isRadial2(coordinates))
          return ["axisLinear", [scale9]];
        return [isTranspose2(coordinates) ? "axisY" : "axisX", [scale9]];
      }
      if (name2.startsWith("y")) {
        if (isPolar2(coordinates))
          return ["axisLinear", [scale9]];
        if (isRadial2(coordinates))
          return ["axisArc", [scale9]];
        return [isTranspose2(coordinates) ? "axisX" : "axisY", [scale9]];
      }
      if (name2.startsWith("z")) {
        return ["axisZ", [scale9]];
      }
      if (name2.startsWith("position")) {
        if (isRadar2(coordinates))
          return ["axisRadar", [scale9]];
        if (!isPolar2(coordinates))
          return ["axisY", [scale9]];
      }
      return null;
    }).filter(defined);
  }
  function inferComponentsType(scales, coordinates) {
    const availableScales = scales.filter((scale9) => isValidScale(scale9));
    return [
      ...inferLegendComponentType(availableScales, coordinates),
      ...inferAxisComponentType(availableScales, coordinates)
    ];
  }
  function angleOf3(coordinates) {
    const polar = coordOf(coordinates, "polar");
    if (polar.length) {
      const lastPolar = polar[polar.length - 1];
      const { startAngle, endAngle } = getPolarOptions(lastPolar);
      return [startAngle, endAngle];
    }
    const radial = coordOf(coordinates, "radial");
    if (radial.length) {
      const lastRadial = radial[radial.length - 1];
      const { startAngle, endAngle } = getRadialOptions(lastRadial);
      return [startAngle, endAngle];
    }
    return [-Math.PI / 2, Math.PI / 2 * 3];
  }
  function matchPosition(name2) {
    const match2 = /position(\d*)/g.exec(name2);
    if (!match2)
      return null;
    return +match2[1];
  }
  function inferAxisPositionAndOrientation(type, ordinalPosition, relativeScales, scales, coordinates) {
    const { name: name2 } = relativeScales[0];
    if (type === "axisRadar") {
      const positions = scales.filter((scale9) => scale9.name.startsWith("position"));
      const index4 = matchPosition(name2);
      if (name2 === positions.slice(-1)[0].name || index4 === null)
        return [null, null];
      const [startAngle, endAngle] = angleOf3(coordinates);
      const angle4 = (endAngle - startAngle) / (positions.length - 1) * index4 + startAngle;
      return ["center", angle4];
    }
    if (type === "axisY" && isParallel2(coordinates)) {
      return isTranspose2(coordinates) ? ["center", "horizontal"] : ["center", "vertical"];
    }
    if (type === "axisLinear") {
      const [startAngle] = angleOf3(coordinates);
      return ["center", startAngle];
    }
    if (type === "axisArc") {
      if (ordinalPosition[0] === "inner")
        return ["inner", null];
      return ["outer", null];
    }
    if (isPolar2(coordinates))
      return ["center", null];
    if (isRadial2(coordinates))
      return ["center", null];
    if (type === "axisX" && isReflect(coordinates) || type === "axisX" && isReflectY(coordinates)) {
      return ["top", null];
    }
    return ordinalPosition;
  }
  function inferComponentPositionAndOrientation(type, defaultPosition, defaultOrientation, guide, relativeScales, scales, coordinates) {
    const [startAngle] = angleOf3(coordinates);
    const ordinalPositionAndOrientation = [
      guide.position || defaultPosition,
      startAngle !== null && startAngle !== void 0 ? startAngle : defaultOrientation
    ];
    if (typeof type === "string" && type.startsWith("axis")) {
      return inferAxisPositionAndOrientation(type, ordinalPositionAndOrientation, relativeScales, scales, coordinates);
    }
    if (typeof type === "string" && type.startsWith("legend") && isPolar2(coordinates)) {
      if (guide.position === "center")
        return ["center", "vertical"];
    }
    return ordinalPositionAndOrientation;
  }
  function inferScrollableType(name2, type, coordinates = []) {
    if (name2 === "x")
      return isTranspose2(coordinates) ? `${type}Y` : `${type}X`;
    if (name2 === "y")
      return isTranspose2(coordinates) ? `${type}X` : `${type}Y`;
    return null;
  }
  function inferScrollableComponents(partialOptions, scales, library3) {
    const [, createGuideComponent] = useLibrary("component", library3);
    const { coordinates } = partialOptions;
    function normalized(type, channelName, scale9, options) {
      const componentType = inferScrollableType(channelName, type, coordinates);
      if (!options || !componentType)
        return;
      const { props } = createGuideComponent(componentType);
      const { defaultPosition, defaultSize, defaultOrder, defaultCrossPadding: [crossPadding] } = props;
      return Object.assign(Object.assign({ position: defaultPosition, defaultSize, order: defaultOrder, type: componentType, crossPadding }, options), { scales: [scale9] });
    }
    return scales.filter((d2) => d2.slider || d2.scrollbar).flatMap((scale9) => {
      const { slider, scrollbar, name: channelName } = scale9;
      return [
        normalized("slider", channelName, scale9, slider),
        normalized("scrollbar", channelName, scale9, scrollbar)
      ];
    }).filter((d2) => !!d2);
  }
  function computeComponentSize(component, crossSize, crossPadding, position, theme, library3) {
    const { type } = component;
    const paddingAreas = ["left", "right", "bottom", "top"];
    if (!paddingAreas.includes(position))
      return;
    if (typeof type !== "string")
      return;
    const t = type;
    const createCompute = () => {
      if (t.startsWith("axis"))
        return computeAxisSize;
      if (t.startsWith("group"))
        return computeGroupSize;
      if (t.startsWith("legendContinuous"))
        return computeContinuousLegendSize;
      if (t === "legendCategory")
        return computeCategoryLegendSize;
      if (t.startsWith("slider"))
        return computeSliderSize;
      if (t === "title")
        return computeTitleSize;
      if (t.startsWith("scrollbar"))
        return computeScrollbarSize;
      return () => {
      };
    };
    return createCompute()(component, crossSize, crossPadding, position, theme, library3);
  }
  function computeGroupSize(component, crossSize, crossPadding, position, theme, library3) {
    const { children } = component;
    const maxCrossPadding = max4(children, (d2) => d2.crossPadding);
    children.forEach((d2) => d2.crossPadding = maxCrossPadding);
    children.forEach((child) => computeComponentSize(child, crossSize, crossPadding, position, theme, library3));
    const maxSize = max4(children, (d2) => d2.size);
    component.size = maxSize;
    children.forEach((d2) => d2.size = maxSize);
  }
  function computeScrollbarSize(component, crossSize, crossPadding, position, theme, library3) {
    const { trackSize = 6 } = deep_mix_default({}, theme.scrollbar, component);
    component.size = trackSize;
  }
  function computeTitleSize(component, crossSize, crossPadding, position, theme, library3) {
    const _a = deep_mix_default({}, theme.title, component), { title, subtitle, spacing = 0 } = _a, style = __rest73(_a, ["title", "subtitle", "spacing"]);
    if (title) {
      const titleStyle = subObject(style, "title");
      const titleBBox = computeLabelSize(title, titleStyle);
      component.size = titleBBox.height;
    }
    if (subtitle) {
      const subtitleStyle = subObject(style, "subtitle");
      const subtitleBBox = computeLabelSize(subtitle, subtitleStyle);
      component.size += spacing + subtitleBBox.height;
    }
  }
  function computeSliderSize(component, crossSize, crossPadding, position, theme, library3) {
    const styleOf2 = () => {
      const { slider } = theme;
      return deep_mix_default({}, slider, component);
    };
    const { trackSize, handleIconSize } = styleOf2();
    const size2 = Math.max(trackSize, handleIconSize * 2.4);
    component.size = size2;
  }
  function computeAxisSize(component, crossSize, crossPadding, position, theme, library3) {
    var _a;
    component.transform = component.transform || [{ type: "hide" }];
    const isVertical2 = position === "left" || position === "right";
    const style = styleOf(component, position, theme);
    const { tickLength = 0, labelSpacing = 0, titleSpacing = 0, labelAutoRotate } = style, rest = __rest73(style, ["tickLength", "labelSpacing", "titleSpacing", "labelAutoRotate"]);
    const scale9 = createScale(component, library3);
    const labelBBoxes = computeLabelsBBox(rest, scale9);
    const paddingTick = tickLength + labelSpacing;
    if (labelBBoxes && labelBBoxes.length) {
      const maxLabelWidth = max4(labelBBoxes, (d2) => d2.width);
      const maxLabelHeight = max4(labelBBoxes, (d2) => d2.height);
      if (isVertical2) {
        component.size = maxLabelWidth + paddingTick;
      } else {
        const { tickFilter, labelTransform } = component;
        if (overflowX(scale9, labelBBoxes, crossSize, crossPadding, tickFilter) && !labelTransform && labelAutoRotate !== false && labelAutoRotate !== null) {
          component.labelTransform = "rotate(90)";
          component.size = maxLabelWidth + paddingTick;
        } else {
          component.labelTransform = (_a = component.labelTransform) !== null && _a !== void 0 ? _a : "rotate(0)";
          component.size = maxLabelHeight + paddingTick;
        }
      }
    } else {
      component.size = tickLength;
    }
    const titleBBox = computeTitleBBox(rest);
    if (titleBBox) {
      if (isVertical2) {
        component.size += titleSpacing + titleBBox.width;
      } else {
        component.size += titleSpacing + titleBBox.height;
      }
    }
  }
  function computeContinuousLegendSize(component, crossSize, crossPadding, position, theme, library3) {
    const styleOf2 = () => {
      const { legendContinuous } = theme;
      return deep_mix_default({}, legendContinuous, component);
    };
    const _a = styleOf2(), { labelSpacing = 0, titleSpacing = 0 } = _a, rest = __rest73(_a, ["labelSpacing", "titleSpacing"]);
    const isVertical2 = position === "left" || position === "right";
    const ribbonStyles = subObject(rest, "ribbon");
    const { size: ribbonSize } = ribbonStyles;
    const handleIconStyles = subObject(rest, "handleIcon");
    const { size: handleIconSize } = handleIconStyles;
    const mainSize = Math.max(ribbonSize, handleIconSize * 2.4);
    component.size = mainSize;
    const scale9 = createScale(component, library3);
    const labelBBoxes = computeLabelsBBox(rest, scale9);
    if (labelBBoxes) {
      const key = isVertical2 ? "width" : "height";
      const size2 = max4(labelBBoxes, (d2) => d2[key]);
      component.size += size2 + labelSpacing;
    }
    const titleBBox = computeTitleBBox(rest);
    if (titleBBox) {
      if (isVertical2) {
        component.size = Math.max(component.size, titleBBox.width);
      } else {
        component.size += titleSpacing + titleBBox.height;
      }
    }
  }
  function computeCategoryLegendSize(component, crossSize0, crossPadding, position, theme, library3) {
    const styleOf2 = () => {
      const { legendCategory } = theme;
      const { title } = component;
      const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
      return deep_mix_default({ title: defaultTitle }, legendCategory, Object.assign(Object.assign({}, component), { title: specifiedTitle }));
    };
    const _a = styleOf2(), { itemSpacing, itemMarkerSize, titleSpacing, rowPadding, colPadding, maxCols = Infinity, maxRows = Infinity } = _a, rest = __rest73(_a, ["itemSpacing", "itemMarkerSize", "titleSpacing", "rowPadding", "colPadding", "maxCols", "maxRows"]);
    const { cols, length: length5 } = component;
    const getRows = (rows) => Math.min(rows, maxRows);
    const getCols = (cols2) => Math.min(cols2, maxCols);
    const isVertical2 = position === "left" || position === "right";
    const crossSize = length5 === void 0 ? crossSize0 + (isVertical2 ? 0 : crossPadding[0] + crossPadding[1]) : length5;
    const titleBBox = computeTitleBBox(rest);
    const scale9 = createScale(component, library3);
    const labelBBoxes = computeLabelsBBox(rest, scale9, "itemLabel");
    const height = Math.max(labelBBoxes[0].height, itemMarkerSize) + rowPadding;
    const widthOf = (w, padding = 0) => itemMarkerSize + w + itemSpacing[0] + padding;
    const computeVerticalSize = () => {
      let maxSize = -Infinity;
      let pos = 0;
      let cols2 = 1;
      let rows = 0;
      let maxRows2 = -Infinity;
      let maxPos = -Infinity;
      const titleHeight = titleBBox ? titleBBox.height : 0;
      const maxHeight = crossSize - titleHeight;
      for (const { width } of labelBBoxes) {
        const w = widthOf(width, colPadding);
        maxSize = Math.max(maxSize, w);
        if (pos + height > maxHeight) {
          cols2++;
          maxRows2 = Math.max(maxRows2, rows);
          maxPos = Math.max(maxPos, pos);
          rows = 1;
          pos = height;
        } else {
          pos += height;
          rows++;
        }
      }
      if (cols2 <= 1) {
        maxRows2 = rows;
        maxPos = pos;
      }
      component.size = maxSize * getCols(cols2);
      component.length = maxPos + titleHeight;
      deep_mix_default(component, { cols: getCols(cols2), gridRow: maxRows2 });
    };
    const computeHorizontalGrid = () => {
      const rows = Math.ceil(labelBBoxes.length / cols);
      const maxWidth = max4(labelBBoxes, (d2) => widthOf(d2.width)) * cols;
      component.size = height * getRows(rows) - rowPadding;
      component.length = Math.min(maxWidth, crossSize);
    };
    const computeHorizontalFlex = () => {
      let rows = 1;
      let pos = 0;
      let maxPos = -Infinity;
      for (const { width } of labelBBoxes) {
        const w = widthOf(width, colPadding);
        if (pos + w > crossSize) {
          maxPos = Math.max(maxPos, pos);
          pos = w;
          rows++;
        } else {
          pos += w;
        }
      }
      if (rows === 1)
        maxPos = pos;
      component.size = height * getRows(rows) - rowPadding;
      component.length = maxPos;
    };
    if (isVertical2)
      computeVerticalSize();
    else if (typeof cols === "number")
      computeHorizontalGrid();
    else
      computeHorizontalFlex();
    if (titleBBox) {
      if (isVertical2) {
        component.size = Math.max(component.size, titleBBox.width);
      } else {
        component.size += titleSpacing + titleBBox.height;
      }
    }
  }
  function createScale(component, library3) {
    const [useScale] = useLibrary("scale", library3);
    const { scales, tickCount, tickMethod } = component;
    const scaleOptions = scales.find((d2) => d2.type !== "constant" && d2.type !== "identity");
    if (tickCount !== void 0)
      scaleOptions.tickCount = tickCount;
    if (tickMethod !== void 0)
      scaleOptions.tickMethod = tickMethod;
    return useScale(scaleOptions);
  }
  function computeLabelsBBox(component, scale9, key = "label") {
    const { labelFormatter, tickFilter, label = true } = component, style = __rest73(component, ["labelFormatter", "tickFilter", "label"]);
    if (!label)
      return null;
    const labels = labelsOf(scale9, labelFormatter, tickFilter);
    const labelStyle = subObject(style, key);
    const labelStyles = labels.map((d2, i) => Object.fromEntries(Object.entries(labelStyle).map(([key2, value2]) => [
      key2,
      typeof value2 === "function" ? value2(d2, i) : value2
    ])));
    const labelBBoxes = labels.map((d2, i) => {
      const normalizeStyle = labelStyles[i];
      return computeLabelSize(d2, normalizeStyle);
    });
    const hasTransform = labelStyles.some((d2) => d2.transform);
    if (!hasTransform) {
      const I = labels.map((_2, i) => i);
      component.indexBBox = new Map(I.map((i) => [i, [labels[i], labelBBoxes[i]]]));
    }
    return labelBBoxes;
  }
  function computeTitleBBox(component) {
    const isFalsy = (x3) => x3 === false || x3 === null;
    const { title } = component, style = __rest73(component, ["title"]);
    if (isFalsy(title) || title === void 0)
      return null;
    const titleStyle = subObject(style, "title");
    const { direction: direction2, transform } = titleStyle;
    const titleText = Array.isArray(title) ? title.join(",") : title;
    if (typeof titleText !== "string")
      return null;
    const titleBBox = computeLabelSize(titleText, Object.assign(Object.assign({}, titleStyle), { transform: transform || (direction2 === "vertical" ? "rotate(-90)" : "") }));
    return titleBBox;
  }
  function styleOf(axis, position, theme) {
    const { title } = axis;
    const [defaultTitle, specifiedTitle] = Array.isArray(title) ? [title, void 0] : [void 0, title];
    const {
      axis: baseStyle,
      // @ts-ignore
      [`axis${capitalizeFirst(position)}`]: positionStyle
    } = theme;
    return deep_mix_default({ title: defaultTitle }, baseStyle, positionStyle, Object.assign(Object.assign({}, axis), { title: specifiedTitle }));
  }
  function ticksOf2(scale9, tickFilter) {
    const ticks2 = scale9.getTicks ? scale9.getTicks() : scale9.getOptions().domain;
    if (!tickFilter)
      return ticks2;
    return ticks2.filter(tickFilter);
  }
  function labelsOf(scale9, labelFormatter, tickFilter) {
    const T = ticksOf2(scale9, tickFilter);
    const ticks2 = T.map((d2) => typeof d2 === "number" ? prettyNumber2(d2) : d2);
    const formatter2 = labelFormatter ? typeof labelFormatter === "string" ? format2(labelFormatter) : labelFormatter : scale9.getFormatter ? scale9.getFormatter() : (d2) => `${d2}`;
    return ticks2.map(formatter2);
  }
  function offsetOf(scale9, d2) {
    if (!scale9.getBandWidth)
      return 0;
    const offset3 = scale9.getBandWidth(d2) / 2;
    return offset3;
  }
  function overflowX(scale9, labelBBoxes, crossSize, crossPadding, tickFilter) {
    const totalSize = sum(labelBBoxes, (d2) => d2.width);
    if (totalSize > crossSize)
      return true;
    const scaleX = scale9.clone();
    scaleX.update({ range: [0, crossSize] });
    const ticks2 = ticksOf2(scale9, tickFilter);
    const X = ticks2.map((d2) => scaleX.map(d2) + offsetOf(scaleX, d2));
    const I = ticks2.map((_2, i) => i);
    const startX = -crossPadding[0];
    const endX = crossSize + crossPadding[1];
    const extent2 = (x3, bbox) => {
      const { width } = bbox;
      return [x3 - width / 2, x3 + width / 2];
    };
    for (let i = 0; i < I.length; i++) {
      const x3 = X[i];
      const [x05, x12] = extent2(x3, labelBBoxes[i]);
      if (x05 < startX || x12 > endX)
        return true;
      const y3 = X[i + 1];
      if (y3) {
        const [y05] = extent2(y3, labelBBoxes[i + 1]);
        if (x12 > y05)
          return true;
      }
    }
    return false;
  }
  function computeLabelSize(d2, style) {
    const shape23 = normalizeLabel(d2);
    const { filter: filter2 } = style, rest = __rest73(style, ["filter"]);
    shape23.attr(Object.assign(Object.assign({}, rest), { visibility: "none" }));
    const bbox = shape23.getBBox();
    return bbox;
  }
  function normalizeLabel(d2) {
    if (d2 instanceof DisplayObject)
      return d2;
    return new Text({ style: { text: `${d2}` } });
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/runtime/layout.js
  function processAxisZ(components) {
    const axisX = components.find(({ type }) => type === "axisX");
    const axisY = components.find(({ type }) => type === "axisY");
    const axisZ = components.find(({ type }) => type === "axisZ");
    if (axisX && axisY && axisZ) {
      axisX.plane = "xy";
      axisY.plane = "xy";
      axisZ.plane = "yz";
      axisZ.origin = [axisX.bbox.x, axisX.bbox.y, 0];
      axisZ.eulerAngles = [0, -90, 0];
      axisZ.bbox.x = axisX.bbox.x;
      axisZ.bbox.y = axisX.bbox.y;
      components.push(Object.assign(Object.assign({}, axisX), { plane: "xz", showLabel: false, showTitle: false, origin: [axisX.bbox.x, axisX.bbox.y, 0], eulerAngles: [-90, 0, 0] }));
      components.push(Object.assign(Object.assign({}, axisY), { plane: "yz", showLabel: false, showTitle: false, origin: [axisY.bbox.x + axisY.bbox.width, axisY.bbox.y, 0], eulerAngles: [0, -90, 0] }));
      components.push(Object.assign(Object.assign({}, axisZ), { plane: "xz", actualPosition: "left", showLabel: false, showTitle: false, eulerAngles: [90, -90, 0] }));
    }
  }
  function computeLayout(components, options, theme, library3) {
    var _a, _b;
    const { width, height, depth, x: x3 = 0, y: y3 = 0, z = 0, inset = (_a = theme.inset) !== null && _a !== void 0 ? _a : 0, insetLeft = inset, insetTop = inset, insetBottom = inset, insetRight = inset, margin = (_b = theme.margin) !== null && _b !== void 0 ? _b : 0, marginLeft = margin, marginBottom = margin, marginTop = margin, marginRight = margin, padding = theme.padding, paddingBottom = padding, paddingLeft = padding, paddingRight = padding, paddingTop = padding } = computeInset(components, options, theme, library3);
    const MIN_CONTENT_RATIO = 1 / 4;
    const maybeClamp = (viewWidth2, paddingLeft2, paddingRight2, pl02, pr02) => {
      const { marks } = options;
      if (marks.length === 0)
        return [pl02, pr02];
      const contentSize = viewWidth2 - pl02 - pr02;
      const diff = contentSize - viewWidth2 * MIN_CONTENT_RATIO;
      if (diff > 0)
        return [pl02, pr02];
      const shrinkSize = viewWidth2 * (1 - MIN_CONTENT_RATIO);
      return [
        paddingLeft2 === "auto" ? shrinkSize * pl02 / (pl02 + pr02) : pl02,
        paddingRight2 === "auto" ? shrinkSize * pr02 / (pl02 + pr02) : pr02
      ];
    };
    const roughPadding = (padding2) => padding2 === "auto" ? 20 : padding2 !== null && padding2 !== void 0 ? padding2 : 20;
    const rpt = roughPadding(paddingTop);
    const rpb = roughPadding(paddingBottom);
    const horizontalPadding = computePadding(components, height - rpt - rpb, [rpt + marginTop, rpb + marginBottom], ["left", "right"], options, theme, library3);
    const { paddingLeft: pl0, paddingRight: pr0 } = horizontalPadding;
    const viewWidth = width - marginLeft - marginRight;
    const [pl, pr] = maybeClamp(viewWidth, paddingLeft, paddingRight, pl0, pr0);
    const iw = viewWidth - pl - pr;
    const verticalPadding = computePadding(components, iw, [pl + marginLeft, pr + marginRight], ["bottom", "top"], options, theme, library3);
    const { paddingTop: pt0, paddingBottom: pb0 } = verticalPadding;
    const viewHeight = height - marginBottom - marginTop;
    const [pb, pt] = maybeClamp(viewHeight, paddingBottom, paddingTop, pb0, pt0);
    const ih = viewHeight - pb - pt;
    return {
      width,
      height,
      depth,
      insetLeft,
      insetTop,
      insetBottom,
      insetRight,
      innerWidth: iw,
      innerHeight: ih,
      paddingLeft: pl,
      paddingRight: pr,
      paddingTop: pt,
      paddingBottom: pb,
      marginLeft,
      marginBottom,
      marginTop,
      marginRight,
      x: x3,
      y: y3,
      z
    };
  }
  function computeRoughPlotSize(options) {
    const { height, width, padding = 0, paddingLeft = padding, paddingRight = padding, paddingTop = padding, paddingBottom = padding, margin = 16, marginLeft = margin, marginRight = margin, marginTop = margin, marginBottom = margin, inset = 0, insetLeft = inset, insetRight = inset, insetTop = inset, insetBottom = inset } = options;
    const maybeAuto = (padding2) => padding2 === "auto" ? 20 : padding2;
    const finalWidth = width - maybeAuto(paddingLeft) - maybeAuto(paddingRight) - marginLeft - marginRight - insetLeft - insetRight;
    const finalHeight = height - maybeAuto(paddingTop) - maybeAuto(paddingBottom) - marginTop - marginBottom - insetTop - insetBottom;
    return { width: finalWidth, height: finalHeight };
  }
  function computeInset(components, options, theme, library3) {
    const { coordinates } = options;
    if (!isPolar2(coordinates) && !isRadial2(coordinates)) {
      return options;
    }
    const axes = components.filter((d2) => typeof d2.type === "string" && d2.type.startsWith("axis"));
    if (axes.length === 0)
      return options;
    const styles = axes.map((component) => {
      const key = component.type === "axisArc" ? "arc" : "linear";
      return styleOf(component, key, theme);
    });
    const maxLabelSpacing = max4(styles, (d2) => {
      var _a;
      return (_a = d2.labelSpacing) !== null && _a !== void 0 ? _a : 0;
    });
    const labelBBoxes = axes.flatMap((component, i) => {
      const style = styles[i];
      const scale9 = createScale(component, library3);
      const labels = computeLabelsBBox(style, scale9);
      return labels;
    }).filter(defined);
    const size2 = max4(labelBBoxes, (d2) => d2.height) + maxLabelSpacing;
    const titleBBoxes = axes.flatMap((_2, i) => {
      const style = styles[i];
      return computeTitleBBox(style);
    }).filter((d2) => d2 !== null);
    const titleSize = titleBBoxes.length === 0 ? 0 : max4(titleBBoxes, (d2) => d2.height);
    const { inset = size2, insetLeft = inset, insetBottom = inset, insetTop = inset + titleSize, insetRight = inset } = options;
    return Object.assign(Object.assign({}, options), { insetLeft, insetBottom, insetTop, insetRight });
  }
  function computePadding(components, crossSize, crossPadding, positions, options, theme, library3) {
    const positionComponents = group(components, (d2) => d2.position);
    const { padding = theme.padding, paddingLeft = padding, paddingRight = padding, paddingBottom = padding, paddingTop = padding } = options;
    const layout = {
      paddingBottom,
      paddingLeft,
      paddingTop,
      paddingRight
    };
    for (const position of positions) {
      const key = `padding${capitalizeFirst(camelCase2(position))}`;
      const components2 = positionComponents.get(position) || [];
      const value2 = layout[key];
      const defaultSizeOf = (d2) => {
        if (d2.size === void 0)
          d2.size = d2.defaultSize;
      };
      const sizeOf3 = (d2) => {
        if (d2.type === "group") {
          d2.children.forEach(defaultSizeOf);
          d2.size = max4(d2.children, (d3) => d3.size);
        } else {
          d2.size = d2.defaultSize;
        }
      };
      const autoSizeOf = (d2) => {
        if (d2.size)
          return;
        if (value2 !== "auto")
          sizeOf3(d2);
        else {
          computeComponentSize(d2, crossSize, crossPadding, position, theme, library3);
          defaultSizeOf(d2);
        }
      };
      const maybeHide = (d2) => {
        if (!d2.type.startsWith("axis"))
          return;
        if (d2.labelAutoHide === void 0)
          d2.labelAutoHide = true;
      };
      const isHorizontal3 = position === "bottom" || position === "top";
      const minOrder = min4(components2, (d2) => d2.order);
      const axes = components2.filter((d2) => d2.type.startsWith("axis") && d2.order == minOrder);
      if (axes.length)
        axes[0].crossPadding = 0;
      if (typeof value2 === "number") {
        components2.forEach(defaultSizeOf);
        components2.forEach(maybeHide);
      } else {
        if (components2.length === 0) {
          layout[key] = 0;
        } else {
          const size2 = isHorizontal3 ? crossSize + crossPadding[0] + crossPadding[1] : crossSize;
          const grouped = groupComponents(components2, size2);
          grouped.forEach(autoSizeOf);
          const totalSize = grouped.reduce((sum3, { size: size3, crossPadding: crossPadding2 = 12 }) => sum3 + size3 + crossPadding2, 0);
          layout[key] = totalSize;
        }
      }
    }
    return layout;
  }
  function placeComponents(components, coordinate, layout) {
    const positionComponents = group(components, (d2) => `${d2.plane || "xy"}-${d2.position}`);
    const { paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop, height, width, depth } = layout;
    const planes = {
      xy: createSection({
        width,
        height,
        paddingLeft,
        paddingRight,
        paddingTop,
        paddingBottom,
        marginLeft,
        marginTop,
        marginBottom,
        marginRight,
        innerHeight,
        innerWidth,
        insetBottom,
        insetLeft,
        insetRight,
        insetTop
      }),
      yz: createSection({
        width: depth,
        height,
        paddingLeft: 0,
        paddingRight: 0,
        paddingTop: 0,
        paddingBottom: 0,
        marginLeft: 0,
        marginTop: 0,
        marginBottom: 0,
        marginRight: 0,
        innerWidth: depth,
        innerHeight: height,
        insetBottom: 0,
        insetLeft: 0,
        insetRight: 0,
        insetTop: 0
      }),
      xz: createSection({
        width,
        height: depth,
        paddingLeft: 0,
        paddingRight: 0,
        paddingTop: 0,
        paddingBottom: 0,
        marginLeft: 0,
        marginTop: 0,
        marginBottom: 0,
        marginRight: 0,
        innerWidth: width,
        innerHeight: depth,
        insetBottom: 0,
        insetLeft: 0,
        insetRight: 0,
        insetTop: 0
      })
    };
    for (const [key, components2] of positionComponents.entries()) {
      const [plane, position] = key.split("-");
      const area2 = planes[plane][position];
      const [nonEntityComponents, entityComponents] = divide4(components2, (component) => {
        if (typeof component.type !== "string")
          return false;
        if (position === "center")
          return true;
        if (component.type.startsWith("axis") && ["inner", "outer"].includes(position)) {
          return true;
        }
        return false;
      });
      if (nonEntityComponents.length) {
        placeNonEntityComponents(nonEntityComponents, coordinate, area2, position);
      }
      if (entityComponents.length) {
        placePaddingArea(components2, coordinate, area2);
      }
    }
  }
  function createSection({ width, height, paddingLeft, paddingRight, paddingTop, paddingBottom, marginLeft, marginTop, marginBottom, marginRight, innerHeight, innerWidth, insetBottom, insetLeft, insetRight, insetTop }) {
    const pl = paddingLeft + marginLeft;
    const pt = paddingTop + marginTop;
    const pr = paddingRight + marginRight;
    const pb = paddingBottom + marginBottom;
    const plotWidth = width - marginLeft - marginRight;
    const centerSection = [
      pl + insetLeft,
      pt + insetTop,
      innerWidth - insetLeft - insetRight,
      innerHeight - insetTop - insetBottom,
      "center",
      null,
      null
    ];
    const xySection = {
      top: [
        pl,
        0,
        innerWidth,
        pt,
        "vertical",
        true,
        ascending,
        marginLeft,
        plotWidth
      ],
      right: [width - pr, pt, pr, innerHeight, "horizontal", false, ascending],
      bottom: [
        pl,
        height - pb,
        innerWidth,
        pb,
        "vertical",
        false,
        ascending,
        marginLeft,
        plotWidth
      ],
      left: [0, pt, pl, innerHeight, "horizontal", true, ascending],
      "top-left": [pl, 0, innerWidth, pt, "vertical", true, ascending],
      "top-right": [pl, 0, innerWidth, pt, "vertical", true, ascending],
      "bottom-left": [
        pl,
        height - pb,
        innerWidth,
        pb,
        "vertical",
        false,
        ascending
      ],
      "bottom-right": [
        pl,
        height - pb,
        innerWidth,
        pb,
        "vertical",
        false,
        ascending
      ],
      center: centerSection,
      inner: centerSection,
      outer: centerSection
    };
    return xySection;
  }
  function placeNonEntityComponents(components, coordinate, area2, position) {
    const [axisComponents, nonAxisComponents] = divide4(components, (component) => {
      if (typeof component.type === "string" && component.type.startsWith("axis")) {
        return true;
      }
      return false;
    });
    placeNonEntityAxis(axisComponents, coordinate, area2, position);
    placeCenter(nonAxisComponents, coordinate, area2);
  }
  function placeNonEntityAxis(components, coordinate, area2, position) {
    if (position === "center") {
      if (isRadar(coordinate)) {
        placeAxisRadar(components, coordinate, area2, position);
      } else if (isPolar(coordinate)) {
        placeArcLinear(components, coordinate, area2);
      } else if (isParallel(coordinate)) {
        placeAxisParallel(components, coordinate, area2, components[0].orientation);
      }
    } else if (position === "inner") {
      placeAxisArcInner(components, coordinate, area2);
    } else if (position === "outer") {
      placeAxisArcOuter(components, coordinate, area2);
    }
  }
  function placeAxisArcInner(components, coordinate, area2) {
    const [x3, y3, , height] = area2;
    const [cx, cy] = coordinate.getCenter();
    const [innerRadius] = radiusOf(coordinate);
    const r = height / 2;
    const size2 = innerRadius * r;
    const x05 = cx - size2;
    const y05 = cy - size2;
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      component.bbox = {
        x: x3 + x05,
        y: y3 + y05,
        width: size2 * 2,
        height: size2 * 2
      };
    }
  }
  function placeAxisArcOuter(components, coordinate, area2) {
    const [x3, y3, width, height] = area2;
    for (const component of components) {
      component.bbox = { x: x3, y: y3, width, height };
    }
  }
  function placeArcLinear(components, coordinate, area2) {
    const [x3, y3, width, height] = area2;
    for (const component of components) {
      component.bbox = { x: x3, y: y3, width, height };
    }
  }
  function placeAxisParallel(components, coordinate, area2, orientation) {
    if (orientation === "horizontal") {
      placeAxisParallelHorizontal(components, coordinate, area2);
    } else if (orientation === "vertical") {
      placeAxisParallelVertical(components, coordinate, area2);
    }
  }
  function placeAxisParallelVertical(components, coordinate, area2) {
    const [x3, y3, , height] = area2;
    const vector = new Array(components.length).fill(0);
    const points = coordinate.map(vector);
    const X = points.filter((_2, i) => i % 2 === 0).map((d2) => d2 + x3);
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      const x4 = X[i];
      const width = X[i + 1] - x4;
      component.bbox = { x: x4, y: y3, width, height };
    }
  }
  function placeAxisParallelHorizontal(components, coordinate, area2) {
    const [x3, y3, width] = area2;
    const vector = new Array(components.length).fill(0);
    const points = coordinate.map(vector);
    const Y = points.filter((_2, i) => i % 2 === 1).map((d2) => d2 + y3);
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      const y4 = Y[i];
      const height = Y[i + 1] - y4;
      component.bbox = { x: x3, y: y4, width, height };
    }
  }
  function placeAxisRadar(components, coordinate, area2, position) {
    const [x3, y3, width, height] = area2;
    for (const component of components) {
      component.bbox = { x: x3, y: y3, width, height };
      component.radar = {
        index: components.indexOf(component),
        count: components.length
      };
    }
  }
  function placePaddingArea(components, coordinate, area2) {
    const [x3, y3, width, height, direction2, reverse, comparator, minX, totalSize] = area2;
    const [mainStartKey, mainStartValue, crossStartKey, crossStartValue, mainSizeKey, mainSizeValue, crossSizeKey, crossSizeValue] = direction2 === "vertical" ? ["y", y3, "x", x3, "height", height, "width", width] : ["x", x3, "y", y3, "width", width, "height", height];
    components.sort((a3, b) => comparator === null || comparator === void 0 ? void 0 : comparator(a3.order, b.order));
    const isLarge = (type) => type === "title" || type === "group" || type.startsWith("legend");
    const crossSizeOf = (type, small, bigger) => {
      if (bigger === void 0)
        return small;
      if (isLarge(type))
        return bigger;
      return small;
    };
    const crossStartOf = (type, x4, minX2) => {
      if (minX2 === void 0)
        return x4;
      if (isLarge(type))
        return minX2;
      return x4;
    };
    const startValue = reverse ? mainStartValue + mainSizeValue : mainStartValue;
    for (let i = 0, start2 = startValue; i < components.length; i++) {
      const component = components[i];
      const { crossPadding = 0, type } = component;
      const { size: size2 } = component;
      component.bbox = {
        [mainStartKey]: reverse ? start2 - size2 - crossPadding : start2 + crossPadding,
        [crossStartKey]: crossStartOf(type, crossStartValue, minX),
        [mainSizeKey]: size2,
        [crossSizeKey]: crossSizeOf(type, crossSizeValue, totalSize)
      };
      start2 += (size2 + crossPadding) * (reverse ? -1 : 1);
    }
    const groupComponents2 = components.filter((d2) => d2.type === "group");
    for (const group3 of groupComponents2) {
      const { bbox, children } = group3;
      const size2 = bbox[crossSizeKey];
      const step2 = size2 / children.length;
      const justifyContent = children.reduce((j, child) => {
        var _a;
        const j0 = (_a = child.layout) === null || _a === void 0 ? void 0 : _a.justifyContent;
        return j0 ? j0 : j;
      }, "flex-start");
      const L = children.map((d2, i) => {
        const { length: length5 = step2, padding = 0 } = d2;
        return length5 + (i === children.length - 1 ? 0 : padding);
      });
      const totalLength = sum(L);
      const diff = size2 - totalLength;
      const offset3 = justifyContent === "flex-start" ? 0 : justifyContent === "center" ? diff / 2 : diff;
      for (let i = 0, start2 = bbox[crossStartKey] + offset3; i < children.length; i++) {
        const component = children[i];
        const { padding = 0 } = component;
        const interval2 = i === children.length - 1 ? 0 : padding;
        component.bbox = {
          [mainSizeKey]: bbox[mainSizeKey],
          [mainStartKey]: bbox[mainStartKey],
          [crossStartKey]: start2,
          [crossSizeKey]: L[i] - interval2
        };
        deep_mix_default(component, { layout: { justifyContent } });
        start2 += L[i];
      }
    }
  }
  function placeCenter(components, coordinate, area2) {
    if (components.length === 0)
      return;
    const [x3, y3, width, height] = area2;
    const [innerRadius] = radiusOf(coordinate);
    const r = height / 2 * innerRadius / Math.sqrt(2);
    const cx = x3 + width / 2;
    const cy = y3 + height / 2;
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      component.bbox = { x: cx - r, y: cy - r, width: r * 2, height: r * 2 };
    }
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/runtime/transform.js
  var __awaiter4 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest74 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function applyDefaults(I, mark, context) {
    const { encode = {}, scale: scale9 = {}, transform = [] } = mark, rest = __rest74(mark, ["encode", "scale", "transform"]);
    return [I, Object.assign(Object.assign({}, rest), { encode, scale: scale9, transform })];
  }
  function applyDataTransform(I, mark, context) {
    return __awaiter4(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const { data: data2 } = mark;
      const [useData] = useLibrary("data", library3);
      const descriptor = normalizedDataSource(data2);
      const { transform: T = [] } = descriptor, connector = __rest74(descriptor, ["transform"]);
      const transform = [connector, ...T];
      const transformFunctions2 = transform.map((t) => useData(t, context));
      const transformedData = yield composeAsync(transformFunctions2)(data2);
      const newData = data2 && !Array.isArray(data2) && !Array.isArray(transformedData) ? { value: transformedData } : transformedData;
      return [
        Array.isArray(transformedData) ? indexOf3(transformedData) : [],
        Object.assign(Object.assign({}, mark), { data: newData })
      ];
    });
  }
  function flatEncode(I, mark, context) {
    const { encode } = mark;
    if (!encode)
      return [I, mark];
    const flattenEncode = {};
    for (const [key, value2] of Object.entries(encode)) {
      if (Array.isArray(value2)) {
        for (let i = 0; i < value2.length; i++) {
          const name2 = `${key}${i === 0 ? "" : i}`;
          flattenEncode[name2] = value2[i];
        }
      } else {
        flattenEncode[key] = value2;
      }
    }
    return [I, Object.assign(Object.assign({}, mark), { encode: flattenEncode })];
  }
  function inferChannelsType(I, mark, context) {
    const { encode, data: data2 } = mark;
    if (!encode)
      return [I, mark];
    const typedEncode = mapObject(encode, (channel) => {
      if (isTypedChannel(channel))
        return channel;
      const type = inferChannelType(data2, channel);
      return { type, value: channel };
    });
    return [I, Object.assign(Object.assign({}, mark), { encode: typedEncode })];
  }
  function maybeVisualChannel(I, mark, context) {
    const { encode } = mark;
    if (!encode)
      return [I, mark];
    const newEncode = mapObject(encode, (channel, name2) => {
      const { type } = channel;
      if (type !== "constant" || isPosition(name2))
        return channel;
      return Object.assign(Object.assign({}, channel), { constant: true });
    });
    return [I, Object.assign(Object.assign({}, mark), { encode: newEncode })];
  }
  function extractColumns(I, mark, context) {
    const { encode, data: data2 } = mark;
    if (!encode)
      return [I, mark];
    const { library: library3 } = context;
    const columnOf2 = createColumnOf(library3);
    const valuedEncode = mapObject(encode, (channel) => columnOf2(data2, channel));
    return [I, Object.assign(Object.assign({}, mark), { encode: valuedEncode })];
  }
  function normalizeTooltip(I, mark, context) {
    const { tooltip: tooltip2 = {} } = mark;
    if (isUnset(tooltip2))
      return [I, mark];
    if (Array.isArray(tooltip2)) {
      return [I, Object.assign(Object.assign({}, mark), { tooltip: { items: tooltip2 } })];
    }
    if (isStrictObject(tooltip2) && isFullTooltip(tooltip2)) {
      return [I, Object.assign(Object.assign({}, mark), { tooltip: tooltip2 })];
    }
    return [I, Object.assign(Object.assign({}, mark), { tooltip: { items: [tooltip2] } })];
  }
  function extractTooltip(I, mark, context) {
    const { data: data2, encode, tooltip: tooltip2 = {} } = mark;
    if (isUnset(tooltip2))
      return [I, mark];
    const valueOf4 = (item) => {
      if (!item)
        return item;
      if (typeof item === "string") {
        return I.map((i) => ({ name: item, value: data2[i][item] }));
      }
      if (isStrictObject(item)) {
        const { field: field3, channel, color: color2, name: name2 = field3, valueFormatter = (d2) => d2 } = item;
        const normalizedValueFormatter = typeof valueFormatter === "string" ? format2(valueFormatter) : valueFormatter;
        const definedChannel = channel && encode[channel];
        const channelField = definedChannel && encode[channel].field;
        const name1 = name2 || channelField || channel;
        const values = [];
        for (const i of I) {
          const value1 = field3 ? data2[i][field3] : definedChannel ? encode[channel].value[i] : null;
          values[i] = {
            name: name1,
            color: color2,
            value: normalizedValueFormatter(value1)
          };
        }
        return values;
      }
      if (typeof item === "function") {
        const values = [];
        for (const i of I) {
          const v = item(data2[i], i, data2, encode);
          if (isStrictObject(v))
            values[i] = v;
          else
            values[i] = { value: v };
        }
        return values;
      }
      return item;
    };
    const { title, items = [] } = tooltip2, rest = __rest74(tooltip2, ["title", "items"]);
    const newTooltip = Object.assign({ title: valueOf4(title), items: Array.isArray(items) ? items.map(valueOf4) : [] }, rest);
    return [I, Object.assign(Object.assign({}, mark), { tooltip: newTooltip })];
  }
  function maybeArrayField(I, mark, context) {
    const { encode } = mark, rest = __rest74(mark, ["encode"]);
    if (!encode)
      return [I, mark];
    const columns = Object.entries(encode);
    const arrayColumns = columns.filter(([, channel]) => {
      const { value: V } = channel;
      return Array.isArray(V[0]);
    }).flatMap(([key, V]) => {
      const columns2 = [[key, new Array(I.length).fill(void 0)]];
      const { value: rows } = V, rest2 = __rest74(V, ["value"]);
      for (let i = 0; i < rows.length; i++) {
        const row2 = rows[i];
        if (Array.isArray(row2)) {
          for (let j = 0; j < row2.length; j++) {
            const column2 = columns2[j] || [
              `${key}${j}`,
              new Array(I).fill(void 0)
            ];
            column2[1][i] = row2[j];
            columns2[j] = column2;
          }
        }
      }
      return columns2.map(([key2, value2]) => [
        key2,
        Object.assign({ type: "column", value: value2 }, rest2)
      ]);
    });
    const newEncode = Object.fromEntries([...columns, ...arrayColumns]);
    return [I, Object.assign(Object.assign({}, rest), { encode: newEncode })];
  }
  function addGuideToScale(I, mark, context) {
    const { axis = {}, legend = {}, slider = {}, scrollbar = {} } = mark;
    const normalize10 = (guide, channel) => {
      if (typeof guide === "boolean")
        return guide ? {} : null;
      const eachGuide = guide[channel];
      return eachGuide === void 0 || eachGuide ? eachGuide : null;
    };
    const axisChannels = typeof axis === "object" ? Array.from(/* @__PURE__ */ new Set(["x", "y", "z", ...Object.keys(axis)])) : ["x", "y", "z"];
    deep_mix_default(mark, {
      scale: Object.assign(Object.assign({}, Object.fromEntries(axisChannels.map((channel) => {
        const scrollbarOptions = normalize10(scrollbar, channel);
        return [
          channel,
          Object.assign({ guide: normalize10(axis, channel), slider: normalize10(slider, channel), scrollbar: scrollbarOptions }, scrollbarOptions && {
            ratio: scrollbarOptions.ratio === void 0 ? 0.5 : scrollbarOptions.ratio
          })
        ];
      }))), {
        color: { guide: normalize10(legend, "color") },
        size: { guide: normalize10(legend, "size") },
        shape: { guide: normalize10(legend, "shape") },
        // fixme: opacity is conflict with DisplayObject.opacity
        // to be confirm.
        opacity: { guide: normalize10(legend, "opacity") }
      })
    });
    return [I, mark];
  }
  function maybeNonAnimate(I, mark, context) {
    const { animate: animate2 } = mark;
    if (animate2 || animate2 === void 0)
      return [I, mark];
    deep_mix_default(mark, {
      animate: {
        enter: { type: null },
        exit: { type: null },
        update: { type: null }
      }
    });
    return [I, mark];
  }
  function isTypedChannel(channel) {
    if (typeof channel !== "object" || channel instanceof Date || channel === null) {
      return false;
    }
    const { type } = channel;
    return defined(type);
  }
  function inferChannelType(data2, channel) {
    if (typeof channel === "function")
      return "transform";
    if (typeof channel === "string" && isField(data2, channel))
      return "field";
    return "constant";
  }
  function isField(data2, value2) {
    if (!Array.isArray(data2))
      return false;
    return data2.some((d2) => d2[value2] !== void 0);
  }
  function normalizedDataSource(data2) {
    if (is_number_default(data2))
      return { type: "inline", value: data2 };
    if (!data2)
      return { type: "inline", value: null };
    if (Array.isArray(data2))
      return { type: "inline", value: data2 };
    const { type = "inline" } = data2, rest = __rest74(data2, ["type"]);
    return Object.assign(Object.assign({}, rest), { type });
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/runtime/mark.js
  var __awaiter5 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest75 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function initializeMark(partialMark, partialProps, context) {
    return __awaiter5(this, void 0, void 0, function* () {
      const [I, transformedMark] = yield applyMarkTransform(partialMark, partialProps, context);
      const { encode, scale: scale9, data: data2, tooltip: tooltip2 } = transformedMark;
      if (Array.isArray(data2) === false) {
        return null;
      }
      const { channels: channelDescriptors } = partialProps;
      const nameChannels = rollups(Object.entries(encode).filter(([, value2]) => defined(value2)), (values) => values.map(([key, options]) => Object.assign({ name: key }, options)), ([key]) => {
        var _a;
        const prefix = (_a = /([^\d]+)\d*$/.exec(key)) === null || _a === void 0 ? void 0 : _a[1];
        const descriptor = channelDescriptors.find((d2) => d2.name === prefix);
        if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.independent)
          return key;
        return prefix;
      });
      const channels = channelDescriptors.filter((descriptor) => {
        const { name: name2, required: required2 } = descriptor;
        if (nameChannels.find(([d2]) => d2 === name2))
          return true;
        if (required2)
          throw new Error(`Missing encoding for channel: ${name2}.`);
        return false;
      }).flatMap((descriptor) => {
        const { name: name2, scale: scaleType, scaleKey, range: range3, quantitative, ordinal } = descriptor;
        const valuesArray = nameChannels.filter(([channel]) => channel.startsWith(name2));
        return valuesArray.map(([channel, values], i) => {
          const visual = values.some((d2) => d2.visual);
          const constant4 = values.some((d2) => d2.constant);
          const _a = scale9[channel] || {}, {
            independent = false,
            // Use channel name as default scale key.
            key = scaleKey || channel,
            // Visual channel use identity scale.
            type = constant4 ? "constant" : visual ? "identity" : scaleType
          } = _a, scaleOptions = __rest75(_a, ["independent", "key", "type"]);
          const isConstant = type === "constant";
          const finalRange = isConstant ? void 0 : range3;
          return {
            name: channel,
            values,
            // Generate a unique key for independent channel,
            // which will not group with any other channels.
            scaleKey: independent || isConstant ? Symbol("independent") : key,
            scale: Object.assign(Object.assign({ type, range: finalRange }, scaleOptions), {
              quantitative,
              ordinal
            })
          };
        });
      });
      return [transformedMark, Object.assign(Object.assign({}, partialProps), { index: I, channels, tooltip: tooltip2 })];
    });
  }
  function createColumnOf(library3) {
    const [useEncode] = useLibrary("encode", library3);
    return (data2, encode) => {
      if (encode === void 0)
        return null;
      if (data2 === void 0)
        return null;
      return Object.assign(Object.assign({}, encode), { type: "column", value: useEncode(encode)(data2), field: fieldOf(encode) });
    };
  }
  function applyMarkTransform(mark, props, context) {
    return __awaiter5(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const [useTransform] = useLibrary("transform", library3);
      const { preInference = [], postInference = [] } = props;
      const { transform = [] } = mark;
      const transforms = [
        applyDefaults,
        applyDataTransform,
        flatEncode,
        inferChannelsType,
        maybeVisualChannel,
        extractColumns,
        maybeArrayField,
        maybeNonAnimate,
        addGuideToScale,
        normalizeTooltip,
        ...preInference.map(useTransform),
        ...transform.map(useTransform),
        ...postInference.map(useTransform),
        extractTooltip
      ];
      let index4 = [];
      let transformedMark = mark;
      for (const t of transforms) {
        [index4, transformedMark] = yield t(index4, transformedMark, context);
      }
      return [index4, transformedMark];
    });
  }
  function fieldOf(encode) {
    const { type, value: value2 } = encode;
    if (type === "field" && typeof value2 === "string")
      return value2;
    return null;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/runtime/plot.js
  var __awaiter6 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest76 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function plot(options, selection, context) {
    var _a;
    return __awaiter6(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const [useComposition] = useLibrary("composition", library3);
      const [useInteraction] = useLibrary("interaction", library3);
      const marks = new Set(Object.keys(library3).map((d2) => {
        var _a2;
        return (_a2 = /mark\.(.*)/.exec(d2)) === null || _a2 === void 0 ? void 0 : _a2[1];
      }).filter(defined));
      const staticMarks = new Set(Object.keys(library3).map((d2) => {
        var _a2;
        return (_a2 = /component\.(.*)/.exec(d2)) === null || _a2 === void 0 ? void 0 : _a2[1];
      }).filter(defined));
      const typeOf = (node) => {
        const { type } = node;
        if (typeof type === "function") {
          const { props = {} } = type;
          const { composite = true } = props;
          if (composite)
            return "mark";
        }
        if (typeof type !== "string")
          return type;
        if (marks.has(type) || staticMarks.has(type))
          return "mark";
        return type;
      };
      const isMark2 = (node) => typeOf(node) === "mark";
      const isStandardView = (node) => typeOf(node) === "standardView";
      const isStaticMark = (node) => {
        const { type } = node;
        if (typeof type !== "string")
          return false;
        if (staticMarks.has(type))
          return true;
        return false;
      };
      const transform = (node) => {
        if (isStandardView(node))
          return [node];
        const type = typeOf(node);
        const composition = useComposition({ type, static: isStaticMark(node) });
        return composition(node);
      };
      const views = [];
      const viewNode = /* @__PURE__ */ new Map();
      const nodeState = /* @__PURE__ */ new Map();
      const discovered = [options];
      const nodeGenerators = [];
      while (discovered.length) {
        const node = discovered.shift();
        if (isStandardView(node)) {
          const state = nodeState.get(node);
          const [view, children] = state ? initializeState(state, node, library3) : yield initializeView(node, context);
          viewNode.set(view, node);
          views.push(view);
          const transformedNodes = children.flatMap(transform).map((d2) => coordinate2Transform(d2, library3));
          discovered.push(...transformedNodes);
          if (transformedNodes.every(isStandardView)) {
            const states = yield Promise.all(transformedNodes.map((d2) => initializeMarks(d2, context)));
            syncFacetsScales(states);
            for (let i = 0; i < transformedNodes.length; i++) {
              const nodeT = transformedNodes[i];
              const state2 = states[i];
              nodeState.set(nodeT, state2);
            }
          }
        } else {
          const n2 = isMark2(node) ? node : yield applyTransform(node, context);
          const N = transform(n2);
          if (Array.isArray(N))
            discovered.push(...N);
          else if (typeof N === "function")
            nodeGenerators.push(N());
        }
      }
      context.emitter.emit(ChartEvent.BEFORE_PAINT);
      const enterContainer = /* @__PURE__ */ new Map();
      const updateContainer = /* @__PURE__ */ new Map();
      const transitions = [];
      selection.selectAll(className(VIEW_CLASS_NAME)).data(views, (d2) => d2.key).join((enter) => enter.append("g").attr("className", VIEW_CLASS_NAME).attr("id", (view) => view.key).call(applyTranslate).each(function(view, i, element) {
        plotView(view, select(element), transitions, context);
        enterContainer.set(view, element);
      }), (update) => update.call(applyTranslate).each(function(view, i, element) {
        plotView(view, select(element), transitions, context);
        updateContainer.set(view, element);
      }), (exit) => exit.each(function(d2, i, element) {
        const interactions = element["nameInteraction"].values();
        for (const interaction of interactions) {
          interaction.destroy();
        }
      }).remove());
      const viewInstanceof = (viewContainer, updateInteractions2, oldStore) => {
        return Array.from(viewContainer.entries()).map(([view, container]) => {
          const store = oldStore || /* @__PURE__ */ new Map();
          const setState = (key, reducer = (x3) => x3) => store.set(key, reducer);
          const options2 = viewNode.get(view);
          const update = createUpdateView(select(container), options2, context);
          return {
            view,
            container,
            options: options2,
            setState,
            update: (from, updateTypes) => __awaiter6(this, void 0, void 0, function* () {
              const reducer = compose(Array.from(store.values()));
              const newOptions = reducer(options2);
              return yield update(newOptions, from, () => {
                if (is_array_default(updateTypes)) {
                  updateInteractions2(viewContainer, updateTypes, store);
                }
              });
            })
          };
        });
      };
      const updateInteractions = (container = updateContainer, updateType, oldStore) => {
        var _a2;
        const updateViewInstances = viewInstanceof(container, updateInteractions, oldStore);
        for (const target of updateViewInstances) {
          const { options: options2, container: container2 } = target;
          const nameInteraction = container2["nameInteraction"];
          let typeOptions = inferInteraction(options2);
          if (updateType) {
            typeOptions = typeOptions.filter((v) => updateType.includes(v[0]));
          }
          for (const typeOption of typeOptions) {
            const [type, option2] = typeOption;
            const prevInteraction = nameInteraction.get(type);
            if (prevInteraction)
              (_a2 = prevInteraction.destroy) === null || _a2 === void 0 ? void 0 : _a2.call(prevInteraction);
            if (option2) {
              const interaction = useThemeInteraction(target.view, type, option2, useInteraction);
              const destroy3 = interaction(target, updateViewInstances, context.emitter);
              nameInteraction.set(type, { destroy: destroy3 });
            }
          }
        }
      };
      const enterViewInstances = viewInstanceof(enterContainer, updateInteractions);
      for (const target of enterViewInstances) {
        const { options: options2 } = target;
        const nameInteraction = /* @__PURE__ */ new Map();
        target.container["nameInteraction"] = nameInteraction;
        for (const typeOption of inferInteraction(options2)) {
          const [type, option2] = typeOption;
          if (option2) {
            const interaction = useThemeInteraction(target.view, type, option2, useInteraction);
            const destroy3 = interaction(target, enterViewInstances, context.emitter);
            nameInteraction.set(type, { destroy: destroy3 });
          }
        }
      }
      updateInteractions();
      const { width, height } = options;
      const keyframes = [];
      for (const nodeGenerator of nodeGenerators) {
        const keyframe = new Promise((resolve) => __awaiter6(this, void 0, void 0, function* () {
          for (const node of nodeGenerator) {
            const sizedNode = Object.assign({ width, height }, node);
            yield plot(sizedNode, selection, context);
          }
          resolve();
        }));
        keyframes.push(keyframe);
      }
      context.views = views;
      (_a = context.animations) === null || _a === void 0 ? void 0 : _a.forEach((animation) => animation === null || animation === void 0 ? void 0 : animation.cancel());
      context.animations = transitions;
      context.emitter.emit(ChartEvent.AFTER_PAINT);
      const finished = transitions.filter(defined).map(cancel).map((d2) => d2.finished);
      return Promise.all([...finished, ...keyframes]);
    });
  }
  function applyTranslate(selection) {
    selection.style("transform", (d2) => `translate(${d2.layout.x}, ${d2.layout.y})`);
  }
  function definedInteraction(library3) {
    const [, createInteraction] = useLibrary("interaction", library3);
    return (d2) => {
      const [name2, options] = d2;
      try {
        return [name2, createInteraction(name2)];
      } catch (_a) {
        return [name2, options.type];
      }
    };
  }
  function createUpdateView(selection, options, context) {
    const { library: library3 } = context;
    const createDefinedInteraction = definedInteraction(library3);
    const filter2 = (d2) => d2[1] && d2[1].props && d2[1].props.reapplyWhenUpdate;
    const interactions = inferInteraction(options);
    const updates = interactions.map(createDefinedInteraction).filter(filter2).map((d2) => d2[0]);
    return (newOptions, source, callback) => __awaiter6(this, void 0, void 0, function* () {
      const transitions = [];
      const [newView, newChildren] = yield initializeView(newOptions, context);
      plotView(newView, selection, transitions, context);
      for (const name2 of updates.filter((d2) => d2 !== source)) {
        updateInteraction(name2, selection, newOptions, newView, context);
      }
      for (const child of newChildren) {
        plot(child, selection, context);
      }
      callback();
      return { options: newOptions, view: newView };
    });
  }
  function updateInteraction(name2, selection, options, view, context) {
    var _a;
    const { library: library3 } = context;
    const [useInteraction] = useLibrary("interaction", library3);
    const container = selection.node();
    const nameInteraction = container["nameInteraction"];
    const interactionOptions = inferInteraction(options).find(([d2]) => d2 === name2);
    const interaction = nameInteraction.get(name2);
    if (!interaction)
      return;
    (_a = interaction.destroy) === null || _a === void 0 ? void 0 : _a.call(interaction);
    if (!interactionOptions[1])
      return;
    const applyInteraction = useThemeInteraction(view, name2, interactionOptions[1], useInteraction);
    const target = {
      options,
      view,
      container: selection.node(),
      update: (options2) => Promise.resolve(options2)
    };
    const destroy3 = applyInteraction(target, [], context.emitter);
    nameInteraction.set(name2, { destroy: destroy3 });
  }
  function initializeView(options, context) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const flattenOptions = yield transformMarks(options, context);
      const mergedOptions = bubbleOptions(flattenOptions);
      options.interaction = mergedOptions.interaction;
      options.coordinate = mergedOptions.coordinate;
      options.marks = [...mergedOptions.marks, ...mergedOptions.components];
      const transformedOptions = coordinate2Transform(mergedOptions, library3);
      const state = yield initializeMarks(transformedOptions, context);
      return initializeState(state, transformedOptions, library3);
    });
  }
  function bubbleOptions(options) {
    const { coordinate: viewCoordinate = {}, interaction: viewInteraction = {}, style: viewStyle = {}, marks } = options, rest = __rest76(options, ["coordinate", "interaction", "style", "marks"]);
    const markCoordinates = marks.map((d2) => d2.coordinate || {});
    const markInteractions = marks.map((d2) => d2.interaction || {});
    const markViewStyles = marks.map((d2) => d2.viewStyle || {});
    const newCoordinate = [...markCoordinates, viewCoordinate].reduceRight((prev, cur) => deep_mix_default(prev, cur), {});
    const newInteraction = [viewInteraction, ...markInteractions].reduce((prev, cur) => deep_mix_default(prev, cur), {});
    const newStyle = [...markViewStyles, viewStyle].reduce((prev, cur) => deep_mix_default(prev, cur), {});
    return Object.assign(Object.assign({}, rest), { marks, coordinate: newCoordinate, interaction: newInteraction, style: newStyle });
  }
  function transformMarks(options, context) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const [useMark, createMark] = useLibrary("mark", library3);
      const staticMarks = new Set(Object.keys(library3).map((d2) => {
        var _a;
        return (_a = /component\.(.*)/.exec(d2)) === null || _a === void 0 ? void 0 : _a[1];
      }).filter(defined));
      const { marks } = options;
      const flattenMarks = [];
      const components = [];
      const discovered = [...marks];
      const { width, height } = computeRoughPlotSize(options);
      const markOptions = { options, width, height };
      while (discovered.length) {
        const [node] = discovered.splice(0, 1);
        const mark = yield applyTransform(node, context);
        const { type = error2("G2Mark type is required."), key } = mark;
        if (staticMarks.has(type))
          components.push(mark);
        else {
          const { props = {} } = createMark(type);
          const { composite = true } = props;
          if (!composite)
            flattenMarks.push(mark);
          else {
            const { data: data2 } = mark;
            const newMark = Object.assign(Object.assign({}, mark), { data: data2 ? Array.isArray(data2) ? data2 : data2.value : data2 });
            const marks2 = yield useMark(newMark, markOptions);
            const M2 = Array.isArray(marks2) ? marks2 : [marks2];
            discovered.unshift(...M2.map((d2, i) => Object.assign(Object.assign({}, d2), { key: `${key}-${i}` })));
          }
        }
      }
      return Object.assign(Object.assign({}, options), { marks: flattenMarks, components });
    });
  }
  function initializeMarks(options, context) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const [useTheme] = useLibrary("theme", library3);
      const [, createMark] = useLibrary("mark", library3);
      const { theme: partialTheme, marks: partialMarks, coordinates = [] } = options;
      const theme = useTheme(inferTheme(partialTheme));
      const markState = /* @__PURE__ */ new Map();
      for (const markOptions of partialMarks) {
        const { type } = markOptions;
        const { props = {} } = createMark(type);
        const markAndState = yield initializeMark(markOptions, props, context);
        if (markAndState) {
          const [initializedMark, state] = markAndState;
          markState.set(initializedMark, state);
        }
      }
      const scaleChannels = group(Array.from(markState.values()).flatMap((d2) => d2.channels), ({ scaleKey }) => scaleKey);
      for (const channels of scaleChannels.values()) {
        const scaleOptions = channels.reduce((total, { scale: scale10 }) => deep_mix_default(total, scale10), {});
        const { scaleKey } = channels[0];
        const { values: FV } = channels[0];
        const fields = Array.from(new Set(FV.map((d2) => d2.field).filter(defined)));
        const options2 = deep_mix_default({
          guide: { title: fields.length === 0 ? void 0 : fields },
          field: fields[0]
        }, scaleOptions);
        const { name: name2 } = channels[0];
        const values = channels.flatMap(({ values: values2 }) => values2.map((d2) => d2.value));
        const scale9 = Object.assign(Object.assign({}, inferScale(name2, values, options2, coordinates, theme, library3)), { uid: Symbol("scale"), key: scaleKey });
        channels.forEach((channel) => channel.scale = scale9);
      }
      return markState;
    });
  }
  function useThemeInteraction(view, type, option2, useInteraction) {
    const theme = view.theme;
    const defaults5 = typeof type === "string" ? theme[type] || {} : {};
    const interaction = useInteraction(deep_mix_default(defaults5, Object.assign({ type }, option2)));
    return interaction;
  }
  function initializeState(markState, options, library3) {
    var _a;
    const [useMark] = useLibrary("mark", library3);
    const [useTheme] = useLibrary("theme", library3);
    const [useLabelTransform] = useLibrary("labelTransform", library3);
    const { key, frame: frame2 = false, theme: partialTheme, clip, style = {}, labelTransform = [] } = options;
    const theme = useTheme(inferTheme(partialTheme));
    const states = Array.from(markState.values());
    const scales = collectScales(states, options);
    const components = normalizeComponents(inferComponent(inferComponentScales(Array.from(scales), states, markState), options, library3));
    const layout = computeLayout(components, options, theme, library3);
    const coordinate = createCoordinate(layout, options, library3);
    const framedStyle = frame2 ? deep_mix_default({ mainLineWidth: 1, mainStroke: "#000" }, style) : style;
    placeComponents(groupComponents(components), coordinate, layout);
    processAxisZ(components);
    const uidScale = new Map(Array.from(markState.values()).flatMap((state) => {
      const { channels } = state;
      return channels.map(({ scale: scale9 }) => [
        scale9.uid,
        useRelationScale(scale9, library3)
      ]);
    }));
    groupTransform(markState, uidScale);
    const scaleInstance = {};
    for (const component of components) {
      const { scales: scaleDescriptors = [] } = component;
      const scales2 = [];
      for (const descriptor of scaleDescriptors) {
        const { name: name2, uid } = descriptor;
        const scale9 = (_a = uidScale.get(uid)) !== null && _a !== void 0 ? _a : useRelationScale(descriptor, library3);
        scales2.push(scale9);
        if (name2 === "y") {
          scale9.update(Object.assign(Object.assign({}, scale9.getOptions()), { xScale: scaleInstance.x }));
        }
        assignScale(scaleInstance, { [name2]: scale9 });
      }
      component.scaleInstances = scales2;
    }
    const children = [];
    for (const [mark, state] of markState.entries()) {
      const {
        // scale,
        // Callback to create children options based on this mark.
        children: createChildren,
        // The total count of data (both show and hide)for this facet.
        // This is for unit visualization to sync data domain.
        dataDomain,
        modifier,
        key: markKey
      } = mark;
      const { index: index4, channels, tooltip: tooltip2 } = state;
      const scale9 = Object.fromEntries(channels.map(({ name: name2, scale: scale10 }) => [name2, scale10]));
      const markScaleInstance = mapObject(scale9, ({ uid }) => uidScale.get(uid));
      assignScale(scaleInstance, markScaleInstance);
      const value2 = applyScale(channels, markScaleInstance);
      const calcPoints = useMark(mark);
      const [I, P, S] = filterValid(calcPoints(index4, markScaleInstance, value2, coordinate));
      const count4 = dataDomain || I.length;
      const T = modifier ? modifier(P, count4, layout) : [];
      const titleOf = (i) => {
        var _a2, _b;
        return (_b = (_a2 = tooltip2.title) === null || _a2 === void 0 ? void 0 : _a2[i]) === null || _b === void 0 ? void 0 : _b.value;
      };
      const itemsOf2 = (i) => tooltip2.items.map((V) => V[i]);
      const visualData = I.map((d2, i) => {
        const datum = Object.assign({ points: P[i], transform: T[i], index: d2, markKey, viewKey: key }, tooltip2 && {
          title: titleOf(d2),
          items: itemsOf2(d2)
        });
        for (const [k, V] of Object.entries(value2)) {
          datum[k] = V[d2];
          if (S)
            datum[`series${upper_first_default(k)}`] = S[i].map((i2) => V[i2]);
        }
        if (S)
          datum["seriesIndex"] = S[i];
        if (S && tooltip2) {
          datum["seriesItems"] = S[i].map((si) => itemsOf2(si));
          datum["seriesTitle"] = S[i].map((si) => titleOf(si));
        }
        return datum;
      });
      state.data = visualData;
      state.index = I;
      const markChildren = createChildren === null || createChildren === void 0 ? void 0 : createChildren(visualData, markScaleInstance, layout);
      children.push(...markChildren || []);
    }
    const view = {
      layout,
      theme,
      coordinate,
      markState,
      key,
      clip,
      scale: scaleInstance,
      style: framedStyle,
      components,
      labelTransform: compose(labelTransform.map(useLabelTransform))
    };
    return [view, children];
  }
  function plotView(view, selection, transitions, context) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { library: library3 } = context;
      const { components, theme, layout, markState, coordinate, key, style, clip, scale: scale9 } = view;
      const { x: x3, y: y3, width, height } = layout, rest = __rest76(layout, ["x", "y", "width", "height"]);
      const areaKeys = ["view", "plot", "main", "content"];
      const I = areaKeys.map((_2, i) => i);
      const sizeKeys = ["a", "margin", "padding", "inset"];
      const areaStyles = areaKeys.map((d2) => maybeSubObject(Object.assign({}, theme.view, style), d2));
      const areaSizes = sizeKeys.map((d2) => subObject(rest, d2));
      const styleArea = (selection2) => selection2.style("x", (i) => areaLayouts[i].x).style("y", (i) => areaLayouts[i].y).style("width", (i) => areaLayouts[i].width).style("height", (i) => areaLayouts[i].height).each(function(i, d2, element) {
        applyStyle2(select(element), areaStyles[i]);
      });
      let px = 0;
      let py = 0;
      let pw = width;
      let ph = height;
      const areaLayouts = I.map((i) => {
        const size2 = areaSizes[i];
        const { left: left2 = 0, top = 0, bottom = 0, right: right2 = 0 } = size2;
        px += left2;
        py += top;
        pw -= left2 + right2;
        ph -= top + bottom;
        return {
          x: px,
          y: py,
          width: pw,
          height: ph
        };
      });
      selection.selectAll(className(AREA_CLASS_NAME)).data(
        // Only render area with defined style.
        I.filter((i) => defined(areaStyles[i])),
        (i) => areaKeys[i]
      ).join((enter) => enter.append("rect").attr("className", AREA_CLASS_NAME).style("zIndex", -2).call(styleArea), (update) => update.call(styleArea), (exit) => exit.remove());
      const animationExtent = computeAnimationExtent(markState);
      const componentAnimateOptions = animationExtent ? { duration: animationExtent[1] } : false;
      for (const [, C3] of groups(components, (d2) => `${d2.type}-${d2.position}`)) {
        C3.forEach((d2, i) => d2.index = i);
      }
      const componentsTransitions = selection.selectAll(className(COMPONENT_CLASS_NAME)).data(components, (d2) => `${d2.type}-${d2.position}-${d2.index}`).join((enter) => enter.append("g").style("zIndex", ({ zIndex }) => zIndex || -1).attr("className", COMPONENT_CLASS_NAME).append((options) => renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale9 }, options), coordinate, theme, library3, markState)), (update) => update.transition(function(options, i, element) {
        const { preserve = false } = options;
        if (preserve)
          return;
        const newComponent = renderComponent(deep_mix_default({ animate: componentAnimateOptions, scale: scale9 }, options), coordinate, theme, library3, markState);
        const { attributes } = newComponent;
        const [node] = element.childNodes;
        return node.update(attributes, false);
      })).transitions();
      transitions.push(...componentsTransitions.flat().filter(defined));
      const T = selection.selectAll(className(PLOT_CLASS_NAME)).data([layout], () => key).join((enter) => enter.append("rect").style("zIndex", 0).style("fill", "transparent").attr("className", PLOT_CLASS_NAME).call(updateBBox).call(updateLayers, Array.from(markState.keys())).call(applyClip, clip), (update) => update.call(updateLayers, Array.from(markState.keys())).call((selection2) => {
        return animationExtent ? animateBBox(selection2, animationExtent) : updateBBox(selection2);
      }).call(applyClip, clip)).transitions();
      transitions.push(...T.flat());
      for (const [mark, state] of markState.entries()) {
        const { data: data2 } = state;
        const { key: key2, class: cls, type } = mark;
        const viewNode = selection.select(`#${key2}`);
        const shapeFunction = createMarkShapeFunction(mark, state, view, context);
        const enterFunction = createEnterFunction(mark, state, view, library3);
        const updateFunction = createUpdateFunction(mark, state, view, library3);
        const exitFunction = createExitFunction(mark, state, view, library3);
        const facetElements = selectFacetElements(selection, viewNode, cls, "element");
        const T2 = viewNode.selectAll(className(ELEMENT_CLASS_NAME)).selectFacetAll(facetElements).data(data2, (d2) => d2.key, (d2) => d2.groupKey).join((enter) => enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data3, i, element) {
          return enterFunction(data3, [element]);
        }), (update) => update.call((selection2) => {
          const parent = selection2.parent();
          const origin = useMemo((node) => {
            const [x4, y4] = node.getBounds().min;
            return [x4, y4];
          });
          selection2.transition(function(data3, index4, element) {
            maybeFacetElement(element, parent, origin);
            const node = shapeFunction(data3, index4);
            const animation = updateFunction(data3, [element], [node]);
            if (animation !== null)
              return animation;
            if (element.nodeName === node.nodeName && node.nodeName !== "g") {
              copyAttributes(element, node);
            } else {
              element.parentNode.replaceChild(node, element);
              node.className = ELEMENT_CLASS_NAME;
              node.markType = type;
              node.__data__ = element.__data__;
            }
            return animation;
          }).attr("markType", type).attr("className", ELEMENT_CLASS_NAME);
        }), (exit) => {
          return exit.each(function(d2, i, element) {
            element.__removed__ = true;
          }).transition(function(data3, i, element) {
            return exitFunction(data3, [element]);
          }).remove();
        }, (merge2) => merge2.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).transition(function(data3, i, element) {
          const { __fromElements__: fromElements } = element;
          const transition2 = updateFunction(data3, fromElements, [element]);
          const exit = new Selection(fromElements, null, element.parentNode);
          exit.transition(transition2).remove();
          return transition2;
        }), (split) => split.transition(function(data3, i, element) {
          const enter = new Selection([], element.__toData__, element.parentNode);
          const toElements = enter.append(shapeFunction).attr("className", ELEMENT_CLASS_NAME).attr("markType", type).nodes();
          return updateFunction(data3, [element], toElements);
        }).remove()).transitions();
        transitions.push(...T2.flat());
      }
      plotLabel(view, selection, transitions, library3, context);
    });
  }
  function plotLabel(view, selection, transitions, library3, context) {
    const [useLabelTransform] = useLibrary("labelTransform", library3);
    const { markState, labelTransform } = view;
    const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
    const labelShapeFunction = /* @__PURE__ */ new Map();
    const labelDescriptor = /* @__PURE__ */ new Map();
    const labels = Array.from(markState.entries()).flatMap(([mark, state]) => {
      const { labels: labelOptions = [], key } = mark;
      const shapeFunction = createLabelShapeFunction(mark, state, view, library3, context);
      const elements = selection.select(`#${key}`).selectAll(className(ELEMENT_CLASS_NAME)).nodes().filter((n2) => !n2.__removed__);
      return labelOptions.flatMap((labelOption, i) => {
        const { transform = [] } = labelOption, options = __rest76(labelOption, ["transform"]);
        return elements.flatMap((e3) => {
          const L = getLabels(options, i, e3);
          L.forEach((l2) => {
            labelShapeFunction.set(l2, shapeFunction);
            labelDescriptor.set(l2, labelOption);
          });
          return L;
        });
      });
    });
    const labelShapes = select(labelLayer).selectAll(className(LABEL_CLASS_NAME)).data(labels, (d2) => d2.key).join((enter) => enter.append((d2) => labelShapeFunction.get(d2)(d2)).attr("className", LABEL_CLASS_NAME), (update) => update.each(function(d2, i, element) {
      const shapeFunction = labelShapeFunction.get(d2);
      const node = shapeFunction(d2);
      copyAttributes(element, node);
    }), (exit) => exit.remove()).nodes();
    const labelGroups = group(labelShapes, (d2) => labelDescriptor.get(d2.__data__));
    const { coordinate } = view;
    const labelTransformContext = {
      canvas: context.canvas,
      coordinate
    };
    for (const [label, shapes] of labelGroups) {
      const { transform = [] } = label;
      const transformFunction = compose(transform.map(useLabelTransform));
      transformFunction(shapes, labelTransformContext);
    }
    if (labelTransform) {
      labelTransform(labelShapes, labelTransformContext);
    }
  }
  function getLabels(label, labelIndex, element) {
    const { seriesIndex: SI, seriesKey, points, key, index: index4 } = element.__data__;
    const bounds = getLocalBounds(element);
    if (!SI) {
      return [
        Object.assign(Object.assign({}, label), {
          key: `${key}-${labelIndex}`,
          bounds,
          index: index4,
          points,
          dependentElement: element
        })
      ];
    }
    const selector = normalizeLabelSelector(label);
    const F = SI.map((index5, i) => Object.assign(Object.assign({}, label), {
      key: `${seriesKey[i]}-${labelIndex}`,
      bounds: [points[i]],
      index: index5,
      points,
      dependentElement: element
    }));
    return selector ? selector(F) : F;
  }
  function filterValid([I, P, S]) {
    if (S)
      return [I, P, S];
    const definedIndex = [];
    const definedPoints = [];
    for (let i = 0; i < I.length; i++) {
      const d2 = I[i];
      const p2 = P[i];
      if (p2.every(([x3, y3]) => defined(x3) && defined(y3))) {
        definedIndex.push(d2);
        definedPoints.push(p2);
      }
    }
    return [definedIndex, definedPoints];
  }
  function normalizeLabelSelector(label) {
    const { selector } = label;
    if (!selector)
      return null;
    if (typeof selector === "function")
      return selector;
    if (selector === "first")
      return (I) => [I[0]];
    if (selector === "last")
      return (I) => [I[I.length - 1]];
    throw new Error(`Unknown selector: ${selector}`);
  }
  function getLocalBounds(element) {
    const cloneElement = element.cloneNode();
    const animations = element.getAnimations();
    cloneElement.style.visibility = "hidden";
    animations.forEach((animation) => {
      const keyframes = animation.effect.getKeyframes();
      cloneElement.attr(keyframes[keyframes.length - 1]);
    });
    element.parentNode.appendChild(cloneElement);
    const bounds = cloneElement.getLocalBounds();
    cloneElement.destroy();
    const { min: min10, max: max10 } = bounds;
    return [min10, max10];
  }
  function createLabelShapeFunction(mark, state, view, library3, context) {
    const [useShape] = useLibrary("shape", library3);
    const { data: abstractData, encode } = mark;
    const { data: visualData, defaultLabelShape } = state;
    const point2d = visualData.map((d2) => d2.points);
    const channel = mapObject(encode, (d2) => d2.value);
    const { theme, coordinate } = view;
    const shapeContext = Object.assign(Object.assign({}, context), {
      document: documentOf(context),
      theme,
      coordinate
    });
    return (options) => {
      const { index: index4, points } = options;
      const datum = abstractData[index4];
      const { formatter: formatter2 = (d2) => `${d2}`, transform, style: abstractStyle, render: render2 } = options, abstractOptions = __rest76(options, ["formatter", "transform", "style", "render"]);
      const visualOptions = mapObject(Object.assign(Object.assign({}, abstractOptions), abstractStyle), (d2) => valueOf2(d2, datum, index4, abstractData, { channel }));
      const { shape: shape23 = defaultLabelShape, text } = visualOptions, style = __rest76(visualOptions, ["shape", "text"]);
      const f = typeof formatter2 === "string" ? format2(formatter2) : formatter2;
      const value2 = Object.assign(Object.assign({}, style), { text: f(text, datum, index4, abstractData), datum });
      const shapeOptions = Object.assign({ type: `label.${shape23}`, render: render2 }, style);
      const shapeFunction = useShape(shapeOptions, shapeContext);
      const defaults5 = getDefaultsStyle(theme, "label", shape23, "label");
      return shapeFunction(points, value2, defaults5, point2d);
    };
  }
  function valueOf2(value2, datum, i, data2, options) {
    if (typeof value2 === "function")
      return value2(datum, i, data2, options);
    if (typeof value2 !== "string")
      return value2;
    if (isStrictObject(datum) && datum[value2] !== void 0)
      return datum[value2];
    return value2;
  }
  function computeAnimationExtent(markState) {
    let maxDuration = -Infinity;
    let minDelay = Infinity;
    for (const [mark, state] of markState) {
      const { animate: animate2 = {} } = mark;
      const { data: data2 } = state;
      const { enter = {}, update = {}, exit = {} } = animate2;
      const { type: defaultUpdateType, duration: defaultUpdateDuration = 300, delay: defaultUpdateDelay = 0 } = update;
      const { type: defaultEnterType, duration: defaultEnterDuration = 300, delay: defaultEnterDelay = 0 } = enter;
      const { type: defaultExitType, duration: defaultExitDuration = 300, delay: defaultExitDelay = 0 } = exit;
      for (const d2 of data2) {
        const { updateType = defaultUpdateType, updateDuration = defaultUpdateDuration, updateDelay = defaultUpdateDelay, enterType = defaultEnterType, enterDuration = defaultEnterDuration, enterDelay = defaultEnterDelay, exitDuration = defaultExitDuration, exitDelay = defaultExitDelay, exitType = defaultExitType } = d2;
        if (updateType === void 0 || updateType) {
          maxDuration = Math.max(maxDuration, updateDuration + updateDelay);
          minDelay = Math.min(minDelay, updateDelay);
        }
        if (exitType === void 0 || exitType) {
          maxDuration = Math.max(maxDuration, exitDuration + exitDelay);
          minDelay = Math.min(minDelay, exitDelay);
        }
        if (enterType === void 0 || enterType) {
          maxDuration = Math.max(maxDuration, enterDuration + enterDelay);
          minDelay = Math.min(minDelay, enterDelay);
        }
      }
    }
    if (maxDuration === -Infinity)
      return null;
    return [minDelay, maxDuration - minDelay];
  }
  function selectFacetElements(selection, current, facetClassName, elementClassName) {
    const group3 = selection.node().parentElement;
    return group3.findAll((node) => node.style.facet !== void 0 && node.style.facet === facetClassName && node !== current.node()).flatMap((node) => node.getElementsByClassName(elementClassName));
  }
  function maybeFacetElement(element, parent, originOf) {
    if (!element.__facet__)
      return;
    const prePlot = element.parentNode.parentNode;
    const newPlot = parent.parentNode;
    const [px, py] = originOf(prePlot);
    const [x3, y3] = originOf(newPlot);
    const translate3 = `translate(${px - x3}, ${py - y3})`;
    appendTransform(element, translate3);
    parent.append(element);
  }
  function createMarkShapeFunction(mark, state, view, context) {
    const { library: library3 } = context;
    const [useShape] = useLibrary("shape", library3);
    const { data: abstractData, encode } = mark;
    const { defaultShape, data: data2, shape: shapeLibrary } = state;
    const channel = mapObject(encode, (d2) => d2.value);
    const point2d = data2.map((d2) => d2.points);
    const { theme, coordinate } = view;
    const { type: markType, style = {} } = mark;
    const shapeContext = Object.assign(Object.assign({}, context), {
      document: documentOf(context),
      coordinate,
      theme
    });
    return (data3) => {
      const { shape: styleShape = defaultShape } = style;
      const { shape: shape23 = styleShape, points, seriesIndex, index: i } = data3, v = __rest76(data3, ["shape", "points", "seriesIndex", "index"]);
      const value2 = Object.assign(Object.assign({}, v), { index: i });
      const abstractDatum = seriesIndex ? seriesIndex.map((i2) => abstractData[i2]) : abstractData[i];
      const I = seriesIndex ? seriesIndex : i;
      const visualStyle = mapObject(style, (d2) => valueOf2(d2, abstractDatum, I, abstractData, { channel }));
      const shapeFunction = shapeLibrary[shape23] ? shapeLibrary[shape23](visualStyle, shapeContext) : useShape(Object.assign(Object.assign({}, visualStyle), { type: shapeName(mark, shape23) }), shapeContext);
      const defaults5 = getDefaultsStyle(theme, markType, shape23, defaultShape);
      return shapeFunction(points, value2, defaults5, point2d);
    };
  }
  function getDefaultsStyle(theme, mark, shape23, defaultShape) {
    if (typeof mark !== "string")
      return;
    const { color: color2 } = theme;
    const markTheme = theme[mark] || {};
    const shapeTheme = markTheme[shape23] || markTheme[defaultShape];
    return Object.assign({ color: color2 }, shapeTheme);
  }
  function createAnimationFunction(type, mark, state, view, library3) {
    var _a, _b;
    const [, createShape] = useLibrary("shape", library3);
    const [useAnimation] = useLibrary("animation", library3);
    const { defaultShape, shape: shapeLibrary } = state;
    const { theme, coordinate } = view;
    const upperType = upper_first_default(type);
    const key = `default${upperType}Animation`;
    const { [key]: defaultAnimation } = ((_a = shapeLibrary[defaultShape]) === null || _a === void 0 ? void 0 : _a.props) || createShape(shapeName(mark, defaultShape)).props;
    const { [type]: defaultEffectTiming = {} } = theme;
    const animate2 = ((_b = mark.animate) === null || _b === void 0 ? void 0 : _b[type]) || {};
    const context = { coordinate };
    return (data2, from, to) => {
      const { [`${type}Type`]: animation, [`${type}Delay`]: delay, [`${type}Duration`]: duration, [`${type}Easing`]: easing } = data2;
      const options = Object.assign({ type: animation || defaultAnimation }, animate2);
      if (!options.type)
        return null;
      const animateFunction = useAnimation(options, context);
      const value2 = { delay, duration, easing };
      const A5 = animateFunction(from, to, deep_mix_default(defaultEffectTiming, value2));
      if (!Array.isArray(A5))
        return [A5];
      return A5;
    };
  }
  function createEnterFunction(mark, state, view, library3) {
    return createAnimationFunction("enter", mark, state, view, library3);
  }
  function cancel(animation) {
    animation.finished.then(() => {
      animation.cancel();
    });
    return animation;
  }
  function createUpdateFunction(mark, state, view, library3) {
    return createAnimationFunction("update", mark, state, view, library3);
  }
  function createExitFunction(mark, state, view, library3) {
    return createAnimationFunction("exit", mark, state, view, library3);
  }
  function inferTheme(theme = {}) {
    if (typeof theme === "string")
      return { type: theme };
    const { type = "light" } = theme, rest = __rest76(theme, ["type"]);
    return Object.assign(Object.assign({}, rest), { type });
  }
  function inferInteraction(view) {
    const defaults5 = {
      event: true,
      tooltip: true,
      // @todo Inferred by slider self.
      sliderFilter: true,
      legendFilter: true,
      scrollbarFilter: true
    };
    const { interaction = {} } = view;
    return Object.entries(deep_mix_default(defaults5, interaction)).reverse();
  }
  function applyTransform(node, context) {
    return __awaiter6(this, void 0, void 0, function* () {
      const { data: data2 } = node, rest = __rest76(node, ["data"]);
      if (data2 == void 0)
        return node;
      const [, { data: newData }] = yield applyDataTransform([], { data: data2 }, context);
      return Object.assign({ data: newData }, rest);
    });
  }
  function updateBBox(selection) {
    selection.style("transform", (d2) => `translate(${d2.paddingLeft + d2.marginLeft}, ${d2.paddingTop + d2.marginTop})`).style("width", (d2) => d2.innerWidth).style("height", (d2) => d2.innerHeight);
  }
  function animateBBox(selection, extent2) {
    const [delay, duration] = extent2;
    selection.transition(function(data2, i, element) {
      const { transform, width, height } = element.style;
      const { paddingLeft, paddingTop, innerWidth, innerHeight, marginLeft, marginTop } = data2;
      const keyframes = [
        {
          transform,
          width,
          height
        },
        {
          transform: `translate(${paddingLeft + marginLeft}, ${paddingTop + marginTop})`,
          width: innerWidth,
          height: innerHeight
        }
      ];
      return element.animate(keyframes, { delay, duration, fill: "both" });
    });
  }
  function shapeName(mark, name2) {
    const { type } = mark;
    if (typeof name2 === "string")
      return `${type}.${name2}`;
    return name2;
  }
  function updateLayers(selection, marks) {
    const facet = (d2) => d2.class !== void 0 ? `${d2.class}` : "";
    const nodes = selection.nodes();
    if (nodes.length === 0)
      return;
    selection.selectAll(className(MAIN_LAYER_CLASS_NAME)).data(marks, (d2) => d2.key).join((enter) => enter.append("g").attr("className", MAIN_LAYER_CLASS_NAME).attr("id", (d2) => d2.key).style("facet", facet).style("fill", "transparent").style("zIndex", (d2) => {
      var _a;
      return (_a = d2.zIndex) !== null && _a !== void 0 ? _a : 0;
    }), (update) => update.style("facet", facet).style("fill", "transparent").style("zIndex", (d2) => {
      var _a;
      return (_a = d2.zIndex) !== null && _a !== void 0 ? _a : 0;
    }), (exit) => exit.remove());
    const labelLayer = selection.select(className(LABEL_LAYER_CLASS_NAME)).node();
    if (labelLayer)
      return;
    selection.append("g").attr("className", LABEL_LAYER_CLASS_NAME).style("zIndex", 0);
  }
  function className(...names) {
    return names.map((d2) => `.${d2}`).join("");
  }
  function applyClip(selection, clip) {
    if (!selection.node())
      return;
    selection.style("clipPath", (data2) => {
      if (!clip)
        return null;
      const { paddingTop: y3, paddingLeft: x3, marginLeft: x12, marginTop: y12, innerWidth: width, innerHeight: height } = data2;
      return new Rect({ style: { x: x3 + x12, y: y3 + y12, width, height } });
    });
  }
  function inferComponentScales(scales, states, markState) {
    var _a;
    for (const [key] of markState.entries()) {
      if (key.type === "cell") {
        return scales.filter((scale9) => scale9.name !== "shape");
      }
    }
    if (states.length !== 1 || scales.some((scale9) => scale9.name === "shape")) {
      return scales;
    }
    const { defaultShape: shape23 } = states[0];
    const acceptMarkTypes = ["point", "line", "rect", "hollow"];
    if (!acceptMarkTypes.includes(shape23))
      return scales;
    const shapeMap = {
      point: "point",
      line: "hyphen",
      rect: "square",
      hollow: "hollow"
    };
    const field3 = ((_a = scales.find((scale9) => scale9.name === "color")) === null || _a === void 0 ? void 0 : _a.field) || null;
    const shapeScale = {
      field: field3,
      name: "shape",
      type: "constant",
      domain: [],
      range: [shapeMap[shape23]]
    };
    return [...scales, shapeScale];
  }
  function applyStyle2(selection, style) {
    for (const [key, value2] of Object.entries(style)) {
      selection.style(key, value2);
    }
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/runtime/render.js
  function inferKeys(options) {
    const root2 = deep_mix_default({}, options);
    const nodeParent = /* @__PURE__ */ new Map([[root2, null]]);
    const nodeIndex = /* @__PURE__ */ new Map([[null, -1]]);
    const discovered = [root2];
    while (discovered.length) {
      const node = discovered.shift();
      if (node.key === void 0) {
        const parent = nodeParent.get(node);
        const index4 = nodeIndex.get(node);
        const key = parent === null ? `${0}` : `${parent.key}-${index4}`;
        node.key = key;
      }
      const { children = [] } = node;
      if (Array.isArray(children)) {
        for (let i = 0; i < children.length; i++) {
          const child = deep_mix_default({}, children[i]);
          children[i] = child;
          nodeParent.set(child, node);
          nodeIndex.set(child, i);
          discovered.push(child);
        }
      }
    }
    return root2;
  }
  function Canvas2(width, height) {
    const renderer = new Renderer2();
    renderer.registerPlugin(new Plugin7());
    return new Canvas({
      width,
      height,
      container: document.createElement("div"),
      renderer
    });
  }
  function render(options, context = {}, resolve = () => {
  }, reject = (e3) => {
    throw e3;
  }) {
    const { width = 640, height = 480, depth = 0 } = options;
    const keyed2 = inferKeys(options);
    const { canvas = Canvas2(width, height), emitter = new esm_default(), library: library3 } = context;
    context.canvas = canvas;
    context.emitter = emitter;
    const { width: prevWidth, height: prevHeight } = canvas.getConfig();
    if (prevWidth !== width || prevHeight !== height) {
      canvas.resize(width, height);
    }
    emitter.emit(ChartEvent.BEFORE_RENDER);
    const selection = select(canvas.document.documentElement);
    canvas.ready.then(() => plot(Object.assign(Object.assign({}, keyed2), { width, height, depth }), selection, context)).then(() => {
      if (depth) {
        const [x3, y3] = canvas.document.documentElement.getPosition();
        canvas.document.documentElement.setPosition(x3, y3, -depth / 2);
      }
      canvas.requestAnimationFrame(() => {
        emitter.emit(ChartEvent.AFTER_RENDER);
        resolve === null || resolve === void 0 ? void 0 : resolve();
      });
    }).catch((e3) => {
      reject === null || reject === void 0 ? void 0 : reject(e3);
    });
    return normalizeContainer(canvas.getConfig().container);
  }
  function destroy2(options, context = {}, isDestroyCanvas = false) {
    const { canvas, emitter } = context;
    if (canvas) {
      destroyAllInteractions(canvas);
      isDestroyCanvas ? canvas.destroy() : canvas.destroyChildren();
    }
    emitter.off();
  }
  function destroyAllInteractions(canvas) {
    const viewGroups = canvas.getRoot().querySelectorAll(`.${VIEW_CLASS_NAME}`);
    viewGroups === null || viewGroups === void 0 ? void 0 : viewGroups.forEach((group3) => {
      const { nameInteraction = /* @__PURE__ */ new Map() } = group3;
      if ((nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.size) > 0) {
        Array.from(nameInteraction === null || nameInteraction === void 0 ? void 0 : nameInteraction.values()).forEach((value2) => {
          value2 === null || value2 === void 0 ? void 0 : value2.destroy();
        });
      }
    });
  }
  function normalizeContainer(container) {
    return typeof container === "string" ? document.getElementById(container) : container;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/style.js
  var defaultStyle = {
    visibility: "visible",
    opacity: 1,
    fillOpacity: 1,
    strokeOpacity: 1
  };
  function getStyle2(element, key) {
    var _a;
    return (_a = element.style[key]) !== null && _a !== void 0 ? _a : defaultStyle[key];
  }
  function setStyle2(element, key, value2, recursive) {
    element.style[key] = value2;
    if (recursive) {
      element.children.forEach((child) => setStyle2(child, key, value2, recursive));
    }
  }
  function hide2(element) {
    setStyle2(element, "visibility", "hidden", true);
  }
  function show2(element) {
    setStyle2(element, "visibility", "visible", true);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/utils.js
  var __rest77 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function selectG2Elements(root2) {
    return select(root2).selectAll(`.${ELEMENT_CLASS_NAME}`).nodes().filter((d2) => !d2.__removed__);
  }
  function selectFacetG2Elements(target, viewInstances) {
    return selectFacetViews(target, viewInstances).flatMap(({ container }) => selectG2Elements(container));
  }
  function selectFacetViews(target, viewInstances) {
    return viewInstances.filter((d2) => d2 !== target && d2.options.parentKey === target.options.key);
  }
  function selectPlotArea(root2) {
    return select(root2).select(`.${PLOT_CLASS_NAME}`).node();
  }
  function bboxOf(element) {
    if (element.tagName === "g")
      return element.getRenderBounds();
    const bounds = element.getGeometryBounds();
    const aabb = new AABB();
    aabb.setFromTransformedAABB(bounds, element.getWorldTransform());
    return aabb;
  }
  function mousePosition(target, event) {
    const { offsetX, offsetY } = event;
    const bbox = bboxOf(target);
    const { min: [x3, y3], max: [x12, y12] } = bbox;
    const isOutX = offsetX < x3 || offsetX > x12;
    const isOutY = offsetY < y3 || offsetY > y12;
    if (isOutX || isOutY)
      return null;
    return [offsetX - x3, offsetY - y3];
  }
  function brushMousePosition(target, event) {
    const { offsetX, offsetY } = event;
    const [x3, y3, x12, y12] = boundsOfBrushArea(target);
    return [
      Math.min(x12, Math.max(x3, offsetX)) - x3,
      Math.min(y12, Math.max(y3, offsetY)) - y3
    ];
  }
  function boundsOfBrushArea(target) {
    const bbox = target.getRenderBounds();
    const { min: [x05, y05], max: [x12, y12] } = bbox;
    return [x05, y05, x12, y12];
  }
  function createColorKey(view) {
    return (element) => element.__data__.color;
  }
  function createXKey(view) {
    return (element) => element.__data__.x;
  }
  function createDatumof(view) {
    const views = Array.isArray(view) ? view : [view];
    const keyData = new Map(views.flatMap((view2) => {
      const marks = Array.from(view2.markState.keys());
      return marks.map((mark) => [keyed(view2.key, mark.key), mark.data]);
    }));
    return (element) => {
      const { index: index4, markKey, viewKey } = element.__data__;
      const data2 = keyData.get(keyed(viewKey, markKey));
      return data2[index4];
    };
  }
  function useState(style, valueof2 = (d2, element) => d2, setAttribute = (element, key, v) => element.setAttribute(key, v)) {
    const STATES = "__states__";
    const ORIGINAL = "__ordinal__";
    const updateState = (element) => {
      const { [STATES]: states = [], [ORIGINAL]: original = {} } = element;
      const stateStyle = states.reduce((mixedStyle, state) => Object.assign(Object.assign({}, mixedStyle), style[state]), original);
      if (Object.keys(stateStyle).length === 0)
        return;
      for (const [key, value2] of Object.entries(stateStyle)) {
        const currentValue = getStyle2(element, key);
        const v = valueof2(value2, element);
        setAttribute(element, key, v);
        if (!(key in original))
          original[key] = currentValue;
      }
      element[ORIGINAL] = original;
    };
    const initState = (element) => {
      if (element[STATES])
        return;
      element[STATES] = [];
      return;
    };
    const setState = (element, ...states) => {
      initState(element);
      element[STATES] = [...states];
      updateState(element);
    };
    const removeState = (element, ...states) => {
      initState(element);
      for (const state of states) {
        const index4 = element[STATES].indexOf(state);
        if (index4 !== -1) {
          element[STATES].splice(index4, 1);
        }
      }
      updateState(element);
    };
    const hasState = (element, state) => {
      initState(element);
      return element[STATES].indexOf(state) !== -1;
    };
    return {
      setState,
      removeState,
      hasState
    };
  }
  function isEmptyObject(obj) {
    if (obj === void 0)
      return true;
    if (typeof obj !== "object")
      return false;
    return Object.keys(obj).length === 0;
  }
  function keyed(viewKey, markKey) {
    return `${viewKey},${markKey}`;
  }
  function mergeState(options, states) {
    const views = Array.isArray(options) ? options : [options];
    const markState = views.flatMap((view) => view.marks.map((mark) => [keyed(view.key, mark.key), mark.state]));
    const state = {};
    for (const descriptor of states) {
      const [key, defaults5] = Array.isArray(descriptor) ? descriptor : [descriptor, {}];
      state[key] = markState.reduce((merged, mark) => {
        const [markKey, markState2 = {}] = mark;
        const selectedState = isEmptyObject(markState2[key]) ? defaults5 : markState2[key];
        for (const [attr2, value2] of Object.entries(selectedState)) {
          const oldValue = merged[attr2];
          const newValue = (data2, index4, array2, element) => {
            const k = keyed(element.__data__.viewKey, element.__data__.markKey);
            if (markKey !== k)
              return oldValue === null || oldValue === void 0 ? void 0 : oldValue(data2, index4, array2, element);
            if (typeof value2 !== "function")
              return value2;
            return value2(data2, index4, array2, element);
          };
          merged[attr2] = newValue;
        }
        return merged;
      }, {});
    }
    return state;
  }
  function createValueof(elements, datum) {
    const elementIndex = new Map(elements.map((d2, i) => [d2, i]));
    const fa = datum ? elements.map(datum) : elements;
    return (d2, e3) => {
      if (typeof d2 !== "function")
        return d2;
      const i = elementIndex.get(e3);
      const fe = datum ? datum(e3) : e3;
      return d2(fe, i, fa, e3);
    };
  }
  function renderLink(_a) {
    var { link: link2 = false, valueof: valueof2 = (d2, element) => d2, coordinate } = _a, style = __rest77(_a, ["link", "valueof", "coordinate"]);
    const LINK_CLASS_NAME = "element-link";
    if (!link2)
      return [() => {
      }, () => {
      }];
    const pointsOf = (element) => element.__data__.points;
    const pathPointsOf = (P0, P1) => {
      const [, p1, p2] = P0;
      const [p0, , , p3] = P1;
      const P = [p1, p0, p3, p2];
      return P;
    };
    const append3 = (elements) => {
      var _a2;
      if (elements.length <= 1)
        return;
      const sortedElements = sort2(elements, (e0, e1) => {
        const { x: x05 } = e0.__data__;
        const { x: x12 } = e1.__data__;
        const dx = x05 - x12;
        return dx;
      });
      for (let i = 1; i < sortedElements.length; i++) {
        const p2 = path();
        const e0 = sortedElements[i - 1];
        const e1 = sortedElements[i];
        const [p0, p1, p22, p3] = pathPointsOf(pointsOf(e0), pointsOf(e1));
        p2.moveTo(...p0);
        p2.lineTo(...p1);
        p2.lineTo(...p22);
        p2.lineTo(...p3);
        p2.closePath();
        const _b = mapObject(style, (d2) => valueof2(d2, e0)), { fill = e0.getAttribute("fill") } = _b, rest = __rest77(_b, ["fill"]);
        const link3 = new Path2({
          className: LINK_CLASS_NAME,
          style: Object.assign({ d: p2.toString(), fill, zIndex: -2 }, rest)
        });
        (_a2 = e0.link) === null || _a2 === void 0 ? void 0 : _a2.remove();
        e0.parentNode.appendChild(link3);
        e0.link = link3;
      }
    };
    const remove = (element) => {
      var _a2;
      (_a2 = element.link) === null || _a2 === void 0 ? void 0 : _a2.remove();
      element.link = null;
    };
    return [append3, remove];
  }
  function offsetTransform(element, offset3, coordinate) {
    const append3 = (t) => {
      const { transform } = element.style;
      return transform ? `${transform} ${t}` : t;
    };
    if (isPolar(coordinate)) {
      const { points } = element.__data__;
      const [p0, p1] = isTranspose(coordinate) ? reorder(points) : points;
      const center2 = coordinate.getCenter();
      const v0 = sub6(p0, center2);
      const v1 = sub6(p1, center2);
      const a0 = angle3(v0);
      const da = angleBetween(v0, v1);
      const amid = a0 + da / 2;
      const dx = offset3 * Math.cos(amid);
      const dy = offset3 * Math.sin(amid);
      return append3(`translate(${dx}, ${dy})`);
    }
    if (isTranspose(coordinate))
      return append3(`translate(${offset3}, 0)`);
    return append3(`translate(0, ${-offset3})`);
  }
  function renderBackground(_a) {
    var { document: document2, background, scale: scale9, coordinate, valueof: valueof2 } = _a, rest = __rest77(_a, ["document", "background", "scale", "coordinate", "valueof"]);
    const BACKGROUND_CLASS_NAME = "element-background";
    if (!background)
      return [() => {
      }, () => {
      }];
    const extentOf2 = (scale10, x3, padding) => {
      const ax = scale10.invert(x3);
      const mid2 = x3 + scale10.getBandWidth(ax) / 2;
      const half = scale10.getStep(ax) / 2;
      const offset3 = half * padding;
      return [mid2 - half + offset3, mid2 + half - offset3];
    };
    const sizeXOf = (element, padding) => {
      const { x: scaleX } = scale9;
      if (!isOrdinalScale(scaleX))
        return [0, 1];
      const { __data__: data2 } = element;
      const { x: x3 } = data2;
      const [e1, e24] = extentOf2(scaleX, x3, padding);
      return [e1, e24];
    };
    const sizeYOf = (element, padding) => {
      const { y: scaleY } = scale9;
      if (!isOrdinalScale(scaleY))
        return [0, 1];
      const { __data__: data2 } = element;
      const { y: y3 } = data2;
      const [e1, e24] = extentOf2(scaleY, y3, padding);
      return [e1, e24];
    };
    const bandShapeOf = (element, style) => {
      const { padding } = style;
      const [x12, x22] = sizeXOf(element, padding);
      const [y12, y22] = sizeYOf(element, padding);
      const points = [
        [x12, y12],
        [x22, y12],
        [x22, y22],
        [x12, y22]
      ].map((d2) => coordinate.map(d2));
      const { __data__: data2 } = element;
      const { y: dy, y1: dy1 } = data2;
      return rect(document2, points, { y: dy, y1: dy1 }, coordinate, style);
    };
    const cloneShapeOf = (element, style) => {
      const { transform = "scale(1.2, 1.2)", transformOrigin = "center center", stroke: stroke2 = "" } = style, rest2 = __rest77(style, ["transform", "transformOrigin", "stroke"]);
      const finalStyle = Object.assign({ transform, transformOrigin, stroke: stroke2 }, rest2);
      const shape23 = element.cloneNode(true);
      for (const [key, value2] of Object.entries(finalStyle)) {
        shape23.style[key] = value2;
      }
      return shape23;
    };
    const isOrdinalShape = () => {
      const { x: x3, y: y3 } = scale9;
      return [x3, y3].some(isOrdinalScale);
    };
    const append3 = (element) => {
      if (element.background)
        element.background.remove();
      const _a2 = mapObject(rest, (d2) => valueof2(d2, element)), { fill = "#CCD6EC", fillOpacity = 0.3, zIndex = -2, padding = 1e-3, lineWidth = 0 } = _a2, style = __rest77(_a2, ["fill", "fillOpacity", "zIndex", "padding", "lineWidth"]);
      const finalStyle = Object.assign(Object.assign({}, style), {
        fill,
        fillOpacity,
        zIndex,
        padding,
        lineWidth
      });
      const shapeOf = isOrdinalShape() ? bandShapeOf : cloneShapeOf;
      const shape23 = shapeOf(element, finalStyle);
      shape23.className = BACKGROUND_CLASS_NAME;
      element.parentNode.parentNode.appendChild(shape23);
      element.background = shape23;
    };
    const remove = (element) => {
      var _a2;
      (_a2 = element.background) === null || _a2 === void 0 ? void 0 : _a2.remove();
      element.background = null;
    };
    const is2 = (element) => {
      return element.className === BACKGROUND_CLASS_NAME;
    };
    return [append3, remove, is2];
  }
  function setCursor(root2, cursor) {
    const canvas = root2.getRootNode().defaultView;
    const dom2 = canvas.getContextService().getDomElement();
    if (dom2 === null || dom2 === void 0 ? void 0 : dom2.style) {
      root2.cursor = dom2.style.cursor;
      dom2.style.cursor = cursor;
    }
  }
  function restoreCursor(root2) {
    setCursor(root2, root2.cursor);
  }
  function selectElementByData(elements, data2, datum) {
    return elements.find((d2) => Object.entries(data2).every(([key, value2]) => datum(d2)[key] === value2));
  }
  function getPointsR(point6, nextPoint) {
    return Math.sqrt(Math.pow(point6[0] - nextPoint[0], 2) + Math.pow(point6[1] - nextPoint[1], 2));
  }
  function getPointsPath(points, isClose = false) {
    const path2 = filter_default(points, (d2) => !!d2).map((d2, i) => {
      return [i === 0 ? "M" : "L", ...d2];
    });
    if (isClose) {
      path2.push(["Z"]);
    }
    return path2;
  }
  function getElements(plot2) {
    return plot2.querySelectorAll(".element");
  }
  function getThetaPath(center2, points, isBig = 0) {
    const path2 = [["M", ...points[1]]];
    const innerRadius = getPointsR(center2, points[1]);
    const outerRadius = getPointsR(center2, points[0]);
    if (innerRadius === 0) {
      path2.push(["L", ...points[3]], ["A", outerRadius, outerRadius, 0, isBig, 1, ...points[0]], ["Z"]);
    } else {
      path2.push(["A", innerRadius, innerRadius, 0, isBig, 0, ...points[2]], ["L", ...points[3]], ["A", outerRadius, outerRadius, 0, isBig, 1, ...points[0]], ["Z"]);
    }
    return path2;
  }
  function maybeRoot(node, rootOf) {
    if (rootOf(node))
      return node;
    let root2 = node.parent;
    while (root2 && !rootOf(root2))
      root2 = root2.parent;
    return root2;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/elementHighlight.js
  var __rest78 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function elementHighlight(root2, {
    elements: elementsof,
    // given the root of chart returns elements to be manipulated
    datum,
    // given each element returns the datum of it
    groupKey = (d2) => d2,
    // group elements by specified key
    link: link2 = false,
    // draw link or not
    background = false,
    // draw background or not
    delay = 60,
    // delay to unhighlighted element
    scale: scale9,
    coordinate,
    emitter,
    state = {}
  }) {
    var _a;
    const elements = elementsof(root2);
    const elementSet = new Set(elements);
    const keyGroup = group(elements, groupKey);
    const valueof2 = createValueof(elements, datum);
    const [appendLink, removeLink] = renderLink(Object.assign({
      elements,
      valueof: valueof2,
      link: link2,
      coordinate
    }, subObject(state.active, "link")));
    const [appendBackground, removeBackground, isBackground] = renderBackground(Object.assign({
      document: root2.ownerDocument,
      scale: scale9,
      coordinate,
      background,
      valueof: valueof2
    }, subObject(state.active, "background")));
    const elementStyle = deep_mix_default(state, {
      active: Object.assign({}, ((_a = state.active) === null || _a === void 0 ? void 0 : _a.offset) && {
        //Apply translate to mock slice out.
        transform: (...params) => {
          const value2 = state.active.offset(...params);
          const [, i] = params;
          return offsetTransform(elements[i], value2, coordinate);
        }
      })
    });
    const { setState, removeState, hasState } = useState(elementStyle, valueof2);
    let out;
    const pointerover = (event) => {
      const { target: element, nativeEvent = true } = event;
      if (!elementSet.has(element))
        return;
      if (out)
        clearTimeout(out);
      const k = groupKey(element);
      const group3 = keyGroup.get(k);
      const groupSet = new Set(group3);
      for (const e3 of elements) {
        if (groupSet.has(e3)) {
          if (!hasState(e3, "active"))
            setState(e3, "active");
        } else {
          setState(e3, "inactive");
          removeLink(e3);
        }
        if (e3 !== element)
          removeBackground(e3);
      }
      appendBackground(element);
      appendLink(group3);
      if (!nativeEvent)
        return;
      emitter.emit("element:highlight", {
        nativeEvent,
        data: {
          data: datum(element),
          group: group3.map(datum)
        }
      });
    };
    const delayUnhighlighted = () => {
      if (out)
        clearTimeout(out);
      out = setTimeout(() => {
        unhighlighted();
        out = null;
      }, delay);
    };
    const unhighlighted = (nativeEvent = true) => {
      for (const e3 of elements) {
        removeState(e3, "active", "inactive");
        removeBackground(e3);
        removeLink(e3);
      }
      if (nativeEvent) {
        emitter.emit("element:unhighlight", { nativeEvent });
      }
    };
    const pointerout = (event) => {
      const { target: element } = event;
      if (background && !isBackground(element))
        return;
      if (!background && !elementSet.has(element))
        return;
      if (delay > 0)
        delayUnhighlighted();
      else
        unhighlighted();
    };
    const pointerleave = () => {
      unhighlighted();
    };
    root2.addEventListener("pointerover", pointerover);
    root2.addEventListener("pointerout", pointerout);
    root2.addEventListener("pointerleave", pointerleave);
    const onRest = (e3) => {
      const { nativeEvent } = e3;
      if (nativeEvent)
        return;
      unhighlighted(false);
    };
    const onHighlight = (e3) => {
      const { nativeEvent } = e3;
      if (nativeEvent)
        return;
      const { data: data2 } = e3.data;
      const element = selectElementByData(elements, data2, datum);
      if (!element)
        return;
      pointerover({ target: element, nativeEvent: false });
    };
    emitter.on("element:highlight", onHighlight);
    emitter.on("element:unhighlight", onRest);
    return () => {
      root2.removeEventListener("pointerover", pointerover);
      root2.removeEventListener("pointerout", pointerout);
      root2.removeEventListener("pointerleave", pointerleave);
      emitter.off("element:highlight", onHighlight);
      emitter.off("element:unhighlight", onRest);
      for (const e3 of elements) {
        removeBackground(e3);
        removeLink(e3);
      }
    };
  }
  function ElementHighlight(_a) {
    var { delay, createGroup, background = false, link: link2 = false } = _a, rest = __rest78(_a, ["delay", "createGroup", "background", "link"]);
    return (context, _2, emitter) => {
      const { container, view, options } = context;
      const { scale: scale9, coordinate } = view;
      const plotArea = selectPlotArea(container);
      return elementHighlight(plotArea, Object.assign({
        elements: selectG2Elements,
        datum: createDatumof(view),
        groupKey: createGroup ? createGroup(view) : void 0,
        coordinate,
        scale: scale9,
        state: mergeState(options, [
          ["active", background ? {} : { lineWidth: "1", stroke: "#000" }],
          "inactive"
        ]),
        background,
        link: link2,
        delay,
        emitter
      }, rest));
    };
  }
  ElementHighlight.props = {
    reapplyWhenUpdate: true
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/elementHighlightByX.js
  function ElementHighlightByX(options) {
    return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
  }
  ElementHighlightByX.props = {
    reapplyWhenUpdate: true
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/elementHighlightByColor.js
  function ElementHighlightByColor(options) {
    return ElementHighlight(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
  }
  ElementHighlightByColor.props = {
    reapplyWhenUpdate: true
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/elementSelect.js
  var __rest79 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function elementSelect(root2, {
    elements: elementsof,
    // given the root of chart returns elements to be manipulated
    datum,
    // given each element returns the datum of it
    groupKey = (d2) => d2,
    // group elements by specified key
    link: link2 = false,
    // draw link or not
    single = false,
    // single select or not
    coordinate,
    background = false,
    scale: scale9,
    emitter,
    state = {}
  }) {
    var _a;
    const elements = elementsof(root2);
    const elementSet = new Set(elements);
    const keyGroup = group(elements, groupKey);
    const valueof2 = createValueof(elements, datum);
    const [appendLink, removeLink] = renderLink(Object.assign({
      link: link2,
      elements,
      valueof: valueof2,
      coordinate
    }, subObject(state.selected, "link")));
    const [appendBackground, removeBackground] = renderBackground(Object.assign({
      document: root2.ownerDocument,
      background,
      coordinate,
      scale: scale9,
      valueof: valueof2
    }, subObject(state.selected, "background")));
    const elementStyle = deep_mix_default(state, {
      selected: Object.assign({}, ((_a = state.selected) === null || _a === void 0 ? void 0 : _a.offset) && {
        //Apply translate to mock slice out.
        transform: (...params) => {
          const value2 = state.selected.offset(...params);
          const [, i] = params;
          return offsetTransform(elements[i], value2, coordinate);
        }
      })
    });
    const { setState, removeState, hasState } = useState(elementStyle, valueof2);
    const clear = (nativeEvent = true) => {
      for (const e3 of elements) {
        removeState(e3, "selected", "unselected");
        removeLink(e3);
        removeBackground(e3);
      }
      if (nativeEvent)
        emitter.emit("element:unselect", { nativeEvent: true });
      return;
    };
    const singleSelect = (event, element, nativeEvent = true) => {
      if (hasState(element, "selected"))
        clear();
      else {
        const k = groupKey(element);
        const group3 = keyGroup.get(k);
        const groupSet = new Set(group3);
        for (const e3 of elements) {
          if (groupSet.has(e3))
            setState(e3, "selected");
          else {
            setState(e3, "unselected");
            removeLink(e3);
          }
          if (e3 !== element)
            removeBackground(e3);
        }
        appendLink(group3);
        appendBackground(element);
        if (!nativeEvent)
          return;
        emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
          data: [datum(element), ...group3.map(datum)]
        } }));
      }
    };
    const multipleSelect = (event, element, nativeEvent = true) => {
      const k = groupKey(element);
      const group3 = keyGroup.get(k);
      const groupSet = new Set(group3);
      if (!hasState(element, "selected")) {
        const hasSelectedGroup = group3.some((e3) => hasState(e3, "selected"));
        for (const e3 of elements) {
          if (groupSet.has(e3))
            setState(e3, "selected");
          else if (!hasState(e3, "selected"))
            setState(e3, "unselected");
        }
        if (!hasSelectedGroup && link2)
          appendLink(group3);
        appendBackground(element);
      } else {
        const hasSelected = elements.some((e3) => !groupSet.has(e3) && hasState(e3, "selected"));
        if (!hasSelected)
          return clear();
        for (const e3 of group3) {
          setState(e3, "unselected");
          removeLink(e3);
          removeBackground(e3);
        }
      }
      if (!nativeEvent)
        return;
      emitter.emit("element:select", Object.assign(Object.assign({}, event), { nativeEvent, data: {
        data: elements.filter((e3) => hasState(e3, "selected")).map(datum)
      } }));
    };
    const click = (event) => {
      const { target: element, nativeEvent = true } = event;
      if (!elementSet.has(element))
        return clear();
      if (single)
        return singleSelect(event, element, nativeEvent);
      return multipleSelect(event, element, nativeEvent);
    };
    root2.addEventListener("click", click);
    const onSelect = (e3) => {
      const { nativeEvent, data: data2 } = e3;
      if (nativeEvent)
        return;
      const selectedData = single ? data2.data.slice(0, 1) : data2.data;
      for (const d2 of selectedData) {
        const element = selectElementByData(elements, d2, datum);
        click({ target: element, nativeEvent: false });
      }
    };
    const onUnSelect = () => {
      clear(false);
    };
    emitter.on("element:select", onSelect);
    emitter.on("element:unselect", onUnSelect);
    return () => {
      for (const e3 of elements)
        removeLink(e3);
      root2.removeEventListener("click", click);
      emitter.off("element:select", onSelect);
      emitter.off("element:unselect", onUnSelect);
    };
  }
  function ElementSelect(_a) {
    var { createGroup, background = false, link: link2 = false } = _a, rest = __rest79(_a, ["createGroup", "background", "link"]);
    return (context, _2, emitter) => {
      const { container, view, options } = context;
      const { coordinate, scale: scale9 } = view;
      const plotArea = selectPlotArea(container);
      return elementSelect(plotArea, Object.assign({
        elements: selectG2Elements,
        datum: createDatumof(view),
        groupKey: createGroup ? createGroup(view) : void 0,
        coordinate,
        scale: scale9,
        state: mergeState(options, [
          ["selected", background ? {} : { lineWidth: "1", stroke: "#000" }],
          "unselected"
        ]),
        background,
        link: link2,
        emitter
      }, rest));
    };
  }
  ElementSelect.props = {
    reapplyWhenUpdate: true
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/elementSelectByX.js
  function ElementSelectByX(options) {
    return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createXKey }));
  }
  ElementSelectByX.props = {
    reapplyWhenUpdate: true
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/elementSelectByColor.js
  function ElementSelectByColor(options) {
    return ElementSelect(Object.assign(Object.assign({}, options), { createGroup: createColorKey }));
  }
  ElementSelectByColor.props = {
    reapplyWhenUpdate: true
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/chartIndex.js
  var __awaiter7 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest80 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function maybeTransform(options) {
    const { transform = [] } = options;
    const normalizeY = transform.find((d2) => d2.type === "normalizeY");
    if (normalizeY)
      return normalizeY;
    const newNormalizeY = { type: "normalizeY" };
    transform.push(newNormalizeY);
    options.transform = transform;
    return newNormalizeY;
  }
  function markValue2(markState, markName, channels) {
    const [value2] = Array.from(markState.entries()).filter(([mark]) => mark.type === markName).map(([mark]) => {
      const { encode } = mark;
      const channel = (name2) => {
        const channel2 = encode[name2];
        return [name2, channel2 ? channel2.value : void 0];
      };
      return Object.fromEntries(channels.map(channel));
    });
    return value2;
  }
  function ChartIndex(_a) {
    var { wait = 20, leading, trailing = false, labelFormatter = (date) => `${date}` } = _a, style = __rest80(_a, ["wait", "leading", "trailing", "labelFormatter"]);
    return (context) => {
      const { view, container, update, setState } = context;
      const { markState, scale: scale9, coordinate } = view;
      const value2 = markValue2(markState, "line", ["x", "y", "series"]);
      if (!value2)
        return;
      const { y: Y, x: X, series: S = [] } = value2;
      const I = Y.map((_2, i) => i);
      const sortedX = sort2(I.map((i) => X[i]));
      const plotArea = selectPlotArea(container);
      const lines = container.getElementsByClassName(ELEMENT_CLASS_NAME);
      const labels = container.getElementsByClassName(LABEL_CLASS_NAME);
      const keyofLabel = (d2) => d2.__data__.key.split("-")[0];
      const keyLabels = group(labels, keyofLabel);
      const rule = new Line({
        style: Object.assign({ x1: 0, y1: 0, x2: 0, y2: plotArea.getAttribute("height"), stroke: "black", lineWidth: 1 }, subObject(style, "rule"))
      });
      const text = new Text({
        style: Object.assign({ x: 0, y: plotArea.getAttribute("height"), text: "", fontSize: 10 }, subObject(style, "label"))
      });
      rule.append(text);
      plotArea.appendChild(rule);
      const dateByFocus = (coordinate2, scaleX, focus) => {
        const [normalizedX] = coordinate2.invert(focus);
        const date = scaleX.invert(normalizedX);
        return sortedX[bisectCenter(sortedX, date)];
      };
      const updateRule = (focus, date) => {
        rule.setAttribute("x1", focus[0]);
        rule.setAttribute("x2", focus[0]);
        text.setAttribute("text", labelFormatter(date));
      };
      let newView;
      const updateBasisByRerender = (focus) => __awaiter7(this, void 0, void 0, function* () {
        const { x: scaleX } = scale9;
        const date = dateByFocus(coordinate, scaleX, focus);
        updateRule(focus, date);
        setState("chartIndex", (options) => {
          const clonedOptions = deep_mix_default({}, options);
          const lineMark = clonedOptions.marks.find((d2) => d2.type === "line");
          const r = (I2) => max4(I2, (i) => +Y[i]) / min4(I2, (i) => +Y[i]);
          const k = max4(rollup(I, r, (i) => S[i]).values());
          const domainY = [1 / k, k];
          deep_mix_default(lineMark, {
            scale: { y: { domain: domainY } }
          });
          const normalizeY = maybeTransform(lineMark);
          normalizeY.groupBy = "color";
          normalizeY.basis = (I2, Y3) => {
            const i = I2[bisector((i2) => X[+i2]).center(I2, date)];
            return Y3[i];
          };
          for (const mark of clonedOptions.marks)
            mark.animate = false;
          return clonedOptions;
        });
        const newState = yield update("chartIndex");
        newView = newState.view;
      });
      const updateBasisByTranslate = (focus) => {
        const { scale: scale10, coordinate: coordinate2 } = newView;
        const { x: scaleX, y: scaleY } = scale10;
        const date = dateByFocus(coordinate2, scaleX, focus);
        updateRule(focus, date);
        for (const line4 of lines) {
          const { seriesIndex: SI, key } = line4.__data__;
          const i = SI[bisector((i2) => X[+i2]).center(SI, date)];
          const p0 = [0, scaleY.map(1)];
          const p1 = [0, scaleY.map(Y[i] / Y[SI[0]])];
          const [, y05] = coordinate2.map(p0);
          const [, y12] = coordinate2.map(p1);
          const dy = y05 - y12;
          line4.setAttribute("transform", `translate(0, ${dy})`);
          const labels2 = keyLabels.get(key) || [];
          for (const label of labels2) {
            label.setAttribute("dy", dy);
          }
        }
      };
      const updateBasis = throttle_default((event) => {
        const focus = mousePosition(plotArea, event);
        if (!focus)
          return;
        updateBasisByTranslate(focus);
      }, wait, { leading, trailing });
      updateBasisByRerender([0, 0]);
      plotArea.addEventListener("pointerenter", updateBasis);
      plotArea.addEventListener("pointermove", updateBasis);
      plotArea.addEventListener("pointerleave", updateBasis);
      return () => {
        rule.remove();
        plotArea.removeEventListener("pointerenter", updateBasis);
        plotArea.removeEventListener("pointermove", updateBasis);
        plotArea.removeEventListener("pointerleave", updateBasis);
      };
    };
  }
  ChartIndex.props = {
    reapplyWhenUpdate: true
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/fisheye.js
  function maybeCoordinate(options) {
    const { coordinate = {} } = options;
    const { transform = [] } = coordinate;
    const fisheye = transform.find((d2) => d2.type === "fisheye");
    if (fisheye)
      return fisheye;
    const newFisheye = { type: "fisheye" };
    transform.push(newFisheye);
    coordinate.transform = transform;
    options.coordinate = coordinate;
    return newFisheye;
  }
  function Fisheye2({ wait = 30, leading, trailing = false }) {
    return (context) => {
      const { options, update, setState, container } = context;
      const plotArea = selectPlotArea(container);
      const updateFocus = throttle_default((event) => {
        const focus = mousePosition(plotArea, event);
        if (!focus) {
          setState("fisheye");
          update();
          return;
        }
        setState("fisheye", (options2) => {
          const clonedOptions = deep_mix_default({}, options2, {
            interaction: { tooltip: { preserve: true } }
          });
          for (const mark of clonedOptions.marks)
            mark.animate = false;
          const [x3, y3] = focus;
          const fisheye = maybeCoordinate(clonedOptions);
          fisheye.focusX = x3;
          fisheye.focusY = y3;
          fisheye.visual = true;
          return clonedOptions;
        });
        update();
      }, wait, { leading, trailing });
      plotArea.addEventListener("pointerenter", updateFocus);
      plotArea.addEventListener("pointermove", updateFocus);
      plotArea.addEventListener("pointerleave", updateFocus);
      return () => {
        plotArea.removeEventListener("pointerenter", updateFocus);
        plotArea.removeEventListener("pointermove", updateFocus);
        plotArea.removeEventListener("pointerleave", updateFocus);
      };
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/tooltip.js
  var __rest81 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function getContainer(group3, mount2) {
    if (mount2) {
      return typeof mount2 === "string" ? document.querySelector(mount2) : mount2;
    }
    const canvas = group3.ownerDocument.defaultView.getContextService().getDomElement();
    return canvas.parentElement;
  }
  function getBounding(root2) {
    const bbox = root2.getRenderBounds();
    const { min: [x12, y12], max: [x22, y22] } = bbox;
    return {
      x: x12,
      y: y12,
      width: x22 - x12,
      height: y22 - y12
    };
  }
  function getContainerOffset(container1, container2) {
    const r1 = container1.getBoundingClientRect();
    const r2 = container2.getBoundingClientRect();
    return {
      x: r1.x - r2.x,
      y: r1.y - r2.y
    };
  }
  function createTooltip(container, x05, y05, position, enterable, bounding, containerOffset, css2 = {}, offset3 = [10, 10]) {
    const defaults5 = {
      ".g2-tooltip": {},
      ".g2-tooltip-title": {
        overflow: "hidden",
        "white-space": "nowrap",
        "text-overflow": "ellipsis"
      }
    };
    const tooltipElement = new Tooltip({
      className: "tooltip",
      style: {
        x: x05,
        y: y05,
        container: containerOffset,
        data: [],
        bounding,
        position,
        enterable,
        title: "",
        offset: offset3,
        template: {
          prefixCls: "g2-"
        },
        style: deep_mix_default(defaults5, css2)
      }
    });
    container.appendChild(tooltipElement.HTMLTooltipElement);
    return tooltipElement;
  }
  function showTooltip({ root: root2, data: data2, x: x3, y: y3, render: render2, event, single, position = "right-bottom", enterable = false, css: css2, mount: mount2, bounding, offset: offset3 }) {
    const container = getContainer(root2, mount2);
    const canvasContainer = getContainer(root2);
    const parent = single ? canvasContainer : root2;
    const b = bounding || getBounding(root2);
    const containerOffset = getContainerOffset(canvasContainer, container);
    const { tooltipElement = createTooltip(container, x3, y3, position, enterable, b, containerOffset, css2, offset3) } = parent;
    const { items, title = "" } = data2;
    tooltipElement.update(Object.assign({
      x: x3,
      y: y3,
      data: items,
      title,
      position,
      enterable
    }, render2 !== void 0 && {
      content: render2(event, { items, title })
    }));
    parent.tooltipElement = tooltipElement;
  }
  function hideTooltip({ root: root2, single, emitter, nativeEvent = true, event = null }) {
    if (nativeEvent) {
      emitter.emit("tooltip:hide", { nativeEvent });
    }
    const container = getContainer(root2);
    const parent = single ? container : root2;
    const { tooltipElement } = parent;
    if (tooltipElement) {
      tooltipElement.hide(event === null || event === void 0 ? void 0 : event.clientX, event === null || event === void 0 ? void 0 : event.clientY);
    }
    hideRuleY(root2);
    hideRuleX(root2);
    hideMarker(root2);
  }
  function destroyTooltip({ root: root2, single }) {
    const container = getContainer(root2);
    const parent = single ? container : root2;
    if (!parent)
      return;
    const { tooltipElement } = parent;
    if (tooltipElement) {
      tooltipElement.destroy();
      parent.tooltipElement = void 0;
    }
    hideRuleY(root2);
    hideRuleX(root2);
    hideMarker(root2);
  }
  function showUndefined(item) {
    const { value: value2 } = item;
    return Object.assign(Object.assign({}, item), { value: value2 === void 0 ? "undefined" : value2 });
  }
  function singleItem(element) {
    const { __data__: datum } = element;
    const { title, items = [] } = datum;
    const newItems = items.filter(defined).map((_a) => {
      var { color: color2 = itemColorOf(element) } = _a, item = __rest81(_a, ["color"]);
      return Object.assign(Object.assign({}, item), { color: color2 });
    }).map(showUndefined);
    return Object.assign(Object.assign({}, title && { title }), { items: newItems });
  }
  function groupNameOf(scale9, datum) {
    const { color: scaleColor, series: scaleSeries, facet = false } = scale9;
    const { color: color2, series } = datum;
    const invertAble = (scale10) => {
      return scale10 && scale10.invert && !(scale10 instanceof Band) && !(scale10 instanceof Constant2);
    };
    if (invertAble(scaleSeries)) {
      const cloned = scaleSeries.clone();
      return cloned.invert(series);
    }
    if (series && scaleSeries instanceof Band && scaleSeries.invert(series) !== color2 && !facet) {
      return scaleSeries.invert(series);
    }
    if (invertAble(scaleColor)) {
      const name2 = scaleColor.invert(color2);
      if (Array.isArray(name2))
        return null;
      return name2;
    }
    return null;
  }
  function itemColorOf(element) {
    const fill = element.getAttribute("fill");
    const stroke2 = element.getAttribute("stroke");
    const { __data__: datum } = element;
    const { color: color2 = fill && fill !== "transparent" ? fill : stroke2 } = datum;
    return color2;
  }
  function unique2(items, key = (d2) => d2) {
    const valueName = new Map(items.map((d2) => [key(d2), d2]));
    return Array.from(valueName.values());
  }
  function groupItems(elements, scale9, groupName, data2 = elements.map((d2) => d2["__data__"]), theme = {}) {
    const key = (d2) => d2 instanceof Date ? +d2 : d2;
    const T = unique2(data2.map((d2) => d2.title), key).filter(defined);
    const newItems = data2.flatMap((datum, i) => {
      const element = elements[i];
      const { items = [], title } = datum;
      const definedItems = items.filter(defined);
      const useGroupName = groupName !== void 0 ? groupName : items.length <= 1 ? true : false;
      return definedItems.map((_a) => {
        var { color: color2 = itemColorOf(element) || theme.color, name: name2 } = _a, item = __rest81(_a, ["color", "name"]);
        const groupName2 = groupNameOf(scale9, datum);
        const name1 = useGroupName ? groupName2 || name2 : name2 || groupName2;
        return Object.assign(Object.assign({}, item), { color: color2, name: name1 || title });
      });
    }).map(showUndefined);
    return Object.assign(Object.assign({}, T.length > 0 && { title: T.join(",") }), { items: unique2(newItems, (d2) => `(${key(d2.name)}, ${key(d2.value)}, ${key(d2.color)})`) });
  }
  function updateRuleX(root2, points, mouse, _a) {
    var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar, insetLeft, insetTop } = _a, rest = __rest81(_a, ["plotWidth", "plotHeight", "mainWidth", "mainHeight", "startX", "startY", "transposed", "polar", "insetLeft", "insetTop"]);
    const defaults5 = Object.assign({ lineWidth: 1, stroke: "#1b1e23", strokeOpacity: 0.5 }, rest);
    const createCircle = (cx, cy, r) => {
      const circle3 = new Circle({
        style: Object.assign({
          cx,
          cy,
          r
        }, defaults5)
      });
      root2.appendChild(circle3);
      return circle3;
    };
    const createLine = (x12, x22, y12, y22) => {
      const line4 = new Line({
        style: Object.assign({
          x1: x12,
          x2: x22,
          y1: y12,
          y2: y22
        }, defaults5)
      });
      root2.appendChild(line4);
      return line4;
    };
    const minDistPoint = (mouse2, points2) => {
      if (points2.length === 1) {
        return points2[0];
      }
      const dists = points2.map((p2) => dist4(p2, mouse2));
      const minDistIndex = minIndex(dists, (d2) => d2);
      return points2[minDistIndex];
    };
    const target = minDistPoint(mouse, points);
    const pointsOf = () => {
      if (transposed)
        return [
          startX + target[0],
          startX + target[0],
          startY,
          startY + plotHeight
        ];
      return [startX, startX + plotWidth, target[1] + startY, target[1] + startY];
    };
    const pointsOfPolar = () => {
      const cx = startX + insetLeft + mainWidth / 2;
      const cy = startY + insetTop + mainHeight / 2;
      const cdist = dist4([cx, cy], target);
      return [cx, cy, cdist];
    };
    if (polar) {
      const [cx, cy, r] = pointsOfPolar();
      const ruleX = root2.ruleX || createCircle(cx, cy, r);
      ruleX.style.cx = cx;
      ruleX.style.cy = cy;
      ruleX.style.r = r;
      root2.ruleX = ruleX;
    } else {
      const [x12, x22, y12, y22] = pointsOf();
      const ruleX = root2.ruleX || createLine(x12, x22, y12, y22);
      ruleX.style.x1 = x12;
      ruleX.style.x2 = x22;
      ruleX.style.y1 = y12;
      ruleX.style.y2 = y22;
      root2.ruleX = ruleX;
    }
  }
  function updateRuleY(root2, points, _a) {
    var { plotWidth, plotHeight, mainWidth, mainHeight, startX, startY, transposed, polar, insetLeft, insetTop } = _a, rest = __rest81(_a, ["plotWidth", "plotHeight", "mainWidth", "mainHeight", "startX", "startY", "transposed", "polar", "insetLeft", "insetTop"]);
    const defaults5 = Object.assign({ lineWidth: 1, stroke: "#1b1e23", strokeOpacity: 0.5 }, rest);
    const Y = points.map((p2) => p2[1]);
    const X = points.map((p2) => p2[0]);
    const y3 = mean(Y);
    const x3 = mean(X);
    const pointsOf = () => {
      if (polar) {
        const r = Math.min(mainWidth, mainHeight) / 2;
        const cx = startX + insetLeft + mainWidth / 2;
        const cy = startY + insetTop + mainHeight / 2;
        const a3 = angle3(sub6([x3, y3], [cx, cy]));
        const x05 = cx + r * Math.cos(a3);
        const y05 = cy + r * Math.sin(a3);
        return [cx, x05, cy, y05];
      }
      if (transposed)
        return [startX, startX + plotWidth, y3 + startY, y3 + startY];
      return [x3 + startX, x3 + startX, startY, startY + plotHeight];
    };
    const [x12, x22, y12, y22] = pointsOf();
    const createLine = () => {
      const line4 = new Line({
        style: Object.assign({
          x1: x12,
          x2: x22,
          y1: y12,
          y2: y22
        }, defaults5)
      });
      root2.appendChild(line4);
      return line4;
    };
    if (X.length > 0) {
      const ruleY = root2.ruleY || createLine();
      ruleY.style.x1 = x12;
      ruleY.style.x2 = x22;
      ruleY.style.y1 = y12;
      ruleY.style.y2 = y22;
      root2.ruleY = ruleY;
    }
  }
  function hideRuleY(root2) {
    if (root2.ruleY) {
      root2.ruleY.remove();
      root2.ruleY = void 0;
    }
  }
  function hideRuleX(root2) {
    if (root2.ruleX) {
      root2.ruleX.remove();
      root2.ruleX = void 0;
    }
  }
  function updateMarker(root2, { data: data2, style, theme }) {
    if (root2.markers)
      root2.markers.forEach((d2) => d2.remove());
    const { type = "" } = style;
    const markers = data2.filter((d2) => {
      const [{ x: x3, y: y3 }] = d2;
      return defined(x3) && defined(y3);
    }).map((d2) => {
      const [{ color: color2, element }, point6] = d2;
      const originColor = color2 || // encode value
      element.style.fill || element.style.stroke || theme.color;
      const fill = type === "hollow" ? "transparent" : originColor;
      const stroke2 = type === "hollow" ? originColor : "#fff";
      const shape23 = new Circle({
        className: "g2-tooltip-marker",
        style: Object.assign({ cx: point6[0], cy: point6[1], fill, r: 4, stroke: stroke2, lineWidth: 2 }, style)
      });
      return shape23;
    });
    for (const marker of markers)
      root2.appendChild(marker);
    root2.markers = markers;
  }
  function hideMarker(root2) {
    if (root2.markers) {
      root2.markers.forEach((d2) => d2.remove());
      root2.markers = [];
    }
  }
  function interactionKeyof(markState, key) {
    return Array.from(markState.values()).some(
      // @ts-ignore
      (d2) => {
        var _a;
        return (_a = d2.interaction) === null || _a === void 0 ? void 0 : _a[key];
      }
    );
  }
  function maybeValue(specified, defaults5) {
    return specified === void 0 ? defaults5 : specified;
  }
  function isEmptyTooltipData(data2) {
    const { title, items } = data2;
    if (items.length === 0 && title === void 0)
      return true;
    return false;
  }
  function hasSeries(markState) {
    return Array.from(markState.values()).some(
      // @ts-ignore
      (d2) => {
        var _a;
        return ((_a = d2.interaction) === null || _a === void 0 ? void 0 : _a.seriesTooltip) && d2.tooltip;
      }
    );
  }
  function seriesTooltip(root2, _a) {
    var { elements: elementsof, sort: sortFunction, filter: filterFunction, scale: scale9, coordinate, crosshairs, crosshairsX, crosshairsY, render: render2, groupName, emitter, wait = 50, leading = true, trailing = false, startX = 0, startY = 0, body = true, single = true, position, enterable, mount: mount2, bounding, theme, offset: offset3, disableNative = false, marker = true, preserve = false, style: _style = {}, css: css2 = {} } = _a, rest = __rest81(_a, ["elements", "sort", "filter", "scale", "coordinate", "crosshairs", "crosshairsX", "crosshairsY", "render", "groupName", "emitter", "wait", "leading", "trailing", "startX", "startY", "body", "single", "position", "enterable", "mount", "bounding", "theme", "offset", "disableNative", "marker", "preserve", "style", "css"]);
    const elements = elementsof(root2);
    const transposed = isTranspose(coordinate);
    const polar = isPolar(coordinate);
    const style = deep_mix_default(_style, rest);
    const { innerWidth: plotWidth, innerHeight: plotHeight, width: mainWidth, height: mainHeight, insetLeft, insetTop } = coordinate.getOptions();
    const seriesElements = [];
    const itemElements = [];
    for (const element of elements) {
      const { __data__: data2 } = element;
      const { seriesX, title, items } = data2;
      if (seriesX)
        seriesElements.push(element);
      else if (title || items)
        itemElements.push(element);
    }
    const inInterval = (d2) => d2.markType === "interval";
    const isBar = itemElements.length && itemElements.every(inInterval) && !isPolar(coordinate);
    const xof = (d2) => d2.__data__.x;
    const isBandScale = !!scale9.x.getBandWidth;
    const closest2 = isBandScale && itemElements.length > 0;
    seriesElements.sort((a3, b) => {
      const index4 = transposed ? 0 : 1;
      const minY = (d2) => d2.getBounds().min[index4];
      return transposed ? minY(b) - minY(a3) : minY(a3) - minY(b);
    });
    const extent2 = (d2) => {
      const index4 = transposed ? 1 : 0;
      const { min: min10, max: max10 } = d2.getLocalBounds();
      return sort2([min10[index4], max10[index4]]);
    };
    if (isBar)
      elements.sort((a3, b) => xof(a3) - xof(b));
    else {
      itemElements.sort((a3, b) => {
        const [minA, maxA] = extent2(a3);
        const [minB, maxB] = extent2(b);
        const midA = (minA + maxA) / 2;
        const midB = (minB + maxB) / 2;
        return transposed ? midB - midA : midA - midB;
      });
    }
    const elementSortedX = new Map(seriesElements.map((element) => {
      const { __data__: data2 } = element;
      const { seriesX } = data2;
      const seriesIndex = seriesX.map((_2, i) => i);
      const sortedIndex2 = sort2(seriesIndex, (i) => seriesX[+i]);
      return [element, [sortedIndex2, seriesX]];
    }));
    const { x: scaleX } = scale9;
    const offsetX = (scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) ? scaleX.getBandWidth() / 2 : 0;
    const abstractX = (focus) => {
      const [normalizedX] = coordinate.invert(focus);
      return normalizedX - offsetX;
    };
    const indexByFocus = (event, focus, I, X) => {
      const { _x } = event;
      const finalX = _x !== void 0 ? scaleX.map(_x) : abstractX(focus);
      const DX = X.filter(defined);
      const [minX, maxX] = sort2([DX[0], DX[DX.length - 1]]);
      const isOnlyOneElement = minX === maxX;
      if (!closest2 && (finalX < minX || finalX > maxX) && !isOnlyOneElement)
        return null;
      const search2 = bisector((i2) => X[+i2]).center;
      const i = search2(I, finalX);
      return I[i];
    };
    const elementsByFocus = isBar ? (focus, elements2) => {
      const search2 = bisector(xof).center;
      const i = search2(elements2, abstractX(focus));
      const find6 = elements2[i];
      const groups2 = group(elements2, xof);
      const selected = groups2.get(xof(find6));
      return selected;
    } : (focus, elements2) => {
      const index4 = transposed ? 1 : 0;
      const x3 = focus[index4];
      const filtered = elements2.filter((element) => {
        const [min10, max10] = extent2(element);
        return x3 >= min10 && x3 <= max10;
      });
      if (!closest2 || filtered.length > 0)
        return filtered;
      const search2 = bisector((element) => {
        const [min10, max10] = extent2(element);
        return (min10 + max10) / 2;
      }).center;
      const i = search2(elements2, x3);
      return [elements2[i]].filter(defined);
    };
    const seriesData = (element, index4) => {
      const { __data__: data2 } = element;
      return Object.fromEntries(Object.entries(data2).filter(([key]) => key.startsWith("series") && key !== "series").map(([key, V]) => {
        const d2 = V[index4];
        return [lower_first_default(key.replace("series", "")), d2];
      }));
    };
    const update = throttle_default((event) => {
      var _a2;
      const mouse = mousePosition(root2, event);
      if (!mouse)
        return;
      const bbox = bboxOf(root2);
      const x3 = bbox.min[0];
      const y3 = bbox.min[1];
      const focus = [mouse[0] - startX, mouse[1] - startY];
      if (!focus)
        return;
      const selectedItems = elementsByFocus(focus, itemElements);
      const selectedSeriesElements = [];
      const selectedSeriesData = [];
      for (const element of seriesElements) {
        const [sortedIndex2, X] = elementSortedX.get(element);
        const index4 = indexByFocus(event, focus, sortedIndex2, X);
        if (index4 !== null) {
          selectedSeriesElements.push(element);
          const d2 = seriesData(element, index4);
          const { x: x4, y: y4 } = d2;
          const p2 = coordinate.map([(x4 || 0) + offsetX, y4 || 0]);
          selectedSeriesData.push([Object.assign(Object.assign({}, d2), { element }), p2]);
        }
      }
      const SX = Array.from(new Set(selectedSeriesData.map((d2) => d2[0].x)));
      const closestX = SX[minIndex(SX, (x4) => Math.abs(x4 - abstractX(focus)))];
      const filteredSeriesData = selectedSeriesData.filter((d2) => d2[0].x === closestX);
      const selectedData = [
        ...filteredSeriesData.map((d2) => d2[0]),
        ...selectedItems.map((d2) => d2.__data__)
      ];
      const selectedElements = [...selectedSeriesElements, ...selectedItems];
      const tooltipData = groupItems(selectedElements, scale9, groupName, selectedData, theme);
      if (sortFunction) {
        tooltipData.items.sort((a3, b) => sortFunction(a3) - sortFunction(b));
      }
      if (filterFunction) {
        tooltipData.items = tooltipData.items.filter(filterFunction);
      }
      if (selectedElements.length === 0 || isEmptyTooltipData(tooltipData)) {
        hide3(event);
        return;
      }
      if (body) {
        showTooltip({
          root: root2,
          data: tooltipData,
          x: mouse[0] + x3,
          y: mouse[1] + y3,
          render: render2,
          event,
          single,
          position,
          enterable,
          mount: mount2,
          bounding,
          css: css2,
          offset: offset3
        });
      }
      if (crosshairs || crosshairsX || crosshairsY) {
        const ruleStyle = subObject(style, "crosshairs");
        const ruleStyleX = Object.assign(Object.assign({}, ruleStyle), subObject(style, "crosshairsX"));
        const ruleStyleY = Object.assign(Object.assign({}, ruleStyle), subObject(style, "crosshairsY"));
        const points = filteredSeriesData.map((d2) => d2[1]);
        if (crosshairsX) {
          updateRuleX(root2, points, mouse, Object.assign(Object.assign({}, ruleStyleX), {
            plotWidth,
            plotHeight,
            mainWidth,
            mainHeight,
            insetLeft,
            insetTop,
            startX,
            startY,
            transposed,
            polar
          }));
        }
        if (crosshairsY) {
          updateRuleY(root2, points, Object.assign(Object.assign({}, ruleStyleY), {
            plotWidth,
            plotHeight,
            mainWidth,
            mainHeight,
            insetLeft,
            insetTop,
            startX,
            startY,
            transposed,
            polar
          }));
        }
      }
      if (marker) {
        const markerStyles = subObject(style, "marker");
        updateMarker(root2, {
          data: filteredSeriesData,
          style: markerStyles,
          theme
        });
      }
      const firstX = (_a2 = filteredSeriesData[0]) === null || _a2 === void 0 ? void 0 : _a2[0].x;
      const transformedX = firstX !== null && firstX !== void 0 ? firstX : abstractX(focus);
      emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: {
        data: { x: invert4(scale9.x, transformedX, true) }
      } }));
    }, wait, { leading, trailing });
    const hide3 = (event) => {
      hideTooltip({ root: root2, single, emitter, event });
    };
    const destroy3 = () => {
      destroyTooltip({ root: root2, single });
    };
    const onTooltipShow = (_a2) => {
      var _b;
      var { nativeEvent, data: data2, offsetX: offsetX2, offsetY } = _a2, rest2 = __rest81(_a2, ["nativeEvent", "data", "offsetX", "offsetY"]);
      if (nativeEvent)
        return;
      const x3 = (_b = data2 === null || data2 === void 0 ? void 0 : data2.data) === null || _b === void 0 ? void 0 : _b.x;
      const scaleX2 = scale9.x;
      const x12 = scaleX2.map(x3);
      const [x22, y22] = coordinate.map([x12, 0.5]);
      const rootBounds = root2.getRenderBounds();
      const minX = rootBounds.min[0];
      const minY = rootBounds.min[1];
      update(Object.assign(Object.assign({}, rest2), { offsetX: offsetX2 !== void 0 ? offsetX2 : minX + x22, offsetY: offsetY !== void 0 ? offsetY : minY + y22, _x: x3 }));
    };
    const onTooltipHide = () => {
      hideTooltip({ root: root2, single, emitter, nativeEvent: false });
    };
    const onTooltipDisable = () => {
      removeEventListeners();
      destroy3();
    };
    const onTooltipEnable = () => {
      addEventListeners();
    };
    const addEventListeners = () => {
      if (!disableNative) {
        root2.addEventListener("pointerenter", update);
        root2.addEventListener("pointermove", update);
        root2.addEventListener("pointerleave", (e3) => {
          if (mousePosition(root2, e3))
            return;
          hide3(e3);
        });
      }
    };
    const removeEventListeners = () => {
      if (!disableNative) {
        root2.removeEventListener("pointerenter", update);
        root2.removeEventListener("pointermove", update);
        root2.removeEventListener("pointerleave", hide3);
      }
    };
    addEventListeners();
    emitter.on("tooltip:show", onTooltipShow);
    emitter.on("tooltip:hide", onTooltipHide);
    emitter.on("tooltip:disable", onTooltipDisable);
    emitter.on("tooltip:enable", onTooltipEnable);
    return () => {
      removeEventListeners();
      emitter.off("tooltip:show", onTooltipShow);
      emitter.off("tooltip:hide", onTooltipHide);
      emitter.off("tooltip:disable", onTooltipDisable);
      emitter.off("tooltip:enable", onTooltipEnable);
      if (preserve) {
        hideTooltip({ root: root2, single, emitter, nativeEvent: false });
      } else {
        destroy3();
      }
    };
  }
  function tooltip(root2, {
    elements: elementsof,
    coordinate,
    scale: scale9,
    render: render2,
    groupName,
    sort: sortFunction,
    filter: filterFunction,
    emitter,
    wait = 50,
    leading = true,
    trailing = false,
    groupKey = (d2) => d2,
    // group elements by specified key
    single = true,
    position,
    enterable,
    datum,
    view,
    mount: mount2,
    bounding,
    theme,
    offset: offset3,
    shared = false,
    body = true,
    disableNative = false,
    preserve = false,
    css: css2 = {}
  }) {
    var _a, _b;
    const elements = elementsof(root2);
    const keyGroup = group(elements, groupKey);
    const inInterval = (d2) => d2.markType === "interval";
    const isBar = elements.every(inInterval) && !isPolar(coordinate);
    const scaleX = scale9.x;
    const scaleSeries = scale9.series;
    const bandWidth3 = (_b = (_a = scaleX === null || scaleX === void 0 ? void 0 : scaleX.getBandWidth) === null || _a === void 0 ? void 0 : _a.call(scaleX)) !== null && _b !== void 0 ? _b : 0;
    const xof = scaleSeries ? (d2) => d2.__data__.x + d2.__data__.series * bandWidth3 : (d2) => d2.__data__.x + bandWidth3 / 2;
    if (isBar)
      elements.sort((a3, b) => xof(a3) - xof(b));
    const findElementByTarget = (event) => {
      const { target } = event;
      return maybeRoot(target, (node) => {
        if (!node.classList)
          return false;
        return node.classList.includes("element");
      });
    };
    const findElement2 = isBar ? (event) => {
      const mouse = mousePosition(root2, event);
      if (!mouse)
        return;
      const [normalizedX] = coordinate.invert(mouse);
      const abstractX = normalizedX;
      const search2 = bisector(xof).center;
      const i = search2(elements, abstractX);
      const target = elements[i];
      if (!shared) {
        const isGrouped = elements.find((d2) => d2 !== target && xof(d2) === xof(target));
        if (isGrouped)
          return findElementByTarget(event);
      }
      return target;
    } : findElementByTarget;
    const pointermove = throttle_default((event) => {
      const element = findElement2(event);
      if (!element) {
        hideTooltip({ root: root2, single, emitter, event });
        return;
      }
      const k = groupKey(element);
      const group3 = keyGroup.get(k);
      if (!group3) {
        return;
      }
      const data2 = group3.length === 1 && !shared ? singleItem(group3[0]) : groupItems(group3, scale9, groupName, void 0, theme);
      if (sortFunction) {
        data2.items.sort((a3, b) => sortFunction(a3) - sortFunction(b));
      }
      if (filterFunction) {
        data2.items = data2.items.filter(filterFunction);
      }
      if (isEmptyTooltipData(data2)) {
        hideTooltip({ root: root2, single, emitter, event });
        return;
      }
      const { offsetX, offsetY } = event;
      if (body) {
        showTooltip({
          root: root2,
          data: data2,
          x: offsetX,
          y: offsetY,
          render: render2,
          event,
          single,
          position,
          enterable,
          mount: mount2,
          bounding,
          css: css2,
          offset: offset3
        });
      }
      emitter.emit("tooltip:show", Object.assign(Object.assign({}, event), { nativeEvent: true, data: {
        data: dataOf(element, view)
      } }));
    }, wait, { leading, trailing });
    const pointerleave = (event) => {
      hideTooltip({ root: root2, single, emitter, event });
    };
    const addEventListeners = () => {
      if (!disableNative) {
        root2.addEventListener("pointermove", pointermove);
        root2.addEventListener("pointerleave", pointerleave);
      }
    };
    const removeEventListeners = () => {
      if (!disableNative) {
        root2.removeEventListener("pointermove", pointermove);
        root2.removeEventListener("pointerleave", pointerleave);
      }
    };
    const onTooltipShow = ({ nativeEvent, offsetX, offsetY, data: raw }) => {
      if (nativeEvent)
        return;
      const { data: data2 } = raw;
      const element = selectElementByData(elements, data2, datum);
      if (!element)
        return;
      const bbox = element.getBBox();
      const { x: x3, y: y3, width, height } = bbox;
      const rootBBox = root2.getBBox();
      pointermove({
        target: element,
        offsetX: offsetX !== void 0 ? offsetX + rootBBox.x : x3 + width / 2,
        offsetY: offsetY !== void 0 ? offsetY + rootBBox.y : y3 + height / 2
      });
    };
    const onTooltipHide = ({ nativeEvent } = {}) => {
      if (nativeEvent)
        return;
      hideTooltip({ root: root2, single, emitter, nativeEvent: false });
    };
    const onTooltipDisable = () => {
      removeEventListeners();
      destroyTooltip({ root: root2, single });
    };
    const onTooltipEnable = () => {
      addEventListeners();
    };
    emitter.on("tooltip:show", onTooltipShow);
    emitter.on("tooltip:hide", onTooltipHide);
    emitter.on("tooltip:enable", onTooltipEnable);
    emitter.on("tooltip:disable", onTooltipDisable);
    addEventListeners();
    return () => {
      removeEventListeners();
      emitter.off("tooltip:show", onTooltipShow);
      emitter.off("tooltip:hide", onTooltipHide);
      if (preserve) {
        hideTooltip({ root: root2, single, emitter, nativeEvent: false });
      } else {
        destroyTooltip({ root: root2, single });
      }
    };
  }
  function Tooltip2(options) {
    const { shared, crosshairs, crosshairsX, crosshairsY, series, name: name2, item = () => ({}), facet = false } = options, rest = __rest81(options, ["shared", "crosshairs", "crosshairsX", "crosshairsY", "series", "name", "item", "facet"]);
    return (target, viewInstances, emitter) => {
      const { container, view } = target;
      const { scale: scale9, markState, coordinate, theme } = view;
      const defaultSeries = interactionKeyof(markState, "seriesTooltip");
      const defaultShowCrosshairs = interactionKeyof(markState, "crosshairs");
      const plotArea = selectPlotArea(container);
      const isSeries = maybeValue(series, defaultSeries);
      const crosshairsSetting = maybeValue(crosshairs, defaultShowCrosshairs);
      if (isSeries && hasSeries(markState) && !facet) {
        return seriesTooltip(plotArea, Object.assign(Object.assign({}, rest), {
          theme,
          elements: selectG2Elements,
          scale: scale9,
          coordinate,
          crosshairs: crosshairsSetting,
          // the crosshairsX settings level: crosshairsX > crosshairs > false
          // it means crosshairsX default is false
          crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
          // crosshairsY default depend on the crossharisSettings
          crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
          item,
          emitter
        }));
      }
      if (isSeries && facet) {
        const facetInstances = viewInstances.filter((d2) => d2 !== target && d2.options.parentKey === target.options.key);
        const elements = selectFacetG2Elements(target, viewInstances);
        const scale10 = facetInstances[0].view.scale;
        const bbox = plotArea.getBounds();
        const startX = bbox.min[0];
        const startY = bbox.min[1];
        Object.assign(scale10, { facet: true });
        return seriesTooltip(plotArea.parentNode.parentNode, Object.assign(Object.assign({}, rest), {
          theme,
          elements: () => elements,
          scale: scale10,
          coordinate,
          crosshairs: maybeValue(crosshairs, defaultShowCrosshairs),
          // the crosshairsX settings level: crosshairsX > crosshairs > false
          // it means crosshairsX default is false
          crosshairsX: maybeValue(maybeValue(crosshairsX, crosshairs), false),
          crosshairsY: maybeValue(crosshairsY, crosshairsSetting),
          item,
          startX,
          startY,
          emitter
        }));
      }
      return tooltip(plotArea, Object.assign(Object.assign({}, rest), {
        datum: createDatumof(view),
        elements: selectG2Elements,
        scale: scale9,
        coordinate,
        groupKey: shared ? createXKey(view) : void 0,
        item,
        emitter,
        view,
        theme,
        shared
      }));
    };
  }
  Tooltip2.props = {
    reapplyWhenUpdate: true
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/legendFilter.js
  var __awaiter8 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var CATEGORY_LEGEND_CLASS_NAME = "legend-category";
  var CONTINUOUS_LEGEND_CLASS_NAME = "legend-continuous";
  var LEGEND_ITEMS_CLASS_NAME = "items-item";
  var LEGEND_MAKER_CLASS_NAME = "legend-category-item-marker";
  var LEGEND_LABEL_CLASS_NAME = "legend-category-item-label";
  function markerOf(item) {
    return item.getElementsByClassName(LEGEND_MAKER_CLASS_NAME)[0];
  }
  function labelOf(item) {
    return item.getElementsByClassName(LEGEND_LABEL_CLASS_NAME)[0];
  }
  function itemsOf(root2) {
    return root2.getElementsByClassName(LEGEND_ITEMS_CLASS_NAME);
  }
  function legendsOf(root2) {
    return root2.getElementsByClassName(CATEGORY_LEGEND_CLASS_NAME);
  }
  function legendsContinuousOf(root2) {
    return root2.getElementsByClassName(CONTINUOUS_LEGEND_CLASS_NAME);
  }
  function legendClearSetState(root2, setState) {
    const legends = [...legendsOf(root2), ...legendsContinuousOf(root2)];
    legends.forEach((legend) => {
      setState(legend, (v) => v);
    });
  }
  function dataOf2(root2) {
    let parent = root2.parentNode;
    while (parent && !parent.__data__) {
      parent = parent.parentNode;
    }
    return parent.__data__;
  }
  function legendFilterOrdinal(root2, {
    legends,
    // given the root of chart returns legends to be manipulated
    marker: markerOf2,
    // given the legend returns the marker
    label: labelOf2,
    // given the legend returns the label
    datum,
    // given the legend returns the value
    filter: filter2,
    // invoke when dispatch filter event,
    emitter,
    channel,
    state = {}
    // state options
  }) {
    const itemClick = /* @__PURE__ */ new Map();
    const itemPointerenter = /* @__PURE__ */ new Map();
    const itemPointerout = /* @__PURE__ */ new Map();
    const { unselected = {
      markerStroke: "#aaa",
      markerFill: "#aaa",
      labelFill: "#aaa"
    } } = state;
    const markerStyle = { unselected: subObject(unselected, "marker") };
    const labelStyle = { unselected: subObject(unselected, "label") };
    const { setState: setM, removeState: removeM } = useState(markerStyle, void 0);
    const { setState: setL, removeState: removeL } = useState(labelStyle, void 0);
    const items = Array.from(legends(root2));
    let selectedValues = items.map(datum);
    const updateLegendState = () => {
      for (const item of items) {
        const value2 = datum(item);
        const marker = markerOf2(item);
        const label = labelOf2(item);
        if (!selectedValues.includes(value2)) {
          setM(marker, "unselected");
          setL(label, "unselected");
        } else {
          removeM(marker, "unselected");
          removeL(label, "unselected");
        }
      }
    };
    for (const item of items) {
      const pointerenter = () => {
        setCursor(root2, "pointer");
      };
      const pointerout = () => {
        restoreCursor(root2);
      };
      const click = (event) => __awaiter8(this, void 0, void 0, function* () {
        const value2 = datum(item);
        const index4 = selectedValues.indexOf(value2);
        if (index4 === -1)
          selectedValues.push(value2);
        else
          selectedValues.splice(index4, 1);
        yield filter2(selectedValues);
        updateLegendState();
        const { nativeEvent = true } = event;
        if (!nativeEvent)
          return;
        if (selectedValues.length === items.length) {
          emitter.emit("legend:reset", { nativeEvent });
        } else {
          emitter.emit("legend:filter", Object.assign(Object.assign({}, event), { nativeEvent, data: {
            channel,
            values: selectedValues
          } }));
        }
      });
      item.addEventListener("click", click);
      item.addEventListener("pointerenter", pointerenter);
      item.addEventListener("pointerout", pointerout);
      itemClick.set(item, click);
      itemPointerenter.set(item, pointerenter);
      itemPointerout.set(item, pointerout);
    }
    const onFilter = (event) => __awaiter8(this, void 0, void 0, function* () {
      const { nativeEvent } = event;
      if (nativeEvent)
        return;
      const { data: data2 } = event;
      const { channel: specifiedChannel, values } = data2;
      if (specifiedChannel !== channel)
        return;
      selectedValues = values;
      yield filter2(selectedValues);
      updateLegendState();
    });
    const onEnd = (event) => __awaiter8(this, void 0, void 0, function* () {
      const { nativeEvent } = event;
      if (nativeEvent)
        return;
      selectedValues = items.map(datum);
      yield filter2(selectedValues);
      updateLegendState();
    });
    emitter.on("legend:filter", onFilter);
    emitter.on("legend:reset", onEnd);
    return () => {
      for (const item of items) {
        item.removeEventListener("click", itemClick.get(item));
        item.removeEventListener("pointerenter", itemPointerenter.get(item));
        item.removeEventListener("pointerout", itemPointerout.get(item));
        emitter.off("legend:filter", onFilter);
        emitter.off("legend:reset", onEnd);
      }
    };
  }
  function legendFilterContinuous(_2, { legend, filter: filter2, emitter, channel }) {
    const onValueChange = ({ detail: { value: value2 } }) => {
      filter2(value2);
      emitter.emit({
        nativeEvent: true,
        data: {
          channel,
          values: value2
        }
      });
    };
    legend.addEventListener("valuechange", onValueChange);
    return () => {
      legend.removeEventListener("valuechange", onValueChange);
    };
  }
  function filterView(context, {
    legend,
    // Legend instance.
    channel,
    // Filter Channel.
    value: value2,
    // Filtered Values.
    ordinal,
    // Data type of the legend.
    channels,
    // Channels for this legend.
    allChannels,
    // Channels for all legends.
    facet = false
    // For facet.
  }) {
    return __awaiter8(this, void 0, void 0, function* () {
      const { view, update, setState } = context;
      setState(legend, (viewOptions) => {
        const { marks } = viewOptions;
        const newMarks = marks.map((mark) => {
          if (mark.type === "legends")
            return mark;
          const { transform = [] } = mark;
          const index4 = transform.findIndex(({ type }) => type.startsWith("group") || type.startsWith("bin"));
          const newTransform = [...transform];
          newTransform.splice(index4 + 1, 0, {
            type: "filter",
            [channel]: { value: value2, ordinal }
          });
          const newScale = Object.fromEntries(channels.map((channel2) => [
            channel2,
            { domain: view.scale[channel2].getOptions().domain }
          ]));
          return deep_mix_default({}, mark, Object.assign(Object.assign({ transform: newTransform, scale: newScale }, !ordinal && { animate: false }), { legend: facet ? false : Object.fromEntries(allChannels.map((d2) => [d2, { preserve: true }])) }));
        });
        return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
      });
      yield update();
    });
  }
  function filterFacets(facets, options) {
    for (const facet of facets) {
      filterView(facet, Object.assign(Object.assign({}, options), { facet: true }));
    }
  }
  function LegendFilter() {
    return (context, contexts, emitter) => {
      const { container } = context;
      const facets = contexts.filter((d2) => d2 !== context);
      const isFacet = facets.length > 0;
      const channelsOf = (legend) => {
        return dataOf2(legend).scales.map((d2) => d2.name);
      };
      const legends = [
        ...legendsOf(container),
        ...legendsContinuousOf(container)
      ];
      const allChannels = legends.flatMap(channelsOf);
      const filter2 = isFacet ? throttle_default(filterFacets, 50, { trailing: true }) : throttle_default(filterView, 50, { trailing: true });
      const removes = legends.map((legend) => {
        const { name: channel, domain } = dataOf2(legend).scales[0];
        const channels = channelsOf(legend);
        const common = {
          legend,
          channel,
          channels,
          allChannels
        };
        if (legend.className === CATEGORY_LEGEND_CLASS_NAME) {
          return legendFilterOrdinal(container, {
            legends: itemsOf,
            marker: markerOf,
            label: labelOf,
            datum: (d2) => {
              const { __data__: datum } = d2;
              const { index: index4 } = datum;
              return domain[index4];
            },
            filter: (value2) => {
              const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: true });
              if (isFacet)
                filter2(facets, options);
              else
                filter2(context, options);
            },
            state: legend.attributes.state,
            channel,
            emitter
          });
        } else {
          return legendFilterContinuous(container, {
            legend,
            filter: (value2) => {
              const options = Object.assign(Object.assign({}, common), { value: value2, ordinal: false });
              if (isFacet)
                filter2(facets, options);
              else
                filter2(context, options);
            },
            emitter,
            channel
          });
        }
      });
      return () => {
        removes.forEach((remove) => remove());
      };
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/legendHighlight.js
  function LegendHighlight() {
    return (context, _2, emitter) => {
      const { container, view, options } = context;
      const legends = legendsOf(container);
      const elements = selectG2Elements(container);
      const channelOf = (legend) => {
        return dataOf2(legend).scales[0].name;
      };
      const scaleOf2 = (channel) => {
        const { scale: { [channel]: scale9 } } = view;
        return scale9;
      };
      const markState = mergeState(options, ["active", "inactive"]);
      const valueof2 = createValueof(elements, createDatumof(view));
      const destroys = [];
      for (const legend of legends) {
        const datumOf = (item) => {
          const { data: data2 } = legend.attributes;
          const { __data__: datum } = item;
          const { index: index4 } = datum;
          return data2[index4].label;
        };
        const channel = channelOf(legend);
        const items = itemsOf(legend);
        const scale9 = scaleOf2(channel);
        const elementGroup = group(elements, (d2) => scale9.invert(d2.__data__[channel]));
        const { state: legendState = {} } = legend.attributes;
        const { inactive = {} } = legendState;
        const { setState, removeState } = useState(markState, valueof2);
        const markerStyle = { inactive: subObject(inactive, "marker") };
        const labelStyle = { inactive: subObject(inactive, "label") };
        const { setState: setM, removeState: removeM } = useState(markerStyle);
        const { setState: setL, removeState: removeL } = useState(labelStyle);
        const updateLegendState = (highlight) => {
          for (const item of items) {
            const marker = markerOf(item);
            const label = labelOf(item);
            if (item === highlight || highlight === null) {
              removeM(marker, "inactive");
              removeL(label, "inactive");
            } else {
              setM(marker, "inactive");
              setL(label, "inactive");
            }
          }
        };
        const highlightItem = (event, item) => {
          const value2 = datumOf(item);
          const elementSet = new Set(elementGroup.get(value2));
          for (const e3 of elements) {
            if (elementSet.has(e3))
              setState(e3, "active");
            else
              setState(e3, "inactive");
          }
          updateLegendState(item);
          const { nativeEvent = true } = event;
          if (!nativeEvent)
            return;
          emitter.emit("legend:highlight", Object.assign(Object.assign({}, event), { nativeEvent, data: { channel, value: value2 } }));
        };
        const itemPointerover = /* @__PURE__ */ new Map();
        for (const item of items) {
          const pointerover = (event) => {
            highlightItem(event, item);
          };
          item.addEventListener("pointerover", pointerover);
          itemPointerover.set(item, pointerover);
        }
        const pointerleave = (event) => {
          for (const e3 of elements)
            removeState(e3, "inactive", "active");
          updateLegendState(null);
          const { nativeEvent = true } = event;
          if (!nativeEvent)
            return;
          emitter.emit("legend:unhighlight", { nativeEvent });
        };
        const onHighlight = (event) => {
          const { nativeEvent, data: data2 } = event;
          if (nativeEvent)
            return;
          const { channel: specifiedChannel, value: value2 } = data2;
          if (specifiedChannel !== channel)
            return;
          const item = items.find((d2) => datumOf(d2) === value2);
          if (!item)
            return;
          highlightItem({ nativeEvent: false }, item);
        };
        const onUnHighlight = (event) => {
          const { nativeEvent } = event;
          if (nativeEvent)
            return;
          pointerleave({ nativeEvent: false });
        };
        legend.addEventListener("pointerleave", pointerleave);
        emitter.on("legend:highlight", onHighlight);
        emitter.on("legend:unhighlight", onUnHighlight);
        const destroy3 = () => {
          legend.removeEventListener(pointerleave);
          emitter.off("legend:highlight", onHighlight);
          emitter.off("legend:unhighlight", onUnHighlight);
          for (const [item, pointerover] of itemPointerover) {
            item.removeEventListener(pointerover);
          }
        };
        destroys.push(destroy3);
      }
      return () => destroys.forEach((d2) => d2());
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/brushHighlight.js
  var __rest82 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function intersect3(bbox1, bbox2) {
    const [minX1, minY1, maxX1, maxY1] = bbox1;
    const [minX2, minY2, maxX2, maxY2] = bbox2;
    return !(minX2 > maxX1 || maxX2 < minX1 || minY2 > maxY1 || maxY2 < minY1);
  }
  function normalizeBounds(x3, y3, x12, y12, extent2) {
    const [minX, minY, maxX, maxY2] = extent2;
    return [
      Math.max(minX, Math.min(x3, x12)),
      Math.max(minY, Math.min(y3, y12)),
      Math.min(maxX, Math.max(x3, x12)),
      Math.min(maxY2, Math.max(y3, y12))
    ];
  }
  function bboxOf2(root2) {
    const { width, height } = root2.getBBox();
    return [0, 0, width, height];
  }
  function applyStyle3(selection, style) {
    for (const [key, value2] of Object.entries(style)) {
      selection.style(key, value2);
    }
  }
  var ResizableMask = createElement((g) => {
    const _a = g.attributes, { x: x3, y: y3, width, height, class: className2, renders = {}, handleSize: size2 = 10, document: document2 } = _a, style = __rest82(_a, ["x", "y", "width", "height", "class", "renders", "handleSize", "document"]);
    if (!document2 || width === void 0 || height === void 0 || x3 === void 0 || y3 === void 0)
      return;
    const half = size2 / 2;
    const renderRect = (g2, options, document3) => {
      if (!g2.handle) {
        g2.handle = document3.createElement("rect");
        g2.append(g2.handle);
      }
      const { handle } = g2;
      handle.attr(options);
      return handle;
    };
    const _b = subObject(omitPrefixObject(style, "handleNW", "handleNE"), "handleN"), { render: handleNRender = renderRect } = _b, handleNStyle = __rest82(_b, ["render"]);
    const _c = subObject(style, "handleE"), { render: handleERender = renderRect } = _c, handleEStyle = __rest82(_c, ["render"]);
    const _d = subObject(omitPrefixObject(style, "handleSE", "handleSW"), "handleS"), { render: handleSRender = renderRect } = _d, handleSStyle = __rest82(_d, ["render"]);
    const _e = subObject(style, "handleW"), { render: handleWRender = renderRect } = _e, handleWStyle = __rest82(_e, ["render"]);
    const _f = subObject(style, "handleNW"), { render: handleNWRender = renderRect } = _f, handleNWStyle = __rest82(_f, ["render"]);
    const _g = subObject(style, "handleNE"), { render: handleNERender = renderRect } = _g, handleNEStyle = __rest82(_g, ["render"]);
    const _h = subObject(style, "handleSE"), { render: handleSERender = renderRect } = _h, handleSEStyle = __rest82(_h, ["render"]);
    const _j = subObject(style, "handleSW"), { render: handleSWRender = renderRect } = _j, handleSWStyle = __rest82(_j, ["render"]);
    const renderHandle = (g2, renderNode) => {
      const { id: id4 } = g2;
      const handle = renderNode(g2, g2.attributes, document2);
      handle.id = id4;
      handle.style.draggable = true;
    };
    const appendHandle = (handleRender) => {
      return () => {
        const Node6 = createElement((g2) => renderHandle(g2, handleRender));
        return new Node6({});
      };
    };
    const container = select(g).attr("className", className2).style("transform", `translate(${x3}, ${y3})`).style("draggable", true);
    container.maybeAppend("selection", "rect").style("draggable", true).style("fill", "transparent").call(applyStyle3, Object.assign(Object.assign({
      width,
      height
    }, omitPrefixObject(style, "handle")), { transform: void 0 }));
    container.maybeAppend("handle-n", appendHandle(handleNRender)).style("x", half).style("y", -half).style("width", width - size2).style("height", size2).style("fill", "transparent").call(applyStyle3, handleNStyle);
    container.maybeAppend("handle-e", appendHandle(handleERender)).style("x", width - half).style("y", half).style("width", size2).style("height", height - size2).style("fill", "transparent").call(applyStyle3, handleEStyle);
    container.maybeAppend("handle-s", appendHandle(handleSRender)).style("x", half).style("y", height - half).style("width", width - size2).style("height", size2).style("fill", "transparent").call(applyStyle3, handleSStyle);
    container.maybeAppend("handle-w", appendHandle(handleWRender)).style("x", -half).style("y", half).style("width", size2).style("height", height - size2).style("fill", "transparent").call(applyStyle3, handleWStyle);
    container.maybeAppend("handle-nw", appendHandle(handleNWRender)).style("x", -half).style("y", -half).style("width", size2).style("height", size2).style("fill", "transparent").call(applyStyle3, handleNWStyle);
    container.maybeAppend("handle-ne", appendHandle(handleNERender)).style("x", width - half).style("y", -half).style("width", size2).style("height", size2).style("fill", "transparent").call(applyStyle3, handleNEStyle);
    container.maybeAppend("handle-se", appendHandle(handleSERender)).style("x", width - half).style("y", height - half).style("width", size2).style("height", size2).style("fill", "transparent").call(applyStyle3, handleSEStyle);
    container.maybeAppend("handle-sw", appendHandle(handleSWRender)).style("x", -half).style("y", height - half).style("width", size2).style("height", size2).style("fill", "transparent").call(applyStyle3, handleSWStyle);
  });
  function brush(root2, _a) {
    var { brushed = () => {
    }, brushended = () => {
    }, brushcreated = () => {
    }, brushstarted = () => {
    }, brushupdated = () => {
    }, extent: extent2 = bboxOf2(root2), brushRegion = (x3, y3, x12, y12, extent3) => [x3, y3, x12, y12], reverse = false, fill = "#777", fillOpacity = "0.3", stroke: stroke2 = "#fff", selectedHandles = [
      "handle-n",
      "handle-e",
      "handle-s",
      "handle-w",
      "handle-nw",
      "handle-ne",
      "handle-se",
      "handle-sw"
    ] } = _a, style = __rest82(_a, ["brushed", "brushended", "brushcreated", "brushstarted", "brushupdated", "extent", "brushRegion", "reverse", "fill", "fillOpacity", "stroke", "selectedHandles"]);
    let start2 = null;
    let end = null;
    let moveStart = null;
    let mask = null;
    let background = null;
    let creating = false;
    const [originX, originY, width, height] = extent2;
    setCursor(root2, "crosshair");
    root2.style.draggable = true;
    const initMask = (x3, y3, event) => {
      brushstarted(event);
      if (mask)
        mask.remove();
      if (background)
        background.remove();
      start2 = [x3, y3];
      if (reverse)
        return initReverseMask();
      initNormalMask();
    };
    const initReverseMask = () => {
      background = new Path2({
        style: Object.assign(Object.assign({}, style), {
          fill,
          fillOpacity,
          stroke: stroke2,
          pointerEvents: "none"
        })
      });
      mask = new ResizableMask({
        // @ts-ignore
        style: {
          x: 0,
          y: 0,
          width: 0,
          height: 0,
          draggable: true,
          document: root2.ownerDocument
        },
        className: "mask"
      });
      root2.appendChild(background);
      root2.appendChild(mask);
    };
    const initNormalMask = () => {
      mask = new ResizableMask({
        // @ts-ignore
        style: Object.assign(Object.assign({ document: root2.ownerDocument, x: 0, y: 0 }, style), {
          fill,
          fillOpacity,
          stroke: stroke2,
          draggable: true
        }),
        className: "mask"
      });
      root2.appendChild(mask);
    };
    const removeMask = (emit = true) => {
      if (mask)
        mask.remove();
      if (background)
        background.remove();
      start2 = null;
      end = null;
      moveStart = null;
      creating = false;
      mask = null;
      background = null;
      brushended(emit);
    };
    const updateMask = (start3, end2, emit = true) => {
      const [x3, y3, x12, y12] = normalizeBounds(start3[0], start3[1], end2[0], end2[1], extent2);
      const [fx, fy, fx1, fy1] = brushRegion(x3, y3, x12, y12, extent2);
      if (reverse)
        updateReverseMask(fx, fy, fx1, fy1);
      else
        updateNormalMask(fx, fy, fx1, fy1);
      brushed(fx, fy, fx1, fy1, emit);
      return [fx, fy, fx1, fy1];
    };
    const updateNormalMask = (x3, y3, x12, y12) => {
      mask.style.x = x3;
      mask.style.y = y3;
      mask.style.width = x12 - x3;
      mask.style.height = y12 - y3;
    };
    const updateReverseMask = (x3, y3, x12, y12) => {
      background.style.d = `
      M${originX},${originY}L${width},${originY}L${width},${height}L${originX},${height}Z
      M${x3},${y3}L${x3},${y12}L${x12},${y12}L${x12},${y3}Z
    `;
      mask.style.x = x3;
      mask.style.y = y3;
      mask.style.width = x12 - x3;
      mask.style.height = y12 - y3;
    };
    const moveMask = (current) => {
      const clip = (dt, start3, end2, min10, max10) => {
        if (dt + start3 < min10)
          return min10 - start3;
        if (dt + end2 > max10)
          return max10 - end2;
        return dt;
      };
      const dx = current[0] - moveStart[0];
      const dy = current[1] - moveStart[1];
      const dx1 = clip(dx, start2[0], end[0], originX, width);
      const dy1 = clip(dy, start2[1], end[1], originY, height);
      const currentStart = [start2[0] + dx1, start2[1] + dy1];
      const currentEnd = [end[0] + dx1, end[1] + dy1];
      updateMask(currentStart, currentEnd);
    };
    const handles = {
      "handle-n": { vector: [0, 1, 0, 0], cursor: "ns-resize" },
      "handle-e": { vector: [0, 0, 1, 0], cursor: "ew-resize" },
      "handle-s": { vector: [0, 0, 0, 1], cursor: "ns-resize" },
      "handle-w": { vector: [1, 0, 0, 0], cursor: "ew-resize" },
      "handle-nw": { vector: [1, 1, 0, 0], cursor: "nwse-resize" },
      "handle-ne": { vector: [0, 1, 1, 0], cursor: "nesw-resize" },
      "handle-se": { vector: [0, 0, 1, 1], cursor: "nwse-resize" },
      "handle-sw": { vector: [1, 0, 0, 1], cursor: "nesw-resize" }
    };
    const isMask = (target) => {
      return isSelection(target) || isHandle(target);
    };
    const isHandle = (target) => {
      const { id: id4 } = target;
      if (selectedHandles.indexOf(id4) === -1)
        return false;
      return new Set(Object.keys(handles)).has(id4);
    };
    const isSelection = (target) => {
      return target === mask.getElementById("selection");
    };
    const dragstart = (event) => {
      const { target } = event;
      const [offsetX, offsetY] = brushMousePosition(root2, event);
      if (!mask || !isMask(target)) {
        initMask(offsetX, offsetY, event);
        creating = true;
        return;
      }
      if (isMask(target)) {
        moveStart = [offsetX, offsetY];
      }
    };
    const drag = (event) => {
      const { target } = event;
      const mouse = brushMousePosition(root2, event);
      if (!start2)
        return;
      if (!moveStart)
        return updateMask(start2, mouse);
      if (isSelection(target))
        return moveMask(mouse);
      const [dx, dy] = [mouse[0] - moveStart[0], mouse[1] - moveStart[1]];
      const { id: id4 } = target;
      if (handles[id4]) {
        const [sx, sy, ex, ey] = handles[id4].vector;
        return updateMask([start2[0] + dx * sx, start2[1] + dy * sy], [end[0] + dx * ex, end[1] + dy * ey]);
      }
    };
    const dragend = (event) => {
      if (moveStart) {
        moveStart = null;
        const { x: x3, y: y3, width: width2, height: height2 } = mask.style;
        start2 = [x3, y3];
        end = [x3 + width2, y3 + height2];
        brushupdated(x3, y3, x3 + width2, y3 + height2, event);
        return;
      }
      end = brushMousePosition(root2, event);
      const [fx, fy, fx1, fy1] = updateMask(start2, end);
      creating = false;
      brushcreated(fx, fy, fx1, fy1, event);
    };
    const click = (event) => {
      const { target } = event;
      if (mask && !isMask(target))
        removeMask();
    };
    const pointermove = (event) => {
      const { target } = event;
      if (!mask || !isMask(target) || creating)
        setCursor(root2, "crosshair");
      else if (isSelection(target))
        setCursor(root2, "move");
      else if (isHandle(target))
        setCursor(root2, handles[target.id].cursor);
    };
    const pointerleave = () => {
      setCursor(root2, "default");
    };
    root2.addEventListener("dragstart", dragstart);
    root2.addEventListener("drag", drag);
    root2.addEventListener("dragend", dragend);
    root2.addEventListener("click", click);
    root2.addEventListener("pointermove", pointermove);
    root2.addEventListener("pointerleave", pointerleave);
    return {
      mask,
      move(x3, y3, x12, y12, emit = true) {
        if (!mask)
          initMask(x3, y3, {});
        start2 = [x3, y3];
        end = [x12, y12];
        updateMask([x3, y3], [x12, y12], emit);
      },
      remove(emit = true) {
        if (mask)
          removeMask(emit);
      },
      destroy() {
        if (mask)
          removeMask(false);
        setCursor(root2, "default");
        root2.removeEventListener("dragstart", dragstart);
        root2.removeEventListener("drag", drag);
        root2.removeEventListener("dragend", dragend);
        root2.removeEventListener("click", click);
        root2.removeEventListener("pointermove", pointermove);
        root2.removeEventListener("pointerleave", pointerleave);
      }
    };
  }
  function selectSiblingViews(target, viewInstances, brushKey) {
    return viewInstances.filter((d2) => {
      if (d2 === target)
        return false;
      const { interaction = {} } = d2.options;
      return Object.values(interaction).find((d3) => d3.brushKey === brushKey);
    });
  }
  function selectSiblingContainers(target, viewInstances, brushKey) {
    return selectSiblingViews(target, viewInstances, brushKey).map((d2) => selectPlotArea(d2.container));
  }
  function selectSiblingOptions(target, viewInstances, brushKey) {
    return selectSiblingViews(target, viewInstances, brushKey).map((d2) => d2.options);
  }
  function brushHighlight(root2, _a) {
    var { elements: elementof, selectedHandles, siblings: siblingsof = (root3) => [], datum, brushRegion, extent: optionalExtent, reverse, scale: scale9, coordinate, series = false, key = (d2) => d2, bboxOf: bboxOf3 = (root3) => {
      const { x: x3, y: y3, width, height } = root3.style;
      return { x: x3, y: y3, width, height };
    }, state = {}, emitter } = _a, rest = __rest82(_a, ["elements", "selectedHandles", "siblings", "datum", "brushRegion", "extent", "reverse", "scale", "coordinate", "series", "key", "bboxOf", "state", "emitter"]);
    const elements = elementof(root2);
    const siblings = siblingsof(root2);
    const siblingElements = siblings.flatMap(elementof);
    const valueof2 = createValueof(elements, datum);
    const brushStyle = subObject(rest, "mask");
    const { setState, removeState } = useState(state, valueof2);
    const clonedElement = /* @__PURE__ */ new Map();
    const { width: rootWidth, height: rootHeight, x: ordinalX = 0, y: ordinalY = 0 } = bboxOf3(root2);
    const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
    const brushended = () => {
      for (const element of [...elements, ...siblingElements]) {
        removeState(element, "active", "inactive");
      }
    };
    const brushed = (x3, y3, x12, y12) => {
      var _a2;
      for (const sibling of siblings)
        (_a2 = sibling.brush) === null || _a2 === void 0 ? void 0 : _a2.remove();
      const keys2 = /* @__PURE__ */ new Set();
      for (const element of elements) {
        const { min: min10, max: max10 } = element.getLocalBounds();
        const [ex, ey] = min10;
        const [ex1, ey1] = max10;
        if (!intersect3([ex, ey, ex1, ey1], [x3, y3, x12, y12])) {
          setState(element, "inactive");
        } else {
          setState(element, "active");
          keys2.add(key(element));
        }
      }
      for (const element of siblingElements) {
        if (keys2.has(key(element)))
          setState(element, "active");
        else
          setState(element, "inactive");
      }
    };
    const seriesBrushend = () => {
      for (const element of elements)
        removeState(element, "inactive");
      for (const cloned of clonedElement.values())
        cloned.remove();
      clonedElement.clear();
    };
    const seriesBrushed = (x3, y3, x12, y12) => {
      const clone11 = (element) => {
        const cloned = element.cloneNode();
        cloned.__data__ = element.__data__;
        element.parentNode.appendChild(cloned);
        clonedElement.set(element, cloned);
        return cloned;
      };
      const clipPath = new Rect({
        style: {
          x: x3 + ordinalX,
          y: y3 + ordinalY,
          width: x12 - x3,
          height: y12 - y3
        }
      });
      root2.appendChild(clipPath);
      for (const element of elements) {
        const cloned = clonedElement.get(element) || clone11(element);
        cloned.style.clipPath = clipPath;
        setState(element, "inactive");
        setState(cloned, "active");
      }
    };
    const brushHandler = brush(root2, Object.assign(Object.assign({}, brushStyle), {
      extent: extent2,
      brushRegion,
      reverse,
      selectedHandles,
      brushended: (emit) => {
        const handler = series ? seriesBrushend : brushended;
        if (emit) {
          emitter.emit("brush:remove", { nativeEvent: true });
        }
        handler();
      },
      brushed: (x3, y3, x12, y12, emit) => {
        const selection = selectionOf(x3, y3, x12, y12, scale9, coordinate);
        if (emit) {
          emitter.emit("brush:highlight", {
            nativeEvent: true,
            data: { selection }
          });
        }
        const handler = series ? seriesBrushed : brushed;
        handler(x3, y3, x12, y12);
      },
      brushcreated: (x3, y3, x12, y12, event) => {
        const selection = selectionOf(x3, y3, x12, y12, scale9, coordinate);
        emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
      },
      brushupdated: (x3, y3, x12, y12, event) => {
        const selection = selectionOf(x3, y3, x12, y12, scale9, coordinate);
        emitter.emit("brush:end", Object.assign(Object.assign({}, event), { nativeEvent: true, data: { selection } }));
      },
      brushstarted: (e3) => {
        emitter.emit("brush:start", e3);
      }
    }));
    const onHighlight = ({ nativeEvent, data: data2 }) => {
      if (nativeEvent)
        return;
      const { selection } = data2;
      const [x3, y3, x12, y12] = pixelsOf(selection, scale9, coordinate);
      brushHandler.move(x3, y3, x12, y12, false);
    };
    emitter.on("brush:highlight", onHighlight);
    const onRemove = ({ nativeEvent } = {}) => {
      if (nativeEvent)
        return;
      brushHandler.remove(false);
    };
    emitter.on("brush:remove", onRemove);
    const preBrushDestroy = brushHandler.destroy.bind(brushHandler);
    brushHandler.destroy = () => {
      emitter.off("brush:highlight", onHighlight);
      emitter.off("brush:remove", onRemove);
      preBrushDestroy();
    };
    return brushHandler;
  }
  function BrushHighlight(_a) {
    var { facet, brushKey } = _a, rest = __rest82(_a, ["facet", "brushKey"]);
    return (target, viewInstances, emitter) => {
      const { container, view, options } = target;
      const plotArea = selectPlotArea(container);
      const defaultOptions2 = {
        maskFill: "#777",
        maskFillOpacity: "0.3",
        maskStroke: "#fff",
        reverse: false
      };
      const defaultStates = ["active", ["inactive", { opacity: 0.5 }]];
      const { scale: scale9, coordinate } = view;
      if (facet) {
        const bbox = plotArea.getBounds();
        const x3 = bbox.min[0];
        const y3 = bbox.min[1];
        const x12 = bbox.max[0];
        const y12 = bbox.max[1];
        return brushHighlight(plotArea.parentNode.parentNode, Object.assign(Object.assign({
          elements: () => selectFacetG2Elements(target, viewInstances),
          datum: createDatumof(selectFacetViews(target, viewInstances).map((d2) => d2.view)),
          brushRegion: (x4, y4, x13, y13) => [x4, y4, x13, y13],
          extent: [x3, y3, x12, y12],
          state: mergeState(selectFacetViews(target, viewInstances).map((d2) => d2.options), defaultStates),
          emitter,
          scale: scale9,
          coordinate,
          selectedHandles: void 0
        }, defaultOptions2), rest));
      }
      const brush2 = brushHighlight(plotArea, Object.assign(Object.assign({
        elements: selectG2Elements,
        key: (element) => element.__data__.key,
        siblings: () => selectSiblingContainers(target, viewInstances, brushKey),
        datum: createDatumof([
          view,
          ...selectSiblingViews(target, viewInstances, brushKey).map((d2) => d2.view)
        ]),
        brushRegion: (x3, y3, x12, y12) => [x3, y3, x12, y12],
        extent: void 0,
        state: mergeState([options, ...selectSiblingOptions(target, viewInstances, brushKey)], defaultStates),
        emitter,
        scale: scale9,
        coordinate,
        selectedHandles: void 0
      }, defaultOptions2), rest));
      plotArea.brush = brush2;
      return () => brush2.destroy();
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/brushXHighlight.js
  function brushXRegion(x3, y3, x12, y12, extent2) {
    const [, minY, , maxY2] = extent2;
    return [x3, minY, x12, maxY2];
  }
  function BrushXHighlight(options) {
    return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushXRegion, selectedHandles: ["handle-e", "handle-w"] }));
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/brushYHighlight.js
  function brushYRegion(x3, y3, x12, y12, extent2) {
    const [minX, , maxX] = extent2;
    return [minX, y3, maxX, y12];
  }
  function BrushYHighlight(options) {
    return BrushHighlight(Object.assign(Object.assign({}, options), { brushRegion: brushYRegion, selectedHandles: ["handle-n", "handle-s"] }));
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/brushAxisHighlight.js
  var __rest83 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var AXIS_CLASS_NAME = "axis";
  var AXIS_LINE_CLASS_NAME = "axis-line";
  var AXIS_MAIN_CLASS_NAME = "axis-main-group";
  var AXIS_HOT_AREA_CLASS_NAME = "axis-hot-area";
  function axesOf(container) {
    return container.getElementsByClassName(AXIS_CLASS_NAME);
  }
  function lineOf(axis) {
    return axis.getElementsByClassName(AXIS_LINE_CLASS_NAME)[0];
  }
  function mainGroupOf(axis) {
    return axis.getElementsByClassName(AXIS_MAIN_CLASS_NAME)[0];
  }
  function boundsOfAxis(axis) {
    return mainGroupOf(axis).getLocalBounds();
  }
  function verticalBrush(axis, _a) {
    var { cross: cross6, offsetX, offsetY } = _a, style = __rest83(_a, ["cross", "offsetX", "offsetY"]);
    const bounds = boundsOfAxis(axis);
    const axisLine = lineOf(axis);
    const [lineX] = axisLine.getLocalBounds().min;
    const [minX, minY] = bounds.min;
    const [maxX, maxY2] = bounds.max;
    const size2 = (maxX - minX) * 2;
    return {
      brushRegion: brushYRegion,
      hotZone: new Rect({
        className: AXIS_HOT_AREA_CLASS_NAME,
        style: Object.assign({
          // If it is not cross, draw brush in both side of axisLine,
          // otherwise the draw brush within bounds area.
          width: cross6 ? size2 / 2 : size2,
          transform: `translate(${(cross6 ? minX : lineX - size2 / 2).toFixed(2)}, ${minY})`,
          height: maxY2 - minY
        }, style)
      }),
      extent: cross6 ? (
        // If it is cross, the x range is ignored.
        (x3, y3, x12, y12) => [-Infinity, y3, Infinity, y12]
      ) : (x3, y3, x12, y12) => [
        Math.floor(minX - offsetX),
        y3,
        Math.ceil(maxX - offsetX),
        y12
      ]
    };
  }
  function horizontalBrush(axis, _a) {
    var { offsetY, offsetX, cross: cross6 = false } = _a, style = __rest83(_a, ["offsetY", "offsetX", "cross"]);
    const bounds = boundsOfAxis(axis);
    const axisLine = lineOf(axis);
    const [, lineY] = axisLine.getLocalBounds().min;
    const [minX, minY] = bounds.min;
    const [maxX, maxY2] = bounds.max;
    const size2 = maxY2 - minY;
    return {
      brushRegion: brushXRegion,
      hotZone: new Rect({
        className: AXIS_HOT_AREA_CLASS_NAME,
        style: Object.assign({
          width: maxX - minX,
          // If it is not cross, draw brush in both side of axisLine,
          // otherwise the draw brush within bounds area.
          height: cross6 ? size2 : size2 * 2,
          transform: `translate(${minX}, ${cross6 ? minY : lineY - size2})`
        }, style)
      }),
      extent: cross6 ? (
        // If it is cross, the y range is ignored.
        (x3, y3, x12, y12) => [x3, -Infinity, x12, Infinity]
      ) : (x3, y3, x12, y12) => [
        x3,
        Math.floor(minY - offsetY),
        x12,
        Math.ceil(maxY2 - offsetY)
      ]
    };
  }
  function brushAxisHighlight(root2, _a) {
    var {
      axes: axesOf2,
      // given root, return axes
      elements: elementsOf,
      // given root, return elements
      points: pointsOf,
      // given shape, return control points
      horizontal: isHorizontal3,
      // given axis, return direction
      datum,
      // given shape, return datum
      offsetY,
      // offsetY for shape area
      offsetX,
      // offsetX for shape area
      reverse = false,
      state = {},
      emitter,
      coordinate
    } = _a, rest = __rest83(_a, ["axes", "elements", "points", "horizontal", "datum", "offsetY", "offsetX", "reverse", "state", "emitter", "coordinate"]);
    const elements = elementsOf(root2);
    const axes = axesOf2(root2);
    const valueof2 = createValueof(elements, datum);
    const { setState, removeState } = useState(state, valueof2);
    const axisExtent = /* @__PURE__ */ new Map();
    const brushStyle = subObject(rest, "mask");
    const brushed = (points) => Array.from(axisExtent.values()).every(([x3, y3, x12, y12]) => points.some(([x05, y05]) => {
      return x05 >= x3 && x05 <= x12 && y05 >= y3 && y05 <= y12;
    }));
    const scales = axes.map((d2) => d2.attributes.scale);
    const extentOf2 = (D2) => D2.length > 2 ? [D2[0], D2[D2.length - 1]] : D2;
    const indexDomain = /* @__PURE__ */ new Map();
    const initIndexDomain = () => {
      indexDomain.clear();
      for (let i = 0; i < axes.length; i++) {
        const scale9 = scales[i];
        const { domain } = scale9.getOptions();
        indexDomain.set(i, extentOf2(domain));
      }
    };
    initIndexDomain();
    const updateElement = (i, emit) => {
      const selectedElements = [];
      for (const element of elements) {
        const points = pointsOf(element);
        if (brushed(points)) {
          setState(element, "active");
          selectedElements.push(element);
        } else
          setState(element, "inactive");
      }
      indexDomain.set(i, selectionOf2(selectedElements, i));
      if (!emit)
        return;
      const selection = () => {
        if (!cross6)
          return Array.from(indexDomain.values());
        const S = [];
        for (const [index4, domain] of indexDomain) {
          const scale9 = scales[index4];
          const { name: name2 } = scale9.getOptions();
          if (name2 === "x")
            S[0] = domain;
          else
            S[1] = domain;
        }
        return S;
      };
      emitter.emit("brushAxis:highlight", {
        nativeEvent: true,
        data: {
          selection: selection()
        }
      });
    };
    const clearElement = (emit) => {
      for (const element of elements)
        removeState(element, "active", "inactive");
      initIndexDomain();
      if (!emit)
        return;
      emitter.emit("brushAxis:remove", { nativeEvent: true });
    };
    const selectionOf2 = (selected, i) => {
      const scale9 = scales[i];
      const { name: name2 } = scale9.getOptions();
      const domain = selected.map((d2) => {
        const data2 = d2.__data__;
        return scale9.invert(data2[name2]);
      });
      return extentOf2(domainOf3(scale9, domain));
    };
    const cross6 = axes.some(isHorizontal3) && axes.some((d2) => !isHorizontal3(d2));
    const handlers = [];
    for (let i = 0; i < axes.length; i++) {
      const axis = axes[i];
      const createBrush = isHorizontal3(axis) ? horizontalBrush : verticalBrush;
      const { hotZone, brushRegion, extent: extent2 } = createBrush(axis, {
        offsetY,
        offsetX,
        cross: cross6,
        zIndex: 999,
        fill: "transparent"
        // Make it interactive.
      });
      axis.parentNode.appendChild(hotZone);
      const brushHandler = brush(hotZone, Object.assign(Object.assign({}, brushStyle), {
        reverse,
        brushRegion,
        brushended(emit) {
          axisExtent.delete(axis);
          if (Array.from(axisExtent.entries()).length === 0)
            clearElement(emit);
          else
            updateElement(i, emit);
        },
        brushed(x3, y3, x12, y12, emit) {
          axisExtent.set(axis, extent2(x3, y3, x12, y12));
          updateElement(i, emit);
        }
      }));
      handlers.push(brushHandler);
    }
    const onRemove = (event = {}) => {
      const { nativeEvent } = event;
      if (nativeEvent)
        return;
      handlers.forEach((d2) => d2.remove(false));
    };
    const rangeOf4 = (domain, scale9, axis) => {
      const [d0, d1] = domain;
      const maybeStep = (scale10) => scale10.getStep ? scale10.getStep() : 0;
      const x3 = abstractOf2(d0, scale9, axis);
      const x12 = abstractOf2(d1, scale9, axis) + maybeStep(scale9);
      if (isHorizontal3(axis))
        return [x3, -Infinity, x12, Infinity];
      return [-Infinity, x3, Infinity, x12];
    };
    const abstractOf2 = (x3, scale9, axis) => {
      const { height, width } = coordinate.getOptions();
      const scale1 = scale9.clone();
      if (isHorizontal3(axis))
        scale1.update({ range: [0, width] });
      else
        scale1.update({ range: [height, 0] });
      return scale1.map(x3);
    };
    const onHighlight = (event) => {
      const { nativeEvent } = event;
      if (nativeEvent)
        return;
      const { selection } = event.data;
      for (let i = 0; i < handlers.length; i++) {
        const domain = selection[i];
        const handler = handlers[i];
        const axis = axes[i];
        if (domain) {
          const scale9 = scales[i];
          handler.move(...rangeOf4(domain, scale9, axis), false);
        } else {
          handler.remove(false);
        }
      }
    };
    emitter.on("brushAxis:remove", onRemove);
    emitter.on("brushAxis:highlight", onHighlight);
    return () => {
      handlers.forEach((d2) => d2.destroy());
      emitter.off("brushAxis:remove", onRemove);
      emitter.off("brushAxis:highlight", onHighlight);
    };
  }
  function BrushAxisHighlight(options) {
    return (target, _2, emitter) => {
      const { container, view, options: viewOptions } = target;
      const plotArea = selectPlotArea(container);
      const { x: x05, y: y05 } = plotArea.getBBox();
      const { coordinate } = view;
      return brushAxisHighlight(container, Object.assign({
        elements: selectG2Elements,
        axes: axesOf,
        offsetY: y05,
        offsetX: x05,
        points: (element) => element.__data__.points,
        horizontal: (axis) => {
          const { startPos: [sx, sy], endPos: [ex, ey] } = axis.attributes;
          return sx !== ex && sy === ey;
        },
        datum: createDatumof(view),
        state: mergeState(viewOptions, [
          "active",
          ["inactive", { opacity: 0.5 }]
        ]),
        coordinate,
        emitter
      }, options));
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/brushFilter.js
  var __awaiter9 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest84 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function dblclick(interval2 = 300) {
    let preTimeStamp = null;
    return (e3) => {
      const { timeStamp } = e3;
      if (preTimeStamp !== null && timeStamp - preTimeStamp < interval2) {
        preTimeStamp = timeStamp;
        return true;
      }
      preTimeStamp = timeStamp;
      return false;
    };
  }
  function brushFilter(root2, _a) {
    var { filter: filter2, reset, brushRegion, extent: optionalExtent, reverse, emitter, scale: scale9, coordinate, selection, series = false } = _a, rest = __rest84(_a, ["filter", "reset", "brushRegion", "extent", "reverse", "emitter", "scale", "coordinate", "selection", "series"]);
    const brushStyle = subObject(rest, "mask");
    const { width: rootWidth, height: rootHeight } = root2.getBBox();
    const extent2 = optionalExtent ? optionalExtent : [0, 0, rootWidth, rootHeight];
    const isDblclick = dblclick();
    const brush2 = brush(root2, Object.assign(Object.assign({}, brushStyle), {
      extent: extent2,
      brushRegion,
      reverse,
      brushcreated
    }));
    root2.addEventListener("click", click);
    function brushcreated(x3, y3, x12, y12, event) {
      event.nativeEvent = true;
      filter2(selection(x3, y3, x12, y12), event);
      brush2.remove();
    }
    function click(e3) {
      if (isDblclick(e3)) {
        e3.nativeEvent = true;
        reset(e3);
      }
    }
    const onFilter = ({ nativeEvent, data: data2 }) => {
      if (nativeEvent)
        return;
      const { selection: selection2 } = data2;
      filter2(selection2, { nativeEvent: false });
    };
    emitter.on("brush:filter", onFilter);
    return () => {
      brush2.destroy();
      emitter.off("brush:filter", onFilter);
      root2.removeEventListener("click", click);
    };
  }
  function BrushFilter(_a) {
    var { hideX = true, hideY = true } = _a, rest = __rest84(_a, ["hideX", "hideY"]);
    return (target, viewInstances, emitter) => {
      const { container, view, options: viewOptions, update, setState } = target;
      const plotArea = selectPlotArea(container);
      const defaultOptions2 = {
        maskFill: "#777",
        maskFillOpacity: "0.3",
        maskStroke: "#fff",
        unhighlightedOpacity: 0.5,
        reverse: false
      };
      let filtered = false;
      let filtering = false;
      let newView = view;
      const { scale: scale9, coordinate } = view;
      return brushFilter(plotArea, Object.assign(Object.assign({
        brushRegion: (x3, y3, x12, y12) => [x3, y3, x12, y12],
        selection: (x3, y3, x12, y12) => {
          const { scale: scale10, coordinate: coordinate2 } = newView;
          return selectionOf(x3, y3, x12, y12, scale10, coordinate2);
        },
        filter: (selection, event) => __awaiter9(this, void 0, void 0, function* () {
          if (filtering)
            return;
          filtering = true;
          const [domainX, domainY] = selection;
          setState("brushFilter", (options) => {
            const { marks } = options;
            const newMarks = marks.map((mark) => deep_mix_default({
              // Hide label to keep smooth transition.
              axis: Object.assign(Object.assign({}, hideX && { x: { transform: [{ type: "hide" }] } }), hideY && { y: { transform: [{ type: "hide" }] } })
            }, mark, {
              // Set nice to false to avoid modify domain.
              scale: {
                x: { domain: domainX, nice: false },
                y: { domain: domainY, nice: false }
              }
            }));
            return Object.assign(Object.assign({}, viewOptions), { marks: newMarks, clip: true });
          });
          emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
          const newState = yield update();
          newView = newState.view;
          filtering = false;
          filtered = true;
        }),
        reset: (event) => {
          if (filtering || !filtered)
            return;
          const { scale: scale10 } = view;
          const { x: scaleX, y: scaleY } = scale10;
          const domainX = scaleX.getOptions().domain;
          const domainY = scaleY.getOptions().domain;
          emitter.emit("brush:filter", Object.assign(Object.assign({}, event), { data: { selection: [domainX, domainY] } }));
          filtered = false;
          newView = view;
          setState("brushFilter");
          update();
        },
        extent: void 0,
        emitter,
        scale: scale9,
        coordinate
      }, defaultOptions2), rest));
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/brushXFilter.js
  function BrushXFilter(options) {
    return BrushFilter(Object.assign(Object.assign({ hideX: true }, options), { brushRegion: brushXRegion }));
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/brushYFilter.js
  function BrushYFilter(options) {
    return BrushFilter(Object.assign(Object.assign({ hideY: true }, options), { brushRegion: brushYRegion }));
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/sliderFilter.js
  var __awaiter10 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var SLIDER_CLASS_NAME = "slider";
  function filterDataByDomain(options, scaleOptions, prefix, hasState = false, channel0 = "x", channel1 = "y") {
    const { marks } = options;
    const newMarks = marks.map((mark) => {
      var _a, _b;
      return deep_mix_default({
        // Hide label to keep smooth transition.
        axis: {
          x: { transform: [{ type: "hide" }] },
          y: { transform: [{ type: "hide" }] }
        }
      }, mark, {
        scale: scaleOptions,
        // Don't rerender sliders.
        [prefix]: Object.assign(Object.assign({}, ((_a = mark[prefix]) === null || _a === void 0 ? void 0 : _a[channel0]) && {
          [channel0]: Object.assign({ preserve: true }, hasState && { ratio: null })
        }), ((_b = mark[prefix]) === null || _b === void 0 ? void 0 : _b[channel1]) && {
          [channel1]: { preserve: true }
        }),
        animate: false
      });
    });
    return Object.assign(Object.assign({}, options), { marks: newMarks, clip: true, animate: false });
  }
  function abstractValue(values, scale9, reverse) {
    const [x3, x12] = values;
    const v = reverse ? (d2) => 1 - d2 : (d2) => d2;
    const d0 = invert4(scale9, v(x3), true);
    const d1 = invert4(scale9, v(x12), false);
    return domainOf3(scale9, [d0, d1]);
  }
  function extentOf(domain) {
    return [domain[0], domain[domain.length - 1]];
  }
  function SliderFilter({ initDomain = {}, className: className2 = SLIDER_CLASS_NAME, prefix = "slider", setValue = (component, values) => component.setValues(values), hasState = false, wait = 50, leading = true, trailing = false, getInitValues = (slider) => {
    var _a;
    const values = (_a = slider === null || slider === void 0 ? void 0 : slider.attributes) === null || _a === void 0 ? void 0 : _a.values;
    if (values[0] !== 0 || values[1] !== 1)
      return values;
  } }) {
    return (context, _2, emitter) => {
      const { container, view, update, setState } = context;
      const sliders = container.getElementsByClassName(className2);
      if (!sliders.length)
        return () => {
        };
      let filtering = false;
      const { scale: scale9, coordinate, layout } = view;
      const { paddingLeft, paddingTop, paddingBottom, paddingRight } = layout;
      const { x: scaleX, y: scaleY } = scale9;
      const transposed = isTranspose(coordinate);
      const channelOf = (orientation) => {
        const channel0 = orientation === "vertical" ? "y" : "x";
        const channel1 = orientation === "vertical" ? "x" : "y";
        if (transposed)
          return [channel1, channel0];
        return [channel0, channel1];
      };
      const sliderHandler = /* @__PURE__ */ new Map();
      const emitHandlers = /* @__PURE__ */ new Set();
      const channelDomain = {
        x: initDomain.x || scaleX.getOptions().domain,
        y: initDomain.y || scaleY.getOptions().domain
      };
      for (const slider of sliders) {
        const { orientation } = slider.attributes;
        const [channel0, channel1] = channelOf(orientation);
        const eventName = `${prefix}${upper_first_default(channel0)}:filter`;
        const isX = channel0 === "x";
        const { ratio: ratioX } = scaleX.getOptions();
        const { ratio: ratioY } = scaleY.getOptions();
        const domainsOf = (event) => {
          if (event.data) {
            const { selection } = event.data;
            const [X = extentOf(channelDomain.x), Y = extentOf(channelDomain.y)] = selection;
            return isX ? [domainOf3(scaleX, X, ratioX), domainOf3(scaleY, Y, ratioY)] : [domainOf3(scaleY, Y, ratioY), domainOf3(scaleX, X, ratioX)];
          }
          const { value: values2 } = event.detail;
          const scale0 = scale9[channel0];
          const domain0 = abstractValue(values2, scale0, transposed && orientation === "horizontal");
          const domain1 = channelDomain[channel1];
          return [domain0, domain1];
        };
        const onValueChange = throttle_default((event) => __awaiter10(this, void 0, void 0, function* () {
          const { initValue = false } = event;
          if (filtering && !initValue)
            return;
          filtering = true;
          const { nativeEvent = true } = event;
          const [domain0, domain1] = domainsOf(event);
          channelDomain[channel0] = domain0;
          channelDomain[channel1] = domain1;
          if (nativeEvent) {
            const X = isX ? domain0 : domain1;
            const Y = isX ? domain1 : domain0;
            emitter.emit(eventName, Object.assign(Object.assign({}, event), { nativeEvent, data: { selection: [extentOf(X), extentOf(Y)] } }));
          }
          setState(slider, (options) => Object.assign(Object.assign({}, filterDataByDomain(
            options,
            // Set nice to false to avoid modify domain.
            // Only update domain of current slider / scrollbar.
            { [channel0]: { domain: domain0, nice: false } },
            prefix,
            hasState,
            channel0,
            channel1
          )), {
            paddingLeft,
            paddingTop,
            paddingBottom,
            paddingRight
          }));
          yield update();
          filtering = false;
        }), wait, { leading, trailing });
        const emitHandler = (event) => {
          const { nativeEvent } = event;
          if (nativeEvent)
            return;
          const { data: data2 } = event;
          const { selection } = data2;
          const [X, Y] = selection;
          slider.dispatchEvent(new CustomEvent2("valuechange", {
            data: data2,
            nativeEvent: false
          }));
          const V = isX ? abstractOf(X, scaleX) : abstractOf(Y, scaleY);
          setValue(slider, V);
        };
        emitter.on(eventName, emitHandler);
        slider.addEventListener("valuechange", onValueChange);
        sliderHandler.set(slider, onValueChange);
        emitHandlers.add([eventName, emitHandler]);
        const values = getInitValues(slider);
        if (values) {
          slider.dispatchEvent(new CustomEvent2("valuechange", {
            detail: {
              value: values
            },
            nativeEvent: false,
            initValue: true
          }));
        }
      }
      return () => {
        for (const [slider, handler] of sliderHandler) {
          slider.removeEventListener("valuechange", handler);
        }
        for (const [name2, handler] of emitHandlers) {
          emitter.off(name2, handler);
        }
      };
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/scrollbarFilter.js
  var SCROLLBAR_CLASS_NAME = "g2-scrollbar";
  function ScrollbarFilter(options = {}) {
    return (context, _2, emitter) => {
      const { view, container } = context;
      const scrollbars = container.getElementsByClassName(SCROLLBAR_CLASS_NAME);
      if (!scrollbars.length)
        return () => {
        };
      const { scale: scale9 } = view;
      const { x: scaleX, y: scaleY } = scale9;
      const initDomain = {
        x: [...scaleX.getOptions().domain],
        y: [...scaleY.getOptions().domain]
      };
      scaleX.update({ domain: scaleX.getOptions().expectedDomain });
      scaleY.update({ domain: scaleY.getOptions().expectedDomain });
      const interaction = SliderFilter(Object.assign(Object.assign({}, options), { initDomain, className: SCROLLBAR_CLASS_NAME, prefix: "scrollbar", hasState: true, setValue: (component, values) => component.setValue(values[0]), getInitValues: (scrollbar) => {
        const values = scrollbar.slider.attributes.values;
        if (values[0] !== 0)
          return values;
      } }));
      return interaction(context, _2, emitter);
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/poptip.js
  var __rest85 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function dom(tag, children, style) {
    return `<${tag} style="${Object.entries(style).map(([key, value2]) => `${kebabCase(key)}:${value2}`).join(";")}">${children}</${tag}>`;
  }
  var defaultTipStyle = {
    backgroundColor: "rgba(0,0,0,0.75)",
    color: "#fff",
    width: "max-content",
    padding: "1px 4px",
    fontSize: "12px",
    borderRadius: "2.5px",
    boxShadow: "0 3px 6px -4px rgba(0,0,0,0.12), 0 6px 16px 0 rgba(0,0,0,0.08), 0 9px 28px 8px rgba(0,0,0,0.05)"
  };
  function isTipText(element) {
    if (element.nodeName !== "text")
      return false;
    if (element.isOverflowing())
      return true;
    return false;
  }
  function Poptip(_a) {
    var { offsetX = 8, offsetY = 8 } = _a, style = __rest85(_a, ["offsetX", "offsetY"]);
    return (context) => {
      const { container } = context;
      const [x05, y05] = container.getBounds().min;
      const tipStyle = subObject(style, "tip");
      const tips = /* @__PURE__ */ new Set();
      const pointerover = (e3) => {
        const { target } = e3;
        if (!isTipText(target)) {
          e3.stopPropagation();
          return;
        }
        const { offsetX: mouseX, offsetY: mouseY } = e3;
        const x3 = mouseX + offsetX - x05;
        const y3 = mouseY + offsetY - y05;
        if (target.tip) {
          target.tip.style.x = x3;
          target.tip.style.y = y3;
          return;
        }
        const { text } = target.style;
        const tipELement = new HTML({
          className: "poptip",
          style: {
            innerHTML: dom("div", text, Object.assign(Object.assign({}, defaultTipStyle), tipStyle)),
            x: x3,
            y: y3
          }
        });
        container.appendChild(tipELement);
        target.tip = tipELement;
        tips.add(tipELement);
      };
      const pointerout = (e3) => {
        const { target } = e3;
        if (!isTipText(target)) {
          e3.stopPropagation();
          return;
        }
        if (!target.tip)
          return;
        target.tip.remove();
        target.tip = null;
        tips.delete(target.tip);
      };
      container.addEventListener("pointerover", pointerover);
      container.addEventListener("pointerout", pointerout);
      return () => {
        container.removeEventListener("pointerover", pointerover);
        container.removeEventListener("pointerout", pointerout);
        tips.forEach((tip) => tip.remove());
      };
    };
  }
  Poptip.props = {
    reapplyWhenUpdate: true
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/treemapDrillDown.js
  var __awaiter11 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest86 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  function selectPlotArea2(root2) {
    return select(root2).select(`.${PLOT_CLASS_NAME}`).node();
  }
  var DEFAULT_BREADCRUMB_STYLE = {
    breadCrumbFill: "rgba(0, 0, 0, 0.85)",
    breadCrumbFontSize: 12,
    breadCrumbY: 12,
    activeFill: "rgba(0, 0, 0, 0.5)"
  };
  function TreemapDrillDown(drillDownOptions = {}) {
    const { originData = [], layout } = drillDownOptions, style = __rest86(drillDownOptions, ["originData", "layout"]);
    const breadCrumb = deep_mix_default({}, DEFAULT_BREADCRUMB_STYLE, style);
    const breadCrumbStyle = subObject(breadCrumb, "breadCrumb");
    const breadCrumbActiveStyle = subObject(breadCrumb, "active");
    return (context) => {
      const { update, setState, container, options } = context;
      const plotArea = selectPlotArea2(container);
      const mark = options.marks[0];
      const { state } = mark;
      const textGroup = new Group2();
      plotArea.appendChild(textGroup);
      const drillDownClick = (path2, depth) => __awaiter11(this, void 0, void 0, function* () {
        textGroup.removeChildren();
        if (depth) {
          let name2 = "";
          let y3 = breadCrumbStyle.y;
          let x3 = 0;
          const textPath = [];
          const maxWidth = plotArea.getBBox().width;
          const drillTexts = path2.map((text, index4) => {
            name2 = `${name2}${text}/`;
            textPath.push(text);
            const drillText = new Text({
              name: name2.replace(/\/$/, ""),
              style: Object.assign(Object.assign({
                text,
                x: x3,
                // @ts-ignore
                path: [...textPath],
                depth: index4
              }, breadCrumbStyle), { y: y3 })
            });
            textGroup.appendChild(drillText);
            x3 += drillText.getBBox().width;
            const textSeparator = new Text({
              style: Object.assign(Object.assign({ x: x3, text: " / " }, breadCrumbStyle), { y: y3 })
            });
            textGroup.appendChild(textSeparator);
            x3 += textSeparator.getBBox().width;
            if (x3 > maxWidth) {
              y3 = textGroup.getBBox().height + breadCrumbStyle.y;
              x3 = 0;
              drillText.attr({
                x: x3,
                y: y3
              });
              x3 += drillText.getBBox().width;
              textSeparator.attr({
                x: x3,
                y: y3
              });
              x3 += textSeparator.getBBox().width;
            }
            if (index4 === size(path2) - 1) {
              textSeparator.remove();
            }
            return drillText;
          });
          drillTexts.forEach((item, index4) => {
            if (index4 === size(drillTexts) - 1)
              return;
            const originalAttrs = Object.assign({}, item.attributes);
            item.attr("cursor", "pointer");
            item.addEventListener("mouseenter", () => {
              item.attr(breadCrumbActiveStyle);
            });
            item.addEventListener("mouseleave", () => {
              item.attr(originalAttrs);
            });
            item.addEventListener("click", () => {
              drillDownClick(get_default(item, ["style", "path"]), get_default(item, ["style", "depth"]));
            });
          });
        }
        legendClearSetState(container, setState);
        setState("treemapDrillDown", (viewOptions) => {
          const { marks } = viewOptions;
          const strPath = path2.join("/");
          const newMarks = marks.map((mark2) => {
            if (mark2.type !== "rect")
              return mark2;
            let newData = originData;
            if (depth) {
              const filterData = originData.filter((item) => {
                const id4 = get_default(item, ["id"]);
                return id4 && (id4.match(`${strPath}/`) || strPath.match(id4));
              }).map((item) => ({
                value: item.height === 0 ? get_default(item, ["value"]) : void 0,
                name: get_default(item, ["id"])
              }));
              const { paddingLeft, paddingBottom, paddingRight } = layout;
              const newLayout = Object.assign(Object.assign({}, layout), { paddingTop: (layout.paddingTop || textGroup.getBBox().height + 10) / (depth + 1), paddingLeft: paddingLeft / (depth + 1), paddingBottom: paddingBottom / (depth + 1), paddingRight: paddingRight / (depth + 1), path: (d2) => d2.name, layer: (d2) => d2.depth === depth + 1 });
              newData = treeDataTransform(filterData, newLayout, {
                value: "value"
              })[0];
            } else {
              newData = originData.filter((item) => {
                return item.depth === 1;
              });
            }
            const colorDomain = [];
            newData.forEach(({ path: path3 }) => {
              colorDomain.push(last(path3));
            });
            return deep_mix_default({}, mark2, {
              data: newData,
              scale: {
                color: { domain: colorDomain }
              }
            });
          });
          return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
        });
        yield update(void 0, ["legendFilter"]);
      });
      const createDrillClick = (e3) => {
        const item = e3.target;
        if (get_default(item, ["markType"]) !== "rect")
          return;
        const key = get_default(item, ["__data__", "key"]);
        const node = find_default(originData, (d2) => d2.id === key);
        if (get_default(node, "height")) {
          drillDownClick(get_default(node, "path"), get_default(node, "depth"));
        }
      };
      plotArea.addEventListener("click", createDrillClick);
      const changeStyleKey = keys_default(Object.assign(Object.assign({}, state.active), state.inactive));
      const createActive = () => {
        const elements = getElements(plotArea);
        elements.forEach((element) => {
          const cursor = get_default(element, ["style", "cursor"]);
          const node = find_default(originData, (d2) => d2.id === get_default(element, ["__data__", "key"]));
          if (cursor !== "pointer" && (node === null || node === void 0 ? void 0 : node.height)) {
            element.style.cursor = "pointer";
            const originalAttrs = pick_default(element.attributes, changeStyleKey);
            element.addEventListener("mouseenter", () => {
              element.attr(state.active);
            });
            element.addEventListener("mouseleave", () => {
              element.attr(deep_mix_default(originalAttrs, state.inactive));
            });
          }
        });
      };
      createActive();
      plotArea.addEventListener("mousemove", createActive);
      return () => {
        textGroup.remove();
        plotArea.removeEventListener("click", createDrillClick);
        plotArea.removeEventListener("mousemove", createActive);
      };
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/interaction/elementPointMove.js
  var __awaiter12 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest87 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var DEFAULT_STYLE = {
    pointR: 6,
    pointStrokeWidth: 1,
    pointStroke: "#888",
    pointActiveStroke: "#f5f5f5",
    pathStroke: "#888",
    pathLineDash: [3, 4],
    labelFontSize: 12,
    labelFill: "#888",
    labelStroke: "#fff",
    labelLineWidth: 1,
    labelY: -6,
    labelX: 2
  };
  var MOVE_POINT_NAME = "movePoint";
  var elementMouseenter = (e3) => {
    const element = e3.target;
    const { markType } = element;
    if (markType === "line") {
      element.attr("_lineWidth", element.attr("lineWidth") || 1);
      element.attr("lineWidth", element.attr("_lineWidth") + 3);
    }
    if (markType === "interval") {
      element.attr("_opacity", element.attr("opacity") || 1);
      element.attr("opacity", 0.7 * element.attr("_opacity"));
    }
  };
  var elementMouseleave = (e3) => {
    const element = e3.target;
    const { markType } = element;
    if (markType === "line") {
      element.attr("lineWidth", element.attr("_lineWidth"));
    }
    if (markType === "interval") {
      element.attr("opacity", element.attr("_opacity"));
    }
  };
  var getNewData = (newChangeData, data2, encode) => {
    return data2.map((d2) => {
      const isUpdate = ["x", "color"].reduce((v, key) => {
        const field3 = encode[key];
        if (!field3)
          return v;
        if (d2[field3] !== newChangeData[field3])
          return false;
        return v;
      }, true);
      return isUpdate ? Object.assign(Object.assign({}, d2), newChangeData) : d2;
    });
  };
  var getIntervalDataRatioTransformFn = (element) => {
    const y3 = get_default(element, ["__data__", "y"]);
    const y12 = get_default(element, ["__data__", "y1"]);
    const v = y12 - y3;
    const { __data__: { data: data2, encode, transform }, childNodes } = element.parentNode;
    const isNormalizeY = find_default(transform, ({ type }) => type === "normalizeY");
    const yField = get_default(encode, ["y", "field"]);
    const value2 = data2[childNodes.indexOf(element)][yField];
    return (newValue, isTheta3 = false) => {
      if (isNormalizeY || isTheta3) {
        return newValue / (1 - newValue) / (v / (1 - v)) * value2;
      }
      return newValue;
    };
  };
  var getPathDataRatioTransformFn = (element, index4) => {
    const v = get_default(element, ["__data__", "seriesItems", index4, "0", "value"]);
    const i = get_default(element, ["__data__", "seriesIndex", index4]);
    const { __data__: { data: data2, encode, transform } } = element.parentNode;
    const isNormalizeY = find_default(transform, ({ type }) => type === "normalizeY");
    const yField = get_default(encode, ["y", "field"]);
    const value2 = data2[i][yField];
    return (newValue) => {
      if (isNormalizeY) {
        if (v === 1) {
          return newValue;
        }
        return newValue / (1 - newValue) / (v / (1 - v)) * value2;
      }
      return newValue;
    };
  };
  var selectedPointsStyle = (pointsShape, selection, defaultStyle2) => {
    pointsShape.forEach((shape23, index4) => {
      shape23.attr("stroke", selection[1] === index4 ? defaultStyle2["activeStroke"] : defaultStyle2["stroke"]);
    });
  };
  var createHelpShape = (group3, circle3, pathStyle, labelStyle) => {
    const pathShape = new Path2({
      style: pathStyle
    });
    const labelShape = new Text({
      style: labelStyle
    });
    circle3.appendChild(labelShape);
    group3.appendChild(pathShape);
    return [pathShape, labelShape];
  };
  var getColorType = (scaleColor, color2) => {
    const indexOf4 = get_default(scaleColor, ["options", "range", "indexOf"]);
    if (!indexOf4)
      return;
    const i = scaleColor.options.range.indexOf(color2);
    return scaleColor.sortedDomain[i];
  };
  var getSamePointPosition = (center2, point6, target) => {
    const oldR = getPointsR(center2, point6);
    const newR = getPointsR(center2, target);
    const ratio = newR / oldR;
    const newX = center2[0] + (point6[0] - center2[0]) * ratio;
    const newY = center2[1] + (point6[1] - center2[1]) * ratio;
    return [newX, newY];
  };
  function ElementPointMove(elementPointMoveOptions = {}) {
    const { selection = [], precision = 2 } = elementPointMoveOptions, style = __rest87(elementPointMoveOptions, ["selection", "precision"]);
    const defaultStyle2 = Object.assign(Object.assign({}, DEFAULT_STYLE), style || {});
    const pathDefaultStyle = subObject(defaultStyle2, "path");
    const labelDefaultStyle = subObject(defaultStyle2, "label");
    const pointDefaultStyle = subObject(defaultStyle2, "point");
    return (context, _2, emitter) => {
      const { update, setState, container, view, options: { marks, coordinate: coordinateOptions } } = context;
      const plotArea = selectPlotArea(container);
      let elements = getElements(plotArea);
      let newState;
      let newSelection = selection;
      const { transform = [], type: coordinateType } = coordinateOptions;
      const isTranspose3 = !!find_default(transform, ({ type }) => type === "transpose");
      const isPolar3 = coordinateType === "polar";
      const isTheta3 = coordinateType === "theta";
      const isArea = !!find_default(elements, ({ markType }) => markType === "area");
      if (isArea) {
        elements = elements.filter(({ markType }) => markType === "area");
      }
      const pointsGroup = new Group2({
        style: {
          // Tooltip point need down.
          zIndex: 2
        }
      });
      plotArea.appendChild(pointsGroup);
      const selectedChange = () => {
        emitter.emit("element-point:select", {
          nativeEvent: true,
          data: {
            selection: newSelection
          }
        });
      };
      const dataChange = (changeData, data2) => {
        emitter.emit("element-point:moved", {
          nativeEvent: true,
          data: {
            changeData,
            data: data2
          }
        });
      };
      const elementClick = (e3) => {
        const element = e3.target;
        newSelection = [element.parentNode.childNodes.indexOf(element)];
        selectedChange();
        createPoints(element);
      };
      const elementSelect2 = (d2) => {
        const { data: { selection: selection2 }, nativeEvent } = d2;
        if (nativeEvent)
          return;
        newSelection = selection2;
        const element = get_default(elements, [newSelection === null || newSelection === void 0 ? void 0 : newSelection[0]]);
        if (element) {
          createPoints(element);
        }
      };
      const createPoints = (element) => {
        const { attributes, markType, __data__: data2 } = element;
        const { stroke: fill } = attributes;
        const { points, seriesTitle, color: color2, title, seriesX, y1: y12 } = data2;
        if (isTranspose3 && markType !== "interval")
          return;
        const { scale: scale9, coordinate } = (newState === null || newState === void 0 ? void 0 : newState.view) || view;
        const { color: scaleColor, y: scaleY, x: scaleX } = scale9;
        const center2 = coordinate.getCenter();
        pointsGroup.removeChildren();
        let downPoint;
        const updateView = (x3, y3, color3, markTypes) => __awaiter12(this, void 0, void 0, function* () {
          setState("elementPointMove", (viewOptions) => {
            var _a;
            const newMarks = (((_a = newState === null || newState === void 0 ? void 0 : newState.options) === null || _a === void 0 ? void 0 : _a.marks) || marks).map((mark) => {
              if (!markTypes.includes(mark.type))
                return mark;
              const { data: data3, encode } = mark;
              const encodeKeys = Object.keys(encode);
              const newChangeData = encodeKeys.reduce((value2, key) => {
                const dataKey = encode[key];
                if (key === "x") {
                  value2[dataKey] = x3;
                }
                if (key === "y") {
                  value2[dataKey] = y3;
                }
                if (key === "color") {
                  value2[dataKey] = color3;
                }
                return value2;
              }, {});
              const newData = getNewData(newChangeData, data3, encode);
              dataChange(newChangeData, newData);
              return deep_mix_default({}, mark, {
                data: newData,
                // No need animate
                animate: false
              });
            });
            return Object.assign(Object.assign({}, viewOptions), { marks: newMarks });
          });
          return yield update("elementPointMove");
        });
        if (["line", "area"].includes(markType)) {
          points.forEach((p2, index4) => {
            const title2 = scaleX.invert(seriesX[index4]);
            if (!title2)
              return;
            const circle3 = new Circle({
              name: MOVE_POINT_NAME,
              style: Object.assign({ cx: p2[0], cy: p2[1], fill }, pointDefaultStyle)
            });
            const ratioTransform = getPathDataRatioTransformFn(element, index4);
            circle3.addEventListener("mousedown", (e3) => {
              const oldPoint = coordinate.output([seriesX[index4], 0]);
              const pathLength = seriesTitle === null || seriesTitle === void 0 ? void 0 : seriesTitle.length;
              container.attr("cursor", "move");
              if (newSelection[1] !== index4) {
                newSelection[1] = index4;
                selectedChange();
              }
              selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
              const [pathShape, labelShape] = createHelpShape(pointsGroup, circle3, pathDefaultStyle, labelDefaultStyle);
              const pointMousemove = (e4) => {
                const newCy = p2[1] + e4.clientY - downPoint[1];
                if (isArea) {
                  if (isPolar3) {
                    const newCx = p2[0] + e4.clientX - downPoint[0];
                    const [newX, newY] = getSamePointPosition(center2, oldPoint, [
                      newCx,
                      newCy
                    ]);
                    const [, initY] = coordinate.output([1, scaleY.output(0)]);
                    const [, y3] = coordinate.invert([
                      newX,
                      initY - (points[index4 + pathLength][1] - newY)
                    ]);
                    const nextIndex = (index4 + 1) % pathLength;
                    const lastIndex = (index4 - 1 + pathLength) % pathLength;
                    const newPath = getPointsPath([
                      points[lastIndex],
                      [newX, newY],
                      seriesTitle[nextIndex] && points[nextIndex]
                    ]);
                    labelShape.attr("text", ratioTransform(scaleY.invert(y3)).toFixed(precision));
                    pathShape.attr("d", newPath);
                    circle3.attr("cx", newX);
                    circle3.attr("cy", newY);
                  } else {
                    const [, initY] = coordinate.output([1, scaleY.output(0)]);
                    const [, y3] = coordinate.invert([
                      p2[0],
                      initY - (points[index4 + pathLength][1] - newCy)
                    ]);
                    const newPath = getPointsPath([
                      points[index4 - 1],
                      [p2[0], newCy],
                      seriesTitle[index4 + 1] && points[index4 + 1]
                    ]);
                    labelShape.attr("text", ratioTransform(scaleY.invert(y3)).toFixed(precision));
                    pathShape.attr("d", newPath);
                    circle3.attr("cy", newCy);
                  }
                } else {
                  const [, y3] = coordinate.invert([p2[0], newCy]);
                  const newPath = getPointsPath([
                    points[index4 - 1],
                    [p2[0], newCy],
                    points[index4 + 1]
                  ]);
                  labelShape.attr("text", scaleY.invert(y3).toFixed(precision));
                  pathShape.attr("d", newPath);
                  circle3.attr("cy", newCy);
                }
              };
              downPoint = [e3.clientX, e3.clientY];
              window.addEventListener("mousemove", pointMousemove);
              const mouseupFn = () => __awaiter12(this, void 0, void 0, function* () {
                container.attr("cursor", "default");
                window.removeEventListener("mousemove", pointMousemove);
                container.removeEventListener("mouseup", mouseupFn);
                if (is_undefined_default(labelShape.attr("text")))
                  return;
                const y3 = Number(labelShape.attr("text"));
                const colorType = getColorType(scaleColor, color2);
                newState = yield updateView(title2, y3, colorType, [
                  "line",
                  "area"
                ]);
                labelShape.remove();
                pathShape.remove();
                createPoints(element);
              });
              container.addEventListener("mouseup", mouseupFn);
            });
            pointsGroup.appendChild(circle3);
          });
          selectedPointsStyle(pointsGroup.childNodes, newSelection, pointDefaultStyle);
        } else if (markType === "interval") {
          let circlePoint = [(points[0][0] + points[1][0]) / 2, points[0][1]];
          if (isTranspose3) {
            circlePoint = [points[0][0], (points[0][1] + points[1][1]) / 2];
          } else if (isTheta3) {
            circlePoint = points[0];
          }
          const ratioTransform = getIntervalDataRatioTransformFn(element);
          const circle3 = new Circle({
            name: MOVE_POINT_NAME,
            style: Object.assign(Object.assign({ cx: circlePoint[0], cy: circlePoint[1], fill }, pointDefaultStyle), { stroke: pointDefaultStyle["activeStroke"] })
          });
          circle3.addEventListener("mousedown", (e3) => {
            container.attr("cursor", "move");
            const colorType = getColorType(scaleColor, color2);
            const [pathShape, labelShape] = createHelpShape(pointsGroup, circle3, pathDefaultStyle, labelDefaultStyle);
            const pointMousemove = (e4) => {
              if (isTranspose3) {
                const newCx = circlePoint[0] + e4.clientX - downPoint[0];
                const [initX] = coordinate.output([
                  scaleY.output(0),
                  scaleY.output(0)
                ]);
                const [, x3] = coordinate.invert([
                  initX + (newCx - points[2][0]),
                  circlePoint[1]
                ]);
                const newPath = getPointsPath([
                  [newCx, points[0][1]],
                  [newCx, points[1][1]],
                  points[2],
                  points[3]
                ], true);
                labelShape.attr("text", ratioTransform(scaleY.invert(x3)).toFixed(precision));
                pathShape.attr("d", newPath);
                circle3.attr("cx", newCx);
              } else if (isTheta3) {
                const newCy = circlePoint[1] + e4.clientY - downPoint[1];
                const newCx = circlePoint[0] + e4.clientX - downPoint[0];
                const [newXOut, newYOut] = getSamePointPosition(center2, [newCx, newCy], circlePoint);
                const [newXIn, newYIn] = getSamePointPosition(center2, [newCx, newCy], points[1]);
                const lastPercent = coordinate.invert([newXOut, newYOut])[1];
                const percent = y12 - lastPercent;
                if (percent < 0)
                  return;
                const newPath = getThetaPath(center2, [[newXOut, newYOut], [newXIn, newYIn], points[2], points[3]], percent > 0.5 ? 1 : 0);
                labelShape.attr("text", ratioTransform(percent, true).toFixed(precision));
                pathShape.attr("d", newPath);
                circle3.attr("cx", newXOut);
                circle3.attr("cy", newYOut);
              } else {
                const newCy = circlePoint[1] + e4.clientY - downPoint[1];
                const [, initY] = coordinate.output([1, scaleY.output(0)]);
                const [, y3] = coordinate.invert([
                  circlePoint[0],
                  initY - (points[2][1] - newCy)
                ]);
                const newPath = getPointsPath([
                  [points[0][0], newCy],
                  [points[1][0], newCy],
                  points[2],
                  points[3]
                ], true);
                labelShape.attr("text", ratioTransform(scaleY.invert(y3)).toFixed(precision));
                pathShape.attr("d", newPath);
                circle3.attr("cy", newCy);
              }
            };
            downPoint = [e3.clientX, e3.clientY];
            window.addEventListener("mousemove", pointMousemove);
            const mouseupFn = () => __awaiter12(this, void 0, void 0, function* () {
              container.attr("cursor", "default");
              container.removeEventListener("mouseup", mouseupFn);
              window.removeEventListener("mousemove", pointMousemove);
              if (is_undefined_default(labelShape.attr("text")))
                return;
              const y3 = Number(labelShape.attr("text"));
              newState = yield updateView(title, y3, colorType, [markType]);
              labelShape.remove();
              pathShape.remove();
              createPoints(element);
            });
            container.addEventListener("mouseup", mouseupFn);
          });
          pointsGroup.appendChild(circle3);
        }
      };
      elements.forEach((element, index4) => {
        if (newSelection[0] === index4) {
          createPoints(element);
        }
        element.addEventListener("click", elementClick);
        element.addEventListener("mouseenter", elementMouseenter);
        element.addEventListener("mouseleave", elementMouseleave);
      });
      const rootClick = (e3) => {
        const element = e3 === null || e3 === void 0 ? void 0 : e3.target;
        if (!element || element.name !== MOVE_POINT_NAME && !elements.includes(element)) {
          newSelection = [];
          selectedChange();
          pointsGroup.removeChildren();
        }
      };
      emitter.on("element-point:select", elementSelect2);
      emitter.on("element-point:unselect", rootClick);
      container.addEventListener("mousedown", rootClick);
      return () => {
        pointsGroup.remove();
        emitter.off("element-point:select", elementSelect2);
        emitter.off("element-point:unselect", rootClick);
        container.removeEventListener("mousedown", rootClick);
        elements.forEach((element) => {
          element.removeEventListener("click", elementClick);
          element.removeEventListener("mouseenter", elementMouseenter);
          element.removeEventListener("mouseleave", elementMouseleave);
        });
      };
    };
  }

  // ../../engine/rails_design/node_modules/d3-dsv/src/dsv.js
  var EOL = {};
  var EOF = {};
  var QUOTE = 34;
  var NEWLINE = 10;
  var RETURN = 13;
  function objectConverter(columns) {
    return new Function("d", "return {" + columns.map(function(name2, i) {
      return JSON.stringify(name2) + ": d[" + i + '] || ""';
    }).join(",") + "}");
  }
  function customConverter(columns, f) {
    var object = objectConverter(columns);
    return function(row2, i) {
      return f(object(row2), i, columns);
    };
  }
  function inferColumns(rows) {
    var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
    rows.forEach(function(row2) {
      for (var column2 in row2) {
        if (!(column2 in columnSet)) {
          columns.push(columnSet[column2] = column2);
        }
      }
    });
    return columns;
  }
  function pad2(value2, width) {
    var s2 = value2 + "", length5 = s2.length;
    return length5 < width ? new Array(width - length5 + 1).join(0) + s2 : s2;
  }
  function formatYear(year2) {
    return year2 < 0 ? "-" + pad2(-year2, 6) : year2 > 9999 ? "+" + pad2(year2, 6) : pad2(year2, 4);
  }
  function formatDate(date) {
    var hours = date.getUTCHours(), minutes = date.getUTCMinutes(), seconds = date.getUTCSeconds(), milliseconds = date.getUTCMilliseconds();
    return isNaN(date) ? "Invalid Date" : formatYear(date.getUTCFullYear(), 4) + "-" + pad2(date.getUTCMonth() + 1, 2) + "-" + pad2(date.getUTCDate(), 2) + (milliseconds ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + ":" + pad2(seconds, 2) + "." + pad2(milliseconds, 3) + "Z" : seconds ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + ":" + pad2(seconds, 2) + "Z" : minutes || hours ? "T" + pad2(hours, 2) + ":" + pad2(minutes, 2) + "Z" : "");
  }
  function dsv_default(delimiter) {
    var reFormat = new RegExp('["' + delimiter + "\n\r]"), DELIMITER = delimiter.charCodeAt(0);
    function parse2(text, f) {
      var convert, columns, rows = parseRows(text, function(row2, i) {
        if (convert) return convert(row2, i - 1);
        columns = row2, convert = f ? customConverter(row2, f) : objectConverter(row2);
      });
      rows.columns = columns || [];
      return rows;
    }
    function parseRows(text, f) {
      var rows = [], N = text.length, I = 0, n2 = 0, t, eof = N <= 0, eol = false;
      if (text.charCodeAt(N - 1) === NEWLINE) --N;
      if (text.charCodeAt(N - 1) === RETURN) --N;
      function token2() {
        if (eof) return EOF;
        if (eol) return eol = false, EOL;
        var i, j = I, c5;
        if (text.charCodeAt(j) === QUOTE) {
          while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE) ;
          if ((i = I) >= N) eof = true;
          else if ((c5 = text.charCodeAt(I++)) === NEWLINE) eol = true;
          else if (c5 === RETURN) {
            eol = true;
            if (text.charCodeAt(I) === NEWLINE) ++I;
          }
          return text.slice(j + 1, i - 1).replace(/""/g, '"');
        }
        while (I < N) {
          if ((c5 = text.charCodeAt(i = I++)) === NEWLINE) eol = true;
          else if (c5 === RETURN) {
            eol = true;
            if (text.charCodeAt(I) === NEWLINE) ++I;
          } else if (c5 !== DELIMITER) continue;
          return text.slice(j, i);
        }
        return eof = true, text.slice(j, N);
      }
      while ((t = token2()) !== EOF) {
        var row2 = [];
        while (t !== EOL && t !== EOF) row2.push(t), t = token2();
        if (f && (row2 = f(row2, n2++)) == null) continue;
        rows.push(row2);
      }
      return rows;
    }
    function preformatBody(rows, columns) {
      return rows.map(function(row2) {
        return columns.map(function(column2) {
          return formatValue(row2[column2]);
        }).join(delimiter);
      });
    }
    function format3(rows, columns) {
      if (columns == null) columns = inferColumns(rows);
      return [columns.map(formatValue).join(delimiter)].concat(preformatBody(rows, columns)).join("\n");
    }
    function formatBody(rows, columns) {
      if (columns == null) columns = inferColumns(rows);
      return preformatBody(rows, columns).join("\n");
    }
    function formatRows(rows) {
      return rows.map(formatRow).join("\n");
    }
    function formatRow(row2) {
      return row2.map(formatValue).join(delimiter);
    }
    function formatValue(value2) {
      return value2 == null ? "" : value2 instanceof Date ? formatDate(value2) : reFormat.test(value2 += "") ? '"' + value2.replace(/"/g, '""') + '"' : value2;
    }
    return {
      parse: parse2,
      parseRows,
      format: format3,
      formatBody,
      formatRows,
      formatRow,
      formatValue
    };
  }

  // ../../engine/rails_design/node_modules/d3-dsv/src/autoType.js
  function autoType(object) {
    for (var key in object) {
      var value2 = object[key].trim(), number2, m3;
      if (!value2) value2 = null;
      else if (value2 === "true") value2 = true;
      else if (value2 === "false") value2 = false;
      else if (value2 === "NaN") value2 = NaN;
      else if (!isNaN(number2 = +value2)) value2 = number2;
      else if (m3 = value2.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
        if (fixtz && !!m3[4] && !m3[7]) value2 = value2.replace(/-/g, "/").replace(/T/, " ");
        value2 = new Date(value2);
      } else continue;
      object[key] = value2;
    }
    return object;
  }
  var fixtz = (/* @__PURE__ */ new Date("2019-01-01T00:00")).getHours() || (/* @__PURE__ */ new Date("2019-07-01T00:00")).getHours();

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/fetch.js
  var __awaiter13 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var Fetch = (options) => {
    const { value: value2, format: format3 = value2.split(".").pop(), delimiter = ",", autoType: autoType2 = true } = options;
    return () => __awaiter13(void 0, void 0, void 0, function* () {
      const response = yield fetch(value2);
      if (format3 === "csv") {
        const str7 = yield response.text();
        return dsv_default(delimiter).parse(str7, autoType2 ? autoType : identity5);
      } else if (format3 === "json") {
        return yield response.json();
      }
      throw new Error(`Unknown format: ${format3}.`);
    });
  };
  Fetch.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/fold.js
  function isEmpty(obj) {
    return !obj || Object.keys(obj).length === 0;
  }
  var Fold = (options) => {
    const { fields, key = "key", value: value2 = "value" } = options;
    return (data2) => {
      if (isEmpty(fields))
        return data2;
      return data2.flatMap((d2) => fields.map((f) => Object.assign(Object.assign({}, d2), { [key]: f, [value2]: d2[f] })));
    };
  };
  Fold.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/filter.js
  function defined3(d2) {
    return d2 !== void 0 && d2 !== null && !Number.isNaN(d2);
  }
  var Filter2 = (options) => {
    const { callback = defined3 } = options;
    return (data2) => data2.filter(callback);
  };
  Filter2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/sort.js
  var Sort2 = (options) => {
    const { callback } = options;
    return (data2) => Array.isArray(data2) ? [...data2].sort(callback) : data2;
  };
  Sort2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/pick.js
  function pick2(v, fields = []) {
    return fields.reduce((datum, field3) => {
      if (field3 in v) {
        datum[field3] = v[field3];
      }
      return datum;
    }, {});
  }
  var Pick = (options) => {
    const { fields } = options;
    return (data2) => data2.map((d2) => pick2(d2, fields));
  };
  Pick.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/rename.js
  function isEmpty2(obj) {
    return Object.keys(obj).length === 0;
  }
  var Rename = (options) => {
    return (data2) => {
      if (!options || isEmpty2(options))
        return data2;
      const rename = (v) => Object.entries(v).reduce((datum, [key, value2]) => (datum[options[key] || key] = value2, datum), {});
      return data2.map(rename);
    };
  };
  Rename.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/utils/fields.js
  function normalizeFields(fields, defaultValue) {
    return fields.map((d2) => {
      if (Array.isArray(d2)) {
        const [field3, value2 = defaultValue] = d2;
        return [field3, value2];
      }
      return [d2, defaultValue];
    });
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/sortBy.js
  var SortBy = (options) => {
    const { fields: F = [] } = options;
    const normalizedF = normalizeFields(F, true);
    return (data2) => {
      const comparator = (a3, b) => normalizedF.reduce((ret, [field3, order = true]) => {
        if (ret !== 0) {
          return ret;
        }
        if (order) {
          return a3[field3] < b[field3] ? -1 : +(a3[field3] !== b[field3]);
        } else {
          return a3[field3] > b[field3] ? -1 : +(a3[field3] !== b[field3]);
        }
      }, 0);
      return [...data2].sort(comparator);
    };
  };
  SortBy.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/inline.js
  var Inline = (options) => {
    const { value: value2 } = options;
    return () => value2;
  };
  Inline.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/custom.js
  var Custom = (options) => {
    const { callback = identity5 } = options;
    return (data2) => callback(data2);
  };
  Custom.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/map.js
  var Map2 = (options) => {
    const { callback = identity5 } = options;
    return (data2) => Array.isArray(data2) ? data2.map(callback) : data2;
  };
  Map2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/utils/flow.js
  var __awaiter14 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  function flow(target, source) {
    return {
      set(key, normalize10, callback) {
        if (source[key] === void 0)
          return this;
        const value2 = normalize10 ? normalize10.call(null, source[key]) : source[key];
        if (callback)
          callback.call(null, value2);
        else if (typeof target[key] === "function")
          target[key](value2);
        else
          target[key] = value2;
        return this;
      },
      setAsync(key, normalize10, callback) {
        return __awaiter14(this, void 0, void 0, function* () {
          if (source[key] === void 0)
            return this;
          const value2 = normalize10 ? yield normalize10.call(null, source[key]) : source[key];
          if (callback)
            callback.call(null, value2);
          else if (typeof target[key] === "function")
            target[key](value2);
          else
            target[key] = value2;
          return this;
        });
      }
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/utils/d3-cloud/index.js
  var cloudRadians = Math.PI / 180;
  var cw = 1 << 11 >> 5;
  var ch = 1 << 11;
  function cloudText(d2) {
    return d2.text;
  }
  function cloudFont() {
    return "serif";
  }
  function cloudFontNormal() {
    return "normal";
  }
  function cloudFontSize(d2) {
    return d2.value;
  }
  function cloudRotate() {
    return ~~(Math.random() * 2) * 90;
  }
  function cloudPadding() {
    return 1;
  }
  function cloudDispatch() {
    return;
  }
  function cloudSprite(contextAndRatio, d2, data2, di) {
    if (d2.sprite)
      return;
    const c5 = contextAndRatio.context, ratio = contextAndRatio.ratio;
    c5.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
    let x3 = 0, y3 = 0, maxh = 0;
    const n2 = data2.length;
    --di;
    while (++di < n2) {
      d2 = data2[di];
      c5.save();
      c5.font = d2.style + " " + d2.weight + " " + ~~((d2.size + 1) / ratio) + "px " + d2.font;
      let w = c5.measureText(d2.text + "m").width * ratio, h = d2.size << 1;
      if (d2.rotate) {
        const sr = Math.sin(d2.rotate * cloudRadians), cr = Math.cos(d2.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
        w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
        h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
      } else {
        w = w + 31 >> 5 << 5;
      }
      if (h > maxh)
        maxh = h;
      if (x3 + w >= cw << 5) {
        x3 = 0;
        y3 += maxh;
        maxh = 0;
      }
      if (y3 + h >= ch)
        break;
      c5.translate((x3 + (w >> 1)) / ratio, (y3 + (h >> 1)) / ratio);
      if (d2.rotate)
        c5.rotate(d2.rotate * cloudRadians);
      c5.fillText(d2.text, 0, 0);
      if (d2.padding) {
        c5.lineWidth = 2 * d2.padding;
        c5.strokeText(d2.text, 0, 0);
      }
      c5.restore();
      d2.width = w;
      d2.height = h;
      d2.xoff = x3;
      d2.yoff = y3;
      d2.x1 = w >> 1;
      d2.y1 = h >> 1;
      d2.x0 = -d2.x1;
      d2.y0 = -d2.y1;
      d2.hasText = true;
      x3 += w;
    }
    const pixels = c5.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
    while (--di >= 0) {
      d2 = data2[di];
      if (!d2.hasText)
        continue;
      const w = d2.width, w32 = w >> 5;
      let h = d2.y1 - d2.y0;
      for (let i = 0; i < h * w32; i++)
        sprite[i] = 0;
      x3 = d2.xoff;
      if (x3 == null)
        return;
      y3 = d2.yoff;
      let seen = 0, seenRow = -1;
      for (let j = 0; j < h; j++) {
        for (let i = 0; i < w; i++) {
          const k = w32 * j + (i >> 5), m3 = pixels[(y3 + j) * (cw << 5) + (x3 + i) << 2] ? 1 << 31 - i % 32 : 0;
          sprite[k] |= m3;
          seen |= m3;
        }
        if (seen)
          seenRow = j;
        else {
          d2.y0++;
          h--;
          j--;
          y3++;
        }
      }
      d2.y1 = d2.y0 + seenRow;
      d2.sprite = sprite.slice(0, (d2.y1 - d2.y0) * w32);
    }
  }
  function cloudCollide(tag, board, sw) {
    sw >>= 5;
    const sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
    let x3 = (tag.y + tag.y0) * sw + (lx >> 5), last4;
    for (let j = 0; j < h; j++) {
      last4 = 0;
      for (let i = 0; i <= w; i++) {
        if ((last4 << msx | (i < w ? (last4 = sprite[j * w + i]) >>> sx : 0)) & board[x3 + i])
          return true;
      }
      x3 += sw;
    }
    return false;
  }
  function cloudBounds(bounds, d2) {
    const b0 = bounds[0], b1 = bounds[1];
    if (d2.x + d2.x0 < b0.x)
      b0.x = d2.x + d2.x0;
    if (d2.y + d2.y0 < b0.y)
      b0.y = d2.y + d2.y0;
    if (d2.x + d2.x1 > b1.x)
      b1.x = d2.x + d2.x1;
    if (d2.y + d2.y1 > b1.y)
      b1.y = d2.y + d2.y1;
  }
  function collideRects(a3, b) {
    return a3.x + a3.x1 > b[0].x && a3.x + a3.x0 < b[1].x && a3.y + a3.y1 > b[0].y && a3.y + a3.y0 < b[1].y;
  }
  function archimedeanSpiral(size2) {
    const e3 = size2[0] / size2[1];
    return function(t) {
      return [e3 * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
    };
  }
  function rectangularSpiral(size2) {
    const dy = 4, dx = dy * size2[0] / size2[1];
    let x3 = 0, y3 = 0;
    return function(t) {
      const sign3 = t < 0 ? -1 : 1;
      switch (Math.sqrt(1 + 4 * sign3 * t) - sign3 & 3) {
        case 0:
          x3 += dx;
          break;
        case 1:
          y3 += dy;
          break;
        case 2:
          x3 -= dx;
          break;
        default:
          y3 -= dy;
          break;
      }
      return [x3, y3];
    };
  }
  function zeroArray(n2) {
    const a3 = [];
    let i = -1;
    while (++i < n2)
      a3[i] = 0;
    return a3;
  }
  function cloudCanvas() {
    return document.createElement("canvas");
  }
  function functor(d2) {
    return typeof d2 === "function" ? d2 : function() {
      return d2;
    };
  }
  var spirals = {
    archimedean: archimedeanSpiral,
    rectangular: rectangularSpiral
  };
  function tagCloud() {
    let size2 = [256, 256], text = cloudText, font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate4 = cloudRotate, padding = cloudPadding, spiral = archimedeanSpiral, random5 = Math.random, event = cloudDispatch, words = [], timer2 = null, timeInterval = Infinity, canvas = cloudCanvas;
    const fontStyle = cloudFontNormal;
    const cloud = {};
    cloud.start = function() {
      const [width, height] = size2;
      const contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size2[0] >> 5) * size2[1]), n2 = words.length, tags = [], data2 = words.map(function(d2, i2, data3) {
        d2.text = text.call(this, d2, i2, data3);
        d2.font = font.call(this, d2, i2, data3);
        d2.style = fontStyle.call(this, d2, i2, data3);
        d2.weight = fontWeight.call(this, d2, i2, data3);
        d2.rotate = rotate4.call(this, d2, i2, data3);
        d2.size = ~~fontSize.call(this, d2, i2, data3);
        d2.padding = padding.call(this, d2, i2, data3);
        return d2;
      }).sort(function(a3, b) {
        return b.size - a3.size;
      });
      let i = -1, bounds = !cloud.board ? void 0 : [
        {
          x: 0,
          y: 0
        },
        {
          x: width,
          y: height
        }
      ];
      if (timer2)
        clearInterval(timer2);
      timer2 = setInterval(step2, 0);
      step2();
      function step2() {
        const start2 = Date.now();
        while (Date.now() - start2 < timeInterval && ++i < n2) {
          const d2 = data2[i];
          d2.x = width * (random5() + 0.5) >> 1;
          d2.y = height * (random5() + 0.5) >> 1;
          cloudSprite(contextAndRatio, d2, data2, i);
          if (d2.hasText && place2(board, d2, bounds)) {
            event.call(null, "word", { cloud, word: d2 });
            tags.push(d2);
            if (bounds) {
              if (!cloud.hasImage) {
                cloudBounds(bounds, d2);
              }
            } else {
              bounds = [
                { x: d2.x + d2.x0, y: d2.y + d2.y0 },
                { x: d2.x + d2.x1, y: d2.y + d2.y1 }
              ];
            }
            d2.x -= size2[0] >> 1;
            d2.y -= size2[1] >> 1;
          }
        }
        cloud._tags = tags;
        cloud._bounds = bounds;
        if (i >= n2) {
          cloud.stop();
          event.call(null, "end", { cloud, words: tags, bounds });
        }
      }
      return cloud;
    };
    cloud.stop = function() {
      if (timer2) {
        clearInterval(timer2);
        timer2 = null;
      }
      return cloud;
    };
    function getContext(canvas2) {
      canvas2.width = canvas2.height = 1;
      const ratio = Math.sqrt(canvas2.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
      canvas2.width = (cw << 5) / ratio;
      canvas2.height = ch / ratio;
      const context = canvas2.getContext("2d");
      context.fillStyle = context.strokeStyle = "red";
      context.textAlign = "center";
      context.textBaseline = "middle";
      return { context, ratio };
    }
    function place2(board, tag, bounds) {
      const startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size2[0] * size2[0] + size2[1] * size2[1]), s2 = spiral(size2), dt = random5() < 0.5 ? 1 : -1;
      let dxdy, t = -dt, dx, dy;
      while (dxdy = s2(t += dt)) {
        dx = ~~dxdy[0];
        dy = ~~dxdy[1];
        if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
          break;
        tag.x = startX + dx;
        tag.y = startY + dy;
        if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size2[0] || tag.y + tag.y1 > size2[1])
          continue;
        if (!bounds || !cloudCollide(tag, board, size2[0])) {
          if (!bounds || collideRects(tag, bounds)) {
            const sprite = tag.sprite, w = tag.width >> 5, sw = size2[0] >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
            let last4, x3 = (tag.y + tag.y0) * sw + (lx >> 5);
            for (let j = 0; j < h; j++) {
              last4 = 0;
              for (let i = 0; i <= w; i++) {
                board[x3 + i] |= last4 << msx | (i < w ? (last4 = sprite[j * w + i]) >>> sx : 0);
              }
              x3 += sw;
            }
            delete tag.sprite;
            return true;
          }
        }
      }
      return false;
    }
    cloud.createMask = (img) => {
      const can = document.createElement("canvas");
      const [width, height] = size2;
      if (!width || !height) {
        return;
      }
      const w32 = width >> 5;
      const board = zeroArray((width >> 5) * height);
      can.width = width;
      can.height = height;
      const cxt = can.getContext("2d");
      cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
      const imageData = cxt.getImageData(0, 0, width, height).data;
      for (let j = 0; j < height; j++) {
        for (let i = 0; i < width; i++) {
          const k = w32 * j + (i >> 5);
          const tmp2 = j * width + i << 2;
          const flag = imageData[tmp2] >= 250 && imageData[tmp2 + 1] >= 250 && imageData[tmp2 + 2] >= 250;
          const m3 = flag ? 1 << 31 - i % 32 : 0;
          board[k] |= m3;
        }
      }
      cloud.board = board;
      cloud.hasImage = true;
    };
    cloud.timeInterval = function(_2) {
      timeInterval = _2 == null ? Infinity : _2;
    };
    cloud.words = function(_2) {
      words = _2;
    };
    cloud.size = function(_2 = []) {
      size2 = [+_2[0], +_2[1]];
    };
    cloud.text = function(_2) {
      text = functor(_2);
    };
    cloud.font = function(_2) {
      font = functor(_2);
    };
    cloud.fontWeight = function(_2) {
      fontWeight = functor(_2);
    };
    cloud.rotate = function(_2) {
      rotate4 = functor(_2);
    };
    cloud.canvas = function(_2) {
      canvas = functor(_2);
    };
    cloud.spiral = function(_2) {
      spiral = spirals[_2] || _2;
    };
    cloud.fontSize = function(_2) {
      fontSize = functor(_2);
    };
    cloud.padding = function(_2) {
      padding = functor(_2);
    };
    cloud.random = function(_2) {
      random5 = functor(_2);
    };
    cloud.on = function(_2) {
      event = functor(_2);
    };
    return cloud;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/wordCloud.js
  var __awaiter15 = function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve) {
        resolve(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value2) {
        try {
          step2(generator.next(value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function rejected(value2) {
        try {
          step2(generator["throw"](value2));
        } catch (e3) {
          reject(e3);
        }
      }
      function step2(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step2((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __rest88 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var DEFAULT_OPTIONS5 = {
    fontSize: [20, 60],
    font: "Impact",
    padding: 2,
    rotate: function() {
      return (~~(Math.random() * 6) - 3) * 30;
    }
  };
  function processImageMask(img) {
    return new Promise((res, rej) => {
      if (img instanceof HTMLImageElement) {
        res(img);
        return;
      }
      if (typeof img === "string") {
        const image = new Image();
        image.crossOrigin = "anonymous";
        image.src = img;
        image.onload = () => res(image);
        image.onerror = () => {
          console.error(`'image ${img} load failed !!!'`);
          rej();
        };
        return;
      }
      rej();
    });
  }
  function normalizeFontSize(fontSize, range3) {
    if (typeof fontSize === "function")
      return fontSize;
    if (Array.isArray(fontSize)) {
      const [fMin, fMax] = fontSize;
      if (!range3)
        return () => (fMax + fMin) / 2;
      const [min10, max10] = range3;
      if (max10 === min10)
        return () => (fMax + fMin) / 2;
      return ({ value: value2 }) => (fMax - fMin) / (max10 - min10) * (value2 - min10) + fMin;
    }
    return () => fontSize;
  }
  var WordCloud2 = (options, context) => {
    return (data2) => __awaiter15(void 0, void 0, void 0, function* () {
      const cloudOptions = Object.assign({}, DEFAULT_OPTIONS5, options, {
        canvas: context.createCanvas
      });
      const layout = tagCloud();
      yield flow(layout, cloudOptions).set("fontSize", (v) => {
        const arr = data2.map((d2) => d2.value);
        return normalizeFontSize(v, [min4(arr), max4(arr)]);
      }).set("font").set("fontStyle").set("fontWeight").set("padding").set("rotate").set("size").set("spiral").set("timeInterval").set("random").set("text").set("on").set("canvas").setAsync("imageMask", processImageMask, layout.createMask);
      layout.words([...data2]);
      const result = layout.start();
      const [cw2, ch2] = cloudOptions.size;
      const defaultBounds = [
        { x: 0, y: 0 },
        { x: cw2, y: ch2 }
      ];
      const { _bounds: bounds = defaultBounds, _tags, hasImage } = result;
      const tags = _tags.map((_a) => {
        var { x: x3, y: y3, font } = _a, rest = __rest88(_a, ["x", "y", "font"]);
        return Object.assign(Object.assign({}, rest), { x: x3 + cw2 / 2, y: y3 + ch2 / 2, fontFamily: font });
      });
      const [{ x: tlx, y: tly }, { x: brx, y: bry }] = bounds;
      const invisibleText = { text: "", value: 0, opacity: 0, fontSize: 0 };
      tags.push(Object.assign(Object.assign({}, invisibleText), { x: hasImage ? 0 : tlx, y: hasImage ? 0 : tly }), Object.assign(Object.assign({}, invisibleText), { x: hasImage ? cw2 : brx, y: hasImage ? ch2 : bry }));
      return tags;
    });
  };
  WordCloud2.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/join.js
  function field2(key) {
    return typeof key === "string" ? (d2) => d2[key] : key;
  }
  var Join = (options) => {
    const { join, on: on2, select: select3 = [], as = select3, unknown = NaN } = options;
    const [key, fromKey] = on2;
    const fk = field2(fromKey);
    const k = field2(key);
    const keyData = rollup(
      join,
      ([d2]) => d2,
      // Get the first matched.
      (d2) => fk(d2)
    );
    return (data2) => data2.map((d2) => {
      const source = keyData.get(k(d2));
      return Object.assign(Object.assign({}, d2), select3.reduce((prev, key2, idx) => (prev[as[idx]] = source ? source[key2] : unknown, prev), {}));
    });
  };
  Join.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/slice.js
  var Slice = (options) => {
    const { start: start2, end } = options;
    return (data2) => data2.slice(start2, end);
  };
  Slice.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/kde.js
  var import_pdfast = __toESM(require_src());
  var KDE = (options) => {
    const { field: field3, groupBy: groupBy2, as = ["y", "size"], min: min10, max: max10, size: size2 = 10, width } = options;
    const [yField, sizeField] = as;
    return (data2) => {
      const gs = Array.from(group(data2, (d2) => groupBy2.map((gb) => d2[gb]).join("-")).values());
      return gs.map((g) => {
        const pdfResult = import_pdfast.default.create(g.map((i) => i[field3]), {
          min: min10,
          max: max10,
          size: size2,
          width
        });
        const _y = pdfResult.map((result) => result.x);
        const _size = pdfResult.map((result) => result.y);
        return Object.assign(Object.assign({}, g[0]), { [yField]: _y, [sizeField]: _size });
      });
    };
  };
  KDE.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/utils/venn/layout.js
  var import_fmin = __toESM(require_fmin());

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/utils/venn/circleintersection.js
  var SMALL = 1e-10;
  function intersectionArea(circles, stats) {
    const intersectionPoints = getIntersectionPoints(circles);
    const innerPoints = intersectionPoints.filter(function(p2) {
      return containedInCircles(p2, circles);
    });
    let arcArea = 0, polygonArea = 0, i;
    const arcs = [];
    if (innerPoints.length > 1) {
      const center2 = getCenter(innerPoints);
      for (i = 0; i < innerPoints.length; ++i) {
        const p3 = innerPoints[i];
        p3.angle = Math.atan2(p3.x - center2.x, p3.y - center2.y);
      }
      innerPoints.sort(function(a3, b) {
        return b.angle - a3.angle;
      });
      let p2 = innerPoints[innerPoints.length - 1];
      for (i = 0; i < innerPoints.length; ++i) {
        const p1 = innerPoints[i];
        polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
        const midPoint2 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        let arc = null;
        for (let j = 0; j < p1.parentIndex.length; ++j) {
          if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
            const circle3 = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle3.x, p1.y - circle3.y), a22 = Math.atan2(p2.x - circle3.x, p2.y - circle3.y);
            let angleDiff = a22 - a1;
            if (angleDiff < 0) {
              angleDiff += 2 * Math.PI;
            }
            const a3 = a22 - angleDiff / 2;
            let width = distance7(midPoint2, {
              x: circle3.x + circle3.radius * Math.sin(a3),
              y: circle3.y + circle3.radius * Math.cos(a3)
            });
            if (width > circle3.radius * 2) {
              width = circle3.radius * 2;
            }
            if (arc === null || arc.width > width) {
              arc = { circle: circle3, width, p1, p2 };
            }
          }
        }
        if (arc !== null) {
          arcs.push(arc);
          arcArea += circleArea(arc.circle.radius, arc.width);
          p2 = p1;
        }
      }
    } else {
      let smallest = circles[0];
      for (i = 1; i < circles.length; ++i) {
        if (circles[i].radius < smallest.radius) {
          smallest = circles[i];
        }
      }
      let disjoint = false;
      for (i = 0; i < circles.length; ++i) {
        if (distance7(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
          disjoint = true;
          break;
        }
      }
      if (disjoint) {
        arcArea = polygonArea = 0;
      } else {
        arcArea = smallest.radius * smallest.radius * Math.PI;
        arcs.push({
          circle: smallest,
          p1: { x: smallest.x, y: smallest.y + smallest.radius },
          p2: { x: smallest.x - SMALL, y: smallest.y + smallest.radius },
          width: smallest.radius * 2
        });
      }
    }
    polygonArea /= 2;
    if (stats) {
      stats.area = arcArea + polygonArea;
      stats.arcArea = arcArea;
      stats.polygonArea = polygonArea;
      stats.arcs = arcs;
      stats.innerPoints = innerPoints;
      stats.intersectionPoints = intersectionPoints;
    }
    return arcArea + polygonArea;
  }
  function containedInCircles(point6, circles) {
    for (let i = 0; i < circles.length; ++i) {
      if (distance7(point6, circles[i]) > circles[i].radius + SMALL) {
        return false;
      }
    }
    return true;
  }
  function getIntersectionPoints(circles) {
    const ret = [];
    for (let i = 0; i < circles.length; ++i) {
      for (let j = i + 1; j < circles.length; ++j) {
        const intersect4 = circleCircleIntersection(circles[i], circles[j]);
        for (let k = 0; k < intersect4.length; ++k) {
          const p2 = intersect4[k];
          p2.parentIndex = [i, j];
          ret.push(p2);
        }
      }
    }
    return ret;
  }
  function circleArea(r, width) {
    return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
  }
  function distance7(p1, p2) {
    return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
  }
  function circleOverlap(r1, r2, d2) {
    if (d2 >= r1 + r2) {
      return 0;
    }
    if (d2 <= Math.abs(r1 - r2)) {
      return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
    }
    const w1 = r1 - (d2 * d2 - r2 * r2 + r1 * r1) / (2 * d2), w2 = r2 - (d2 * d2 - r1 * r1 + r2 * r2) / (2 * d2);
    return circleArea(r1, w1) + circleArea(r2, w2);
  }
  function circleCircleIntersection(p1, p2) {
    const d2 = distance7(p1, p2), r1 = p1.radius, r2 = p2.radius;
    if (d2 >= r1 + r2 || d2 <= Math.abs(r1 - r2)) {
      return [];
    }
    const a3 = (r1 * r1 - r2 * r2 + d2 * d2) / (2 * d2), h = Math.sqrt(r1 * r1 - a3 * a3), x05 = p1.x + a3 * (p2.x - p1.x) / d2, y05 = p1.y + a3 * (p2.y - p1.y) / d2, rx = -(p2.y - p1.y) * (h / d2), ry = -(p2.x - p1.x) * (h / d2);
    return [
      { x: x05 + rx, y: y05 - ry },
      { x: x05 - rx, y: y05 + ry }
    ];
  }
  function getCenter(points) {
    const center2 = { x: 0, y: 0 };
    for (let i = 0; i < points.length; ++i) {
      center2.x += points[i].x;
      center2.y += points[i].y;
    }
    center2.x /= points.length;
    center2.y /= points.length;
    return center2;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/utils/venn/layout.js
  function venn(areas, parameters) {
    parameters = parameters || {};
    parameters.maxIterations = parameters.maxIterations || 500;
    const initialLayout = parameters.initialLayout || bestInitialLayout;
    const loss = parameters.lossFunction || lossFunction;
    areas = addMissingAreas(areas);
    const circles = initialLayout(areas, parameters);
    const initial = [], setids = [];
    let setid;
    for (setid in circles) {
      if (circles.hasOwnProperty(setid)) {
        initial.push(circles[setid].x);
        initial.push(circles[setid].y);
        setids.push(setid);
      }
    }
    const solution = (0, import_fmin.nelderMead)(function(values) {
      const current = {};
      for (let i = 0; i < setids.length; ++i) {
        const setid2 = setids[i];
        current[setid2] = {
          x: values[2 * i],
          y: values[2 * i + 1],
          radius: circles[setid2].radius
        };
      }
      return loss(current, areas);
    }, initial, parameters);
    const positions = solution.x;
    for (let i = 0; i < setids.length; ++i) {
      setid = setids[i];
      circles[setid].x = positions[2 * i];
      circles[setid].y = positions[2 * i + 1];
    }
    return circles;
  }
  var SMALL2 = 1e-10;
  function distanceFromIntersectArea(r1, r2, overlap) {
    if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL2) {
      return Math.abs(r1 - r2);
    }
    return (0, import_fmin.bisect)(function(distance8) {
      return circleOverlap(r1, r2, distance8) - overlap;
    }, 0, r1 + r2);
  }
  function addMissingAreas(areas) {
    areas = areas.slice();
    const ids = [], pairs = {};
    let i, j, a3, b;
    for (i = 0; i < areas.length; ++i) {
      const area2 = areas[i];
      if (area2.sets.length == 1) {
        ids.push(area2.sets[0]);
      } else if (area2.sets.length == 2) {
        a3 = area2.sets[0];
        b = area2.sets[1];
        pairs[[a3, b]] = true;
        pairs[[b, a3]] = true;
      }
    }
    ids.sort((a4, b2) => {
      return a4 > b2 ? 1 : -1;
    });
    for (i = 0; i < ids.length; ++i) {
      a3 = ids[i];
      for (j = i + 1; j < ids.length; ++j) {
        b = ids[j];
        if (!([a3, b] in pairs)) {
          areas.push({ sets: [a3, b], size: 0 });
        }
      }
    }
    return areas;
  }
  function getDistanceMatrices(areas, sets, setids) {
    const distances = (0, import_fmin.zerosM)(sets.length, sets.length), constraints = (0, import_fmin.zerosM)(sets.length, sets.length);
    areas.filter(function(x3) {
      return x3.sets.length == 2;
    }).map(function(current) {
      const left2 = setids[current.sets[0]], right2 = setids[current.sets[1]], r1 = Math.sqrt(sets[left2].size / Math.PI), r2 = Math.sqrt(sets[right2].size / Math.PI), distance8 = distanceFromIntersectArea(r1, r2, current.size);
      distances[left2][right2] = distances[right2][left2] = distance8;
      let c5 = 0;
      if (current.size + 1e-10 >= Math.min(sets[left2].size, sets[right2].size)) {
        c5 = 1;
      } else if (current.size <= 1e-10) {
        c5 = -1;
      }
      constraints[left2][right2] = constraints[right2][left2] = c5;
    });
    return { distances, constraints };
  }
  function constrainedMDSGradient(x3, fxprime, distances, constraints) {
    let loss = 0, i;
    for (i = 0; i < fxprime.length; ++i) {
      fxprime[i] = 0;
    }
    for (i = 0; i < distances.length; ++i) {
      const xi = x3[2 * i], yi = x3[2 * i + 1];
      for (let j = i + 1; j < distances.length; ++j) {
        const xj = x3[2 * j], yj = x3[2 * j + 1], dij = distances[i][j], constraint = constraints[i][j];
        const squaredDistance4 = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance8 = Math.sqrt(squaredDistance4), delta = squaredDistance4 - dij * dij;
        if (constraint > 0 && distance8 <= dij || constraint < 0 && distance8 >= dij) {
          continue;
        }
        loss += 2 * delta * delta;
        fxprime[2 * i] += 4 * delta * (xi - xj);
        fxprime[2 * i + 1] += 4 * delta * (yi - yj);
        fxprime[2 * j] += 4 * delta * (xj - xi);
        fxprime[2 * j + 1] += 4 * delta * (yj - yi);
      }
    }
    return loss;
  }
  function bestInitialLayout(areas, params) {
    let initial = greedyLayout(areas, params);
    const loss = params.lossFunction || lossFunction;
    if (areas.length >= 8) {
      const constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial, areas);
      if (constrainedLoss + 1e-8 < greedyLoss) {
        initial = constrained;
      }
    }
    return initial;
  }
  function constrainedMDSLayout(areas, params) {
    params = params || {};
    const restarts = params.restarts || 10;
    const sets = [], setids = {};
    let i;
    for (i = 0; i < areas.length; ++i) {
      const area2 = areas[i];
      if (area2.sets.length == 1) {
        setids[area2.sets[0]] = sets.length;
        sets.push(area2);
      }
    }
    const matrices = getDistanceMatrices(areas, sets, setids);
    let distances = matrices.distances;
    const constraints = matrices.constraints;
    const norm = (0, import_fmin.norm2)(distances.map(import_fmin.norm2)) / distances.length;
    distances = distances.map(function(row2) {
      return row2.map(function(value2) {
        return value2 / norm;
      });
    });
    const obj = function(x3, fxprime) {
      return constrainedMDSGradient(x3, fxprime, distances, constraints);
    };
    let best, current;
    for (i = 0; i < restarts; ++i) {
      const initial = (0, import_fmin.zeros)(distances.length * 2).map(Math.random);
      current = (0, import_fmin.conjugateGradient)(obj, initial, params);
      if (!best || current.fx < best.fx) {
        best = current;
      }
    }
    const positions = best.x;
    const circles = {};
    for (i = 0; i < sets.length; ++i) {
      const set8 = sets[i];
      circles[set8.sets[0]] = {
        x: positions[2 * i] * norm,
        y: positions[2 * i + 1] * norm,
        radius: Math.sqrt(set8.size / Math.PI)
      };
    }
    if (params.history) {
      for (i = 0; i < params.history.length; ++i) {
        (0, import_fmin.scale)(params.history[i].x, norm);
      }
    }
    return circles;
  }
  function greedyLayout(areas, params) {
    const loss = params && params.lossFunction ? params.lossFunction : lossFunction;
    const circles = {}, setOverlaps = {};
    let set8;
    for (let i = 0; i < areas.length; ++i) {
      const area2 = areas[i];
      if (area2.sets.length == 1) {
        set8 = area2.sets[0];
        circles[set8] = {
          x: 1e10,
          y: 1e10,
          // rowid: circles.length, // fix to ->
          rowid: Object.keys(circles).length,
          size: area2.size,
          radius: Math.sqrt(area2.size / Math.PI)
        };
        setOverlaps[set8] = [];
      }
    }
    areas = areas.filter(function(a3) {
      return a3.sets.length == 2;
    });
    for (let i = 0; i < areas.length; ++i) {
      const current = areas[i];
      let weight2 = current.hasOwnProperty("weight") ? current.weight : 1;
      const left2 = current.sets[0], right2 = current.sets[1];
      if (current.size + SMALL2 >= Math.min(circles[left2].size, circles[right2].size)) {
        weight2 = 0;
      }
      setOverlaps[left2].push({ set: right2, size: current.size, weight: weight2 });
      setOverlaps[right2].push({ set: left2, size: current.size, weight: weight2 });
    }
    const mostOverlapped = [];
    for (set8 in setOverlaps) {
      if (setOverlaps.hasOwnProperty(set8)) {
        let size2 = 0;
        for (let i = 0; i < setOverlaps[set8].length; ++i) {
          size2 += setOverlaps[set8][i].size * setOverlaps[set8][i].weight;
        }
        mostOverlapped.push({ set: set8, size: size2 });
      }
    }
    function sortOrder(a3, b) {
      return b.size - a3.size;
    }
    mostOverlapped.sort(sortOrder);
    const positioned = {};
    function isPositioned(element) {
      return element.set in positioned;
    }
    function positionSet(point6, index4) {
      circles[index4].x = point6.x;
      circles[index4].y = point6.y;
      positioned[index4] = true;
    }
    positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);
    for (let i = 1; i < mostOverlapped.length; ++i) {
      const setIndex = mostOverlapped[i].set, overlap = setOverlaps[setIndex].filter(isPositioned);
      set8 = circles[setIndex];
      overlap.sort(sortOrder);
      if (overlap.length === 0) {
        throw "ERROR: missing pairwise overlap information";
      }
      const points = [];
      for (let j = 0; j < overlap.length; ++j) {
        const p1 = circles[overlap[j].set], d1 = distanceFromIntersectArea(set8.radius, p1.radius, overlap[j].size);
        points.push({ x: p1.x + d1, y: p1.y });
        points.push({ x: p1.x - d1, y: p1.y });
        points.push({ y: p1.y + d1, x: p1.x });
        points.push({ y: p1.y - d1, x: p1.x });
        for (let k = j + 1; k < overlap.length; ++k) {
          const p2 = circles[overlap[k].set], d2 = distanceFromIntersectArea(set8.radius, p2.radius, overlap[k].size);
          const extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p2.x, y: p2.y, radius: d2 });
          for (let l2 = 0; l2 < extraPoints.length; ++l2) {
            points.push(extraPoints[l2]);
          }
        }
      }
      let bestLoss = 1e50, bestPoint = points[0];
      for (let j = 0; j < points.length; ++j) {
        circles[setIndex].x = points[j].x;
        circles[setIndex].y = points[j].y;
        const localLoss = loss(circles, areas);
        if (localLoss < bestLoss) {
          bestLoss = localLoss;
          bestPoint = points[j];
        }
      }
      positionSet(bestPoint, setIndex);
    }
    return circles;
  }
  function lossFunction(sets, overlaps) {
    let output = 0;
    function getCircles(indices) {
      return indices.map(function(i) {
        return sets[i];
      });
    }
    for (let i = 0; i < overlaps.length; ++i) {
      const area2 = overlaps[i];
      let overlap;
      if (area2.sets.length == 1) {
        continue;
      } else if (area2.sets.length == 2) {
        const left2 = sets[area2.sets[0]], right2 = sets[area2.sets[1]];
        overlap = circleOverlap(left2.radius, right2.radius, distance7(left2, right2));
      } else {
        overlap = intersectionArea(getCircles(area2.sets));
      }
      const weight2 = area2.hasOwnProperty("weight") ? area2.weight : 1;
      output += weight2 * (overlap - area2.size) * (overlap - area2.size);
    }
    return output;
  }
  function getBoundingBox(circles) {
    const minMax = function(d2) {
      const hi = Math.max.apply(null, circles.map(function(c5) {
        return c5[d2] + c5.radius;
      })), lo = Math.min.apply(null, circles.map(function(c5) {
        return c5[d2] - c5.radius;
      }));
      return { max: hi, min: lo };
    };
    return { xRange: minMax("x"), yRange: minMax("y") };
  }
  function scaleSolution(solution, width, height, padding) {
    const circles = [], setids = [];
    for (const setid in solution) {
      if (solution.hasOwnProperty(setid)) {
        setids.push(setid);
        circles.push(solution[setid]);
      }
    }
    width -= 2 * padding;
    height -= 2 * padding;
    const bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
    if (xRange.max == xRange.min || yRange.max == yRange.min) {
      console.log("not scaling solution: zero size detected");
      return solution;
    }
    const xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
    const scaled = {};
    for (let i = 0; i < circles.length; ++i) {
      const circle3 = circles[i];
      scaled[setids[i]] = {
        radius: scaling * circle3.radius,
        x: padding + xOffset + (circle3.x - xRange.min) * scaling,
        y: padding + yOffset + (circle3.y - yRange.min) * scaling
      };
    }
    return scaled;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/utils/venn/diagram.js
  function circlePath(x3, y3, r) {
    const ret = [];
    const x05 = x3 - r;
    const y05 = y3;
    ret.push("M", x05, y05);
    ret.push("A", r, r, 0, 1, 0, x05 + 2 * r, y05);
    ret.push("A", r, r, 0, 1, 0, x05, y05);
    return ret.join(" ");
  }
  function intersectionAreaPath(circles) {
    const stats = {};
    intersectionArea(circles, stats);
    const arcs = stats.arcs;
    if (arcs.length === 0) {
      return "M 0 0";
    } else if (arcs.length == 1) {
      const circle3 = arcs[0].circle;
      return circlePath(circle3.x, circle3.y, circle3.radius);
    } else {
      const ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
      for (let i = 0; i < arcs.length; ++i) {
        const arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;
        ret.push("\nA", r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);
      }
      return ret.join(" ");
    }
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/venn.js
  var Venn = (options) => {
    const { sets = "sets", size: size2 = "size", as = ["key", "path"], padding = 0 } = options;
    const [key, path2] = as;
    return (data2) => {
      const vennData = data2.map((d2) => Object.assign(Object.assign({}, d2), { sets: d2[sets], size: d2[size2], [key]: d2.sets.join("&") }));
      vennData.sort((a3, b) => a3.sets.length - b.sets.length);
      const solution = venn(vennData);
      let circles;
      return vennData.map((datum) => {
        const setsValue = datum[sets];
        const pathFunc = ({ width, height }) => {
          circles = circles ? circles : scaleSolution(solution, width, height, padding);
          const setCircles = setsValue.map((set8) => circles[set8]);
          let p2 = intersectionAreaPath(setCircles);
          if (!/[zZ]$/.test(p2))
            p2 += " Z";
          return p2;
        };
        return Object.assign(Object.assign({}, datum), { [path2]: pathFunc });
      });
    };
  };
  Venn.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/data/log.js
  var Log3 = () => {
    return (data2) => {
      console.log("G2 data section:", data2);
      return data2;
    };
  };
  Log3.props = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/bounds.js
  function parseAABB(min22) {
    const { min: min10, max: max10 } = min22;
    return [
      [min10[0], min10[1]],
      [max10[0], max10[1]]
    ];
  }
  function isInBounds(point6, bounds) {
    const [x3, y3] = point6;
    const [min10, max10] = bounds;
    return x3 >= min10[0] && x3 <= max10[0] && y3 >= min10[1] && y3 <= max10[1];
  }
  function isOverflow(b1, b2) {
    const [min10, max10] = b1;
    return !(isInBounds(min10, b2) && isInBounds(max10, b2));
  }
  function isOverlap(b1, b2) {
    const [min1, max1] = b1;
    const [min22, max22] = b2;
    return min1[0] < max22[0] && max1[0] > min22[0] && min1[1] < max22[1] && max1[1] > min22[1];
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/label-transform/overlapHide.js
  var OverlapHide = (options) => {
    const { priority } = options;
    return (labels) => {
      const displayLabels = [];
      if (priority)
        labels.sort(priority);
      labels.forEach((l2) => {
        show2(l2);
        const b1 = l2.getLocalBounds();
        const overlaping = displayLabels.some((dl) => isOverlap(parseAABB(b1), parseAABB(dl.getLocalBounds())));
        if (overlaping)
          hide2(l2);
        else
          displayLabels.push(l2);
      });
      return labels;
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/label-transform/overlapDodgeY.js
  function isSegmentIntersect([a3, b], [c5, d2]) {
    return d2 > a3 && b > c5;
  }
  function useMap() {
    const map3 = /* @__PURE__ */ new Map();
    const get2 = (key) => map3.get(key);
    const set8 = (key, value2) => map3.set(key, value2);
    return [get2, set8];
  }
  function getBoundsWithoutConnector(shape23) {
    const node = shape23.cloneNode(true);
    const connectorShape = node.getElementById("connector");
    connectorShape && node.removeChild(connectorShape);
    const { min: min10, max: max10 } = node.getRenderBounds();
    node.destroy();
    return { min: min10, max: max10 };
  }
  var OverlapDodgeY = (options) => {
    const { maxIterations = 10, maxError = 0.1, padding = 1 } = options;
    return (labels) => {
      const n2 = labels.length;
      if (n2 <= 1)
        return labels;
      const [y05, setY0] = useMap();
      const [y3, setY] = useMap();
      const [h, setH] = useMap();
      const [xx, setXX] = useMap();
      for (const label of labels) {
        const { min: min10, max: max10 } = getBoundsWithoutConnector(label);
        const [x05, y06] = min10;
        const [x12, y12] = max10;
        setY0(label, y06);
        setY(label, y06);
        setH(label, y12 - y06);
        setXX(label, [x05, x12]);
      }
      for (let iter = 0; iter < maxIterations; iter++) {
        labels.sort((a3, b) => ascending(y3(a3), y3(b)));
        let error4 = 0;
        for (let i = 0; i < n2 - 1; i++) {
          const l0 = labels[i];
          let j = i + 1;
          let l1;
          while ((l1 = labels[j]) && !isSegmentIntersect(xx(l0), xx(l1)))
            j += 1;
          if (l1) {
            const y06 = y3(l0);
            const h0 = h(l0);
            const y12 = y3(l1);
            const delta = y12 - (y06 + h0);
            if (delta < padding) {
              const newDelta = (padding - delta) / 2;
              error4 = Math.max(error4, newDelta);
              setY(l0, y06 - newDelta);
              setY(l1, y12 + newDelta);
            }
          }
        }
        if (error4 < maxError)
          break;
      }
      for (const label of labels) {
        label.style.y += y3(label) - y05(label);
      }
      return labels;
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/color.js
  function parseToRGB(c5) {
    if (typeof c5 === "object")
      return c5;
    return parseColor(c5);
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/label-transform/contrastReverse.js
  function getsRGB(s2) {
    let c5 = s2 / 255;
    c5 = c5 <= 0.03928 ? c5 / 12.92 : Math.pow((c5 + 0.055) / 1.055, 2.4);
    return c5;
  }
  function getL(r, g, b) {
    return 0.2126 * getsRGB(r) + 0.7152 * getsRGB(g) + 0.0722 * getsRGB(b);
  }
  function contrast(foreground, background) {
    const { r, g, b } = foreground;
    const { r: rb, g: gb, b: bb } = background;
    const L1 = getL(r, g, b);
    const L2 = getL(rb, gb, bb);
    return (Math.max(L1, L2) + 0.05) / (Math.min(L1, L2) + 0.05);
  }
  function mostContrast(color2, palette) {
    const i = maxIndex(palette, (c5) => contrast(color2, parseToRGB(c5)));
    return palette[i];
  }
  var ContrastReverse = (options) => {
    const { threshold = 4.5, palette = ["#000", "#fff"] } = options;
    return (labels) => {
      labels.forEach((l2) => {
        const background = l2.attr("dependentElement").parsedStyle.fill;
        const foreground = l2.parsedStyle.fill;
        const c5 = contrast(foreground, background);
        if (c5 < threshold)
          l2.attr("fill", mostContrast(background, palette));
      });
      return labels;
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/label-transform/overflowHide.js
  var OverflowHide = () => {
    return (labels) => {
      labels.forEach((l2) => {
        show2(l2);
        const bounds = l2.attr("bounds");
        const b = l2.getLocalBounds();
        const overflow = isOverflow(parseAABB(b), bounds);
        if (overflow)
          hide2(l2);
      });
      return labels;
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/label-transform/exceedAdjust.js
  var adjustPosition = (target, edge) => {
    const [[minEdgeX, minEdgeY], [maxEdgeX, maxEdgeY]] = edge;
    const [[minX, minY], [maxX, maxY2]] = target;
    let changeX = 0, changeY = 0;
    if (minX < minEdgeX) {
      changeX = minEdgeX - minX;
    } else if (maxX > maxEdgeX) {
      changeX = maxEdgeX - maxX;
    }
    if (minY < minEdgeY) {
      changeY = minEdgeY - minY;
    } else if (maxY2 > maxEdgeY) {
      changeY = maxEdgeY - maxY2;
    }
    return [changeX, changeY];
  };
  var ExceedAdjust = () => {
    return (labels, { canvas }) => {
      const { width, height } = canvas.getConfig();
      labels.forEach((l2) => {
        show2(l2);
        const { max: max10, min: min10 } = l2.getRenderBounds();
        const [xMax, yMax] = max10, [xMin, yMin] = min10;
        const changeValue = adjustPosition([
          [xMin, yMin],
          [xMax, yMax]
        ], [
          [0, 0],
          [width, height]
        ]);
        if (l2.style.connector && l2.style.connectorPoints) {
          l2.style.connectorPoints[0][0] -= changeValue[0];
          l2.style.connectorPoints[0][1] -= changeValue[1];
        }
        l2.style.x += changeValue[0];
        l2.style.y += changeValue[1];
      });
      return labels;
    };
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/lib/core.js
  function corelib() {
    return {
      "data.fetch": Fetch,
      "data.inline": Inline,
      "data.sortBy": SortBy,
      "data.sort": Sort2,
      "data.filter": Filter2,
      "data.pick": Pick,
      "data.rename": Rename,
      "data.fold": Fold,
      "data.slice": Slice,
      "data.custom": Custom,
      "data.map": Map2,
      "data.join": Join,
      "data.kde": KDE,
      "data.log": Log3,
      "data.wordCloud": WordCloud2,
      "transform.stackY": StackY,
      "transform.binX": BinX,
      "transform.bin": Bin,
      "transform.dodgeX": DodgeX,
      "transform.jitter": Jitter,
      "transform.jitterX": JitterX,
      "transform.jitterY": JitterY,
      "transform.symmetryY": SymmetryY,
      "transform.diffY": DiffY,
      "transform.stackEnter": StackEnter,
      "transform.normalizeY": NormalizeY,
      "transform.select": Select,
      "transform.selectX": SelectX,
      "transform.selectY": SelectY,
      "transform.groupX": GroupX,
      "transform.groupY": GroupY,
      "transform.groupColor": GroupColor,
      "transform.group": Group,
      "transform.sortX": SortX,
      "transform.sortY": SortY,
      "transform.sortColor": SortColor,
      "transform.flexX": FlexX,
      "transform.pack": Pack,
      "transform.sample": Sample,
      "transform.filter": Filter,
      "coordinate.cartesian": Cartesian,
      "coordinate.polar": Polar,
      "coordinate.transpose": Transpose,
      "coordinate.theta": Theta,
      "coordinate.parallel": Parallel,
      "coordinate.fisheye": Fisheye,
      "coordinate.radial": Radial,
      "coordinate.radar": Radar,
      "encode.constant": Constant,
      "encode.field": Field,
      "encode.transform": Transform,
      "encode.column": Column,
      "mark.interval": Interval2,
      "mark.rect": Rect3,
      "mark.line": Line5,
      "mark.point": Point4,
      "mark.text": Text4,
      "mark.cell": Cell,
      "mark.area": Area2,
      "mark.link": Link2,
      "mark.image": Image4,
      "mark.polygon": Polygon3,
      "mark.box": Box2,
      "mark.vector": Vector2,
      "mark.lineX": LineX,
      "mark.lineY": LineY,
      "mark.connector": Connector2,
      "mark.range": Range,
      "mark.rangeX": RangeX,
      "mark.rangeY": RangeY,
      "mark.path": Path4,
      "mark.shape": Shape3,
      "mark.density": Density2,
      "mark.heatmap": Heatmap2,
      "mark.wordCloud": WordCloud,
      "palette.category10": Category10,
      "palette.category20": Category20,
      "scale.linear": Linear4,
      "scale.ordinal": Ordinal3,
      "scale.band": Band3,
      "scale.identity": Identity2,
      "scale.point": Point5,
      "scale.time": Time2,
      "scale.log": Log2,
      "scale.pow": Pow2,
      "scale.sqrt": Sqrt2,
      "scale.threshold": Threshold2,
      "scale.quantile": Quantile2,
      "scale.quantize": Quantize2,
      "scale.sequential": Sequential3,
      "scale.constant": Constant3,
      "theme.classic": Classic,
      "theme.classicDark": ClassicDark,
      "theme.academy": Academy,
      "theme.light": Light,
      "theme.dark": Dark,
      "component.axisX": AxisX,
      "component.axisY": AxisY,
      "component.legendCategory": LegendCategory,
      "component.legendContinuous": LegendContinuous,
      "component.legends": Legends,
      "component.title": TitleComponent,
      "component.sliderX": SliderX,
      "component.sliderY": SliderY,
      "component.scrollbarX": ScrollbarX,
      "component.scrollbarY": ScrollbarY,
      "animation.scaleInX": ScaleInX,
      "animation.scaleOutX": ScaleOutX,
      "animation.scaleInY": ScaleInY,
      "animation.scaleOutY": ScaleOutY,
      "animation.waveIn": WaveIn,
      "animation.fadeIn": FadeIn,
      "animation.fadeOut": FadeOut,
      "animation.zoomIn": ZoomIn,
      "animation.zoomOut": ZoomOut,
      "animation.pathIn": PathIn,
      "animation.morphing": Morphing,
      "animation.growInX": GrowInX,
      "animation.growInY": GrowInY,
      "interaction.elementHighlight": ElementHighlight,
      "interaction.elementHighlightByX": ElementHighlightByX,
      "interaction.elementHighlightByColor": ElementHighlightByColor,
      "interaction.elementSelect": ElementSelect,
      "interaction.elementSelectByX": ElementSelectByX,
      "interaction.elementSelectByColor": ElementSelectByColor,
      "interaction.fisheye": Fisheye2,
      "interaction.chartIndex": ChartIndex,
      "interaction.tooltip": Tooltip2,
      "interaction.legendFilter": LegendFilter,
      "interaction.legendHighlight": LegendHighlight,
      "interaction.brushHighlight": BrushHighlight,
      "interaction.brushXHighlight": BrushXHighlight,
      "interaction.brushYHighlight": BrushYHighlight,
      "interaction.brushAxisHighlight": BrushAxisHighlight,
      "interaction.brushFilter": BrushFilter,
      "interaction.brushXFilter": BrushXFilter,
      "interaction.brushYFilter": BrushYFilter,
      "interaction.sliderFilter": SliderFilter,
      "interaction.scrollbarFilter": ScrollbarFilter,
      "interaction.poptip": Poptip,
      "interaction.treemapDrillDown": TreemapDrillDown,
      "interaction.elementPointMove": ElementPointMove,
      "composition.spaceLayer": SpaceLayer,
      "composition.spaceFlex": SpaceFlex,
      "composition.facetRect": FacetRect,
      "composition.repeatMatrix": RepeatMatrix,
      "composition.facetCircle": FacetCircle,
      "composition.timingKeyframe": TimingKeyframe,
      "labelTransform.overlapHide": OverlapHide,
      "labelTransform.overlapDodgeY": OverlapDodgeY,
      "labelTransform.overflowHide": OverflowHide,
      "labelTransform.contrastReverse": ContrastReverse,
      "labelTransform.exceedAdjust": ExceedAdjust
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/lib/geo.js
  function geolib() {
    return {
      "composition.geoView": GeoView,
      "composition.geoPath": GeoPath
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/lib/graph.js
  function graphlib() {
    return {
      "data.arc": Arc3,
      "data.cluster": Cluster,
      "mark.forceGraph": ForceGraph,
      "mark.tree": Tree2,
      "mark.pack": Pack2,
      "mark.sankey": Sankey3,
      "mark.chord": Chord,
      "mark.treemap": Treemap
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/lib/plot.js
  function plotlib() {
    return {
      "data.venn": Venn,
      "mark.boxplot": Boxplot,
      "mark.gauge": Gauge,
      "mark.wordCloud": WordCloud,
      "mark.liquid": Liquid2
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/lib/std.js
  function stdlib() {
    return Object.assign(Object.assign(Object.assign(Object.assign({}, geolib()), graphlib()), plotlib()), corelib());
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/api/extend.js
  function extend6(Runtime2, library3) {
    class Chart2 extends Runtime2 {
      constructor(options) {
        super(Object.assign(Object.assign({}, options), { lib: library3 }));
      }
    }
    return Chart2;
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/api/library.js
  var library = {};

  // ../../engine/rails_design/node_modules/@antv/g2/esm/utils/size.js
  var parseInt10 = (d2) => d2 ? parseInt(d2) : 0;
  function getContainerSize(container) {
    const style = getComputedStyle(container);
    const wrapperWidth = container.clientWidth || parseInt10(style.width);
    const wrapperHeight = container.clientHeight || parseInt10(style.height);
    const widthPadding = parseInt10(style.paddingLeft) + parseInt10(style.paddingRight);
    const heightPadding = parseInt10(style.paddingTop) + parseInt10(style.paddingBottom);
    return {
      width: wrapperWidth - widthPadding,
      height: wrapperHeight - heightPadding
    };
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/api/node.js
  function bfs(node, callback) {
    const discovered = [node];
    while (discovered.length) {
      const currentNode = discovered.shift();
      callback && callback(currentNode);
      const children = currentNode.children || [];
      for (const child of children) {
        discovered.push(child);
      }
    }
  }
  var Node5 = class {
    constructor(value2 = {}, type) {
      this.parentNode = null;
      this.children = [];
      this.index = 0;
      this.type = type;
      this.value = value2;
    }
    /**
     * Apply specified transform to current value. Mount the node
     * to replace the original one in the tree and then return it.
     */
    map(transform = (x3) => x3) {
      const newValue = transform(this.value);
      this.value = newValue;
      return this;
    }
    /**
     * Set or get the specified attribute. It the value is specified, update
     * the attribute of current value and return the node. Otherwise
     * return the the attribute of current value.
     */
    attr(key, value2) {
      if (arguments.length === 1)
        return this.value[key];
      return this.map((v) => (v[key] = value2, v));
    }
    /**
     * Create a new node and append to children nodes.
     */
    append(Ctor) {
      const node = new Ctor({});
      node.children = [];
      this.push(node);
      return node;
    }
    push(node) {
      node.parentNode = this;
      node.index = this.children.length;
      this.children.push(node);
      return this;
    }
    /**
     * Remove current node from parentNode.
     */
    remove() {
      const parent = this.parentNode;
      if (parent) {
        const { children } = parent;
        const index4 = children.findIndex((item) => item === this);
        children.splice(index4, 1);
      }
      return this;
    }
    getNodeByKey(key) {
      let targetNode = null;
      const callback = (node) => {
        if (key === node.attr("key")) {
          targetNode = node;
        }
      };
      bfs(this, callback);
      return targetNode;
    }
    getNodesByType(type) {
      const nodes = [];
      const callback = (node) => {
        if (type === node.type) {
          nodes.push(node);
        }
      };
      bfs(this, callback);
      return nodes;
    }
    getNodeByType(type) {
      let node = null;
      bfs(this, (current) => {
        if (node)
          return;
        if (type === current.type)
          node = current;
      });
      return node;
    }
    /**
     * Apply specified callback to the node value.
     */
    call(callback, ...params) {
      callback(this.map(), ...params);
      return this;
    }
    getRoot() {
      let root2 = this;
      while (root2 && root2.parentNode) {
        root2 = root2.parentNode;
      }
      return root2;
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/api/utils.js
  var __rest89 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var VIEW_KEYS = [
    "width",
    "height",
    "depth",
    "padding",
    "paddingLeft",
    "paddingRight",
    "paddingBottom",
    "paddingTop",
    "inset",
    "insetLeft",
    "insetRight",
    "insetTop",
    "insetBottom",
    "margin",
    "marginLeft",
    "marginRight",
    "marginTop",
    "marginBottom",
    "autoFit",
    "theme",
    "title"
  ];
  var REMOVE_FLAG = "__remove__";
  var CALLBACK_NODE = "__callback__";
  var MIN_CHART_WIDTH = 1;
  var MIN_CHART_HEIGHT = 1;
  function normalizeContainer2(container) {
    if (container === void 0) {
      const container2 = document.createElement("div");
      container2[REMOVE_FLAG] = true;
      return container2;
    }
    if (typeof container === "string") {
      const node = document.getElementById(container);
      return node;
    }
    return container;
  }
  function removeContainer(container) {
    const parent = container.parentNode;
    if (parent) {
      parent.removeChild(container);
    }
  }
  function normalizeRoot(node) {
    if (node.type !== null)
      return node;
    const root2 = node.children[node.children.length - 1];
    for (const key of VIEW_KEYS)
      root2.attr(key, node.attr(key));
    return root2;
  }
  function valueOf3(node) {
    return Object.assign(Object.assign({}, node.value), { type: node.type });
  }
  function sizeOf2(options, container) {
    const { width, height, autoFit, depth = 0 } = options;
    let effectiveWidth = 640;
    let effectiveHeight = 480;
    if (autoFit) {
      const { width: containerWidth, height: containerHeight } = getContainerSize(container);
      effectiveWidth = containerWidth || effectiveWidth;
      effectiveHeight = containerHeight || effectiveHeight;
    }
    effectiveWidth = width || effectiveWidth;
    effectiveHeight = height || effectiveHeight;
    return {
      width: Math.max(is_number_default(effectiveWidth) ? effectiveWidth : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
      height: Math.max(is_number_default(effectiveHeight) ? effectiveHeight : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT),
      depth
    };
  }
  function optionsOf(node) {
    const root2 = normalizeRoot(node);
    const discovered = [root2];
    const nodeValue = /* @__PURE__ */ new Map();
    nodeValue.set(root2, valueOf3(root2));
    while (discovered.length) {
      const node2 = discovered.pop();
      const value2 = nodeValue.get(node2);
      const { children = [] } = node2;
      for (const child of children) {
        if (child.type === CALLBACK_NODE) {
          value2.children = child.value;
        } else {
          const childValue = valueOf3(child);
          const { children: children2 = [] } = value2;
          children2.push(childValue);
          discovered.push(child);
          nodeValue.set(child, childValue);
          value2.children = children2;
        }
      }
    }
    return nodeValue.get(root2);
  }
  function isMark(type, mark) {
    if (typeof type === "function")
      return true;
    return new Set(Object.keys(mark)).has(type);
  }
  function isComposition(type, composition) {
    return typeof type !== "function" && new Set(Object.keys(composition)).has(type);
  }
  function normalizeRootOptions(node, options, previousType, marks, composition) {
    const { type: oldType } = node;
    const { type = previousType || oldType } = options;
    if (isComposition(type, composition)) {
      for (const key of VIEW_KEYS) {
        if (node.attr(key) !== void 0 && options[key] === void 0) {
          options[key] = node.attr(key);
        }
      }
      return options;
    }
    if (isMark(type, marks)) {
      const view = { type: "view" };
      const mark = Object.assign({}, options);
      for (const key of VIEW_KEYS) {
        if (mark[key] !== void 0) {
          view[key] = mark[key];
          delete mark[key];
        }
      }
      return Object.assign(Object.assign({}, view), { children: [mark] });
    }
    return options;
  }
  function typeCtor(type, mark, composition) {
    if (typeof type === "function")
      return mark.mark;
    const node = Object.assign(Object.assign({}, mark), composition);
    const ctor = node[type];
    if (!ctor)
      throw new Error(`Unknown mark: ${type}.`);
    return ctor;
  }
  function createNode(options, mark, composition) {
    if (typeof options === "function") {
      const node2 = new Node5();
      node2.value = options;
      node2.type = CALLBACK_NODE;
      return node2;
    }
    const { type, children } = options, value2 = __rest89(options, ["type", "children"]);
    const Ctor = typeCtor(type, mark, composition);
    const node = new Ctor();
    node.value = value2;
    node.type = type;
    return node;
  }
  function updateNode(node, newOptions) {
    const { type, children } = newOptions, value2 = __rest89(newOptions, ["type", "children"]);
    if (node.type === type || type === void 0) {
      deepAssign(node.value, value2);
    } else if (typeof type === "string") {
      node.type = type;
      node.value = value2;
    }
  }
  function appendNode(parent, newOptions, mark, composition) {
    if (!parent)
      return;
    const discovered = [[parent, newOptions]];
    while (discovered.length) {
      const [parent2, nodeOptions] = discovered.shift();
      const node = createNode(nodeOptions, mark, composition);
      if (Array.isArray(parent2.children))
        parent2.push(node);
      const { children } = nodeOptions;
      if (Array.isArray(children)) {
        for (const child of children) {
          discovered.push([node, child]);
        }
      } else if (typeof children === "function") {
        discovered.push([node, children]);
      }
    }
  }
  function updateRoot(node, options, definedType, mark, composition) {
    const rootOptions = normalizeRootOptions(node, options, definedType, mark, composition);
    const discovered = [[null, node, rootOptions]];
    while (discovered.length) {
      const [parent, oldNode, newNode] = discovered.shift();
      if (!oldNode) {
        appendNode(parent, newNode, mark, composition);
      } else if (!newNode) {
        oldNode.remove();
      } else {
        updateNode(oldNode, newNode);
        const { children: newChildren } = newNode;
        const { children: oldChildren } = oldNode;
        if (Array.isArray(newChildren) && Array.isArray(oldChildren)) {
          const n2 = Math.max(newChildren.length, oldChildren.length);
          for (let i = 0; i < n2; i++) {
            const newChild = newChildren[i];
            const oldChild = oldChildren[i];
            discovered.push([oldNode, oldChild, newChild]);
          }
        } else if (typeof newChildren === "function") {
          discovered.push([oldNode, null, newChildren]);
        }
      }
    }
  }
  function createEmptyPromise() {
    let reject;
    let resolve;
    const cloned = new Promise((res, rej) => {
      resolve = res;
      reject = rej;
    });
    return [cloned, resolve, reject];
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/api/define.js
  function defineValueProp(Node6, name2, { key = name2 }) {
    Node6.prototype[name2] = function(value2) {
      if (arguments.length === 0)
        return this.attr(key);
      return this.attr(key, value2);
    };
  }
  function defineArrayProp(Node6, name2, { key = name2 }) {
    Node6.prototype[name2] = function(value2) {
      if (arguments.length === 0)
        return this.attr(key);
      if (Array.isArray(value2))
        return this.attr(key, value2);
      const array2 = [...this.attr(key) || [], value2];
      return this.attr(key, array2);
    };
  }
  function defineObjectProp(Node6, name2, { key: k = name2 }) {
    Node6.prototype[name2] = function(key, value2) {
      if (arguments.length === 0)
        return this.attr(k);
      if (arguments.length === 1 && typeof key !== "string") {
        return this.attr(k, key);
      }
      const obj = this.attr(k) || {};
      obj[key] = arguments.length === 1 ? true : value2;
      return this.attr(k, obj);
    };
  }
  function defineMixProp(Node6, name2, descriptor) {
    Node6.prototype[name2] = function(key) {
      if (arguments.length === 0)
        return this.attr(name2);
      if (Array.isArray(key))
        return this.attr(name2, { items: key });
      if (isStrictObject(key) && (key.title !== void 0 || key.items !== void 0)) {
        return this.attr(name2, key);
      }
      if (key === null || key === false)
        return this.attr(name2, key);
      const obj = this.attr(name2) || {};
      const { items = [] } = obj;
      items.push(key);
      obj.items = items;
      return this.attr(name2, obj);
    };
  }
  function defineNodeProp(Node6, name2, { ctor }) {
    Node6.prototype[name2] = function(hocMark) {
      const node = this.append(ctor);
      if (name2 === "mark") {
        node.type = hocMark;
      }
      return node;
    };
  }
  function defineContainerProp(Node6, name2, { ctor }) {
    Node6.prototype[name2] = function() {
      this.type = null;
      return this.append(ctor);
    };
  }
  function defineProps(descriptors) {
    return (Node6) => {
      for (const [name2, descriptor] of Object.entries(descriptors)) {
        const { type } = descriptor;
        if (type === "value")
          defineValueProp(Node6, name2, descriptor);
        else if (type === "array")
          defineArrayProp(Node6, name2, descriptor);
        else if (type === "object")
          defineObjectProp(Node6, name2, descriptor);
        else if (type === "node")
          defineNodeProp(Node6, name2, descriptor);
        else if (type === "container")
          defineContainerProp(Node6, name2, descriptor);
        else if (type === "mix")
          defineMixProp(Node6, name2, descriptor);
      }
      return Node6;
    };
  }
  function nodeProps(node) {
    return Object.fromEntries(Object.entries(node).map(([name2, ctor]) => [name2, { type: "node", ctor }]));
  }

  // ../../engine/rails_design/node_modules/@antv/g2/esm/api/props.js
  var commonProps = {
    encode: { type: "object" },
    scale: { type: "object" },
    data: { type: "value" },
    transform: { type: "array" },
    style: { type: "object" },
    animate: { type: "object" },
    coordinate: { type: "object" },
    interaction: { type: "object" },
    label: { type: "array", key: "labels" },
    axis: { type: "object" },
    legend: { type: "object" },
    slider: { type: "object" },
    scrollbar: { type: "object" },
    state: { type: "object" },
    layout: { type: "object" },
    theme: { type: "object" },
    title: { type: "value" }
  };
  var markProps = Object.assign(Object.assign({}, commonProps), { tooltip: { type: "mix" }, viewStyle: { type: "object" } });
  var compositionProps = Object.assign(Object.assign({}, commonProps), { labelTransform: { type: "array" } });

  // ../../engine/rails_design/node_modules/@antv/g2/esm/api/composition.js
  var __decorate2 = function(decorators, target, key, desc) {
    var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r = (c5 < 3 ? d2(r) : c5 > 3 ? d2(target, key, r) : d2(target, key)) || r;
    return c5 > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var CompositionNode = class CompositionNode2 extends Node5 {
    /**
     * Change current node data and its children data.
     */
    changeData(data2) {
      var _a;
      const chart = this.getRoot();
      if (!chart)
        return;
      this.attr("data", data2);
      if ((_a = this.children) === null || _a === void 0 ? void 0 : _a.length) {
        this.children.forEach((child) => {
          child.attr("data", data2);
        });
      }
      return chart === null || chart === void 0 ? void 0 : chart.render();
    }
    /**
     * Get view instance by key.
     */
    getView() {
      const chart = this.getRoot();
      const { views } = chart.getContext();
      if (!(views === null || views === void 0 ? void 0 : views.length))
        return void 0;
      return views.find((view) => view.key === this._key);
    }
    getScale() {
      var _a;
      return (_a = this.getView()) === null || _a === void 0 ? void 0 : _a.scale;
    }
    getScaleByChannel(channel) {
      const scale9 = this.getScale();
      if (scale9)
        return scale9[channel];
      return;
    }
    getCoordinate() {
      var _a;
      return (_a = this.getView()) === null || _a === void 0 ? void 0 : _a.coordinate;
    }
    getTheme() {
      var _a;
      return (_a = this.getView()) === null || _a === void 0 ? void 0 : _a.theme;
    }
    getGroup() {
      const key = this._key;
      if (!key)
        return void 0;
      const chart = this.getRoot();
      const chartGroup = chart.getContext().canvas.getRoot();
      return chartGroup.getElementById(key);
    }
    /**
     * Show the view.
     */
    show() {
      const group3 = this.getGroup();
      if (!group3)
        return;
      !group3.isVisible() && show2(group3);
    }
    /**
     * Hide the view.
     */
    hide() {
      const group3 = this.getGroup();
      if (!group3)
        return;
      group3.isVisible() && hide2(group3);
    }
  };
  CompositionNode = __decorate2([
    defineProps(compositionProps)
  ], CompositionNode);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/api/mark.js
  var __decorate3 = function(decorators, target, key, desc) {
    var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r = (c5 < 3 ? d2(r) : c5 > 3 ? d2(target, key, r) : d2(target, key)) || r;
    return c5 > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var MarkNode = class MarkNode2 extends Node5 {
    changeData(data2) {
      const chart = this.getRoot();
      if (!chart)
        return;
      this.attr("data", data2);
      return chart === null || chart === void 0 ? void 0 : chart.render();
    }
    /**
     * Get mark from chart views.
     */
    getMark() {
      var _a;
      const chartView = (_a = this.getRoot()) === null || _a === void 0 ? void 0 : _a.getView();
      if (!chartView)
        return void 0;
      const { markState } = chartView;
      const markKey = Array.from(markState.keys()).find((item) => item.key === this.attr("key"));
      return markState.get(markKey);
    }
    /**
     * Get all scales instance.
     */
    getScale() {
      var _a;
      const chartView = (_a = this.getRoot()) === null || _a === void 0 ? void 0 : _a.getView();
      if (!chartView)
        return void 0;
      return chartView === null || chartView === void 0 ? void 0 : chartView.scale;
    }
    /**
     * Get the scale instance by channel.
     */
    getScaleByChannel(channel) {
      var _a, _b;
      const chartView = (_a = this.getRoot()) === null || _a === void 0 ? void 0 : _a.getView();
      if (!chartView)
        return void 0;
      return (_b = chartView === null || chartView === void 0 ? void 0 : chartView.scale) === null || _b === void 0 ? void 0 : _b[channel];
    }
    /**
     * Get canvas group.
     */
    getGroup() {
      const key = this.attr("key");
      if (!key)
        return void 0;
      const chart = this.getRoot();
      const chartGroup = chart.getContext().canvas.getRoot();
      return chartGroup.getElementById(key);
    }
  };
  MarkNode = __decorate3([
    defineProps(markProps)
  ], MarkNode);

  // ../../engine/rails_design/node_modules/@antv/g2/esm/api/runtime.js
  var __decorate4 = function(decorators, target, key, desc) {
    var c5 = arguments.length, r = c5 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r = (c5 < 3 ? d2(r) : c5 > 3 ? d2(target, key, r) : d2(target, key)) || r;
    return c5 > 3 && r && Object.defineProperty(target, key, r), r;
  };
  var __rest90 = function(s2, e3) {
    var t = {};
    for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t[p2] = s2[p2];
    if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
        if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
          t[p2[i]] = s2[p2[i]];
      }
    return t;
  };
  var G2_CHART_KEY = "G2_CHART_KEY";
  var Runtime = class extends CompositionNode {
    constructor(options) {
      const { container, canvas, renderer, plugins: plugins2, lib, createCanvas } = options, rest = __rest90(options, ["container", "canvas", "renderer", "plugins", "lib", "createCanvas"]);
      super(rest, "view");
      this._hasBindAutoFit = false;
      this._rendering = false;
      this._trailing = false;
      this._trailingResolve = null;
      this._trailingReject = null;
      this._previousDefinedType = null;
      this._onResize = debounce_default(() => {
        this.forceFit();
      }, 300);
      this._renderer = renderer || new Renderer2();
      this._plugins = plugins2 || [];
      this._container = normalizeContainer2(container);
      this._emitter = new esm_default();
      this._context = {
        library: Object.assign(Object.assign({}, lib), library),
        emitter: this._emitter,
        canvas,
        createCanvas
      };
      this._create();
    }
    render() {
      if (this._rendering)
        return this._addToTrailing();
      if (!this._context.canvas)
        this._createCanvas();
      this._context.canvas.getConfig().supportsCSSTransform = true;
      this._bindAutoFit();
      this._rendering = true;
      const finished = new Promise((resolve2, reject2) => render(this._computedOptions(), this._context, this._createResolve(resolve2), this._createReject(reject2)));
      const [finished1, resolve, reject] = createEmptyPromise();
      finished.then(resolve).catch(reject).then(() => this._renderTrailing());
      return finished1;
    }
    /**
     * @overload
     * @param {G2ViewTree} [options]
     * @returns {Runtime|Spec}
     */
    options(options) {
      if (arguments.length === 0)
        return optionsOf(this);
      const { type } = options;
      if (type)
        this._previousDefinedType = type;
      updateRoot(this, options, this._previousDefinedType, this._marks, this._compositions);
      return this;
    }
    getContainer() {
      return this._container;
    }
    getContext() {
      return this._context;
    }
    on(event, callback, once) {
      this._emitter.on(event, callback, once);
      return this;
    }
    once(event, callback) {
      this._emitter.once(event, callback);
      return this;
    }
    emit(event, ...args) {
      this._emitter.emit(event, ...args);
      return this;
    }
    off(event, callback) {
      this._emitter.off(event, callback);
      return this;
    }
    clear() {
      const options = this.options();
      this.emit(ChartEvent.BEFORE_CLEAR);
      this._reset();
      destroy2(options, this._context, false);
      this.emit(ChartEvent.AFTER_CLEAR);
    }
    destroy() {
      const options = this.options();
      this.emit(ChartEvent.BEFORE_DESTROY);
      this._unbindAutoFit();
      this._reset();
      destroy2(options, this._context, true);
      if (this._container[REMOVE_FLAG])
        removeContainer(this._container);
      this.emit(ChartEvent.AFTER_DESTROY);
    }
    forceFit() {
      this.options["autoFit"] = true;
      const { width, height } = sizeOf2(this.options(), this._container);
      if (width === this._width && height === this._height) {
        return Promise.resolve(this);
      }
      this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
      const finished = this.render();
      finished.then(() => {
        this.emit(ChartEvent.AFTER_CHANGE_SIZE);
      });
      return finished;
    }
    changeSize(width, height) {
      if (width === this._width && height === this._height) {
        return Promise.resolve(this);
      }
      this.emit(ChartEvent.BEFORE_CHANGE_SIZE);
      this.attr("width", width);
      this.attr("height", height);
      const finished = this.render();
      finished.then(() => {
        this.emit(ChartEvent.AFTER_CHANGE_SIZE);
      });
      return finished;
    }
    _create() {
      const { library: library3 } = this._context;
      const isMark2 = (key) => key.startsWith("mark.") || key === "component.axisX" || key === "component.axisY" || key === "component.legends";
      const marks = [
        "mark.mark",
        ...Object.keys(library3).filter(isMark2)
      ];
      this._marks = {};
      for (const key of marks) {
        const name2 = key.split(".").pop();
        class Mark2 extends MarkNode {
          constructor() {
            super({}, name2);
          }
        }
        this._marks[name2] = Mark2;
        this[name2] = function(composite) {
          const node = this.append(Mark2);
          if (name2 === "mark")
            node.type = composite;
          return node;
        };
      }
      const compositions = [
        "composition.view",
        ...Object.keys(library3).filter((key) => key.startsWith("composition.") && key !== "composition.mark")
      ];
      this._compositions = Object.fromEntries(compositions.map((key) => {
        const name2 = key.split(".").pop();
        let Composition = class Composition extends CompositionNode {
          constructor() {
            super({}, name2);
          }
        };
        Composition = __decorate4([
          defineProps(nodeProps(this._marks))
        ], Composition);
        return [name2, Composition];
      }));
      for (const Ctor of Object.values(this._compositions)) {
        defineProps(nodeProps(this._compositions))(Ctor);
      }
      for (const key of compositions) {
        const name2 = key.split(".").pop();
        this[name2] = function() {
          const Composition = this._compositions[name2];
          this.type = null;
          return this.append(Composition);
        };
      }
    }
    _reset() {
      const KEYS = ["theme", "type", "width", "height", "autoFit"];
      this.type = "view";
      this.value = Object.fromEntries(Object.entries(this.value).filter(([key]) => key.startsWith("margin") || key.startsWith("padding") || key.startsWith("inset") || KEYS.includes(key)));
      this.children = [];
    }
    _renderTrailing() {
      if (!this._trailing)
        return;
      this._trailing = false;
      this.render().then(() => {
        const trailingResolve = this._trailingResolve.bind(this);
        this._trailingResolve = null;
        trailingResolve(this);
      }).catch((error4) => {
        const trailingReject = this._trailingReject.bind(this);
        this._trailingReject = null;
        trailingReject(error4);
      });
    }
    _createResolve(resolve) {
      return () => {
        this._rendering = false;
        resolve(this);
      };
    }
    _createReject(reject) {
      return (error4) => {
        this._rendering = false;
        reject(error4);
      };
    }
    // Update actual size and key.
    _computedOptions() {
      const options = this.options();
      const { key = G2_CHART_KEY } = options;
      const { width, height, depth } = sizeOf2(options, this._container);
      this._width = width;
      this._height = height;
      this._key = key;
      return Object.assign(Object.assign({ key: this._key }, options), { width, height, depth });
    }
    // Create canvas if it does not exist.
    // DragAndDropPlugin is for interaction.
    // It is OK to register more than one time, G will handle this.
    _createCanvas() {
      const { width, height } = sizeOf2(this.options(), this._container);
      this._plugins.push(new Plugin7());
      this._plugins.forEach((d2) => this._renderer.registerPlugin(d2));
      this._context.canvas = new Canvas({
        container: this._container,
        width,
        height,
        renderer: this._renderer
      });
    }
    _addToTrailing() {
      var _a;
      (_a = this._trailingResolve) === null || _a === void 0 ? void 0 : _a.call(this, this);
      this._trailing = true;
      const promise = new Promise((resolve, reject) => {
        this._trailingResolve = resolve;
        this._trailingReject = reject;
      });
      return promise;
    }
    _bindAutoFit() {
      const options = this.options();
      const { autoFit } = options;
      if (this._hasBindAutoFit) {
        if (!autoFit)
          this._unbindAutoFit();
        return;
      }
      if (autoFit) {
        this._hasBindAutoFit = true;
        window.addEventListener("resize", this._onResize);
      }
    }
    _unbindAutoFit() {
      if (this._hasBindAutoFit) {
        this._hasBindAutoFit = false;
        window.removeEventListener("resize", this._onResize);
      }
    }
  };

  // ../../engine/rails_design/node_modules/@antv/g2/esm/index.js
  var library2 = Object.assign({}, stdlib());
  var Chart = extend6(Runtime, library2);

  // ../../engine/rails_design/app/javascripts/stimulus_antv/antv-line.js
  var antv_line_default = class extends Controller {
    static values = {
      url: String
    };
    connect() {
      this.chart = new Chart({
        container: this.element,
        autoFit: true
      });
      this.chart.options({
        data: {
          type: "fetch",
          value: this.urlValue,
          format: "json"
        },
        encode: {
          x: "year",
          y: "value"
        }
      });
      this.chart.axis("y", { labelFormatter: (v) => `${v}`.replace(/\d{1,3}(?=(\d{3})+$)/g, (s2) => `${s2},`) });
      this.chart.line().encode("shape", "smooth");
      this.chart.point().encode("shape", "point").tooltip(false);
      this.chart.render();
    }
    disconnect() {
      this.chart.destroy();
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_antv/index.js
  application.register("antv-line", antv_line_default);

  // ../../engine/rails_design/app/javascripts/stimulus_bulma/bulma-menu.js
  var bulma_menu_default = class extends Controller {
    static values = {
      openClass: String,
      closeClass: String
    };
    toggle() {
      this.element.classList.toggle("is-active");
    }
    enter(event) {
      const ele = event.currentTarget;
      Array.from(ele.parentNode.children).filter((el) => el.classList.contains("is-active")).forEach((i) => {
        i.classList.remove("is-active");
      });
      ele.classList.add("is-active");
    }
    expand(event) {
      let expander = event.currentTarget;
      if (expander.nextElementSibling !== null) {
        expander.nextElementSibling.classList.toggle("display-none");
      }
      if (expander.lastElementChild !== null) {
        expander.lastElementChild.classList.toggle(this.closeClass);
        expander.lastElementChild.classList.toggle(this.openClass);
      }
    }
    get closeClass() {
      return this.openClassValue || "fa-angle-left";
    }
    get openClass() {
      return this.closeClassValue || "fa-angle-down";
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_bulma/bulma-modal.js
  var I18N = {
    zh: "\u5DF2\u6539\u53D8\uFF0C\u786E\u8BA4\u5173\u95ED\uFF1F",
    en: " is changed, Are You Sure?"
  };
  var bulma_modal_default = class extends base_controller_default {
    connect() {
      document.documentElement.classList.add("clipped");
    }
    close() {
      if (this.closeCheck()) {
        this.element.remove();
      }
    }
    hide() {
      if (this.closeCheck()) {
        this.element.classList.remove("is-active");
        document.documentElement.classList.remove("clipped");
      }
    }
    show() {
      this.element.classList.add("is-active");
    }
    toggle() {
      if (this.element.classList.contains("is-active")) {
        this.close();
      } else {
        this.show();
      }
    }
    disconnect() {
      document.documentElement.classList.remove("clipped");
    }
    // 关闭前检查下有没有未提交的表单
    closeCheck() {
      let arr = [];
      Array.from(this.element.getElementsByTagName("input")).forEach((el) => {
        if (el.value !== el.defaultValue && el.labels[0]) {
          arr.push(el.labels[0].innerText);
        }
      });
      return arr.length === 0 || confirm(`${arr.join(",")}${I18N[this.locale]}`);
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_bulma/bulma-navbar.js
  var bulma_navbar_default = class extends Controller {
    static targets = ["menu", "old", "new"];
    static classes = ["old", "new"];
    static values = {
      scroll: Boolean
    };
    connect() {
      this.scrollLook();
    }
    scrollLook() {
      let scrollEle, scrollEvent;
      if (this.element.parentNode === document.body) {
        scrollEle = document.documentElement;
        scrollEvent = document;
      } else {
        scrollEle = this.element.parentNode;
        scrollEvent = scrollEle;
      }
      if (this.scrollValue) {
        scrollEvent.addEventListener("scroll", () => {
          if (scrollEle.scrollTop > 0) {
            this.element.classList.replace(this.oldClass, this.newClass);
            this.oldTargets.forEach((el) => {
              el.classList.add("display-none");
            });
            this.newTargets.forEach((el) => {
              el.classList.remove("display-none");
            });
          } else {
            this.element.classList.replace(this.newClass, this.oldClass);
            this.newTargets.forEach((el) => {
              el.classList.add("display-none");
            });
            this.oldTargets.forEach((el) => {
              el.classList.remove("display-none");
            });
          }
        });
      }
    }
    toggle(element) {
      element.currentTarget.classList.toggle("is-active");
      this.menuTarget.classList.toggle("is-active");
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_bulma/bulma-skeleton.js
  var bulma_skeleton_default = class extends Controller {
    appear(event) {
      const ele = event.currentTarget;
      ele.parentNode.classList.remove("is-skeleton");
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_bulma/index.js
  application.register("menu", bulma_menu_default);
  application.register("modal", bulma_modal_default);
  application.register("navbar", bulma_navbar_default);
  application.register("skeleton", bulma_skeleton_default);

  // ../../engine/rails_design/app/javascripts/stimulus_form/check.js
  var check_default = class extends Controller {
    static outlets = ["form"];
    static targets = ["all", "total"];
    static values = {
      container: String,
      range: String
    };
    connect() {
      for (const ingredient of this.checkboxes) {
        if (ingredient.dataset.all) {
          ingredient.dataset.all = ingredient.dataset.all.concat(`, #${this.element.id}`);
        } else {
          ingredient.dataset.all = `#${this.element.id}`;
        }
        ingredient.addEventListener("change", this.updateDisplay);
      }
    }
    // checkbox data-action="check#toggleAll"
    toggleAll(event) {
      const element = event.currentTarget;
      for (const checkbox of this.checkboxes) {
        if (!checkbox.disabled) {
          checkbox.checked = element.checked;
          checkbox.dispatchEvent(new Event("input"));
          const all = checkbox.dataset.all.split(", ").filter((el) => el !== `#${this.element.id}`).join(", ");
          if (all) {
            console.debug(all);
            const cons = document.querySelectorAll(all);
            cons.forEach((ele) => {
              const con = ele.getController("check");
              con.computeDisplay();
            });
          }
        }
      }
      if (element.checked) {
        this.showCommits(this.checkboxes);
      } else {
        this.hiddenCommits();
      }
    }
    showCommits(ids) {
      this.formOutlets.forEach((el) => {
        if (ids.length > 0) {
          if (el.hasSubmitTarget) {
            el.submitTarget.disabled = false;
          }
          if (el.hasIdsTarget) {
            el.idsTarget.value = ids;
          }
        }
      });
      if (this.hasTotalTarget) {
        this.totalTarget.innerText = `${ids.length} Selected`;
      }
    }
    hiddenCommits() {
      this.formOutlets.forEach((el) => {
        if (el.hasSubmitTarget) {
          el.submitTarget.disabled = true;
        }
        if (el.hasIdsTarget) {
          el.idsTarget.value = "";
        }
      });
      if (this.hasTotalTarget) {
        this.totalTarget.innerText = "";
      }
    }
    // NOTICE: this become event
    updateDisplay(event) {
      const cons = document.querySelectorAll(event.currentTarget.dataset.all);
      cons.forEach((ele) => {
        const con = ele.getController("check");
        con.computeDisplay();
      });
    }
    computeDisplay() {
      let checkedCount = 0;
      const ids = [];
      const overall = this.allTarget;
      for (const ingredient of this.checkboxes) {
        if (ingredient.checked) {
          checkedCount++;
          ids.push(ingredient.value);
        }
      }
      if (checkedCount === 0) {
        overall.checked = false;
        overall.indeterminate = false;
        this.hiddenCommits();
      } else if (checkedCount === this.checkboxes.length) {
        overall.checked = true;
        overall.indeterminate = false;
        this.showCommits(ids);
      } else {
        overall.checked = false;
        overall.indeterminate = true;
        this.showCommits(ids);
      }
    }
    get checkboxes() {
      if (this.hasContainerValue) {
        const container = document.getElementById(this.containerValue);
        return container.querySelectorAll(`input[type=checkbox][name^='${this.allTarget.value}']`);
      } else if (this.hasRangeValue) {
        return document.querySelectorAll(`[id^=${this.rangeValue}] input[type=checkbox][name^='${this.allTarget.value}']`);
      } else {
        return document.querySelectorAll(`input[type=checkbox][name^='${this.allTarget.value}']`);
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/coeff.js
  var coeff_default = class extends Controller {
    static targets = ["quantity", "total", "single"];
    updateSingle(event) {
      const single = event.currentTarget;
      let quantity = this.quantityTarget;
      let result = (single.value * quantity.value).toFixed(2);
      if (this.hasTotalTarget) {
        this.totalTarget.value = result;
      }
    }
    updateQuantity(event) {
      let quantity = event.currentTarget;
      let single = this.singleTarget;
      let result = (single.value * quantity.value).toFixed(2);
      if (this.hasTotalTarget) {
        this.totalTarget.value = result;
      }
    }
    updateTotal(event) {
      let total = event.currentTarget;
      let quantity = this.quantityTarget;
      let result = (total.value / quantity.value).toFixed(2);
      if (this.hasSingleTarget) {
        this.singleTarget.value = result;
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/color-range.js
  var color_range_default = class extends Controller {
    static targets = ["hue", "saturation", "lightness"];
    static values = {
      id: String
    };
    // data-action="click->field#add"
    hue() {
      this.changeAll();
    }
    saturation() {
      this.changeAll();
    }
    lightness() {
      this.changeAll();
    }
    changeAll() {
      const color2 = `hsl(${this.hueTarget.value}, ${this.saturationTarget.value}%, ${this.lightnessTarget.value}%)`;
      const darker2 = (this.lightnessTarget.value * 0.8).toFixed();
      const colorDarker = `hsl(${this.hueTarget.value}, ${this.saturationTarget.value}%, ${darker2}%)`;
      this.saturationTarget.setAttribute("style", `background-image: linear-gradient(to right, hsl(${this.hueTarget.value}, 0%, ${this.lightnessTarget.value}%), hsl(${this.hueTarget.value}, 50%, ${this.lightnessTarget.value}%), hsl(${this.hueTarget.value}, 100%, ${this.lightnessTarget.value}%))`);
      this.lightnessTarget.setAttribute("style", `background-image: linear-gradient(to right, hsl(${this.hueTarget.value}, ${this.saturationTarget.value}%, 0%), hsl(${this.hueTarget.value}, ${this.saturationTarget.value}%, 50%), hsl(${this.hueTarget.value}, ${this.saturationTarget.value}%, 100%))`);
      document.getElementById(this.idValue).setAttribute("style", `--admin-menu: ${color2}; --admin-menu-darker: ${colorDarker}`);
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/enter.js
  var enter_default = class extends Controller {
    static targets = ["input"];
    static values = {
      index: Number,
      label: Boolean
    };
    // data-action="click->field#add"
    open() {
      this.element.querySelectorAll("input").forEach((el) => {
        el.disabled = false;
      });
    }
    close() {
      this.element.querySelectorAll("input").forEach((el) => {
        el.disabled = true;
      });
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/equal.js
  var equal_default = class extends Controller {
    static targets = ["goal"];
    static values = {
      plus: Object
    };
    update(event) {
      const ele = event.currentTarget;
      if (parseFloat(ele.value) > parseFloat(this.goalTarget.value)) {
        this.goalTarget.value = ele.value;
      }
    }
    updateTime(event) {
      const ele = event.currentTarget;
      const dt = DateTime.fromISO(ele.value).plus(this.plusValue).toFormat("yyyy-MM-dd'T'HH:mm:ss");
      if (this.goalTarget.value === this.goalTarget.defaultValue) {
        this.goalTarget.value = dt;
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/former.js
  var former_default = class extends base_controller_default {
    static values = {
      id: String,
      url: String
    };
    submit() {
      const ele = document.getElementById(this.idValue);
      this.formPost(ele);
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/indeterminate.js
  var indeterminate_default = class extends Controller {
    static values = {
      partial: { type: Boolean, default: false }
    };
    connect() {
      if (this.partialValue) {
        this.element.indeterminate = true;
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/form.js
  var I18N2 = {
    zh: {
      badInput: "{label}\u683C\u5F0F\u4E0D\u6B63\u786E",
      customError: "{label}\u8F93\u5165\u9519\u8BEF",
      patternMismatch: "{label}\u4E0D\u7B26\u5408\u683C\u5F0F\u8981\u6C42",
      rangeOverflow: "{label}\u8D85\u51FA\u5141\u8BB8\u7684\u6700\u5927\u503C",
      rangeUnderflow: "{label}\u4F4E\u4E8E\u5141\u8BB8\u7684\u6700\u5C0F\u503C",
      stepMismatch: "{label}\u8F93\u5165\u9519\u8BEF",
      tooLong: "{label}\u592A\u957F\u4E86",
      tooShort: "{label}\u592A\u77ED\u4E86",
      typeMismatch: "{label}\u8F93\u5165\u9519\u8BEF",
      valid: "{label}\u4E3A\u975E\u6CD5\u503C",
      valueMissing: "\u8BF7\u8F93\u5165{label}"
    },
    en: {
      badInput: "Bad Input: {label}",
      customError: "Custom Error: {label}",
      patternMismatch: "Invalid Input: {label}",
      rangeOverflow: "Range Over Flow: {label}",
      rangeUnderflow: "Range Under Flow: {label}",
      stepMismatch: "Step Mismatch",
      tooLong: "{label} is too long",
      tooShort: "{label} is Too Short",
      typeMismatch: "{label} Type Mismatch",
      valid: "{label} is not valid",
      valueMissing: "Please enter: {label}"
    }
  };
  var form_default = class extends base_controller_default {
    static targets = ["ids", "submit"];
    static values = {
      css: { type: String, default: "is-danger" }
    };
    connect() {
      this.setMinLength();
    }
    defaultValid(input) {
      let label, word2;
      for (let key in input.validity) {
        if (input.validity[key]) {
          word2 = I18N2[this.locale][key];
        }
      }
      if (input.labels.length > 0) {
        label = input.labels[0].innerText;
      } else {
        label = input.dataset["label"] || "";
      }
      const text = word2.replace("{label}", label);
      input.classList.add(this.cssValue);
      if (!input.parentNode.nextElementSibling) {
        const help = document.createElement("p");
        help.classList.add("help", this.cssValue);
        help.innerText = text;
        input.parentNode.after(help);
      }
    }
    defaultClear(input) {
      if (input.validity.valid) {
        input.classList.remove(this.cssValue);
        let help = input.parentNode.nextElementSibling;
        if (help && help.classList.contains("help") && help.classList.contains(this.cssValue)) {
          help.remove();
        }
      }
    }
    // data-action="blur->default_valid#check"
    check(event) {
      event.currentTarget.checkValidity();
    }
    // data-action="input->default_valid#clear"
    clear(event) {
      this.defaultClear(event.currentTarget);
    }
    // data-action="invalid->default_valid#notice"
    notice(event) {
      event.preventDefault();
      this.defaultValid(event.currentTarget);
    }
    // data-action="change->form#xx"
    tip(event) {
      const ele = event.currentTarget;
      if (ele.defaultValue !== ele.value) {
        ele.classList.add("is-warning");
      } else {
        ele.classList.remove("is-warning");
      }
    }
    // form[method="get"]
    // submit->xx
    filter(event) {
      const ele = event.currentTarget;
      for (let el of ele.form.elements) {
        if (el.value) {
        } else {
          el.disabled = true;
        }
      }
    }
    focusEnd(event) {
      const ele = event.currentTarget;
      if (ele.type === "text") {
        ele.setSelectionRange(0, ele.value.length);
      }
    }
    setMinLength() {
      const labels = Array.from(this.element.querySelectorAll(".field-label > label.label"));
      const lengths = labels.map((i) => i.innerText.length);
      const max10 = Math.max.apply(null, lengths);
      Array.from(this.element.getElementsByClassName("field-label")).forEach((i) => {
        i.style.minWidth = `${max10}ch`;
      });
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/input.js
  var input_default = class extends base_controller_default {
    static targets = ["checkbox"];
    static values = {
      force: Boolean
    };
    // <label data-action="click->input#check"></label>
    // label out of check
    check() {
      if (this.hasCheckboxTarget) {
        this.checkboxTarget.checked = !this.checkboxTarget.checked;
        this.checkboxTarget.form.requestSubmit();
      }
    }
    // label wrap input
    toggle() {
      if (this.hasCheckboxTarget) {
        const form = new FormData(this.checkboxTarget.form);
        form.append("checked", this.checkboxTarget.checked);
        this.request(this.checkboxTarget.form.action, this.checkboxTarget.form.method, form);
      }
    }
    link(event) {
      const ele = event.currentTarget;
      this.inputGet(ele);
    }
    form(event) {
      const el = event.currentTarget;
      if (el.value.length > 0 || this.forceValue) {
        el.form.requestSubmit();
      }
    }
    filter(event) {
      const ele = event.currentTarget;
      if (!ele.value) {
        return;
      }
      ele.form.requestSubmit();
    }
    remove() {
      this.element.remove();
    }
    // focus->form#blank
    blank(event) {
      const ele = event.currentTarget;
      ele.lastValue = ele.value;
      ele.value = "";
      ele.addEventListener("blur", this.restoreLastValue, { once: true });
    }
    restoreLastValue(event) {
      const ele = event.currentTarget;
      if (isNaN(ele.valueAsNumber)) {
        ele.value = ele.lastValue;
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/keyboard.js
  var keyboard_default = class extends Controller {
    static targets = ["submit"];
    static values = {
      id: String,
      dot: String,
      digit: Number
    };
    enter(event) {
      const element = event.currentTarget;
      let value2;
      if (this.dotElement.hidden) {
        value2 = this.input.value.concat(element.innerText);
      } else {
        value2 = this.input.value.concat(".", element.innerText);
        this.dotElement.hidden = true;
      }
      if (this.hasDigitValue) {
        if (value2.includes(".")) {
          let [left2, right2] = value2.split(".");
          if (right2.length > this.digitValue) {
            this.input.value = [left2, right2.slice(0, this.digitValue)].join(".");
          } else {
            this.input.value = value2;
          }
        } else {
          this.input.value = value2;
        }
      } else {
        this.input.value = value2;
      }
      if (this.input.valueAsNumber > 0) {
        this.submitTarget.disabled = false;
      }
      this.input.dispatchEvent(new Event("input"));
    }
    zeroEnter(event) {
      this.enter(event);
    }
    dot() {
      if (this.input.value.includes(".")) {
      } else if (this.input.value === "") {
        this.input.value = "0";
        this.dotElement.hidden = false;
      } else {
        this.dotElement.hidden = false;
      }
    }
    backspace() {
      this.input.value = this.input.value.slice(0, -1);
      if (this.input.value === "") {
        this.dotElement.hidden = true;
      }
    }
    get input() {
      return document.getElementById(this.idValue);
    }
    get dotElement() {
      return document.getElementById(this.dotValue);
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/modify.js
  var modify_default = class extends Controller {
    static targets = ["input"];
    static values = {
      step: { type: Number, default: 1 },
      submit: { type: Boolean, default: false },
      total: Number,
      quantity: String
    };
    plus() {
      this.inputTarget.value = Number(parseFloat(this.inputTarget.value || 0) + this.step).toFixed(this.digit);
      this.inputTarget.dispatchEvent(new Event("change"));
      if (this.submitValue) {
        this.inputTarget.form.requestSubmit();
      }
      if (this.hasQuantityValue) {
        this.doDivide(this.inputTarget.value);
      }
    }
    minus() {
      if (this.inputTarget.value >= this.step) {
        this.inputTarget.value = Number(parseFloat(this.inputTarget.value || 0) - this.step).toFixed(this.digit);
        this.inputTarget.dispatchEvent(new Event("change"));
        if (this.submitValue) {
          this.inputTarget.form.requestSubmit();
        }
        if (this.hasQuantityValue) {
          this.doDivide(this.inputTarget.value);
        }
      }
    }
    divide(event) {
      this.doDivide(event.currentTarget.value);
    }
    doDivide(value2) {
      if (value2 !== 0) {
        this.quantity.innerText = Math.floor(this.totalValue / value2);
      }
    }
    get quantity() {
      return document.getElementById(this.quantityValue);
    }
    get step() {
      if (this.hasStepValue) {
        return this.stepValue;
      } else {
        return parseFloat(this.inputTarget.step);
      }
    }
    get digit() {
      return String(this.step).split(".")[1]?.length || 0;
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/picker.js
  var picker_default = class extends base_controller_default {
    static values = {
      id: String,
      input: String
    };
    static outlets = ["modal"];
    confirmValue() {
      const input = document.getElementById(this.idValue);
      input.value = this.inputValue;
      this.modalOutletElement.remove();
    }
    clear(node) {
      let el = node.nextElementSibling;
      while (el) {
        el.remove();
        el = node.nextElementSibling;
      }
    }
  };

  // ../../engine/rails_design/node_modules/@rails/activestorage/src/file_checksum.js
  var import_spark_md5 = __toESM(require_spark_md5());
  var fileSlice = File.prototype.slice || File.prototype.mozSlice || File.prototype.webkitSlice;
  var FileChecksum = class _FileChecksum {
    static create(file, callback) {
      const instance = new _FileChecksum(file);
      instance.create(callback);
    }
    constructor(file) {
      this.file = file;
      this.chunkSize = 2097152;
      this.chunkCount = Math.ceil(this.file.size / this.chunkSize);
      this.chunkIndex = 0;
    }
    create(callback) {
      this.callback = callback;
      this.md5Buffer = new import_spark_md5.default.ArrayBuffer();
      this.fileReader = new FileReader();
      this.fileReader.addEventListener("load", (event) => this.fileReaderDidLoad(event));
      this.fileReader.addEventListener("error", (event) => this.fileReaderDidError(event));
      this.readNextChunk();
    }
    fileReaderDidLoad(event) {
      this.md5Buffer.append(event.target.result);
      if (!this.readNextChunk()) {
        const binaryDigest = this.md5Buffer.end(true);
        const base64digest = btoa(binaryDigest);
        this.callback(null, base64digest);
      }
    }
    fileReaderDidError(event) {
      this.callback(`Error reading ${this.file.name}`);
    }
    readNextChunk() {
      if (this.chunkIndex < this.chunkCount || this.chunkIndex == 0 && this.chunkCount == 0) {
        const start2 = this.chunkIndex * this.chunkSize;
        const end = Math.min(start2 + this.chunkSize, this.file.size);
        const bytes = fileSlice.call(this.file, start2, end);
        this.fileReader.readAsArrayBuffer(bytes);
        this.chunkIndex++;
        return true;
      } else {
        return false;
      }
    }
  };

  // ../../engine/rails_design/node_modules/@rails/activestorage/src/helpers.js
  function getMetaValue(name2) {
    const element = findElement(document.head, `meta[name="${name2}"]`);
    if (element) {
      return element.getAttribute("content");
    }
  }
  function findElement(root2, selector) {
    if (typeof root2 == "string") {
      selector = root2;
      root2 = document;
    }
    return root2.querySelector(selector);
  }
  function dispatchEvent3(element, type, eventInit = {}) {
    const { disabled } = element;
    const { bubbles, cancelable, detail } = eventInit;
    const event = document.createEvent("Event");
    event.initEvent(type, bubbles || true, cancelable || true);
    event.detail = detail || {};
    try {
      element.disabled = false;
      element.dispatchEvent(event);
    } finally {
      element.disabled = disabled;
    }
    return event;
  }

  // ../../engine/rails_design/node_modules/@rails/activestorage/src/blob_record.js
  var BlobRecord = class {
    constructor(file, checksum, url, customHeaders = {}) {
      this.file = file;
      this.attributes = {
        filename: file.name,
        content_type: file.type || "application/octet-stream",
        byte_size: file.size,
        checksum
      };
      this.xhr = new XMLHttpRequest();
      this.xhr.open("POST", url, true);
      this.xhr.responseType = "json";
      this.xhr.setRequestHeader("Content-Type", "application/json");
      this.xhr.setRequestHeader("Accept", "application/json");
      this.xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
      Object.keys(customHeaders).forEach((headerKey) => {
        this.xhr.setRequestHeader(headerKey, customHeaders[headerKey]);
      });
      const csrfToken = getMetaValue("csrf-token");
      if (csrfToken != void 0) {
        this.xhr.setRequestHeader("X-CSRF-Token", csrfToken);
      }
      this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
      this.xhr.addEventListener("error", (event) => this.requestDidError(event));
    }
    get status() {
      return this.xhr.status;
    }
    get response() {
      const { responseType, response } = this.xhr;
      if (responseType == "json") {
        return response;
      } else {
        return JSON.parse(response);
      }
    }
    create(callback) {
      this.callback = callback;
      this.xhr.send(JSON.stringify({ blob: this.attributes }));
    }
    requestDidLoad(event) {
      if (this.status >= 200 && this.status < 300) {
        const { response } = this;
        const { direct_upload } = response;
        delete response.direct_upload;
        this.attributes = response;
        this.directUploadData = direct_upload;
        this.callback(null, this.toJSON());
      } else {
        this.requestDidError(event);
      }
    }
    requestDidError(event) {
      this.callback(`Error creating Blob for "${this.file.name}". Status: ${this.status}`);
    }
    toJSON() {
      const result = {};
      for (const key in this.attributes) {
        result[key] = this.attributes[key];
      }
      return result;
    }
  };

  // ../../engine/rails_design/node_modules/@rails/activestorage/src/blob_upload.js
  var BlobUpload = class {
    constructor(blob) {
      this.blob = blob;
      this.file = blob.file;
      const { url, headers } = blob.directUploadData;
      this.xhr = new XMLHttpRequest();
      this.xhr.open("PUT", url, true);
      this.xhr.responseType = "text";
      for (const key in headers) {
        this.xhr.setRequestHeader(key, headers[key]);
      }
      this.xhr.addEventListener("load", (event) => this.requestDidLoad(event));
      this.xhr.addEventListener("error", (event) => this.requestDidError(event));
    }
    create(callback) {
      this.callback = callback;
      this.xhr.send(this.file.slice());
    }
    requestDidLoad(event) {
      const { status, response } = this.xhr;
      if (status >= 200 && status < 300) {
        this.callback(null, response);
      } else {
        this.requestDidError(event);
      }
    }
    requestDidError(event) {
      this.callback(`Error storing "${this.file.name}". Status: ${this.xhr.status}`);
    }
  };

  // ../../engine/rails_design/node_modules/@rails/activestorage/src/direct_upload.js
  var id3 = 0;
  var DirectUpload = class {
    constructor(file, url, delegate, customHeaders = {}) {
      this.id = ++id3;
      this.file = file;
      this.url = url;
      this.delegate = delegate;
      this.customHeaders = customHeaders;
    }
    create(callback) {
      FileChecksum.create(this.file, (error4, checksum) => {
        if (error4) {
          callback(error4);
          return;
        }
        const blob = new BlobRecord(this.file, checksum, this.url, this.customHeaders);
        notify(this.delegate, "directUploadWillCreateBlobWithXHR", blob.xhr);
        blob.create((error5) => {
          if (error5) {
            callback(error5);
          } else {
            const upload = new BlobUpload(blob);
            notify(this.delegate, "directUploadWillStoreFileWithXHR", upload.xhr);
            upload.create((error6) => {
              if (error6) {
                callback(error6);
              } else {
                callback(null, blob.toJSON());
              }
            });
          }
        });
      });
    }
  };
  function notify(object, methodName, ...messages) {
    if (object && typeof object[methodName] == "function") {
      return object[methodName](...messages);
    }
  }

  // ../../engine/rails_design/node_modules/@rails/activestorage/src/direct_upload_controller.js
  var DirectUploadController = class {
    constructor(input, file) {
      this.input = input;
      this.file = file;
      this.directUpload = new DirectUpload(this.file, this.url, this);
      this.dispatch("initialize");
    }
    start(callback) {
      const hiddenInput = document.createElement("input");
      hiddenInput.type = "hidden";
      hiddenInput.name = this.input.name;
      this.input.insertAdjacentElement("beforebegin", hiddenInput);
      this.dispatch("start");
      this.directUpload.create((error4, attributes) => {
        if (error4) {
          hiddenInput.parentNode.removeChild(hiddenInput);
          this.dispatchError(error4);
        } else {
          hiddenInput.value = attributes.signed_id;
        }
        this.dispatch("end");
        callback(error4);
      });
    }
    uploadRequestDidProgress(event) {
      const progress = event.loaded / event.total * 100;
      if (progress) {
        this.dispatch("progress", { progress });
      }
    }
    get url() {
      return this.input.getAttribute("data-direct-upload-url");
    }
    dispatch(name2, detail = {}) {
      detail.file = this.file;
      detail.id = this.directUpload.id;
      return dispatchEvent3(this.input, `direct-upload:${name2}`, { detail });
    }
    dispatchError(error4) {
      const event = this.dispatch("error", { error: error4 });
      if (!event.defaultPrevented) {
        alert(error4);
      }
    }
    // DirectUpload delegate
    directUploadWillCreateBlobWithXHR(xhr) {
      this.dispatch("before-blob-request", { xhr });
    }
    directUploadWillStoreFileWithXHR(xhr) {
      this.dispatch("before-storage-request", { xhr });
      xhr.upload.addEventListener("progress", (event) => this.uploadRequestDidProgress(event));
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/picture.js
  var picture_default = class extends Controller {
    static targets = ["src", "filename", "preview", "uploadDiv"];
    //<input type="file" data-action="picture#upload">
    upload(event) {
      const input = event.currentTarget;
      const button2 = input.form.querySelector("input[type=submit], button[type=submit]");
      input.disabled = true;
      button2.disabled = true;
      Array.from(input.files).forEach((file) => {
        this.filenameTarget.innerText = file.name;
        this.previewFile(file);
        let controller = new DirectUploadController(input, file);
        controller.start((error4) => {
          console.error("upload,er", error4);
          input.disabled = false;
          button2.disabled = false;
        });
      });
      input.value = null;
    }
    dropFile(event) {
      event.preventDefault();
      event.stopPropagation();
      for (var i = 0; i < event.dataTransfer.files.length; i++) {
        var file = e.dataTransfer.files[i];
        console.debug("drop\u6587\u4EF6", file.name);
      }
    }
    pasteFile(event) {
      const result = false;
      const clipboardData = event.clipboardData;
      let items;
      if (typeof clipboardData === "object") {
        items = clipboardData.items || clipboardData.files || [];
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          console.debug("\u7C98\u8D34", item);
        }
      }
      if (result) {
        event.preventDefault();
      }
    }
    previewFile(file) {
      const template = this.previewTarget;
      const cloned = template.cloneNode(true);
      cloned.style.display = "block";
      let img = cloned.querySelector("img");
      img.src = window.URL.createObjectURL(file);
      img.onload = function(e3) {
        console.debug(e3);
        window.URL.revokeObjectURL(img.src);
      };
      template.after(cloned);
    }
    removePreview(event) {
      const wrap = event.currentTarget.parentNode.parentNode;
      wrap.style.display = "none";
      wrap.querySelector("input").remove();
      const up = this.uploadDivTarget;
      const input = up.querySelector("input[type=file]");
      up.style.display = "block";
      input.disabled = false;
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/qq-map.js
  var qq_map_default = class extends Controller {
    static values = {
      name: String,
      index: Number,
      key: String
    };
    static targets = ["load"];
    connect() {
      const center2 = new TMap.LatLng(39.98412, 116.307484);
      this.map = new TMap.Map(this.element, {
        center: center2,
        zoom: 17.2
      });
    }
    selected(event) {
      this.doSelected(event);
    }
    select(event) {
      this.doSelected(event);
    }
    doSelected(event) {
      console.log("selected", event);
      const loc = event.data;
      if (loc && loc.module === "locationPicker") {
        if (this.hasIndexValue) {
          document.getElementById(`${this.nameValue}_${this.indexValue}_lat`).value = loc.latlng.lat;
          document.getElementById(`${this.nameValue}_${this.indexValue}_lng`).value = loc.latlng.lng;
          document.getElementById(`${this.nameValue}_${this.indexValue}_poiname`).value = loc.poiname;
          document.getElementById(`${this.nameValue}_${this.indexValue}_poiaddress`).value = loc.poiaddress;
          document.getElementById(`${this.nameValue}_${this.indexValue}_cityname`).value = loc.cityname;
          document.getElementById(`${this.indexValue}_name`).innerText = loc.poiname;
        } else {
          document.getElementById(`${this.nameValue}_lat`).value = loc.latlng.lat;
          document.getElementById(`${this.nameValue}_lng`).value = loc.latlng.lng;
          document.getElementById(`${this.nameValue}_poiname`).value = loc.poiname;
          document.getElementById(`${this.nameValue}_poiaddress`).value = loc.poiaddress;
          document.getElementById(`${this.nameValue}_cityname`).value = loc.cityname;
        }
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/search-input.js
  var search_input_default = class extends base_controller_default {
    static targets = ["input", "content"];
    static values = {
      url: String
    };
    connect() {
      this.initInput();
    }
    initInput() {
      const ele = this.inputTarget;
      ele.addEventListener("input", this.form);
      ele.addEventListener("compositionstart", (event) => {
        event.target.removeEventListener("input", this.form);
      });
      ele.addEventListener("compositionend", (event) => {
        event.target.addEventListener("input", this.form);
        this.conForm(ele);
      });
    }
    // NOTICE  here this becomes ele, who call addEventListener
    form() {
      const con = this.closest("[data-controller~=search-input]").getController("search-input");
      if (con.hasUrlValue) {
        con.inputPost(this);
      } else {
        this.form.requestSubmit();
      }
    }
    conForm(ele) {
      if (this.hasUrlValue) {
        this.inputPost(ele);
      } else {
        ele.form.requestSubmit();
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/taxon.js
  var taxon_default = class extends base_controller_default {
    static values = {
      url: String,
      title: String,
      params: Object
    };
    // change
    choose(event) {
      let ele = event.currentTarget;
      if (ele.value === "" || ele.value === null) {
        this.clear(this.element);
      } else {
        let search_url = new URL(this.urlValue, location.origin);
        search_url.searchParams.set("node_id", ele.value);
        search_url.searchParams.set("html_id", this.element.id);
        Object.keys(this.paramsValue).forEach((k) => {
          search_url.searchParams.set(k, this.paramsValue[k]);
        });
        fetch(search_url, {
          method: "GET",
          headers: {
            Accept: "text/vnd.turbo-stream.html"
          }
        }).then((response) => {
          return response.text();
        }).then((body) => {
          this.clear(this.element);
          Turbo.renderStreamMessage(body);
        });
      }
    }
    clear(node) {
      let el = node.nextElementSibling;
      while (el && el.dataset["taxonTitleValue"] === this.titleValue) {
        el.remove();
        el = node.nextElementSibling;
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/time-range.js
  var time_range_default = class extends Controller {
    static targets = ["start", "finish"];
    // action
    time(event) {
      const el = event.currentTarget;
      const start2 = el.dataset.startAt;
      const finish = el.dataset.finishAt;
      this.startTarget.value = start2;
      this.finishTarget.value = finish;
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/total.js
  var total_default = class extends Controller {
    static targets = ["reduce", "total"];
    updateReduce(event) {
      const reduce2 = event.currentTarget;
      if (this.hasTotalTarget) {
        this.totalTarget.value = (parseFloat(this.totalTarget.defaultValue) + parseFloat(reduce2.value) - parseFloat(reduce2.defaultValue)).toFixed(2);
      }
    }
    updateTotal(event) {
      let total = event.currentTarget;
      if (this.hasReduceTarget) {
        this.reduceTarget.value = (parseFloat(this.reduceTarget.defaultValue) + parseFloat(total.value) - parseFloat(total.defaultValue)).toFixed(2);
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/typer.js
  var typer_default = class extends base_controller_default {
    static targets = ["input", "value", "content"];
    static values = {
      url: String
    };
    connect() {
      this.initInput();
    }
    initInput() {
      const ele = this.inputTarget;
      ele.addEventListener("input", this.form);
      ele.addEventListener("compositionstart", (event) => {
        event.target.removeEventListener("input", this.form);
      });
      ele.addEventListener("compositionend", (event) => {
        event.target.addEventListener("input", this.form);
        this.conForm(ele);
      });
    }
    // NOTICE  here this becomes ele, who call addEventListener
    form() {
      const con = this.closest("[data-controller~=typer]").getController("typer");
      if (con.hasValueTarget) {
        con.valueTarget.removeAttribute("value");
        if (!this.value) {
          con.clear();
          return;
        }
      }
      if (con.hasUrlValue) {
        con.inputPost(this);
      } else {
        this.form.requestSubmit();
      }
    }
    conForm(ele) {
      this.valueTarget.removeAttribute("value");
      if (!ele.value) {
        this.clear();
        return;
      }
      if (this.hasUrlValue) {
        this.inputPost(ele);
      } else {
        ele.form.requestSubmit();
      }
    }
    clear() {
      Array.from(this.contentTarget.children).forEach((child) => {
        child.remove();
      });
    }
    // click->typer#choose
    choose(event) {
      const ele = event.currentTarget;
      this.valueTarget.value = ele.dataset["id"];
      this.inputTarget.value = ele.dataset["name"];
      ele.parentNode.replaceChildren();
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/field.js
  var field_default = class extends Controller {
    static targets = ["node"];
    static values = {
      index: Number,
      label: { type: String, default: "label.field_label" }
    };
    // data-action="click->field#add"
    add() {
      const el = this.element.cloneNode(true);
      const label = el.querySelector(this.labelValue);
      if (label) {
        label.innerText = "";
      }
      const next = this.element.nextElementSibling;
      let addIndex;
      if (next) {
        const nextItem = next.getController(this.identifier);
        if (nextItem && nextItem.indexValue > this.indexValue) {
          addIndex = (nextItem.indexValue - this.indexValue) / 2;
        } else {
          addIndex = 1;
        }
      } else {
        addIndex = 1;
      }
      const nextIndex = this.indexValue + addIndex;
      el.setAttribute("data-field-index-value", nextIndex);
      el.querySelectorAll("input, select").forEach((input) => {
        input.name = input.name.replace(`[${this.indexValue}]`, `[${nextIndex}]`);
        if (input.id) {
          input.id = input.id.replace(`${this.indexValue}`, `${nextIndex}`);
        }
        input.value = input.defaultValue;
        input.autofocus = true;
        if (input.type === "text") {
          input.setSelectionRange(0, input.value.length);
        }
      });
      if (this.element.parentNode) {
        this.element.parentNode.insertBefore(el, next);
      }
    }
    remove() {
      this.element.remove();
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/datetime.js
  var datetime_default = class extends Controller {
    // data-action="datetime#default"
    default(event) {
      const el = event.currentTarget;
      const date = new Date(el.value);
      const form = el.form;
      this.append(form, el.name.replace("(date)", "(1i)"), date.getFullYear());
      this.append(form, el.name.replace("(date)", "(2i)"), date.getMonth() + 1);
      this.append(form, el.name.replace("(date)", "(3i)"), date.getDate());
    }
    append(form, name2, value2) {
      let input = form.elements.namedItem(name2);
      if (input) {
        input.setAttribute("value", value2);
      } else {
        input = document.createElement("input");
        input.setAttribute("type", "hidden");
        input.setAttribute("name", name2);
        input.setAttribute("value", value2);
        this.element.appendChild(input);
      }
    }
  };

  // ../../engine/rails_design/app/javascripts/stimulus_form/index.js
  application.register("check", check_default);
  application.register("coeff", coeff_default);
  application.register("color-range", color_range_default);
  application.register("enter", enter_default);
  application.register("equal", equal_default);
  application.register("former", former_default);
  application.register("indeterminate", indeterminate_default);
  application.register("form", form_default);
  application.register("input", input_default);
  application.register("keyboard", keyboard_default);
  application.register("modify", modify_default);
  application.register("picker", picker_default);
  application.register("picture", picture_default);
  application.register("qq-map", qq_map_default);
  application.register("search-input", search_input_default);
  application.register("taxon", taxon_default);
  application.register("time-range", time_range_default);
  application.register("total", total_default);
  application.register("typer", typer_default);
  application.register("field", field_default);
  application.register("datetime", datetime_default);

  // ../../engine/rails_design/app/javascripts/turbo/events.js
  document.addEventListener("turbo:before-fetch-request", (event) => {
    const xhr = event.detail.fetchOptions;
    xhr.headers["Timezone"] = Intl.DateTimeFormat().resolvedOptions().timeZone;
  });

  // ../../engine/rails_design/app/javascripts/turbo/override.js
  Object.defineProperties(customElements.get("turbo-stream").prototype, {
    targetElementsById: {
      get: function() {
        let element;
        if (this.target === "body") {
          element = this.ownerDocument.body;
        } else if (this.target) {
          element = this.ownerDocument.getElementById(this.target);
        }
        if (element !== null) {
          return [element];
        } else {
          return [];
        }
      }
    }
  });

  // ../../engine/rails_design/app/javascripts/rails_design/index.js
  window.Idiomorph = Idiomorph2;

  // ../../engine/rails_design/app/javascripts/channels/session_channel.js
  window.consumer = cable_default2;
  cable_default2.subscriptions.create({ channel: "Com::SessionChannel", room: "room" }, {
    received(data2) {
      const url = data2.url || "/";
      if (data2.auth_token) {
        document.addEventListener("turbo:before-fetch-request", (event) => {
          const xhr = event.detail.fetchOptions;
          xhr.headers["Authorization"] = data2.auth_token;
        });
      }
      Turbo.visit(url);
    },
    connected() {
      console.debug("connected:", this.identifier);
    },
    disconnected() {
      console.debug("disconnected:", this.identifier);
    }
  });

  // ../../engine/rails_design/app/javascripts/channels/notice_channel.js
  cable_default2.subscriptions.create({ channel: "Notice::ReceiverChannel", room: "room" }, {
    received(data2) {
      Turbo.renderStreamMessage(data2);
      document.getElementById("notice_show").classList.add("color-danger");
    },
    connected() {
      console.debug("connected:", this.identifier);
    },
    disconnected() {
      console.debug("disconnected:", this.identifier);
    }
  });

  // app/javascript/application.js
  application.debug = true;
})();
/*! Bundled license information:

choices.js/public/assets/scripts/choices.js:
  (*! choices.js v10.2.0 | © 2022 Josh Johnson | https://github.com/jshjohnson/Choices#readme *)

@hotwired/turbo/dist/turbo.es2017-esm.js:
  (*!
  Turbo 8.0.10
  Copyright © 2024 37signals LLC
   *)

sortablejs/modular/sortable.esm.js:
  (**!
   * Sortable 1.15.2
   * @author	RubaXa   <trash@rubaxa.org>
   * @author	owenm    <owen23355@gmail.com>
   * @license MIT
   *)
*/
//# sourceMappingURL=/assets/application-64ec1e0b.js.map
